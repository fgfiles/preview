this.createjs = this.createjs || {};
(function() { "use strict";
    createjs.proxy = function(method, scope) { var aArgs = Array.prototype.slice.call(arguments, 2); return function() { return method.apply(scope, Array.prototype.slice.call(arguments, 0).concat(aArgs)); }; } }());
this.createjs = this.createjs || {};
(function() {
    "use strict";
    createjs.indexOf = function(array, searchElement) {
        for (var i = 0, l = array.length; i < l; i++) { if (searchElement === array[i]) { return i; } }
        return -1;
    }
}());
this.createjs = this.createjs || {};
(function() { "use strict"; var Event = function(type, bubbles, cancelable) { this.initialize(type, bubbles, cancelable); }; var p = Event.prototype;
    p.type = null;
    p.target = null;
    p.currentTarget = null;
    p.eventPhase = 0;
    p.bubbles = false;
    p.cancelable = false;
    p.timeStamp = 0;
    p.defaultPrevented = false;
    p.propagationStopped = false;
    p.immediatePropagationStopped = false;
    p.removed = false;
    p.initialize = function(type, bubbles, cancelable) { this.type = type;
        this.bubbles = bubbles;
        this.cancelable = cancelable;
        this.timeStamp = (new Date()).getTime(); };
    p.preventDefault = function() { this.defaultPrevented = true; };
    p.stopPropagation = function() { this.propagationStopped = true; };
    p.stopImmediatePropagation = function() { this.immediatePropagationStopped = this.propagationStopped = true; };
    p.remove = function() { this.removed = true; };
    p.clone = function() { return new Event(this.type, this.bubbles, this.cancelable); };
    p.toString = function() { return "[Event (type=" + this.type + ")]"; };
    createjs.Event = Event; }());
this.createjs = this.createjs || {};
(function() {
    "use strict";
    var EventDispatcher = function() {};
    var p = EventDispatcher.prototype;
    EventDispatcher.initialize = function(target) { target.addEventListener = p.addEventListener;
        target.on = p.on;
        target.removeEventListener = target.off = p.removeEventListener;
        target.removeAllEventListeners = p.removeAllEventListeners;
        target.hasEventListener = p.hasEventListener;
        target.dispatchEvent = p.dispatchEvent;
        target._dispatchEvent = p._dispatchEvent; };
    p._listeners = null;
    p._captureListeners = null;
    p.initialize = function() {};
    p.addEventListener = function(type, listener, useCapture) {
        var listeners;
        if (useCapture) { listeners = this._captureListeners = this._captureListeners || {}; } else { listeners = this._listeners = this._listeners || {}; }
        var arr = listeners[type];
        if (arr) { this.removeEventListener(type, listener, useCapture); }
        arr = listeners[type];
        if (!arr) { listeners[type] = [listener]; } else { arr.push(listener); }
        return listener;
    };
    p.on = function(type, listener, scope, once, data, useCapture) {
        if (listener.handleEvent) { scope = scope || listener;
            listener = listener.handleEvent; }
        scope = scope || this;
        return this.addEventListener(type, function(evt) { listener.call(scope, evt, data);
            once && evt.remove(); }, useCapture);
    };
    p.removeEventListener = function(type, listener, useCapture) {
        var listeners = useCapture ? this._captureListeners : this._listeners;
        if (!listeners) { return; }
        var arr = listeners[type];
        if (!arr) { return; }
        for (var i = 0, l = arr.length; i < l; i++) {
            if (arr[i] == listener) {
                if (l == 1) { delete(listeners[type]); } else { arr.splice(i, 1); }
                break;
            }
        }
    };
    p.off = p.removeEventListener;
    p.removeAllEventListeners = function(type) {
        if (!type) { this._listeners = this._captureListeners = null; } else {
            if (this._listeners) { delete(this._listeners[type]); }
            if (this._captureListeners) { delete(this._captureListeners[type]); }
        }
    };
    p.dispatchEvent = function(eventObj, target) {
        if (typeof eventObj == "string") {
            var listeners = this._listeners;
            if (!listeners || !listeners[eventObj]) { return false; }
            eventObj = new createjs.Event(eventObj);
        }
        eventObj.target = target || this;
        if (!eventObj.bubbles || !this.parent) { this._dispatchEvent(eventObj, 2); } else {
            var top = this,
                list = [top];
            while (top.parent) { list.push(top = top.parent); }
            var i, l = list.length;
            for (i = l - 1; i >= 0 && !eventObj.propagationStopped; i--) { list[i]._dispatchEvent(eventObj, 1 + (i == 0)); }
            for (i = 1; i < l && !eventObj.propagationStopped; i++) { list[i]._dispatchEvent(eventObj, 3); }
        }
        return eventObj.defaultPrevented;
    };
    p.hasEventListener = function(type) { var listeners = this._listeners,
            captureListeners = this._captureListeners; return !!((listeners && listeners[type]) || (captureListeners && captureListeners[type])); };
    p.toString = function() { return "[EventDispatcher]"; };
    p._dispatchEvent = function(eventObj, eventPhase) {
        var l, listeners = (eventPhase == 1) ? this._captureListeners : this._listeners;
        if (eventObj && listeners) {
            var arr = listeners[eventObj.type];
            if (!arr || !(l = arr.length)) { return; }
            eventObj.currentTarget = this;
            eventObj.eventPhase = eventPhase;
            eventObj.removed = false;
            arr = arr.slice();
            for (var i = 0; i < l && !eventObj.immediatePropagationStopped; i++) {
                var o = arr[i];
                if (o.handleEvent) { o.handleEvent(eventObj); } else { o(eventObj); }
                if (eventObj.removed) { this.off(eventObj.type, o, eventPhase == 1);
                    eventObj.removed = false; }
            }
        }
    };
    createjs.EventDispatcher = EventDispatcher;
}());
this.createjs = this.createjs || {};
(function() {
    "use strict";

    function Sound() { throw "Sound cannot be instantiated"; }
    var s = Sound;
    s.DELIMITER = "|";
    s.AUDIO_TIMEOUT = 8000;
    s.INTERRUPT_ANY = "any";
    s.INTERRUPT_EARLY = "early";
    s.INTERRUPT_LATE = "late";
    s.INTERRUPT_NONE = "none";
    s.PLAY_INITED = "playInited";
    s.PLAY_SUCCEEDED = "playSucceeded";
    s.PLAY_INTERRUPTED = "playInterrupted";
    s.PLAY_FINISHED = "playFinished";
    s.PLAY_FAILED = "playFailed";
    s.SUPPORTED_EXTENSIONS = ["mp3", "ogg", "mpeg", "wav", "m4a", "mp4", "aiff", "wma", "mid"];
    s.EXTENSION_MAP = { m4a: "mp4" };
    s.FILE_PATTERN = /^(?:(\w+:)\/{2}(\w+(?:\.\w+)*\/?))?([/.]*?(?:[^?]+)?\/)?((?:[^/?]+)\.(\w+))(?:\?(\S+)?)?$/;
    s.defaultInterruptBehavior = s.INTERRUPT_NONE;
    s.lastId = 0;
    s.activePlugin = null;
    s.pluginsRegistered = false;
    s.masterVolume = 1;
    s.masterMute = false;
    s.instances = [];
    s.idHash = {};
    s.preloadHash = {};
    s.defaultSoundInstance = null;
    s.addEventListener = null;
    s.removeEventListener = null;
    s.removeAllEventListeners = null;
    s.dispatchEvent = null;
    s.hasEventListener = null;
    s._listeners = null;
    createjs.EventDispatcher.initialize(s);
    s.sendFileLoadEvent = function(src) {
        if (!s.preloadHash[src]) { return; }
        for (var i = 0, l = s.preloadHash[src].length; i < l; i++) {
            var item = s.preloadHash[src][i];
            s.preloadHash[src][i] = true;
            if (!s.hasEventListener("fileload")) { continue; }
            var event = new createjs.Event("fileload");
            event.src = item.src, event.id = item.id, event.data = item.data
            s.dispatchEvent(event);
        }
    }
    s.getPreloadHandlers = function() { return { callback: createjs.proxy(s.initLoad, s), types: ["sound"], extensions: s.SUPPORTED_EXTENSIONS }; }
    s.registerPlugin = function(plugin) {
        s.pluginsRegistered = true;
        if (plugin == null) { return false; }
        if (plugin.isSupported()) { s.activePlugin = new plugin(); return true; }
        return false;
    }
    s.registerPlugins = function(plugins) {
        for (var i = 0, l = plugins.length; i < l; i++) { var plugin = plugins[i]; if (s.registerPlugin(plugin)) { return true; } }
        return false;
    }
    s.initializeDefaultPlugins = function() {
        if (s.activePlugin != null) { return true; }
        if (s.pluginsRegistered) { return false; }
        if (s.registerPlugins([createjs.WebAudioPlugin, createjs.HTMLAudioPlugin])) { return true; }
        return false;
    }
    s.isReady = function() { return (s.activePlugin != null); }
    s.getCapabilities = function() {
        if (s.activePlugin == null) { return null; }
        return s.activePlugin.capabilities;
    }
    s.getCapability = function(key) {
        if (s.activePlugin == null) { return null; }
        return s.activePlugin.capabilities[key];
    }
    s.initLoad = function(src, type, id, data, basePath) {
        var details = s.registerSound(src, id, data, false, basePath);
        if (details == null) { return false; }
        return details;
    }
    s.registerSound = function(src, id, data, preload, basePath) {
        if (!s.initializeDefaultPlugins()) { return false; }
        if (src instanceof Object) { basePath = id;
            id = src.id;
            data = src.data;
            src = src.src; }
        var details = s.parsePath(src, "sound", id, data);
        if (details == null) { return false; }
        if (id != null) { s.idHash[id] = details.src; }
        var numChannels = null;
        if (data != null) {
            if (!isNaN(data.channels)) { numChannels = parseInt(data.channels); } else if (!isNaN(data)) { numChannels = parseInt(data); }
        }
        var loader = s.activePlugin.register(details.src, numChannels);
        if (loader != null) {
            if (loader.numChannels != null) { numChannels = loader.numChannels; }
            SoundChannel.create(details.src, numChannels);
            if (data == null || !isNaN(data)) { data = details.data = numChannels || SoundChannel.maxPerChannel(); } else { data.channels = details.data.channels = numChannels || SoundChannel.maxPerChannel(); }
            if (loader.tag != null) { details.tag = loader.tag; } else if (loader.src) { details.src = loader.src; }
            if (loader.completeHandler != null) { details.completeHandler = loader.completeHandler; }
            if (loader.type) { details.type = loader.type; }
        }
        if (preload != false) {
            if (!s.preloadHash[details.src]) { s.preloadHash[details.src] = []; }
            s.preloadHash[details.src].push({ src: src, id: id, data: data });
            if (s.preloadHash[details.src].length == 1) {
                if (basePath == null) { basePath = ""; }
                s.activePlugin.preload(details.src, loader, basePath);
            } else { if (s.preloadHash[details.src][0] == true) { return true; } }
        }
        return details;
    }
    s.registerManifest = function(manifest, basePath) {
        var returnValues = [];
        for (var i = 0, l = manifest.length; i < l; i++) { returnValues[i] = createjs.Sound.registerSound(manifest[i].src, manifest[i].id, manifest[i].data, manifest[i].preload, basePath); }
        return returnValues;
    }
    s.removeSound = function(src) {
        if (s.activePlugin == null) { return false; }
        if (src instanceof Object) { src = src.src; }
        src = s.getSrcById(src);
        var details = s.parsePath(src);
        if (details == null) { return false; }
        src = details.src;
        for (var prop in s.idHash) { if (s.idHash[prop] == src) { delete(s.idHash[prop]); } }
        SoundChannel.removeSrc(src);
        delete(s.preloadHash[src]);
        s.activePlugin.removeSound(src);
        return true;
    }
    s.removeManifest = function(manifest) {
        var returnValues = [];
        for (var i = 0, l = manifest.length; i < l; i++) { returnValues[i] = createjs.Sound.removeSound(manifest[i].src); }
        return returnValues;
    }
    s.removeAllSounds = function() { s.idHash = {};
        s.preloadHash = {};
        SoundChannel.removeAll();
        s.activePlugin.removeAllSounds(); }
    s.loadComplete = function(src) {
        var details = s.parsePath(src, "sound");
        if (details) { src = s.getSrcById(details.src); } else { src = s.getSrcById(src); }
        return (s.preloadHash[src][0] == true);
    }
    s.parsePath = function(value, type, id, data) {
        if (typeof(value) != "string") { value = value.toString(); }
        var sounds = value.split(s.DELIMITER);
        var ret = { type: type || "sound", id: id, data: data };
        var c = s.getCapabilities();
        for (var i = 0, l = sounds.length; i < l; i++) {
            var sound = sounds[i];
            var match = sound.match(s.FILE_PATTERN);
            if (match == null) { return false; }
            var name = match[4];
            var ext = match[5];
            if (c[ext] && createjs.indexOf(s.SUPPORTED_EXTENSIONS, ext) > -1) { ret.name = name;
                ret.src = sound;
                ret.extension = ext; return ret; }
        }
        return null;
    }
    s.play = function(src, interrupt, delay, offset, loop, volume, pan) {
        var instance = s.createInstance(src);
        var ok = s.playInstance(instance, interrupt, delay, offset, loop, volume, pan);
        if (!ok) { instance.playFailed(); }
        return instance;
    }
    s.createInstance = function(src) {
        if (!s.initializeDefaultPlugins()) { return s.defaultSoundInstance; }
        src = s.getSrcById(src);
        var details = s.parsePath(src, "sound");
        var instance = null;
        if (details != null && details.src != null) { SoundChannel.create(details.src);
            instance = s.activePlugin.create(details.src); } else { instance = Sound.defaultSoundInstance; }
        instance.uniqueId = s.lastId++;
        return instance;
    }
    s.setVolume = function(value) {
        if (Number(value) == null) { return false; }
        value = Math.max(0, Math.min(1, value));
        s.masterVolume = value;
        if (!this.activePlugin || !this.activePlugin.setVolume || !this.activePlugin.setVolume(value)) { var instances = this.instances; for (var i = 0, l = instances.length; i < l; i++) { instances[i].setMasterVolume(value); } }
    }
    s.getVolume = function() { return s.masterVolume; }
    s.setMute = function(value) {
        if (value == null || value == undefined) { return false; }
        this.masterMute = value;
        if (!this.activePlugin || !this.activePlugin.setMute || !this.activePlugin.setMute(value)) { var instances = this.instances; for (var i = 0, l = instances.length; i < l; i++) { instances[i].setMasterMute(value); } }
        return true;
    }
    s.getMute = function() { return this.masterMute; }
    s.stop = function() { var instances = this.instances; for (var i = instances.length; i--;) { instances[i].stop(); } }
    s.playInstance = function(instance, interrupt, delay, offset, loop, volume, pan) {
        if (interrupt instanceof Object) { delay = interrupt.delay;
            offset = interrupt.offset;
            loop = interrupt.loop;
            volume = interrupt.volume;
            pan = interrupt.pan; }
        interrupt = interrupt || s.defaultInterruptBehavior;
        if (delay == null) { delay = 0; }
        if (offset == null) { offset = instance.getPosition(); }
        if (loop == null) { loop = 0; }
        if (volume == null) { volume = instance.volume; }
        if (pan == null) { pan = instance.pan; }
        if (delay == 0) { var ok = s.beginPlaying(instance, interrupt, offset, loop, volume, pan); if (!ok) { return false; } } else { var delayTimeoutId = setTimeout(function() { s.beginPlaying(instance, interrupt, offset, loop, volume, pan); }, delay);
            instance.delayTimeoutId = delayTimeoutId; }
        this.instances.push(instance);
        return true;
    }
    s.beginPlaying = function(instance, interrupt, offset, loop, volume, pan) {
        if (!SoundChannel.add(instance, interrupt)) { return false; }
        var result = instance.beginPlaying(offset, loop, volume, pan);
        if (!result) {
            var index = createjs.indexOf(this.instances, instance);
            if (index > -1) { this.instances.splice(index, 1); }
            return false;
        }
        return true;
    }
    s.getSrcById = function(value) {
        if (s.idHash == null || s.idHash[value] == null) { return value; }
        return s.idHash[value];
    }
    s.playFinished = function(instance) { SoundChannel.remove(instance); var index = createjs.indexOf(this.instances, instance); if (index > -1) { this.instances.splice(index, 1); } }
    createjs.Sound = Sound;

    function SoundChannel(src, max) { this.init(src, max); }
    SoundChannel.channels = {};
    SoundChannel.create = function(src, max) {
        var channel = SoundChannel.get(src);
        if (channel == null) { SoundChannel.channels[src] = new SoundChannel(src, max); return true; }
        return false;
    }
    SoundChannel.removeSrc = function(src) {
        var channel = SoundChannel.get(src);
        if (channel == null) { return false; }
        channel.removeAll();
        delete(SoundChannel.channels[src]);
        return true;
    }
    SoundChannel.removeAll = function() {
        for (var channel in SoundChannel.channels) { SoundChannel.channels[channel].removeAll(); }
        SoundChannel.channels = {};
    }
    SoundChannel.add = function(instance, interrupt) {
        var channel = SoundChannel.get(instance.src);
        if (channel == null) { return false; }
        return channel.add(instance, interrupt);
    }
    SoundChannel.remove = function(instance) {
        var channel = SoundChannel.get(instance.src);
        if (channel == null) { return false; }
        channel.remove(instance);
        return true;
    }
    SoundChannel.maxPerChannel = function() { return p.maxDefault; }
    SoundChannel.get = function(src) { return SoundChannel.channels[src]; }
    var p = SoundChannel.prototype;
    p.src = null;
    p.max = null;
    p.maxDefault = 100;
    p.length = 0;
    p.init = function(src, max) {
        this.src = src;
        this.max = max || this.maxDefault;
        if (this.max == -1) { this.max == this.maxDefault; }
        this.instances = [];
    };
    p.get = function(index) { return this.instances[index]; };
    p.add = function(instance, interrupt) {
        if (!this.getSlot(interrupt, instance)) { return false; }
        this.instances.push(instance);
        this.length++;
        return true;
    };
    p.remove = function(instance) {
        var index = createjs.indexOf(this.instances, instance);
        if (index == -1) { return false; }
        this.instances.splice(index, 1);
        this.length--;
        return true;
    };
    p.removeAll = function() { for (var i = this.length - 1; i >= 0; i--) { this.instances[i].stop(); } };
    p.getSlot = function(interrupt, instance) {
        var target, replacement;
        for (var i = 0, l = this.max; i < l; i++) {
            target = this.get(i);
            if (target == null) { return true; } else if (interrupt == Sound.INTERRUPT_NONE && target.playState != Sound.PLAY_FINISHED) { continue; }
            if (i == 0) { replacement = target; continue; }
            if (target.playState == Sound.PLAY_FINISHED || target.playState == Sound.PLAY_INTERRUPTED || target.playState == Sound.PLAY_FAILED) { replacement = target; } else if ((interrupt == Sound.INTERRUPT_EARLY && target.getPosition() < replacement.getPosition()) || (interrupt == Sound.INTERRUPT_LATE && target.getPosition() > replacement.getPosition())) { replacement = target; }
        }
        if (replacement != null) { replacement.interrupt();
            this.remove(replacement); return true; }
        return false;
    };
    p.toString = function() { return "[Sound SoundChannel]"; };

    function SoundInstance() {
        this.isDefault = true;
        this.addEventListener = this.removeEventListener = this.removeAllEventListener = this.dispatchEvent = this.hasEventListener = this._listeners = this.interrupt = this.playFailed = this.pause = this.resume = this.play = this.beginPlaying = this.cleanUp = this.stop = this.setMasterVolume = this.setVolume = this.mute = this.setMute = this.getMute = this.setPan = this.getPosition = this.setPosition = function() { return false; };
        this.getVolume = this.getPan = this.getDuration = function() { return 0; }
        this.playState = Sound.PLAY_FAILED;
        this.toString = function() { return "[Sound Default Sound Instance]"; }
    }
    Sound.defaultSoundInstance = new SoundInstance();
    if (createjs.proxy == null) { createjs.proxy = function() { throw ("Proxy has been moved to an external file, and must be included separately."); } }

    function BrowserDetect() {}
    BrowserDetect.init = function() { var agent = window.navigator.userAgent;
        BrowserDetect.isFirefox = (agent.indexOf("Firefox") > -1);
        BrowserDetect.isOpera = (window.opera != null);
        BrowserDetect.isChrome = (agent.indexOf("Chrome") > -1);
        BrowserDetect.isIOS = agent.indexOf("iPod") > -1 || agent.indexOf("iPhone") > -1 || agent.indexOf("iPad") > -1;
        BrowserDetect.isAndroid = (agent.indexOf("Android") > -1);
        BrowserDetect.isBlackberry = (agent.indexOf("Blackberry") > -1); }
    BrowserDetect.init();
    createjs.Sound.BrowserDetect = BrowserDetect;
}());
this.createjs = this.createjs || {};
(function() {
    "use strict";

    function WebAudioPlugin() { this.init(); }
    var s = WebAudioPlugin;
    s.capabilities = null;
    s.isSupported = function() {
        var isMobilePhoneGap = createjs.Sound.BrowserDetect.isIOS || createjs.Sound.BrowserDetect.isAndroid || createjs.Sound.BrowserDetect.isBlackberry;
        if (location.protocol == "file:" && !isMobilePhoneGap && !this.isFileXHRSupported()) { return false; }
        s.generateCapabilities();
        if (s.context == null) { return false; }
        return true;
    };
    s.isFileXHRSupported = function() {
        var supported = true;
        var xhr = new XMLHttpRequest();
        try { xhr.open("GET", "fail.fail", false); } catch (error) { supported = false; return supported; }
        xhr.onerror = function() { supported = false; };
        xhr.onload = function() { supported = this.status == 404 || (this.status == 200 || (this.status == 0 && this.response != "")); };
        try { xhr.send(); } catch (error) { supported = false; }
        return supported;
    }
    s.generateCapabilities = function() {
        if (s.capabilities != null) { return; }
        var t = document.createElement("audio");
        if (t.canPlayType == null) { return null; }
        if (window.webkitAudioContext) { s.context = new webkitAudioContext(); } else if (window.AudioContext) { s.context = new AudioContext(); } else { return null; }
        s.compatibilitySetUp();
        s.playEmptySound();
        s.capabilities = { panning: true, volume: true, tracks: -1 };
        var supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;
        var extensionMap = createjs.Sound.EXTENSION_MAP;
        for (var i = 0, l = supportedExtensions.length; i < l; i++) { var ext = supportedExtensions[i]; var playType = extensionMap[ext] || ext;
            s.capabilities[ext] = (t.canPlayType("audio/" + ext) != "no" && t.canPlayType("audio/" + ext) != "") || (t.canPlayType("audio/" + playType) != "no" && t.canPlayType("audio/" + playType) != ""); }
        if (s.context.destination.numberOfChannels < 2) { s.capabilities.panning = false; }
        s.dynamicsCompressorNode = s.context.createDynamicsCompressor();
        s.dynamicsCompressorNode.connect(s.context.destination);
        s.gainNode = s.context.createGain();
        s.gainNode.connect(s.dynamicsCompressorNode);
    };
    s.compatibilitySetUp = function() {
        if (s.context.createGain) { return; }
        s.context.createGain = s.context.createGainNode;
        var audioNode = s.context.createBufferSource();
        audioNode.__proto__.start = audioNode.__proto__.noteGrainOn;
        audioNode.__proto__.stop = audioNode.__proto__.noteOff;
        this.panningModel = 0;
    }
    s.playEmptySound = function() { var buffer = this.context.createBuffer(1, 1, 22050); var source = this.context.createBufferSource();
        source.buffer = buffer;
        source.connect(this.context.destination);
        source.start(0, 0, 0); };
    var p = WebAudioPlugin.prototype;
    p.capabilities = null;
    p.volume = 1;
    p.context = null;
    p.panningModel = "equalpower";
    p.dynamicsCompressorNode = null;
    p.gainNode = null;
    p.arrayBuffers = null;
    p.init = function() { this.capabilities = s.capabilities;
        this.arrayBuffers = {};
        this.context = s.context;
        this.gainNode = s.gainNode;
        this.dynamicsCompressorNode = s.dynamicsCompressorNode; };
    p.register = function(src, instances) { this.arrayBuffers[src] = true; var tag = new createjs.WebAudioPlugin.Loader(src, this); return { tag: tag }; };
    p.isPreloadStarted = function(src) { return (this.arrayBuffers[src] != null); };
    p.isPreloadComplete = function(src) { return (!(this.arrayBuffers[src] == null || this.arrayBuffers[src] == true)); };
    p.removeFromPreload = function(src) { delete(this.arrayBuffers[src]); };
    p.removeSound = function(src) { delete(this.arrayBuffers[src]); };
    p.removeAllSounds = function() { this.arrayBuffers = {}; };
    p.addPreloadResults = function(src, result) { this.arrayBuffers[src] = result; };
    p.handlePreloadComplete = function() { createjs.Sound.sendFileLoadEvent(this.src); };
    p.preload = function(src, instance, basePath) {
        this.arrayBuffers[src] = true;
        var loader = new createjs.WebAudioPlugin.Loader(src, this);
        loader.onload = this.handlePreloadComplete;
        if (basePath != null) { loader.src = basePath + loader.src; }
        loader.load();
    };
    p.create = function(src) {
        if (!this.isPreloadStarted(src)) { this.preload(src); }
        return new createjs.WebAudioPlugin.SoundInstance(src, this);
    };
    p.setVolume = function(value) { this.volume = value;
        this.updateVolume(); return true; };
    p.updateVolume = function() { var newVolume = createjs.Sound.masterMute ? 0 : this.volume; if (newVolume != this.gainNode.gain.value) { this.gainNode.gain.value = newVolume; } };
    p.getVolume = function() { return this.volume; };
    p.setMute = function(value) { this.updateVolume(); return true; };
    p.toString = function() { return "[WebAudioPlugin]"; };
    createjs.WebAudioPlugin = WebAudioPlugin;
}());
(function() {
    "use strict";

    function SoundInstance(src, owner) { this.init(src, owner); }
    var p = SoundInstance.prototype;
    p.src = null;
    p.uniqueId = -1;
    p.playState = null;
    p.owner = null;
    p.offset = 0;
    p.delay = 0;
    p._volume = 1;
    Object.defineProperty(p, "volume", {
        get: function() { return this._volume; },
        set: function(value) {
            if (Number(value) == null) { return false }
            value = Math.max(0, Math.min(1, value));
            this._volume = value;
            this.updateVolume();
        }
    });
    p._pan = 0;
    Object.defineProperty(p, "pan", {
        get: function() { return this._pan; },
        set: function(value) {
            if (!this.owner.capabilities.panning || Number(value) == null) { return false; }
            value = Math.max(-1, Math.min(1, value));
            this._pan = value;
            this.panNode.setPosition(value, 0, -0.5);
        }
    });
    p.duration = 0;
    p.remainingLoops = 0;
    p.delayTimeoutId = null;
    p.soundCompleteTimeout = null;
    p.panNode = null;
    p.gainNode = null;
    p.sourceNode = null;
    p.sourceNodeNext = null;
    p.muted = false;
    p.paused = false;
    p.startTime = 0;
    p.addEventListener = null;
    p.removeEventListener = null;
    p.removeAllEventListeners = null;
    p.dispatchEvent = null;
    p.hasEventListener = null;
    p._listeners = null;
    p.endedHandler = null;
    p.readyHandler = null;
    p.stalledHandler = null;
    p.sendEvent = function(type) { var event = new createjs.Event(type);
        this.dispatchEvent(event); };
    p.init = function(src, owner) {
        this.owner = owner;
        this.src = src;
        this.panNode = this.owner.context.createPanner();
        this.panNode.panningModel = this.owner.panningModel;
        this.gainNode = this.owner.context.createGain();
        this.gainNode.connect(this.panNode);
        if (this.owner.isPreloadComplete(this.src)) { this.duration = this.owner.arrayBuffers[this.src].duration * 1000; }
        this.endedHandler = createjs.proxy(this.handleSoundComplete, this);
        this.readyHandler = createjs.proxy(this.handleSoundReady, this);
        this.stalledHandler = createjs.proxy(this.handleSoundStalled, this);
    };
    p.cleanUp = function() {
        if (this.sourceNode && this.sourceNode.playbackState != this.sourceNode.UNSCHEDULED_STATE) { this.sourceNode = this.cleanUpAudioNode(this.sourceNode);
            this.sourceNodeNext = this.cleanUpAudioNode(this.sourceNodeNext); }
        if (this.panNode.numberOfOutputs != 0) { this.panNode.disconnect(0); }
        clearTimeout(this.delayTimeoutId);
        clearTimeout(this.soundCompleteTimeout);
        this.startTime = 0;
        if (window.createjs == null) { return; }
        createjs.Sound.playFinished(this);
    };
    p.cleanUpAudioNode = function(audioNode) {
        if (audioNode) { audioNode.stop(0);
            audioNode.disconnect(this.gainNode);
            audioNode = null; }
        return audioNode;
    };
    p.interrupt = function() { this.playState = createjs.Sound.PLAY_INTERRUPTED;
        this.cleanUp();
        this.paused = false;
        this.sendEvent("interrupted"); };
    p.handleSoundStalled = function(event) { this.sendEvent("failed"); };
    p.handleSoundReady = function(event) {
        if (window.createjs == null) { return; }
        if ((this.offset * 1000) > this.getDuration()) { this.playFailed(); return; } else if (this.offset < 0) { this.offset = 0; }
        this.playState = createjs.Sound.PLAY_SUCCEEDED;
        this.paused = false;
        this.panNode.connect(this.owner.gainNode);
        var dur = this.owner.arrayBuffers[this.src].duration;
        this.sourceNode = this.createAndPlayAudioNode((this.owner.context.currentTime - dur), this.offset);
        this.duration = dur * 1000;
        this.startTime = this.sourceNode.startTime - this.offset;
        this.soundCompleteTimeout = setTimeout(this.endedHandler, (dur - this.offset) * 1000);
        if (this.remainingLoops != 0) { this.sourceNodeNext = this.createAndPlayAudioNode(this.startTime, 0); }
    };
    p.createAndPlayAudioNode = function(startTime, offset) { var audioNode = this.owner.context.createBufferSource();
        audioNode.buffer = this.owner.arrayBuffers[this.src];
        audioNode.connect(this.gainNode); var currentTime = this.owner.context.currentTime;
        audioNode.startTime = startTime + audioNode.buffer.duration;
        audioNode.start(audioNode.startTime, offset, audioNode.buffer.duration - offset); return audioNode; };
    p.play = function(interrupt, delay, offset, loop, volume, pan) { this.cleanUp();
        createjs.Sound.playInstance(this, interrupt, delay, offset, loop, volume, pan); };
    p.beginPlaying = function(offset, loop, volume, pan) {
        if (window.createjs == null) { return; }
        if (!this.src) { return; }
        this.offset = offset / 1000;
        this.remainingLoops = loop;
        this.volume = volume;
        this.pan = pan;
        if (this.owner.isPreloadComplete(this.src)) { this.handleSoundReady(null);
            this.sendEvent("succeeded"); return 1; } else { this.playFailed(); return; }
    };
    p.pause = function() {
        if (!this.paused && this.playState == createjs.Sound.PLAY_SUCCEEDED) {
            this.paused = true;
            this.offset = this.owner.context.currentTime - this.startTime;
            this.cleanUpAudioNode(this.sourceNode);
            this.cleanUpAudioNode(this.sourceNodeNext);
            if (this.panNode.numberOfOutputs != 0) { this.panNode.disconnect(); }
            clearTimeout(this.delayTimeoutId);
            clearTimeout(this.soundCompleteTimeout);
            return true;
        }
        return false;
    };
    p.resume = function() {
        if (!this.paused) { return false; }
        this.handleSoundReady(null);
        return true;
    };
    p.stop = function() { this.playState = createjs.Sound.PLAY_FINISHED;
        this.cleanUp();
        this.offset = 0; return true; };
    p.setVolume = function(value) { this.volume = value; return true; };
    p.updateVolume = function() {
        var newVolume = this.muted ? 0 : this._volume;
        if (newVolume != this.gainNode.gain.value) { this.gainNode.gain.value = newVolume; return true; }
        return false;
    };
    p.getVolume = function() { return this.volume; };
    p.setMute = function(value) {
        if (value == null || value == undefined) { return false; }
        this.muted = value;
        this.updateVolume();
        return true;
    };
    p.getMute = function() { return this.muted; };
    p.setPan = function(value) { this.pan = value; if (this.pan != value) { return false; } };
    p.getPan = function() { return this.pan; };
    p.getPosition = function() {
        if (this.paused || this.sourceNode == null) { var pos = this.offset; } else { var pos = this.owner.context.currentTime - this.startTime; }
        return pos * 1000;
    };
    p.setPosition = function(value) {
        this.offset = value / 1000;
        if (this.sourceNode && this.sourceNode.playbackState != this.sourceNode.UNSCHEDULED_STATE) { this.cleanUpAudioNode(this.sourceNode);
            this.cleanUpAudioNode(this.sourceNodeNext);
            clearTimeout(this.soundCompleteTimeout); }
        if (!this.paused && this.playState == createjs.Sound.PLAY_SUCCEEDED) { this.handleSoundReady(null); }
        return true;
    };
    p.getDuration = function() { return this.duration; };
    p.handleSoundComplete = function(event) {
        this.offset = 0;
        if (this.remainingLoops != 0) {
            this.remainingLoops--;
            if (this.sourceNodeNext) { this.cleanUpAudioNode(this.sourceNode);
                this.sourceNode = this.sourceNodeNext;
                this.startTime = this.sourceNode.startTime;
                this.sourceNodeNext = this.createAndPlayAudioNode(this.startTime, 0);
                this.soundCompleteTimeout = setTimeout(this.endedHandler, this.duration); } else { this.handleSoundReady(null); }
            this.sendEvent("loop");
            return;
        }
        if (window.createjs == null) { return; }
        this.playState = createjs.Sound.PLAY_FINISHED;
        this.cleanUp();
        this.sendEvent("complete");
    };
    p.playFailed = function() {
        if (window.createjs == null) { return; }
        this.playState = createjs.Sound.PLAY_FAILED;
        this.cleanUp();
        this.sendEvent("failed");
    };
    p.toString = function() { return "[WebAudioPlugin SoundInstance]"; };
    createjs.EventDispatcher.initialize(SoundInstance.prototype);
    createjs.WebAudioPlugin.SoundInstance = SoundInstance;
}());
(function() {
    "use strict";

    function Loader(src, owner) { this.init(src, owner); }
    var p = Loader.prototype;
    p.request = null;
    p.owner = null;
    p.progress = -1;
    p.src = null;
    p.originalSrc = null;
    p.result = null;
    p.onload = null;
    p.onprogress = null;
    p.onError = null;
    p.init = function(src, owner) { this.src = src;
        this.originalSrc = src;
        this.owner = owner; };
    p.load = function(src) {
        if (src != null) { this.src = src; }
        this.request = new XMLHttpRequest();
        this.request.open("GET", this.src, true);
        this.request.responseType = "arraybuffer";
        this.request.onload = createjs.proxy(this.handleLoad, this);
        this.request.onError = createjs.proxy(this.handleError, this);
        this.request.onprogress = createjs.proxy(this.handleProgress, this);
        this.request.send();
    };
    p.handleProgress = function(loaded, total) { this.progress = loaded / total;
        this.onprogress != null && this.onprogress({ loaded: loaded, total: total, progress: this.progress }); };
    p.handleLoad = function() {
        var handleAudioDecoded = createjs.proxy(this.handleAudioDecoded, this);
        var handleError = createjs.proxy(this.handleError, this);
        var promise = this.owner.context.decodeAudioData(this.request.response, handleAudioDecoded, handleError);
        if (promise && promise.then)
            promise.then(handleAudioDecoded, handleError);
    };
    p.handleAudioDecoded = function(decodedAudio) { this.progress = 1;
        this.result = decodedAudio;
        this.src = this.originalSrc;
        this.owner.addPreloadResults(this.src, this.result);
        this.onload && this.onload(); };
    p.handleError = function(evt) { this.owner.removeSound(this.src);
        this.onerror && this.onerror(evt); };
    p.toString = function() { return "[WebAudioPlugin Loader]"; };
    createjs.WebAudioPlugin.Loader = Loader;
}());
this.createjs = this.createjs || {};
(function() {
    "use strict";

    function HTMLAudioPlugin() { this.init(); }
    var s = HTMLAudioPlugin;
    s.MAX_INSTANCES = 30;
    s.capabilities = null;
    s.AUDIO_READY = "canplaythrough";
    s.AUDIO_ENDED = "ended";
    s.AUDIO_SEEKED = "seeked";
    s.AUDIO_ERROR = "error";
    s.AUDIO_STALLED = "stalled";
    s.enableIOS = false;
    s.isSupported = function() {
        if (createjs.Sound.BrowserDetect.isIOS && !s.enableIOS) { return false; }
        s.generateCapabilities();
        var t = s.tag;
        if (t == null || s.capabilities == null) { return false; }
        return true;
    };
    s.generateCapabilities = function() {
        if (s.capabilities != null) { return; }
        var t = s.tag = document.createElement("audio");
        if (t.canPlayType == null) { return null; }
        s.capabilities = { panning: true, volume: true, tracks: -1 };
        var supportedExtensions = createjs.Sound.SUPPORTED_EXTENSIONS;
        var extensionMap = createjs.Sound.EXTENSION_MAP;
        for (var i = 0, l = supportedExtensions.length; i < l; i++) { var ext = supportedExtensions[i]; var playType = extensionMap[ext] || ext;
            s.capabilities[ext] = (t.canPlayType("audio/" + ext) != "no" && t.canPlayType("audio/" + ext) != "") || (t.canPlayType("audio/" + playType) != "no" && t.canPlayType("audio/" + playType) != ""); }
    }
    var p = HTMLAudioPlugin.prototype;
    p.capabilities = null;
    p.audioSources = null;
    p.defaultNumChannels = 2;
    p.loadedHandler = null;
    p.init = function() { this.capabilities = s.capabilities;
        this.audioSources = {}; };
    p.register = function(src, instances) {
        this.audioSources[src] = true;
        var channel = createjs.HTMLAudioPlugin.TagPool.get(src);
        var tag = null;
        var l = instances || this.defaultNumChannels;
        for (var i = 0; i < l; i++) { tag = this.createTag(src);
            channel.add(tag); }
        tag.id = src;
        this.loadedHandler = createjs.proxy(this.handleTagLoad, this);
        tag.addEventListener && tag.addEventListener("canplaythrough", this.loadedHandler);
        if (tag.onreadystatechange == null) { tag.onreadystatechange = this.loadedHandler; } else { var f = tag.onreadystatechange;
            tag.onreadystatechange = function() { f();
                this.loadedHandler(); } }
        return { tag: tag, numChannels: l };
    };
    p.handleTagLoad = function(event) {
        event.target.removeEventListener && event.target.removeEventListener("canplaythrough", this.loadedHandler);
        event.target.onreadystatechange = null;
        if (event.target.src == event.target.id) { return; }
        createjs.HTMLAudioPlugin.TagPool.checkSrc(event.target.id);
    };
    p.createTag = function(src) { var tag = document.createElement("audio");
        tag.autoplay = false;
        tag.preload = "none";
        tag.src = src; return tag; };
    p.removeSound = function(src) { delete(this.audioSources[src]);
        createjs.HTMLAudioPlugin.TagPool.remove(src); };
    p.removeAllSounds = function() { this.audioSources = {};
        createjs.HTMLAudioPlugin.TagPool.removeAll(); };
    p.create = function(src) {
        if (!this.isPreloadStarted(src)) { var channel = createjs.HTMLAudioPlugin.TagPool.get(src); var tag = this.createTag(src);
            tag.id = src;
            channel.add(tag);
            this.preload(src, { tag: tag }); }
        return new createjs.HTMLAudioPlugin.SoundInstance(src, this);
    };
    p.isPreloadStarted = function(src) { return (this.audioSources[src] != null); };
    p.preload = function(src, instance, basePath) {
        this.audioSources[src] = true;
        if (basePath != null) { instance.tag.src = basePath + src; }
        new createjs.HTMLAudioPlugin.Loader(src, instance.tag);
    };
    p.toString = function() { return "[HTMLAudioPlugin]"; };
    createjs.HTMLAudioPlugin = HTMLAudioPlugin;
}());
(function() {
    "use strict";

    function SoundInstance(src, owner) { this.init(src, owner); }
    var p = SoundInstance.prototype;
    p.src = null, p.uniqueId = -1;
    p.playState = null;
    p.owner = null;
    p.loaded = false;
    p.offset = 0;
    p.delay = 0;
    p._volume = 1;
    Object.defineProperty(p, "volume", {
        get: function() { return this._volume; },
        set: function(value) {
            if (Number(value) == null) { return; }
            value = Math.max(0, Math.min(1, value));
            this._volume = value;
            this.updateVolume();
        }
    });
    p.pan = 0;
    p.duration = 0;
    p.remainingLoops = 0;
    p.delayTimeoutId = null;
    p.tag = null;
    p.muted = false;
    p.paused = false;
    p.addEventListener = null;
    p.removeEventListener = null;
    p.removeAllEventListeners = null;
    p.dispatchEvent = null;
    p.hasEventListener = null;
    p._listeners = null;
    p.endedHandler = null;
    p.readyHandler = null;
    p.stalledHandler = null;
    p.loopHandler = null;
    p.init = function(src, owner) { this.src = src;
        this.owner = owner;
        this.endedHandler = createjs.proxy(this.handleSoundComplete, this);
        this.readyHandler = createjs.proxy(this.handleSoundReady, this);
        this.stalledHandler = createjs.proxy(this.handleSoundStalled, this);
        this.loopHandler = createjs.proxy(this.handleSoundLoop, this); };
    p.sendEvent = function(type) { var event = new createjs.Event(type);
        this.dispatchEvent(event); };
    p.cleanUp = function() {
        var tag = this.tag;
        if (tag != null) {
            tag.pause();
            tag.removeEventListener(createjs.HTMLAudioPlugin.AUDIO_ENDED, this.endedHandler, false);
            tag.removeEventListener(createjs.HTMLAudioPlugin.AUDIO_READY, this.readyHandler, false);
            tag.removeEventListener(createjs.HTMLAudioPlugin.AUDIO_SEEKED, this.loopHandler, false);
            try { tag.currentTime = 0; } catch (e) {}
            createjs.HTMLAudioPlugin.TagPool.setInstance(this.src, tag);
            this.tag = null;
        }
        clearTimeout(this.delayTimeoutId);
        if (window.createjs == null) { return; }
        createjs.Sound.playFinished(this);
    };
    p.interrupt = function() {
        if (this.tag == null) { return; }
        this.playState = createjs.Sound.PLAY_INTERRUPTED;
        this.cleanUp();
        this.paused = false;
        this.sendEvent("interrupted");
    };
    p.play = function(interrupt, delay, offset, loop, volume, pan) { this.cleanUp();
        createjs.Sound.playInstance(this, interrupt, delay, offset, loop, volume, pan); };
    p.beginPlaying = function(offset, loop, volume, pan) {
        if (window.createjs == null) { return -1; }
        var tag = this.tag = createjs.HTMLAudioPlugin.TagPool.getInstance(this.src);
        if (tag == null) { this.playFailed(); return -1; }
        tag.addEventListener(createjs.HTMLAudioPlugin.AUDIO_ENDED, this.endedHandler, false);
        this.offset = offset;
        this.volume = volume;
        this.pan = pan;
        this.updateVolume();
        this.remainingLoops = loop;
        if (tag.readyState !== 4) { tag.addEventListener(createjs.HTMLAudioPlugin.AUDIO_READY, this.readyHandler, false);
            tag.addEventListener(createjs.HTMLAudioPlugin.AUDIO_STALLED, this.stalledHandler, false);
            tag.preload = "auto";
            tag.load(); } else { this.handleSoundReady(null); }
        this.sendEvent("succeeded");
        return 1;
    };
    p.handleSoundStalled = function(event) { this.cleanUp();
        this.sendEvent("failed"); };
    p.handleSoundReady = function(event) {
        if (window.createjs == null) { return; }
        this.duration = this.tag.duration * 1000;
        this.playState = createjs.Sound.PLAY_SUCCEEDED;
        this.paused = false;
        this.tag.removeEventListener(createjs.HTMLAudioPlugin.AUDIO_READY, this.readyHandler, false);
        if (this.offset >= this.getDuration()) { this.playFailed(); return; } else if (this.offset > 0) { this.tag.currentTime = this.offset * 0.001; }
        if (this.remainingLoops == -1) { this.tag.loop = true; }
        if (this.remainingLoops != 0) { this.tag.addEventListener(createjs.HTMLAudioPlugin.AUDIO_SEEKED, this.loopHandler, false);
            this.tag.loop = true; }
        this.tag.play();
    };
    p.pause = function() {
        if (!this.paused && this.playState == createjs.Sound.PLAY_SUCCEEDED && this.tag != null) { this.paused = true;
            this.tag.pause();
            clearTimeout(this.delayTimeoutId); return true; }
        return false;
    };
    p.resume = function() {
        if (!this.paused || this.tag == null) { return false; }
        this.paused = false;
        this.tag.play();
        return true;
    };
    p.stop = function() { this.offset = 0;
        this.pause();
        this.playState = createjs.Sound.PLAY_FINISHED;
        this.cleanUp(); return true; };
    p.setMasterVolume = function(value) { this.updateVolume(); return true; };
    p.setVolume = function(value) { this.volume = value; return true; };
    p.updateVolume = function() {
        if (this.tag != null) {
            var newVolume = (this.muted || createjs.Sound.masterMute) ? 0 : this._volume * createjs.Sound.masterVolume;
            if (newVolume != this.tag.volume) { this.tag.volume = newVolume; }
            return true;
        } else { return false; }
    };
    p.getVolume = function(value) { return this.volume; };
    p.setMasterMute = function(isMuted) { this.updateVolume(); return true; };
    p.setMute = function(isMuted) {
        if (isMuted == null || isMuted == undefined) { return false; }
        this.muted = isMuted;
        this.updateVolume();
        return true;
    };
    p.getMute = function() { return this.muted; };
    p.setPan = function(value) { return false; };
    p.getPan = function() { return 0; };
    p.getPosition = function() {
        if (this.tag == null) { return this.offset; }
        return this.tag.currentTime * 1000;
    };
    p.setPosition = function(value) {
        if (this.tag == null) { this.offset = value } else {
            this.tag.removeEventListener(createjs.HTMLAudioPlugin.AUDIO_SEEKED, this.loopHandler, false);
            try { this.tag.currentTime = value * 0.001; } catch (error) { return false; }
            this.tag.addEventListener(createjs.HTMLAudioPlugin.AUDIO_SEEKED, this.loopHandler, false);
        }
        return true;
    };
    p.getDuration = function() { return this.duration; };
    p.handleSoundComplete = function(event) {
        this.offset = 0;
        if (window.createjs == null) { return; }
        this.playState = createjs.Sound.PLAY_FINISHED;
        this.cleanUp();
        this.sendEvent("complete");
    };
    p.handleSoundLoop = function(event) {
        this.offset = 0;
        this.remainingLoops--;
        if (this.remainingLoops == 0) { this.tag.loop = false;
            this.tag.removeEventListener(createjs.HTMLAudioPlugin.AUDIO_SEEKED, this.loopHandler, false); }
        this.sendEvent("loop");
    };
    p.playFailed = function() {
        if (window.createjs == null) { return; }
        this.playState = createjs.Sound.PLAY_FAILED;
        this.cleanUp();
        this.sendEvent("failed");
    };
    p.toString = function() { return "[HTMLAudioPlugin SoundInstance]"; };
    createjs.EventDispatcher.initialize(SoundInstance.prototype);
    createjs.HTMLAudioPlugin.SoundInstance = SoundInstance;
}());
(function() {
    "use strict";

    function Loader(src, tag) { this.init(src, tag); }
    var p = Loader.prototype;
    p.src = null;
    p.tag = null;
    p.preloadTimer = null;
    p.loadedHandler = null;
    p.init = function(src, tag) {
        this.src = src;
        this.tag = tag;
        this.preloadTimer = setInterval(createjs.proxy(this.preloadTick, this), 200);
        this.loadedHandler = createjs.proxy(this.sendLoadedEvent, this);
        this.tag.addEventListener && this.tag.addEventListener("canplaythrough", this.loadedHandler);
        if (this.tag.onreadystatechange == null) { this.tag.onreadystatechange = createjs.proxy(this.sendLoadedEvent, this); } else { var f = this.tag.onreadystatechange;
            this.tag.onreadystatechange = function() { f();
                this.tag.onreadystatechange = createjs.proxy(this.sendLoadedEvent, this); } }
        this.tag.preload = "auto";
        this.tag.load();
    };
    p.preloadTick = function() { var buffered = this.tag.buffered; var duration = this.tag.duration; if (buffered.length > 0) { if (buffered.end(0) >= duration - 1) { this.handleTagLoaded(); } } };
    p.handleTagLoaded = function() { clearInterval(this.preloadTimer); };
    p.sendLoadedEvent = function(evt) { this.tag.removeEventListener && this.tag.removeEventListener("canplaythrough", this.loadedHandler);
        this.tag.onreadystatechange = null;
        createjs.Sound.sendFileLoadEvent(this.src); };
    p.toString = function() { return "[HTMLAudioPlugin Loader]"; }
    createjs.HTMLAudioPlugin.Loader = Loader;
}());
(function() {
    "use strict";

    function TagPool(src) { this.init(src); }
    var s = TagPool;
    s.tags = {};
    s.get = function(src) {
        var channel = s.tags[src];
        if (channel == null) { channel = s.tags[src] = new TagPool(src); }
        return channel;
    }
    s.remove = function(src) {
        var channel = s.tags[src];
        if (channel == null) { return false; }
        channel.removeAll();
        delete(s.tags[src]);
        return true;
    }
    s.removeAll = function() {
        for (var channel in s.tags) { s.tags[channel].removeAll(); }
        s.tags = {};
    }
    s.getInstance = function(src) {
        var channel = s.tags[src];
        if (channel == null) { return null; }
        return channel.get();
    }
    s.setInstance = function(src, tag) {
        var channel = s.tags[src];
        if (channel == null) { return null; }
        return channel.set(tag);
    }
    s.checkSrc = function(src) {
        var channel = s.tags[src];
        if (channel == null) { return null; }
        channel.checkSrcChange();
    }
    var p = TagPool.prototype;
    p.src = null;
    p.length = 0;
    p.available = 0;
    p.tags = null;
    p.init = function(src) { this.src = src;
        this.tags = []; };
    p.add = function(tag) { this.tags.push(tag);
        this.length++;
        this.available++; };
    p.removeAll = function() {
        while (this.length--) { delete(this.tags[this.length]); }
        this.src = null;
        this.tags.length = 0;
    };
    p.get = function() {
        if (this.tags.length == 0) { return null; }
        this.available = this.tags.length;
        var tag = this.tags.pop();
        if (tag.parentNode == null) { document.body.appendChild(tag); }
        return tag;
    };
    p.set = function(tag) {
        var index = createjs.indexOf(this.tags, tag);
        if (index == -1) { this.tags.push(tag); }
        this.available = this.tags.length;
    };
    p.checkSrcChange = function() {
        var i = this.tags.length - 1;
        if (i < 0)
            return;
        var newSrc = this.tags[i].src;
        while (i--) { this.tags[i].src = newSrc; }
    };
    p.toString = function() { return "[HTMLAudioPlugin TagPool]"; }
    createjs.HTMLAudioPlugin.TagPool = TagPool;
}());
(function(window, undefined) {
    var
        rootjQuery, readyList, document = window.document,
        location = window.location,
        navigator = window.navigator,
        _jQuery = window.jQuery,
        _$ = window.$,
        core_push = Array.prototype.push,
        core_slice = Array.prototype.slice,
        core_indexOf = Array.prototype.indexOf,
        core_toString = Object.prototype.toString,
        core_hasOwn = Object.prototype.hasOwnProperty,
        core_trim = String.prototype.trim,
        jQuery = function(selector, context) { return new jQuery.fn.init(selector, context, rootjQuery); },
        core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,
        core_rnotwhite = /\S/,
        core_rspace = /\s+/,
        rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
        rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,
        rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
        rvalidchars = /^[\],:{}\s]*$/,
        rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
        rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
        rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,
        rmsPrefix = /^-ms-/,
        rdashAlpha = /-([\da-z])/gi,
        fcamelCase = function(all, letter) { return (letter + "").toUpperCase(); },
        DOMContentLoaded = function() { if (document.addEventListener) { document.removeEventListener("DOMContentLoaded", DOMContentLoaded, false);
                jQuery.ready(); } else if (document.readyState === "complete") { document.detachEvent("onreadystatechange", DOMContentLoaded);
                jQuery.ready(); } },
        class2type = {};
    jQuery.fn = jQuery.prototype = {
        constructor: jQuery,
        init: function(selector, context, rootjQuery) {
            var match, elem, ret, doc;
            if (!selector) { return this; }
            if (selector.nodeType) { this.context = this[0] = selector;
                this.length = 1; return this; }
            if (typeof selector === "string") {
                if (selector.charAt(0) === "<" && selector.charAt(selector.length - 1) === ">" && selector.length >= 3) { match = [null, selector, null]; } else { match = rquickExpr.exec(selector); }
                if (match && (match[1] || !context)) {
                    if (match[1]) {
                        context = context instanceof jQuery ? context[0] : context;
                        doc = (context && context.nodeType ? context.ownerDocument || context : document);
                        selector = jQuery.parseHTML(match[1], doc, true);
                        if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) { this.attr.call(selector, context, true); }
                        return jQuery.merge(this, selector);
                    } else {
                        elem = document.getElementById(match[2]);
                        if (elem && elem.parentNode) {
                            if (elem.id !== match[2]) { return rootjQuery.find(selector); }
                            this.length = 1;
                            this[0] = elem;
                        }
                        this.context = document;
                        this.selector = selector;
                        return this;
                    }
                } else if (!context || context.jquery) { return (context || rootjQuery).find(selector); } else { return this.constructor(context).find(selector); }
            } else if (jQuery.isFunction(selector)) { return rootjQuery.ready(selector); }
            if (selector.selector !== undefined) { this.selector = selector.selector;
                this.context = selector.context; }
            return jQuery.makeArray(selector, this);
        },
        selector: "",
        jquery: "1.8.3",
        length: 0,
        size: function() { return this.length; },
        toArray: function() { return core_slice.call(this); },
        get: function(num) { return num == null ? this.toArray() : (num < 0 ? this[this.length + num] : this[num]); },
        pushStack: function(elems, name, selector) {
            var ret = jQuery.merge(this.constructor(), elems);
            ret.prevObject = this;
            ret.context = this.context;
            if (name === "find") { ret.selector = this.selector + (this.selector ? " " : "") + selector; } else if (name) { ret.selector = this.selector + "." + name + "(" + selector + ")"; }
            return ret;
        },
        each: function(callback, args) { return jQuery.each(this, callback, args); },
        ready: function(fn) { jQuery.ready.promise().done(fn); return this; },
        eq: function(i) { i = +i; return i === -1 ? this.slice(i) : this.slice(i, i + 1); },
        first: function() { return this.eq(0); },
        last: function() { return this.eq(-1); },
        slice: function() { return this.pushStack(core_slice.apply(this, arguments), "slice", core_slice.call(arguments).join(",")); },
        map: function(callback) { return this.pushStack(jQuery.map(this, function(elem, i) { return callback.call(elem, i, elem); })); },
        end: function() { return this.prevObject || this.constructor(null); },
        push: core_push,
        sort: [].sort,
        splice: [].splice
    };
    jQuery.fn.init.prototype = jQuery.fn;
    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false;
        if (typeof target === "boolean") { deep = target;
            target = arguments[1] || {};
            i = 2; }
        if (typeof target !== "object" && !jQuery.isFunction(target)) { target = {}; }
        if (length === i) { target = this;--i; }
        for (; i < length; i++) {
            if ((options = arguments[i]) != null) {
                for (name in options) {
                    src = target[name];
                    copy = options[name];
                    if (target === copy) { continue; }
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                        if (copyIsArray) { copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : []; } else { clone = src && jQuery.isPlainObject(src) ? src : {}; }
                        target[name] = jQuery.extend(deep, clone, copy);
                    } else if (copy !== undefined) { target[name] = copy; }
                }
            }
        }
        return target;
    };
    jQuery.extend({
        noConflict: function(deep) {
            if (window.$ === jQuery) { window.$ = _$; }
            if (deep && window.jQuery === jQuery) { window.jQuery = _jQuery; }
            return jQuery;
        },
        isReady: false,
        readyWait: 1,
        holdReady: function(hold) { if (hold) { jQuery.readyWait++; } else { jQuery.ready(true); } },
        ready: function(wait) {
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) { return; }
            if (!document.body) { return setTimeout(jQuery.ready, 1); }
            jQuery.isReady = true;
            if (wait !== true && --jQuery.readyWait > 0) { return; }
            readyList.resolveWith(document, [jQuery]);
            if (jQuery.fn.trigger) { jQuery(document).trigger("ready").off("ready"); }
        },
        isFunction: function(obj) { return jQuery.type(obj) === "function"; },
        isArray: Array.isArray || function(obj) { return jQuery.type(obj) === "array"; },
        isWindow: function(obj) { return obj != null && obj == obj.window; },
        isNumeric: function(obj) { return !isNaN(parseFloat(obj)) && isFinite(obj); },
        type: function(obj) { return obj == null ? String(obj) : class2type[core_toString.call(obj)] || "object"; },
        isPlainObject: function(obj) {
            if (!obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) { return false; }
            try { if (obj.constructor && !core_hasOwn.call(obj, "constructor") && !core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) { return false; } } catch (e) { return false; }
            var key;
            for (key in obj) {}
            return key === undefined || core_hasOwn.call(obj, key);
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) { return false; }
            return true;
        },
        error: function(msg) { throw new Error(msg); },
        parseHTML: function(data, context, scripts) {
            var parsed;
            if (!data || typeof data !== "string") { return null; }
            if (typeof context === "boolean") { scripts = context;
                context = 0; }
            context = context || document;
            if ((parsed = rsingleTag.exec(data))) { return [context.createElement(parsed[1])]; }
            parsed = jQuery.buildFragment([data], context, scripts ? null : []);
            return jQuery.merge([], (parsed.cacheable ? jQuery.clone(parsed.fragment) : parsed.fragment).childNodes);
        },
        parseJSON: function(data) {
            if (!data || typeof data !== "string") { return null; }
            data = jQuery.trim(data);
            if (window.JSON && window.JSON.parse) { return window.JSON.parse(data); }
            if (rvalidchars.test(data.replace(rvalidescape, "@").replace(rvalidtokens, "]").replace(rvalidbraces, ""))) { return (new Function("return " + data))(); }
            jQuery.error("Invalid JSON: " + data);
        },
        parseXML: function(data) {
            var xml, tmp;
            if (!data || typeof data !== "string") { return null; }
            try { if (window.DOMParser) { tmp = new DOMParser();
                    xml = tmp.parseFromString(data, "text/xml"); } else { xml = new ActiveXObject("Microsoft.XMLDOM");
                    xml.async = "false";
                    xml.loadXML(data); } } catch (e) { xml = undefined; }
            if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) { jQuery.error("Invalid XML: " + data); }
            return xml;
        },
        noop: function() {},
        globalEval: function(data) { if (data && core_rnotwhite.test(data)) {
                (window.execScript || function(data) { window["eval"].call(window, data); })(data); } },
        camelCase: function(string) { return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase); },
        nodeName: function(elem, name) { return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase(); },
        each: function(obj, callback, args) {
            var name, i = 0,
                length = obj.length,
                isObj = length === undefined || jQuery.isFunction(obj);
            if (args) { if (isObj) { for (name in obj) { if (callback.apply(obj[name], args) === false) { break; } } } else { for (; i < length;) { if (callback.apply(obj[i++], args) === false) { break; } } } } else { if (isObj) { for (name in obj) { if (callback.call(obj[name], name, obj[name]) === false) { break; } } } else { for (; i < length;) { if (callback.call(obj[i], i, obj[i++]) === false) { break; } } } }
            return obj;
        },
        trim: core_trim && !core_trim.call("\uFEFF\xA0") ? function(text) { return text == null ? "" : core_trim.call(text); } : function(text) { return text == null ? "" : (text + "").replace(rtrim, ""); },
        makeArray: function(arr, results) {
            var type, ret = results || [];
            if (arr != null) { type = jQuery.type(arr); if (arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow(arr)) { core_push.call(ret, arr); } else { jQuery.merge(ret, arr); } }
            return ret;
        },
        inArray: function(elem, arr, i) {
            var len;
            if (arr) {
                if (core_indexOf) { return core_indexOf.call(arr, elem, i); }
                len = arr.length;
                i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
                for (; i < len; i++) { if (i in arr && arr[i] === elem) { return i; } }
            }
            return -1;
        },
        merge: function(first, second) {
            var l = second.length,
                i = first.length,
                j = 0;
            if (typeof l === "number") { for (; j < l; j++) { first[i++] = second[j]; } } else { while (second[j] !== undefined) { first[i++] = second[j++]; } }
            first.length = i;
            return first;
        },
        grep: function(elems, callback, inv) {
            var retVal, ret = [],
                i = 0,
                length = elems.length;
            inv = !!inv;
            for (; i < length; i++) { retVal = !!callback(elems[i], i); if (inv !== retVal) { ret.push(elems[i]); } }
            return ret;
        },
        map: function(elems, callback, arg) {
            var value, key, ret = [],
                i = 0,
                length = elems.length,
                isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ((length > 0 && elems[0] && elems[length - 1]) || length === 0 || jQuery.isArray(elems));
            if (isArray) { for (; i < length; i++) { value = callback(elems[i], i, arg); if (value != null) { ret[ret.length] = value; } } } else { for (key in elems) { value = callback(elems[key], key, arg); if (value != null) { ret[ret.length] = value; } } }
            return ret.concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if (typeof context === "string") { tmp = fn[context];
                context = fn;
                fn = tmp; }
            if (!jQuery.isFunction(fn)) { return undefined; }
            args = core_slice.call(arguments, 2);
            proxy = function() { return fn.apply(context, args.concat(core_slice.call(arguments))); };
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;
            return proxy;
        },
        access: function(elems, fn, key, value, chainable, emptyGet, pass) {
            var exec, bulk = key == null,
                i = 0,
                length = elems.length;
            if (key && typeof key === "object") {
                for (i in key) { jQuery.access(elems, fn, i, key[i], 1, emptyGet, value); }
                chainable = 1;
            } else if (value !== undefined) {
                exec = pass === undefined && jQuery.isFunction(value);
                if (bulk) { if (exec) { exec = fn;
                        fn = function(elem, key, value) { return exec.call(jQuery(elem), value); }; } else { fn.call(elems, value);
                        fn = null; } }
                if (fn) { for (; i < length; i++) { fn(elems[i], key, exec ? value.call(elems[i], i, fn(elems[i], key)) : value, pass); } }
                chainable = 1;
            }
            return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
        },
        now: function() { return (new Date()).getTime(); }
    });
    jQuery.ready.promise = function(obj) {
        if (!readyList) {
            readyList = jQuery.Deferred();
            if (document.readyState === "complete") { setTimeout(jQuery.ready, 1); } else if (document.addEventListener) { document.addEventListener("DOMContentLoaded", DOMContentLoaded, false);
                window.addEventListener("load", jQuery.ready, false); } else {
                document.attachEvent("onreadystatechange", DOMContentLoaded);
                window.attachEvent("onload", jQuery.ready);
                var top = false;
                try { top = window.frameElement == null && document.documentElement; } catch (e) {}
                if (top && top.doScroll) {
                    (function doScrollCheck() {
                        if (!jQuery.isReady) {
                            try { top.doScroll("left"); } catch (e) { return setTimeout(doScrollCheck, 50); }
                            jQuery.ready();
                        }
                    })();
                }
            }
        }
        return readyList.promise(obj);
    };
    jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) { class2type["[object " + name + "]"] = name.toLowerCase(); });
    rootjQuery = jQuery(document);
    var optionsCache = {};

    function createOptions(options) { var object = optionsCache[options] = {};
        jQuery.each(options.split(core_rspace), function(_, flag) { object[flag] = true; }); return object; }
    jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? (optionsCache[options] || createOptions(options)) : jQuery.extend({}, options);
        var
            memory, fired, firing, firingStart, firingLength, firingIndex, list = [],
            stack = !options.once && [],
            fire = function(data) {
                memory = options.memory && data;
                fired = true;
                firingIndex = firingStart || 0;
                firingStart = 0;
                firingLength = list.length;
                firing = true;
                for (; list && firingIndex < firingLength; firingIndex++) { if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) { memory = false; break; } }
                firing = false;
                if (list) { if (stack) { if (stack.length) { fire(stack.shift()); } } else if (memory) { list = []; } else { self.disable(); } }
            },
            self = {
                add: function() {
                    if (list) { var start = list.length;
                        (function add(args) { jQuery.each(args, function(_, arg) { var type = jQuery.type(arg); if (type === "function") { if (!options.unique || !self.has(arg)) { list.push(arg); } } else if (arg && arg.length && type !== "string") { add(arg); } }); })(arguments); if (firing) { firingLength = list.length; } else if (memory) { firingStart = start;
                            fire(memory); } }
                    return this;
                },
                remove: function() {
                    if (list) {
                        jQuery.each(arguments, function(_, arg) {
                            var index;
                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1);
                                if (firing) {
                                    if (index <= firingLength) { firingLength--; }
                                    if (index <= firingIndex) { firingIndex--; }
                                }
                            }
                        });
                    }
                    return this;
                },
                has: function(fn) { return jQuery.inArray(fn, list) > -1; },
                empty: function() { list = []; return this; },
                disable: function() { list = stack = memory = undefined; return this; },
                disabled: function() { return !list; },
                lock: function() {
                    stack = undefined;
                    if (!memory) { self.disable(); }
                    return this;
                },
                locked: function() { return !stack; },
                fireWith: function(context, args) {
                    args = args || [];
                    args = [context, args.slice ? args.slice() : args];
                    if (list && (!fired || stack)) { if (firing) { stack.push(args); } else { fire(args); } }
                    return this;
                },
                fire: function() { self.fireWith(this, arguments); return this; },
                fired: function() { return !!fired; }
            };
        return self;
    };
    jQuery.extend({
        Deferred: function(func) {
            var tuples = [
                    ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
                    ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
                    ["notify", "progress", jQuery.Callbacks("memory")]
                ],
                state = "pending",
                promise = { state: function() { return state; }, always: function() { deferred.done(arguments).fail(arguments); return this; }, then: function() { var fns = arguments; return jQuery.Deferred(function(newDefer) { jQuery.each(tuples, function(i, tuple) { var action = tuple[0],
                                    fn = fns[i];
                                deferred[tuple[1]](jQuery.isFunction(fn) ? function() { var returned = fn.apply(this, arguments); if (returned && jQuery.isFunction(returned.promise)) { returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify); } else { newDefer[action + "With"](this === deferred ? newDefer : this, [returned]); } } : newDefer[action]); });
                            fns = null; }).promise(); }, promise: function(obj) { return obj != null ? jQuery.extend(obj, promise) : promise; } },
                deferred = {};
            promise.pipe = promise.then;
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2],
                    stateString = tuple[3];
                promise[tuple[1]] = list.add;
                if (stateString) { list.add(function() { state = stateString; }, tuples[i ^ 1][2].disable, tuples[2][2].lock); }
                deferred[tuple[0]] = list.fire;
                deferred[tuple[0] + "With"] = list.fireWith;
            });
            promise.promise(deferred);
            if (func) { func.call(deferred, deferred); }
            return deferred;
        },
        when: function(subordinate) {
            var i = 0,
                resolveValues = core_slice.call(arguments),
                length = resolveValues.length,
                remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
                deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
                updateFunc = function(i, contexts, values) { return function(value) { contexts[i] = this;
                        values[i] = arguments.length > 1 ? core_slice.call(arguments) : value; if (values === progressValues) { deferred.notifyWith(contexts, values); } else if (!(--remaining)) { deferred.resolveWith(contexts, values); } }; },
                progressValues, progressContexts, resolveContexts;
            if (length > 1) { progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length); for (; i < length; i++) { if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) { resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues)); } else {--remaining; } } }
            if (!remaining) { deferred.resolveWith(resolveContexts, resolveValues); }
            return deferred.promise();
        }
    });
    jQuery.support = (function() {
        var support, all, a, select, opt, input, fragment, eventName, i, isSupported, clickFn, div = document.createElement("div");
        div.setAttribute("className", "t");
        div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
        all = div.getElementsByTagName("*");
        a = div.getElementsByTagName("a")[0];
        if (!all || !a || !all.length) { return {}; }
        select = document.createElement("select");
        opt = select.appendChild(document.createElement("option"));
        input = div.getElementsByTagName("input")[0];
        a.style.cssText = "top:1px;float:left;opacity:.5";
        support = { leadingWhitespace: (div.firstChild.nodeType === 3), tbody: !div.getElementsByTagName("tbody").length, htmlSerialize: !!div.getElementsByTagName("link").length, style: /top/.test(a.getAttribute("style")), hrefNormalized: (a.getAttribute("href") === "/a"), opacity: /^0.5/.test(a.style.opacity), cssFloat: !!a.style.cssFloat, checkOn: (input.value === "on"), optSelected: opt.selected, getSetAttribute: div.className !== "t", enctype: !!document.createElement("form").enctype, html5Clone: document.createElement("nav").cloneNode(true).outerHTML !== "<:nav></:nav>", boxModel: (document.compatMode === "CSS1Compat"), submitBubbles: true, changeBubbles: true, focusinBubbles: false, deleteExpando: true, noCloneEvent: true, inlineBlockNeedsLayout: false, shrinkWrapBlocks: false, reliableMarginRight: true, boxSizingReliable: true, pixelPosition: false };
        input.checked = true;
        support.noCloneChecked = input.cloneNode(true).checked;
        select.disabled = true;
        support.optDisabled = !opt.disabled;
        try { delete div.test; } catch (e) { support.deleteExpando = false; }
        if (!div.addEventListener && div.attachEvent && div.fireEvent) { div.attachEvent("onclick", clickFn = function() { support.noCloneEvent = false; });
            div.cloneNode(true).fireEvent("onclick");
            div.detachEvent("onclick", clickFn); }
        input = document.createElement("input");
        input.value = "t";
        input.setAttribute("type", "radio");
        support.radioValue = input.value === "t";
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        fragment = document.createDocumentFragment();
        fragment.appendChild(div.lastChild);
        support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;
        support.appendChecked = input.checked;
        fragment.removeChild(input);
        fragment.appendChild(div);
        if (div.attachEvent) {
            for (i in { submit: true, change: true, focusin: true }) {
                eventName = "on" + i;
                isSupported = (eventName in div);
                if (!isSupported) { div.setAttribute(eventName, "return;");
                    isSupported = (typeof div[eventName] === "function"); }
                support[i + "Bubbles"] = isSupported;
            }
        }
        jQuery(function() {
            var container, div, tds, marginDiv, divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
                body = document.getElementsByTagName("body")[0];
            if (!body) { return; }
            container = document.createElement("div");
            container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
            body.insertBefore(container, body.firstChild);
            div = document.createElement("div");
            container.appendChild(div);
            div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
            tds = div.getElementsByTagName("td");
            tds[0].style.cssText = "padding:0;margin:0;border:0;display:none";
            isSupported = (tds[0].offsetHeight === 0);
            tds[0].style.display = "";
            tds[1].style.display = "none";
            support.reliableHiddenOffsets = isSupported && (tds[0].offsetHeight === 0);
            div.innerHTML = "";
            div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
            support.boxSizing = (div.offsetWidth === 4);
            support.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== 1);
            if (window.getComputedStyle) { support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== "1%";
                support.boxSizingReliable = (window.getComputedStyle(div, null) || { width: "4px" }).width === "4px";
                marginDiv = document.createElement("div");
                marginDiv.style.cssText = div.style.cssText = divReset;
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";
                div.appendChild(marginDiv);
                support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight); }
            if (typeof div.style.zoom !== "undefined") { div.innerHTML = "";
                div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
                support.inlineBlockNeedsLayout = (div.offsetWidth === 3);
                div.style.display = "block";
                div.style.overflow = "visible";
                div.innerHTML = "<div></div>";
                div.firstChild.style.width = "5px";
                support.shrinkWrapBlocks = (div.offsetWidth !== 3);
                container.style.zoom = 1; }
            body.removeChild(container);
            container = div = tds = marginDiv = null;
        });
        fragment.removeChild(div);
        all = a = select = opt = input = fragment = div = null;
        return support;
    })();
    var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
        rmultiDash = /([A-Z])/g;
    jQuery.extend({
        cache: {},
        deletedIds: [],
        uuid: 0,
        expando: "jQuery" + (jQuery.fn.jquery + Math.random()).replace(/\D/g, ""),
        noData: { "embed": true, "object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000", "applet": true },
        hasData: function(elem) { elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando]; return !!elem && !isEmptyDataObject(elem); },
        data: function(elem, name, data, pvt) {
            if (!jQuery.acceptData(elem)) { return; }
            var thisCache, ret, internalKey = jQuery.expando,
                getByName = typeof name === "string",
                isNode = elem.nodeType,
                cache = isNode ? jQuery.cache : elem,
                id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;
            if ((!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined) { return; }
            if (!id) { if (isNode) { elem[internalKey] = id = jQuery.deletedIds.pop() || jQuery.guid++; } else { id = internalKey; } }
            if (!cache[id]) { cache[id] = {}; if (!isNode) { cache[id].toJSON = jQuery.noop; } }
            if (typeof name === "object" || typeof name === "function") { if (pvt) { cache[id] = jQuery.extend(cache[id], name); } else { cache[id].data = jQuery.extend(cache[id].data, name); } }
            thisCache = cache[id];
            if (!pvt) {
                if (!thisCache.data) { thisCache.data = {}; }
                thisCache = thisCache.data;
            }
            if (data !== undefined) { thisCache[jQuery.camelCase(name)] = data; }
            if (getByName) { ret = thisCache[name]; if (ret == null) { ret = thisCache[jQuery.camelCase(name)]; } } else { ret = thisCache; }
            return ret;
        },
        removeData: function(elem, name, pvt) {
            if (!jQuery.acceptData(elem)) { return; }
            var thisCache, i, l, isNode = elem.nodeType,
                cache = isNode ? jQuery.cache : elem,
                id = isNode ? elem[jQuery.expando] : jQuery.expando;
            if (!cache[id]) { return; }
            if (name) {
                thisCache = pvt ? cache[id] : cache[id].data;
                if (thisCache) {
                    if (!jQuery.isArray(name)) { if (name in thisCache) { name = [name]; } else { name = jQuery.camelCase(name); if (name in thisCache) { name = [name]; } else { name = name.split(" "); } } }
                    for (i = 0, l = name.length; i < l; i++) { delete thisCache[name[i]]; }
                    if (!(pvt ? isEmptyDataObject : jQuery.isEmptyObject)(thisCache)) { return; }
                }
            }
            if (!pvt) { delete cache[id].data; if (!isEmptyDataObject(cache[id])) { return; } }
            if (isNode) { jQuery.cleanData([elem], true); } else if (jQuery.support.deleteExpando || cache != cache.window) { delete cache[id]; } else { cache[id] = null; }
        },
        _data: function(elem, name, data) { return jQuery.data(elem, name, data, true); },
        acceptData: function(elem) { var noData = elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]; return !noData || noData !== true && elem.getAttribute("classid") === noData; }
    });
    jQuery.fn.extend({
        data: function(key, value) {
            var parts, part, attr, name, l, elem = this[0],
                i = 0,
                data = null;
            if (key === undefined) {
                if (this.length) {
                    data = jQuery.data(elem);
                    if (elem.nodeType === 1 && !jQuery._data(elem, "parsedAttrs")) {
                        attr = elem.attributes;
                        for (l = attr.length; i < l; i++) { name = attr[i].name; if (!name.indexOf("data-")) { name = jQuery.camelCase(name.substring(5));
                                dataAttr(elem, name, data[name]); } }
                        jQuery._data(elem, "parsedAttrs", true);
                    }
                }
                return data;
            }
            if (typeof key === "object") { return this.each(function() { jQuery.data(this, key); }); }
            parts = key.split(".", 2);
            parts[1] = parts[1] ? "." + parts[1] : "";
            part = parts[1] + "!";
            return jQuery.access(this, function(value) {
                if (value === undefined) {
                    data = this.triggerHandler("getData" + part, [parts[0]]);
                    if (data === undefined && elem) { data = jQuery.data(elem, key);
                        data = dataAttr(elem, key, data); }
                    return data === undefined && parts[1] ? this.data(parts[0]) : data;
                }
                parts[1] = value;
                this.each(function() { var self = jQuery(this);
                    self.triggerHandler("setData" + part, parts);
                    jQuery.data(this, key, value);
                    self.triggerHandler("changeData" + part, parts); });
            }, null, value, arguments.length > 1, null, false);
        },
        removeData: function(key) { return this.each(function() { jQuery.removeData(this, key); }); }
    });

    function dataAttr(elem, key, data) {
        if (data === undefined && elem.nodeType === 1) {
            var name = "data-" + key.replace(rmultiDash, "-$1").toLowerCase();
            data = elem.getAttribute(name);
            if (typeof data === "string") {
                try { data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data; } catch (e) {}
                jQuery.data(elem, key, data);
            } else { data = undefined; }
        }
        return data;
    }

    function isEmptyDataObject(obj) {
        var name;
        for (name in obj) {
            if (name === "data" && jQuery.isEmptyObject(obj[name])) { continue; }
            if (name !== "toJSON") { return false; }
        }
        return true;
    }
    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) {
                type = (type || "fx") + "queue";
                queue = jQuery._data(elem, type);
                if (data) { if (!queue || jQuery.isArray(data)) { queue = jQuery._data(elem, type, jQuery.makeArray(data)); } else { queue.push(data); } }
                return queue || [];
            }
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type),
                startLength = queue.length,
                fn = queue.shift(),
                hooks = jQuery._queueHooks(elem, type),
                next = function() { jQuery.dequeue(elem, type); };
            if (fn === "inprogress") { fn = queue.shift();
                startLength--; }
            if (fn) {
                if (type === "fx") { queue.unshift("inprogress"); }
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }
            if (!startLength && hooks) { hooks.empty.fire(); }
        },
        _queueHooks: function(elem, type) { var key = type + "queueHooks"; return jQuery._data(elem, key) || jQuery._data(elem, key, { empty: jQuery.Callbacks("once memory").add(function() { jQuery.removeData(elem, type + "queue", true);
                    jQuery.removeData(elem, key, true); }) }); }
    });
    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            if (typeof type !== "string") { data = type;
                type = "fx";
                setter--; }
            if (arguments.length < setter) { return jQuery.queue(this[0], type); }
            return data === undefined ? this : this.each(function() { var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type); if (type === "fx" && queue[0] !== "inprogress") { jQuery.dequeue(this, type); } });
        },
        dequeue: function(type) { return this.each(function() { jQuery.dequeue(this, type); }); },
        delay: function(time, type) { time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || "fx"; return this.queue(type, function(next, hooks) { var timeout = setTimeout(next, time);
                hooks.stop = function() { clearTimeout(timeout); }; }); },
        clearQueue: function(type) { return this.queue(type || "fx", []); },
        promise: function(type, obj) {
            var tmp, count = 1,
                defer = jQuery.Deferred(),
                elements = this,
                i = this.length,
                resolve = function() { if (!(--count)) { defer.resolveWith(elements, [elements]); } };
            if (typeof type !== "string") { obj = type;
                type = undefined; }
            type = type || "fx";
            while (i--) { tmp = jQuery._data(elements[i], type + "queueHooks"); if (tmp && tmp.empty) { count++;
                    tmp.empty.add(resolve); } }
            resolve();
            return defer.promise(obj);
        }
    });
    var nodeHook, boolHook, fixSpecified, rclass = /[\t\r\n]/g,
        rreturn = /\r/g,
        rtype = /^(?:button|input)$/i,
        rfocusable = /^(?:button|input|object|select|textarea)$/i,
        rclickable = /^a(?:rea|)$/i,
        rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
        getSetAttribute = jQuery.support.getSetAttribute;
    jQuery.fn.extend({
        attr: function(name, value) { return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1); },
        removeAttr: function(name) { return this.each(function() { jQuery.removeAttr(this, name); }); },
        prop: function(name, value) { return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1); },
        removeProp: function(name) { name = jQuery.propFix[name] || name; return this.each(function() { try { this[name] = undefined;
                    delete this[name]; } catch (e) {} }); },
        addClass: function(value) {
            var classNames, i, l, elem, setClass, c, cl;
            if (jQuery.isFunction(value)) { return this.each(function(j) { jQuery(this).addClass(value.call(this, j, this.className)); }); }
            if (value && typeof value === "string") {
                classNames = value.split(core_rspace);
                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];
                    if (elem.nodeType === 1) {
                        if (!elem.className && classNames.length === 1) { elem.className = value; } else {
                            setClass = " " + elem.className + " ";
                            for (c = 0, cl = classNames.length; c < cl; c++) { if (setClass.indexOf(" " + classNames[c] + " ") < 0) { setClass += classNames[c] + " "; } }
                            elem.className = jQuery.trim(setClass);
                        }
                    }
                }
            }
            return this;
        },
        removeClass: function(value) {
            var removes, className, elem, c, cl, i, l;
            if (jQuery.isFunction(value)) { return this.each(function(j) { jQuery(this).removeClass(value.call(this, j, this.className)); }); }
            if ((value && typeof value === "string") || value === undefined) {
                removes = (value || "").split(core_rspace);
                for (i = 0, l = this.length; i < l; i++) {
                    elem = this[i];
                    if (elem.nodeType === 1 && elem.className) {
                        className = (" " + elem.className + " ").replace(rclass, " ");
                        for (c = 0, cl = removes.length; c < cl; c++) { while (className.indexOf(" " + removes[c] + " ") >= 0) { className = className.replace(" " + removes[c] + " ", " "); } }
                        elem.className = value ? jQuery.trim(className) : "";
                    }
                }
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value,
                isBool = typeof stateVal === "boolean";
            if (jQuery.isFunction(value)) { return this.each(function(i) { jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal); }); }
            return this.each(function() {
                if (type === "string") { var className, i = 0,
                        self = jQuery(this),
                        state = stateVal,
                        classNames = value.split(core_rspace); while ((className = classNames[i++])) { state = isBool ? state : !self.hasClass(className);
                        self[state ? "addClass" : "removeClass"](className); } } else if (type === "undefined" || type === "boolean") {
                    if (this.className) { jQuery._data(this, "__className__", this.className); }
                    this.className = this.className || value === false ? "" : jQuery._data(this, "__className__") || "";
                }
            });
        },
        hasClass: function(selector) {
            var className = " " + selector + " ",
                i = 0,
                l = this.length;
            for (; i < l; i++) { if (this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf(className) >= 0) { return true; } }
            return false;
        },
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                    if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) { return ret; }
                    ret = elem.value;
                    return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
                }
                return;
            }
            isFunction = jQuery.isFunction(value);
            return this.each(function(i) {
                var val, self = jQuery(this);
                if (this.nodeType !== 1) { return; }
                if (isFunction) { val = value.call(this, i, self.val()); } else { val = value; }
                if (val == null) { val = ""; } else if (typeof val === "number") { val += ""; } else if (jQuery.isArray(val)) { val = jQuery.map(val, function(value) { return value == null ? "" : value + ""; }); }
                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) { this.value = val; }
            });
        }
    });
    jQuery.extend({
        valHooks: {
            option: { get: function(elem) { var val = elem.attributes.value; return !val || val.specified ? elem.value : elem.text; } },
            select: {
                get: function(elem) {
                    var value, option, options = elem.options,
                        index = elem.selectedIndex,
                        one = elem.type === "select-one" || index < 0,
                        values = one ? null : [],
                        max = one ? index + 1 : options.length,
                        i = index < 0 ? max : one ? index : 0;
                    for (; i < max; i++) {
                        option = options[i];
                        if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            value = jQuery(option).val();
                            if (one) { return value; }
                            values.push(value);
                        }
                    }
                    return values;
                },
                set: function(elem, value) {
                    var values = jQuery.makeArray(value);
                    jQuery(elem).find("option").each(function() { this.selected = jQuery.inArray(jQuery(this).val(), values) >= 0; });
                    if (!values.length) { elem.selectedIndex = -1; }
                    return values;
                }
            }
        },
        attrFn: {},
        attr: function(elem, name, value, pass) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) { return; }
            if (pass && jQuery.isFunction(jQuery.fn[name])) { return jQuery(elem)[name](value); }
            if (typeof elem.getAttribute === "undefined") { return jQuery.prop(elem, name, value); }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) { name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (rboolean.test(name) ? boolHook : nodeHook); }
            if (value !== undefined) { if (value === null) { jQuery.removeAttr(elem, name); return; } else if (hooks && "set" in hooks && notxml && (ret = hooks.set(elem, value, name)) !== undefined) { return ret; } else { elem.setAttribute(name, value + ""); return value; } } else if (hooks && "get" in hooks && notxml && (ret = hooks.get(elem, name)) !== null) { return ret; } else { ret = elem.getAttribute(name); return ret === null ? undefined : ret; }
        },
        removeAttr: function(elem, value) {
            var propName, attrNames, name, isBool, i = 0;
            if (value && elem.nodeType === 1) {
                attrNames = value.split(core_rspace);
                for (; i < attrNames.length; i++) {
                    name = attrNames[i];
                    if (name) {
                        propName = jQuery.propFix[name] || name;
                        isBool = rboolean.test(name);
                        if (!isBool) { jQuery.attr(elem, name, ""); }
                        elem.removeAttribute(getSetAttribute ? name : propName);
                        if (isBool && propName in elem) { elem[propName] = false; }
                    }
                }
            }
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (rtype.test(elem.nodeName) && elem.parentNode) { jQuery.error("type property can't be changed"); } else if (!jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) { elem.value = val; }
                        return value;
                    }
                }
            },
            value: {
                get: function(elem, name) {
                    if (nodeHook && jQuery.nodeName(elem, "button")) { return nodeHook.get(elem, name); }
                    return name in elem ? elem.value : null;
                },
                set: function(elem, value, name) {
                    if (nodeHook && jQuery.nodeName(elem, "button")) { return nodeHook.set(elem, value, name); }
                    elem.value = value;
                }
            }
        },
        propFix: { tabindex: "tabIndex", readonly: "readOnly", "for": "htmlFor", "class": "className", maxlength: "maxLength", cellspacing: "cellSpacing", cellpadding: "cellPadding", rowspan: "rowSpan", colspan: "colSpan", usemap: "useMap", frameborder: "frameBorder", contenteditable: "contentEditable" },
        prop: function(elem, name, value) {
            var ret, hooks, notxml, nType = elem.nodeType;
            if (!elem || nType === 3 || nType === 8 || nType === 2) { return; }
            notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
            if (notxml) { name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name]; }
            if (value !== undefined) { if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) { return ret; } else { return (elem[name] = value); } } else { if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) { return ret; } else { return elem[name]; } }
        },
        propHooks: { tabIndex: { get: function(elem) { var attributeNode = elem.getAttributeNode("tabindex"); return attributeNode && attributeNode.specified ? parseInt(attributeNode.value, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : undefined; } } }
    });
    boolHook = {
        get: function(elem, name) { var attrNode, property = jQuery.prop(elem, name); return property === true || typeof property !== "boolean" && (attrNode = elem.getAttributeNode(name)) && attrNode.nodeValue !== false ? name.toLowerCase() : undefined; },
        set: function(elem, value, name) {
            var propName;
            if (value === false) { jQuery.removeAttr(elem, name); } else {
                propName = jQuery.propFix[name] || name;
                if (propName in elem) { elem[propName] = true; }
                elem.setAttribute(name, name.toLowerCase());
            }
            return name;
        }
    };
    if (!getSetAttribute) {
        fixSpecified = { name: true, id: true, coords: true };
        nodeHook = jQuery.valHooks.button = {
            get: function(elem, name) { var ret;
                ret = elem.getAttributeNode(name); return ret && (fixSpecified[name] ? ret.value !== "" : ret.specified) ? ret.value : undefined; },
            set: function(elem, value, name) {
                var ret = elem.getAttributeNode(name);
                if (!ret) { ret = document.createAttribute(name);
                    elem.setAttributeNode(ret); }
                return (ret.value = value + "");
            }
        };
        jQuery.each(["width", "height"], function(i, name) { jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], { set: function(elem, value) { if (value === "") { elem.setAttribute(name, "auto"); return value; } } }); });
        jQuery.attrHooks.contenteditable = {
            get: nodeHook.get,
            set: function(elem, value, name) {
                if (value === "") { value = "false"; }
                nodeHook.set(elem, value, name);
            }
        };
    }
    if (!jQuery.support.hrefNormalized) { jQuery.each(["href", "src", "width", "height"], function(i, name) { jQuery.attrHooks[name] = jQuery.extend(jQuery.attrHooks[name], { get: function(elem) { var ret = elem.getAttribute(name, 2); return ret === null ? undefined : ret; } }); }); }
    if (!jQuery.support.style) { jQuery.attrHooks.style = { get: function(elem) { return elem.style.cssText.toLowerCase() || undefined; }, set: function(elem, value) { return (elem.style.cssText = value + ""); } }; }
    if (!jQuery.support.optSelected) {
        jQuery.propHooks.selected = jQuery.extend(jQuery.propHooks.selected, {
            get: function(elem) {
                var parent = elem.parentNode;
                if (parent) { parent.selectedIndex; if (parent.parentNode) { parent.parentNode.selectedIndex; } }
                return null;
            }
        });
    }
    if (!jQuery.support.enctype) { jQuery.propFix.enctype = "encoding"; }
    if (!jQuery.support.checkOn) { jQuery.each(["radio", "checkbox"], function() { jQuery.valHooks[this] = { get: function(elem) { return elem.getAttribute("value") === null ? "on" : elem.value; } }; }); }
    jQuery.each(["radio", "checkbox"], function() { jQuery.valHooks[this] = jQuery.extend(jQuery.valHooks[this], { set: function(elem, value) { if (jQuery.isArray(value)) { return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0); } } }); });
    var rformElems = /^(?:textarea|input|select)$/i,
        rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
        rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
        rkeyEvent = /^key/,
        rmouseEvent = /^(?:mouse|contextmenu)|click/,
        rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        hoverHack = function(events) { return jQuery.event.special.hover ? events : events.replace(rhoverHack, "mouseenter$1 mouseleave$1"); };
    jQuery.event = {
        add: function(elem, types, handler, data, selector) {
            var elemData, eventHandle, events, t, tns, type, namespaces, handleObj, handleObjIn, handlers, special;
            if (elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data(elem))) { return; }
            if (handler.handler) { handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector; }
            if (!handler.guid) { handler.guid = jQuery.guid++; }
            events = elemData.events;
            if (!events) { elemData.events = events = {}; }
            eventHandle = elemData.handle;
            if (!eventHandle) { elemData.handle = eventHandle = function(e) { return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined; };
                eventHandle.elem = elem; }
            types = jQuery.trim(hoverHack(types)).split(" ");
            for (t = 0; t < types.length; t++) {
                tns = rtypenamespace.exec(types[t]) || [];
                type = tns[1];
                namespaces = (tns[2] || "").split(".").sort();
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                special = jQuery.event.special[type] || {};
                handleObj = jQuery.extend({ type: type, origType: tns[1], data: data, handler: handler, guid: handler.guid, selector: selector, needsContext: selector && jQuery.expr.match.needsContext.test(selector), namespace: namespaces.join(".") }, handleObjIn);
                handlers = events[type];
                if (!handlers) { handlers = events[type] = [];
                    handlers.delegateCount = 0; if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) { if (elem.addEventListener) { elem.addEventListener(type, eventHandle, false); } else if (elem.attachEvent) { elem.attachEvent("on" + type, eventHandle); } } }
                if (special.add) { special.add.call(elem, handleObj); if (!handleObj.handler.guid) { handleObj.handler.guid = handler.guid; } }
                if (selector) { handlers.splice(handlers.delegateCount++, 0, handleObj); } else { handlers.push(handleObj); }
                jQuery.event.global[type] = true;
            }
            elem = null;
        },
        global: {},
        remove: function(elem, types, handler, selector, mappedTypes) {
            var t, tns, type, origType, namespaces, origCount, j, events, special, eventType, handleObj, elemData = jQuery.hasData(elem) && jQuery._data(elem);
            if (!elemData || !(events = elemData.events)) { return; }
            types = jQuery.trim(hoverHack(types || "")).split(" ");
            for (t = 0; t < types.length; t++) {
                tns = rtypenamespace.exec(types[t]) || [];
                type = origType = tns[1];
                namespaces = tns[2];
                if (!type) {
                    for (type in events) { jQuery.event.remove(elem, type + types[t], handler, selector, true); }
                    continue;
                }
                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                eventType = events[type] || [];
                origCount = eventType.length;
                namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
                for (j = 0; j < eventType.length; j++) {
                    handleObj = eventType[j];
                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!namespaces || namespaces.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        eventType.splice(j--, 1);
                        if (handleObj.selector) { eventType.delegateCount--; }
                        if (special.remove) { special.remove.call(elem, handleObj); }
                    }
                }
                if (eventType.length === 0 && origCount !== eventType.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) { jQuery.removeEvent(elem, type, elemData.handle); }
                    delete events[type];
                }
            }
            if (jQuery.isEmptyObject(events)) { delete elemData.handle;
                jQuery.removeData(elem, "events", true); }
        },
        customEvent: { "getData": true, "setData": true, "changeData": true },
        trigger: function(event, data, elem, onlyHandlers) {
            if (elem && (elem.nodeType === 3 || elem.nodeType === 8)) { return; }
            var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType, type = event.type || event,
                namespaces = [];
            if (rfocusMorph.test(type + jQuery.event.triggered)) { return; }
            if (type.indexOf("!") >= 0) { type = type.slice(0, -1);
                exclusive = true; }
            if (type.indexOf(".") >= 0) { namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort(); }
            if ((!elem || jQuery.event.customEvent[type]) && !jQuery.event.global[type]) { return; }
            event = typeof event === "object" ? event[jQuery.expando] ? event : new jQuery.Event(type, event) : new jQuery.Event(type);
            event.type = type;
            event.isTrigger = true;
            event.exclusive = exclusive;
            event.namespace = namespaces.join(".");
            event.namespace_re = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
            ontype = type.indexOf(":") < 0 ? "on" + type : "";
            if (!elem) {
                cache = jQuery.cache;
                for (i in cache) { if (cache[i].events && cache[i].events[type]) { jQuery.event.trigger(event, data, cache[i].handle.elem, true); } }
                return;
            }
            event.result = undefined;
            if (!event.target) { event.target = elem; }
            data = data != null ? jQuery.makeArray(data) : [];
            data.unshift(event);
            special = jQuery.event.special[type] || {};
            if (special.trigger && special.trigger.apply(elem, data) === false) { return; }
            eventPath = [
                [elem, special.bindType || type]
            ];
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                bubbleType = special.delegateType || type;
                cur = rfocusMorph.test(bubbleType + type) ? elem : elem.parentNode;
                for (old = elem; cur; cur = cur.parentNode) { eventPath.push([cur, bubbleType]);
                    old = cur; }
                if (old === (elem.ownerDocument || document)) { eventPath.push([old.defaultView || old.parentWindow || window, bubbleType]); }
            }
            for (i = 0; i < eventPath.length && !event.isPropagationStopped(); i++) {
                cur = eventPath[i][0];
                event.type = eventPath[i][1];
                handle = (jQuery._data(cur, "events") || {})[event.type] && jQuery._data(cur, "handle");
                if (handle) { handle.apply(cur, data); }
                handle = ontype && cur[ontype];
                if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) { event.preventDefault(); }
            }
            event.type = type;
            if (!onlyHandlers && !event.isDefaultPrevented()) {
                if ((!special._default || special._default.apply(elem.ownerDocument, data) === false) && !(type === "click" && jQuery.nodeName(elem, "a")) && jQuery.acceptData(elem)) {
                    if (ontype && elem[type] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow(elem)) {
                        old = elem[ontype];
                        if (old) { elem[ontype] = null; }
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;
                        if (old) { elem[ontype] = old; }
                    }
                }
            }
            return event.result;
        },
        dispatch: function(event) {
            event = jQuery.event.fix(event || window.event);
            var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related, handlers = ((jQuery._data(this, "events") || {})[event.type] || []),
                delegateCount = handlers.delegateCount,
                args = core_slice.call(arguments),
                run_all = !event.exclusive && !event.namespace,
                special = jQuery.event.special[event.type] || {},
                handlerQueue = [];
            args[0] = event;
            event.delegateTarget = this;
            if (special.preDispatch && special.preDispatch.call(this, event) === false) { return; }
            if (delegateCount && !(event.button && event.type === "click")) {
                for (cur = event.target; cur != this; cur = cur.parentNode || this) {
                    if (cur.disabled !== true || event.type !== "click") {
                        selMatch = {};
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];
                            sel = handleObj.selector;
                            if (selMatch[sel] === undefined) { selMatch[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length; }
                            if (selMatch[sel]) { matches.push(handleObj); }
                        }
                        if (matches.length) { handlerQueue.push({ elem: cur, matches: matches }); }
                    }
                }
            }
            if (handlers.length > delegateCount) { handlerQueue.push({ elem: this, matches: handlers.slice(delegateCount) }); }
            for (i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++) { matched = handlerQueue[i];
                event.currentTarget = matched.elem; for (j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++) { handleObj = matched.matches[j]; if (run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test(handleObj.namespace)) { event.data = handleObj.data;
                        event.handleObj = handleObj;
                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args); if (ret !== undefined) { event.result = ret; if (ret === false) { event.preventDefault();
                                event.stopPropagation(); } } } } }
            if (special.postDispatch) { special.postDispatch.call(this, event); }
            return event.result;
        },
        props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {
                if (event.which == null) { event.which = original.charCode != null ? original.charCode : original.keyCode; }
                return event;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body, button = original.button,
                    fromElement = original.fromElement;
                if (event.pageX == null && original.clientX != null) { eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;
                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0); }
                if (!event.relatedTarget && fromElement) { event.relatedTarget = fromElement === event.target ? original.toElement : fromElement; }
                if (!event.which && button !== undefined) { event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0))); }
                return event;
            }
        },
        fix: function(event) {
            if (event[jQuery.expando]) { return event; }
            var i, prop, originalEvent = event,
                fixHook = jQuery.event.fixHooks[event.type] || {},
                copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
            event = jQuery.Event(originalEvent);
            for (i = copy.length; i;) { prop = copy[--i];
                event[prop] = originalEvent[prop]; }
            if (!event.target) { event.target = originalEvent.srcElement || document; }
            if (event.target.nodeType === 3) { event.target = event.target.parentNode; }
            event.metaKey = !!event.metaKey;
            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },
        special: { load: { noBubble: true }, focus: { delegateType: "focusin" }, blur: { delegateType: "focusout" }, beforeunload: { setup: function(data, namespaces, eventHandle) { if (jQuery.isWindow(this)) { this.onbeforeunload = eventHandle; } }, teardown: function(namespaces, eventHandle) { if (this.onbeforeunload === eventHandle) { this.onbeforeunload = null; } } } },
        simulate: function(type, elem, event, bubble) {
            var e = jQuery.extend(new jQuery.Event(), event, { type: type, isSimulated: true, originalEvent: {} });
            if (bubble) { jQuery.event.trigger(e, null, elem); } else { jQuery.event.dispatch.call(elem, e); }
            if (e.isDefaultPrevented()) { event.preventDefault(); }
        }
    };
    jQuery.event.handle = jQuery.event.dispatch;
    jQuery.removeEvent = document.removeEventListener ? function(elem, type, handle) { if (elem.removeEventListener) { elem.removeEventListener(type, handle, false); } } : function(elem, type, handle) {
        var name = "on" + type;
        if (elem.detachEvent) {
            if (typeof elem[name] === "undefined") { elem[name] = null; }
            elem.detachEvent(name, handle);
        }
    };
    jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) { return new jQuery.Event(src, props); }
        if (src && src.type) { this.originalEvent = src;
            this.type = src.type;
            this.isDefaultPrevented = (src.defaultPrevented || src.returnValue === false || src.getPreventDefault && src.getPreventDefault()) ? returnTrue : returnFalse; } else { this.type = src; }
        if (props) { jQuery.extend(this, props); }
        this.timeStamp = src && src.timeStamp || jQuery.now();
        this[jQuery.expando] = true;
    };

    function returnFalse() { return false; }

    function returnTrue() { return true; }
    jQuery.Event.prototype = {
        preventDefault: function() {
            this.isDefaultPrevented = returnTrue;
            var e = this.originalEvent;
            if (!e) { return; }
            if (e.preventDefault) { e.preventDefault(); } else { e.returnValue = false; }
        },
        stopPropagation: function() {
            this.isPropagationStopped = returnTrue;
            var e = this.originalEvent;
            if (!e) { return; }
            if (e.stopPropagation) { e.stopPropagation(); }
            e.cancelBubble = true;
        },
        stopImmediatePropagation: function() { this.isImmediatePropagationStopped = returnTrue;
            this.stopPropagation(); },
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse
    };
    jQuery.each({ mouseenter: "mouseover", mouseleave: "mouseout" }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this,
                    related = event.relatedTarget,
                    handleObj = event.handleObj,
                    selector = handleObj.selector;
                if (!related || (related !== target && !jQuery.contains(target, related))) { event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix; }
                return ret;
            }
        };
    });
    if (!jQuery.support.submitBubbles) {
        jQuery.event.special.submit = {
            setup: function() {
                if (jQuery.nodeName(this, "form")) { return false; }
                jQuery.event.add(this, "click._submit keypress._submit", function(e) { var elem = e.target,
                        form = jQuery.nodeName(elem, "input") || jQuery.nodeName(elem, "button") ? elem.form : undefined; if (form && !jQuery._data(form, "_submit_attached")) { jQuery.event.add(form, "submit._submit", function(event) { event._submit_bubble = true; });
                        jQuery._data(form, "_submit_attached", true); } });
            },
            postDispatch: function(event) { if (event._submit_bubble) { delete event._submit_bubble; if (this.parentNode && !event.isTrigger) { jQuery.event.simulate("submit", this.parentNode, event, true); } } },
            teardown: function() {
                if (jQuery.nodeName(this, "form")) { return false; }
                jQuery.event.remove(this, "._submit");
            }
        };
    }
    if (!jQuery.support.changeBubbles) {
        jQuery.event.special.change = {
            setup: function() {
                if (rformElems.test(this.nodeName)) {
                    if (this.type === "checkbox" || this.type === "radio") {
                        jQuery.event.add(this, "propertychange._change", function(event) { if (event.originalEvent.propertyName === "checked") { this._just_changed = true; } });
                        jQuery.event.add(this, "click._change", function(event) {
                            if (this._just_changed && !event.isTrigger) { this._just_changed = false; }
                            jQuery.event.simulate("change", this, event, true);
                        });
                    }
                    return false;
                }
                jQuery.event.add(this, "beforeactivate._change", function(e) { var elem = e.target; if (rformElems.test(elem.nodeName) && !jQuery._data(elem, "_change_attached")) { jQuery.event.add(elem, "change._change", function(event) { if (this.parentNode && !event.isSimulated && !event.isTrigger) { jQuery.event.simulate("change", this.parentNode, event, true); } });
                        jQuery._data(elem, "_change_attached", true); } });
            },
            handle: function(event) { var elem = event.target; if (this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox")) { return event.handleObj.handler.apply(this, arguments); } },
            teardown: function() { jQuery.event.remove(this, "._change"); return !rformElems.test(this.nodeName); }
        };
    }
    if (!jQuery.support.focusinBubbles) { jQuery.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) { var attaches = 0,
                handler = function(event) { jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true); };
            jQuery.event.special[fix] = { setup: function() { if (attaches++ === 0) { document.addEventListener(orig, handler, true); } }, teardown: function() { if (--attaches === 0) { document.removeEventListener(orig, handler, true); } } }; }); }
    jQuery.fn.extend({
        on: function(types, selector, data, fn, one) {
            var origFn, type;
            if (typeof types === "object") {
                if (typeof selector !== "string") { data = data || selector;
                    selector = undefined; }
                for (type in types) { this.on(type, selector, data, types[type], one); }
                return this;
            }
            if (data == null && fn == null) { fn = selector;
                data = selector = undefined; } else if (fn == null) { if (typeof selector === "string") { fn = data;
                    data = undefined; } else { fn = data;
                    data = selector;
                    selector = undefined; } }
            if (fn === false) { fn = returnFalse; } else if (!fn) { return this; }
            if (one === 1) { origFn = fn;
                fn = function(event) { jQuery().off(event); return origFn.apply(this, arguments); };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++); }
            return this.each(function() { jQuery.event.add(this, types, fn, data, selector); });
        },
        one: function(types, selector, data, fn) { return this.on(types, selector, data, fn, 1); },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) { handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler); return this; }
            if (typeof types === "object") {
                for (type in types) { this.off(type, selector, types[type]); }
                return this;
            }
            if (selector === false || typeof selector === "function") { fn = selector;
                selector = undefined; }
            if (fn === false) { fn = returnFalse; }
            return this.each(function() { jQuery.event.remove(this, types, fn, selector); });
        },
        bind: function(types, data, fn) { return this.on(types, null, data, fn); },
        unbind: function(types, fn) { return this.off(types, null, fn); },
        live: function(types, data, fn) { jQuery(this.context).on(types, this.selector, data, fn); return this; },
        die: function(types, fn) { jQuery(this.context).off(types, this.selector || "**", fn); return this; },
        delegate: function(selector, types, data, fn) { return this.on(types, selector, data, fn); },
        undelegate: function(selector, types, fn) { return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn); },
        trigger: function(type, data) { return this.each(function() { jQuery.event.trigger(type, data, this); }); },
        triggerHandler: function(type, data) { if (this[0]) { return jQuery.event.trigger(type, data, this[0], true); } },
        toggle: function(fn) {
            var args = arguments,
                guid = fn.guid || jQuery.guid++,
                i = 0,
                toggler = function(event) { var lastToggle = (jQuery._data(this, "lastToggle" + fn.guid) || 0) % i;
                    jQuery._data(this, "lastToggle" + fn.guid, lastToggle + 1);
                    event.preventDefault(); return args[lastToggle].apply(this, arguments) || false; };
            toggler.guid = guid;
            while (i < args.length) { args[i++].guid = guid; }
            return this.click(toggler);
        },
        hover: function(fnOver, fnOut) { return this.mouseenter(fnOver).mouseleave(fnOut || fnOver); }
    });
    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            if (fn == null) { fn = data;
                data = null; }
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
        if (rkeyEvent.test(name)) { jQuery.event.fixHooks[name] = jQuery.event.keyHooks; }
        if (rmouseEvent.test(name)) { jQuery.event.fixHooks[name] = jQuery.event.mouseHooks; }
    });
    (function(window, undefined) {
        var cachedruns, assertGetIdNotName, Expr, getText, isXML, contains, compile, sortOrder, hasDuplicate, outermostContext, baseHasDuplicate = true,
            strundefined = "undefined",
            expando = ("sizcache" + Math.random()).replace(".", ""),
            Token = String,
            document = window.document,
            docElem = document.documentElement,
            dirruns = 0,
            done = 0,
            pop = [].pop,
            push = [].push,
            slice = [].slice,
            indexOf = [].indexOf || function(elem) {
                var i = 0,
                    len = this.length;
                for (; i < len; i++) { if (this[i] === elem) { return i; } }
                return -1;
            },
            markFunction = function(fn, value) { fn[expando] = value == null || value; return fn; },
            createCache = function() {
                var cache = {},
                    keys = [];
                return markFunction(function(key, value) {
                    if (keys.push(key) > Expr.cacheLength) { delete cache[keys.shift()]; }
                    return (cache[key + " "] = value);
                }, cache);
            },
            classCache = createCache(),
            tokenCache = createCache(),
            compilerCache = createCache(),
            whitespace = "[\\x20\\t\\r\\n\\f]",
            characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",
            identifier = characterEncoding.replace("w", "w#"),
            operators = "([*^$|!~]?=)",
            attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace + "*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",
            pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",
            pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",
            rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
            rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
            rcombinators = new RegExp("^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*"),
            rpseudo = new RegExp(pseudos),
            rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,
            rnot = /^:not/,
            rsibling = /[\x20\t\r\n\f]*[+~]/,
            rendsWithNot = /:not\($/,
            rheader = /h\d/i,
            rinputs = /input|select|textarea|button/i,
            rbackslash = /\\(?!\\)/g,
            matchExpr = { "ID": new RegExp("^#(" + characterEncoding + ")"), "CLASS": new RegExp("^\\.(" + characterEncoding + ")"), "NAME": new RegExp("^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]"), "TAG": new RegExp("^(" + characterEncoding.replace("w", "w*") + ")"), "ATTR": new RegExp("^" + attributes), "PSEUDO": new RegExp("^" + pseudos), "POS": new RegExp(pos, "i"), "CHILD": new RegExp("^:(only|nth|first|last)-child(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"), "needsContext": new RegExp("^" + whitespace + "*[>+~]|" + pos, "i") },
            assert = function(fn) { var div = document.createElement("div"); try { return fn(div); } catch (e) { return false; } finally { div = null; } },
            assertTagNameNoComments = assert(function(div) { div.appendChild(document.createComment("")); return !div.getElementsByTagName("*").length; }),
            assertHrefNotNormalized = assert(function(div) { div.innerHTML = "<a href='#'></a>"; return div.firstChild && typeof div.firstChild.getAttribute !== strundefined && div.firstChild.getAttribute("href") === "#"; }),
            assertAttributes = assert(function(div) { div.innerHTML = "<select></select>"; var type = typeof div.lastChild.getAttribute("multiple"); return type !== "boolean" && type !== "string"; }),
            assertUsableClassName = assert(function(div) {
                div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
                if (!div.getElementsByClassName || !div.getElementsByClassName("e").length) { return false; }
                div.lastChild.className = "e";
                return div.getElementsByClassName("e").length === 2;
            }),
            assertUsableName = assert(function(div) {
                div.id = expando + 0;
                div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
                docElem.insertBefore(div, docElem.firstChild);
                var pass = document.getElementsByName && document.getElementsByName(expando).length === 2 +
                    document.getElementsByName(expando + 0).length;
                assertGetIdNotName = !document.getElementById(expando);
                docElem.removeChild(div);
                return pass;
            });
        try { slice.call(docElem.childNodes, 0)[0].nodeType; } catch (e) {
            slice = function(i) {
                var elem, results = [];
                for (;
                    (elem = this[i]); i++) { results.push(elem); }
                return results;
            };
        }

        function Sizzle(selector, context, results, seed) {
            results = results || [];
            context = context || document;
            var match, elem, xml, m, nodeType = context.nodeType;
            if (!selector || typeof selector !== "string") { return results; }
            if (nodeType !== 1 && nodeType !== 9) { return []; }
            xml = isXML(context);
            if (!xml && !seed) { if ((match = rquickExpr.exec(selector))) { if ((m = match[1])) { if (nodeType === 9) { elem = context.getElementById(m); if (elem && elem.parentNode) { if (elem.id === m) { results.push(elem); return results; } } else { return results; } } else { if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) { results.push(elem); return results; } } } else if (match[2]) { push.apply(results, slice.call(context.getElementsByTagName(selector), 0)); return results; } else if ((m = match[3]) && assertUsableClassName && context.getElementsByClassName) { push.apply(results, slice.call(context.getElementsByClassName(m), 0)); return results; } } }
            return select(selector.replace(rtrim, "$1"), context, results, seed, xml);
        }
        Sizzle.matches = function(expr, elements) { return Sizzle(expr, null, null, elements); };
        Sizzle.matchesSelector = function(elem, expr) { return Sizzle(expr, null, null, [elem]).length > 0; };

        function createInputPseudo(type) { return function(elem) { var name = elem.nodeName.toLowerCase(); return name === "input" && elem.type === type; }; }

        function createButtonPseudo(type) { return function(elem) { var name = elem.nodeName.toLowerCase(); return (name === "input" || name === "button") && elem.type === type; }; }

        function createPositionalPseudo(fn) { return markFunction(function(argument) { argument = +argument; return markFunction(function(seed, matches) { var j, matchIndexes = fn([], seed.length, argument),
                        i = matchIndexes.length; while (i--) { if (seed[(j = matchIndexes[i])]) { seed[j] = !(matches[j] = seed[j]); } } }); }); }
        getText = Sizzle.getText = function(elem) {
            var node, ret = "",
                i = 0,
                nodeType = elem.nodeType;
            if (nodeType) { if (nodeType === 1 || nodeType === 9 || nodeType === 11) { if (typeof elem.textContent === "string") { return elem.textContent; } else { for (elem = elem.firstChild; elem; elem = elem.nextSibling) { ret += getText(elem); } } } else if (nodeType === 3 || nodeType === 4) { return elem.nodeValue; } } else { for (;
                    (node = elem[i]); i++) { ret += getText(node); } }
            return ret;
        };
        isXML = Sizzle.isXML = function(elem) { var documentElement = elem && (elem.ownerDocument || elem).documentElement; return documentElement ? documentElement.nodeName !== "HTML" : false; };
        contains = Sizzle.contains = docElem.contains ? function(a, b) { var adown = a.nodeType === 9 ? a.documentElement : a,
                bup = b && b.parentNode; return a === bup || !!(bup && bup.nodeType === 1 && adown.contains && adown.contains(bup)); } : docElem.compareDocumentPosition ? function(a, b) { return b && !!(a.compareDocumentPosition(b) & 16); } : function(a, b) {
            while ((b = b.parentNode)) { if (b === a) { return true; } }
            return false;
        };
        Sizzle.attr = function(elem, name) {
            var val, xml = isXML(elem);
            if (!xml) { name = name.toLowerCase(); }
            if ((val = Expr.attrHandle[name])) { return val(elem); }
            if (xml || assertAttributes) { return elem.getAttribute(name); }
            val = elem.getAttributeNode(name);
            return val ? typeof elem[name] === "boolean" ? elem[name] ? name : null : val.specified ? val.value : null : null;
        };
        Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: assertHrefNotNormalized ? {} : { "href": function(elem) { return elem.getAttribute("href", 2); }, "type": function(elem) { return elem.getAttribute("type"); } },
            find: {
                "ID": assertGetIdNotName ? function(id, context, xml) { if (typeof context.getElementById !== strundefined && !xml) { var m = context.getElementById(id); return m && m.parentNode ? [m] : []; } } : function(id, context, xml) { if (typeof context.getElementById !== strundefined && !xml) { var m = context.getElementById(id); return m ? m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ? [m] : undefined : []; } },
                "TAG": assertTagNameNoComments ? function(tag, context) { if (typeof context.getElementsByTagName !== strundefined) { return context.getElementsByTagName(tag); } } : function(tag, context) {
                    var results = context.getElementsByTagName(tag);
                    if (tag === "*") {
                        var elem, tmp = [],
                            i = 0;
                        for (;
                            (elem = results[i]); i++) { if (elem.nodeType === 1) { tmp.push(elem); } }
                        return tmp;
                    }
                    return results;
                },
                "NAME": assertUsableName && function(tag, context) { if (typeof context.getElementsByName !== strundefined) { return context.getElementsByName(name); } },
                "CLASS": assertUsableClassName && function(className, context, xml) { if (typeof context.getElementsByClassName !== strundefined && !xml) { return context.getElementsByClassName(className); } }
            },
            relative: { ">": { dir: "parentNode", first: true }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: true }, "~": { dir: "previousSibling" } },
            preFilter: {
                "ATTR": function(match) {
                    match[1] = match[1].replace(rbackslash, "");
                    match[3] = (match[4] || match[5] || "").replace(rbackslash, "");
                    if (match[2] === "~=") { match[3] = " " + match[3] + " "; }
                    return match.slice(0, 4);
                },
                "CHILD": function(match) {
                    match[1] = match[1].toLowerCase();
                    if (match[1] === "nth") {
                        if (!match[2]) { Sizzle.error(match[0]); }
                        match[3] = +(match[3] ? match[4] + (match[5] || 1) : 2 * (match[2] === "even" || match[2] === "odd"));
                        match[4] = +((match[6] + match[7]) || match[2] === "odd");
                    } else if (match[2]) { Sizzle.error(match[0]); }
                    return match;
                },
                "PSEUDO": function(match) {
                    var unquoted, excess;
                    if (matchExpr["CHILD"].test(match[0])) { return null; }
                    if (match[3]) { match[2] = match[3]; } else if ((unquoted = match[4])) {
                        if (rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) { unquoted = unquoted.slice(0, excess);
                            match[0] = match[0].slice(0, excess); }
                        match[2] = unquoted;
                    }
                    return match.slice(0, 3);
                }
            },
            filter: {
                "ID": assertGetIdNotName ? function(id) { id = id.replace(rbackslash, ""); return function(elem) { return elem.getAttribute("id") === id; }; } : function(id) { id = id.replace(rbackslash, ""); return function(elem) { var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id"); return node && node.value === id; }; },
                "TAG": function(nodeName) {
                    if (nodeName === "*") { return function() { return true; }; }
                    nodeName = nodeName.replace(rbackslash, "").toLowerCase();
                    return function(elem) { return elem.nodeName && elem.nodeName.toLowerCase() === nodeName; };
                },
                "CLASS": function(className) { var pattern = classCache[expando][className + " "]; return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) { return pattern.test(elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || ""); }); },
                "ATTR": function(name, operator, check) {
                    return function(elem, context) {
                        var result = Sizzle.attr(elem, name);
                        if (result == null) { return operator === "!="; }
                        if (!operator) { return true; }
                        result += "";
                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.substr(result.length - check.length) === check : operator === "~=" ? (" " + result + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.substr(0, check.length + 1) === check + "-" : false;
                    };
                },
                "CHILD": function(type, argument, first, last) {
                    if (type === "nth") {
                        return function(elem) {
                            var node, diff, parent = elem.parentNode;
                            if (first === 1 && last === 0) { return true; }
                            if (parent) { diff = 0; for (node = parent.firstChild; node; node = node.nextSibling) { if (node.nodeType === 1) { diff++; if (elem === node) { break; } } } }
                            diff -= last;
                            return diff === first || (diff % first === 0 && diff / first >= 0);
                        };
                    }
                    return function(elem) {
                        var node = elem;
                        switch (type) {
                            case "only":
                            case "first":
                                while ((node = node.previousSibling)) { if (node.nodeType === 1) { return false; } }
                                if (type === "first") { return true; }
                                node = elem;
                            case "last":
                                while ((node = node.nextSibling)) { if (node.nodeType === 1) { return false; } }
                                return true;
                        }
                    };
                },
                "PSEUDO": function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    if (fn[expando]) { return fn(argument); }
                    if (fn.length > 1) { args = [pseudo, pseudo, "", argument]; return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) { var idx, matched = fn(seed, argument),
                                i = matched.length; while (i--) { idx = indexOf.call(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]); } }) : function(elem) { return fn(elem, 0, args); }; }
                    return fn;
                }
            },
            pseudos: {
                "not": markFunction(function(selector) { var input = [],
                        results = [],
                        matcher = compile(selector.replace(rtrim, "$1")); return matcher[expando] ? markFunction(function(seed, matches, context, xml) { var elem, unmatched = matcher(seed, null, xml, []),
                            i = seed.length; while (i--) { if ((elem = unmatched[i])) { seed[i] = !(matches[i] = elem); } } }) : function(elem, context, xml) { input[0] = elem;
                        matcher(input, null, xml, results); return !results.pop(); }; }),
                "has": markFunction(function(selector) { return function(elem) { return Sizzle(selector, elem).length > 0; }; }),
                "contains": markFunction(function(text) { return function(elem) { return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1; }; }),
                "enabled": function(elem) { return elem.disabled === false; },
                "disabled": function(elem) { return elem.disabled === true; },
                "checked": function(elem) { var nodeName = elem.nodeName.toLowerCase(); return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected); },
                "selected": function(elem) {
                    if (elem.parentNode) { elem.parentNode.selectedIndex; }
                    return elem.selected === true;
                },
                "parent": function(elem) { return !Expr.pseudos["empty"](elem); },
                "empty": function(elem) {
                    var nodeType;
                    elem = elem.firstChild;
                    while (elem) {
                        if (elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4) { return false; }
                        elem = elem.nextSibling;
                    }
                    return true;
                },
                "header": function(elem) { return rheader.test(elem.nodeName); },
                "text": function(elem) { var type, attr; return elem.nodeName.toLowerCase() === "input" && (type = elem.type) === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type); },
                "radio": createInputPseudo("radio"),
                "checkbox": createInputPseudo("checkbox"),
                "file": createInputPseudo("file"),
                "password": createInputPseudo("password"),
                "image": createInputPseudo("image"),
                "submit": createButtonPseudo("submit"),
                "reset": createButtonPseudo("reset"),
                "button": function(elem) { var name = elem.nodeName.toLowerCase(); return name === "input" && elem.type === "button" || name === "button"; },
                "input": function(elem) { return rinputs.test(elem.nodeName); },
                "focus": function(elem) { var doc = elem.ownerDocument; return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex); },
                "active": function(elem) { return elem === elem.ownerDocument.activeElement; },
                "first": createPositionalPseudo(function() { return [0]; }),
                "last": createPositionalPseudo(function(matchIndexes, length) { return [length - 1]; }),
                "eq": createPositionalPseudo(function(matchIndexes, length, argument) { return [argument < 0 ? argument + length : argument]; }),
                "even": createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 0; i < length; i += 2) { matchIndexes.push(i); }
                    return matchIndexes;
                }),
                "odd": createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 1; i < length; i += 2) { matchIndexes.push(i); }
                    return matchIndexes;
                }),
                "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; --i >= 0;) { matchIndexes.push(i); }
                    return matchIndexes;
                }),
                "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; ++i < length;) { matchIndexes.push(i); }
                    return matchIndexes;
                })
            }
        };

        function siblingCheck(a, b, ret) {
            if (a === b) { return ret; }
            var cur = a.nextSibling;
            while (cur) {
                if (cur === b) { return -1; }
                cur = cur.nextSibling;
            }
            return 1;
        }
        sortOrder = docElem.compareDocumentPosition ? function(a, b) {
            if (a === b) { hasDuplicate = true; return 0; }
            return (!a.compareDocumentPosition || !b.compareDocumentPosition ? a.compareDocumentPosition : a.compareDocumentPosition(b) & 4) ? -1 : 1;
        } : function(a, b) {
            if (a === b) { hasDuplicate = true; return 0; } else if (a.sourceIndex && b.sourceIndex) { return a.sourceIndex - b.sourceIndex; }
            var al, bl, ap = [],
                bp = [],
                aup = a.parentNode,
                bup = b.parentNode,
                cur = aup;
            if (aup === bup) { return siblingCheck(a, b); } else if (!aup) { return -1; } else if (!bup) { return 1; }
            while (cur) { ap.unshift(cur);
                cur = cur.parentNode; }
            cur = bup;
            while (cur) { bp.unshift(cur);
                cur = cur.parentNode; }
            al = ap.length;
            bl = bp.length;
            for (var i = 0; i < al && i < bl; i++) { if (ap[i] !== bp[i]) { return siblingCheck(ap[i], bp[i]); } }
            return i === al ? siblingCheck(a, bp[i], -1) : siblingCheck(ap[i], b, 1);
        };
        [0, 0].sort(sortOrder);
        baseHasDuplicate = !hasDuplicate;
        Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [],
                i = 1,
                j = 0;
            hasDuplicate = baseHasDuplicate;
            results.sort(sortOrder);
            if (hasDuplicate) {
                for (;
                    (elem = results[i]); i++) { if (elem === results[i - 1]) { j = duplicates.push(i); } }
                while (j--) { results.splice(duplicates[j], 1); }
            }
            return results;
        };
        Sizzle.error = function(msg) { throw new Error("Syntax error, unrecognized expression: " + msg); };

        function tokenize(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[expando][selector + " "];
            if (cached) { return parseOnly ? 0 : cached.slice(0); }
            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;
            while (soFar) {
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) { soFar = soFar.slice(match[0].length) || soFar; }
                    groups.push(tokens = []);
                }
                matched = false;
                if ((match = rcombinators.exec(soFar))) { tokens.push(matched = new Token(match.shift()));
                    soFar = soFar.slice(matched.length);
                    matched.type = match[0].replace(rtrim, " "); }
                for (type in Expr.filter) { if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) { tokens.push(matched = new Token(match.shift()));
                        soFar = soFar.slice(matched.length);
                        matched.type = type;
                        matched.matches = match; } }
                if (!matched) { break; }
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        }

        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir,
                checkNonElements = base && combinator.dir === "parentNode",
                doneName = done++;
            return combinator.first ? function(elem, context, xml) { while ((elem = elem[dir])) { if (checkNonElements || elem.nodeType === 1) { return matcher(elem, context, xml); } } } : function(elem, context, xml) {
                if (!xml) {
                    var cache, dirkey = dirruns + " " + doneName + " ",
                        cachedkey = dirkey + cachedruns;
                    while ((elem = elem[dir])) {
                        if (checkNonElements || elem.nodeType === 1) {
                            if ((cache = elem[expando]) === cachedkey) { return elem.sizset; } else if (typeof cache === "string" && cache.indexOf(dirkey) === 0) { if (elem.sizset) { return elem; } } else {
                                elem[expando] = cachedkey;
                                if (matcher(elem, context, xml)) { elem.sizset = true; return elem; }
                                elem.sizset = false;
                            }
                        }
                    }
                } else { while ((elem = elem[dir])) { if (checkNonElements || elem.nodeType === 1) { if (matcher(elem, context, xml)) { return elem; } } } }
            };
        }

        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while (i--) { if (!matchers[i](elem, context, xml)) { return false; } }
                return true;
            } : matchers[0];
        }

        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [],
                i = 0,
                len = unmatched.length,
                mapped = map != null;
            for (; i < len; i++) { if ((elem = unmatched[i])) { if (!filter || filter(elem, context, xml)) { newUnmatched.push(elem); if (mapped) { map.push(i); } } } }
            return newUnmatched;
        }

        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) { postFilter = setMatcher(postFilter); }
            if (postFinder && !postFinder[expando]) { postFinder = setMatcher(postFinder, postSelector); }
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [],
                    postMap = [],
                    preexisting = results.length,
                    elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
                    matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
                    matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher) { matcher(matcherIn, matcherOut, context, xml); }
                if (postFilter) { temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);
                    i = temp.length; while (i--) { if ((elem = temp[i])) { matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem); } } }
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            temp = [];
                            i = matcherOut.length;
                            while (i--) { if ((elem = matcherOut[i])) { temp.push((matcherIn[i] = elem)); } }
                            postFinder(null, (matcherOut = []), temp, xml);
                        }
                        i = matcherOut.length;
                        while (i--) { if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) { seed[temp] = !(results[temp] = elem); } }
                    }
                } else { matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut); if (postFinder) { postFinder(null, results, matcherOut, xml); } else { push.apply(results, matcherOut); } }
            });
        }

        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length,
                leadingRelative = Expr.relative[tokens[0].type],
                implicitRelative = leadingRelative || Expr.relative[" "],
                i = leadingRelative ? 1 : 0,
                matchContext = addCombinator(function(elem) { return elem === checkContext; }, implicitRelative, true),
                matchAnyContext = addCombinator(function(elem) { return indexOf.call(checkContext, elem) > -1; }, implicitRelative, true),
                matchers = [function(elem, context, xml) { return (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); }];
            for (; i < len; i++) {
                if ((matcher = Expr.relative[tokens[i].type])) { matchers = [addCombinator(elementMatcher(matchers), matcher)]; } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                    if (matcher[expando]) {
                        j = ++i;
                        for (; j < len; j++) { if (Expr.relative[tokens[j].type]) { break; } }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && tokens.slice(0, i - 1).join("").replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && tokens.join(""));
                    }
                    matchers.push(matcher);
                }
            }
            return elementMatcher(matchers);
        }

        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0,
                byElement = elementMatchers.length > 0,
                superMatcher = function(seed, context, xml, results, expandContext) {
                    var elem, j, matcher, setMatched = [],
                        matchedCount = 0,
                        i = "0",
                        unmatched = seed && [],
                        outermost = expandContext != null,
                        contextBackup = outermostContext,
                        elems = seed || byElement && Expr.find["TAG"]("*", expandContext && context.parentNode || context),
                        dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);
                    if (outermost) { outermostContext = context !== document && context;
                        cachedruns = superMatcher.el; }
                    for (;
                        (elem = elems[i]) != null; i++) {
                        if (byElement && elem) {
                            for (j = 0;
                                (matcher = elementMatchers[j]); j++) { if (matcher(elem, context, xml)) { results.push(elem); break; } }
                            if (outermost) { dirruns = dirrunsUnique;
                                cachedruns = ++superMatcher.el; }
                        }
                        if (bySet) {
                            if ((elem = !matcher && elem)) { matchedCount--; }
                            if (seed) { unmatched.push(elem); }
                        }
                    }
                    matchedCount += i;
                    if (bySet && i !== matchedCount) {
                        for (j = 0;
                            (matcher = setMatchers[j]); j++) { matcher(unmatched, setMatched, context, xml); }
                        if (seed) {
                            if (matchedCount > 0) { while (i--) { if (!(unmatched[i] || setMatched[i])) { setMatched[i] = pop.call(results); } } }
                            setMatched = condense(setMatched);
                        }
                        push.apply(results, setMatched);
                        if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) { Sizzle.uniqueSort(results); }
                    }
                    if (outermost) { dirruns = dirrunsUnique;
                        outermostContext = contextBackup; }
                    return unmatched;
                };
            superMatcher.el = 0;
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle.compile = function(selector, group) {
            var i, setMatchers = [],
                elementMatchers = [],
                cached = compilerCache[expando][selector + " "];
            if (!cached) {
                if (!group) { group = tokenize(selector); }
                i = group.length;
                while (i--) { cached = matcherFromTokens(group[i]); if (cached[expando]) { setMatchers.push(cached); } else { elementMatchers.push(cached); } }
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            }
            return cached;
        };

        function multipleContexts(selector, contexts, results) {
            var i = 0,
                len = contexts.length;
            for (; i < len; i++) { Sizzle(selector, contexts[i], results); }
            return results;
        }

        function select(selector, context, results, seed, xml) {
            var i, tokens, token, type, find, match = tokenize(selector),
                j = match.length;
            if (!seed) {
                if (match.length === 1) {
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && !xml && Expr.relative[tokens[1].type]) {
                        context = Expr.find["ID"](token.matches[0].replace(rbackslash, ""), context, xml)[0];
                        if (!context) { return results; }
                        selector = selector.slice(tokens.shift().length);
                    }
                    for (i = matchExpr["POS"].test(selector) ? -1 : tokens.length - 1; i >= 0; i--) {
                        token = tokens[i];
                        if (Expr.relative[(type = token.type)]) { break; }
                        if ((find = Expr.find[type])) {
                            if ((seed = find(token.matches[0].replace(rbackslash, ""), rsibling.test(tokens[0].type) && context.parentNode || context, xml))) {
                                tokens.splice(i, 1);
                                selector = seed.length && tokens.join("");
                                if (!selector) { push.apply(results, slice.call(seed, 0)); return results; }
                                break;
                            }
                        }
                    }
                }
            }
            compile(selector, match)(seed, context, xml, results, rsibling.test(selector));
            return results;
        }
        if (document.querySelectorAll) {
            (function() {
                var disconnectedMatch, oldSelect = select,
                    rescape = /'|\\/g,
                    rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,
                    rbuggyQSA = [":focus"],
                    rbuggyMatches = [":active"],
                    matches = docElem.matchesSelector || docElem.mozMatchesSelector || docElem.webkitMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector;
                assert(function(div) {
                    div.innerHTML = "<select><option selected=''></option></select>";
                    if (!div.querySelectorAll("[selected]").length) { rbuggyQSA.push("\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)"); }
                    if (!div.querySelectorAll(":checked").length) { rbuggyQSA.push(":checked"); }
                });
                assert(function(div) {
                    div.innerHTML = "<p test=''></p>";
                    if (div.querySelectorAll("[test^='']").length) { rbuggyQSA.push("[*^$]=" + whitespace + "*(?:\"\"|'')"); }
                    div.innerHTML = "<input type='hidden'/>";
                    if (!div.querySelectorAll(":enabled").length) { rbuggyQSA.push(":enabled", ":disabled"); }
                });
                rbuggyQSA = new RegExp(rbuggyQSA.join("|"));
                select = function(selector, context, results, seed, xml) {
                    if (!seed && !xml && !rbuggyQSA.test(selector)) {
                        var groups, i, old = true,
                            nid = expando,
                            newContext = context,
                            newSelector = context.nodeType === 9 && selector;
                        if (context.nodeType === 1 && context.nodeName.toLowerCase() !== "object") {
                            groups = tokenize(selector);
                            if ((old = context.getAttribute("id"))) { nid = old.replace(rescape, "\\$&"); } else { context.setAttribute("id", nid); }
                            nid = "[id='" + nid + "'] ";
                            i = groups.length;
                            while (i--) { groups[i] = nid + groups[i].join(""); }
                            newContext = rsibling.test(selector) && context.parentNode || context;
                            newSelector = groups.join(",");
                        }
                        if (newSelector) { try { push.apply(results, slice.call(newContext.querySelectorAll(newSelector), 0)); return results; } catch (qsaError) {} finally { if (!old) { context.removeAttribute("id"); } } }
                    }
                    return oldSelect(selector, context, results, seed, xml);
                };
                if (matches) {
                    assert(function(div) { disconnectedMatch = matches.call(div, "div"); try { matches.call(div, "[test!='']:sizzle");
                            rbuggyMatches.push("!=", pseudos); } catch (e) {} });
                    rbuggyMatches = new RegExp(rbuggyMatches.join("|"));
                    Sizzle.matchesSelector = function(elem, expr) {
                        expr = expr.replace(rattributeQuotes, "='$1']");
                        if (!isXML(elem) && !rbuggyMatches.test(expr) && !rbuggyQSA.test(expr)) { try { var ret = matches.call(elem, expr); if (ret || disconnectedMatch || elem.document && elem.document.nodeType !== 11) { return ret; } } catch (e) {} }
                        return Sizzle(expr, null, null, [elem]).length > 0;
                    };
                }
            })();
        }
        Expr.pseudos["nth"] = Expr.pseudos["eq"];

        function setFilters() {}
        Expr.filters = setFilters.prototype = Expr.pseudos;
        Expr.setFilters = new setFilters();
        Sizzle.attr = jQuery.attr;
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[":"] = jQuery.expr.pseudos;
        jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;
    })(window);
    var runtil = /Until$/,
        rparentsprev = /^(?:parents|prev(?:Until|All))/,
        isSimple = /^.[^:#\[\.,]*$/,
        rneedsContext = jQuery.expr.match.needsContext,
        guaranteedUnique = { children: true, contents: true, next: true, prev: true };
    jQuery.fn.extend({
        find: function(selector) {
            var i, l, length, n, r, ret, self = this;
            if (typeof selector !== "string") { return jQuery(selector).filter(function() { for (i = 0, l = self.length; i < l; i++) { if (jQuery.contains(self[i], this)) { return true; } } }); }
            ret = this.pushStack("", "find", selector);
            for (i = 0, l = this.length; i < l; i++) { length = ret.length;
                jQuery.find(selector, this[i], ret); if (i > 0) { for (n = length; n < ret.length; n++) { for (r = 0; r < length; r++) { if (ret[r] === ret[n]) { ret.splice(n--, 1); break; } } } } }
            return ret;
        },
        has: function(target) { var i, targets = jQuery(target, this),
                len = targets.length; return this.filter(function() { for (i = 0; i < len; i++) { if (jQuery.contains(this, targets[i])) { return true; } } }); },
        not: function(selector) { return this.pushStack(winnow(this, selector, false), "not", selector); },
        filter: function(selector) { return this.pushStack(winnow(this, selector, true), "filter", selector); },
        is: function(selector) { return !!selector && (typeof selector === "string" ? rneedsContext.test(selector) ? jQuery(selector, this.context).index(this[0]) >= 0 : jQuery.filter(selector, this).length > 0 : this.filter(selector).length > 0); },
        closest: function(selectors, context) {
            var cur, i = 0,
                l = this.length,
                ret = [],
                pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
            for (; i < l; i++) {
                cur = this[i];
                while (cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11) {
                    if (pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors)) { ret.push(cur); break; }
                    cur = cur.parentNode;
                }
            }
            ret = ret.length > 1 ? jQuery.unique(ret) : ret;
            return this.pushStack(ret, "closest", selectors);
        },
        index: function(elem) {
            if (!elem) { return (this[0] && this[0].parentNode) ? this.prevAll().length : -1; }
            if (typeof elem === "string") { return jQuery.inArray(this[0], jQuery(elem)); }
            return jQuery.inArray(elem.jquery ? elem[0] : elem, this);
        },
        add: function(selector, context) { var set = typeof selector === "string" ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector),
                all = jQuery.merge(this.get(), set); return this.pushStack(isDisconnected(set[0]) || isDisconnected(all[0]) ? all : jQuery.unique(all)); },
        addBack: function(selector) { return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector)); }
    });
    jQuery.fn.andSelf = jQuery.fn.addBack;

    function isDisconnected(node) { return !node || !node.parentNode || node.parentNode.nodeType === 11; }

    function sibling(cur, dir) { do { cur = cur[dir]; } while (cur && cur.nodeType !== 1); return cur; }
    jQuery.each({ parent: function(elem) { var parent = elem.parentNode; return parent && parent.nodeType !== 11 ? parent : null; }, parents: function(elem) { return jQuery.dir(elem, "parentNode"); }, parentsUntil: function(elem, i, until) { return jQuery.dir(elem, "parentNode", until); }, next: function(elem) { return sibling(elem, "nextSibling"); }, prev: function(elem) { return sibling(elem, "previousSibling"); }, nextAll: function(elem) { return jQuery.dir(elem, "nextSibling"); }, prevAll: function(elem) { return jQuery.dir(elem, "previousSibling"); }, nextUntil: function(elem, i, until) { return jQuery.dir(elem, "nextSibling", until); }, prevUntil: function(elem, i, until) { return jQuery.dir(elem, "previousSibling", until); }, siblings: function(elem) { return jQuery.sibling((elem.parentNode || {}).firstChild, elem); }, children: function(elem) { return jQuery.sibling(elem.firstChild); }, contents: function(elem) { return jQuery.nodeName(elem, "iframe") ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes); } }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var ret = jQuery.map(this, fn, until);
            if (!runtil.test(name)) { selector = until; }
            if (selector && typeof selector === "string") { ret = jQuery.filter(selector, ret); }
            ret = this.length > 1 && !guaranteedUnique[name] ? jQuery.unique(ret) : ret;
            if (this.length > 1 && rparentsprev.test(name)) { ret = ret.reverse(); }
            return this.pushStack(ret, name, core_slice.call(arguments).join(","));
        };
    });
    jQuery.extend({
        filter: function(expr, elems, not) {
            if (not) { expr = ":not(" + expr + ")"; }
            return elems.length === 1 ? jQuery.find.matchesSelector(elems[0], expr) ? [elems[0]] : [] : jQuery.find.matches(expr, elems);
        },
        dir: function(elem, dir, until) {
            var matched = [],
                cur = elem[dir];
            while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
                if (cur.nodeType === 1) { matched.push(cur); }
                cur = cur[dir];
            }
            return matched;
        },
        sibling: function(n, elem) {
            var r = [];
            for (; n; n = n.nextSibling) { if (n.nodeType === 1 && n !== elem) { r.push(n); } }
            return r;
        }
    });

    function winnow(elements, qualifier, keep) {
        qualifier = qualifier || 0;
        if (jQuery.isFunction(qualifier)) { return jQuery.grep(elements, function(elem, i) { var retVal = !!qualifier.call(elem, i, elem); return retVal === keep; }); } else if (qualifier.nodeType) { return jQuery.grep(elements, function(elem, i) { return (elem === qualifier) === keep; }); } else if (typeof qualifier === "string") { var filtered = jQuery.grep(elements, function(elem) { return elem.nodeType === 1; }); if (isSimple.test(qualifier)) { return jQuery.filter(qualifier, filtered, !keep); } else { qualifier = jQuery.filter(qualifier, filtered); } }
        return jQuery.grep(elements, function(elem, i) { return (jQuery.inArray(elem, qualifier) >= 0) === keep; });
    }

    function createSafeFragment(document) {
        var list = nodeNames.split("|"),
            safeFrag = document.createDocumentFragment();
        if (safeFrag.createElement) { while (list.length) { safeFrag.createElement(list.pop()); } }
        return safeFrag;
    }
    var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" + "header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
        rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
        rleadingWhitespace = /^\s+/,
        rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
        rtagName = /<([\w:]+)/,
        rtbody = /<tbody/i,
        rhtml = /<|&#?\w+;/,
        rnoInnerhtml = /<(?:script|style|link)/i,
        rnocache = /<(?:script|object|embed|option|style)/i,
        rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
        rcheckableType = /^(?:checkbox|radio)$/,
        rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rscriptType = /\/(java|ecma)script/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
        wrapMap = { option: [1, "<select multiple='multiple'>", "</select>"], legend: [1, "<fieldset>", "</fieldset>"], thead: [1, "<table>", "</table>"], tr: [2, "<table><tbody>", "</tbody></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"], area: [1, "<map>", "</map>"], _default: [0, "", ""] },
        safeFragment = createSafeFragment(document),
        fragmentDiv = safeFragment.appendChild(document.createElement("div"));
    wrapMap.optgroup = wrapMap.option;
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    if (!jQuery.support.htmlSerialize) { wrapMap._default = [1, "X<div>", "</div>"]; }
    jQuery.fn.extend({
        text: function(value) { return jQuery.access(this, function(value) { return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value)); }, null, value, arguments.length); },
        wrapAll: function(html) {
            if (jQuery.isFunction(html)) { return this.each(function(i) { jQuery(this).wrapAll(html.call(this, i)); }); }
            if (this[0]) {
                var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                if (this[0].parentNode) { wrap.insertBefore(this[0]); }
                wrap.map(function() {
                    var elem = this;
                    while (elem.firstChild && elem.firstChild.nodeType === 1) { elem = elem.firstChild; }
                    return elem;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(html) {
            if (jQuery.isFunction(html)) { return this.each(function(i) { jQuery(this).wrapInner(html.call(this, i)); }); }
            return this.each(function() { var self = jQuery(this),
                    contents = self.contents(); if (contents.length) { contents.wrapAll(html); } else { self.append(html); } });
        },
        wrap: function(html) { var isFunction = jQuery.isFunction(html); return this.each(function(i) { jQuery(this).wrapAll(isFunction ? html.call(this, i) : html); }); },
        unwrap: function() { return this.parent().each(function() { if (!jQuery.nodeName(this, "body")) { jQuery(this).replaceWith(this.childNodes); } }).end(); },
        append: function() { return this.domManip(arguments, true, function(elem) { if (this.nodeType === 1 || this.nodeType === 11) { this.appendChild(elem); } }); },
        prepend: function() { return this.domManip(arguments, true, function(elem) { if (this.nodeType === 1 || this.nodeType === 11) { this.insertBefore(elem, this.firstChild); } }); },
        before: function() {
            if (!isDisconnected(this[0])) { return this.domManip(arguments, false, function(elem) { this.parentNode.insertBefore(elem, this); }); }
            if (arguments.length) { var set = jQuery.clean(arguments); return this.pushStack(jQuery.merge(set, this), "before", this.selector); }
        },
        after: function() {
            if (!isDisconnected(this[0])) { return this.domManip(arguments, false, function(elem) { this.parentNode.insertBefore(elem, this.nextSibling); }); }
            if (arguments.length) { var set = jQuery.clean(arguments); return this.pushStack(jQuery.merge(this, set), "after", this.selector); }
        },
        remove: function(selector, keepData) {
            var elem, i = 0;
            for (;
                (elem = this[i]) != null; i++) {
                if (!selector || jQuery.filter(selector, [elem]).length) {
                    if (!keepData && elem.nodeType === 1) { jQuery.cleanData(elem.getElementsByTagName("*"));
                        jQuery.cleanData([elem]); }
                    if (elem.parentNode) { elem.parentNode.removeChild(elem); }
                }
            }
            return this;
        },
        empty: function() {
            var elem, i = 0;
            for (;
                (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) { jQuery.cleanData(elem.getElementsByTagName("*")); }
                while (elem.firstChild) { elem.removeChild(elem.firstChild); }
            }
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) { dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents; return this.map(function() { return jQuery.clone(this, dataAndEvents, deepDataAndEvents); }); },
        html: function(value) {
            return jQuery.access(this, function(value) {
                var elem = this[0] || {},
                    i = 0,
                    l = this.length;
                if (value === undefined) { return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, "") : undefined; }
                if (typeof value === "string" && !rnoInnerhtml.test(value) && (jQuery.support.htmlSerialize || !rnoshimcache.test(value)) && (jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                    value = value.replace(rxhtmlTag, "<$1></$2>");
                    try {
                        for (; i < l; i++) { elem = this[i] || {}; if (elem.nodeType === 1) { jQuery.cleanData(elem.getElementsByTagName("*"));
                                elem.innerHTML = value; } }
                        elem = 0;
                    } catch (e) {}
                }
                if (elem) { this.empty().append(value); }
            }, null, value, arguments.length);
        },
        replaceWith: function(value) {
            if (!isDisconnected(this[0])) {
                if (jQuery.isFunction(value)) { return this.each(function(i) { var self = jQuery(this),
                            old = self.html();
                        self.replaceWith(value.call(this, i, old)); }); }
                if (typeof value !== "string") { value = jQuery(value).detach(); }
                return this.each(function() { var next = this.nextSibling,
                        parent = this.parentNode;
                    jQuery(this).remove(); if (next) { jQuery(next).before(value); } else { jQuery(parent).append(value); } });
            }
            return this.length ? this.pushStack(jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value) : this;
        },
        detach: function(selector) { return this.remove(selector, true); },
        domManip: function(args, table, callback) {
            args = [].concat.apply([], args);
            var results, first, fragment, iNoClone, i = 0,
                value = args[0],
                scripts = [],
                l = this.length;
            if (!jQuery.support.checkClone && l > 1 && typeof value === "string" && rchecked.test(value)) { return this.each(function() { jQuery(this).domManip(args, table, callback); }); }
            if (jQuery.isFunction(value)) { return this.each(function(i) { var self = jQuery(this);
                    args[0] = value.call(this, i, table ? self.html() : undefined);
                    self.domManip(args, table, callback); }); }
            if (this[0]) {
                results = jQuery.buildFragment(args, this, scripts);
                fragment = results.fragment;
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) { fragment = first; }
                if (first) { table = table && jQuery.nodeName(first, "tr"); for (iNoClone = results.cacheable || l - 1; i < l; i++) { callback.call(table && jQuery.nodeName(this[i], "table") ? findOrAppend(this[i], "tbody") : this[i], i === iNoClone ? fragment : jQuery.clone(fragment, true, true)); } }
                fragment = first = null;
                if (scripts.length) {
                    jQuery.each(scripts, function(i, elem) {
                        if (elem.src) { if (jQuery.ajax) { jQuery.ajax({ url: elem.src, type: "GET", dataType: "script", async: false, global: false, "throws": true }); } else { jQuery.error("no ajax"); } } else { jQuery.globalEval((elem.text || elem.textContent || elem.innerHTML || "").replace(rcleanScript, "")); }
                        if (elem.parentNode) { elem.parentNode.removeChild(elem); }
                    });
                }
            }
            return this;
        }
    });

    function findOrAppend(elem, tag) { return elem.getElementsByTagName(tag)[0] || elem.appendChild(elem.ownerDocument.createElement(tag)); }

    function cloneCopyEvent(src, dest) {
        if (dest.nodeType !== 1 || !jQuery.hasData(src)) { return; }
        var type, i, l, oldData = jQuery._data(src),
            curData = jQuery._data(dest, oldData),
            events = oldData.events;
        if (events) { delete curData.handle;
            curData.events = {}; for (type in events) { for (i = 0, l = events[type].length; i < l; i++) { jQuery.event.add(dest, type, events[type][i]); } } }
        if (curData.data) { curData.data = jQuery.extend({}, curData.data); }
    }

    function cloneFixAttributes(src, dest) {
        var nodeName;
        if (dest.nodeType !== 1) { return; }
        if (dest.clearAttributes) { dest.clearAttributes(); }
        if (dest.mergeAttributes) { dest.mergeAttributes(src); }
        nodeName = dest.nodeName.toLowerCase();
        if (nodeName === "object") {
            if (dest.parentNode) { dest.outerHTML = src.outerHTML; }
            if (jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML))) { dest.innerHTML = src.innerHTML; }
        } else if (nodeName === "input" && rcheckableType.test(src.type)) { dest.defaultChecked = dest.checked = src.checked; if (dest.value !== src.value) { dest.value = src.value; } } else if (nodeName === "option") { dest.selected = src.defaultSelected; } else if (nodeName === "input" || nodeName === "textarea") { dest.defaultValue = src.defaultValue; } else if (nodeName === "script" && dest.text !== src.text) { dest.text = src.text; }
        dest.removeAttribute(jQuery.expando);
    }
    jQuery.buildFragment = function(args, context, scripts) {
        var fragment, cacheable, cachehit, first = args[0];
        context = context || document;
        context = !context.nodeType && context[0] || context;
        context = context.ownerDocument || context;
        if (args.length === 1 && typeof first === "string" && first.length < 512 && context === document && first.charAt(0) === "<" && !rnocache.test(first) && (jQuery.support.checkClone || !rchecked.test(first)) && (jQuery.support.html5Clone || !rnoshimcache.test(first))) { cacheable = true;
            fragment = jQuery.fragments[first];
            cachehit = fragment !== undefined; }
        if (!fragment) { fragment = context.createDocumentFragment();
            jQuery.clean(args, context, fragment, scripts); if (cacheable) { jQuery.fragments[first] = cachehit && fragment; } }
        return { fragment: fragment, cacheable: cacheable };
    };
    jQuery.fragments = {};
    jQuery.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, i = 0,
                ret = [],
                insert = jQuery(selector),
                l = insert.length,
                parent = this.length === 1 && this[0].parentNode;
            if ((parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1) { insert[original](this[0]); return this; } else {
                for (; i < l; i++) { elems = (i > 0 ? this.clone(true) : this).get();
                    jQuery(insert[i])[original](elems);
                    ret = ret.concat(elems); }
                return this.pushStack(ret, name, insert.selector);
            }
        };
    });

    function getAll(elem) { if (typeof elem.getElementsByTagName !== "undefined") { return elem.getElementsByTagName("*"); } else if (typeof elem.querySelectorAll !== "undefined") { return elem.querySelectorAll("*"); } else { return []; } }

    function fixDefaultChecked(elem) { if (rcheckableType.test(elem.type)) { elem.defaultChecked = elem.checked; } }
    jQuery.extend({
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var srcElements, destElements, i, clone;
            if (jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test("<" + elem.nodeName + ">")) { clone = elem.cloneNode(true); } else { fragmentDiv.innerHTML = elem.outerHTML;
                fragmentDiv.removeChild(clone = fragmentDiv.firstChild); }
            if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) { cloneFixAttributes(elem, clone);
                srcElements = getAll(elem);
                destElements = getAll(clone); for (i = 0; srcElements[i]; ++i) { if (destElements[i]) { cloneFixAttributes(srcElements[i], destElements[i]); } } }
            if (dataAndEvents) { cloneCopyEvent(elem, clone); if (deepDataAndEvents) { srcElements = getAll(elem);
                    destElements = getAll(clone); for (i = 0; srcElements[i]; ++i) { cloneCopyEvent(srcElements[i], destElements[i]); } } }
            srcElements = destElements = null;
            return clone;
        },
        clean: function(elems, context, fragment, scripts) {
            var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags, safe = context === document && safeFragment,
                ret = [];
            if (!context || typeof context.createDocumentFragment === "undefined") { context = document; }
            for (i = 0;
                (elem = elems[i]) != null; i++) {
                if (typeof elem === "number") { elem += ""; }
                if (!elem) { continue; }
                if (typeof elem === "string") {
                    if (!rhtml.test(elem)) { elem = context.createTextNode(elem); } else {
                        safe = safe || createSafeFragment(context);
                        div = context.createElement("div");
                        safe.appendChild(div);
                        elem = elem.replace(rxhtmlTag, "<$1></$2>");
                        tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        depth = wrap[0];
                        div.innerHTML = wrap[1] + elem + wrap[2];
                        while (depth--) { div = div.lastChild; }
                        if (!jQuery.support.tbody) { hasBody = rtbody.test(elem);
                            tbody = tag === "table" && !hasBody ? div.firstChild && div.firstChild.childNodes : wrap[1] === "<table>" && !hasBody ? div.childNodes : []; for (j = tbody.length - 1; j >= 0; --j) { if (jQuery.nodeName(tbody[j], "tbody") && !tbody[j].childNodes.length) { tbody[j].parentNode.removeChild(tbody[j]); } } }
                        if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) { div.insertBefore(context.createTextNode(rleadingWhitespace.exec(elem)[0]), div.firstChild); }
                        elem = div.childNodes;
                        div.parentNode.removeChild(div);
                    }
                }
                if (elem.nodeType) { ret.push(elem); } else { jQuery.merge(ret, elem); }
            }
            if (div) { elem = div = safe = null; }
            if (!jQuery.support.appendChecked) { for (i = 0;
                    (elem = ret[i]) != null; i++) { if (jQuery.nodeName(elem, "input")) { fixDefaultChecked(elem); } else if (typeof elem.getElementsByTagName !== "undefined") { jQuery.grep(elem.getElementsByTagName("input"), fixDefaultChecked); } } }
            if (fragment) { handleScript = function(elem) { if (!elem.type || rscriptType.test(elem.type)) { return scripts ? scripts.push(elem.parentNode ? elem.parentNode.removeChild(elem) : elem) : fragment.appendChild(elem); } }; for (i = 0;
                    (elem = ret[i]) != null; i++) { if (!(jQuery.nodeName(elem, "script") && handleScript(elem))) { fragment.appendChild(elem); if (typeof elem.getElementsByTagName !== "undefined") { jsTags = jQuery.grep(jQuery.merge([], elem.getElementsByTagName("script")), handleScript);
                            ret.splice.apply(ret, [i + 1, 0].concat(jsTags));
                            i += jsTags.length; } } } }
            return ret;
        },
        cleanData: function(elems, acceptData) {
            var data, id, elem, type, i = 0,
                internalKey = jQuery.expando,
                cache = jQuery.cache,
                deleteExpando = jQuery.support.deleteExpando,
                special = jQuery.event.special;
            for (;
                (elem = elems[i]) != null; i++) {
                if (acceptData || jQuery.acceptData(elem)) {
                    id = elem[internalKey];
                    data = id && cache[id];
                    if (data) {
                        if (data.events) { for (type in data.events) { if (special[type]) { jQuery.event.remove(elem, type); } else { jQuery.removeEvent(elem, type, data.handle); } } }
                        if (cache[id]) {
                            delete cache[id];
                            if (deleteExpando) { delete elem[internalKey]; } else if (elem.removeAttribute) { elem.removeAttribute(internalKey); } else { elem[internalKey] = null; }
                            jQuery.deletedIds.push(id);
                        }
                    }
                }
            }
        }
    });
    (function() {
        var matched, browser;
        jQuery.uaMatch = function(ua) { ua = ua.toLowerCase(); var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || /(webkit)[\/]([\w.]+)/.exec(ua) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(ua) || /(msie)([\w.]+)/.exec(ua) || ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || []; return { browser: match[1] || "", version: match[2] || "0" }; };
        matched = jQuery.uaMatch(navigator.userAgent);
        browser = {};
        if (matched.browser) { browser[matched.browser] = true;
            browser.version = matched.version; }
        if (browser.chrome) { browser.webkit = true; } else if (browser.webkit) { browser.safari = true; }
        jQuery.browser = browser;
        jQuery.sub = function() {
            function jQuerySub(selector, context) { return new jQuerySub.fn.init(selector, context); }
            jQuery.extend(true, jQuerySub, this);
            jQuerySub.superclass = this;
            jQuerySub.fn = jQuerySub.prototype = this();
            jQuerySub.fn.constructor = jQuerySub;
            jQuerySub.sub = this.sub;
            jQuerySub.fn.init = function init(selector, context) {
                if (context && context instanceof jQuery && !(context instanceof jQuerySub)) { context = jQuerySub(context); }
                return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
            };
            jQuerySub.fn.init.prototype = jQuerySub.fn;
            var rootjQuerySub = jQuerySub(document);
            return jQuerySub;
        };
    })();
    var curCSS, iframe, iframeDoc, ralpha = /alpha\([^)]*\)/i,
        ropacity = /opacity=([^)]*)/,
        rposition = /^(top|right|bottom|left)$/,
        rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rmargin = /^margin/,
        rnumsplit = new RegExp("^(" + core_pnum + ")(.*)$", "i"),
        rnumnonpx = new RegExp("^(" + core_pnum + ")(?!px)[a-z%]+$", "i"),
        rrelNum = new RegExp("^([-+])=(" + core_pnum + ")", "i"),
        elemdisplay = { BODY: "block" },
        cssShow = { position: "absolute", visibility: "hidden", display: "block" },
        cssNormalTransform = { letterSpacing: 0, fontWeight: 400 },
        cssExpand = ["Top", "Right", "Bottom", "Left"],
        cssPrefixes = ["Webkit", "O", "Moz", "ms"],
        eventsToggle = jQuery.fn.toggle;

    function vendorPropName(style, name) {
        if (name in style) { return name; }
        var capName = name.charAt(0).toUpperCase() + name.slice(1),
            origName = name,
            i = cssPrefixes.length;
        while (i--) { name = cssPrefixes[i] + capName; if (name in style) { return name; } }
        return origName;
    }

    function isHidden(elem, el) { elem = el || elem; return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem); }

    function showHide(elements, show) {
        var elem, display, values = [],
            index = 0,
            length = elements.length;
        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) { continue; }
            values[index] = jQuery._data(elem, "olddisplay");
            if (show) {
                if (!values[index] && elem.style.display === "none") { elem.style.display = ""; }
                if (elem.style.display === "" && isHidden(elem)) { values[index] = jQuery._data(elem, "olddisplay", css_defaultDisplay(elem.nodeName)); }
            } else { display = curCSS(elem, "display"); if (!values[index] && display !== "none") { jQuery._data(elem, "olddisplay", display); } }
        }
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) { continue; }
            if (!show || elem.style.display === "none" || elem.style.display === "") { elem.style.display = show ? values[index] || "" : "none"; }
        }
        return elements;
    }
    jQuery.fn.extend({
        css: function(name, value) { return jQuery.access(this, function(elem, name, value) { return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name); }, name, value, arguments.length > 1); },
        show: function() { return showHide(this, true); },
        hide: function() { return showHide(this); },
        toggle: function(state, fn2) {
            var bool = typeof state === "boolean";
            if (jQuery.isFunction(state) && jQuery.isFunction(fn2)) { return eventsToggle.apply(this, arguments); }
            return this.each(function() { if (bool ? state : isHidden(this)) { jQuery(this).show(); } else { jQuery(this).hide(); } });
        }
    });
    jQuery.extend({
        cssHooks: { opacity: { get: function(elem, computed) { if (computed) { var ret = curCSS(elem, "opacity"); return ret === "" ? "1" : ret; } } } },
        cssNumber: { "fillOpacity": true, "fontWeight": true, "lineHeight": true, "opacity": true, "orphans": true, "widows": true, "zIndex": true, "zoom": true },
        cssProps: { "float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat" },
        style: function(elem, name, value, extra) {
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) { return; }
            var ret, type, hooks, origName = jQuery.camelCase(name),
                style = elem.style;
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (value !== undefined) {
                type = typeof value;
                if (type === "string" && (ret = rrelNum.exec(value))) { value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
                    type = "number"; }
                if (value == null || type === "number" && isNaN(value)) { return; }
                if (type === "number" && !jQuery.cssNumber[origName]) { value += "px"; }
                if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) { try { style[name] = value; } catch (e) {} }
            } else {
                if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) { return ret; }
                return style[name];
            }
        },
        css: function(elem, name, numeric, extra) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
            if (hooks && "get" in hooks) { val = hooks.get(elem, true, extra); }
            if (val === undefined) { val = curCSS(elem, name); }
            if (val === "normal" && name in cssNormalTransform) { val = cssNormalTransform[name]; }
            if (numeric || extra !== undefined) { num = parseFloat(val); return numeric || jQuery.isNumeric(num) ? num || 0 : val; }
            return val;
        },
        swap: function(elem, options, callback) {
            var ret, name, old = {};
            for (name in options) { old[name] = elem.style[name];
                elem.style[name] = options[name]; }
            ret = callback.call(elem);
            for (name in options) { elem.style[name] = old[name]; }
            return ret;
        }
    });
    if (window.getComputedStyle) {
        curCSS = function(elem, name) {
            var ret, width, minWidth, maxWidth, computed = window.getComputedStyle(elem, null),
                style = elem.style;
            if (computed) {
                ret = computed.getPropertyValue(name) || computed[name];
                if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) { ret = jQuery.style(elem, name); }
                if (rnumnonpx.test(ret) && rmargin.test(name)) { width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;
                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;
                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth; }
            }
            return ret;
        };
    } else if (document.documentElement.currentStyle) {
        curCSS = function(elem, name) {
            var left, rsLeft, ret = elem.currentStyle && elem.currentStyle[name],
                style = elem.style;
            if (ret == null && style && style[name]) { ret = style[name]; }
            if (rnumnonpx.test(ret) && !rposition.test(name)) {
                left = style.left;
                rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;
                if (rsLeft) { elem.runtimeStyle.left = elem.currentStyle.left; }
                style.left = name === "fontSize" ? "1em" : ret;
                ret = style.pixelLeft + "px";
                style.left = left;
                if (rsLeft) { elem.runtimeStyle.left = rsLeft; }
            }
            return ret === "" ? "auto" : ret;
        };
    }

    function setPositiveNumber(elem, value, subtract) { var matches = rnumsplit.exec(value); return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || "px") : value; }

    function augmentWidthOrHeight(elem, name, extra, isBorderBox) {
        var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0,
            val = 0;
        for (; i < 4; i += 2) {
            if (extra === "margin") { val += jQuery.css(elem, extra + cssExpand[i], true); }
            if (isBorderBox) {
                if (extra === "content") { val -= parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0; }
                if (extra !== "margin") { val -= parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0; }
            } else { val += parseFloat(curCSS(elem, "padding" + cssExpand[i])) || 0; if (extra !== "padding") { val += parseFloat(curCSS(elem, "border" + cssExpand[i] + "Width")) || 0; } }
        }
        return val;
    }

    function getWidthOrHeight(elem, name, extra) {
        var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
            valueIsBorderBox = true,
            isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, "boxSizing") === "border-box";
        if (val <= 0 || val == null) {
            val = curCSS(elem, name);
            if (val < 0 || val == null) { val = elem.style[name]; }
            if (rnumnonpx.test(val)) { return val; }
            valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]);
            val = parseFloat(val) || 0;
        }
        return (val +
            augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox)) + "px";
    }

    function css_defaultDisplay(nodeName) {
        if (elemdisplay[nodeName]) { return elemdisplay[nodeName]; }
        var elem = jQuery("<" + nodeName + ">").appendTo(document.body),
            display = elem.css("display");
        elem.remove();
        if (display === "none" || display === "") {
            iframe = document.body.appendChild(iframe || jQuery.extend(document.createElement("iframe"), { frameBorder: 0, width: 0, height: 0 }));
            if (!iframeDoc || !iframe.createElement) { iframeDoc = (iframe.contentWindow || iframe.contentDocument).document;
                iframeDoc.write("<!doctype html><html><body>");
                iframeDoc.close(); }
            elem = iframeDoc.body.appendChild(iframeDoc.createElement(nodeName));
            display = curCSS(elem, "display");
            document.body.removeChild(iframe);
        }
        elemdisplay[nodeName] = display;
        return display;
    }
    jQuery.each(["height", "width"], function(i, name) { jQuery.cssHooks[name] = { get: function(elem, computed, extra) { if (computed) { if (elem.offsetWidth === 0 && rdisplayswap.test(curCSS(elem, "display"))) { return jQuery.swap(elem, cssShow, function() { return getWidthOrHeight(elem, name, extra); }); } else { return getWidthOrHeight(elem, name, extra); } } }, set: function(elem, value, extra) { return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, "boxSizing") === "border-box") : 0); } }; });
    if (!jQuery.support.opacity) {
        jQuery.cssHooks.opacity = {
            get: function(elem, computed) { return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "") ? (0.01 * parseFloat(RegExp.$1)) + "" : computed ? "1" : ""; },
            set: function(elem, value) {
                var style = elem.style,
                    currentStyle = elem.currentStyle,
                    opacity = jQuery.isNumeric(value) ? "alpha(opacity=" + value * 100 + ")" : "",
                    filter = currentStyle && currentStyle.filter || style.filter || "";
                style.zoom = 1;
                if (value >= 1 && jQuery.trim(filter.replace(ralpha, "")) === "" && style.removeAttribute) { style.removeAttribute("filter"); if (currentStyle && !currentStyle.filter) { return; } }
                style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + " " + opacity;
            }
        };
    }
    jQuery(function() {
        if (!jQuery.support.reliableMarginRight) { jQuery.cssHooks.marginRight = { get: function(elem, computed) { return jQuery.swap(elem, { "display": "inline-block" }, function() { if (computed) { return curCSS(elem, "marginRight"); } }); } }; }
        if (!jQuery.support.pixelPosition && jQuery.fn.position) { jQuery.each(["top", "left"], function(i, prop) { jQuery.cssHooks[prop] = { get: function(elem, computed) { if (computed) { var ret = curCSS(elem, prop); return rnumnonpx.test(ret) ? jQuery(elem).position()[prop] + "px" : ret; } } }; }); }
    });
    if (jQuery.expr && jQuery.expr.filters) { jQuery.expr.filters.hidden = function(elem) { return (elem.offsetWidth === 0 && elem.offsetHeight === 0) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS(elem, "display")) === "none"); };
        jQuery.expr.filters.visible = function(elem) { return !jQuery.expr.filters.hidden(elem); }; }
    jQuery.each({ margin: "", padding: "", border: "Width" }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i, parts = typeof value === "string" ? value.split(" ") : [value],
                    expanded = {};
                for (i = 0; i < 4; i++) { expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0]; }
                return expanded;
            }
        };
        if (!rmargin.test(prefix)) { jQuery.cssHooks[prefix + suffix].set = setPositiveNumber; }
    });
    var r20 = /%20/g,
        rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
        rselectTextarea = /^(?:select|textarea)/i;
    jQuery.fn.extend({ serialize: function() { return jQuery.param(this.serializeArray()); }, serializeArray: function() { return this.map(function() { return this.elements ? jQuery.makeArray(this.elements) : this; }).filter(function() { return this.name && !this.disabled && (this.checked || rselectTextarea.test(this.nodeName) || rinput.test(this.type)); }).map(function(i, elem) { var val = jQuery(this).val(); return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val, i) { return { name: elem.name, value: val.replace(rCRLF, "\r\n") }; }) : { name: elem.name, value: val.replace(rCRLF, "\r\n") }; }).get(); } });
    jQuery.param = function(a, traditional) {
        var prefix, s = [],
            add = function(key, value) { value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
                s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value); };
        if (traditional === undefined) { traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional; }
        if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) { jQuery.each(a, function() { add(this.name, this.value); }); } else { for (prefix in a) { buildParams(prefix, a[prefix], traditional, add); } }
        return s.join("&").replace(r20, "+");
    };

    function buildParams(prefix, obj, traditional, add) { var name; if (jQuery.isArray(obj)) { jQuery.each(obj, function(i, v) { if (traditional || rbracket.test(prefix)) { add(prefix, v); } else { buildParams(prefix + "[" + (typeof v === "object" ? i : "") + "]", v, traditional, add); } }); } else if (!traditional && jQuery.type(obj) === "object") { for (name in obj) { buildParams(prefix + "[" + name + "]", obj[name], traditional, add); } } else { add(prefix, obj); } }
    var
        ajaxLocParts, ajaxLocation, rhash = /#.*$/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg,
        rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,
        rquery = /\?/,
        rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
        rts = /([?&])_=[^&]*/,
        rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
        _load = jQuery.fn.load,
        prefilters = {},
        transports = {},
        allTypes = ["*/"] + ["*"];
    try { ajaxLocation = location.href; } catch (e) { ajaxLocation = document.createElement("a");
        ajaxLocation.href = "";
        ajaxLocation = ajaxLocation.href; }
    ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];

    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            if (typeof dataTypeExpression !== "string") { func = dataTypeExpression;
                dataTypeExpression = "*"; }
            var dataType, list, placeBefore, dataTypes = dataTypeExpression.toLowerCase().split(core_rspace),
                i = 0,
                length = dataTypes.length;
            if (jQuery.isFunction(func)) {
                for (; i < length; i++) {
                    dataType = dataTypes[i];
                    placeBefore = /^\+/.test(dataType);
                    if (placeBefore) { dataType = dataType.substr(1) || "*"; }
                    list = structure[dataType] = structure[dataType] || [];
                    list[placeBefore ? "unshift" : "push"](func);
                }
            }
        };
    }

    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR, dataType, inspected) {
        dataType = dataType || options.dataTypes[0];
        inspected = inspected || {};
        inspected[dataType] = true;
        var selection, list = structure[dataType],
            i = 0,
            length = list ? list.length : 0,
            executeOnly = (structure === prefilters);
        for (; i < length && (executeOnly || !selection); i++) { selection = list[i](options, originalOptions, jqXHR); if (typeof selection === "string") { if (!executeOnly || inspected[selection]) { selection = undefined; } else { options.dataTypes.unshift(selection);
                    selection = inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR, selection, inspected); } } }
        if ((executeOnly || !selection) && !inspected["*"]) { selection = inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR, "*", inspected); }
        return selection;
    }

    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) { if (src[key] !== undefined) {
                (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key]; } }
        if (deep) { jQuery.extend(true, target, deep); }
    }
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) { return _load.apply(this, arguments); }
        if (!this.length) { return this; }
        var selector, type, response, self = this,
            off = url.indexOf(" ");
        if (off >= 0) { selector = url.slice(off, url.length);
            url = url.slice(0, off); }
        if (jQuery.isFunction(params)) { callback = params;
            params = undefined; } else if (params && typeof params === "object") { type = "POST"; }
        jQuery.ajax({ url: url, type: type, dataType: "html", data: params, complete: function(jqXHR, status) { if (callback) { self.each(callback, response || [jqXHR.responseText, status, jqXHR]); } } }).done(function(responseText) { response = arguments;
            self.html(selector ? jQuery("<div>").append(responseText.replace(rscript, "")).find(selector) : responseText); });
        return this;
    };
    jQuery.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "), function(i, o) { jQuery.fn[o] = function(f) { return this.on(o, f); }; });
    jQuery.each(["get", "post"], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            if (jQuery.isFunction(data)) { type = type || callback;
                callback = data;
                data = undefined; }
            return jQuery.ajax({ type: method, url: url, data: data, success: callback, dataType: type });
        };
    });
    jQuery.extend({
        getScript: function(url, callback) { return jQuery.get(url, undefined, callback, "script"); },
        getJSON: function(url, data, callback) { return jQuery.get(url, data, callback, "json"); },
        ajaxSetup: function(target, settings) {
            if (settings) { ajaxExtend(target, jQuery.ajaxSettings); } else { settings = target;
                target = jQuery.ajaxSettings; }
            ajaxExtend(target, settings);
            return target;
        },
        ajaxSettings: { url: ajaxLocation, isLocal: rlocalProtocol.test(ajaxLocParts[1]), global: true, type: "GET", contentType: "application/x-www-form-urlencoded; charset=UTF-8", processData: true, async: true, accepts: { xml: "application/xml, text/xml", html: "text/html", text: "text/plain", json: "application/json, text/javascript", "*": allTypes }, contents: { xml: /xml/, html: /html/, json: /json/ }, responseFields: { xml: "responseXML", text: "responseText" }, converters: { "* text": window.String, "text html": true, "text json": jQuery.parseJSON, "text xml": jQuery.parseXML }, flatOptions: { context: true, url: true } },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            if (typeof url === "object") { options = url;
                url = undefined; }
            options = options || {};
            var
                ifModifiedKey, responseHeadersString, responseHeaders, transport, timeoutTimer, parts, fireGlobals, i, s = jQuery.ajaxSetup({}, options),
                callbackContext = s.context || s,
                globalEventContext = callbackContext !== s && (callbackContext.nodeType || callbackContext instanceof jQuery) ? jQuery(callbackContext) : jQuery.event,
                deferred = jQuery.Deferred(),
                completeDeferred = jQuery.Callbacks("once memory"),
                statusCode = s.statusCode || {},
                requestHeaders = {},
                requestHeadersNames = {},
                state = 0,
                strAbort = "canceled",
                jqXHR = {
                    readyState: 0,
                    setRequestHeader: function(name, value) {
                        if (!state) { var lname = name.toLowerCase();
                            name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                            requestHeaders[name] = value; }
                        return this;
                    },
                    getAllResponseHeaders: function() { return state === 2 ? responseHeadersString : null; },
                    getResponseHeader: function(key) {
                        var match;
                        if (state === 2) {
                            if (!responseHeaders) { responseHeaders = {}; while ((match = rheaders.exec(responseHeadersString))) { responseHeaders[match[1].toLowerCase()] = match[2]; } }
                            match = responseHeaders[key.toLowerCase()];
                        }
                        return match === undefined ? null : match;
                    },
                    overrideMimeType: function(type) {
                        if (!state) { s.mimeType = type; }
                        return this;
                    },
                    abort: function(statusText) {
                        statusText = statusText || strAbort;
                        if (transport) { transport.abort(statusText); }
                        done(0, statusText);
                        return this;
                    }
                };

            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                if (state === 2) { return; }
                state = 2;
                if (timeoutTimer) { clearTimeout(timeoutTimer); }
                transport = undefined;
                responseHeadersString = headers || "";
                jqXHR.readyState = status > 0 ? 4 : 0;
                if (responses) { response = ajaxHandleResponses(s, jqXHR, responses); }
                if (status >= 200 && status < 300 || status === 304) {
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) { jQuery.lastModified[ifModifiedKey] = modified; }
                        modified = jqXHR.getResponseHeader("Etag");
                        if (modified) { jQuery.etag[ifModifiedKey] = modified; }
                    }
                    if (status === 304) { statusText = "notmodified";
                        isSuccess = true; } else { isSuccess = ajaxConvert(s, response);
                        statusText = isSuccess.state;
                        success = isSuccess.data;
                        error = isSuccess.error;
                        isSuccess = !error; }
                } else { error = statusText; if (!statusText || status) { statusText = "error"; if (status < 0) { status = 0; } } }
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";
                if (isSuccess) { deferred.resolveWith(callbackContext, [success, statusText, jqXHR]); } else { deferred.rejectWith(callbackContext, [jqXHR, statusText, error]); }
                jqXHR.statusCode(statusCode);
                statusCode = undefined;
                if (fireGlobals) { globalEventContext.trigger("ajax" + (isSuccess ? "Success" : "Error"), [jqXHR, s, isSuccess ? success : error]); }
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
                if (fireGlobals) { globalEventContext.trigger("ajaxComplete", [jqXHR, s]); if (!(--jQuery.active)) { jQuery.event.trigger("ajaxStop"); } }
            }
            deferred.promise(jqXHR);
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;
            jqXHR.complete = completeDeferred.add;
            jqXHR.statusCode = function(map) {
                if (map) { var tmp; if (state < 2) { for (tmp in map) { statusCode[tmp] = [statusCode[tmp], map[tmp]]; } } else { tmp = map[jqXHR.status];
                        jqXHR.always(tmp); } }
                return this;
            };
            s.url = ((url || s.url) + "").replace(rhash, "").replace(rprotocol, ajaxLocParts[1] + "//");
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().split(core_rspace);
            if (s.crossDomain == null) { parts = rurl.exec(s.url.toLowerCase());
                s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443)))); }
            if (s.data && s.processData && typeof s.data !== "string") { s.data = jQuery.param(s.data, s.traditional); }
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
            if (state === 2) { return jqXHR; }
            fireGlobals = s.global;
            s.type = s.type.toUpperCase();
            s.hasContent = !rnoContent.test(s.type);
            if (fireGlobals && jQuery.active++ === 0) { jQuery.event.trigger("ajaxStart"); }
            if (!s.hasContent) {
                if (s.data) { s.url += (rquery.test(s.url) ? "&" : "?") + s.data;
                    delete s.data; }
                ifModifiedKey = s.url;
                if (s.cache === false) { var ts = jQuery.now(),
                        ret = s.url.replace(rts, "$1_=" + ts);
                    s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? "&" : "?") + "_=" + ts : ""); }
            }
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) { jqXHR.setRequestHeader("Content-Type", s.contentType); }
            if (s.ifModified) {
                ifModifiedKey = ifModifiedKey || s.url;
                if (jQuery.lastModified[ifModifiedKey]) { jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[ifModifiedKey]); }
                if (jQuery.etag[ifModifiedKey]) { jqXHR.setRequestHeader("If-None-Match", jQuery.etag[ifModifiedKey]); }
            }
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) { jqXHR.setRequestHeader(i, s.headers[i]); }
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) { return jqXHR.abort(); }
            strAbort = "abort";
            for (i in { success: 1, error: 1, complete: 1 }) { jqXHR[i](s[i]); }
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
            if (!transport) { done(-1, "No Transport"); } else {
                jqXHR.readyState = 1;
                if (fireGlobals) { globalEventContext.trigger("ajaxSend", [jqXHR, s]); }
                if (s.async && s.timeout > 0) { timeoutTimer = setTimeout(function() { jqXHR.abort("timeout"); }, s.timeout); }
                try { state = 1;
                    transport.send(requestHeaders, done); } catch (e) { if (state < 2) { done(-1, e); } else { throw e; } }
            }
            return jqXHR;
        },
        active: 0,
        lastModified: {},
        etag: {}
    });

    function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents,
            dataTypes = s.dataTypes,
            responseFields = s.responseFields;
        for (type in responseFields) { if (type in responses) { jqXHR[responseFields[type]] = responses[type]; } }
        while (dataTypes[0] === "*") { dataTypes.shift(); if (ct === undefined) { ct = s.mimeType || jqXHR.getResponseHeader("content-type"); } }
        if (ct) { for (type in contents) { if (contents[type] && contents[type].test(ct)) { dataTypes.unshift(type); break; } } }
        if (dataTypes[0] in responses) { finalDataType = dataTypes[0]; } else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) { finalDataType = type; break; }
                if (!firstDataType) { firstDataType = type; }
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) { dataTypes.unshift(finalDataType); }
            return responses[finalDataType];
        }
    }

    function ajaxConvert(s, response) {
        var conv, conv2, current, tmp, dataTypes = s.dataTypes.slice(),
            prev = dataTypes[0],
            converters = {},
            i = 0;
        if (s.dataFilter) { response = s.dataFilter(response, s.dataType); }
        if (dataTypes[1]) { for (conv in s.converters) { converters[conv.toLowerCase()] = s.converters[conv]; } }
        for (;
            (current = dataTypes[++i]);) {
            if (current !== "*") {
                if (prev !== "*" && prev !== current) {
                    conv = converters[prev + " " + current] || converters["* " + current];
                    if (!conv) {
                        for (conv2 in converters) {
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {
                                    if (conv === true) { conv = converters[conv2]; } else if (converters[conv2] !== true) { current = tmp[0];
                                        dataTypes.splice(i--, 0, current); }
                                    break;
                                }
                            }
                        }
                    }
                    if (conv !== true) { if (conv && s["throws"]) { response = conv(response); } else { try { response = conv(response); } catch (e) { return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current }; } } }
                }
                prev = current;
            }
        }
        return { state: "success", data: response };
    }
    var oldCallbacks = [],
        rquestion = /\?/,
        rjsonp = /(=)\?(?=&|$)|\?\?/,
        nonce = jQuery.now();
    jQuery.ajaxSetup({ jsonp: "callback", jsonpCallback: function() { var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
            this[callback] = true; return callback; } });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, data = s.data,
            url = s.url,
            hasCallback = s.jsonp !== false,
            replaceInUrl = hasCallback && rjsonp.test(url),
            replaceInData = hasCallback && !replaceInUrl && typeof data === "string" && !(s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(data);
        if (s.dataTypes[0] === "jsonp" || replaceInUrl || replaceInData) {
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
            overwritten = window[callbackName];
            if (replaceInUrl) { s.url = url.replace(rjsonp, "$1" + callbackName); } else if (replaceInData) { s.data = data.replace(rjsonp, "$1" + callbackName); } else if (hasCallback) { s.url += (rquestion.test(url) ? "&" : "?") + s.jsonp + "=" + callbackName; }
            s.converters["script json"] = function() {
                if (!responseContainer) { jQuery.error(callbackName + " was not called"); }
                return responseContainer[0];
            };
            s.dataTypes[0] = "json";
            window[callbackName] = function() { responseContainer = arguments; };
            jqXHR.always(function() {
                window[callbackName] = overwritten;
                if (s[callbackName]) { s.jsonpCallback = originalSettings.jsonpCallback;
                    oldCallbacks.push(callbackName); }
                if (responseContainer && jQuery.isFunction(overwritten)) { overwritten(responseContainer[0]); }
                responseContainer = overwritten = undefined;
            });
            return "script";
        }
    });
    jQuery.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /javascript|ecmascript/ }, converters: { "text script": function(text) { jQuery.globalEval(text); return text; } } });
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) { s.cache = false; }
        if (s.crossDomain) { s.type = "GET";
            s.global = false; }
    });
    jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, head = document.head || document.getElementsByTagName("head")[0] || document.documentElement;
            return {
                send: function(_, callback) {
                    script = document.createElement("script");
                    script.async = "async";
                    if (s.scriptCharset) { script.charset = s.scriptCharset; }
                    script.src = s.url;
                    script.onload = script.onreadystatechange = function(_, isAbort) {
                        if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
                            script.onload = script.onreadystatechange = null;
                            if (head && script.parentNode) { head.removeChild(script); }
                            script = undefined;
                            if (!isAbort) { callback(200, "success"); }
                        }
                    };
                    head.insertBefore(script, head.firstChild);
                },
                abort: function() { if (script) { script.onload(0, 1); } }
            };
        }
    });
    var xhrCallbacks, xhrOnUnloadAbort = window.ActiveXObject ? function() { for (var key in xhrCallbacks) { xhrCallbacks[key](0, 1); } } : false,
        xhrId = 0;

    function createStandardXHR() { try { return new window.XMLHttpRequest(); } catch (e) {} }

    function createActiveXHR() { try { return new window.ActiveXObject("Microsoft.XMLHTTP"); } catch (e) {} }
    jQuery.ajaxSettings.xhr = window.ActiveXObject ? function() { return !this.isLocal && createStandardXHR() || createActiveXHR(); } : createStandardXHR;
    (function(xhr) { jQuery.extend(jQuery.support, { ajax: !!xhr, cors: !!xhr && ("withCredentials" in xhr) }); })(jQuery.ajaxSettings.xhr());
    if (jQuery.support.ajax) {
        jQuery.ajaxTransport(function(s) {
            if (!s.crossDomain || jQuery.support.cors) {
                var callback;
                return {
                    send: function(headers, complete) {
                        var handle, i, xhr = s.xhr();
                        if (s.username) { xhr.open(s.type, s.url, s.async, s.username, s.password); } else { xhr.open(s.type, s.url, s.async); }
                        if (s.xhrFields) { for (i in s.xhrFields) { xhr[i] = s.xhrFields[i]; } }
                        if (s.mimeType && xhr.overrideMimeType) { xhr.overrideMimeType(s.mimeType); }
                        if (!s.crossDomain && !headers["X-Requested-With"]) { headers["X-Requested-With"] = "XMLHttpRequest"; }
                        try { for (i in headers) { xhr.setRequestHeader(i, headers[i]); } } catch (_) {}
                        xhr.send((s.hasContent && s.data) || null);
                        callback = function(_, isAbort) {
                            var status, statusText, responseHeaders, responses, xml;
                            try {
                                if (callback && (isAbort || xhr.readyState === 4)) {
                                    callback = undefined;
                                    if (handle) { xhr.onreadystatechange = jQuery.noop; if (xhrOnUnloadAbort) { delete xhrCallbacks[handle]; } }
                                    if (isAbort) { if (xhr.readyState !== 4) { xhr.abort(); } } else {
                                        status = xhr.status;
                                        responseHeaders = xhr.getAllResponseHeaders();
                                        responses = {};
                                        xml = xhr.responseXML;
                                        if (xml && xml.documentElement) { responses.xml = xml; }
                                        try { responses.text = xhr.responseText; } catch (e) {}
                                        try { statusText = xhr.statusText; } catch (e) { statusText = ""; }
                                        if (!status && s.isLocal && !s.crossDomain) { status = responses.text ? 200 : 404; } else if (status === 1223) { status = 204; }
                                    }
                                }
                            } catch (firefoxAccessException) { if (!isAbort) { complete(-1, firefoxAccessException); } }
                            if (responses) { complete(status, statusText, responses, responseHeaders); }
                        };
                        if (!s.async) { callback(); } else if (xhr.readyState === 4) { setTimeout(callback, 0); } else {
                            handle = ++xhrId;
                            if (xhrOnUnloadAbort) {
                                if (!xhrCallbacks) { xhrCallbacks = {};
                                    jQuery(window).unload(xhrOnUnloadAbort); }
                                xhrCallbacks[handle] = callback;
                            }
                            xhr.onreadystatechange = callback;
                        }
                    },
                    abort: function() { if (callback) { callback(0, 1); } }
                };
            }
        });
    }
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/,
        rfxnum = new RegExp("^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i"),
        rrun = /queueHooks$/,
        animationPrefilters = [defaultPrefilter],
        tweeners = {
            "*": [function(prop, value) {
                var end, unit, tween = this.createTween(prop, value),
                    parts = rfxnum.exec(value),
                    target = tween.cur(),
                    start = +target || 0,
                    scale = 1,
                    maxIterations = 20;
                if (parts) {
                    end = +parts[2];
                    unit = parts[3] || (jQuery.cssNumber[prop] ? "" : "px");
                    if (unit !== "px" && start) { start = jQuery.css(tween.elem, prop, true) || end || 1;
                        do { scale = scale || ".5";
                            start = start / scale;
                            jQuery.style(tween.elem, prop, start + unit); } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations); }
                    tween.unit = unit;
                    tween.start = start;
                    tween.end = parts[1] ? start + (parts[1] + 1) * end : end;
                }
                return tween;
            }]
        };

    function createFxNow() { setTimeout(function() { fxNow = undefined; }, 0); return (fxNow = jQuery.now()); }

    function createTweens(animation, props) { jQuery.each(props, function(prop, value) { var collection = (tweeners[prop] || []).concat(tweeners["*"]),
                index = 0,
                length = collection.length; for (; index < length; index++) { if (collection[index].call(animation, prop, value)) { return; } } }); }

    function Animation(elem, properties, options) {
        var result, index = 0,
            tweenerIndex = 0,
            length = animationPrefilters.length,
            deferred = jQuery.Deferred().always(function() { delete tick.elem; }),
            tick = function() {
                var currentTime = fxNow || createFxNow(),
                    remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
                    temp = remaining / animation.duration || 0,
                    percent = 1 - temp,
                    index = 0,
                    length = animation.tweens.length;
                for (; index < length; index++) { animation.tweens[index].run(percent); }
                deferred.notifyWith(elem, [animation, percent, remaining]);
                if (percent < 1 && length) { return remaining; } else { deferred.resolveWith(elem, [animation]); return false; }
            },
            animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(true, { specialEasing: {} }, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function(prop, end, easing) { var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    animation.tweens.push(tween); return tween; },
                stop: function(gotoEnd) {
                    var index = 0,
                        length = gotoEnd ? animation.tweens.length : 0;
                    for (; index < length; index++) { animation.tweens[index].run(1); }
                    if (gotoEnd) { deferred.resolveWith(elem, [animation, gotoEnd]); } else { deferred.rejectWith(elem, [animation, gotoEnd]); }
                    return this;
                }
            }),
            props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) { result = animationPrefilters[index].call(animation, elem, props, animation.opts); if (result) { return result; } }
        createTweens(animation, props);
        if (jQuery.isFunction(animation.opts.start)) { animation.opts.start.call(elem, animation); }
        jQuery.fx.timer(jQuery.extend(tick, { anim: animation, queue: animation.opts.queue, elem: elem }));
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) { easing = value[1];
                value = props[index] = value[0]; }
            if (index !== name) { props[name] = value;
                delete props[index]; }
            hooks = jQuery.cssHooks[name];
            if (hooks && "expand" in hooks) { value = hooks.expand(value);
                delete props[name]; for (index in value) { if (!(index in props)) { props[index] = value[index];
                        specialEasing[index] = easing; } } } else { specialEasing[name] = easing; }
        }
    }
    jQuery.Animation = jQuery.extend(Animation, {
        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) { callback = props;
                props = ["*"]; } else { props = props.split(" "); }
            var prop, index = 0,
                length = props.length;
            for (; index < length; index++) { prop = props[index];
                tweeners[prop] = tweeners[prop] || [];
                tweeners[prop].unshift(callback); }
        },
        prefilter: function(callback, prepend) { if (prepend) { animationPrefilters.unshift(callback); } else { animationPrefilters.push(callback); } }
    });

    function defaultPrefilter(elem, props, opts) {
        var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire, anim = this,
            style = elem.style,
            orig = {},
            handled = [],
            hidden = elem.nodeType && isHidden(elem);
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) { hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() { if (!hooks.unqueued) { oldfire(); } }; }
            hooks.unqueued++;
            anim.always(function() { anim.always(function() { hooks.unqueued--; if (!jQuery.queue(elem, "fx").length) { hooks.empty.fire(); } }); });
        }
        if (elem.nodeType === 1 && ("height" in props || "width" in props)) { opts.overflow = [style.overflow, style.overflowX, style.overflowY]; if (jQuery.css(elem, "display") === "inline" && jQuery.css(elem, "float") === "none") { if (!jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay(elem.nodeName) === "inline") { style.display = "inline-block"; } else { style.zoom = 1; } } }
        if (opts.overflow) { style.overflow = "hidden"; if (!jQuery.support.shrinkWrapBlocks) { anim.done(function() { style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2]; }); } }
        for (index in props) {
            value = props[index];
            if (rfxtypes.exec(value)) {
                delete props[index];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) { continue; }
                handled.push(index);
            }
        }
        length = handled.length;
        if (length) {
            dataShow = jQuery._data(elem, "fxshow") || jQuery._data(elem, "fxshow", {});
            if ("hidden" in dataShow) { hidden = dataShow.hidden; }
            if (toggle) { dataShow.hidden = !hidden; }
            if (hidden) { jQuery(elem).show(); } else { anim.done(function() { jQuery(elem).hide(); }); }
            anim.done(function() { var prop;
                jQuery.removeData(elem, "fxshow", true); for (prop in orig) { jQuery.style(elem, prop, orig[prop]); } });
            for (index = 0; index < length; index++) { prop = handled[index];
                tween = anim.createTween(prop, hidden ? dataShow[prop] : 0);
                orig[prop] = dataShow[prop] || jQuery.style(elem, prop); if (!(prop in dataShow)) { dataShow[prop] = tween.start; if (hidden) { tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0; } } }
        }
    }

    function Tween(elem, options, prop, end, easing) { return new Tween.prototype.init(elem, options, prop, end, easing); }
    jQuery.Tween = Tween;
    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) { this.elem = elem;
            this.prop = prop;
            this.easing = easing || "swing";
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px"); },
        cur: function() { var hooks = Tween.propHooks[this.prop]; return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this); },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            if (this.options.duration) { this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration); } else { this.pos = eased = percent; }
            this.now = (this.end - this.start) * eased + this.start;
            if (this.options.step) { this.options.step.call(this.elem, this.now, this); }
            if (hooks && hooks.set) { hooks.set(this); } else { Tween.propHooks._default.set(this); }
            return this;
        }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) { return tween.elem[tween.prop]; }
                result = jQuery.css(tween.elem, tween.prop, false, "");
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) { if (jQuery.fx.step[tween.prop]) { jQuery.fx.step[tween.prop](tween); } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) { jQuery.style(tween.elem, tween.prop, tween.now + tween.unit); } else { tween.elem[tween.prop] = tween.now; } }
        }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = { set: function(tween) { if (tween.elem.nodeType && tween.elem.parentNode) { tween.elem[tween.prop] = tween.now; } } };
    jQuery.each(["toggle", "show", "hide"], function(i, name) { var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) { return speed == null || typeof speed === "boolean" || (!i && jQuery.isFunction(speed) && jQuery.isFunction(easing)) ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback); }; });
    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) { return this.filter(isHidden).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback); },
        animate: function(prop, speed, easing, callback) { var empty = jQuery.isEmptyObject(prop),
                optall = jQuery.speed(speed, easing, callback),
                doAnimation = function() { var anim = Animation(this, jQuery.extend({}, prop), optall); if (empty) { anim.stop(true); } }; return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation); },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) { var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd); };
            if (typeof type !== "string") { gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined; }
            if (clearQueue && type !== false) { this.queue(type || "fx", []); }
            return this.each(function() {
                var dequeue = true,
                    index = type != null && type + "queueHooks",
                    timers = jQuery.timers,
                    data = jQuery._data(this);
                if (index) { if (data[index] && data[index].stop) { stopQueue(data[index]); } } else { for (index in data) { if (data[index] && data[index].stop && rrun.test(index)) { stopQueue(data[index]); } } }
                for (index = timers.length; index--;) { if (timers[index].elem === this && (type == null || timers[index].queue === type)) { timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1); } }
                if (dequeue || !gotoEnd) { jQuery.dequeue(this, type); }
            });
        }
    });

    function genFx(type, includeWidth) {
        var which, attrs = { height: type },
            i = 0;
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) { which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type; }
        if (includeWidth) { attrs.opacity = attrs.width = type; }
        return attrs;
    }
    jQuery.each({ slideDown: genFx("show"), slideUp: genFx("hide"), slideToggle: genFx("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function(name, props) { jQuery.fn[name] = function(speed, easing, callback) { return this.animate(props, speed, easing, callback); }; });
    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : { complete: fn || !fn && easing || jQuery.isFunction(speed) && speed, duration: speed, easing: fn && easing || easing && !jQuery.isFunction(easing) && easing };
        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
        if (opt.queue == null || opt.queue === true) { opt.queue = "fx"; }
        opt.old = opt.complete;
        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) { opt.old.call(this); }
            if (opt.queue) { jQuery.dequeue(this, opt.queue); }
        };
        return opt;
    };
    jQuery.easing = { linear: function(p) { return p; }, swing: function(p) { return 0.5 - Math.cos(p * Math.PI) / 2; } };
    jQuery.timers = [];
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.tick = function() {
        var timer, timers = jQuery.timers,
            i = 0;
        fxNow = jQuery.now();
        for (; i < timers.length; i++) { timer = timers[i]; if (!timer() && timers[i] === timer) { timers.splice(i--, 1); } }
        if (!timers.length) { jQuery.fx.stop(); }
        fxNow = undefined;
    };
    jQuery.fx.timer = function(timer) { if (timer() && jQuery.timers.push(timer) && !timerId) { timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval); } };
    jQuery.fx.interval = 13;
    jQuery.fx.stop = function() { clearInterval(timerId);
        timerId = null; };
    jQuery.fx.speeds = { slow: 600, fast: 200, _default: 400 };
    jQuery.fx.step = {};
    if (jQuery.expr && jQuery.expr.filters) { jQuery.expr.filters.animated = function(elem) { return jQuery.grep(jQuery.timers, function(fn) { return elem === fn.elem; }).length; }; }
    var rroot = /^(?:body|html)$/i;
    jQuery.fn.offset = function(options) {
        if (arguments.length) { return options === undefined ? this : this.each(function(i) { jQuery.offset.setOffset(this, options, i); }); }
        var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft, box = { top: 0, left: 0 },
            elem = this[0],
            doc = elem && elem.ownerDocument;
        if (!doc) { return; }
        if ((body = doc.body) === elem) { return jQuery.offset.bodyOffset(elem); }
        docElem = doc.documentElement;
        if (!jQuery.contains(docElem, elem)) { return box; }
        if (typeof elem.getBoundingClientRect !== "undefined") { box = elem.getBoundingClientRect(); }
        win = getWindow(doc);
        clientTop = docElem.clientTop || body.clientTop || 0;
        clientLeft = docElem.clientLeft || body.clientLeft || 0;
        scrollTop = win.pageYOffset || docElem.scrollTop;
        scrollLeft = win.pageXOffset || docElem.scrollLeft;
        return { top: box.top + scrollTop - clientTop, left: box.left + scrollLeft - clientLeft };
    };
    jQuery.offset = {
        bodyOffset: function(body) {
            var top = body.offsetTop,
                left = body.offsetLeft;
            if (jQuery.support.doesNotIncludeMarginInBodyOffset) { top += parseFloat(jQuery.css(body, "marginTop")) || 0;
                left += parseFloat(jQuery.css(body, "marginLeft")) || 0; }
            return { top: top, left: left };
        },
        setOffset: function(elem, options, i) {
            var position = jQuery.css(elem, "position");
            if (position === "static") { elem.style.position = "relative"; }
            var curElem = jQuery(elem),
                curOffset = curElem.offset(),
                curCSSTop = jQuery.css(elem, "top"),
                curCSSLeft = jQuery.css(elem, "left"),
                calculatePosition = (position === "absolute" || position === "fixed") && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
                props = {},
                curPosition = {},
                curTop, curLeft;
            if (calculatePosition) { curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left; } else { curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0; }
            if (jQuery.isFunction(options)) { options = options.call(elem, i, curOffset); }
            if (options.top != null) { props.top = (options.top - curOffset.top) + curTop; }
            if (options.left != null) { props.left = (options.left - curOffset.left) + curLeft; }
            if ("using" in options) { options.using.call(elem, props); } else { curElem.css(props); }
        }
    };
    jQuery.fn.extend({
        position: function() {
            if (!this[0]) { return; }
            var elem = this[0],
                offsetParent = this.offsetParent(),
                offset = this.offset(),
                parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();
            offset.top -= parseFloat(jQuery.css(elem, "marginTop")) || 0;
            offset.left -= parseFloat(jQuery.css(elem, "marginLeft")) || 0;
            parentOffset.top += parseFloat(jQuery.css(offsetParent[0], "borderTopWidth")) || 0;
            parentOffset.left += parseFloat(jQuery.css(offsetParent[0], "borderLeftWidth")) || 0;
            return { top: offset.top - parentOffset.top, left: offset.left - parentOffset.left };
        },
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent || document.body;
                while (offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static")) { offsetParent = offsetParent.offsetParent; }
                return offsetParent || document.body;
            });
        }
    });
    jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
        var top = /Y/.test(prop);
        jQuery.fn[method] = function(val) {
            return jQuery.access(this, function(elem, method, val) {
                var win = getWindow(elem);
                if (val === undefined) { return win ? (prop in win) ? win[prop] : win.document.documentElement[method] : elem[method]; }
                if (win) { win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop()); } else { elem[method] = val; }
            }, method, val, arguments.length, null);
        };
    });

    function getWindow(elem) { return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false; }
    jQuery.each({ Height: "height", Width: "width" }, function(name, type) {
        jQuery.each({ padding: "inner" + name, content: type, "": "outer" + name }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                    extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
                return jQuery.access(this, function(elem, type, value) {
                    var doc;
                    if (jQuery.isWindow(elem)) { return elem.document.documentElement["client" + name]; }
                    if (elem.nodeType === 9) { doc = elem.documentElement; return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]); }
                    return value === undefined ? jQuery.css(elem, type, value, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            };
        });
    });
    window.jQuery = window.$ = jQuery;
    if (typeof define === "function" && define.amd && define.amd.jQuery) { define("jquery", [], function() { return jQuery; }); }
})(window);
(function($) {
    function rewriteSelector(context, name, argPos) { var original = context[name]; if (!original) return;
        context[name] = function() { arguments[argPos] = arguments[argPos].replace(/@([\w\u00c0-\uFFFF\-]+)/g, '[data-role~="$1"]'); return original.apply(context, arguments); };
        $.extend(context[name], original); }
    rewriteSelector($, 'find', 0);
    rewriteSelector($, 'multiFilter', 0);
    rewriteSelector($.find, 'matchesSelector', 1);
    rewriteSelector($.find, 'matches', 0);

    function parse(roleString, without) {
        var role, result = [],
            roles = $.trim(roleString).split(/\s+/);
        for (var i = 0; i < roles.length; i++) {
            role = roles[i];
            if (!~$.inArray(role, result) && (!without || !~$.inArray(role, without)))
                result.push(role);
        }
        return result;
    };
    $.extend($.fn, {
        roles: function() { return parse(this.attr('data-role')); },
        hasRole: function(roleName) {
            var roles = parse(roleName);
            for (var i = 0; i < roles.length; i++)
                if (!this.is('@' + roles[i])) return false;
            return true;
        },
        addRole: function(roleName) { if (this.hasRole(roleName)) return this; return this.each(function(_, element) { var $el = $(element);
                $el.attr('data-role', parse($el.attr('data-role') + ' ' + roleName).join(' ')); }); },
        removeRole: function(roleName) { if (!this.hasRole(roleName)) return this; return this.each(function(_, element) { var $el = $(element);
                $el.attr('data-role', parse($el.attr('data-role'), parse(roleName)).join(' ')); }); },
        toggleRole: function(roleName) {
            var roles = parse(roleName);
            for (var i = 0; i < roles.length; i++)
                this[this.hasRole(roles[i]) ? 'removeRole' : 'addRole'].call(this, roles[i]);
            return this;
        }
    });
})(jQuery);
(function(f) { if (typeof exports === "object" && typeof module !== "undefined") { module.exports = f() } else if (typeof define === "function" && define.amd) { define([], f) } else { var g; if (typeof window !== "undefined") { g = window } else if (typeof global !== "undefined") { g = global } else if (typeof self !== "undefined") { g = self } else { g = this } g.PIXI = f() } })(function() {
    var define, module, exports;
    return (function e(t, n, r) {
        function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = "MODULE_NOT_FOUND", f } var l = n[o] = { exports: {} };
                t[o][0].call(l.exports, function(e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++) s(r[o]); return s })({
        1: [function(require, module, exports) {
            "use strict";
            "use restrict";
            var INT_BITS = 32;
            exports.INT_BITS = INT_BITS;
            exports.INT_MAX = 0x7fffffff;
            exports.INT_MIN = -1 << (INT_BITS - 1);
            exports.sign = function(v) { return (v > 0) - (v < 0); }
            exports.abs = function(v) { var mask = v >> (INT_BITS - 1); return (v ^ mask) - mask; }
            exports.min = function(x, y) { return y ^ ((x ^ y) & -(x < y)); }
            exports.max = function(x, y) { return x ^ ((x ^ y) & -(x < y)); }
            exports.isPow2 = function(v) { return !(v & (v - 1)) && (!!v); }
            exports.log2 = function(v) { var r, shift;
                r = (v > 0xFFFF) << 4;
                v >>>= r;
                shift = (v > 0xFF) << 3;
                v >>>= shift;
                r |= shift;
                shift = (v > 0xF) << 2;
                v >>>= shift;
                r |= shift;
                shift = (v > 0x3) << 1;
                v >>>= shift;
                r |= shift; return r | (v >> 1); }
            exports.log10 = function(v) { return (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 : (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 : (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0; }
            exports.popCount = function(v) { v = v - ((v >>> 1) & 0x55555555);
                v = (v & 0x33333333) + ((v >>> 2) & 0x33333333); return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24; }

            function countTrailingZeros(v) { var c = 32;
                v &= -v; if (v) c--; if (v & 0x0000FFFF) c -= 16; if (v & 0x00FF00FF) c -= 8; if (v & 0x0F0F0F0F) c -= 4; if (v & 0x33333333) c -= 2; if (v & 0x55555555) c -= 1; return c; }
            exports.countTrailingZeros = countTrailingZeros;
            exports.nextPow2 = function(v) { v += v === 0;--v;
                v |= v >>> 1;
                v |= v >>> 2;
                v |= v >>> 4;
                v |= v >>> 8;
                v |= v >>> 16; return v + 1; }
            exports.prevPow2 = function(v) { v |= v >>> 1;
                v |= v >>> 2;
                v |= v >>> 4;
                v |= v >>> 8;
                v |= v >>> 16; return v - (v >>> 1); }
            exports.parity = function(v) { v ^= v >>> 16;
                v ^= v >>> 8;
                v ^= v >>> 4;
                v &= 0xf; return (0x6996 >>> v) & 1; }
            var REVERSE_TABLE = new Array(256);
            (function(tab) {
                for (var i = 0; i < 256; ++i) {
                    var v = i,
                        r = i,
                        s = 7;
                    for (v >>>= 1; v; v >>>= 1) { r <<= 1;
                        r |= v & 1;--s; }
                    tab[i] = (r << s) & 0xff;
                }
            })(REVERSE_TABLE);
            exports.reverse = function(v) { return (REVERSE_TABLE[v & 0xff] << 24) | (REVERSE_TABLE[(v >>> 8) & 0xff] << 16) | (REVERSE_TABLE[(v >>> 16) & 0xff] << 8) | REVERSE_TABLE[(v >>> 24) & 0xff]; }
            exports.interleave2 = function(x, y) { x &= 0xFFFF;
                x = (x | (x << 8)) & 0x00FF00FF;
                x = (x | (x << 4)) & 0x0F0F0F0F;
                x = (x | (x << 2)) & 0x33333333;
                x = (x | (x << 1)) & 0x55555555;
                y &= 0xFFFF;
                y = (y | (y << 8)) & 0x00FF00FF;
                y = (y | (y << 4)) & 0x0F0F0F0F;
                y = (y | (y << 2)) & 0x33333333;
                y = (y | (y << 1)) & 0x55555555; return x | (y << 1); }
            exports.deinterleave2 = function(v, n) { v = (v >>> n) & 0x55555555;
                v = (v | (v >>> 1)) & 0x33333333;
                v = (v | (v >>> 2)) & 0x0F0F0F0F;
                v = (v | (v >>> 4)) & 0x00FF00FF;
                v = (v | (v >>> 16)) & 0x000FFFF; return (v << 16) >> 16; }
            exports.interleave3 = function(x, y, z) { x &= 0x3FF;
                x = (x | (x << 16)) & 4278190335;
                x = (x | (x << 8)) & 251719695;
                x = (x | (x << 4)) & 3272356035;
                x = (x | (x << 2)) & 1227133513;
                y &= 0x3FF;
                y = (y | (y << 16)) & 4278190335;
                y = (y | (y << 8)) & 251719695;
                y = (y | (y << 4)) & 3272356035;
                y = (y | (y << 2)) & 1227133513;
                x |= (y << 1);
                z &= 0x3FF;
                z = (z | (z << 16)) & 4278190335;
                z = (z | (z << 8)) & 251719695;
                z = (z | (z << 4)) & 3272356035;
                z = (z | (z << 2)) & 1227133513; return x | (z << 2); }
            exports.deinterleave3 = function(v, n) { v = (v >>> n) & 1227133513;
                v = (v | (v >>> 2)) & 3272356035;
                v = (v | (v >>> 4)) & 251719695;
                v = (v | (v >>> 8)) & 4278190335;
                v = (v | (v >>> 16)) & 0x3FF; return (v << 22) >> 22; }
            exports.nextCombination = function(v) { var t = v | (v - 1); return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1)); }
        }, {}],
        2: [function(require, module, exports) {
            'use strict';
            module.exports = earcut;

            function earcut(data, holeIndices, dim) {
                dim = dim || 2;
                var hasHoles = holeIndices && holeIndices.length,
                    outerLen = hasHoles ? holeIndices[0] * dim : data.length,
                    outerNode = linkedList(data, 0, outerLen, dim, true),
                    triangles = [];
                if (!outerNode) return triangles;
                var minX, minY, maxX, maxY, x, y, size;
                if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
                if (data.length > 80 * dim) {
                    minX = maxX = data[0];
                    minY = maxY = data[1];
                    for (var i = dim; i < outerLen; i += dim) { x = data[i];
                        y = data[i + 1]; if (x < minX) minX = x; if (y < minY) minY = y; if (x > maxX) maxX = x; if (y > maxY) maxY = y; }
                    size = Math.max(maxX - minX, maxY - minY);
                }
                earcutLinked(outerNode, triangles, dim, minX, minY, size);
                return triangles;
            }

            function linkedList(data, start, end, dim, clockwise) {
                var i, last;
                if (clockwise === (signedArea(data, start, end, dim) > 0)) { for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last); } else { for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last); }
                if (last && equals(last, last.next)) { removeNode(last);
                    last = last.next; }
                return last;
            }

            function filterPoints(start, end) { if (!start) return start; if (!end) end = start; var p = start,
                    again;
                do { again = false; if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) { removeNode(p);
                        p = end = p.prev; if (p === p.next) return null;
                        again = true; } else { p = p.next; } } while (again || p !== end); return end; }

            function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
                if (!ear) return;
                if (!pass && size) indexCurve(ear, minX, minY, size);
                var stop = ear,
                    prev, next;
                while (ear.prev !== ear.next) {
                    prev = ear.prev;
                    next = ear.next;
                    if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) { triangles.push(prev.i / dim);
                        triangles.push(ear.i / dim);
                        triangles.push(next.i / dim);
                        removeNode(ear);
                        ear = next.next;
                        stop = next.next; continue; }
                    ear = next;
                    if (ear === stop) {
                        if (!pass) { earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1); } else if (pass === 1) { ear = cureLocalIntersections(ear, triangles, dim);
                            earcutLinked(ear, triangles, dim, minX, minY, size, 2); } else if (pass === 2) { splitEarcut(ear, triangles, dim, minX, minY, size); }
                        break;
                    }
                }
            }

            function isEar(ear) {
                var a = ear.prev,
                    b = ear,
                    c = ear.next;
                if (area(a, b, c) >= 0) return false;
                var p = ear.next.next;
                while (p !== ear.prev) { if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
                    p = p.next; }
                return true;
            }

            function isEarHashed(ear, minX, minY, size) {
                var a = ear.prev,
                    b = ear,
                    c = ear.next;
                if (area(a, b, c) >= 0) return false;
                var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
                    minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
                    maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
                    maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
                var minZ = zOrder(minTX, minTY, minX, minY, size),
                    maxZ = zOrder(maxTX, maxTY, minX, minY, size);
                var p = ear.nextZ;
                while (p && p.z <= maxZ) { if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
                    p = p.nextZ; }
                p = ear.prevZ;
                while (p && p.z >= minZ) { if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
                    p = p.prevZ; }
                return true;
            }

            function cureLocalIntersections(start, triangles, dim) {
                var p = start;
                do {
                    var a = p.prev,
                        b = p.next.next;
                    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) { triangles.push(a.i / dim);
                        triangles.push(p.i / dim);
                        triangles.push(b.i / dim);
                        removeNode(p);
                        removeNode(p.next);
                        p = start = b; }
                    p = p.next;
                } while (p !== start);
                return p;
            }

            function splitEarcut(start, triangles, dim, minX, minY, size) {
                var a = start;
                do {
                    var b = a.next.next;
                    while (b !== a.prev) {
                        if (a.i !== b.i && isValidDiagonal(a, b)) { var c = splitPolygon(a, b);
                            a = filterPoints(a, a.next);
                            c = filterPoints(c, c.next);
                            earcutLinked(a, triangles, dim, minX, minY, size);
                            earcutLinked(c, triangles, dim, minX, minY, size); return; }
                        b = b.next;
                    }
                    a = a.next;
                } while (a !== start);
            }

            function eliminateHoles(data, holeIndices, outerNode, dim) {
                var queue = [],
                    i, len, start, end, list;
                for (i = 0, len = holeIndices.length; i < len; i++) { start = holeIndices[i] * dim;
                    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                    list = linkedList(data, start, end, dim, false); if (list === list.next) list.steiner = true;
                    queue.push(getLeftmost(list)); }
                queue.sort(compareX);
                for (i = 0; i < queue.length; i++) { eliminateHole(queue[i], outerNode);
                    outerNode = filterPoints(outerNode, outerNode.next); }
                return outerNode;
            }

            function compareX(a, b) { return a.x - b.x; }

            function eliminateHole(hole, outerNode) { outerNode = findHoleBridge(hole, outerNode); if (outerNode) { var b = splitPolygon(outerNode, hole);
                    filterPoints(b, b.next); } }

            function findHoleBridge(hole, outerNode) {
                var p = outerNode,
                    hx = hole.x,
                    hy = hole.y,
                    qx = -Infinity,
                    m;
                do {
                    if (hy <= p.y && hy >= p.next.y) {
                        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                        if (x <= hx && x > qx) {
                            qx = x;
                            if (x === hx) { if (hy === p.y) return p; if (hy === p.next.y) return p.next; }
                            m = p.x < p.next.x ? p : p.next;
                        }
                    }
                    p = p.next;
                } while (p !== outerNode);
                if (!m) return null;
                if (hx === qx) return m.prev;
                var stop = m,
                    mx = m.x,
                    my = m.y,
                    tanMin = Infinity,
                    tan;
                p = m.next;
                while (p !== stop) {
                    if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) { tan = Math.abs(hy - p.y) / (hx - p.x); if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) { m = p;
                            tanMin = tan; } }
                    p = p.next;
                }
                return m;
            }

            function indexCurve(start, minX, minY, size) { var p = start;
                do { if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
                    p.prevZ = p.prev;
                    p.nextZ = p.next;
                    p = p.next; } while (p !== start);
                p.prevZ.nextZ = null;
                p.prevZ = null;
                sortLinked(p); }

            function sortLinked(list) {
                var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
                do {
                    p = list;
                    list = null;
                    tail = null;
                    numMerges = 0;
                    while (p) {
                        numMerges++;
                        q = p;
                        pSize = 0;
                        for (i = 0; i < inSize; i++) { pSize++;
                            q = q.nextZ; if (!q) break; }
                        qSize = inSize;
                        while (pSize > 0 || (qSize > 0 && q)) {
                            if (pSize === 0) { e = q;
                                q = q.nextZ;
                                qSize--; } else if (qSize === 0 || !q) { e = p;
                                p = p.nextZ;
                                pSize--; } else if (p.z <= q.z) { e = p;
                                p = p.nextZ;
                                pSize--; } else { e = q;
                                q = q.nextZ;
                                qSize--; }
                            if (tail) tail.nextZ = e;
                            else list = e;
                            e.prevZ = tail;
                            tail = e;
                        }
                        p = q;
                    }
                    tail.nextZ = null;
                    inSize *= 2;
                } while (numMerges > 1);
                return list;
            }

            function zOrder(x, y, minX, minY, size) { x = 32767 * (x - minX) / size;
                y = 32767 * (y - minY) / size;
                x = (x | (x << 8)) & 0x00FF00FF;
                x = (x | (x << 4)) & 0x0F0F0F0F;
                x = (x | (x << 2)) & 0x33333333;
                x = (x | (x << 1)) & 0x55555555;
                y = (y | (y << 8)) & 0x00FF00FF;
                y = (y | (y << 4)) & 0x0F0F0F0F;
                y = (y | (y << 2)) & 0x33333333;
                y = (y | (y << 1)) & 0x55555555; return x | (y << 1); }

            function getLeftmost(start) { var p = start,
                    leftmost = start;
                do { if (p.x < leftmost.x) leftmost = p;
                    p = p.next; } while (p !== start); return leftmost; }

            function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) { return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0; }

            function isValidDiagonal(a, b) { return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b); }

            function area(p, q, r) { return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); }

            function equals(p1, p2) { return p1.x === p2.x && p1.y === p2.y; }

            function intersects(p1, q1, p2, q2) { if ((equals(p1, q1) && equals(p2, q2)) || (equals(p1, q2) && equals(p2, q1))) return true; return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0; }

            function intersectsPolygon(a, b) { var p = a;
                do { if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
                    p = p.next; } while (p !== a); return false; }

            function locallyInside(a, b) { return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0; }

            function middleInside(a, b) {
                var p = a,
                    inside = false,
                    px = (a.x + b.x) / 2,
                    py = (a.y + b.y) / 2;
                do {
                    if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                        inside = !inside;
                    p = p.next;
                } while (p !== a);
                return inside;
            }

            function splitPolygon(a, b) { var a2 = new Node(a.i, a.x, a.y),
                    b2 = new Node(b.i, b.x, b.y),
                    an = a.next,
                    bp = b.prev;
                a.next = b;
                b.prev = a;
                a2.next = an;
                an.prev = a2;
                b2.next = a2;
                a2.prev = b2;
                bp.next = b2;
                b2.prev = bp; return b2; }

            function insertNode(i, x, y, last) {
                var p = new Node(i, x, y);
                if (!last) { p.prev = p;
                    p.next = p; } else { p.next = last.next;
                    p.prev = last;
                    last.next.prev = p;
                    last.next = p; }
                return p;
            }

            function removeNode(p) { p.next.prev = p.prev;
                p.prev.next = p.next; if (p.prevZ) p.prevZ.nextZ = p.nextZ; if (p.nextZ) p.nextZ.prevZ = p.prevZ; }

            function Node(i, x, y) { this.i = i;
                this.x = x;
                this.y = y;
                this.prev = null;
                this.next = null;
                this.z = null;
                this.prevZ = null;
                this.nextZ = null;
                this.steiner = false; }
            earcut.deviation = function(data, holeIndices, dim, triangles) {
                var hasHoles = holeIndices && holeIndices.length;
                var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
                var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
                if (hasHoles) { for (var i = 0, len = holeIndices.length; i < len; i++) { var start = holeIndices[i] * dim; var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                        polygonArea -= Math.abs(signedArea(data, start, end, dim)); } }
                var trianglesArea = 0;
                for (i = 0; i < triangles.length; i += 3) {
                    var a = triangles[i] * dim;
                    var b = triangles[i + 1] * dim;
                    var c = triangles[i + 2] * dim;
                    trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
                        (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
                }
                return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
            };

            function signedArea(data, start, end, dim) {
                var sum = 0;
                for (var i = start, j = end - dim; i < end; i += dim) { sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                    j = i; }
                return sum;
            }
            earcut.flatten = function(data) {
                var dim = data[0][0].length,
                    result = { vertices: [], holes: [], dimensions: dim },
                    holeIndex = 0;
                for (var i = 0; i < data.length; i++) {
                    for (var j = 0; j < data[i].length; j++) { for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]); }
                    if (i > 0) { holeIndex += data[i - 1].length;
                        result.holes.push(holeIndex); }
                }
                return result;
            };
        }, {}],
        3: [function(require, module, exports) {
            'use strict';
            var has = Object.prototype.hasOwnProperty,
                prefix = '~';

            function Events() {}
            if (Object.create) { Events.prototype = Object.create(null); if (!new Events().__proto__) prefix = false; }

            function EE(fn, context, once) { this.fn = fn;
                this.context = context;
                this.once = once || false; }

            function EventEmitter() { this._events = new Events();
                this._eventsCount = 0; }
            EventEmitter.prototype.eventNames = function eventNames() {
                var names = [],
                    events, name;
                if (this._eventsCount === 0) return names;
                for (name in (events = this._events)) { if (has.call(events, name)) names.push(prefix ? name.slice(1) : name); }
                if (Object.getOwnPropertySymbols) { return names.concat(Object.getOwnPropertySymbols(events)); }
                return names;
            };
            EventEmitter.prototype.listeners = function listeners(event, exists) {
                var evt = prefix ? prefix + event : event,
                    available = this._events[evt];
                if (exists) return !!available;
                if (!available) return [];
                if (available.fn) return [available.fn];
                for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) { ee[i] = available[i].fn; }
                return ee;
            };
            EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
                var evt = prefix ? prefix + event : event;
                if (!this._events[evt]) return false;
                var listeners = this._events[evt],
                    len = arguments.length,
                    args, i;
                if (listeners.fn) {
                    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
                    switch (len) {
                        case 1:
                            return listeners.fn.call(listeners.context), true;
                        case 2:
                            return listeners.fn.call(listeners.context, a1), true;
                        case 3:
                            return listeners.fn.call(listeners.context, a1, a2), true;
                        case 4:
                            return listeners.fn.call(listeners.context, a1, a2, a3), true;
                        case 5:
                            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
                        case 6:
                            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true; }
                    for (i = 1, args = new Array(len - 1); i < len; i++) { args[i - 1] = arguments[i]; }
                    listeners.fn.apply(listeners.context, args);
                } else {
                    var length = listeners.length,
                        j;
                    for (i = 0; i < length; i++) {
                        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
                        switch (len) {
                            case 1:
                                listeners[i].fn.call(listeners[i].context);
                                break;
                            case 2:
                                listeners[i].fn.call(listeners[i].context, a1);
                                break;
                            case 3:
                                listeners[i].fn.call(listeners[i].context, a1, a2);
                                break;
                            case 4:
                                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                                break;
                            default:
                                if (!args)
                                    for (j = 1, args = new Array(len - 1); j < len; j++) { args[j - 1] = arguments[j]; }
                                listeners[i].fn.apply(listeners[i].context, args);
                        }
                    }
                }
                return true;
            };
            EventEmitter.prototype.on = function on(event, fn, context) { var listener = new EE(fn, context || this),
                    evt = prefix ? prefix + event : event; if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
                else if (!this._events[evt].fn) this._events[evt].push(listener);
                else this._events[evt] = [this._events[evt], listener]; return this; };
            EventEmitter.prototype.once = function once(event, fn, context) { var listener = new EE(fn, context || this, true),
                    evt = prefix ? prefix + event : event; if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;
                else if (!this._events[evt].fn) this._events[evt].push(listener);
                else this._events[evt] = [this._events[evt], listener]; return this; };
            EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
                var evt = prefix ? prefix + event : event;
                if (!this._events[evt]) return this;
                if (!fn) { if (--this._eventsCount === 0) this._events = new Events();
                    else delete this._events[evt]; return this; }
                var listeners = this._events[evt];
                if (listeners.fn) { if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) { if (--this._eventsCount === 0) this._events = new Events();
                        else delete this._events[evt]; } } else {
                    for (var i = 0, events = [], length = listeners.length; i < length; i++) { if (listeners[i].fn !== fn || (once && !listeners[i].once) || (context && listeners[i].context !== context)) { events.push(listeners[i]); } }
                    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
                    else if (--this._eventsCount === 0) this._events = new Events();
                    else delete this._events[evt];
                }
                return this;
            };
            EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
                var evt;
                if (event) { evt = prefix ? prefix + event : event; if (this._events[evt]) { if (--this._eventsCount === 0) this._events = new Events();
                        else delete this._events[evt]; } } else { this._events = new Events();
                    this._eventsCount = 0; }
                return this;
            };
            EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
            EventEmitter.prototype.addListener = EventEmitter.prototype.on;
            EventEmitter.prototype.setMaxListeners = function setMaxListeners() { return this; };
            EventEmitter.prefixed = prefix;
            EventEmitter.EventEmitter = EventEmitter;
            if ('undefined' !== typeof module) { module.exports = EventEmitter; }
        }, {}],
        4: [function(require, module, exports) {
            (function(global) {
                var apple_phone = /iPhone/i,
                    apple_ipod = /iPod/i,
                    apple_tablet = /iPad/i,
                    android_phone = /(?=.*\bAndroid\b)(?=.*\bMobile\b)/i,
                    android_tablet = /Android/i,
                    amazon_phone = /(?=.*\bAndroid\b)(?=.*\bSD4930UR\b)/i,
                    amazon_tablet = /(?=.*\bAndroid\b)(?=.*\b(?:KFOT|KFTT|KFJWI|KFJWA|KFSOWI|KFTHWI|KFTHWA|KFAPWI|KFAPWA|KFARWI|KFASWI|KFSAWI|KFSAWA)\b)/i,
                    windows_phone = /IEMobile/i,
                    windows_tablet = /(?=.*\bWindows\b)(?=.*\bARM\b)/i,
                    other_blackberry = /BlackBerry/i,
                    other_blackberry_10 = /BB10/i,
                    other_opera = /Opera Mini/i,
                    other_chrome = /(CriOS|Chrome)(?=.*\bMobile\b)/i,
                    other_firefox = /(?=.*\bFirefox\b)(?=.*\bMobile\b)/i,
                    seven_inch = new RegExp('(?:' + 'Nexus 7' + '|' + 'BNTV250' + '|' + 'Kindle Fire' + '|' + 'Silk' + '|' + 'GT-P1000' + ')', 'i');
                var match = function(regex, userAgent) { return regex.test(userAgent); };
                var IsMobileClass = function(userAgent) {
                    var ua = userAgent || navigator.userAgent;
                    var tmp = ua.split('[FBAN');
                    if (typeof tmp[1] !== 'undefined') { ua = tmp[0]; }
                    tmp = ua.split('Twitter');
                    if (typeof tmp[1] !== 'undefined') { ua = tmp[0]; }
                    this.apple = { phone: match(apple_phone, ua), ipod: match(apple_ipod, ua), tablet: !match(apple_phone, ua) && match(apple_tablet, ua), device: match(apple_phone, ua) || match(apple_ipod, ua) || match(apple_tablet, ua) };
                    this.amazon = { phone: match(amazon_phone, ua), tablet: !match(amazon_phone, ua) && match(amazon_tablet, ua), device: match(amazon_phone, ua) || match(amazon_tablet, ua) };
                    this.android = { phone: match(amazon_phone, ua) || match(android_phone, ua), tablet: !match(amazon_phone, ua) && !match(android_phone, ua) && (match(amazon_tablet, ua) || match(android_tablet, ua)), device: match(amazon_phone, ua) || match(amazon_tablet, ua) || match(android_phone, ua) || match(android_tablet, ua) };
                    this.windows = { phone: match(windows_phone, ua), tablet: match(windows_tablet, ua), device: match(windows_phone, ua) || match(windows_tablet, ua) };
                    this.other = { blackberry: match(other_blackberry, ua), blackberry10: match(other_blackberry_10, ua), opera: match(other_opera, ua), firefox: match(other_firefox, ua), chrome: match(other_chrome, ua), device: match(other_blackberry, ua) || match(other_blackberry_10, ua) || match(other_opera, ua) || match(other_firefox, ua) || match(other_chrome, ua) };
                    this.seven_inch = match(seven_inch, ua);
                    this.any = this.apple.device || this.android.device || this.windows.device || this.other.device || this.seven_inch;
                    this.phone = this.apple.phone || this.android.phone || this.windows.phone;
                    this.tablet = this.apple.tablet || this.android.tablet || this.windows.tablet;
                    if (typeof window === 'undefined') { return this; }
                };
                var instantiate = function() { var IM = new IsMobileClass();
                    IM.Class = IsMobileClass; return IM; };
                if (typeof module !== 'undefined' && module.exports && typeof window === 'undefined') { module.exports = IsMobileClass; } else if (typeof module !== 'undefined' && module.exports && typeof window !== 'undefined') { module.exports = instantiate(); } else if (typeof define === 'function' && define.amd) { define('isMobile', [], global.isMobile = instantiate()); } else { global.isMobile = instantiate(); }
            })(this);
        }, {}],
        5: [function(require, module, exports) {
            'use strict';
            var getOwnPropertySymbols = Object.getOwnPropertySymbols;
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var propIsEnumerable = Object.prototype.propertyIsEnumerable;

            function toObject(val) {
                if (val === null || val === undefined) { throw new TypeError('Object.assign cannot be called with null or undefined'); }
                return Object(val);
            }

            function shouldUseNative() {
                try {
                    if (!Object.assign) { return false; }
                    var test1 = new String('abc');
                    test1[5] = 'de';
                    if (Object.getOwnPropertyNames(test1)[0] === '5') { return false; }
                    var test2 = {};
                    for (var i = 0; i < 10; i++) { test2['_' + String.fromCharCode(i)] = i; }
                    var order2 = Object.getOwnPropertyNames(test2).map(function(n) { return test2[n]; });
                    if (order2.join('') !== '0123456789') { return false; }
                    var test3 = {};
                    'abcdefghijklmnopqrst'.split('').forEach(function(letter) { test3[letter] = letter; });
                    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') { return false; }
                    return true;
                } catch (err) { return false; }
            }
            module.exports = shouldUseNative() ? Object.assign : function(target, source) {
                var from;
                var to = toObject(target);
                var symbols;
                for (var s = 1; s < arguments.length; s++) {
                    from = Object(arguments[s]);
                    for (var key in from) { if (hasOwnProperty.call(from, key)) { to[key] = from[key]; } }
                    if (getOwnPropertySymbols) { symbols = getOwnPropertySymbols(from); for (var i = 0; i < symbols.length; i++) { if (propIsEnumerable.call(from, symbols[i])) { to[symbols[i]] = from[symbols[i]]; } } }
                }
                return to;
            };
        }, {}],
        6: [function(require, module, exports) {
            var EMPTY_ARRAY_BUFFER = new ArrayBuffer(0);
            var Buffer = function(gl, type, data, drawType) {
                this.gl = gl;
                this.buffer = gl.createBuffer();
                this.type = type || gl.ARRAY_BUFFER;
                this.drawType = drawType || gl.STATIC_DRAW;
                this.data = EMPTY_ARRAY_BUFFER;
                if (data) { this.upload(data); }
            };
            Buffer.prototype.upload = function(data, offset, dontBind) {
                if (!dontBind) this.bind();
                var gl = this.gl;
                data = data || this.data;
                offset = offset || 0;
                if (this.data.byteLength >= data.byteLength) { gl.bufferSubData(this.type, offset, data); } else { gl.bufferData(this.type, data, this.drawType); }
                this.data = data;
            };
            Buffer.prototype.bind = function() { var gl = this.gl;
                gl.bindBuffer(this.type, this.buffer); };
            Buffer.createVertexBuffer = function(gl, data, drawType) { return new Buffer(gl, gl.ARRAY_BUFFER, data, drawType); };
            Buffer.createIndexBuffer = function(gl, data, drawType) { return new Buffer(gl, gl.ELEMENT_ARRAY_BUFFER, data, drawType); };
            Buffer.create = function(gl, type, data, drawType) { return new Buffer(gl, type, data, drawType); };
            Buffer.prototype.destroy = function() { this.gl.deleteBuffer(this.buffer); };
            module.exports = Buffer;
        }, {}],
        7: [function(require, module, exports) {
            var Texture = require('./GLTexture');
            var Framebuffer = function(gl, width, height) { this.gl = gl;
                this.framebuffer = gl.createFramebuffer();
                this.stencil = null;
                this.texture = null;
                this.width = width || 100;
                this.height = height || 100; };
            Framebuffer.prototype.enableTexture = function(texture) { var gl = this.gl;
                this.texture = texture || new Texture(gl);
                this.texture.bind();
                this.bind();
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0); };
            Framebuffer.prototype.enableStencil = function() { if (this.stencil) return; var gl = this.gl;
                this.stencil = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this.stencil);
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, this.width, this.height); };
            Framebuffer.prototype.clear = function(r, g, b, a) { this.bind(); var gl = this.gl;
                gl.clearColor(r, g, b, a);
                gl.clear(gl.COLOR_BUFFER_BIT); };
            Framebuffer.prototype.bind = function() { var gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer); };
            Framebuffer.prototype.unbind = function() { var gl = this.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, null); };
            Framebuffer.prototype.resize = function(width, height) {
                var gl = this.gl;
                this.width = width;
                this.height = height;
                if (this.texture) { this.texture.uploadData(null, width, height); }
                if (this.stencil) { gl.bindRenderbuffer(gl.RENDERBUFFER, this.stencil);
                    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height); }
            };
            Framebuffer.prototype.destroy = function() {
                var gl = this.gl;
                if (this.texture) { this.texture.destroy(); }
                gl.deleteFramebuffer(this.framebuffer);
                this.gl = null;
                this.stencil = null;
                this.texture = null;
            };
            Framebuffer.createRGBA = function(gl, width, height, data) { var texture = Texture.fromData(gl, null, width, height);
                texture.enableNearestScaling();
                texture.enableWrapClamp(); var fbo = new Framebuffer(gl, width, height);
                fbo.enableTexture(texture);
                fbo.unbind(); return fbo; };
            Framebuffer.createFloat32 = function(gl, width, height, data) { var texture = new Texture.fromData(gl, data, width, height);
                texture.enableNearestScaling();
                texture.enableWrapClamp(); var fbo = new Framebuffer(gl, width, height);
                fbo.enableTexture(texture);
                fbo.unbind(); return fbo; };
            module.exports = Framebuffer;
        }, { "./GLTexture": 9 }],
        8: [function(require, module, exports) {
            var compileProgram = require('./shader/compileProgram'),
                extractAttributes = require('./shader/extractAttributes'),
                extractUniforms = require('./shader/extractUniforms'),
                generateUniformAccessObject = require('./shader/generateUniformAccessObject');
            var Shader = function(gl, vertexSrc, fragmentSrc) { this.gl = gl;
                this.program = compileProgram(gl, vertexSrc, fragmentSrc);
                this.attributes = extractAttributes(gl, this.program); var uniformData = extractUniforms(gl, this.program);
                this.uniforms = generateUniformAccessObject(gl, uniformData); };
            Shader.prototype.bind = function() { this.gl.useProgram(this.program); };
            Shader.prototype.destroy = function() {};
            module.exports = Shader;
        }, { "./shader/compileProgram": 14, "./shader/extractAttributes": 16, "./shader/extractUniforms": 17, "./shader/generateUniformAccessObject": 18 }],
        9: [function(require, module, exports) {
            var Texture = function(gl, width, height, format, type) { this.gl = gl;
                this.texture = gl.createTexture();
                this.mipmap = false;
                this.premultiplyAlpha = false;
                this.width = width || -1;
                this.height = height || -1;
                this.format = format || gl.RGBA;
                this.type = type || gl.UNSIGNED_BYTE; };
            Texture.prototype.upload = function(source) {
                this.bind();
                var gl = this.gl;
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
                var newWidth = source.videoWidth || source.width;
                var newHeight = source.videoHeight || source.height;
                if (newHeight !== this.height || newWidth !== this.width) { gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, source); } else { gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.format, this.type, source); }
                this.width = newWidth;
                this.height = newHeight;
            };
            var FLOATING_POINT_AVAILABLE = false;
            Texture.prototype.uploadData = function(data, width, height) {
                this.bind();
                var gl = this.gl;
                if (data instanceof Float32Array) {
                    if (!FLOATING_POINT_AVAILABLE) {
                        var ext = gl.getExtension("OES_texture_float");
                        if (ext) { FLOATING_POINT_AVAILABLE = true; } else { throw new Error('floating point textures not available'); }
                    }
                    this.type = gl.FLOAT;
                } else { this.type = gl.UNSIGNED_BYTE; }
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
                if (width !== this.width || height !== this.height) { gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, data || null); } else { gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, this.format, this.type, data || null); }
                this.width = width;
                this.height = height;
            };
            Texture.prototype.bind = function(location) {
                var gl = this.gl;
                if (location !== undefined) { gl.activeTexture(gl.TEXTURE0 + location); }
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
            };
            Texture.prototype.unbind = function() { var gl = this.gl;
                gl.bindTexture(gl.TEXTURE_2D, null); };
            Texture.prototype.minFilter = function(linear) {
                var gl = this.gl;
                this.bind();
                if (this.mipmap) { gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST); } else { gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, linear ? gl.LINEAR : gl.NEAREST); }
            };
            Texture.prototype.magFilter = function(linear) { var gl = this.gl;
                this.bind();
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, linear ? gl.LINEAR : gl.NEAREST); };
            Texture.prototype.enableMipmap = function() { var gl = this.gl;
                this.bind();
                this.mipmap = true;
                gl.generateMipmap(gl.TEXTURE_2D); };
            Texture.prototype.enableLinearScaling = function() { this.minFilter(true);
                this.magFilter(true); };
            Texture.prototype.enableNearestScaling = function() { this.minFilter(false);
                this.magFilter(false); };
            Texture.prototype.enableWrapClamp = function() { var gl = this.gl;
                this.bind();
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); };
            Texture.prototype.enableWrapRepeat = function() { var gl = this.gl;
                this.bind();
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT); };
            Texture.prototype.enableWrapMirrorRepeat = function() { var gl = this.gl;
                this.bind();
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.MIRRORED_REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT); };
            Texture.prototype.destroy = function() { var gl = this.gl;
                gl.deleteTexture(this.texture); };
            Texture.fromSource = function(gl, source, premultiplyAlpha) { var texture = new Texture(gl);
                texture.premultiplyAlpha = premultiplyAlpha || false;
                texture.upload(source); return texture; };
            Texture.fromData = function(gl, data, width, height) { var texture = new Texture(gl);
                texture.uploadData(data, width, height); return texture; };
            module.exports = Texture;
        }, {}],
        10: [function(require, module, exports) {
            var setVertexAttribArrays = require('./setVertexAttribArrays');

            function VertexArrayObject(gl, state) {
                this.nativeVaoExtension = null;
                if (!VertexArrayObject.FORCE_NATIVE) { this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') || gl.getExtension('MOZ_OES_vertex_array_object') || gl.getExtension('WEBKIT_OES_vertex_array_object'); }
                this.nativeState = state;
                if (this.nativeVaoExtension) { this.nativeVao = this.nativeVaoExtension.createVertexArrayOES(); var maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                    this.nativeState = { tempAttribState: new Array(maxAttribs), attribState: new Array(maxAttribs) }; }
                this.gl = gl;
                this.attributes = [];
                this.indexBuffer = null;
                this.dirty = false;
            }
            VertexArrayObject.prototype.constructor = VertexArrayObject;
            module.exports = VertexArrayObject;
            VertexArrayObject.FORCE_NATIVE = false;
            VertexArrayObject.prototype.bind = function() {
                if (this.nativeVao) {
                    this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao);
                    if (this.dirty) { this.dirty = false;
                        this.activate(); }
                } else { this.activate(); }
                return this;
            };
            VertexArrayObject.prototype.unbind = function() {
                if (this.nativeVao) { this.nativeVaoExtension.bindVertexArrayOES(null); }
                return this;
            };
            VertexArrayObject.prototype.activate = function() {
                var gl = this.gl;
                var lastBuffer = null;
                for (var i = 0; i < this.attributes.length; i++) {
                    var attrib = this.attributes[i];
                    if (lastBuffer !== attrib.buffer) { attrib.buffer.bind();
                        lastBuffer = attrib.buffer; }
                    gl.vertexAttribPointer(attrib.attribute.location, attrib.attribute.size, attrib.type || gl.FLOAT, attrib.normalized || false, attrib.stride || 0, attrib.start || 0);
                }
                setVertexAttribArrays(gl, this.attributes, this.nativeState);
                this.indexBuffer.bind();
                return this;
            };
            VertexArrayObject.prototype.addAttribute = function(buffer, attribute, type, normalized, stride, start) { this.attributes.push({ buffer: buffer, attribute: attribute, location: attribute.location, type: type || this.gl.FLOAT, normalized: normalized || false, stride: stride || 0, start: start || 0 });
                this.dirty = true; return this; };
            VertexArrayObject.prototype.addIndex = function(buffer) { this.indexBuffer = buffer;
                this.dirty = true; return this; };
            VertexArrayObject.prototype.clear = function() {
                if (this.nativeVao) { this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao); }
                this.attributes.length = 0;
                this.indexBuffer = null;
                return this;
            };
            VertexArrayObject.prototype.draw = function(type, size, start) { var gl = this.gl;
                gl.drawElements(type, size, gl.UNSIGNED_SHORT, start || 0); return this; };
            VertexArrayObject.prototype.destroy = function() {
                this.gl = null;
                this.indexBuffer = null;
                this.attributes = null;
                this.nativeState = null;
                if (this.nativeVao) { this.nativeVaoExtension.deleteVertexArrayOES(this.nativeVao); }
                this.nativeVaoExtension = null;
                this.nativeVao = null;
            };
        }, { "./setVertexAttribArrays": 13 }],
        11: [function(require, module, exports) {
            var createContext = function(canvas, options) {
                var gl = canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options);
                if (!gl) { throw new Error('This browser does not support webGL. Try using the canvas renderer'); }
                return gl;
            };
            module.exports = createContext;
        }, {}],
        12: [function(require, module, exports) {
            var gl = { createContext: require('./createContext'), setVertexAttribArrays: require('./setVertexAttribArrays'), GLBuffer: require('./GLBuffer'), GLFramebuffer: require('./GLFramebuffer'), GLShader: require('./GLShader'), GLTexture: require('./GLTexture'), VertexArrayObject: require('./VertexArrayObject'), shader: require('./shader') };
            if (typeof module !== 'undefined' && module.exports) { module.exports = gl; }
            if (typeof window !== 'undefined') { window.PIXI = window.PIXI || {};
                window.PIXI.glCore = gl; }
        }, { "./GLBuffer": 6, "./GLFramebuffer": 7, "./GLShader": 8, "./GLTexture": 9, "./VertexArrayObject": 10, "./createContext": 11, "./setVertexAttribArrays": 13, "./shader": 19 }],
        13: [function(require, module, exports) {
            var setVertexAttribArrays = function(gl, attribs, state) {
                var i;
                if (state) {
                    var tempAttribState = state.tempAttribState,
                        attribState = state.attribState;
                    for (i = 0; i < tempAttribState.length; i++) { tempAttribState[i] = false; }
                    for (i = 0; i < attribs.length; i++) { tempAttribState[attribs[i].attribute.location] = true; }
                    for (i = 0; i < attribState.length; i++) {
                        if (attribState[i] !== tempAttribState[i]) {
                            attribState[i] = tempAttribState[i];
                            if (state.attribState[i]) { gl.enableVertexAttribArray(i); } else { gl.disableVertexAttribArray(i); }
                        }
                    }
                } else {
                    for (i = 0; i < attribs.length; i++) { var attrib = attribs[i];
                        gl.enableVertexAttribArray(attrib.attribute.location); }
                }
            };
            module.exports = setVertexAttribArrays;
        }, {}],
        14: [function(require, module, exports) {
            var compileProgram = function(gl, vertexSrc, fragmentSrc) {
                var glVertShader = compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
                var glFragShader = compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
                var program = gl.createProgram();
                gl.attachShader(program, glVertShader);
                gl.attachShader(program, glFragShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error('Pixi.js Error: Could not initialize shader.');
                    console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
                    console.error('gl.getError()', gl.getError());
                    if (gl.getProgramInfoLog(program) !== '') { console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program)); }
                    gl.deleteProgram(program);
                    program = null;
                }
                gl.deleteShader(glVertShader);
                gl.deleteShader(glFragShader);
                return program;
            };
            var compileShader = function(gl, type, src) {
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { console.log(gl.getShaderInfoLog(shader)); return null; }
                return shader;
            };
            module.exports = compileProgram;
        }, {}],
        15: [function(require, module, exports) {
            var defaultValue = function(type, size) {
                switch (type) {
                    case 'float':
                        return 0;
                    case 'vec2':
                        return new Float32Array(2 * size);
                    case 'vec3':
                        return new Float32Array(3 * size);
                    case 'vec4':
                        return new Float32Array(4 * size);
                    case 'int':
                    case 'sampler2D':
                        return 0;
                    case 'ivec2':
                        return new Int32Array(2 * size);
                    case 'ivec3':
                        return new Int32Array(3 * size);
                    case 'ivec4':
                        return new Int32Array(4 * size);
                    case 'bool':
                        return false;
                    case 'bvec2':
                        return booleanArray(2 * size);
                    case 'bvec3':
                        return booleanArray(3 * size);
                    case 'bvec4':
                        return booleanArray(4 * size);
                    case 'mat2':
                        return new Float32Array([1, 0, 0, 1]);
                    case 'mat3':
                        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
                    case 'mat4':
                        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]); }
            };
            var booleanArray = function(size) {
                var array = new Array(size);
                for (var i = 0; i < array.length; i++) { array[i] = false; }
                return array;
            };
            module.exports = defaultValue;
        }, {}],
        16: [function(require, module, exports) {
            var mapType = require('./mapType');
            var mapSize = require('./mapSize');
            var extractAttributes = function(gl, program) {
                var attributes = {};
                var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
                for (var i = 0; i < totalAttributes; i++) { var attribData = gl.getActiveAttrib(program, i); var type = mapType(gl, attribData.type);
                    attributes[attribData.name] = { type: type, size: mapSize(type), location: gl.getAttribLocation(program, attribData.name), pointer: pointer }; }
                return attributes;
            };
            var pointer = function(type, normalized, stride, start) { gl.vertexAttribPointer(this.location, this.size, type || gl.FLOAT, normalized || false, stride || 0, start || 0); };
            module.exports = extractAttributes;
        }, { "./mapSize": 20, "./mapType": 21 }],
        17: [function(require, module, exports) {
            var mapType = require('./mapType');
            var defaultValue = require('./defaultValue');
            var extractUniforms = function(gl, program) {
                var uniforms = {};
                var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
                for (var i = 0; i < totalUniforms; i++) { var uniformData = gl.getActiveUniform(program, i); var name = uniformData.name.replace(/\[.*?\]/, ""); var type = mapType(gl, uniformData.type);
                    uniforms[name] = { type: type, size: uniformData.size, location: gl.getUniformLocation(program, name), value: defaultValue(type, uniformData.size) }; }
                return uniforms;
            };
            module.exports = extractUniforms;
        }, { "./defaultValue": 15, "./mapType": 21 }],
        18: [function(require, module, exports) {
            var generateUniformAccessObject = function(gl, uniformData) {
                var uniforms = { data: {} };
                uniforms.gl = gl;
                var uniformKeys = Object.keys(uniformData);
                for (var i = 0; i < uniformKeys.length; i++) { var fullName = uniformKeys[i]; var nameTokens = fullName.split('.'); var name = nameTokens[nameTokens.length - 1]; var uniformGroup = getUniformGroup(nameTokens, uniforms); var uniform = uniformData[fullName];
                    uniformGroup.data[name] = uniform;
                    uniformGroup.gl = gl;
                    Object.defineProperty(uniformGroup, name, { get: generateGetter(name), set: generateSetter(name, uniform) }); }
                return uniforms;
            };
            var generateGetter = function(name) { var template = getterTemplate.replace('%%', name); return new Function(template); };
            var generateSetter = function(name, uniform) {
                var template = setterTemplate.replace(/%%/g, name);
                var setTemplate;
                if (uniform.size === 1) { setTemplate = GLSL_TO_SINGLE_SETTERS[uniform.type]; } else { setTemplate = GLSL_TO_ARRAY_SETTERS[uniform.type]; }
                if (setTemplate) { template += "\nthis.gl." + setTemplate + ";"; }
                return new Function('value', template);
            };
            var getUniformGroup = function(nameTokens, uniform) {
                var cur = uniform;
                for (var i = 0; i < nameTokens.length - 1; i++) { var o = cur[nameTokens[i]] || { data: {} };
                    cur[nameTokens[i]] = o;
                    cur = o; }
                return cur;
            };
            var getterTemplate = ['return this.data.%%.value;', ].join('\n');
            var setterTemplate = ['this.data.%%.value = value;', 'var location = this.data.%%.location;'].join('\n');
            var GLSL_TO_SINGLE_SETTERS = { 'float': 'uniform1f(location, value)', 'vec2': 'uniform2f(location, value[0], value[1])', 'vec3': 'uniform3f(location, value[0], value[1], value[2])', 'vec4': 'uniform4f(location, value[0], value[1], value[2], value[3])', 'int': 'uniform1i(location, value)', 'ivec2': 'uniform2i(location, value[0], value[1])', 'ivec3': 'uniform3i(location, value[0], value[1], value[2])', 'ivec4': 'uniform4i(location, value[0], value[1], value[2], value[3])', 'bool': 'uniform1i(location, value)', 'bvec2': 'uniform2i(location, value[0], value[1])', 'bvec3': 'uniform3i(location, value[0], value[1], value[2])', 'bvec4': 'uniform4i(location, value[0], value[1], value[2], value[3])', 'mat2': 'uniformMatrix2fv(location, false, value)', 'mat3': 'uniformMatrix3fv(location, false, value)', 'mat4': 'uniformMatrix4fv(location, false, value)', 'sampler2D': 'uniform1i(location, value)' };
            var GLSL_TO_ARRAY_SETTERS = { 'float': 'uniform1fv(location, value)', 'vec2': 'uniform2fv(location, value)', 'vec3': 'uniform3fv(location, value)', 'vec4': 'uniform4fv(location, value)', 'int': 'uniform1iv(location, value)', 'ivec2': 'uniform2iv(location, value)', 'ivec3': 'uniform3iv(location, value)', 'ivec4': 'uniform4iv(location, value)', 'bool': 'uniform1iv(location, value)', 'bvec2': 'uniform2iv(location, value)', 'bvec3': 'uniform3iv(location, value)', 'bvec4': 'uniform4iv(location, value)', 'sampler2D': 'uniform1iv(location, value)' };
            module.exports = generateUniformAccessObject;
        }, {}],
        19: [function(require, module, exports) { module.exports = { compileProgram: require('./compileProgram'), defaultValue: require('./defaultValue'), extractAttributes: require('./extractAttributes'), extractUniforms: require('./extractUniforms'), generateUniformAccessObject: require('./generateUniformAccessObject'), mapSize: require('./mapSize'), mapType: require('./mapType') }; }, { "./compileProgram": 14, "./defaultValue": 15, "./extractAttributes": 16, "./extractUniforms": 17, "./generateUniformAccessObject": 18, "./mapSize": 20, "./mapType": 21 }],
        20: [function(require, module, exports) {
            var mapSize = function(type) { return GLSL_TO_SIZE[type]; };
            var GLSL_TO_SIZE = { 'float': 1, 'vec2': 2, 'vec3': 3, 'vec4': 4, 'int': 1, 'ivec2': 2, 'ivec3': 3, 'ivec4': 4, 'bool': 1, 'bvec2': 2, 'bvec3': 3, 'bvec4': 4, 'mat2': 4, 'mat3': 9, 'mat4': 16, 'sampler2D': 1 };
            module.exports = mapSize;
        }, {}],
        21: [function(require, module, exports) {
            var mapSize = function(gl, type) {
                if (!GL_TABLE) {
                    var typeNames = Object.keys(GL_TO_GLSL_TYPES);
                    GL_TABLE = {};
                    for (var i = 0; i < typeNames.length; ++i) { var tn = typeNames[i];
                        GL_TABLE[gl[tn]] = GL_TO_GLSL_TYPES[tn]; }
                }
                return GL_TABLE[type];
            };
            var GL_TABLE = null;
            var GL_TO_GLSL_TYPES = { 'FLOAT': 'float', 'FLOAT_VEC2': 'vec2', 'FLOAT_VEC3': 'vec3', 'FLOAT_VEC4': 'vec4', 'INT': 'int', 'INT_VEC2': 'ivec2', 'INT_VEC3': 'ivec3', 'INT_VEC4': 'ivec4', 'BOOL': 'bool', 'BOOL_VEC2': 'bvec2', 'BOOL_VEC3': 'bvec3', 'BOOL_VEC4': 'bvec4', 'FLOAT_MAT2': 'mat2', 'FLOAT_MAT3': 'mat3', 'FLOAT_MAT4': 'mat4', 'SAMPLER_2D': 'sampler2D' };
            module.exports = mapSize;
        }, {}],
        22: [function(require, module, exports) {
            (function(process) {
                function normalizeArray(parts, allowAboveRoot) {
                    var up = 0;
                    for (var i = parts.length - 1; i >= 0; i--) { var last = parts[i]; if (last === '.') { parts.splice(i, 1); } else if (last === '..') { parts.splice(i, 1);
                            up++; } else if (up) { parts.splice(i, 1);
                            up--; } }
                    if (allowAboveRoot) { for (; up--; up) { parts.unshift('..'); } }
                    return parts;
                }
                var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
                var splitPath = function(filename) { return splitPathRe.exec(filename).slice(1); };
                exports.resolve = function() {
                    var resolvedPath = '',
                        resolvedAbsolute = false;
                    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                        var path = (i >= 0) ? arguments[i] : process.cwd();
                        if (typeof path !== 'string') { throw new TypeError('Arguments to path.resolve must be strings'); } else if (!path) { continue; }
                        resolvedPath = path + '/' + resolvedPath;
                        resolvedAbsolute = path.charAt(0) === '/';
                    }
                    resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) { return !!p; }), !resolvedAbsolute).join('/');
                    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
                };
                exports.normalize = function(path) {
                    var isAbsolute = exports.isAbsolute(path),
                        trailingSlash = substr(path, -1) === '/';
                    path = normalizeArray(filter(path.split('/'), function(p) { return !!p; }), !isAbsolute).join('/');
                    if (!path && !isAbsolute) { path = '.'; }
                    if (path && trailingSlash) { path += '/'; }
                    return (isAbsolute ? '/' : '') + path;
                };
                exports.isAbsolute = function(path) { return path.charAt(0) === '/'; };
                exports.join = function() {
                    var paths = Array.prototype.slice.call(arguments, 0);
                    return exports.normalize(filter(paths, function(p, index) {
                        if (typeof p !== 'string') { throw new TypeError('Arguments to path.join must be strings'); }
                        return p;
                    }).join('/'));
                };
                exports.relative = function(from, to) {
                    from = exports.resolve(from).substr(1);
                    to = exports.resolve(to).substr(1);

                    function trim(arr) {
                        var start = 0;
                        for (; start < arr.length; start++) { if (arr[start] !== '') break; }
                        var end = arr.length - 1;
                        for (; end >= 0; end--) { if (arr[end] !== '') break; }
                        if (start > end) return [];
                        return arr.slice(start, end - start + 1);
                    }
                    var fromParts = trim(from.split('/'));
                    var toParts = trim(to.split('/'));
                    var length = Math.min(fromParts.length, toParts.length);
                    var samePartsLength = length;
                    for (var i = 0; i < length; i++) { if (fromParts[i] !== toParts[i]) { samePartsLength = i; break; } }
                    var outputParts = [];
                    for (var i = samePartsLength; i < fromParts.length; i++) { outputParts.push('..'); }
                    outputParts = outputParts.concat(toParts.slice(samePartsLength));
                    return outputParts.join('/');
                };
                exports.sep = '/';
                exports.delimiter = ':';
                exports.dirname = function(path) {
                    var result = splitPath(path),
                        root = result[0],
                        dir = result[1];
                    if (!root && !dir) { return '.'; }
                    if (dir) { dir = dir.substr(0, dir.length - 1); }
                    return root + dir;
                };
                exports.basename = function(path, ext) {
                    var f = splitPath(path)[2];
                    if (ext && f.substr(-1 * ext.length) === ext) { f = f.substr(0, f.length - ext.length); }
                    return f;
                };
                exports.extname = function(path) { return splitPath(path)[3]; };

                function filter(xs, f) {
                    if (xs.filter) return xs.filter(f);
                    var res = [];
                    for (var i = 0; i < xs.length; i++) { if (f(xs[i], i, xs)) res.push(xs[i]); }
                    return res;
                }
                var substr = 'ab'.substr(-1) === 'b' ? function(str, start, len) { return str.substr(start, len) } : function(str, start, len) { if (start < 0) start = str.length + start; return str.substr(start, len); };
            }).call(this, require('_process'))
        }, { "_process": 23 }],
        23: [function(require, module, exports) {
            var process = module.exports = {};
            var cachedSetTimeout;
            var cachedClearTimeout;

            function defaultSetTimout() { throw new Error('setTimeout has not been defined'); }

            function defaultClearTimeout() { throw new Error('clearTimeout has not been defined'); }
            (function() {
                try { if (typeof setTimeout === 'function') { cachedSetTimeout = setTimeout; } else { cachedSetTimeout = defaultSetTimout; } } catch (e) { cachedSetTimeout = defaultSetTimout; }
                try { if (typeof clearTimeout === 'function') { cachedClearTimeout = clearTimeout; } else { cachedClearTimeout = defaultClearTimeout; } } catch (e) { cachedClearTimeout = defaultClearTimeout; }
            }())

            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) { return setTimeout(fun, 0); }
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) { cachedSetTimeout = setTimeout; return setTimeout(fun, 0); }
                try { return cachedSetTimeout(fun, 0); } catch (e) { try { return cachedSetTimeout.call(null, fun, 0); } catch (e) { return cachedSetTimeout.call(this, fun, 0); } }
            }

            function runClearTimeout(marker) {
                if (cachedClearTimeout === clearTimeout) { return clearTimeout(marker); }
                if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) { cachedClearTimeout = clearTimeout; return clearTimeout(marker); }
                try { return cachedClearTimeout(marker); } catch (e) { try { return cachedClearTimeout.call(null, marker); } catch (e) { return cachedClearTimeout.call(this, marker); } }
            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;

            function cleanUpNextTick() {
                if (!draining || !currentQueue) { return; }
                draining = false;
                if (currentQueue.length) { queue = currentQueue.concat(queue); } else { queueIndex = -1; }
                if (queue.length) { drainQueue(); }
            }

            function drainQueue() {
                if (draining) { return; }
                var timeout = runTimeout(cleanUpNextTick);
                draining = true;
                var len = queue.length;
                while (len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) { if (currentQueue) { currentQueue[queueIndex].run(); } }
                    queueIndex = -1;
                    len = queue.length;
                }
                currentQueue = null;
                draining = false;
                runClearTimeout(timeout);
            }
            process.nextTick = function(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) { for (var i = 1; i < arguments.length; i++) { args[i - 1] = arguments[i]; } }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) { runTimeout(drainQueue); }
            };

            function Item(fun, array) { this.fun = fun;
                this.array = array; }
            Item.prototype.run = function() { this.fun.apply(null, this.array); };
            process.title = 'browser';
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = '';
            process.versions = {};

            function noop() {}
            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;
            process.binding = function(name) { throw new Error('process.binding is not supported'); };
            process.cwd = function() { return '/' };
            process.chdir = function(dir) { throw new Error('process.chdir is not supported'); };
            process.umask = function() { return 0; };
        }, {}],
        24: [function(require, module, exports) {
            (function(global) {;
                (function(root) {
                    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
                    var freeModule = typeof module == 'object' && module && !module.nodeType && module;
                    var freeGlobal = typeof global == 'object' && global;
                    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) { root = freeGlobal; }
                    var punycode, maxInt = 2147483647,
                        base = 36,
                        tMin = 1,
                        tMax = 26,
                        skew = 38,
                        damp = 700,
                        initialBias = 72,
                        initialN = 128,
                        delimiter = '-',
                        regexPunycode = /^xn--/,
                        regexNonASCII = /[^\x20-\x7E]/,
                        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
                        errors = { 'overflow': 'Overflow: input needs wider integers to process', 'not-basic': 'Illegal input >= 0x80 (not a basic code point)', 'invalid-input': 'Invalid input' },
                        baseMinusTMin = base - tMin,
                        floor = Math.floor,
                        stringFromCharCode = String.fromCharCode,
                        key;

                    function error(type) { throw new RangeError(errors[type]); }

                    function map(array, fn) {
                        var length = array.length;
                        var result = [];
                        while (length--) { result[length] = fn(array[length]); }
                        return result;
                    }

                    function mapDomain(string, fn) {
                        var parts = string.split('@');
                        var result = '';
                        if (parts.length > 1) { result = parts[0] + '@';
                            string = parts[1]; }
                        string = string.replace(regexSeparators, '\x2E');
                        var labels = string.split('.');
                        var encoded = map(labels, fn).join('.');
                        return result + encoded;
                    }

                    function ucs2decode(string) {
                        var output = [],
                            counter = 0,
                            length = string.length,
                            value, extra;
                        while (counter < length) { value = string.charCodeAt(counter++); if (value >= 0xD800 && value <= 0xDBFF && counter < length) { extra = string.charCodeAt(counter++); if ((extra & 0xFC00) == 0xDC00) { output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000); } else { output.push(value);
                                    counter--; } } else { output.push(value); } }
                        return output;
                    }

                    function ucs2encode(array) {
                        return map(array, function(value) {
                            var output = '';
                            if (value > 0xFFFF) { value -= 0x10000;
                                output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                                value = 0xDC00 | value & 0x3FF; }
                            output += stringFromCharCode(value);
                            return output;
                        }).join('');
                    }

                    function basicToDigit(codePoint) {
                        if (codePoint - 48 < 10) { return codePoint - 22; }
                        if (codePoint - 65 < 26) { return codePoint - 65; }
                        if (codePoint - 97 < 26) { return codePoint - 97; }
                        return base;
                    }

                    function digitToBasic(digit, flag) { return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5); }

                    function adapt(delta, numPoints, firstTime) {
                        var k = 0;
                        delta = firstTime ? floor(delta / damp) : delta >> 1;
                        delta += floor(delta / numPoints);
                        for (; delta > baseMinusTMin * tMax >> 1; k += base) { delta = floor(delta / baseMinusTMin); }
                        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                    }

                    function decode(input) {
                        var output = [],
                            inputLength = input.length,
                            out, i = 0,
                            n = initialN,
                            bias = initialBias,
                            basic, j, index, oldi, w, k, digit, t, baseMinusT;
                        basic = input.lastIndexOf(delimiter);
                        if (basic < 0) { basic = 0; }
                        for (j = 0; j < basic; ++j) {
                            if (input.charCodeAt(j) >= 0x80) { error('not-basic'); }
                            output.push(input.charCodeAt(j));
                        }
                        for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
                            for (oldi = i, w = 1, k = base;; k += base) {
                                if (index >= inputLength) { error('invalid-input'); }
                                digit = basicToDigit(input.charCodeAt(index++));
                                if (digit >= base || digit > floor((maxInt - i) / w)) { error('overflow'); }
                                i += digit * w;
                                t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                                if (digit < t) { break; }
                                baseMinusT = base - t;
                                if (w > floor(maxInt / baseMinusT)) { error('overflow'); }
                                w *= baseMinusT;
                            }
                            out = output.length + 1;
                            bias = adapt(i - oldi, out, oldi == 0);
                            if (floor(i / out) > maxInt - n) { error('overflow'); }
                            n += floor(i / out);
                            i %= out;
                            output.splice(i++, 0, n);
                        }
                        return ucs2encode(output);
                    }

                    function encode(input) {
                        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [],
                            inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                        input = ucs2decode(input);
                        inputLength = input.length;
                        n = initialN;
                        delta = 0;
                        bias = initialBias;
                        for (j = 0; j < inputLength; ++j) { currentValue = input[j]; if (currentValue < 0x80) { output.push(stringFromCharCode(currentValue)); } }
                        handledCPCount = basicLength = output.length;
                        if (basicLength) { output.push(delimiter); }
                        while (handledCPCount < inputLength) {
                            for (m = maxInt, j = 0; j < inputLength; ++j) { currentValue = input[j]; if (currentValue >= n && currentValue < m) { m = currentValue; } }
                            handledCPCountPlusOne = handledCPCount + 1;
                            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) { error('overflow'); }
                            delta += (m - n) * handledCPCountPlusOne;
                            n = m;
                            for (j = 0; j < inputLength; ++j) {
                                currentValue = input[j];
                                if (currentValue < n && ++delta > maxInt) { error('overflow'); }
                                if (currentValue == n) {
                                    for (q = delta, k = base;; k += base) {
                                        t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                                        if (q < t) { break; }
                                        qMinusT = q - t;
                                        baseMinusT = base - t;
                                        output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                        q = floor(qMinusT / baseMinusT);
                                    }
                                    output.push(stringFromCharCode(digitToBasic(q, 0)));
                                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                    delta = 0;
                                    ++handledCPCount;
                                }
                            }
                            ++delta;
                            ++n;
                        }
                        return output.join('');
                    }

                    function toUnicode(input) { return mapDomain(input, function(string) { return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string; }); }

                    function toASCII(input) { return mapDomain(input, function(string) { return regexNonASCII.test(string) ? 'xn--' + encode(string) : string; }); }
                    punycode = { 'version': '1.4.1', 'ucs2': { 'decode': ucs2decode, 'encode': ucs2encode }, 'decode': decode, 'encode': encode, 'toASCII': toASCII, 'toUnicode': toUnicode };
                    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) { define('punycode', function() { return punycode; }); } else if (freeExports && freeModule) { if (module.exports == freeExports) { freeModule.exports = punycode; } else { for (key in punycode) { punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]); } } } else { root.punycode = punycode; }
                }(this));
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {}],
        25: [function(require, module, exports) {
            'use strict';

            function hasOwnProperty(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
            module.exports = function(qs, sep, eq, options) {
                sep = sep || '&';
                eq = eq || '=';
                var obj = {};
                if (typeof qs !== 'string' || qs.length === 0) { return obj; }
                var regexp = /\+/g;
                qs = qs.split(sep);
                var maxKeys = 1000;
                if (options && typeof options.maxKeys === 'number') { maxKeys = options.maxKeys; }
                var len = qs.length;
                if (maxKeys > 0 && len > maxKeys) { len = maxKeys; }
                for (var i = 0; i < len; ++i) {
                    var x = qs[i].replace(regexp, '%20'),
                        idx = x.indexOf(eq),
                        kstr, vstr, k, v;
                    if (idx >= 0) { kstr = x.substr(0, idx);
                        vstr = x.substr(idx + 1); } else { kstr = x;
                        vstr = ''; }
                    k = decodeURIComponent(kstr);
                    v = decodeURIComponent(vstr);
                    if (!hasOwnProperty(obj, k)) { obj[k] = v; } else if (isArray(obj[k])) { obj[k].push(v); } else { obj[k] = [obj[k], v]; }
                }
                return obj;
            };
            var isArray = Array.isArray || function(xs) { return Object.prototype.toString.call(xs) === '[object Array]'; };
        }, {}],
        26: [function(require, module, exports) {
            'use strict';
            var stringifyPrimitive = function(v) { switch (typeof v) {
                    case 'string':
                        return v;
                    case 'boolean':
                        return v ? 'true' : 'false';
                    case 'number':
                        return isFinite(v) ? v : '';
                    default:
                        return ''; } };
            module.exports = function(obj, sep, eq, name) {
                sep = sep || '&';
                eq = eq || '=';
                if (obj === null) { obj = undefined; }
                if (typeof obj === 'object') { return map(objectKeys(obj), function(k) { var ks = encodeURIComponent(stringifyPrimitive(k)) + eq; if (isArray(obj[k])) { return map(obj[k], function(v) { return ks + encodeURIComponent(stringifyPrimitive(v)); }).join(sep); } else { return ks + encodeURIComponent(stringifyPrimitive(obj[k])); } }).join(sep); }
                if (!name) return '';
                return encodeURIComponent(stringifyPrimitive(name)) + eq +
                    encodeURIComponent(stringifyPrimitive(obj));
            };
            var isArray = Array.isArray || function(xs) { return Object.prototype.toString.call(xs) === '[object Array]'; };

            function map(xs, f) {
                if (xs.map) return xs.map(f);
                var res = [];
                for (var i = 0; i < xs.length; i++) { res.push(f(xs[i], i)); }
                return res;
            }
            var objectKeys = Object.keys || function(obj) {
                var res = [];
                for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key); }
                return res;
            };
        }, {}],
        27: [function(require, module, exports) { 'use strict';
            exports.decode = exports.parse = require('./decode');
            exports.encode = exports.stringify = require('./encode'); }, { "./decode": 25, "./encode": 26 }],
        28: [function(require, module, exports) {
            'use strict';
            var punycode = require('punycode');
            var util = require('./util');
            exports.parse = urlParse;
            exports.resolve = urlResolve;
            exports.resolveObject = urlResolveObject;
            exports.format = urlFormat;
            exports.Url = Url;

            function Url() { this.protocol = null;
                this.slashes = null;
                this.auth = null;
                this.host = null;
                this.port = null;
                this.hostname = null;
                this.hash = null;
                this.search = null;
                this.query = null;
                this.pathname = null;
                this.path = null;
                this.href = null; }
            var protocolPattern = /^([a-z0-9.+-]+:)/i,
                portPattern = /:[0-9]*$/,
                simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
                delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
                unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
                autoEscape = ['\''].concat(unwise),
                nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
                hostEndingChars = ['/', '?', '#'],
                hostnameMaxLen = 255,
                hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
                hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
                unsafeProtocol = { 'javascript': true, 'javascript:': true },
                hostlessProtocol = { 'javascript': true, 'javascript:': true },
                slashedProtocol = { 'http': true, 'https': true, 'ftp': true, 'gopher': true, 'file': true, 'http:': true, 'https:': true, 'ftp:': true, 'gopher:': true, 'file:': true },
                querystring = require('querystring');

            function urlParse(url, parseQueryString, slashesDenoteHost) { if (url && util.isObject(url) && url instanceof Url) return url; var u = new Url;
                u.parse(url, parseQueryString, slashesDenoteHost); return u; }
            Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
                if (!util.isString(url)) { throw new TypeError("Parameter 'url' must be a string, not " + typeof url); }
                var queryIndex = url.indexOf('?'),
                    splitter = (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
                    uSplit = url.split(splitter),
                    slashRegex = /\\/g;
                uSplit[0] = uSplit[0].replace(slashRegex, '/');
                url = uSplit.join(splitter);
                var rest = url;
                rest = rest.trim();
                if (!slashesDenoteHost && url.split('#').length === 1) {
                    var simplePath = simplePathPattern.exec(rest);
                    if (simplePath) {
                        this.path = rest;
                        this.href = rest;
                        this.pathname = simplePath[1];
                        if (simplePath[2]) { this.search = simplePath[2]; if (parseQueryString) { this.query = querystring.parse(this.search.substr(1)); } else { this.query = this.search.substr(1); } } else if (parseQueryString) { this.search = '';
                            this.query = {}; }
                        return this;
                    }
                }
                var proto = protocolPattern.exec(rest);
                if (proto) { proto = proto[0]; var lowerProto = proto.toLowerCase();
                    this.protocol = lowerProto;
                    rest = rest.substr(proto.length); }
                if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) { var slashes = rest.substr(0, 2) === '//'; if (slashes && !(proto && hostlessProtocol[proto])) { rest = rest.substr(2);
                        this.slashes = true; } }
                if (!hostlessProtocol[proto] && (slashes || (proto && !slashedProtocol[proto]))) {
                    var hostEnd = -1;
                    for (var i = 0; i < hostEndingChars.length; i++) {
                        var hec = rest.indexOf(hostEndingChars[i]);
                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                            hostEnd = hec;
                    }
                    var auth, atSign;
                    if (hostEnd === -1) { atSign = rest.lastIndexOf('@'); } else { atSign = rest.lastIndexOf('@', hostEnd); }
                    if (atSign !== -1) { auth = rest.slice(0, atSign);
                        rest = rest.slice(atSign + 1);
                        this.auth = decodeURIComponent(auth); }
                    hostEnd = -1;
                    for (var i = 0; i < nonHostChars.length; i++) {
                        var hec = rest.indexOf(nonHostChars[i]);
                        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                            hostEnd = hec;
                    }
                    if (hostEnd === -1)
                        hostEnd = rest.length;
                    this.host = rest.slice(0, hostEnd);
                    rest = rest.slice(hostEnd);
                    this.parseHost();
                    this.hostname = this.hostname || '';
                    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';
                    if (!ipv6Hostname) {
                        var hostparts = this.hostname.split(/\./);
                        for (var i = 0, l = hostparts.length; i < l; i++) {
                            var part = hostparts[i];
                            if (!part) continue;
                            if (!part.match(hostnamePartPattern)) {
                                var newpart = '';
                                for (var j = 0, k = part.length; j < k; j++) { if (part.charCodeAt(j) > 127) { newpart += 'x'; } else { newpart += part[j]; } }
                                if (!newpart.match(hostnamePartPattern)) {
                                    var validParts = hostparts.slice(0, i);
                                    var notHost = hostparts.slice(i + 1);
                                    var bit = part.match(hostnamePartStart);
                                    if (bit) { validParts.push(bit[1]);
                                        notHost.unshift(bit[2]); }
                                    if (notHost.length) { rest = '/' + notHost.join('.') + rest; }
                                    this.hostname = validParts.join('.');
                                    break;
                                }
                            }
                        }
                    }
                    if (this.hostname.length > hostnameMaxLen) { this.hostname = ''; } else { this.hostname = this.hostname.toLowerCase(); }
                    if (!ipv6Hostname) { this.hostname = punycode.toASCII(this.hostname); }
                    var p = this.port ? ':' + this.port : '';
                    var h = this.hostname || '';
                    this.host = h + p;
                    this.href += this.host;
                    if (ipv6Hostname) { this.hostname = this.hostname.substr(1, this.hostname.length - 2); if (rest[0] !== '/') { rest = '/' + rest; } }
                }
                if (!unsafeProtocol[lowerProto]) {
                    for (var i = 0, l = autoEscape.length; i < l; i++) {
                        var ae = autoEscape[i];
                        if (rest.indexOf(ae) === -1)
                            continue;
                        var esc = encodeURIComponent(ae);
                        if (esc === ae) { esc = escape(ae); }
                        rest = rest.split(ae).join(esc);
                    }
                }
                var hash = rest.indexOf('#');
                if (hash !== -1) { this.hash = rest.substr(hash);
                    rest = rest.slice(0, hash); }
                var qm = rest.indexOf('?');
                if (qm !== -1) {
                    this.search = rest.substr(qm);
                    this.query = rest.substr(qm + 1);
                    if (parseQueryString) { this.query = querystring.parse(this.query); }
                    rest = rest.slice(0, qm);
                } else if (parseQueryString) { this.search = '';
                    this.query = {}; }
                if (rest) this.pathname = rest;
                if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) { this.pathname = '/'; }
                if (this.pathname || this.search) { var p = this.pathname || ''; var s = this.search || '';
                    this.path = p + s; }
                this.href = this.format();
                return this;
            };

            function urlFormat(obj) { if (util.isString(obj)) obj = urlParse(obj); if (!(obj instanceof Url)) return Url.prototype.format.call(obj); return obj.format(); }
            Url.prototype.format = function() {
                var auth = this.auth || '';
                if (auth) { auth = encodeURIComponent(auth);
                    auth = auth.replace(/%3A/i, ':');
                    auth += '@'; }
                var protocol = this.protocol || '',
                    pathname = this.pathname || '',
                    hash = this.hash || '',
                    host = false,
                    query = '';
                if (this.host) { host = auth + this.host; } else if (this.hostname) { host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']'); if (this.port) { host += ':' + this.port; } }
                if (this.query && util.isObject(this.query) && Object.keys(this.query).length) { query = querystring.stringify(this.query); }
                var search = this.search || (query && ('?' + query)) || '';
                if (protocol && protocol.substr(-1) !== ':') protocol += ':';
                if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) { host = '//' + (host || ''); if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname; } else if (!host) { host = ''; }
                if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
                if (search && search.charAt(0) !== '?') search = '?' + search;
                pathname = pathname.replace(/[?#]/g, function(match) { return encodeURIComponent(match); });
                search = search.replace('#', '%23');
                return protocol + host + pathname + search + hash;
            };

            function urlResolve(source, relative) { return urlParse(source, false, true).resolve(relative); }
            Url.prototype.resolve = function(relative) { return this.resolveObject(urlParse(relative, false, true)).format(); };

            function urlResolveObject(source, relative) { if (!source) return relative; return urlParse(source, false, true).resolveObject(relative); }
            Url.prototype.resolveObject = function(relative) {
                if (util.isString(relative)) { var rel = new Url();
                    rel.parse(relative, false, true);
                    relative = rel; }
                var result = new Url();
                var tkeys = Object.keys(this);
                for (var tk = 0; tk < tkeys.length; tk++) { var tkey = tkeys[tk];
                    result[tkey] = this[tkey]; }
                result.hash = relative.hash;
                if (relative.href === '') { result.href = result.format(); return result; }
                if (relative.slashes && !relative.protocol) {
                    var rkeys = Object.keys(relative);
                    for (var rk = 0; rk < rkeys.length; rk++) {
                        var rkey = rkeys[rk];
                        if (rkey !== 'protocol')
                            result[rkey] = relative[rkey];
                    }
                    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) { result.path = result.pathname = '/'; }
                    result.href = result.format();
                    return result;
                }
                if (relative.protocol && relative.protocol !== result.protocol) {
                    if (!slashedProtocol[relative.protocol]) {
                        var keys = Object.keys(relative);
                        for (var v = 0; v < keys.length; v++) { var k = keys[v];
                            result[k] = relative[k]; }
                        result.href = result.format();
                        return result;
                    }
                    result.protocol = relative.protocol;
                    if (!relative.host && !hostlessProtocol[relative.protocol]) { var relPath = (relative.pathname || '').split('/'); while (relPath.length && !(relative.host = relPath.shift())); if (!relative.host) relative.host = ''; if (!relative.hostname) relative.hostname = ''; if (relPath[0] !== '') relPath.unshift(''); if (relPath.length < 2) relPath.unshift('');
                        result.pathname = relPath.join('/'); } else { result.pathname = relative.pathname; }
                    result.search = relative.search;
                    result.query = relative.query;
                    result.host = relative.host || '';
                    result.auth = relative.auth;
                    result.hostname = relative.hostname || relative.host;
                    result.port = relative.port;
                    if (result.pathname || result.search) { var p = result.pathname || ''; var s = result.search || '';
                        result.path = p + s; }
                    result.slashes = result.slashes || relative.slashes;
                    result.href = result.format();
                    return result;
                }
                var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
                    isRelAbs = (relative.host || relative.pathname && relative.pathname.charAt(0) === '/'),
                    mustEndAbs = (isRelAbs || isSourceAbs || (result.host && relative.pathname)),
                    removeAllDots = mustEndAbs,
                    srcPath = result.pathname && result.pathname.split('/') || [],
                    relPath = relative.pathname && relative.pathname.split('/') || [],
                    psychotic = result.protocol && !slashedProtocol[result.protocol];
                if (psychotic) {
                    result.hostname = '';
                    result.port = null;
                    if (result.host) { if (srcPath[0] === '') srcPath[0] = result.host;
                        else srcPath.unshift(result.host); }
                    result.host = '';
                    if (relative.protocol) {
                        relative.hostname = null;
                        relative.port = null;
                        if (relative.host) { if (relPath[0] === '') relPath[0] = relative.host;
                            else relPath.unshift(relative.host); }
                        relative.host = null;
                    }
                    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
                }
                if (isRelAbs) { result.host = (relative.host || relative.host === '') ? relative.host : result.host;
                    result.hostname = (relative.hostname || relative.hostname === '') ? relative.hostname : result.hostname;
                    result.search = relative.search;
                    result.query = relative.query;
                    srcPath = relPath; } else if (relPath.length) { if (!srcPath) srcPath = [];
                    srcPath.pop();
                    srcPath = srcPath.concat(relPath);
                    result.search = relative.search;
                    result.query = relative.query; } else if (!util.isNullOrUndefined(relative.search)) {
                    if (psychotic) { result.hostname = result.host = srcPath.shift(); var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false; if (authInHost) { result.auth = authInHost.shift();
                            result.host = result.hostname = authInHost.shift(); } }
                    result.search = relative.search;
                    result.query = relative.query;
                    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                        result.path = (result.pathname ? result.pathname : '') +
                            (result.search ? result.search : '');
                    }
                    result.href = result.format();
                    return result;
                }
                if (!srcPath.length) {
                    result.pathname = null;
                    if (result.search) { result.path = '/' + result.search; } else { result.path = null; }
                    result.href = result.format();
                    return result;
                }
                var last = srcPath.slice(-1)[0];
                var hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '');
                var up = 0;
                for (var i = srcPath.length; i >= 0; i--) { last = srcPath[i]; if (last === '.') { srcPath.splice(i, 1); } else if (last === '..') { srcPath.splice(i, 1);
                        up++; } else if (up) { srcPath.splice(i, 1);
                        up--; } }
                if (!mustEndAbs && !removeAllDots) { for (; up--; up) { srcPath.unshift('..'); } }
                if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) { srcPath.unshift(''); }
                if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) { srcPath.push(''); }
                var isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');
                if (psychotic) { result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false; if (authInHost) { result.auth = authInHost.shift();
                        result.host = result.hostname = authInHost.shift(); } }
                mustEndAbs = mustEndAbs || (result.host && srcPath.length);
                if (mustEndAbs && !isAbsolute) { srcPath.unshift(''); }
                if (!srcPath.length) { result.pathname = null;
                    result.path = null; } else { result.pathname = srcPath.join('/'); }
                if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
                    result.path = (result.pathname ? result.pathname : '') +
                        (result.search ? result.search : '');
                }
                result.auth = relative.auth || result.auth;
                result.slashes = result.slashes || relative.slashes;
                result.href = result.format();
                return result;
            };
            Url.prototype.parseHost = function() {
                var host = this.host;
                var port = portPattern.exec(host);
                if (port) {
                    port = port[0];
                    if (port !== ':') { this.port = port.substr(1); }
                    host = host.substr(0, host.length - port.length);
                }
                if (host) this.hostname = host;
            };
        }, { "./util": 29, "punycode": 24, "querystring": 27 }],
        29: [function(require, module, exports) { 'use strict';
            module.exports = { isString: function(arg) { return typeof(arg) === 'string'; }, isObject: function(arg) { return typeof(arg) === 'object' && arg !== null; }, isNull: function(arg) { return arg === null; }, isNullOrUndefined: function(arg) { return arg == null; } }; }, {}],
        30: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) { return typeof obj; } : function(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
            var _miniSignals = require('mini-signals');
            var _miniSignals2 = _interopRequireDefault(_miniSignals);
            var _parseUri = require('parse-uri');
            var _parseUri2 = _interopRequireDefault(_parseUri);
            var _async = require('./async');
            var async = _interopRequireWildcard(_async);
            var _Resource = require('./Resource');
            var _Resource2 = _interopRequireDefault(_Resource);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var MAX_PROGRESS = 100;
            var rgxExtractUrlHash = /(#[\w-]+)?$/;
            var Loader = function() {
                function Loader() { var _this = this; var baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ''; var concurrency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
                    _classCallCheck(this, Loader);
                    this.baseUrl = baseUrl;
                    this.progress = 0;
                    this.loading = false;
                    this.defaultQueryString = '';
                    this._beforeMiddleware = [];
                    this._afterMiddleware = [];
                    this._resourcesParsing = [];
                    this._boundLoadResource = function(r, d) { return _this._loadResource(r, d); };
                    this._queue = async.queue(this._boundLoadResource, concurrency);
                    this._queue.pause();
                    this.resources = {};
                    this.onProgress = new _miniSignals2.default();
                    this.onError = new _miniSignals2.default();
                    this.onLoad = new _miniSignals2.default();
                    this.onStart = new _miniSignals2.default();
                    this.onComplete = new _miniSignals2.default(); }
                Loader.prototype.add = function add(name, url, options, cb) {
                    if (Array.isArray(name)) {
                        for (var i = 0; i < name.length; ++i) { this.add(name[i]); }
                        return this;
                    }
                    if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') { cb = url || name.callback || name.onComplete;
                        options = name;
                        url = name.url;
                        name = name.name || name.key || name.url; }
                    if (typeof url !== 'string') { cb = options;
                        options = url;
                        url = name; }
                    if (typeof url !== 'string') { throw new Error('No url passed to add resource to loader.'); }
                    if (typeof options === 'function') { cb = options;
                        options = null; }
                    if (this.loading && (!options || !options.parentResource)) { throw new Error('Cannot add resources while the loader is running.'); }
                    if (this.resources[name]) { throw new Error('Resource named "' + name + '" already exists.'); }
                    url = this._prepareUrl(url);
                    this.resources[name] = new _Resource2.default(name, url, options);
                    if (typeof cb === 'function') { this.resources[name].onAfterMiddleware.once(cb); }
                    if (this.loading) {
                        var parent = options.parentResource;
                        var incompleteChildren = [];
                        for (var _i = 0; _i < parent.children.length; ++_i) { if (!parent.children[_i].isComplete) { incompleteChildren.push(parent.children[_i]); } }
                        var fullChunk = parent.progressChunk * (incompleteChildren.length + 1);
                        var eachChunk = fullChunk / (incompleteChildren.length + 2);
                        parent.children.push(this.resources[name]);
                        parent.progressChunk = eachChunk;
                        for (var _i2 = 0; _i2 < incompleteChildren.length; ++_i2) { incompleteChildren[_i2].progressChunk = eachChunk; }
                        this.resources[name].progressChunk = eachChunk;
                    }
                    this._queue.push(this.resources[name]);
                    return this;
                };
                Loader.prototype.pre = function pre(fn) { this._beforeMiddleware.push(fn); return this; };
                Loader.prototype.use = function use(fn) { this._afterMiddleware.push(fn); return this; };
                Loader.prototype.reset = function reset() {
                    this.progress = 0;
                    this.loading = false;
                    this._queue.kill();
                    this._queue.pause();
                    for (var k in this.resources) {
                        var res = this.resources[k];
                        if (res._onLoadBinding) { res._onLoadBinding.detach(); }
                        if (res.isLoading) { res.abort(); }
                    }
                    this.resources = {};
                    return this;
                };
                Loader.prototype.load = function load(cb) {
                    if (typeof cb === 'function') { this.onComplete.once(cb); }
                    if (this.loading) { return this; }
                    var chunk = 100 / this._queue._tasks.length;
                    for (var i = 0; i < this._queue._tasks.length; ++i) { this._queue._tasks[i].data.progressChunk = chunk; }
                    this.loading = true;
                    this.onStart.dispatch(this);
                    this._queue.resume();
                    return this;
                };
                Loader.prototype._prepareUrl = function _prepareUrl(url) {
                    var parsedUrl = (0, _parseUri2.default)(url, { strictMode: true });
                    var result = void 0;
                    if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0) { result = url; } else if (this.baseUrl.length && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 && url.charAt(0) !== '/') { result = this.baseUrl + '/' + url; } else { result = this.baseUrl + url; }
                    if (this.defaultQueryString) {
                        var hash = rgxExtractUrlHash.exec(result)[0];
                        result = result.substr(0, result.length - hash.length);
                        if (result.indexOf('?') !== -1) { result += '&' + this.defaultQueryString; } else { result += '?' + this.defaultQueryString; }
                        result += hash;
                    }
                    return result;
                };
                Loader.prototype._loadResource = function _loadResource(resource, dequeue) { var _this2 = this;
                    resource._dequeue = dequeue;
                    async.eachSeries(this._beforeMiddleware, function(fn, next) { fn.call(_this2, resource, function() { next(resource.isComplete ? {} : null); }); }, function() { if (resource.isComplete) { _this2._onLoad(resource); } else { resource._onLoadBinding = resource.onComplete.once(_this2._onLoad, _this2);
                            resource.load(); } }); };
                Loader.prototype._onComplete = function _onComplete() { this.loading = false;
                    this.onComplete.dispatch(this, this.resources); };
                Loader.prototype._onLoad = function _onLoad(resource) {
                    var _this3 = this;
                    resource._onLoadBinding = null;
                    resource._dequeue();
                    this._resourcesParsing.push(resource);
                    async.eachSeries(this._afterMiddleware, function(fn, next) { fn.call(_this3, resource, next); }, function() {
                        resource.onAfterMiddleware.dispatch(resource);
                        _this3.progress += resource.progressChunk;
                        _this3.onProgress.dispatch(_this3, resource);
                        if (resource.error) { _this3.onError.dispatch(resource.error, _this3, resource); } else { _this3.onLoad.dispatch(_this3, resource); }
                        _this3._resourcesParsing.splice(_this3._resourcesParsing.indexOf(resource), 1);
                        if (_this3._queue.idle() && _this3._resourcesParsing.length === 0) { _this3.progress = MAX_PROGRESS;
                            _this3._onComplete(); }
                    });
                };
                return Loader;
            }();
            exports.default = Loader;
        }, { "./Resource": 31, "./async": 32, "mini-signals": 36, "parse-uri": 37 }],
        31: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _parseUri = require('parse-uri');
            var _parseUri2 = _interopRequireDefault(_parseUri);
            var _miniSignals = require('mini-signals');
            var _miniSignals2 = _interopRequireDefault(_miniSignals);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var useXdr = !!(window.XDomainRequest && !('withCredentials' in new XMLHttpRequest()));
            var tempAnchor = null;
            var STATUS_NONE = 0;
            var STATUS_OK = 200;
            var STATUS_EMPTY = 204;

            function _noop() {}
            var Resource = function() {
                Resource.setExtensionLoadType = function setExtensionLoadType(extname, loadType) { setExtMap(Resource._loadTypeMap, extname, loadType); };
                Resource.setExtensionXhrType = function setExtensionXhrType(extname, xhrType) { setExtMap(Resource._xhrTypeMap, extname, xhrType); };

                function Resource(name, url, options) {
                    _classCallCheck(this, Resource);
                    if (typeof name !== 'string' || typeof url !== 'string') { throw new Error('Both name and url are required for constructing a resource.'); }
                    options = options || {};
                    this._flags = 0;
                    this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);
                    this.name = name;
                    this.url = url;
                    this.extension = this._getExtension();
                    this.data = null;
                    this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;
                    this.loadType = options.loadType || this._determineLoadType();
                    this.xhrType = options.xhrType;
                    this.metadata = options.metadata || {};
                    this.error = null;
                    this.xhr = null;
                    this.children = [];
                    this.type = Resource.TYPE.UNKNOWN;
                    this.progressChunk = 0;
                    this._dequeue = _noop;
                    this._onLoadBinding = null;
                    this._boundComplete = this.complete.bind(this);
                    this._boundOnError = this._onError.bind(this);
                    this._boundOnProgress = this._onProgress.bind(this);
                    this._boundXhrOnError = this._xhrOnError.bind(this);
                    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);
                    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);
                    this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this);
                    this.onStart = new _miniSignals2.default();
                    this.onProgress = new _miniSignals2.default();
                    this.onComplete = new _miniSignals2.default();
                    this.onAfterMiddleware = new _miniSignals2.default();
                }
                Resource.prototype.complete = function complete() {
                    if (this.data && this.data.removeEventListener) { this.data.removeEventListener('error', this._boundOnError, false);
                        this.data.removeEventListener('load', this._boundComplete, false);
                        this.data.removeEventListener('progress', this._boundOnProgress, false);
                        this.data.removeEventListener('canplaythrough', this._boundComplete, false); }
                    if (this.xhr) { if (this.xhr.removeEventListener) { this.xhr.removeEventListener('error', this._boundXhrOnError, false);
                            this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);
                            this.xhr.removeEventListener('progress', this._boundOnProgress, false);
                            this.xhr.removeEventListener('load', this._boundXhrOnLoad, false); } else { this.xhr.onerror = null;
                            this.xhr.ontimeout = null;
                            this.xhr.onprogress = null;
                            this.xhr.onload = null; } }
                    if (this.isComplete) { throw new Error('Complete called again for an already completed resource.'); }
                    this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);
                    this._setFlag(Resource.STATUS_FLAGS.LOADING, false);
                    this.onComplete.dispatch(this);
                };
                Resource.prototype.abort = function abort(message) {
                    if (this.error) { return; }
                    this.error = new Error(message);
                    if (this.xhr) { this.xhr.abort(); } else if (this.xdr) { this.xdr.abort(); } else if (this.data) {
                        if (this.data.src) { this.data.src = Resource.EMPTY_GIF; } else { while (this.data.firstChild) { this.data.removeChild(this.data.firstChild); } }
                    }
                    this.complete();
                };
                Resource.prototype.load = function load(cb) {
                    var _this = this;
                    if (this.isLoading) { return; }
                    if (this.isComplete) {
                        if (cb) { setTimeout(function() { return cb(_this); }, 1); }
                        return;
                    } else if (cb) { this.onComplete.once(cb); }
                    this._setFlag(Resource.STATUS_FLAGS.LOADING, true);
                    this.onStart.dispatch(this);
                    if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') { this.crossOrigin = this._determineCrossOrigin(this.url); }
                    switch (this.loadType) {
                        case Resource.LOAD_TYPE.IMAGE:
                            this.type = Resource.TYPE.IMAGE;
                            this._loadElement('image');
                            break;
                        case Resource.LOAD_TYPE.AUDIO:
                            this.type = Resource.TYPE.AUDIO;
                            this._loadSourceElement('audio');
                            break;
                        case Resource.LOAD_TYPE.VIDEO:
                            this.type = Resource.TYPE.VIDEO;
                            this._loadSourceElement('video');
                            break;
                        case Resource.LOAD_TYPE.XHR:
                        default:
                            if (useXdr && this.crossOrigin) { this._loadXdr(); } else { this._loadXhr(); }
                            break;
                    }
                };
                Resource.prototype._hasFlag = function _hasFlag(flag) { return !!(this._flags & flag); };
                Resource.prototype._setFlag = function _setFlag(flag, value) { this._flags = value ? this._flags | flag : this._flags & ~flag; };
                Resource.prototype._loadElement = function _loadElement(type) {
                    if (this.metadata.loadElement) { this.data = this.metadata.loadElement; } else if (type === 'image' && typeof window.Image !== 'undefined') { this.data = new Image(); } else { this.data = document.createElement(type); }
                    if (this.crossOrigin) { this.data.crossOrigin = this.crossOrigin; }
                    if (!this.metadata.skipSource) { this.data.src = this.url; }
                    this.data.addEventListener('error', this._boundOnError, false);
                    this.data.addEventListener('load', this._boundComplete, false);
                    this.data.addEventListener('progress', this._boundOnProgress, false);
                };
                Resource.prototype._loadSourceElement = function _loadSourceElement(type) {
                    if (this.metadata.loadElement) { this.data = this.metadata.loadElement; } else if (type === 'audio' && typeof window.Audio !== 'undefined') { this.data = new Audio(); } else { this.data = document.createElement(type); }
                    if (this.data === null) { this.abort('Unsupported element: ' + type); return; }
                    if (!this.metadata.skipSource) { if (navigator.isCocoonJS) { this.data.src = Array.isArray(this.url) ? this.url[0] : this.url; } else if (Array.isArray(this.url)) { for (var i = 0; i < this.url.length; ++i) { this.data.appendChild(this._createSource(type, this.url[i])); } } else { this.data.appendChild(this._createSource(type, this.url)); } }
                    this.data.addEventListener('error', this._boundOnError, false);
                    this.data.addEventListener('load', this._boundComplete, false);
                    this.data.addEventListener('progress', this._boundOnProgress, false);
                    this.data.addEventListener('canplaythrough', this._boundComplete, false);
                    this.data.load();
                };
                Resource.prototype._loadXhr = function _loadXhr() {
                    if (typeof this.xhrType !== 'string') { this.xhrType = this._determineXhrType(); }
                    var xhr = this.xhr = new XMLHttpRequest();
                    xhr.open('GET', this.url, true);
                    if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) { xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT; } else { xhr.responseType = this.xhrType; }
                    xhr.addEventListener('error', this._boundXhrOnError, false);
                    xhr.addEventListener('abort', this._boundXhrOnAbort, false);
                    xhr.addEventListener('progress', this._boundOnProgress, false);
                    xhr.addEventListener('load', this._boundXhrOnLoad, false);
                    xhr.send();
                };
                Resource.prototype._loadXdr = function _loadXdr() {
                    if (typeof this.xhrType !== 'string') { this.xhrType = this._determineXhrType(); }
                    var xdr = this.xhr = new XDomainRequest();
                    xdr.timeout = 5000;
                    xdr.onerror = this._boundXhrOnError;
                    xdr.ontimeout = this._boundXdrOnTimeout;
                    xdr.onprogress = this._boundOnProgress;
                    xdr.onload = this._boundXhrOnLoad;
                    xdr.open('GET', this.url, true);
                    setTimeout(function() { return xdr.send(); }, 1);
                };
                Resource.prototype._createSource = function _createSource(type, url, mime) {
                    if (!mime) { mime = type + '/' + url.substr(url.lastIndexOf('.') + 1); }
                    var source = document.createElement('source');
                    source.src = url;
                    source.type = mime;
                    return source;
                };
                Resource.prototype._onError = function _onError(event) { this.abort('Failed to load element using: ' + event.target.nodeName); };
                Resource.prototype._onProgress = function _onProgress(event) { if (event && event.lengthComputable) { this.onProgress.dispatch(this, event.loaded / event.total); } };
                Resource.prototype._xhrOnError = function _xhrOnError() { var xhr = this.xhr;
                    this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: "' + xhr.statusText + '"'); };
                Resource.prototype._xhrOnAbort = function _xhrOnAbort() { this.abort(reqType(this.xhr) + ' Request was aborted by the user.'); };
                Resource.prototype._xdrOnTimeout = function _xdrOnTimeout() { this.abort(reqType(this.xhr) + ' Request timed out.'); };
                Resource.prototype._xhrOnLoad = function _xhrOnLoad() {
                    var xhr = this.xhr;
                    var status = typeof xhr.status === 'undefined' ? xhr.status : STATUS_OK;
                    if (status === STATUS_OK || status === STATUS_EMPTY || status === STATUS_NONE && xhr.responseText.length > 0) {
                        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) { this.data = xhr.responseText;
                            this.type = Resource.TYPE.TEXT; } else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) { try { this.data = JSON.parse(xhr.responseText);
                                this.type = Resource.TYPE.JSON; } catch (e) { this.abort('Error trying to parse loaded json: ' + e); return; } } else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {
                            try {
                                if (window.DOMParser) { var domparser = new DOMParser();
                                    this.data = domparser.parseFromString(xhr.responseText, 'text/xml'); } else { var div = document.createElement('div');
                                    div.innerHTML = xhr.responseText;
                                    this.data = div; }
                                this.type = Resource.TYPE.XML;
                            } catch (e) { this.abort('Error trying to parse loaded xml: ' + e); return; }
                        } else { this.data = xhr.response || xhr.responseText; }
                    } else { this.abort('[' + xhr.status + '] ' + xhr.statusText + ': ' + xhr.responseURL); return; }
                    this.complete();
                };
                Resource.prototype._determineCrossOrigin = function _determineCrossOrigin(url, loc) {
                    if (url.indexOf('data:') === 0) { return ''; }
                    loc = loc || window.location;
                    if (!tempAnchor) { tempAnchor = document.createElement('a'); }
                    tempAnchor.href = url;
                    url = (0, _parseUri2.default)(tempAnchor.href, { strictMode: true });
                    var samePort = !url.port && loc.port === '' || url.port === loc.port;
                    var protocol = url.protocol ? url.protocol + ':' : '';
                    if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) { return 'anonymous'; }
                    return '';
                };
                Resource.prototype._determineXhrType = function _determineXhrType() { return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT; };
                Resource.prototype._determineLoadType = function _determineLoadType() { return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR; };
                Resource.prototype._getExtension = function _getExtension() {
                    var url = this.url;
                    var ext = '';
                    if (this.isDataUrl) { var slashIndex = url.indexOf('/');
                        ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex)); } else {
                        var queryStart = url.indexOf('?');
                        if (queryStart !== -1) { url = url.substring(0, queryStart); }
                        ext = url.substring(url.lastIndexOf('.') + 1);
                    }
                    return ext.toLowerCase();
                };
                Resource.prototype._getMimeFromXhrType = function _getMimeFromXhrType(type) { switch (type) {
                        case Resource.XHR_RESPONSE_TYPE.BUFFER:
                            return 'application/octet-binary';
                        case Resource.XHR_RESPONSE_TYPE.BLOB:
                            return 'application/blob';
                        case Resource.XHR_RESPONSE_TYPE.DOCUMENT:
                            return 'application/xml';
                        case Resource.XHR_RESPONSE_TYPE.JSON:
                            return 'application/json';
                        case Resource.XHR_RESPONSE_TYPE.DEFAULT:
                        case Resource.XHR_RESPONSE_TYPE.TEXT:
                        default:
                            return 'text/plain'; } };
                _createClass(Resource, [{ key: 'isDataUrl', get: function get() { return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL); } }, { key: 'isComplete', get: function get() { return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE); } }, { key: 'isLoading', get: function get() { return this._hasFlag(Resource.STATUS_FLAGS.LOADING); } }]);
                return Resource;
            }();
            exports.default = Resource;
            Resource.STATUS_FLAGS = { NONE: 0, DATA_URL: 1 << 0, COMPLETE: 1 << 1, LOADING: 1 << 2 };
            Resource.TYPE = { UNKNOWN: 0, JSON: 1, XML: 2, IMAGE: 3, AUDIO: 4, VIDEO: 5, TEXT: 6 };
            Resource.LOAD_TYPE = { XHR: 1, IMAGE: 2, AUDIO: 3, VIDEO: 4 };
            Resource.XHR_RESPONSE_TYPE = { DEFAULT: 'text', BUFFER: 'arraybuffer', BLOB: 'blob', DOCUMENT: 'document', JSON: 'json', TEXT: 'text' };
            Resource._loadTypeMap = { gif: Resource.LOAD_TYPE.IMAGE, png: Resource.LOAD_TYPE.IMAGE, bmp: Resource.LOAD_TYPE.IMAGE, jpg: Resource.LOAD_TYPE.IMAGE, jpeg: Resource.LOAD_TYPE.IMAGE, tif: Resource.LOAD_TYPE.IMAGE, tiff: Resource.LOAD_TYPE.IMAGE, webp: Resource.LOAD_TYPE.IMAGE, tga: Resource.LOAD_TYPE.IMAGE, svg: Resource.LOAD_TYPE.IMAGE, 'svg+xml': Resource.LOAD_TYPE.IMAGE, mp3: Resource.LOAD_TYPE.AUDIO, ogg: Resource.LOAD_TYPE.AUDIO, wav: Resource.LOAD_TYPE.AUDIO, mp4: Resource.LOAD_TYPE.VIDEO, webm: Resource.LOAD_TYPE.VIDEO };
            Resource._xhrTypeMap = { xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT, html: Resource.XHR_RESPONSE_TYPE.DOCUMENT, htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT, xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT, tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT, svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT, tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT, gif: Resource.XHR_RESPONSE_TYPE.BLOB, png: Resource.XHR_RESPONSE_TYPE.BLOB, bmp: Resource.XHR_RESPONSE_TYPE.BLOB, jpg: Resource.XHR_RESPONSE_TYPE.BLOB, jpeg: Resource.XHR_RESPONSE_TYPE.BLOB, tif: Resource.XHR_RESPONSE_TYPE.BLOB, tiff: Resource.XHR_RESPONSE_TYPE.BLOB, webp: Resource.XHR_RESPONSE_TYPE.BLOB, tga: Resource.XHR_RESPONSE_TYPE.BLOB, json: Resource.XHR_RESPONSE_TYPE.JSON, text: Resource.XHR_RESPONSE_TYPE.TEXT, txt: Resource.XHR_RESPONSE_TYPE.TEXT, ttf: Resource.XHR_RESPONSE_TYPE.BUFFER, otf: Resource.XHR_RESPONSE_TYPE.BUFFER };
            Resource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';

            function setExtMap(map, extname, val) {
                if (extname && extname.indexOf('.') === 0) { extname = extname.substring(1); }
                if (!extname) { return; }
                map[extname] = val;
            }

            function reqType(xhr) { return xhr.toString().replace('object ', ''); }
        }, { "mini-signals": 36, "parse-uri": 37 }],
        32: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.eachSeries = eachSeries;
            exports.queue = queue;

            function _noop() {}

            function eachSeries(array, iterator, callback) {
                var i = 0;
                var len = array.length;
                (function next(err) {
                    if (err || i === len) {
                        if (callback) { callback(err); }
                        return;
                    }
                    iterator(array[i++], next);
                })();
            }

            function onlyOnce(fn) {
                return function onceWrapper() {
                    if (fn === null) { throw new Error('Callback was already called.'); }
                    var callFn = fn;
                    fn = null;
                    callFn.apply(this, arguments);
                };
            }

            function queue(worker, concurrency) {
                if (concurrency == null) { concurrency = 1; } else if (concurrency === 0) { throw new Error('Concurrency must not be zero'); }
                var workers = 0;
                var q = {
                    _tasks: [],
                    concurrency: concurrency,
                    saturated: _noop,
                    unsaturated: _noop,
                    buffer: concurrency / 4,
                    empty: _noop,
                    drain: _noop,
                    error: _noop,
                    started: false,
                    paused: false,
                    push: function push(data, callback) { _insert(data, false, callback); },
                    kill: function kill() { workers = 0;
                        q.drain = _noop;
                        q.started = false;
                        q._tasks = []; },
                    unshift: function unshift(data, callback) { _insert(data, true, callback); },
                    process: function process() {
                        while (!q.paused && workers < q.concurrency && q._tasks.length) {
                            var task = q._tasks.shift();
                            if (q._tasks.length === 0) { q.empty(); }
                            workers += 1;
                            if (workers === q.concurrency) { q.saturated(); }
                            worker(task.data, onlyOnce(_next(task)));
                        }
                    },
                    length: function length() { return q._tasks.length; },
                    running: function running() { return workers; },
                    idle: function idle() { return q._tasks.length + workers === 0; },
                    pause: function pause() {
                        if (q.paused === true) { return; }
                        q.paused = true;
                    },
                    resume: function resume() {
                        if (q.paused === false) { return; }
                        q.paused = false;
                        for (var w = 1; w <= q.concurrency; w++) { q.process(); }
                    }
                };

                function _insert(data, insertAtFront, callback) {
                    if (callback != null && typeof callback !== 'function') { throw new Error('task callback must be a function'); }
                    q.started = true;
                    if (data == null && q.idle()) { setTimeout(function() { return q.drain(); }, 1); return; }
                    var item = { data: data, callback: typeof callback === 'function' ? callback : _noop };
                    if (insertAtFront) { q._tasks.unshift(item); } else { q._tasks.push(item); }
                    setTimeout(function() { return q.process(); }, 1);
                }

                function _next(task) {
                    return function next() {
                        workers -= 1;
                        task.callback.apply(task, arguments);
                        if (arguments[0] != null) { q.error(arguments[0], task.data); }
                        if (workers <= q.concurrency - q.buffer) { q.unsaturated(); }
                        if (q.idle()) { q.drain(); }
                        q.process();
                    };
                }
                return q;
            }
        }, {}],
        33: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.encodeBinary = encodeBinary;
            var _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

            function encodeBinary(input) {
                var output = '';
                var inx = 0;
                while (inx < input.length) {
                    var bytebuffer = [0, 0, 0];
                    var encodedCharIndexes = [0, 0, 0, 0];
                    for (var jnx = 0; jnx < bytebuffer.length; ++jnx) { if (inx < input.length) { bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff; } else { bytebuffer[jnx] = 0; } }
                    encodedCharIndexes[0] = bytebuffer[0] >> 2;
                    encodedCharIndexes[1] = (bytebuffer[0] & 0x3) << 4 | bytebuffer[1] >> 4;
                    encodedCharIndexes[2] = (bytebuffer[1] & 0x0f) << 2 | bytebuffer[2] >> 6;
                    encodedCharIndexes[3] = bytebuffer[2] & 0x3f;
                    var paddingBytes = inx - (input.length - 1);
                    switch (paddingBytes) {
                        case 2:
                            encodedCharIndexes[3] = 64;
                            encodedCharIndexes[2] = 64; break;
                        case 1:
                            encodedCharIndexes[3] = 64; break;
                        default:
                            break; }
                    for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx) { output += _keyStr.charAt(encodedCharIndexes[_jnx]); }
                }
                return output;
            }
        }, {}],
        34: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _Loader = require('./Loader');
            var _Loader2 = _interopRequireDefault(_Loader);
            var _Resource = require('./Resource');
            var _Resource2 = _interopRequireDefault(_Resource);
            var _async = require('./async');
            var async = _interopRequireWildcard(_async);
            var _b = require('./b64');
            var b64 = _interopRequireWildcard(_b);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            _Loader2.default.Resource = _Resource2.default;
            _Loader2.default.async = async;
            _Loader2.default.base64 = b64;
            module.exports = _Loader2.default;
            exports.default = _Loader2.default;
        }, { "./Loader": 30, "./Resource": 31, "./async": 32, "./b64": 33 }],
        35: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) { return typeof obj; } : function(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
            exports.blobMiddlewareFactory = blobMiddlewareFactory;
            var _Resource = require('../../Resource');
            var _Resource2 = _interopRequireDefault(_Resource);
            var _b = require('../../b64');
            var _b2 = _interopRequireDefault(_b);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            var Url = window.URL || window.webkitURL;

            function blobMiddlewareFactory() {
                return function blobMiddleware(resource, next) {
                    if (!resource.data) { next(); return; }
                    if (resource.xhr && resource.xhrType === _Resource2.default.XHR_RESPONSE_TYPE.BLOB) {
                        if (!window.Blob || typeof resource.data === 'string') { var type = resource.xhr.getResponseHeader('content-type'); if (type && type.indexOf('image') === 0) { resource.data = new Image();
                                resource.data.src = 'data:' + type + ';base64,' + _b2.default.encodeBinary(resource.xhr.responseText);
                                resource.type = _Resource2.default.TYPE.IMAGE;
                                resource.data.onload = function() { resource.data.onload = null;
                                    next(); }; return; } } else if (resource.data.type.indexOf('image') === 0) { var _ret = function() { var src = Url.createObjectURL(resource.data);
                                resource.blob = resource.data;
                                resource.data = new Image();
                                resource.data.src = src;
                                resource.type = _Resource2.default.TYPE.IMAGE;
                                resource.data.onload = function() { Url.revokeObjectURL(src);
                                    resource.data.onload = null;
                                    next(); }; return { v: void 0 }; }(); if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v; }
                    }
                    next();
                };
            }
        }, { "../../Resource": 31, "../../b64": 33 }],
        36: [function(require, module, exports) {
            'use strict';
            Object.defineProperty(exports, '__esModule', { value: true });
            var _createClass = (function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
            var MiniSignalBinding = (function() {
                function MiniSignalBinding(fn, once, thisArg) { if (once === undefined) once = false;
                    _classCallCheck(this, MiniSignalBinding);
                    this._fn = fn;
                    this._once = once;
                    this._thisArg = thisArg;
                    this._next = this._prev = this._owner = null; }
                _createClass(MiniSignalBinding, [{ key: 'detach', value: function detach() { if (this._owner === null) return false;
                        this._owner.detach(this); return true; } }]);
                return MiniSignalBinding;
            })();

            function _addMiniSignalBinding(self, node) {
                if (!self._head) { self._head = node;
                    self._tail = node; } else { self._tail._next = node;
                    node._prev = self._tail;
                    self._tail = node; }
                node._owner = self;
                return node;
            }
            var MiniSignal = (function() {
                function MiniSignal() { _classCallCheck(this, MiniSignal);
                    this._head = this._tail = undefined; }
                _createClass(MiniSignal, [{
                    key: 'handlers',
                    value: function handlers() {
                        var exists = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
                        var node = this._head;
                        if (exists) return !!node;
                        var ee = [];
                        while (node) { ee.push(node);
                            node = node._next; }
                        return ee;
                    }
                }, {
                    key: 'has',
                    value: function has(node) {
                        if (!(node instanceof MiniSignalBinding)) { throw new Error('MiniSignal#has(): First arg must be a MiniSignalBinding object.'); }
                        return node._owner === this;
                    }
                }, {
                    key: 'dispatch',
                    value: function dispatch() {
                        var node = this._head;
                        if (!node) return false;
                        while (node) { if (node._once) this.detach(node);
                            node._fn.apply(node._thisArg, arguments);
                            node = node._next; }
                        return true;
                    }
                }, {
                    key: 'add',
                    value: function add(fn) {
                        var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
                        if (typeof fn !== 'function') { throw new Error('MiniSignal#add(): First arg must be a Function.'); }
                        return _addMiniSignalBinding(this, new MiniSignalBinding(fn, false, thisArg));
                    }
                }, {
                    key: 'once',
                    value: function once(fn) {
                        var thisArg = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
                        if (typeof fn !== 'function') { throw new Error('MiniSignal#once(): First arg must be a Function.'); }
                        return _addMiniSignalBinding(this, new MiniSignalBinding(fn, true, thisArg));
                    }
                }, {
                    key: 'detach',
                    value: function detach(node) {
                        if (!(node instanceof MiniSignalBinding)) { throw new Error('MiniSignal#detach(): First arg must be a MiniSignalBinding object.'); }
                        if (node._owner !== this) return this;
                        if (node._prev) node._prev._next = node._next;
                        if (node._next) node._next._prev = node._prev;
                        if (node === this._head) { this._head = node._next; if (node._next === null) { this._tail = null; } } else if (node === this._tail) { this._tail = node._prev;
                            this._tail._next = null; }
                        node._owner = null;
                        return this;
                    }
                }, {
                    key: 'detachAll',
                    value: function detachAll() {
                        var node = this._head;
                        if (!node) return this;
                        this._head = this._tail = null;
                        while (node) { node._owner = null;
                            node = node._next; }
                        return this;
                    }
                }]);
                return MiniSignal;
            })();
            MiniSignal.MiniSignalBinding = MiniSignalBinding;
            exports['default'] = MiniSignal;
            module.exports = exports['default'];
        }, {}],
        37: [function(require, module, exports) {
            'use strict'
            module.exports = function parseURI(str, opts) {
                opts = opts || {}
                var o = { key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'], q: { name: 'queryKey', parser: /(?:^|&)([^&=]*)=?([^&]*)/g }, parser: { strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/, loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/ } }
                var m = o.parser[opts.strictMode ? 'strict' : 'loose'].exec(str)
                var uri = {}
                var i = 14
                while (i--) uri[o.key[i]] = m[i] || ''
                uri[o.q.name] = {}
                uri[o.key[12]].replace(o.q.parser, function($0, $1, $2) { if ($1) uri[o.q.name][$1] = $2 })
                return uri
            }
        }, {}],
        38: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../core');
            var core = _interopRequireWildcard(_core);
            var _ismobilejs = require('ismobilejs');
            var _ismobilejs2 = _interopRequireDefault(_ismobilejs);
            var _accessibleTarget = require('./accessibleTarget');
            var _accessibleTarget2 = _interopRequireDefault(_accessibleTarget);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            core.utils.mixins.delayMixin(core.DisplayObject.prototype, _accessibleTarget2.default);
            var KEY_CODE_TAB = 9;
            var DIV_TOUCH_SIZE = 100;
            var DIV_TOUCH_POS_X = 0;
            var DIV_TOUCH_POS_Y = 0;
            var DIV_TOUCH_ZINDEX = 2;
            var DIV_HOOK_SIZE = 1;
            var DIV_HOOK_POS_X = -1000;
            var DIV_HOOK_POS_Y = -1000;
            var DIV_HOOK_ZINDEX = 2;
            var AccessibilityManager = function() {
                function AccessibilityManager(renderer) {
                    _classCallCheck(this, AccessibilityManager);
                    if ((_ismobilejs2.default.tablet || _ismobilejs2.default.phone) && !navigator.isCocoonJS) { this.createTouchHook(); }
                    var div = document.createElement('div');
                    div.style.width = DIV_TOUCH_SIZE + 'px';
                    div.style.height = DIV_TOUCH_SIZE + 'px';
                    div.style.position = 'absolute';
                    div.style.top = DIV_TOUCH_POS_X + 'px';
                    div.style.left = DIV_TOUCH_POS_Y + 'px';
                    div.style.zIndex = DIV_TOUCH_ZINDEX;
                    this.div = div;
                    this.pool = [];
                    this.renderId = 0;
                    this.debug = false;
                    this.renderer = renderer;
                    this.children = [];
                    this._onKeyDown = this._onKeyDown.bind(this);
                    this._onMouseMove = this._onMouseMove.bind(this);
                    this.isActive = false;
                    this.isMobileAccessabillity = false;
                    window.addEventListener('keydown', this._onKeyDown, false);
                }
                AccessibilityManager.prototype.createTouchHook = function createTouchHook() { var _this = this; var hookDiv = document.createElement('button');
                    hookDiv.style.width = DIV_HOOK_SIZE + 'px';
                    hookDiv.style.height = DIV_HOOK_SIZE + 'px';
                    hookDiv.style.position = 'absolute';
                    hookDiv.style.top = DIV_HOOK_POS_X + 'px';
                    hookDiv.style.left = DIV_HOOK_POS_Y + 'px';
                    hookDiv.style.zIndex = DIV_HOOK_ZINDEX;
                    hookDiv.style.backgroundColor = '#FF0000';
                    hookDiv.title = 'HOOK DIV';
                    hookDiv.addEventListener('focus', function() { _this.isMobileAccessabillity = true;
                        _this.activate();
                        document.body.removeChild(hookDiv); });
                    document.body.appendChild(hookDiv); };
                AccessibilityManager.prototype.activate = function activate() {
                    if (this.isActive) { return; }
                    this.isActive = true;
                    window.document.addEventListener('mousemove', this._onMouseMove, true);
                    window.removeEventListener('keydown', this._onKeyDown, false);
                    this.renderer.on('postrender', this.update, this);
                    if (this.renderer.view.parentNode) { this.renderer.view.parentNode.appendChild(this.div); }
                };
                AccessibilityManager.prototype.deactivate = function deactivate() {
                    if (!this.isActive || this.isMobileAccessabillity) { return; }
                    this.isActive = false;
                    window.document.removeEventListener('mousemove', this._onMouseMove);
                    window.addEventListener('keydown', this._onKeyDown, false);
                    this.renderer.off('postrender', this.update);
                    if (this.div.parentNode) { this.div.parentNode.removeChild(this.div); }
                };
                AccessibilityManager.prototype.updateAccessibleObjects = function updateAccessibleObjects(displayObject) {
                    if (!displayObject.visible) { return; }
                    if (displayObject.accessible && displayObject.interactive) {
                        if (!displayObject._accessibleActive) { this.addChild(displayObject); }
                        displayObject.renderId = this.renderId;
                    }
                    var children = displayObject.children;
                    for (var i = children.length - 1; i >= 0; i--) { this.updateAccessibleObjects(children[i]); }
                };
                AccessibilityManager.prototype.update = function update() {
                    if (!this.renderer.renderingToScreen) { return; }
                    this.updateAccessibleObjects(this.renderer._lastObjectRendered);
                    var rect = this.renderer.view.getBoundingClientRect();
                    var sx = rect.width / this.renderer.width;
                    var sy = rect.height / this.renderer.height;
                    var div = this.div;
                    div.style.left = rect.left + 'px';
                    div.style.top = rect.top + 'px';
                    div.style.width = this.renderer.width + 'px';
                    div.style.height = this.renderer.height + 'px';
                    for (var i = 0; i < this.children.length; i++) { var child = this.children[i]; if (child.renderId !== this.renderId) { child._accessibleActive = false;
                            core.utils.removeItems(this.children, i, 1);
                            this.div.removeChild(child._accessibleDiv);
                            this.pool.push(child._accessibleDiv);
                            child._accessibleDiv = null;
                            i--; if (this.children.length === 0) { this.deactivate(); } } else { div = child._accessibleDiv; var hitArea = child.hitArea; var wt = child.worldTransform; if (child.hitArea) { div.style.left = (wt.tx + hitArea.x * wt.a) * sx + 'px';
                                div.style.top = (wt.ty + hitArea.y * wt.d) * sy + 'px';
                                div.style.width = hitArea.width * wt.a * sx + 'px';
                                div.style.height = hitArea.height * wt.d * sy + 'px'; } else { hitArea = child.getBounds();
                                this.capHitArea(hitArea);
                                div.style.left = hitArea.x * sx + 'px';
                                div.style.top = hitArea.y * sy + 'px';
                                div.style.width = hitArea.width * sx + 'px';
                                div.style.height = hitArea.height * sy + 'px'; } } }
                    this.renderId++;
                };
                AccessibilityManager.prototype.capHitArea = function capHitArea(hitArea) {
                    if (hitArea.x < 0) { hitArea.width += hitArea.x;
                        hitArea.x = 0; }
                    if (hitArea.y < 0) { hitArea.height += hitArea.y;
                        hitArea.y = 0; }
                    if (hitArea.x + hitArea.width > this.renderer.width) { hitArea.width = this.renderer.width - hitArea.x; }
                    if (hitArea.y + hitArea.height > this.renderer.height) { hitArea.height = this.renderer.height - hitArea.y; }
                };
                AccessibilityManager.prototype.addChild = function addChild(displayObject) {
                    var div = this.pool.pop();
                    if (!div) { div = document.createElement('button');
                        div.style.width = DIV_TOUCH_SIZE + 'px';
                        div.style.height = DIV_TOUCH_SIZE + 'px';
                        div.style.backgroundColor = this.debug ? 'rgba(255,0,0,0.5)' : 'transparent';
                        div.style.position = 'absolute';
                        div.style.zIndex = DIV_TOUCH_ZINDEX;
                        div.style.borderStyle = 'none';
                        div.addEventListener('click', this._onClick.bind(this));
                        div.addEventListener('focus', this._onFocus.bind(this));
                        div.addEventListener('focusout', this._onFocusOut.bind(this)); }
                    if (displayObject.accessibleTitle) { div.title = displayObject.accessibleTitle; } else if (!displayObject.accessibleTitle && !displayObject.accessibleHint) { div.title = 'displayObject ' + this.tabIndex; }
                    if (displayObject.accessibleHint) { div.setAttribute('aria-label', displayObject.accessibleHint); }
                    displayObject._accessibleActive = true;
                    displayObject._accessibleDiv = div;
                    div.displayObject = displayObject;
                    this.children.push(displayObject);
                    this.div.appendChild(displayObject._accessibleDiv);
                    displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
                };
                AccessibilityManager.prototype._onClick = function _onClick(e) { var interactionManager = this.renderer.plugins.interaction;
                    interactionManager.dispatchEvent(e.target.displayObject, 'click', interactionManager.eventData); };
                AccessibilityManager.prototype._onFocus = function _onFocus(e) { var interactionManager = this.renderer.plugins.interaction;
                    interactionManager.dispatchEvent(e.target.displayObject, 'mouseover', interactionManager.eventData); };
                AccessibilityManager.prototype._onFocusOut = function _onFocusOut(e) { var interactionManager = this.renderer.plugins.interaction;
                    interactionManager.dispatchEvent(e.target.displayObject, 'mouseout', interactionManager.eventData); };
                AccessibilityManager.prototype._onKeyDown = function _onKeyDown(e) {
                    if (e.keyCode !== KEY_CODE_TAB) { return; }
                    this.activate();
                };
                AccessibilityManager.prototype._onMouseMove = function _onMouseMove() { this.deactivate(); };
                AccessibilityManager.prototype.destroy = function destroy() {
                    this.div = null;
                    for (var i = 0; i < this.children.length; i++) { this.children[i].div = null; }
                    window.document.removeEventListener('mousemove', this._onMouseMove);
                    window.removeEventListener('keydown', this._onKeyDown);
                    this.pool = null;
                    this.children = null;
                    this.renderer = null;
                };
                return AccessibilityManager;
            }();
            exports.default = AccessibilityManager;
            core.WebGLRenderer.registerPlugin('accessibility', AccessibilityManager);
            core.CanvasRenderer.registerPlugin('accessibility', AccessibilityManager);
        }, { "../core": 63, "./accessibleTarget": 39, "ismobilejs": 4 }],
        39: [function(require, module, exports) { "use strict";
            exports.__esModule = true;
            exports.default = { accessible: false, accessibleTitle: null, accessibleHint: null, tabIndex: 0, _accessibleActive: false, _accessibleDiv: false }; }, {}],
        40: [function(require, module, exports) { 'use strict';
            exports.__esModule = true; var _accessibleTarget = require('./accessibleTarget');
            Object.defineProperty(exports, 'accessibleTarget', { enumerable: true, get: function get() { return _interopRequireDefault(_accessibleTarget).default; } }); var _AccessibilityManager = require('./AccessibilityManager');
            Object.defineProperty(exports, 'AccessibilityManager', { enumerable: true, get: function get() { return _interopRequireDefault(_AccessibilityManager).default; } });

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } }, { "./AccessibilityManager": 38, "./accessibleTarget": 39 }],
        41: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _autoDetectRenderer = require('./autoDetectRenderer');
            var _Container = require('./display/Container');
            var _Container2 = _interopRequireDefault(_Container);
            var _ticker = require('./ticker');
            var _settings = require('./settings');
            var _settings2 = _interopRequireDefault(_settings);
            var _const = require('./const');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var Application = function() {
                function Application(options, arg2, arg3, arg4, arg5) {
                    _classCallCheck(this, Application);
                    if (typeof options === 'number') { options = Object.assign({ width: options, height: arg2 || _settings2.default.RENDER_OPTIONS.height, forceCanvas: !!arg4, sharedTicker: !!arg5 }, arg3); }
                    this._options = options = Object.assign({ sharedTicker: false, forceCanvas: false, sharedLoader: false }, options);
                    this.renderer = (0, _autoDetectRenderer.autoDetectRenderer)(options);
                    this.stage = new _Container2.default();
                    this._ticker = null;
                    this.ticker = options.sharedTicker ? _ticker.shared : new _ticker.Ticker();
                    this.start();
                }
                Application.prototype.render = function render() { this.renderer.render(this.stage); };
                Application.prototype.stop = function stop() { this._ticker.stop(); };
                Application.prototype.start = function start() { this._ticker.start(); };
                Application.prototype.destroy = function destroy(removeView) { var oldTicker = this._ticker;
                    this.ticker = null;
                    oldTicker.destroy();
                    this.stage.destroy();
                    this.stage = null;
                    this.renderer.destroy(removeView);
                    this.renderer = null;
                    this._options = null; };
                _createClass(Application, [{
                    key: 'ticker',
                    set: function set(ticker) {
                        if (this._ticker) { this._ticker.remove(this.render, this); }
                        this._ticker = ticker;
                        if (ticker) { ticker.add(this.render, this, _const.UPDATE_PRIORITY.LOW); }
                    },
                    get: function get() { return this._ticker; }
                }, { key: 'view', get: function get() { return this.renderer.view; } }, { key: 'screen', get: function get() { return this.renderer.screen; } }]);
                return Application;
            }();
            exports.default = Application;
        }, { "./autoDetectRenderer": 43, "./const": 44, "./display/Container": 46, "./settings": 99, "./ticker": 118 }],
        42: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _pixiGlCore = require('pixi-gl-core');
            var _settings = require('./settings');
            var _settings2 = _interopRequireDefault(_settings);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

            function checkPrecision(src, def) {
                if (src instanceof Array) { if (src[0].substring(0, 9) !== 'precision') { var copy = src.slice(0);
                        copy.unshift('precision ' + def + ' float;'); return copy; } } else if (src.substring(0, 9) !== 'precision') { return 'precision ' + def + ' float;\n' + src; }
                return src;
            }
            var Shader = function(_GLShader) {
                _inherits(Shader, _GLShader);

                function Shader(gl, vertexSrc, fragmentSrc) { _classCallCheck(this, Shader); return _possibleConstructorReturn(this, _GLShader.call(this, gl, checkPrecision(vertexSrc, _settings2.default.PRECISION_VERTEX), checkPrecision(fragmentSrc, _settings2.default.PRECISION_FRAGMENT))); }
                return Shader;
            }(_pixiGlCore.GLShader);
            exports.default = Shader;
        }, { "./settings": 99, "pixi-gl-core": 12 }],
        43: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.autoDetectRenderer = autoDetectRenderer;
            var _utils = require('./utils');
            var utils = _interopRequireWildcard(_utils);
            var _CanvasRenderer = require('./renderers/canvas/CanvasRenderer');
            var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);
            var _WebGLRenderer = require('./renderers/webgl/WebGLRenderer');
            var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function autoDetectRenderer(options, arg1, arg2, arg3) {
                var forceCanvas = options && options.forceCanvas;
                if (arg3 !== undefined) { forceCanvas = arg3; }
                if (!forceCanvas && utils.isWebGLSupported()) { return new _WebGLRenderer2.default(options, arg1, arg2); }
                return new _CanvasRenderer2.default(options, arg1, arg2);
            }
        }, { "./renderers/canvas/CanvasRenderer": 75, "./renderers/webgl/WebGLRenderer": 82, "./utils": 122 }],
        44: [function(require, module, exports) { 'use strict';
            exports.__esModule = true; var VERSION = exports.VERSION = '4.5.1'; var PI_2 = exports.PI_2 = Math.PI * 2; var RAD_TO_DEG = exports.RAD_TO_DEG = 180 / Math.PI; var DEG_TO_RAD = exports.DEG_TO_RAD = Math.PI / 180; var RENDERER_TYPE = exports.RENDERER_TYPE = { UNKNOWN: 0, WEBGL: 1, CANVAS: 2 }; var BLEND_MODES = exports.BLEND_MODES = { NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5, LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12, HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16 }; var DRAW_MODES = exports.DRAW_MODES = { POINTS: 0, LINES: 1, LINE_LOOP: 2, LINE_STRIP: 3, TRIANGLES: 4, TRIANGLE_STRIP: 5, TRIANGLE_FAN: 6 }; var SCALE_MODES = exports.SCALE_MODES = { LINEAR: 0, NEAREST: 1 }; var WRAP_MODES = exports.WRAP_MODES = { CLAMP: 0, REPEAT: 1, MIRRORED_REPEAT: 2 }; var GC_MODES = exports.GC_MODES = { AUTO: 0, MANUAL: 1 }; var URL_FILE_EXTENSION = exports.URL_FILE_EXTENSION = /\.(\w{3,4})(?:$|\?|#)/i; var DATA_URI = exports.DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;(charset=[\w-]+|base64))?,(.*)/i; var SVG_SIZE = exports.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i; var SHAPES = exports.SHAPES = { POLY: 0, RECT: 1, CIRC: 2, ELIP: 3, RREC: 4 }; var PRECISION = exports.PRECISION = { LOW: 'lowp', MEDIUM: 'mediump', HIGH: 'highp' }; var TRANSFORM_MODE = exports.TRANSFORM_MODE = { STATIC: 0, DYNAMIC: 1 }; var TEXT_GRADIENT = exports.TEXT_GRADIENT = { LINEAR_VERTICAL: 0, LINEAR_HORIZONTAL: 1 }; var UPDATE_PRIORITY = exports.UPDATE_PRIORITY = { INTERACTION: 50, HIGH: 25, NORMAL: 0, LOW: -25, UTILITY: -50 }; }, {}],
        45: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _math = require('../math');

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var Bounds = function() {
                function Bounds() { _classCallCheck(this, Bounds);
                    this.minX = Infinity;
                    this.minY = Infinity;
                    this.maxX = -Infinity;
                    this.maxY = -Infinity;
                    this.rect = null; }
                Bounds.prototype.isEmpty = function isEmpty() { return this.minX > this.maxX || this.minY > this.maxY; };
                Bounds.prototype.clear = function clear() { this.updateID++;
                    this.minX = Infinity;
                    this.minY = Infinity;
                    this.maxX = -Infinity;
                    this.maxY = -Infinity; };
                Bounds.prototype.getRectangle = function getRectangle(rect) {
                    if (this.minX > this.maxX || this.minY > this.maxY) { return _math.Rectangle.EMPTY; }
                    rect = rect || new _math.Rectangle(0, 0, 1, 1);
                    rect.x = this.minX;
                    rect.y = this.minY;
                    rect.width = this.maxX - this.minX;
                    rect.height = this.maxY - this.minY;
                    return rect;
                };
                Bounds.prototype.addPoint = function addPoint(point) { this.minX = Math.min(this.minX, point.x);
                    this.maxX = Math.max(this.maxX, point.x);
                    this.minY = Math.min(this.minY, point.y);
                    this.maxY = Math.max(this.maxY, point.y); };
                Bounds.prototype.addQuad = function addQuad(vertices) { var minX = this.minX; var minY = this.minY; var maxX = this.maxX; var maxY = this.maxY; var x = vertices[0]; var y = vertices[1];
                    minX = x < minX ? x : minX;
                    minY = y < minY ? y : minY;
                    maxX = x > maxX ? x : maxX;
                    maxY = y > maxY ? y : maxY;
                    x = vertices[2];
                    y = vertices[3];
                    minX = x < minX ? x : minX;
                    minY = y < minY ? y : minY;
                    maxX = x > maxX ? x : maxX;
                    maxY = y > maxY ? y : maxY;
                    x = vertices[4];
                    y = vertices[5];
                    minX = x < minX ? x : minX;
                    minY = y < minY ? y : minY;
                    maxX = x > maxX ? x : maxX;
                    maxY = y > maxY ? y : maxY;
                    x = vertices[6];
                    y = vertices[7];
                    minX = x < minX ? x : minX;
                    minY = y < minY ? y : minY;
                    maxX = x > maxX ? x : maxX;
                    maxY = y > maxY ? y : maxY;
                    this.minX = minX;
                    this.minY = minY;
                    this.maxX = maxX;
                    this.maxY = maxY; };
                Bounds.prototype.addFrame = function addFrame(transform, x0, y0, x1, y1) { var matrix = transform.worldTransform; var a = matrix.a; var b = matrix.b; var c = matrix.c; var d = matrix.d; var tx = matrix.tx; var ty = matrix.ty; var minX = this.minX; var minY = this.minY; var maxX = this.maxX; var maxY = this.maxY; var x = a * x0 + c * y0 + tx; var y = b * x0 + d * y0 + ty;
                    minX = x < minX ? x : minX;
                    minY = y < minY ? y : minY;
                    maxX = x > maxX ? x : maxX;
                    maxY = y > maxY ? y : maxY;
                    x = a * x1 + c * y0 + tx;
                    y = b * x1 + d * y0 + ty;
                    minX = x < minX ? x : minX;
                    minY = y < minY ? y : minY;
                    maxX = x > maxX ? x : maxX;
                    maxY = y > maxY ? y : maxY;
                    x = a * x0 + c * y1 + tx;
                    y = b * x0 + d * y1 + ty;
                    minX = x < minX ? x : minX;
                    minY = y < minY ? y : minY;
                    maxX = x > maxX ? x : maxX;
                    maxY = y > maxY ? y : maxY;
                    x = a * x1 + c * y1 + tx;
                    y = b * x1 + d * y1 + ty;
                    minX = x < minX ? x : minX;
                    minY = y < minY ? y : minY;
                    maxX = x > maxX ? x : maxX;
                    maxY = y > maxY ? y : maxY;
                    this.minX = minX;
                    this.minY = minY;
                    this.maxX = maxX;
                    this.maxY = maxY; };
                Bounds.prototype.addVertices = function addVertices(transform, vertices, beginOffset, endOffset) {
                    var matrix = transform.worldTransform;
                    var a = matrix.a;
                    var b = matrix.b;
                    var c = matrix.c;
                    var d = matrix.d;
                    var tx = matrix.tx;
                    var ty = matrix.ty;
                    var minX = this.minX;
                    var minY = this.minY;
                    var maxX = this.maxX;
                    var maxY = this.maxY;
                    for (var i = beginOffset; i < endOffset; i += 2) { var rawX = vertices[i]; var rawY = vertices[i + 1]; var x = a * rawX + c * rawY + tx; var y = d * rawY + b * rawX + ty;
                        minX = x < minX ? x : minX;
                        minY = y < minY ? y : minY;
                        maxX = x > maxX ? x : maxX;
                        maxY = y > maxY ? y : maxY; }
                    this.minX = minX;
                    this.minY = minY;
                    this.maxX = maxX;
                    this.maxY = maxY;
                };
                Bounds.prototype.addBounds = function addBounds(bounds) { var minX = this.minX; var minY = this.minY; var maxX = this.maxX; var maxY = this.maxY;
                    this.minX = bounds.minX < minX ? bounds.minX : minX;
                    this.minY = bounds.minY < minY ? bounds.minY : minY;
                    this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
                    this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY; };
                Bounds.prototype.addBoundsMask = function addBoundsMask(bounds, mask) { var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX; var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY; var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX; var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY; if (_minX <= _maxX && _minY <= _maxY) { var minX = this.minX; var minY = this.minY; var maxX = this.maxX; var maxY = this.maxY;
                        this.minX = _minX < minX ? _minX : minX;
                        this.minY = _minY < minY ? _minY : minY;
                        this.maxX = _maxX > maxX ? _maxX : maxX;
                        this.maxY = _maxY > maxY ? _maxY : maxY; } };
                Bounds.prototype.addBoundsArea = function addBoundsArea(bounds, area) { var _minX = bounds.minX > area.x ? bounds.minX : area.x; var _minY = bounds.minY > area.y ? bounds.minY : area.y; var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : area.x + area.width; var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : area.y + area.height; if (_minX <= _maxX && _minY <= _maxY) { var minX = this.minX; var minY = this.minY; var maxX = this.maxX; var maxY = this.maxY;
                        this.minX = _minX < minX ? _minX : minX;
                        this.minY = _minY < minY ? _minY : minY;
                        this.maxX = _maxX > maxX ? _maxX : maxX;
                        this.maxY = _maxY > maxY ? _maxY : maxY; } };
                return Bounds;
            }();
            exports.default = Bounds;
        }, { "../math": 68 }],
        46: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _utils = require('../utils');
            var _DisplayObject2 = require('./DisplayObject');
            var _DisplayObject3 = _interopRequireDefault(_DisplayObject2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var Container = function(_DisplayObject) {
                _inherits(Container, _DisplayObject);

                function Container() { _classCallCheck(this, Container); var _this = _possibleConstructorReturn(this, _DisplayObject.call(this));
                    _this.children = []; return _this; }
                Container.prototype.onChildrenChange = function onChildrenChange() {};
                Container.prototype.addChild = function addChild(child) {
                    var argumentsLength = arguments.length;
                    if (argumentsLength > 1) { for (var i = 0; i < argumentsLength; i++) { this.addChild(arguments[i]); } } else {
                        if (child.parent) { child.parent.removeChild(child); }
                        child.parent = this;
                        child.transform._parentID = -1;
                        this.children.push(child);
                        this._boundsID++;
                        this.onChildrenChange(this.children.length - 1);
                        child.emit('added', this);
                    }
                    return child;
                };
                Container.prototype.addChildAt = function addChildAt(child, index) {
                    if (index < 0 || index > this.children.length) { throw new Error(child + 'addChildAt: The index ' + index + ' supplied is out of bounds ' + this.children.length); }
                    if (child.parent) { child.parent.removeChild(child); }
                    child.parent = this;
                    child.transform._parentID = -1;
                    this.children.splice(index, 0, child);
                    this._boundsID++;
                    this.onChildrenChange(index);
                    child.emit('added', this);
                    return child;
                };
                Container.prototype.swapChildren = function swapChildren(child, child2) {
                    if (child === child2) { return; }
                    var index1 = this.getChildIndex(child);
                    var index2 = this.getChildIndex(child2);
                    this.children[index1] = child2;
                    this.children[index2] = child;
                    this.onChildrenChange(index1 < index2 ? index1 : index2);
                };
                Container.prototype.getChildIndex = function getChildIndex(child) {
                    var index = this.children.indexOf(child);
                    if (index === -1) { throw new Error('The supplied DisplayObject must be a child of the caller'); }
                    return index;
                };
                Container.prototype.setChildIndex = function setChildIndex(child, index) {
                    if (index < 0 || index >= this.children.length) { throw new Error('The supplied index is out of bounds'); }
                    var currentIndex = this.getChildIndex(child);
                    (0, _utils.removeItems)(this.children, currentIndex, 1);
                    this.children.splice(index, 0, child);
                    this.onChildrenChange(index);
                };
                Container.prototype.getChildAt = function getChildAt(index) {
                    if (index < 0 || index >= this.children.length) { throw new Error('getChildAt: Index (' + index + ') does not exist.'); }
                    return this.children[index];
                };
                Container.prototype.removeChild = function removeChild(child) {
                    var argumentsLength = arguments.length;
                    if (argumentsLength > 1) { for (var i = 0; i < argumentsLength; i++) { this.removeChild(arguments[i]); } } else { var index = this.children.indexOf(child); if (index === -1) return null;
                        child.parent = null;
                        child.transform._parentID = -1;
                        (0, _utils.removeItems)(this.children, index, 1);
                        this._boundsID++;
                        this.onChildrenChange(index);
                        child.emit('removed', this); }
                    return child;
                };
                Container.prototype.removeChildAt = function removeChildAt(index) { var child = this.getChildAt(index);
                    child.parent = null;
                    child.transform._parentID = -1;
                    (0, _utils.removeItems)(this.children, index, 1);
                    this._boundsID++;
                    this.onChildrenChange(index);
                    child.emit('removed', this); return child; };
                Container.prototype.removeChildren = function removeChildren() {
                    var beginIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                    var endIndex = arguments[1];
                    var begin = beginIndex;
                    var end = typeof endIndex === 'number' ? endIndex : this.children.length;
                    var range = end - begin;
                    var removed = void 0;
                    if (range > 0 && range <= end) {
                        removed = this.children.splice(begin, range);
                        for (var i = 0; i < removed.length; ++i) { removed[i].parent = null; if (removed[i].transform) { removed[i].transform._parentID = -1; } }
                        this._boundsID++;
                        this.onChildrenChange(beginIndex);
                        for (var _i = 0; _i < removed.length; ++_i) { removed[_i].emit('removed', this); }
                        return removed;
                    } else if (range === 0 && this.children.length === 0) { return []; }
                    throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
                };
                Container.prototype.updateTransform = function updateTransform() { this._boundsID++;
                    this.transform.updateTransform(this.parent.transform);
                    this.worldAlpha = this.alpha * this.parent.worldAlpha; for (var i = 0, j = this.children.length; i < j; ++i) { var child = this.children[i]; if (child.visible) { child.updateTransform(); } } };
                Container.prototype.calculateBounds = function calculateBounds() {
                    this._bounds.clear();
                    this._calculateBounds();
                    for (var i = 0; i < this.children.length; i++) {
                        var child = this.children[i];
                        if (!child.visible || !child.renderable) { continue; }
                        child.calculateBounds();
                        if (child._mask) { child._mask.calculateBounds();
                            this._bounds.addBoundsMask(child._bounds, child._mask._bounds); } else if (child.filterArea) { this._bounds.addBoundsArea(child._bounds, child.filterArea); } else { this._bounds.addBounds(child._bounds); }
                    }
                    this._lastBoundsID = this._boundsID;
                };
                Container.prototype._calculateBounds = function _calculateBounds() {};
                Container.prototype.renderWebGL = function renderWebGL(renderer) {
                    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) { return; }
                    if (this._mask || this._filters) { this.renderAdvancedWebGL(renderer); } else { this._renderWebGL(renderer); for (var i = 0, j = this.children.length; i < j; ++i) { this.children[i].renderWebGL(renderer); } }
                };
                Container.prototype.renderAdvancedWebGL = function renderAdvancedWebGL(renderer) {
                    renderer.flush();
                    var filters = this._filters;
                    var mask = this._mask;
                    if (filters) {
                        if (!this._enabledFilters) { this._enabledFilters = []; }
                        this._enabledFilters.length = 0;
                        for (var i = 0; i < filters.length; i++) { if (filters[i].enabled) { this._enabledFilters.push(filters[i]); } }
                        if (this._enabledFilters.length) { renderer.filterManager.pushFilter(this, this._enabledFilters); }
                    }
                    if (mask) { renderer.maskManager.pushMask(this, this._mask); }
                    this._renderWebGL(renderer);
                    for (var _i2 = 0, j = this.children.length; _i2 < j; _i2++) { this.children[_i2].renderWebGL(renderer); }
                    renderer.flush();
                    if (mask) { renderer.maskManager.popMask(this, this._mask); }
                    if (filters && this._enabledFilters && this._enabledFilters.length) { renderer.filterManager.popFilter(); }
                };
                Container.prototype._renderWebGL = function _renderWebGL(renderer) {};
                Container.prototype._renderCanvas = function _renderCanvas(renderer) {};
                Container.prototype.renderCanvas = function renderCanvas(renderer) {
                    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) { return; }
                    if (this._mask) { renderer.maskManager.pushMask(this._mask); }
                    this._renderCanvas(renderer);
                    for (var i = 0, j = this.children.length; i < j; ++i) { this.children[i].renderCanvas(renderer); }
                    if (this._mask) { renderer.maskManager.popMask(renderer); }
                };
                Container.prototype.destroy = function destroy(options) { _DisplayObject.prototype.destroy.call(this); var destroyChildren = typeof options === 'boolean' ? options : options && options.children; var oldChildren = this.removeChildren(0, this.children.length); if (destroyChildren) { for (var i = 0; i < oldChildren.length; ++i) { oldChildren[i].destroy(options); } } };
                _createClass(Container, [{
                    key: 'width',
                    get: function get() { return this.scale.x * this.getLocalBounds().width; },
                    set: function set(value) {
                        var width = this.getLocalBounds().width;
                        if (width !== 0) { this.scale.x = value / width; } else { this.scale.x = 1; }
                        this._width = value;
                    }
                }, {
                    key: 'height',
                    get: function get() { return this.scale.y * this.getLocalBounds().height; },
                    set: function set(value) {
                        var height = this.getLocalBounds().height;
                        if (height !== 0) { this.scale.y = value / height; } else { this.scale.y = 1; }
                        this._height = value;
                    }
                }]);
                return Container;
            }(_DisplayObject3.default);
            exports.default = Container;
            Container.prototype.containerUpdateTransform = Container.prototype.updateTransform;
        }, { "../utils": 122, "./DisplayObject": 47 }],
        47: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _eventemitter = require('eventemitter3');
            var _eventemitter2 = _interopRequireDefault(_eventemitter);
            var _const = require('../const');
            var _settings = require('../settings');
            var _settings2 = _interopRequireDefault(_settings);
            var _TransformStatic = require('./TransformStatic');
            var _TransformStatic2 = _interopRequireDefault(_TransformStatic);
            var _Transform = require('./Transform');
            var _Transform2 = _interopRequireDefault(_Transform);
            var _Bounds = require('./Bounds');
            var _Bounds2 = _interopRequireDefault(_Bounds);
            var _math = require('../math');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var DisplayObject = function(_EventEmitter) {
                _inherits(DisplayObject, _EventEmitter);

                function DisplayObject() { _classCallCheck(this, DisplayObject); var _this = _possibleConstructorReturn(this, _EventEmitter.call(this)); var TransformClass = _settings2.default.TRANSFORM_MODE === _const.TRANSFORM_MODE.STATIC ? _TransformStatic2.default : _Transform2.default;
                    _this.tempDisplayObjectParent = null;
                    _this.transform = new TransformClass();
                    _this.alpha = 1;
                    _this.visible = true;
                    _this.renderable = true;
                    _this.parent = null;
                    _this.worldAlpha = 1;
                    _this.filterArea = null;
                    _this._filters = null;
                    _this._enabledFilters = null;
                    _this._bounds = new _Bounds2.default();
                    _this._boundsID = 0;
                    _this._lastBoundsID = -1;
                    _this._boundsRect = null;
                    _this._localBoundsRect = null;
                    _this._mask = null;
                    _this._destroyed = false; return _this; }
                DisplayObject.prototype.updateTransform = function updateTransform() { this.transform.updateTransform(this.parent.transform);
                    this.worldAlpha = this.alpha * this.parent.worldAlpha;
                    this._bounds.updateID++; };
                DisplayObject.prototype._recursivePostUpdateTransform = function _recursivePostUpdateTransform() { if (this.parent) { this.parent._recursivePostUpdateTransform();
                        this.transform.updateTransform(this.parent.transform); } else { this.transform.updateTransform(this._tempDisplayObjectParent.transform); } };
                DisplayObject.prototype.getBounds = function getBounds(skipUpdate, rect) {
                    if (!skipUpdate) { if (!this.parent) { this.parent = this._tempDisplayObjectParent;
                            this.updateTransform();
                            this.parent = null; } else { this._recursivePostUpdateTransform();
                            this.updateTransform(); } }
                    if (this._boundsID !== this._lastBoundsID) { this.calculateBounds(); }
                    if (!rect) {
                        if (!this._boundsRect) { this._boundsRect = new _math.Rectangle(); }
                        rect = this._boundsRect;
                    }
                    return this._bounds.getRectangle(rect);
                };
                DisplayObject.prototype.getLocalBounds = function getLocalBounds(rect) {
                    var transformRef = this.transform;
                    var parentRef = this.parent;
                    this.parent = null;
                    this.transform = this._tempDisplayObjectParent.transform;
                    if (!rect) {
                        if (!this._localBoundsRect) { this._localBoundsRect = new _math.Rectangle(); }
                        rect = this._localBoundsRect;
                    }
                    var bounds = this.getBounds(false, rect);
                    this.parent = parentRef;
                    this.transform = transformRef;
                    return bounds;
                };
                DisplayObject.prototype.toGlobal = function toGlobal(position, point) {
                    var skipUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                    if (!skipUpdate) { this._recursivePostUpdateTransform(); if (!this.parent) { this.parent = this._tempDisplayObjectParent;
                            this.displayObjectUpdateTransform();
                            this.parent = null; } else { this.displayObjectUpdateTransform(); } }
                    return this.worldTransform.apply(position, point);
                };
                DisplayObject.prototype.toLocal = function toLocal(position, from, point, skipUpdate) {
                    if (from) { position = from.toGlobal(position, point, skipUpdate); }
                    if (!skipUpdate) { this._recursivePostUpdateTransform(); if (!this.parent) { this.parent = this._tempDisplayObjectParent;
                            this.displayObjectUpdateTransform();
                            this.parent = null; } else { this.displayObjectUpdateTransform(); } }
                    return this.worldTransform.applyInverse(position, point);
                };
                DisplayObject.prototype.renderWebGL = function renderWebGL(renderer) {};
                DisplayObject.prototype.renderCanvas = function renderCanvas(renderer) {};
                DisplayObject.prototype.setParent = function setParent(container) {
                    if (!container || !container.addChild) { throw new Error('setParent: Argument must be a Container'); }
                    container.addChild(this);
                    return container;
                };
                DisplayObject.prototype.setTransform = function setTransform() { var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0; var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; var scaleX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1; var scaleY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1; var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0; var skewX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0; var skewY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0; var pivotX = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0; var pivotY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
                    this.position.x = x;
                    this.position.y = y;
                    this.scale.x = !scaleX ? 1 : scaleX;
                    this.scale.y = !scaleY ? 1 : scaleY;
                    this.rotation = rotation;
                    this.skew.x = skewX;
                    this.skew.y = skewY;
                    this.pivot.x = pivotX;
                    this.pivot.y = pivotY; return this; };
                DisplayObject.prototype.destroy = function destroy() {
                    this.removeAllListeners();
                    if (this.parent) { this.parent.removeChild(this); }
                    this.transform = null;
                    this.parent = null;
                    this._bounds = null;
                    this._currentBounds = null;
                    this._mask = null;
                    this.filterArea = null;
                    this.interactive = false;
                    this.interactiveChildren = false;
                    this._destroyed = true;
                };
                _createClass(DisplayObject, [{
                    key: '_tempDisplayObjectParent',
                    get: function get() {
                        if (this.tempDisplayObjectParent === null) { this.tempDisplayObjectParent = new DisplayObject(); }
                        return this.tempDisplayObjectParent;
                    }
                }, {
                    key: 'x',
                    get: function get() { return this.position.x; },
                    set: function set(value) { this.transform.position.x = value; }
                }, {
                    key: 'y',
                    get: function get() { return this.position.y; },
                    set: function set(value) { this.transform.position.y = value; }
                }, { key: 'worldTransform', get: function get() { return this.transform.worldTransform; } }, { key: 'localTransform', get: function get() { return this.transform.localTransform; } }, {
                    key: 'position',
                    get: function get() { return this.transform.position; },
                    set: function set(value) { this.transform.position.copy(value); }
                }, {
                    key: 'scale',
                    get: function get() { return this.transform.scale; },
                    set: function set(value) { this.transform.scale.copy(value); }
                }, {
                    key: 'pivot',
                    get: function get() { return this.transform.pivot; },
                    set: function set(value) { this.transform.pivot.copy(value); }
                }, {
                    key: 'skew',
                    get: function get() { return this.transform.skew; },
                    set: function set(value) { this.transform.skew.copy(value); }
                }, {
                    key: 'rotation',
                    get: function get() { return this.transform.rotation; },
                    set: function set(value) { this.transform.rotation = value; }
                }, {
                    key: 'worldVisible',
                    get: function get() {
                        var item = this;
                        do {
                            if (!item.visible) { return false; }
                            item = item.parent;
                        } while (item);
                        return true;
                    }
                }, {
                    key: 'mask',
                    get: function get() { return this._mask; },
                    set: function set(value) {
                        if (this._mask) { this._mask.renderable = true; }
                        this._mask = value;
                        if (this._mask) { this._mask.renderable = false; }
                    }
                }, {
                    key: 'filters',
                    get: function get() { return this._filters && this._filters.slice(); },
                    set: function set(value) { this._filters = value && value.slice(); }
                }]);
                return DisplayObject;
            }(_eventemitter2.default);
            exports.default = DisplayObject;
            DisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;
        }, { "../const": 44, "../math": 68, "../settings": 99, "./Bounds": 45, "./Transform": 48, "./TransformStatic": 50, "eventemitter3": 3 }],
        48: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _math = require('../math');
            var _TransformBase2 = require('./TransformBase');
            var _TransformBase3 = _interopRequireDefault(_TransformBase2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var Transform = function(_TransformBase) {
                _inherits(Transform, _TransformBase);

                function Transform() { _classCallCheck(this, Transform); var _this = _possibleConstructorReturn(this, _TransformBase.call(this));
                    _this.position = new _math.Point(0, 0);
                    _this.scale = new _math.Point(1, 1);
                    _this.skew = new _math.ObservablePoint(_this.updateSkew, _this, 0, 0);
                    _this.pivot = new _math.Point(0, 0);
                    _this._rotation = 0;
                    _this._cx = 1;
                    _this._sx = 0;
                    _this._cy = 0;
                    _this._sy = 1; return _this; }
                Transform.prototype.updateSkew = function updateSkew() { this._cx = Math.cos(this._rotation + this.skew._y);
                    this._sx = Math.sin(this._rotation + this.skew._y);
                    this._cy = -Math.sin(this._rotation - this.skew._x);
                    this._sy = Math.cos(this._rotation - this.skew._x); };
                Transform.prototype.updateLocalTransform = function updateLocalTransform() { var lt = this.localTransform;
                    lt.a = this._cx * this.scale.x;
                    lt.b = this._sx * this.scale.x;
                    lt.c = this._cy * this.scale.y;
                    lt.d = this._sy * this.scale.y;
                    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
                    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d); };
                Transform.prototype.updateTransform = function updateTransform(parentTransform) { var lt = this.localTransform;
                    lt.a = this._cx * this.scale.x;
                    lt.b = this._sx * this.scale.x;
                    lt.c = this._cy * this.scale.y;
                    lt.d = this._sy * this.scale.y;
                    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);
                    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d); var pt = parentTransform.worldTransform; var wt = this.worldTransform;
                    wt.a = lt.a * pt.a + lt.b * pt.c;
                    wt.b = lt.a * pt.b + lt.b * pt.d;
                    wt.c = lt.c * pt.a + lt.d * pt.c;
                    wt.d = lt.c * pt.b + lt.d * pt.d;
                    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
                    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
                    this._worldID++; };
                Transform.prototype.setFromMatrix = function setFromMatrix(matrix) { matrix.decompose(this); };
                _createClass(Transform, [{
                    key: 'rotation',
                    get: function get() { return this._rotation; },
                    set: function set(value) { this._rotation = value;
                        this.updateSkew(); }
                }]);
                return Transform;
            }(_TransformBase3.default);
            exports.default = Transform;
        }, { "../math": 68, "./TransformBase": 49 }],
        49: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _math = require('../math');

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var TransformBase = function() {
                function TransformBase() { _classCallCheck(this, TransformBase);
                    this.worldTransform = new _math.Matrix();
                    this.localTransform = new _math.Matrix();
                    this._worldID = 0;
                    this._parentID = 0; }
                TransformBase.prototype.updateLocalTransform = function updateLocalTransform() {};
                TransformBase.prototype.updateTransform = function updateTransform(parentTransform) { var pt = parentTransform.worldTransform; var wt = this.worldTransform; var lt = this.localTransform;
                    wt.a = lt.a * pt.a + lt.b * pt.c;
                    wt.b = lt.a * pt.b + lt.b * pt.d;
                    wt.c = lt.c * pt.a + lt.d * pt.c;
                    wt.d = lt.c * pt.b + lt.d * pt.d;
                    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
                    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
                    this._worldID++; };
                return TransformBase;
            }();
            exports.default = TransformBase;
            TransformBase.prototype.updateWorldTransform = TransformBase.prototype.updateTransform;
            TransformBase.IDENTITY = new TransformBase();
        }, { "../math": 68 }],
        50: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _math = require('../math');
            var _TransformBase2 = require('./TransformBase');
            var _TransformBase3 = _interopRequireDefault(_TransformBase2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var TransformStatic = function(_TransformBase) {
                _inherits(TransformStatic, _TransformBase);

                function TransformStatic() { _classCallCheck(this, TransformStatic); var _this = _possibleConstructorReturn(this, _TransformBase.call(this));
                    _this.position = new _math.ObservablePoint(_this.onChange, _this, 0, 0);
                    _this.scale = new _math.ObservablePoint(_this.onChange, _this, 1, 1);
                    _this.pivot = new _math.ObservablePoint(_this.onChange, _this, 0, 0);
                    _this.skew = new _math.ObservablePoint(_this.updateSkew, _this, 0, 0);
                    _this._rotation = 0;
                    _this._cx = 1;
                    _this._sx = 0;
                    _this._cy = 0;
                    _this._sy = 1;
                    _this._localID = 0;
                    _this._currentLocalID = 0; return _this; }
                TransformStatic.prototype.onChange = function onChange() { this._localID++; };
                TransformStatic.prototype.updateSkew = function updateSkew() { this._cx = Math.cos(this._rotation + this.skew._y);
                    this._sx = Math.sin(this._rotation + this.skew._y);
                    this._cy = -Math.sin(this._rotation - this.skew._x);
                    this._sy = Math.cos(this._rotation - this.skew._x);
                    this._localID++; };
                TransformStatic.prototype.updateLocalTransform = function updateLocalTransform() { var lt = this.localTransform; if (this._localID !== this._currentLocalID) { lt.a = this._cx * this.scale._x;
                        lt.b = this._sx * this.scale._x;
                        lt.c = this._cy * this.scale._y;
                        lt.d = this._sy * this.scale._y;
                        lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);
                        lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);
                        this._currentLocalID = this._localID;
                        this._parentID = -1; } };
                TransformStatic.prototype.updateTransform = function updateTransform(parentTransform) {
                    var lt = this.localTransform;
                    if (this._localID !== this._currentLocalID) { lt.a = this._cx * this.scale._x;
                        lt.b = this._sx * this.scale._x;
                        lt.c = this._cy * this.scale._y;
                        lt.d = this._sy * this.scale._y;
                        lt.tx = this.position._x - (this.pivot._x * lt.a + this.pivot._y * lt.c);
                        lt.ty = this.position._y - (this.pivot._x * lt.b + this.pivot._y * lt.d);
                        this._currentLocalID = this._localID;
                        this._parentID = -1; }
                    if (this._parentID !== parentTransform._worldID) { var pt = parentTransform.worldTransform; var wt = this.worldTransform;
                        wt.a = lt.a * pt.a + lt.b * pt.c;
                        wt.b = lt.a * pt.b + lt.b * pt.d;
                        wt.c = lt.c * pt.a + lt.d * pt.c;
                        wt.d = lt.c * pt.b + lt.d * pt.d;
                        wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;
                        wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;
                        this._parentID = parentTransform._worldID;
                        this._worldID++; }
                };
                TransformStatic.prototype.setFromMatrix = function setFromMatrix(matrix) { matrix.decompose(this);
                    this._localID++; };
                _createClass(TransformStatic, [{
                    key: 'rotation',
                    get: function get() { return this._rotation; },
                    set: function set(value) { this._rotation = value;
                        this.updateSkew(); }
                }]);
                return TransformStatic;
            }(_TransformBase3.default);
            exports.default = TransformStatic;
        }, { "../math": 68, "./TransformBase": 49 }],
        51: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _Container2 = require('../display/Container');
            var _Container3 = _interopRequireDefault(_Container2);
            var _RenderTexture = require('../textures/RenderTexture');
            var _RenderTexture2 = _interopRequireDefault(_RenderTexture);
            var _Texture = require('../textures/Texture');
            var _Texture2 = _interopRequireDefault(_Texture);
            var _GraphicsData = require('./GraphicsData');
            var _GraphicsData2 = _interopRequireDefault(_GraphicsData);
            var _Sprite = require('../sprites/Sprite');
            var _Sprite2 = _interopRequireDefault(_Sprite);
            var _math = require('../math');
            var _utils = require('../utils');
            var _const = require('../const');
            var _Bounds = require('../display/Bounds');
            var _Bounds2 = _interopRequireDefault(_Bounds);
            var _bezierCurveTo2 = require('./utils/bezierCurveTo');
            var _bezierCurveTo3 = _interopRequireDefault(_bezierCurveTo2);
            var _CanvasRenderer = require('../renderers/canvas/CanvasRenderer');
            var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var canvasRenderer = void 0;
            var tempMatrix = new _math.Matrix();
            var tempPoint = new _math.Point();
            var tempColor1 = new Float32Array(4);
            var tempColor2 = new Float32Array(4);
            var Graphics = function(_Container) {
                _inherits(Graphics, _Container);

                function Graphics() { var nativeLines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                    _classCallCheck(this, Graphics); var _this = _possibleConstructorReturn(this, _Container.call(this));
                    _this.fillAlpha = 1;
                    _this.lineWidth = 0;
                    _this.nativeLines = nativeLines;
                    _this.lineColor = 0;
                    _this.graphicsData = [];
                    _this.tint = 0xFFFFFF;
                    _this._prevTint = 0xFFFFFF;
                    _this.blendMode = _const.BLEND_MODES.NORMAL;
                    _this.currentPath = null;
                    _this._webGL = {};
                    _this.isMask = false;
                    _this.boundsPadding = 0;
                    _this._localBounds = new _Bounds2.default();
                    _this.dirty = 0;
                    _this.fastRectDirty = -1;
                    _this.clearDirty = 0;
                    _this.boundsDirty = -1;
                    _this.cachedSpriteDirty = false;
                    _this._spriteRect = null;
                    _this._fastRect = false; return _this; }
                Graphics.prototype.clone = function clone() {
                    var clone = new Graphics();
                    clone.renderable = this.renderable;
                    clone.fillAlpha = this.fillAlpha;
                    clone.lineWidth = this.lineWidth;
                    clone.lineColor = this.lineColor;
                    clone.tint = this.tint;
                    clone.blendMode = this.blendMode;
                    clone.isMask = this.isMask;
                    clone.boundsPadding = this.boundsPadding;
                    clone.dirty = 0;
                    clone.cachedSpriteDirty = this.cachedSpriteDirty;
                    for (var i = 0; i < this.graphicsData.length; ++i) { clone.graphicsData.push(this.graphicsData[i].clone()); }
                    clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];
                    clone.updateLocalBounds();
                    return clone;
                };
                Graphics.prototype.lineStyle = function lineStyle() {
                    var lineWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                    var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    var alpha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
                    this.lineWidth = lineWidth;
                    this.lineColor = color;
                    this.lineAlpha = alpha;
                    if (this.currentPath) { if (this.currentPath.shape.points.length) { var shape = new _math.Polygon(this.currentPath.shape.points.slice(-2));
                            shape.closed = false;
                            this.drawShape(shape); } else { this.currentPath.lineWidth = this.lineWidth;
                            this.currentPath.lineColor = this.lineColor;
                            this.currentPath.lineAlpha = this.lineAlpha; } }
                    return this;
                };
                Graphics.prototype.moveTo = function moveTo(x, y) { var shape = new _math.Polygon([x, y]);
                    shape.closed = false;
                    this.drawShape(shape); return this; };
                Graphics.prototype.lineTo = function lineTo(x, y) { this.currentPath.shape.points.push(x, y);
                    this.dirty++; return this; };
                Graphics.prototype.quadraticCurveTo = function quadraticCurveTo(cpX, cpY, toX, toY) {
                    if (this.currentPath) { if (this.currentPath.shape.points.length === 0) { this.currentPath.shape.points = [0, 0]; } } else { this.moveTo(0, 0); }
                    var n = 20;
                    var points = this.currentPath.shape.points;
                    var xa = 0;
                    var ya = 0;
                    if (points.length === 0) { this.moveTo(0, 0); }
                    var fromX = points[points.length - 2];
                    var fromY = points[points.length - 1];
                    for (var i = 1; i <= n; ++i) { var j = i / n;
                        xa = fromX + (cpX - fromX) * j;
                        ya = fromY + (cpY - fromY) * j;
                        points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j); }
                    this.dirty++;
                    return this;
                };
                Graphics.prototype.bezierCurveTo = function bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
                    if (this.currentPath) { if (this.currentPath.shape.points.length === 0) { this.currentPath.shape.points = [0, 0]; } } else { this.moveTo(0, 0); }
                    var points = this.currentPath.shape.points;
                    var fromX = points[points.length - 2];
                    var fromY = points[points.length - 1];
                    points.length -= 2;
                    (0, _bezierCurveTo3.default)(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, points);
                    this.dirty++;
                    return this;
                };
                Graphics.prototype.arcTo = function arcTo(x1, y1, x2, y2, radius) {
                    if (this.currentPath) { if (this.currentPath.shape.points.length === 0) { this.currentPath.shape.points.push(x1, y1); } } else { this.moveTo(x1, y1); }
                    var points = this.currentPath.shape.points;
                    var fromX = points[points.length - 2];
                    var fromY = points[points.length - 1];
                    var a1 = fromY - y1;
                    var b1 = fromX - x1;
                    var a2 = y2 - y1;
                    var b2 = x2 - x1;
                    var mm = Math.abs(a1 * b2 - b1 * a2);
                    if (mm < 1.0e-8 || radius === 0) { if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) { points.push(x1, y1); } } else { var dd = a1 * a1 + b1 * b1; var cc = a2 * a2 + b2 * b2; var tt = a1 * a2 + b1 * b2; var k1 = radius * Math.sqrt(dd) / mm; var k2 = radius * Math.sqrt(cc) / mm; var j1 = k1 * tt / dd; var j2 = k2 * tt / cc; var cx = k1 * b2 + k2 * b1; var cy = k1 * a2 + k2 * a1; var px = b1 * (k2 + j1); var py = a1 * (k2 + j1); var qx = b2 * (k1 + j2); var qy = a2 * (k1 + j2); var startAngle = Math.atan2(py - cy, px - cx); var endAngle = Math.atan2(qy - cy, qx - cx);
                        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1); }
                    this.dirty++;
                    return this;
                };
                Graphics.prototype.arc = function arc(cx, cy, radius, startAngle, endAngle) {
                    var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
                    if (startAngle === endAngle) { return this; }
                    if (!anticlockwise && endAngle <= startAngle) { endAngle += Math.PI * 2; } else if (anticlockwise && startAngle <= endAngle) { startAngle += Math.PI * 2; }
                    var sweep = endAngle - startAngle;
                    var segs = Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;
                    if (sweep === 0) { return this; }
                    var startX = cx + Math.cos(startAngle) * radius;
                    var startY = cy + Math.sin(startAngle) * radius;
                    var points = this.currentPath ? this.currentPath.shape.points : null;
                    if (points) { if (points[points.length - 2] !== startX || points[points.length - 1] !== startY) { points.push(startX, startY); } } else { this.moveTo(startX, startY);
                        points = this.currentPath.shape.points; }
                    var theta = sweep / (segs * 2);
                    var theta2 = theta * 2;
                    var cTheta = Math.cos(theta);
                    var sTheta = Math.sin(theta);
                    var segMinus = segs - 1;
                    var remainder = segMinus % 1 / segMinus;
                    for (var i = 0; i <= segMinus; ++i) { var real = i + remainder * i; var angle = theta + startAngle + theta2 * real; var c = Math.cos(angle); var s = -Math.sin(angle);
                        points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy); }
                    this.dirty++;
                    return this;
                };
                Graphics.prototype.beginFill = function beginFill() {
                    var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                    var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                    this.filling = true;
                    this.fillColor = color;
                    this.fillAlpha = alpha;
                    if (this.currentPath) { if (this.currentPath.shape.points.length <= 2) { this.currentPath.fill = this.filling;
                            this.currentPath.fillColor = this.fillColor;
                            this.currentPath.fillAlpha = this.fillAlpha; } }
                    return this;
                };
                Graphics.prototype.endFill = function endFill() { this.filling = false;
                    this.fillColor = null;
                    this.fillAlpha = 1; return this; };
                Graphics.prototype.drawRect = function drawRect(x, y, width, height) { this.drawShape(new _math.Rectangle(x, y, width, height)); return this; };
                Graphics.prototype.drawRoundedRect = function drawRoundedRect(x, y, width, height, radius) { this.drawShape(new _math.RoundedRectangle(x, y, width, height, radius)); return this; };
                Graphics.prototype.drawCircle = function drawCircle(x, y, radius) { this.drawShape(new _math.Circle(x, y, radius)); return this; };
                Graphics.prototype.drawEllipse = function drawEllipse(x, y, width, height) { this.drawShape(new _math.Ellipse(x, y, width, height)); return this; };
                Graphics.prototype.drawPolygon = function drawPolygon(path) {
                    var points = path;
                    var closed = true;
                    if (points instanceof _math.Polygon) { closed = points.closed;
                        points = points.points; }
                    if (!Array.isArray(points)) { points = new Array(arguments.length); for (var i = 0; i < points.length; ++i) { points[i] = arguments[i]; } }
                    var shape = new _math.Polygon(points);
                    shape.closed = closed;
                    this.drawShape(shape);
                    return this;
                };
                Graphics.prototype.clear = function clear() {
                    if (this.lineWidth || this.filling || this.graphicsData.length > 0) { this.lineWidth = 0;
                        this.filling = false;
                        this.boundsDirty = -1;
                        this.dirty++;
                        this.clearDirty++;
                        this.graphicsData.length = 0; }
                    this.currentPath = null;
                    this._spriteRect = null;
                    return this;
                };
                Graphics.prototype.isFastRect = function isFastRect() { return this.graphicsData.length === 1 && this.graphicsData[0].shape.type === _const.SHAPES.RECT && !this.graphicsData[0].lineWidth; };
                Graphics.prototype._renderWebGL = function _renderWebGL(renderer) {
                    if (this.dirty !== this.fastRectDirty) { this.fastRectDirty = this.dirty;
                        this._fastRect = this.isFastRect(); }
                    if (this._fastRect) { this._renderSpriteRect(renderer); } else { renderer.setObjectRenderer(renderer.plugins.graphics);
                        renderer.plugins.graphics.render(this); }
                };
                Graphics.prototype._renderSpriteRect = function _renderSpriteRect(renderer) {
                    var rect = this.graphicsData[0].shape;
                    if (!this._spriteRect) { this._spriteRect = new _Sprite2.default(new _Texture2.default(_Texture2.default.WHITE)); }
                    var sprite = this._spriteRect;
                    if (this.tint === 0xffffff) { sprite.tint = this.graphicsData[0].fillColor; } else { var t1 = tempColor1; var t2 = tempColor2;
                        (0, _utils.hex2rgb)(this.graphicsData[0].fillColor, t1);
                        (0, _utils.hex2rgb)(this.tint, t2);
                        t1[0] *= t2[0];
                        t1[1] *= t2[1];
                        t1[2] *= t2[2];
                        sprite.tint = (0, _utils.rgb2hex)(t1); }
                    sprite.alpha = this.graphicsData[0].fillAlpha;
                    sprite.worldAlpha = this.worldAlpha * sprite.alpha;
                    sprite.blendMode = this.blendMode;
                    sprite._texture._frame.width = rect.width;
                    sprite._texture._frame.height = rect.height;
                    sprite.transform.worldTransform = this.transform.worldTransform;
                    sprite.anchor.set(-rect.x / rect.width, -rect.y / rect.height);
                    sprite._onAnchorUpdate();
                    sprite._renderWebGL(renderer);
                };
                Graphics.prototype._renderCanvas = function _renderCanvas(renderer) {
                    if (this.isMask === true) { return; }
                    renderer.plugins.graphics.render(this);
                };
                Graphics.prototype._calculateBounds = function _calculateBounds() {
                    if (this.boundsDirty !== this.dirty) { this.boundsDirty = this.dirty;
                        this.updateLocalBounds();
                        this.cachedSpriteDirty = true; }
                    var lb = this._localBounds;
                    this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);
                };
                Graphics.prototype.containsPoint = function containsPoint(point) {
                    this.worldTransform.applyInverse(point, tempPoint);
                    var graphicsData = this.graphicsData;
                    for (var i = 0; i < graphicsData.length; ++i) {
                        var data = graphicsData[i];
                        if (!data.fill) { continue; }
                        if (data.shape) { if (data.shape.contains(tempPoint.x, tempPoint.y)) { return true; } }
                    }
                    return false;
                };
                Graphics.prototype.updateLocalBounds = function updateLocalBounds() {
                    var minX = Infinity;
                    var maxX = -Infinity;
                    var minY = Infinity;
                    var maxY = -Infinity;
                    if (this.graphicsData.length) {
                        var shape = 0;
                        var x = 0;
                        var y = 0;
                        var w = 0;
                        var h = 0;
                        for (var i = 0; i < this.graphicsData.length; i++) {
                            var data = this.graphicsData[i];
                            var type = data.type;
                            var lineWidth = data.lineWidth;
                            shape = data.shape;
                            if (type === _const.SHAPES.RECT || type === _const.SHAPES.RREC) { x = shape.x - lineWidth / 2;
                                y = shape.y - lineWidth / 2;
                                w = shape.width + lineWidth;
                                h = shape.height + lineWidth;
                                minX = x < minX ? x : minX;
                                maxX = x + w > maxX ? x + w : maxX;
                                minY = y < minY ? y : minY;
                                maxY = y + h > maxY ? y + h : maxY; } else if (type === _const.SHAPES.CIRC) { x = shape.x;
                                y = shape.y;
                                w = shape.radius + lineWidth / 2;
                                h = shape.radius + lineWidth / 2;
                                minX = x - w < minX ? x - w : minX;
                                maxX = x + w > maxX ? x + w : maxX;
                                minY = y - h < minY ? y - h : minY;
                                maxY = y + h > maxY ? y + h : maxY; } else if (type === _const.SHAPES.ELIP) { x = shape.x;
                                y = shape.y;
                                w = shape.width + lineWidth / 2;
                                h = shape.height + lineWidth / 2;
                                minX = x - w < minX ? x - w : minX;
                                maxX = x + w > maxX ? x + w : maxX;
                                minY = y - h < minY ? y - h : minY;
                                maxY = y + h > maxY ? y + h : maxY; } else {
                                var points = shape.points;
                                var x2 = 0;
                                var y2 = 0;
                                var dx = 0;
                                var dy = 0;
                                var rw = 0;
                                var rh = 0;
                                var cx = 0;
                                var cy = 0;
                                for (var j = 0; j + 2 < points.length; j += 2) {
                                    x = points[j];
                                    y = points[j + 1];
                                    x2 = points[j + 2];
                                    y2 = points[j + 3];
                                    dx = Math.abs(x2 - x);
                                    dy = Math.abs(y2 - y);
                                    h = lineWidth;
                                    w = Math.sqrt(dx * dx + dy * dy);
                                    if (w < 1e-9) { continue; }
                                    rw = (h / w * dy + dx) / 2;
                                    rh = (h / w * dx + dy) / 2;
                                    cx = (x2 + x) / 2;
                                    cy = (y2 + y) / 2;
                                    minX = cx - rw < minX ? cx - rw : minX;
                                    maxX = cx + rw > maxX ? cx + rw : maxX;
                                    minY = cy - rh < minY ? cy - rh : minY;
                                    maxY = cy + rh > maxY ? cy + rh : maxY;
                                }
                            }
                        }
                    } else { minX = 0;
                        maxX = 0;
                        minY = 0;
                        maxY = 0; }
                    var padding = this.boundsPadding;
                    this._localBounds.minX = minX - padding;
                    this._localBounds.maxX = maxX + padding * 2;
                    this._localBounds.minY = minY - padding;
                    this._localBounds.maxY = maxY + padding * 2;
                };
                Graphics.prototype.drawShape = function drawShape(shape) {
                    if (this.currentPath) { if (this.currentPath.shape.points.length <= 2) { this.graphicsData.pop(); } }
                    this.currentPath = null;
                    var data = new _GraphicsData2.default(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, this.nativeLines, shape);
                    this.graphicsData.push(data);
                    if (data.type === _const.SHAPES.POLY) { data.shape.closed = data.shape.closed || this.filling;
                        this.currentPath = data; }
                    this.dirty++;
                    return data;
                };
                Graphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode) {
                    var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                    var bounds = this.getLocalBounds();
                    var canvasBuffer = _RenderTexture2.default.create(bounds.width, bounds.height, scaleMode, resolution);
                    if (!canvasRenderer) { canvasRenderer = new _CanvasRenderer2.default(); }
                    this.transform.updateLocalTransform();
                    this.transform.localTransform.copy(tempMatrix);
                    tempMatrix.invert();
                    tempMatrix.tx -= bounds.x;
                    tempMatrix.ty -= bounds.y;
                    canvasRenderer.render(this, canvasBuffer, true, tempMatrix);
                    var texture = _Texture2.default.fromCanvas(canvasBuffer.baseTexture._canvasRenderTarget.canvas, scaleMode, 'graphics');
                    texture.baseTexture.resolution = resolution;
                    texture.baseTexture.update();
                    return texture;
                };
                Graphics.prototype.closePath = function closePath() {
                    var currentPath = this.currentPath;
                    if (currentPath && currentPath.shape) { currentPath.shape.close(); }
                    return this;
                };
                Graphics.prototype.addHole = function addHole() { var hole = this.graphicsData.pop();
                    this.currentPath = this.graphicsData[this.graphicsData.length - 1];
                    this.currentPath.addHole(hole.shape);
                    this.currentPath = null; return this; };
                Graphics.prototype.destroy = function destroy(options) {
                    _Container.prototype.destroy.call(this, options);
                    for (var i = 0; i < this.graphicsData.length; ++i) { this.graphicsData[i].destroy(); }
                    for (var id in this._webgl) { for (var j = 0; j < this._webgl[id].data.length; ++j) { this._webgl[id].data[j].destroy(); } }
                    if (this._spriteRect) { this._spriteRect.destroy(); }
                    this.graphicsData = null;
                    this.currentPath = null;
                    this._webgl = null;
                    this._localBounds = null;
                };
                return Graphics;
            }(_Container3.default);
            exports.default = Graphics;
            Graphics._SPRITE_TEXTURE = null;
        }, { "../const": 44, "../display/Bounds": 45, "../display/Container": 46, "../math": 68, "../renderers/canvas/CanvasRenderer": 75, "../sprites/Sprite": 100, "../textures/RenderTexture": 111, "../textures/Texture": 113, "../utils": 122, "./GraphicsData": 52, "./utils/bezierCurveTo": 54 }],
        52: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var GraphicsData = function() {
                function GraphicsData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, nativeLines, shape) { _classCallCheck(this, GraphicsData);
                    this.lineWidth = lineWidth;
                    this.nativeLines = nativeLines;
                    this.lineColor = lineColor;
                    this.lineAlpha = lineAlpha;
                    this._lineTint = lineColor;
                    this.fillColor = fillColor;
                    this.fillAlpha = fillAlpha;
                    this._fillTint = fillColor;
                    this.fill = fill;
                    this.holes = [];
                    this.shape = shape;
                    this.type = shape.type; }
                GraphicsData.prototype.clone = function clone() { return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.nativeLines, this.shape); };
                GraphicsData.prototype.addHole = function addHole(shape) { this.holes.push(shape); };
                GraphicsData.prototype.destroy = function destroy() { this.shape = null;
                    this.holes = null; };
                return GraphicsData;
            }();
            exports.default = GraphicsData;
        }, {}],
        53: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _CanvasRenderer = require('../../renderers/canvas/CanvasRenderer');
            var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);
            var _const = require('../../const');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var CanvasGraphicsRenderer = function() {
                function CanvasGraphicsRenderer(renderer) { _classCallCheck(this, CanvasGraphicsRenderer);
                    this.renderer = renderer; }
                CanvasGraphicsRenderer.prototype.render = function render(graphics) {
                    var renderer = this.renderer;
                    var context = renderer.context;
                    var worldAlpha = graphics.worldAlpha;
                    var transform = graphics.transform.worldTransform;
                    var resolution = renderer.resolution;
                    if (this._prevTint !== this.tint) { this.dirty = true; }
                    context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);
                    if (graphics.dirty) { this.updateGraphicsTint(graphics);
                        graphics.dirty = false; }
                    renderer.setBlendMode(graphics.blendMode);
                    for (var i = 0; i < graphics.graphicsData.length; i++) {
                        var data = graphics.graphicsData[i];
                        var shape = data.shape;
                        var fillColor = data._fillTint;
                        var lineColor = data._lineTint;
                        context.lineWidth = data.lineWidth;
                        if (data.type === _const.SHAPES.POLY) {
                            context.beginPath();
                            this.renderPolygon(shape.points, shape.closed, context);
                            for (var j = 0; j < data.holes.length; j++) { this.renderPolygon(data.holes[j].points, true, context); }
                            if (data.fill) { context.globalAlpha = data.fillAlpha * worldAlpha;
                                context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                                context.fill(); }
                            if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha;
                                context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                                context.stroke(); }
                        } else if (data.type === _const.SHAPES.RECT) {
                            if (data.fillColor || data.fillColor === 0) { context.globalAlpha = data.fillAlpha * worldAlpha;
                                context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                                context.fillRect(shape.x, shape.y, shape.width, shape.height); }
                            if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha;
                                context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                                context.strokeRect(shape.x, shape.y, shape.width, shape.height); }
                        } else if (data.type === _const.SHAPES.CIRC) {
                            context.beginPath();
                            context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                            context.closePath();
                            if (data.fill) { context.globalAlpha = data.fillAlpha * worldAlpha;
                                context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                                context.fill(); }
                            if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha;
                                context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                                context.stroke(); }
                        } else if (data.type === _const.SHAPES.ELIP) {
                            var w = shape.width * 2;
                            var h = shape.height * 2;
                            var x = shape.x - w / 2;
                            var y = shape.y - h / 2;
                            context.beginPath();
                            var kappa = 0.5522848;
                            var ox = w / 2 * kappa;
                            var oy = h / 2 * kappa;
                            var xe = x + w;
                            var ye = y + h;
                            var xm = x + w / 2;
                            var ym = y + h / 2;
                            context.moveTo(x, ym);
                            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                            context.closePath();
                            if (data.fill) { context.globalAlpha = data.fillAlpha * worldAlpha;
                                context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                                context.fill(); }
                            if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha;
                                context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                                context.stroke(); }
                        } else if (data.type === _const.SHAPES.RREC) {
                            var rx = shape.x;
                            var ry = shape.y;
                            var width = shape.width;
                            var height = shape.height;
                            var radius = shape.radius;
                            var maxRadius = Math.min(width, height) / 2 | 0;
                            radius = radius > maxRadius ? maxRadius : radius;
                            context.beginPath();
                            context.moveTo(rx, ry + radius);
                            context.lineTo(rx, ry + height - radius);
                            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                            context.lineTo(rx + width - radius, ry + height);
                            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                            context.lineTo(rx + width, ry + radius);
                            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                            context.lineTo(rx + radius, ry);
                            context.quadraticCurveTo(rx, ry, rx, ry + radius);
                            context.closePath();
                            if (data.fillColor || data.fillColor === 0) { context.globalAlpha = data.fillAlpha * worldAlpha;
                                context.fillStyle = '#' + ('00000' + (fillColor | 0).toString(16)).substr(-6);
                                context.fill(); }
                            if (data.lineWidth) { context.globalAlpha = data.lineAlpha * worldAlpha;
                                context.strokeStyle = '#' + ('00000' + (lineColor | 0).toString(16)).substr(-6);
                                context.stroke(); }
                        }
                    }
                };
                CanvasGraphicsRenderer.prototype.updateGraphicsTint = function updateGraphicsTint(graphics) { graphics._prevTint = graphics.tint; var tintR = (graphics.tint >> 16 & 0xFF) / 255; var tintG = (graphics.tint >> 8 & 0xFF) / 255; var tintB = (graphics.tint & 0xFF) / 255; for (var i = 0; i < graphics.graphicsData.length; ++i) { var data = graphics.graphicsData[i]; var fillColor = data.fillColor | 0; var lineColor = data.lineColor | 0;
                        data._fillTint = ((fillColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((fillColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (fillColor & 0xFF) / 255 * tintB * 255;
                        data._lineTint = ((lineColor >> 16 & 0xFF) / 255 * tintR * 255 << 16) + ((lineColor >> 8 & 0xFF) / 255 * tintG * 255 << 8) + (lineColor & 0xFF) / 255 * tintB * 255; } };
                CanvasGraphicsRenderer.prototype.renderPolygon = function renderPolygon(points, close, context) {
                    context.moveTo(points[0], points[1]);
                    for (var j = 1; j < points.length / 2; ++j) { context.lineTo(points[j * 2], points[j * 2 + 1]); }
                    if (close) { context.closePath(); }
                };
                CanvasGraphicsRenderer.prototype.destroy = function destroy() { this.renderer = null; };
                return CanvasGraphicsRenderer;
            }();
            exports.default = CanvasGraphicsRenderer;
            _CanvasRenderer2.default.registerPlugin('graphics', CanvasGraphicsRenderer);
        }, { "../../const": 44, "../../renderers/canvas/CanvasRenderer": 75 }],
        54: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;
            exports.default = bezierCurveTo;

            function bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
                var path = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : [];
                var n = 20;
                var dt = 0;
                var dt2 = 0;
                var dt3 = 0;
                var t2 = 0;
                var t3 = 0;
                path.push(fromX, fromY);
                for (var i = 1, j = 0; i <= n; ++i) { j = i / n;
                    dt = 1 - j;
                    dt2 = dt * dt;
                    dt3 = dt2 * dt;
                    t2 = j * j;
                    t3 = t2 * j;
                    path.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY); }
                return path;
            }
        }, {}],
        55: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _utils = require('../../utils');
            var _const = require('../../const');
            var _ObjectRenderer2 = require('../../renderers/webgl/utils/ObjectRenderer');
            var _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);
            var _WebGLRenderer = require('../../renderers/webgl/WebGLRenderer');
            var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);
            var _WebGLGraphicsData = require('./WebGLGraphicsData');
            var _WebGLGraphicsData2 = _interopRequireDefault(_WebGLGraphicsData);
            var _PrimitiveShader = require('./shaders/PrimitiveShader');
            var _PrimitiveShader2 = _interopRequireDefault(_PrimitiveShader);
            var _buildPoly = require('./utils/buildPoly');
            var _buildPoly2 = _interopRequireDefault(_buildPoly);
            var _buildRectangle = require('./utils/buildRectangle');
            var _buildRectangle2 = _interopRequireDefault(_buildRectangle);
            var _buildRoundedRectangle = require('./utils/buildRoundedRectangle');
            var _buildRoundedRectangle2 = _interopRequireDefault(_buildRoundedRectangle);
            var _buildCircle = require('./utils/buildCircle');
            var _buildCircle2 = _interopRequireDefault(_buildCircle);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var GraphicsRenderer = function(_ObjectRenderer) {
                _inherits(GraphicsRenderer, _ObjectRenderer);

                function GraphicsRenderer(renderer) { _classCallCheck(this, GraphicsRenderer); var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));
                    _this.graphicsDataPool = [];
                    _this.primitiveShader = null;
                    _this.gl = renderer.gl;
                    _this.CONTEXT_UID = 0; return _this; }
                GraphicsRenderer.prototype.onContextChange = function onContextChange() { this.gl = this.renderer.gl;
                    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
                    this.primitiveShader = new _PrimitiveShader2.default(this.gl); };
                GraphicsRenderer.prototype.destroy = function destroy() {
                    _ObjectRenderer3.default.prototype.destroy.call(this);
                    for (var i = 0; i < this.graphicsDataPool.length; ++i) { this.graphicsDataPool[i].destroy(); }
                    this.graphicsDataPool = null;
                };
                GraphicsRenderer.prototype.render = function render(graphics) {
                    var renderer = this.renderer;
                    var gl = renderer.gl;
                    var webGLData = void 0;
                    var webGL = graphics._webGL[this.CONTEXT_UID];
                    if (!webGL || graphics.dirty !== webGL.dirty) { this.updateGraphics(graphics);
                        webGL = graphics._webGL[this.CONTEXT_UID]; }
                    var shader = this.primitiveShader;
                    renderer.bindShader(shader);
                    renderer.state.setBlendMode(graphics.blendMode);
                    for (var i = 0, n = webGL.data.length; i < n; i++) { webGLData = webGL.data[i]; var shaderTemp = webGLData.shader;
                        renderer.bindShader(shaderTemp);
                        shaderTemp.uniforms.translationMatrix = graphics.transform.worldTransform.toArray(true);
                        shaderTemp.uniforms.tint = (0, _utils.hex2rgb)(graphics.tint);
                        shaderTemp.uniforms.alpha = graphics.worldAlpha;
                        renderer.bindVao(webGLData.vao); if (webGLData.nativeLines) { gl.drawArrays(gl.LINES, 0, webGLData.points.length / 6); } else { webGLData.vao.draw(gl.TRIANGLE_STRIP, webGLData.indices.length); } }
                };
                GraphicsRenderer.prototype.updateGraphics = function updateGraphics(graphics) {
                    var gl = this.renderer.gl;
                    var webGL = graphics._webGL[this.CONTEXT_UID];
                    if (!webGL) { webGL = graphics._webGL[this.CONTEXT_UID] = { lastIndex: 0, data: [], gl: gl, clearDirty: -1, dirty: -1 }; }
                    webGL.dirty = graphics.dirty;
                    if (graphics.clearDirty !== webGL.clearDirty) {
                        webGL.clearDirty = graphics.clearDirty;
                        for (var i = 0; i < webGL.data.length; i++) { this.graphicsDataPool.push(webGL.data[i]); }
                        webGL.data.length = 0;
                        webGL.lastIndex = 0;
                    }
                    var webGLData = void 0;
                    var webGLDataNativeLines = void 0;
                    for (var _i = webGL.lastIndex; _i < graphics.graphicsData.length; _i++) {
                        var data = graphics.graphicsData[_i];
                        webGLData = this.getWebGLData(webGL, 0);
                        if (data.nativeLines && data.lineWidth) { webGLDataNativeLines = this.getWebGLData(webGL, 0, true);
                            webGL.lastIndex++; }
                        if (data.type === _const.SHAPES.POLY) {
                            (0, _buildPoly2.default)(data, webGLData, webGLDataNativeLines); }
                        if (data.type === _const.SHAPES.RECT) {
                            (0, _buildRectangle2.default)(data, webGLData, webGLDataNativeLines); } else if (data.type === _const.SHAPES.CIRC || data.type === _const.SHAPES.ELIP) {
                            (0, _buildCircle2.default)(data, webGLData, webGLDataNativeLines); } else if (data.type === _const.SHAPES.RREC) {
                            (0, _buildRoundedRectangle2.default)(data, webGLData, webGLDataNativeLines); }
                        webGL.lastIndex++;
                    }
                    this.renderer.bindVao(null);
                    for (var _i2 = 0; _i2 < webGL.data.length; _i2++) { webGLData = webGL.data[_i2]; if (webGLData.dirty) { webGLData.upload(); } }
                };
                GraphicsRenderer.prototype.getWebGLData = function getWebGLData(gl, type, nativeLines) {
                    var webGLData = gl.data[gl.data.length - 1];
                    if (!webGLData || webGLData.nativeLines !== nativeLines || webGLData.points.length > 320000) { webGLData = this.graphicsDataPool.pop() || new _WebGLGraphicsData2.default(this.renderer.gl, this.primitiveShader, this.renderer.state.attribsState);
                        webGLData.nativeLines = nativeLines;
                        webGLData.reset(type);
                        gl.data.push(webGLData); }
                    webGLData.dirty = true;
                    return webGLData;
                };
                return GraphicsRenderer;
            }(_ObjectRenderer3.default);
            exports.default = GraphicsRenderer;
            _WebGLRenderer2.default.registerPlugin('graphics', GraphicsRenderer);
        }, { "../../const": 44, "../../renderers/webgl/WebGLRenderer": 82, "../../renderers/webgl/utils/ObjectRenderer": 92, "../../utils": 122, "./WebGLGraphicsData": 56, "./shaders/PrimitiveShader": 57, "./utils/buildCircle": 58, "./utils/buildPoly": 60, "./utils/buildRectangle": 61, "./utils/buildRoundedRectangle": 62 }],
        56: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _pixiGlCore = require('pixi-gl-core');
            var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var WebGLGraphicsData = function() {
                function WebGLGraphicsData(gl, shader, attribsState) { _classCallCheck(this, WebGLGraphicsData);
                    this.gl = gl;
                    this.color = [0, 0, 0];
                    this.points = [];
                    this.indices = [];
                    this.buffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl);
                    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl);
                    this.dirty = true;
                    this.nativeLines = false;
                    this.glPoints = null;
                    this.glIndices = null;
                    this.shader = shader;
                    this.vao = new _pixiGlCore2.default.VertexArrayObject(gl, attribsState).addIndex(this.indexBuffer).addAttribute(this.buffer, shader.attributes.aVertexPosition, gl.FLOAT, false, 4 * 6, 0).addAttribute(this.buffer, shader.attributes.aColor, gl.FLOAT, false, 4 * 6, 2 * 4); }
                WebGLGraphicsData.prototype.reset = function reset() { this.points.length = 0;
                    this.indices.length = 0; };
                WebGLGraphicsData.prototype.upload = function upload() { this.glPoints = new Float32Array(this.points);
                    this.buffer.upload(this.glPoints);
                    this.glIndices = new Uint16Array(this.indices);
                    this.indexBuffer.upload(this.glIndices);
                    this.dirty = false; };
                WebGLGraphicsData.prototype.destroy = function destroy() { this.color = null;
                    this.points = null;
                    this.indices = null;
                    this.vao.destroy();
                    this.buffer.destroy();
                    this.indexBuffer.destroy();
                    this.gl = null;
                    this.buffer = null;
                    this.indexBuffer = null;
                    this.glPoints = null;
                    this.glIndices = null; };
                return WebGLGraphicsData;
            }();
            exports.default = WebGLGraphicsData;
        }, { "pixi-gl-core": 12 }],
        57: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _Shader2 = require('../../../Shader');
            var _Shader3 = _interopRequireDefault(_Shader2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var PrimitiveShader = function(_Shader) {
                _inherits(PrimitiveShader, _Shader);

                function PrimitiveShader(gl) { _classCallCheck(this, PrimitiveShader); return _possibleConstructorReturn(this, _Shader.call(this, gl, ['attribute vec2 aVertexPosition;', 'attribute vec4 aColor;', 'uniform mat3 translationMatrix;', 'uniform mat3 projectionMatrix;', 'uniform float alpha;', 'uniform vec3 tint;', 'varying vec4 vColor;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vColor = aColor * vec4(tint * alpha, alpha);', '}'].join('\n'), ['varying vec4 vColor;', 'void main(void){', '   gl_FragColor = vColor;', '}'].join('\n'))); }
                return PrimitiveShader;
            }(_Shader3.default);
            exports.default = PrimitiveShader;
        }, { "../../../Shader": 42 }],
        58: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = buildCircle;
            var _buildLine = require('./buildLine');
            var _buildLine2 = _interopRequireDefault(_buildLine);
            var _const = require('../../../const');
            var _utils = require('../../../utils');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function buildCircle(graphicsData, webGLData, webGLDataNativeLines) {
                var circleData = graphicsData.shape;
                var x = circleData.x;
                var y = circleData.y;
                var width = void 0;
                var height = void 0;
                if (graphicsData.type === _const.SHAPES.CIRC) { width = circleData.radius;
                    height = circleData.radius; } else { width = circleData.width;
                    height = circleData.height; }
                if (width === 0 || height === 0) { return; }
                var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));
                var seg = Math.PI * 2 / totalSegs;
                if (graphicsData.fill) {
                    var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
                    var alpha = graphicsData.fillAlpha;
                    var r = color[0] * alpha;
                    var g = color[1] * alpha;
                    var b = color[2] * alpha;
                    var verts = webGLData.points;
                    var indices = webGLData.indices;
                    var vecPos = verts.length / 6;
                    indices.push(vecPos);
                    for (var i = 0; i < totalSegs + 1; i++) { verts.push(x, y, r, g, b, alpha);
                        verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);
                        indices.push(vecPos++, vecPos++); }
                    indices.push(vecPos - 1);
                }
                if (graphicsData.lineWidth) {
                    var tempPoints = graphicsData.points;
                    graphicsData.points = [];
                    for (var _i = 0; _i < totalSegs + 1; _i++) { graphicsData.points.push(x + Math.sin(seg * _i) * width, y + Math.cos(seg * _i) * height); }
                    (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);
                    graphicsData.points = tempPoints;
                }
            }
        }, { "../../../const": 44, "../../../utils": 122, "./buildLine": 59 }],
        59: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = function(graphicsData, webGLData, webGLDataNativeLines) { if (graphicsData.nativeLines) { buildNativeLine(graphicsData, webGLDataNativeLines); } else { buildLine(graphicsData, webGLData); } };
            var _math = require('../../../math');
            var _utils = require('../../../utils');

            function buildLine(graphicsData, webGLData) {
                var points = graphicsData.points;
                if (points.length === 0) { return; }
                var firstPoint = new _math.Point(points[0], points[1]);
                var lastPoint = new _math.Point(points[points.length - 2], points[points.length - 1]);
                if (firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y) { points = points.slice();
                    points.pop();
                    points.pop();
                    lastPoint = new _math.Point(points[points.length - 2], points[points.length - 1]); var midPointX = lastPoint.x + (firstPoint.x - lastPoint.x) * 0.5; var midPointY = lastPoint.y + (firstPoint.y - lastPoint.y) * 0.5;
                    points.unshift(midPointX, midPointY);
                    points.push(midPointX, midPointY); }
                var verts = webGLData.points;
                var indices = webGLData.indices;
                var length = points.length / 2;
                var indexCount = points.length;
                var indexStart = verts.length / 6;
                var width = graphicsData.lineWidth / 2;
                var color = (0, _utils.hex2rgb)(graphicsData.lineColor);
                var alpha = graphicsData.lineAlpha;
                var r = color[0] * alpha;
                var g = color[1] * alpha;
                var b = color[2] * alpha;
                var p1x = points[0];
                var p1y = points[1];
                var p2x = points[2];
                var p2y = points[3];
                var p3x = 0;
                var p3y = 0;
                var perpx = -(p1y - p2y);
                var perpy = p1x - p2x;
                var perp2x = 0;
                var perp2y = 0;
                var perp3x = 0;
                var perp3y = 0;
                var dist = Math.sqrt(perpx * perpx + perpy * perpy);
                perpx /= dist;
                perpy /= dist;
                perpx *= width;
                perpy *= width;
                verts.push(p1x - perpx, p1y - perpy, r, g, b, alpha);
                verts.push(p1x + perpx, p1y + perpy, r, g, b, alpha);
                for (var i = 1; i < length - 1; ++i) {
                    p1x = points[(i - 1) * 2];
                    p1y = points[(i - 1) * 2 + 1];
                    p2x = points[i * 2];
                    p2y = points[i * 2 + 1];
                    p3x = points[(i + 1) * 2];
                    p3y = points[(i + 1) * 2 + 1];
                    perpx = -(p1y - p2y);
                    perpy = p1x - p2x;
                    dist = Math.sqrt(perpx * perpx + perpy * perpy);
                    perpx /= dist;
                    perpy /= dist;
                    perpx *= width;
                    perpy *= width;
                    perp2x = -(p2y - p3y);
                    perp2y = p2x - p3x;
                    dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
                    perp2x /= dist;
                    perp2y /= dist;
                    perp2x *= width;
                    perp2y *= width;
                    var a1 = -perpy + p1y - (-perpy + p2y);
                    var b1 = -perpx + p2x - (-perpx + p1x);
                    var c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
                    var a2 = -perp2y + p3y - (-perp2y + p2y);
                    var b2 = -perp2x + p2x - (-perp2x + p3x);
                    var c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
                    var denom = a1 * b2 - a2 * b1;
                    if (Math.abs(denom) < 0.1) { denom += 10.1;
                        verts.push(p2x - perpx, p2y - perpy, r, g, b, alpha);
                        verts.push(p2x + perpx, p2y + perpy, r, g, b, alpha); continue; }
                    var px = (b1 * c2 - b2 * c1) / denom;
                    var py = (a2 * c1 - a1 * c2) / denom;
                    var pdist = (px - p2x) * (px - p2x) + (py - p2y) * (py - p2y);
                    if (pdist > 196 * width * width) { perp3x = perpx - perp2x;
                        perp3y = perpy - perp2y;
                        dist = Math.sqrt(perp3x * perp3x + perp3y * perp3y);
                        perp3x /= dist;
                        perp3y /= dist;
                        perp3x *= width;
                        perp3y *= width;
                        verts.push(p2x - perp3x, p2y - perp3y);
                        verts.push(r, g, b, alpha);
                        verts.push(p2x + perp3x, p2y + perp3y);
                        verts.push(r, g, b, alpha);
                        verts.push(p2x - perp3x, p2y - perp3y);
                        verts.push(r, g, b, alpha);
                        indexCount++; } else { verts.push(px, py);
                        verts.push(r, g, b, alpha);
                        verts.push(p2x - (px - p2x), p2y - (py - p2y));
                        verts.push(r, g, b, alpha); }
                }
                p1x = points[(length - 2) * 2];
                p1y = points[(length - 2) * 2 + 1];
                p2x = points[(length - 1) * 2];
                p2y = points[(length - 1) * 2 + 1];
                perpx = -(p1y - p2y);
                perpy = p1x - p2x;
                dist = Math.sqrt(perpx * perpx + perpy * perpy);
                perpx /= dist;
                perpy /= dist;
                perpx *= width;
                perpy *= width;
                verts.push(p2x - perpx, p2y - perpy);
                verts.push(r, g, b, alpha);
                verts.push(p2x + perpx, p2y + perpy);
                verts.push(r, g, b, alpha);
                indices.push(indexStart);
                for (var _i = 0; _i < indexCount; ++_i) { indices.push(indexStart++); }
                indices.push(indexStart - 1);
            }

            function buildNativeLine(graphicsData, webGLData) { var i = 0; var points = graphicsData.points; if (points.length === 0) return; var verts = webGLData.points; var length = points.length / 2; var color = (0, _utils.hex2rgb)(graphicsData.lineColor); var alpha = graphicsData.lineAlpha; var r = color[0] * alpha; var g = color[1] * alpha; var b = color[2] * alpha; for (i = 1; i < length; i++) { var p1x = points[(i - 1) * 2]; var p1y = points[(i - 1) * 2 + 1]; var p2x = points[i * 2]; var p2y = points[i * 2 + 1];
                    verts.push(p1x, p1y);
                    verts.push(r, g, b, alpha);
                    verts.push(p2x, p2y);
                    verts.push(r, g, b, alpha); } }
        }, { "../../../math": 68, "../../../utils": 122 }],
        60: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = buildPoly;
            var _buildLine = require('./buildLine');
            var _buildLine2 = _interopRequireDefault(_buildLine);
            var _utils = require('../../../utils');
            var _earcut = require('earcut');
            var _earcut2 = _interopRequireDefault(_earcut);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function buildPoly(graphicsData, webGLData, webGLDataNativeLines) {
                graphicsData.points = graphicsData.shape.points.slice();
                var points = graphicsData.points;
                if (graphicsData.fill && points.length >= 6) {
                    var holeArray = [];
                    var holes = graphicsData.holes;
                    for (var i = 0; i < holes.length; i++) { var hole = holes[i];
                        holeArray.push(points.length / 2);
                        points = points.concat(hole.points); }
                    var verts = webGLData.points;
                    var indices = webGLData.indices;
                    var length = points.length / 2;
                    var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
                    var alpha = graphicsData.fillAlpha;
                    var r = color[0] * alpha;
                    var g = color[1] * alpha;
                    var b = color[2] * alpha;
                    var triangles = (0, _earcut2.default)(points, holeArray, 2);
                    if (!triangles) { return; }
                    var vertPos = verts.length / 6;
                    for (var _i = 0; _i < triangles.length; _i += 3) { indices.push(triangles[_i] + vertPos);
                        indices.push(triangles[_i] + vertPos);
                        indices.push(triangles[_i + 1] + vertPos);
                        indices.push(triangles[_i + 2] + vertPos);
                        indices.push(triangles[_i + 2] + vertPos); }
                    for (var _i2 = 0; _i2 < length; _i2++) { verts.push(points[_i2 * 2], points[_i2 * 2 + 1], r, g, b, alpha); }
                }
                if (graphicsData.lineWidth > 0) {
                    (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines); }
            }
        }, { "../../../utils": 122, "./buildLine": 59, "earcut": 2 }],
        61: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = buildRectangle;
            var _buildLine = require('./buildLine');
            var _buildLine2 = _interopRequireDefault(_buildLine);
            var _utils = require('../../../utils');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function buildRectangle(graphicsData, webGLData, webGLDataNativeLines) {
                var rectData = graphicsData.shape;
                var x = rectData.x;
                var y = rectData.y;
                var width = rectData.width;
                var height = rectData.height;
                if (graphicsData.fill) { var color = (0, _utils.hex2rgb)(graphicsData.fillColor); var alpha = graphicsData.fillAlpha; var r = color[0] * alpha; var g = color[1] * alpha; var b = color[2] * alpha; var verts = webGLData.points; var indices = webGLData.indices; var vertPos = verts.length / 6;
                    verts.push(x, y);
                    verts.push(r, g, b, alpha);
                    verts.push(x + width, y);
                    verts.push(r, g, b, alpha);
                    verts.push(x, y + height);
                    verts.push(r, g, b, alpha);
                    verts.push(x + width, y + height);
                    verts.push(r, g, b, alpha);
                    indices.push(vertPos, vertPos, vertPos + 1, vertPos + 2, vertPos + 3, vertPos + 3); }
                if (graphicsData.lineWidth) { var tempPoints = graphicsData.points;
                    graphicsData.points = [x, y, x + width, y, x + width, y + height, x, y + height, x, y];
                    (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);
                    graphicsData.points = tempPoints; }
            }
        }, { "../../../utils": 122, "./buildLine": 59 }],
        62: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = buildRoundedRectangle;
            var _earcut = require('earcut');
            var _earcut2 = _interopRequireDefault(_earcut);
            var _buildLine = require('./buildLine');
            var _buildLine2 = _interopRequireDefault(_buildLine);
            var _utils = require('../../../utils');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function buildRoundedRectangle(graphicsData, webGLData, webGLDataNativeLines) {
                var rrectData = graphicsData.shape;
                var x = rrectData.x;
                var y = rrectData.y;
                var width = rrectData.width;
                var height = rrectData.height;
                var radius = rrectData.radius;
                var recPoints = [];
                recPoints.push(x, y + radius);
                quadraticBezierCurve(x, y + height - radius, x, y + height, x + radius, y + height, recPoints);
                quadraticBezierCurve(x + width - radius, y + height, x + width, y + height, x + width, y + height - radius, recPoints);
                quadraticBezierCurve(x + width, y + radius, x + width, y, x + width - radius, y, recPoints);
                quadraticBezierCurve(x + radius, y, x, y, x, y + radius + 0.0000000001, recPoints);
                if (graphicsData.fill) {
                    var color = (0, _utils.hex2rgb)(graphicsData.fillColor);
                    var alpha = graphicsData.fillAlpha;
                    var r = color[0] * alpha;
                    var g = color[1] * alpha;
                    var b = color[2] * alpha;
                    var verts = webGLData.points;
                    var indices = webGLData.indices;
                    var vecPos = verts.length / 6;
                    var triangles = (0, _earcut2.default)(recPoints, null, 2);
                    for (var i = 0, j = triangles.length; i < j; i += 3) { indices.push(triangles[i] + vecPos);
                        indices.push(triangles[i] + vecPos);
                        indices.push(triangles[i + 1] + vecPos);
                        indices.push(triangles[i + 2] + vecPos);
                        indices.push(triangles[i + 2] + vecPos); }
                    for (var _i = 0, _j = recPoints.length; _i < _j; _i++) { verts.push(recPoints[_i], recPoints[++_i], r, g, b, alpha); }
                }
                if (graphicsData.lineWidth) { var tempPoints = graphicsData.points;
                    graphicsData.points = recPoints;
                    (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);
                    graphicsData.points = tempPoints; }
            }

            function getPt(n1, n2, perc) { var diff = n2 - n1; return n1 + diff * perc; }

            function quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY) {
                var out = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];
                var n = 20;
                var points = out;
                var xa = 0;
                var ya = 0;
                var xb = 0;
                var yb = 0;
                var x = 0;
                var y = 0;
                for (var i = 0, j = 0; i <= n; ++i) { j = i / n;
                    xa = getPt(fromX, cpX, j);
                    ya = getPt(fromY, cpY, j);
                    xb = getPt(cpX, toX, j);
                    yb = getPt(cpY, toY, j);
                    x = getPt(xa, xb, j);
                    y = getPt(ya, yb, j);
                    points.push(x, y); }
                return points;
            }
        }, { "../../../utils": 122, "./buildLine": 59, "earcut": 2 }],
        63: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.autoDetectRenderer = exports.Application = exports.Filter = exports.SpriteMaskFilter = exports.Quad = exports.RenderTarget = exports.ObjectRenderer = exports.WebGLManager = exports.Shader = exports.CanvasRenderTarget = exports.TextureUvs = exports.VideoBaseTexture = exports.BaseRenderTexture = exports.RenderTexture = exports.BaseTexture = exports.Texture = exports.Spritesheet = exports.CanvasGraphicsRenderer = exports.GraphicsRenderer = exports.GraphicsData = exports.Graphics = exports.TextMetrics = exports.TextStyle = exports.Text = exports.SpriteRenderer = exports.CanvasTinter = exports.CanvasSpriteRenderer = exports.Sprite = exports.TransformBase = exports.TransformStatic = exports.Transform = exports.Container = exports.DisplayObject = exports.Bounds = exports.glCore = exports.WebGLRenderer = exports.CanvasRenderer = exports.ticker = exports.utils = exports.settings = undefined;
            var _const = require('./const');
            Object.keys(_const).forEach(function(key) { if (key === "default" || key === "__esModule") return;
                Object.defineProperty(exports, key, { enumerable: true, get: function get() { return _const[key]; } }); });
            var _math = require('./math');
            Object.keys(_math).forEach(function(key) { if (key === "default" || key === "__esModule") return;
                Object.defineProperty(exports, key, { enumerable: true, get: function get() { return _math[key]; } }); });
            var _pixiGlCore = require('pixi-gl-core');
            Object.defineProperty(exports, 'glCore', { enumerable: true, get: function get() { return _interopRequireDefault(_pixiGlCore).default; } });
            var _Bounds = require('./display/Bounds');
            Object.defineProperty(exports, 'Bounds', { enumerable: true, get: function get() { return _interopRequireDefault(_Bounds).default; } });
            var _DisplayObject = require('./display/DisplayObject');
            Object.defineProperty(exports, 'DisplayObject', { enumerable: true, get: function get() { return _interopRequireDefault(_DisplayObject).default; } });
            var _Container = require('./display/Container');
            Object.defineProperty(exports, 'Container', { enumerable: true, get: function get() { return _interopRequireDefault(_Container).default; } });
            var _Transform = require('./display/Transform');
            Object.defineProperty(exports, 'Transform', { enumerable: true, get: function get() { return _interopRequireDefault(_Transform).default; } });
            var _TransformStatic = require('./display/TransformStatic');
            Object.defineProperty(exports, 'TransformStatic', { enumerable: true, get: function get() { return _interopRequireDefault(_TransformStatic).default; } });
            var _TransformBase = require('./display/TransformBase');
            Object.defineProperty(exports, 'TransformBase', { enumerable: true, get: function get() { return _interopRequireDefault(_TransformBase).default; } });
            var _Sprite = require('./sprites/Sprite');
            Object.defineProperty(exports, 'Sprite', { enumerable: true, get: function get() { return _interopRequireDefault(_Sprite).default; } });
            var _CanvasSpriteRenderer = require('./sprites/canvas/CanvasSpriteRenderer');
            Object.defineProperty(exports, 'CanvasSpriteRenderer', { enumerable: true, get: function get() { return _interopRequireDefault(_CanvasSpriteRenderer).default; } });
            var _CanvasTinter = require('./sprites/canvas/CanvasTinter');
            Object.defineProperty(exports, 'CanvasTinter', { enumerable: true, get: function get() { return _interopRequireDefault(_CanvasTinter).default; } });
            var _SpriteRenderer = require('./sprites/webgl/SpriteRenderer');
            Object.defineProperty(exports, 'SpriteRenderer', { enumerable: true, get: function get() { return _interopRequireDefault(_SpriteRenderer).default; } });
            var _Text = require('./text/Text');
            Object.defineProperty(exports, 'Text', { enumerable: true, get: function get() { return _interopRequireDefault(_Text).default; } });
            var _TextStyle = require('./text/TextStyle');
            Object.defineProperty(exports, 'TextStyle', { enumerable: true, get: function get() { return _interopRequireDefault(_TextStyle).default; } });
            var _TextMetrics = require('./text/TextMetrics');
            Object.defineProperty(exports, 'TextMetrics', { enumerable: true, get: function get() { return _interopRequireDefault(_TextMetrics).default; } });
            var _Graphics = require('./graphics/Graphics');
            Object.defineProperty(exports, 'Graphics', { enumerable: true, get: function get() { return _interopRequireDefault(_Graphics).default; } });
            var _GraphicsData = require('./graphics/GraphicsData');
            Object.defineProperty(exports, 'GraphicsData', { enumerable: true, get: function get() { return _interopRequireDefault(_GraphicsData).default; } });
            var _GraphicsRenderer = require('./graphics/webgl/GraphicsRenderer');
            Object.defineProperty(exports, 'GraphicsRenderer', { enumerable: true, get: function get() { return _interopRequireDefault(_GraphicsRenderer).default; } });
            var _CanvasGraphicsRenderer = require('./graphics/canvas/CanvasGraphicsRenderer');
            Object.defineProperty(exports, 'CanvasGraphicsRenderer', { enumerable: true, get: function get() { return _interopRequireDefault(_CanvasGraphicsRenderer).default; } });
            var _Spritesheet = require('./textures/Spritesheet');
            Object.defineProperty(exports, 'Spritesheet', { enumerable: true, get: function get() { return _interopRequireDefault(_Spritesheet).default; } });
            var _Texture = require('./textures/Texture');
            Object.defineProperty(exports, 'Texture', { enumerable: true, get: function get() { return _interopRequireDefault(_Texture).default; } });
            var _BaseTexture = require('./textures/BaseTexture');
            Object.defineProperty(exports, 'BaseTexture', { enumerable: true, get: function get() { return _interopRequireDefault(_BaseTexture).default; } });
            var _RenderTexture = require('./textures/RenderTexture');
            Object.defineProperty(exports, 'RenderTexture', { enumerable: true, get: function get() { return _interopRequireDefault(_RenderTexture).default; } });
            var _BaseRenderTexture = require('./textures/BaseRenderTexture');
            Object.defineProperty(exports, 'BaseRenderTexture', { enumerable: true, get: function get() { return _interopRequireDefault(_BaseRenderTexture).default; } });
            var _VideoBaseTexture = require('./textures/VideoBaseTexture');
            Object.defineProperty(exports, 'VideoBaseTexture', { enumerable: true, get: function get() { return _interopRequireDefault(_VideoBaseTexture).default; } });
            var _TextureUvs = require('./textures/TextureUvs');
            Object.defineProperty(exports, 'TextureUvs', { enumerable: true, get: function get() { return _interopRequireDefault(_TextureUvs).default; } });
            var _CanvasRenderTarget = require('./renderers/canvas/utils/CanvasRenderTarget');
            Object.defineProperty(exports, 'CanvasRenderTarget', { enumerable: true, get: function get() { return _interopRequireDefault(_CanvasRenderTarget).default; } });
            var _Shader = require('./Shader');
            Object.defineProperty(exports, 'Shader', { enumerable: true, get: function get() { return _interopRequireDefault(_Shader).default; } });
            var _WebGLManager = require('./renderers/webgl/managers/WebGLManager');
            Object.defineProperty(exports, 'WebGLManager', { enumerable: true, get: function get() { return _interopRequireDefault(_WebGLManager).default; } });
            var _ObjectRenderer = require('./renderers/webgl/utils/ObjectRenderer');
            Object.defineProperty(exports, 'ObjectRenderer', { enumerable: true, get: function get() { return _interopRequireDefault(_ObjectRenderer).default; } });
            var _RenderTarget = require('./renderers/webgl/utils/RenderTarget');
            Object.defineProperty(exports, 'RenderTarget', { enumerable: true, get: function get() { return _interopRequireDefault(_RenderTarget).default; } });
            var _Quad = require('./renderers/webgl/utils/Quad');
            Object.defineProperty(exports, 'Quad', { enumerable: true, get: function get() { return _interopRequireDefault(_Quad).default; } });
            var _SpriteMaskFilter = require('./renderers/webgl/filters/spriteMask/SpriteMaskFilter');
            Object.defineProperty(exports, 'SpriteMaskFilter', { enumerable: true, get: function get() { return _interopRequireDefault(_SpriteMaskFilter).default; } });
            var _Filter = require('./renderers/webgl/filters/Filter');
            Object.defineProperty(exports, 'Filter', { enumerable: true, get: function get() { return _interopRequireDefault(_Filter).default; } });
            var _Application = require('./Application');
            Object.defineProperty(exports, 'Application', { enumerable: true, get: function get() { return _interopRequireDefault(_Application).default; } });
            var _autoDetectRenderer = require('./autoDetectRenderer');
            Object.defineProperty(exports, 'autoDetectRenderer', { enumerable: true, get: function get() { return _autoDetectRenderer.autoDetectRenderer; } });
            var _utils = require('./utils');
            var utils = _interopRequireWildcard(_utils);
            var _ticker = require('./ticker');
            var ticker = _interopRequireWildcard(_ticker);
            var _settings = require('./settings');
            var _settings2 = _interopRequireDefault(_settings);
            var _CanvasRenderer = require('./renderers/canvas/CanvasRenderer');
            var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);
            var _WebGLRenderer = require('./renderers/webgl/WebGLRenderer');
            var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            exports.settings = _settings2.default;
            exports.utils = utils;
            exports.ticker = ticker;
            exports.CanvasRenderer = _CanvasRenderer2.default;
            exports.WebGLRenderer = _WebGLRenderer2.default;
        }, { "./Application": 41, "./Shader": 42, "./autoDetectRenderer": 43, "./const": 44, "./display/Bounds": 45, "./display/Container": 46, "./display/DisplayObject": 47, "./display/Transform": 48, "./display/TransformBase": 49, "./display/TransformStatic": 50, "./graphics/Graphics": 51, "./graphics/GraphicsData": 52, "./graphics/canvas/CanvasGraphicsRenderer": 53, "./graphics/webgl/GraphicsRenderer": 55, "./math": 68, "./renderers/canvas/CanvasRenderer": 75, "./renderers/canvas/utils/CanvasRenderTarget": 77, "./renderers/webgl/WebGLRenderer": 82, "./renderers/webgl/filters/Filter": 84, "./renderers/webgl/filters/spriteMask/SpriteMaskFilter": 87, "./renderers/webgl/managers/WebGLManager": 91, "./renderers/webgl/utils/ObjectRenderer": 92, "./renderers/webgl/utils/Quad": 93, "./renderers/webgl/utils/RenderTarget": 94, "./settings": 99, "./sprites/Sprite": 100, "./sprites/canvas/CanvasSpriteRenderer": 101, "./sprites/canvas/CanvasTinter": 102, "./sprites/webgl/SpriteRenderer": 104, "./text/Text": 106, "./text/TextMetrics": 107, "./text/TextStyle": 108, "./textures/BaseRenderTexture": 109, "./textures/BaseTexture": 110, "./textures/RenderTexture": 111, "./textures/Spritesheet": 112, "./textures/Texture": 113, "./textures/TextureUvs": 114, "./textures/VideoBaseTexture": 115, "./ticker": 118, "./utils": 122, "pixi-gl-core": 12 }],
        64: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _Matrix = require('./Matrix');
            var _Matrix2 = _interopRequireDefault(_Matrix);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            var ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
            var uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
            var vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
            var vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
            var tempMatrices = [];
            var mul = [];

            function signum(x) {
                if (x < 0) { return -1; }
                if (x > 0) { return 1; }
                return 0;
            }

            function init() {
                for (var i = 0; i < 16; i++) { var row = [];
                    mul.push(row); for (var j = 0; j < 16; j++) { var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]); var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]); var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]); var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]); for (var k = 0; k < 16; k++) { if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) { row.push(k); break; } } } }
                for (var _i = 0; _i < 16; _i++) { var mat = new _Matrix2.default();
                    mat.set(ux[_i], uy[_i], vx[_i], vy[_i], 0, 0);
                    tempMatrices.push(mat); }
            }
            init();
            var GroupD8 = {
                E: 0,
                SE: 1,
                S: 2,
                SW: 3,
                W: 4,
                NW: 5,
                N: 6,
                NE: 7,
                MIRROR_VERTICAL: 8,
                MIRROR_HORIZONTAL: 12,
                uX: function uX(ind) { return ux[ind]; },
                uY: function uY(ind) { return uy[ind]; },
                vX: function vX(ind) { return vx[ind]; },
                vY: function vY(ind) { return vy[ind]; },
                inv: function inv(rotation) {
                    if (rotation & 8) { return rotation & 15; }
                    return -rotation & 7;
                },
                add: function add(rotationSecond, rotationFirst) { return mul[rotationSecond][rotationFirst]; },
                sub: function sub(rotationSecond, rotationFirst) { return mul[rotationSecond][GroupD8.inv(rotationFirst)]; },
                rotate180: function rotate180(rotation) { return rotation ^ 4; },
                isSwapWidthHeight: function isSwapWidthHeight(rotation) { return (rotation & 3) === 2; },
                byDirection: function byDirection(dx, dy) {
                    if (Math.abs(dx) * 2 <= Math.abs(dy)) {
                        if (dy >= 0) { return GroupD8.S; }
                        return GroupD8.N;
                    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
                        if (dx > 0) { return GroupD8.E; }
                        return GroupD8.W;
                    } else if (dy > 0) {
                        if (dx > 0) { return GroupD8.SE; }
                        return GroupD8.SW;
                    } else if (dx > 0) { return GroupD8.NE; }
                    return GroupD8.NW;
                },
                matrixAppendRotationInv: function matrixAppendRotationInv(matrix, rotation) { var tx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; var ty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0; var mat = tempMatrices[GroupD8.inv(rotation)];
                    mat.tx = tx;
                    mat.ty = ty;
                    matrix.append(mat); }
            };
            exports.default = GroupD8;
        }, { "./Matrix": 65 }],
        65: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _Point = require('./Point');
            var _Point2 = _interopRequireDefault(_Point);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var Matrix = function() {
                function Matrix() { var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1; var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1; var tx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0; var ty = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
                    _classCallCheck(this, Matrix);
                    this.a = a;
                    this.b = b;
                    this.c = c;
                    this.d = d;
                    this.tx = tx;
                    this.ty = ty;
                    this.array = null; }
                Matrix.prototype.fromArray = function fromArray(array) { this.a = array[0];
                    this.b = array[1];
                    this.c = array[3];
                    this.d = array[4];
                    this.tx = array[2];
                    this.ty = array[5]; };
                Matrix.prototype.set = function set(a, b, c, d, tx, ty) { this.a = a;
                    this.b = b;
                    this.c = c;
                    this.d = d;
                    this.tx = tx;
                    this.ty = ty; return this; };
                Matrix.prototype.toArray = function toArray(transpose, out) {
                    if (!this.array) { this.array = new Float32Array(9); }
                    var array = out || this.array;
                    if (transpose) { array[0] = this.a;
                        array[1] = this.b;
                        array[2] = 0;
                        array[3] = this.c;
                        array[4] = this.d;
                        array[5] = 0;
                        array[6] = this.tx;
                        array[7] = this.ty;
                        array[8] = 1; } else { array[0] = this.a;
                        array[1] = this.c;
                        array[2] = this.tx;
                        array[3] = this.b;
                        array[4] = this.d;
                        array[5] = this.ty;
                        array[6] = 0;
                        array[7] = 0;
                        array[8] = 1; }
                    return array;
                };
                Matrix.prototype.apply = function apply(pos, newPos) { newPos = newPos || new _Point2.default(); var x = pos.x; var y = pos.y;
                    newPos.x = this.a * x + this.c * y + this.tx;
                    newPos.y = this.b * x + this.d * y + this.ty; return newPos; };
                Matrix.prototype.applyInverse = function applyInverse(pos, newPos) { newPos = newPos || new _Point2.default(); var id = 1 / (this.a * this.d + this.c * -this.b); var x = pos.x; var y = pos.y;
                    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;
                    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id; return newPos; };
                Matrix.prototype.translate = function translate(x, y) { this.tx += x;
                    this.ty += y; return this; };
                Matrix.prototype.scale = function scale(x, y) { this.a *= x;
                    this.d *= y;
                    this.c *= x;
                    this.b *= y;
                    this.tx *= x;
                    this.ty *= y; return this; };
                Matrix.prototype.rotate = function rotate(angle) { var cos = Math.cos(angle); var sin = Math.sin(angle); var a1 = this.a; var c1 = this.c; var tx1 = this.tx;
                    this.a = a1 * cos - this.b * sin;
                    this.b = a1 * sin + this.b * cos;
                    this.c = c1 * cos - this.d * sin;
                    this.d = c1 * sin + this.d * cos;
                    this.tx = tx1 * cos - this.ty * sin;
                    this.ty = tx1 * sin + this.ty * cos; return this; };
                Matrix.prototype.append = function append(matrix) { var a1 = this.a; var b1 = this.b; var c1 = this.c; var d1 = this.d;
                    this.a = matrix.a * a1 + matrix.b * c1;
                    this.b = matrix.a * b1 + matrix.b * d1;
                    this.c = matrix.c * a1 + matrix.d * c1;
                    this.d = matrix.c * b1 + matrix.d * d1;
                    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;
                    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty; return this; };
                Matrix.prototype.setTransform = function setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) { var sr = Math.sin(rotation); var cr = Math.cos(rotation); var cy = Math.cos(skewY); var sy = Math.sin(skewY); var nsx = -Math.sin(skewX); var cx = Math.cos(skewX); var a = cr * scaleX; var b = sr * scaleX; var c = -sr * scaleY; var d = cr * scaleY;
                    this.a = cy * a + sy * c;
                    this.b = cy * b + sy * d;
                    this.c = nsx * a + cx * c;
                    this.d = nsx * b + cx * d;
                    this.tx = x + (pivotX * a + pivotY * c);
                    this.ty = y + (pivotX * b + pivotY * d); return this; };
                Matrix.prototype.prepend = function prepend(matrix) {
                    var tx1 = this.tx;
                    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) { var a1 = this.a; var c1 = this.c;
                        this.a = a1 * matrix.a + this.b * matrix.c;
                        this.b = a1 * matrix.b + this.b * matrix.d;
                        this.c = c1 * matrix.a + this.d * matrix.c;
                        this.d = c1 * matrix.b + this.d * matrix.d; }
                    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;
                    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;
                    return this;
                };
                Matrix.prototype.decompose = function decompose(transform) {
                    var a = this.a;
                    var b = this.b;
                    var c = this.c;
                    var d = this.d;
                    var skewX = -Math.atan2(-c, d);
                    var skewY = Math.atan2(b, a);
                    var delta = Math.abs(skewX + skewY);
                    if (delta < 0.00001) {
                        transform.rotation = skewY;
                        if (a < 0 && d >= 0) { transform.rotation += transform.rotation <= 0 ? Math.PI : -Math.PI; }
                        transform.skew.x = transform.skew.y = 0;
                    } else { transform.skew.x = skewX;
                        transform.skew.y = skewY; }
                    transform.scale.x = Math.sqrt(a * a + b * b);
                    transform.scale.y = Math.sqrt(c * c + d * d);
                    transform.position.x = this.tx;
                    transform.position.y = this.ty;
                    return transform;
                };
                Matrix.prototype.invert = function invert() { var a1 = this.a; var b1 = this.b; var c1 = this.c; var d1 = this.d; var tx1 = this.tx; var n = a1 * d1 - b1 * c1;
                    this.a = d1 / n;
                    this.b = -b1 / n;
                    this.c = -c1 / n;
                    this.d = a1 / n;
                    this.tx = (c1 * this.ty - d1 * tx1) / n;
                    this.ty = -(a1 * this.ty - b1 * tx1) / n; return this; };
                Matrix.prototype.identity = function identity() { this.a = 1;
                    this.b = 0;
                    this.c = 0;
                    this.d = 1;
                    this.tx = 0;
                    this.ty = 0; return this; };
                Matrix.prototype.clone = function clone() { var matrix = new Matrix();
                    matrix.a = this.a;
                    matrix.b = this.b;
                    matrix.c = this.c;
                    matrix.d = this.d;
                    matrix.tx = this.tx;
                    matrix.ty = this.ty; return matrix; };
                Matrix.prototype.copy = function copy(matrix) { matrix.a = this.a;
                    matrix.b = this.b;
                    matrix.c = this.c;
                    matrix.d = this.d;
                    matrix.tx = this.tx;
                    matrix.ty = this.ty; return matrix; };
                _createClass(Matrix, null, [{ key: 'IDENTITY', get: function get() { return new Matrix(); } }, { key: 'TEMP_MATRIX', get: function get() { return new Matrix(); } }]);
                return Matrix;
            }();
            exports.default = Matrix;
        }, { "./Point": 67 }],
        66: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var ObservablePoint = function() {
                function ObservablePoint(cb, scope) { var x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; var y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
                    _classCallCheck(this, ObservablePoint);
                    this._x = x;
                    this._y = y;
                    this.cb = cb;
                    this.scope = scope; }
                ObservablePoint.prototype.set = function set(x, y) { var _x = x || 0; var _y = y || (y !== 0 ? _x : 0); if (this._x !== _x || this._y !== _y) { this._x = _x;
                        this._y = _y;
                        this.cb.call(this.scope); } };
                ObservablePoint.prototype.copy = function copy(point) { if (this._x !== point.x || this._y !== point.y) { this._x = point.x;
                        this._y = point.y;
                        this.cb.call(this.scope); } };
                _createClass(ObservablePoint, [{
                    key: "x",
                    get: function get() { return this._x; },
                    set: function set(value) { if (this._x !== value) { this._x = value;
                            this.cb.call(this.scope); } }
                }, {
                    key: "y",
                    get: function get() { return this._y; },
                    set: function set(value) { if (this._y !== value) { this._y = value;
                            this.cb.call(this.scope); } }
                }]);
                return ObservablePoint;
            }();
            exports.default = ObservablePoint;
        }, {}],
        67: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var Point = function() {
                function Point() { var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0; var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                    _classCallCheck(this, Point);
                    this.x = x;
                    this.y = y; }
                Point.prototype.clone = function clone() { return new Point(this.x, this.y); };
                Point.prototype.copy = function copy(p) { this.set(p.x, p.y); };
                Point.prototype.equals = function equals(p) { return p.x === this.x && p.y === this.y; };
                Point.prototype.set = function set(x, y) { this.x = x || 0;
                    this.y = y || (y !== 0 ? this.x : 0); };
                return Point;
            }();
            exports.default = Point;
        }, {}],
        68: [function(require, module, exports) { 'use strict';
            exports.__esModule = true; var _Point = require('./Point');
            Object.defineProperty(exports, 'Point', { enumerable: true, get: function get() { return _interopRequireDefault(_Point).default; } }); var _ObservablePoint = require('./ObservablePoint');
            Object.defineProperty(exports, 'ObservablePoint', { enumerable: true, get: function get() { return _interopRequireDefault(_ObservablePoint).default; } }); var _Matrix = require('./Matrix');
            Object.defineProperty(exports, 'Matrix', { enumerable: true, get: function get() { return _interopRequireDefault(_Matrix).default; } }); var _GroupD = require('./GroupD8');
            Object.defineProperty(exports, 'GroupD8', { enumerable: true, get: function get() { return _interopRequireDefault(_GroupD).default; } }); var _Circle = require('./shapes/Circle');
            Object.defineProperty(exports, 'Circle', { enumerable: true, get: function get() { return _interopRequireDefault(_Circle).default; } }); var _Ellipse = require('./shapes/Ellipse');
            Object.defineProperty(exports, 'Ellipse', { enumerable: true, get: function get() { return _interopRequireDefault(_Ellipse).default; } }); var _Polygon = require('./shapes/Polygon');
            Object.defineProperty(exports, 'Polygon', { enumerable: true, get: function get() { return _interopRequireDefault(_Polygon).default; } }); var _Rectangle = require('./shapes/Rectangle');
            Object.defineProperty(exports, 'Rectangle', { enumerable: true, get: function get() { return _interopRequireDefault(_Rectangle).default; } }); var _RoundedRectangle = require('./shapes/RoundedRectangle');
            Object.defineProperty(exports, 'RoundedRectangle', { enumerable: true, get: function get() { return _interopRequireDefault(_RoundedRectangle).default; } });

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } }, { "./GroupD8": 64, "./Matrix": 65, "./ObservablePoint": 66, "./Point": 67, "./shapes/Circle": 69, "./shapes/Ellipse": 70, "./shapes/Polygon": 71, "./shapes/Rectangle": 72, "./shapes/RoundedRectangle": 73 }],
        69: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _Rectangle = require('./Rectangle');
            var _Rectangle2 = _interopRequireDefault(_Rectangle);
            var _const = require('../../const');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var Circle = function() {
                function Circle() { var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0; var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                    _classCallCheck(this, Circle);
                    this.x = x;
                    this.y = y;
                    this.radius = radius;
                    this.type = _const.SHAPES.CIRC; }
                Circle.prototype.clone = function clone() { return new Circle(this.x, this.y, this.radius); };
                Circle.prototype.contains = function contains(x, y) {
                    if (this.radius <= 0) { return false; }
                    var r2 = this.radius * this.radius;
                    var dx = this.x - x;
                    var dy = this.y - y;
                    dx *= dx;
                    dy *= dy;
                    return dx + dy <= r2;
                };
                Circle.prototype.getBounds = function getBounds() { return new _Rectangle2.default(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2); };
                return Circle;
            }();
            exports.default = Circle;
        }, { "../../const": 44, "./Rectangle": 72 }],
        70: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _Rectangle = require('./Rectangle');
            var _Rectangle2 = _interopRequireDefault(_Rectangle);
            var _const = require('../../const');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var Ellipse = function() {
                function Ellipse() { var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0; var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
                    _classCallCheck(this, Ellipse);
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.type = _const.SHAPES.ELIP; }
                Ellipse.prototype.clone = function clone() { return new Ellipse(this.x, this.y, this.width, this.height); };
                Ellipse.prototype.contains = function contains(x, y) {
                    if (this.width <= 0 || this.height <= 0) { return false; }
                    var normx = (x - this.x) / this.width;
                    var normy = (y - this.y) / this.height;
                    normx *= normx;
                    normy *= normy;
                    return normx + normy <= 1;
                };
                Ellipse.prototype.getBounds = function getBounds() { return new _Rectangle2.default(this.x - this.width, this.y - this.height, this.width, this.height); };
                return Ellipse;
            }();
            exports.default = Ellipse;
        }, { "../../const": 44, "./Rectangle": 72 }],
        71: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _Point = require('../Point');
            var _Point2 = _interopRequireDefault(_Point);
            var _const = require('../../const');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var Polygon = function() {
                function Polygon() {
                    for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) { points[_key] = arguments[_key]; }
                    _classCallCheck(this, Polygon);
                    if (Array.isArray(points[0])) { points = points[0]; }
                    if (points[0] instanceof _Point2.default) {
                        var p = [];
                        for (var i = 0, il = points.length; i < il; i++) { p.push(points[i].x, points[i].y); }
                        points = p;
                    }
                    this.closed = true;
                    this.points = points;
                    this.type = _const.SHAPES.POLY;
                }
                Polygon.prototype.clone = function clone() { return new Polygon(this.points.slice()); };
                Polygon.prototype.close = function close() { var points = this.points; if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1]) { points.push(points[0], points[1]); } };
                Polygon.prototype.contains = function contains(x, y) {
                    var inside = false;
                    var length = this.points.length / 2;
                    for (var i = 0, j = length - 1; i < length; j = i++) { var xi = this.points[i * 2]; var yi = this.points[i * 2 + 1]; var xj = this.points[j * 2]; var yj = this.points[j * 2 + 1]; var intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi; if (intersect) { inside = !inside; } }
                    return inside;
                };
                return Polygon;
            }();
            exports.default = Polygon;
        }, { "../../const": 44, "../Point": 67 }],
        72: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _const = require('../../const');

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var Rectangle = function() {
                function Rectangle() { var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0; var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
                    _classCallCheck(this, Rectangle);
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.type = _const.SHAPES.RECT; }
                Rectangle.prototype.clone = function clone() { return new Rectangle(this.x, this.y, this.width, this.height); };
                Rectangle.prototype.copy = function copy(rectangle) { this.x = rectangle.x;
                    this.y = rectangle.y;
                    this.width = rectangle.width;
                    this.height = rectangle.height; return this; };
                Rectangle.prototype.contains = function contains(x, y) {
                    if (this.width <= 0 || this.height <= 0) { return false; }
                    if (x >= this.x && x < this.x + this.width) { if (y >= this.y && y < this.y + this.height) { return true; } }
                    return false;
                };
                Rectangle.prototype.pad = function pad(paddingX, paddingY) { paddingX = paddingX || 0;
                    paddingY = paddingY || (paddingY !== 0 ? paddingX : 0);
                    this.x -= paddingX;
                    this.y -= paddingY;
                    this.width += paddingX * 2;
                    this.height += paddingY * 2; };
                Rectangle.prototype.fit = function fit(rectangle) {
                    if (this.x < rectangle.x) {
                        this.width += this.x;
                        if (this.width < 0) { this.width = 0; }
                        this.x = rectangle.x;
                    }
                    if (this.y < rectangle.y) {
                        this.height += this.y;
                        if (this.height < 0) { this.height = 0; }
                        this.y = rectangle.y;
                    }
                    if (this.x + this.width > rectangle.x + rectangle.width) { this.width = rectangle.width - this.x; if (this.width < 0) { this.width = 0; } }
                    if (this.y + this.height > rectangle.y + rectangle.height) { this.height = rectangle.height - this.y; if (this.height < 0) { this.height = 0; } }
                };
                Rectangle.prototype.enlarge = function enlarge(rectangle) { var x1 = Math.min(this.x, rectangle.x); var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width); var y1 = Math.min(this.y, rectangle.y); var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
                    this.x = x1;
                    this.width = x2 - x1;
                    this.y = y1;
                    this.height = y2 - y1; };
                _createClass(Rectangle, [{ key: 'left', get: function get() { return this.x; } }, { key: 'right', get: function get() { return this.x + this.width; } }, { key: 'top', get: function get() { return this.y; } }, { key: 'bottom', get: function get() { return this.y + this.height; } }], [{ key: 'EMPTY', get: function get() { return new Rectangle(0, 0, 0, 0); } }]);
                return Rectangle;
            }();
            exports.default = Rectangle;
        }, { "../../const": 44 }],
        73: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _const = require('../../const');

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var RoundedRectangle = function() {
                function RoundedRectangle() { var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0; var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0; var radius = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 20;
                    _classCallCheck(this, RoundedRectangle);
                    this.x = x;
                    this.y = y;
                    this.width = width;
                    this.height = height;
                    this.radius = radius;
                    this.type = _const.SHAPES.RREC; }
                RoundedRectangle.prototype.clone = function clone() { return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius); };
                RoundedRectangle.prototype.contains = function contains(x, y) {
                    if (this.width <= 0 || this.height <= 0) { return false; }
                    if (x >= this.x && x <= this.x + this.width) {
                        if (y >= this.y && y <= this.y + this.height) {
                            if (y >= this.y + this.radius && y <= this.y + this.height - this.radius || x >= this.x + this.radius && x <= this.x + this.width - this.radius) { return true; }
                            var dx = x - (this.x + this.radius);
                            var dy = y - (this.y + this.radius);
                            var radius2 = this.radius * this.radius;
                            if (dx * dx + dy * dy <= radius2) { return true; }
                            dx = x - (this.x + this.width - this.radius);
                            if (dx * dx + dy * dy <= radius2) { return true; }
                            dy = y - (this.y + this.height - this.radius);
                            if (dx * dx + dy * dy <= radius2) { return true; }
                            dx = x - (this.x + this.radius);
                            if (dx * dx + dy * dy <= radius2) { return true; }
                        }
                    }
                    return false;
                };
                return RoundedRectangle;
            }();
            exports.default = RoundedRectangle;
        }, { "../../const": 44 }],
        74: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _utils = require('../utils');
            var _math = require('../math');
            var _const = require('../const');
            var _settings = require('../settings');
            var _settings2 = _interopRequireDefault(_settings);
            var _Container = require('../display/Container');
            var _Container2 = _interopRequireDefault(_Container);
            var _RenderTexture = require('../textures/RenderTexture');
            var _RenderTexture2 = _interopRequireDefault(_RenderTexture);
            var _eventemitter = require('eventemitter3');
            var _eventemitter2 = _interopRequireDefault(_eventemitter);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var tempMatrix = new _math.Matrix();
            var SystemRenderer = function(_EventEmitter) {
                _inherits(SystemRenderer, _EventEmitter);

                function SystemRenderer(system, options, arg2, arg3) {
                    _classCallCheck(this, SystemRenderer);
                    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
                    (0, _utils.sayHello)(system);
                    if (typeof options === 'number') { options = Object.assign({ width: options, height: arg2 || _settings2.default.RENDER_OPTIONS.height }, arg3); }
                    options = Object.assign({}, _settings2.default.RENDER_OPTIONS, options);
                    _this.options = options;
                    _this.type = _const.RENDERER_TYPE.UNKNOWN;
                    _this.screen = new _math.Rectangle(0, 0, options.width, options.height);
                    _this.view = options.view || document.createElement('canvas');
                    _this.resolution = options.resolution || _settings2.default.RESOLUTION;
                    _this.transparent = options.transparent;
                    _this.autoResize = options.autoResize || false;
                    _this.blendModes = null;
                    _this.preserveDrawingBuffer = options.preserveDrawingBuffer;
                    _this.clearBeforeRender = options.clearBeforeRender;
                    _this.roundPixels = options.roundPixels;
                    _this._backgroundColor = 0x000000;
                    _this._backgroundColorRgba = [0, 0, 0, 0];
                    _this._backgroundColorString = '#000000';
                    _this.backgroundColor = options.backgroundColor || _this._backgroundColor;
                    _this._tempDisplayObjectParent = new _Container2.default();
                    _this._lastObjectRendered = _this._tempDisplayObjectParent;
                    return _this;
                }
                SystemRenderer.prototype.resize = function resize(screenWidth, screenHeight) { this.screen.width = screenWidth;
                    this.screen.height = screenHeight;
                    this.view.width = screenWidth * this.resolution;
                    this.view.height = screenHeight * this.resolution; if (this.autoResize) { this.view.style.width = screenWidth + 'px';
                        this.view.style.height = screenHeight + 'px'; } };
                SystemRenderer.prototype.generateTexture = function generateTexture(displayObject, scaleMode, resolution) { var bounds = displayObject.getLocalBounds(); var renderTexture = _RenderTexture2.default.create(bounds.width | 0, bounds.height | 0, scaleMode, resolution);
                    tempMatrix.tx = -bounds.x;
                    tempMatrix.ty = -bounds.y;
                    this.render(displayObject, renderTexture, false, tempMatrix, true); return renderTexture; };
                SystemRenderer.prototype.destroy = function destroy(removeView) {
                    if (removeView && this.view.parentNode) { this.view.parentNode.removeChild(this.view); }
                    this.type = _const.RENDERER_TYPE.UNKNOWN;
                    this.view = null;
                    this.screen = null;
                    this.resolution = 0;
                    this.transparent = false;
                    this.autoResize = false;
                    this.blendModes = null;
                    this.options = null;
                    this.preserveDrawingBuffer = false;
                    this.clearBeforeRender = false;
                    this.roundPixels = false;
                    this._backgroundColor = 0;
                    this._backgroundColorRgba = null;
                    this._backgroundColorString = null;
                    this.backgroundColor = 0;
                    this._tempDisplayObjectParent = null;
                    this._lastObjectRendered = null;
                };
                _createClass(SystemRenderer, [{ key: 'width', get: function get() { return this.view.width; } }, { key: 'height', get: function get() { return this.view.height; } }, {
                    key: 'backgroundColor',
                    get: function get() { return this._backgroundColor; },
                    set: function set(value) { this._backgroundColor = value;
                        this._backgroundColorString = (0, _utils.hex2string)(value);
                        (0, _utils.hex2rgb)(value, this._backgroundColorRgba); }
                }]);
                return SystemRenderer;
            }(_eventemitter2.default);
            exports.default = SystemRenderer;
        }, { "../const": 44, "../display/Container": 46, "../math": 68, "../settings": 99, "../textures/RenderTexture": 111, "../utils": 122, "eventemitter3": 3 }],
        75: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _SystemRenderer2 = require('../SystemRenderer');
            var _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);
            var _CanvasMaskManager = require('./utils/CanvasMaskManager');
            var _CanvasMaskManager2 = _interopRequireDefault(_CanvasMaskManager);
            var _CanvasRenderTarget = require('./utils/CanvasRenderTarget');
            var _CanvasRenderTarget2 = _interopRequireDefault(_CanvasRenderTarget);
            var _mapCanvasBlendModesToPixi = require('./utils/mapCanvasBlendModesToPixi');
            var _mapCanvasBlendModesToPixi2 = _interopRequireDefault(_mapCanvasBlendModesToPixi);
            var _utils = require('../../utils');
            var _const = require('../../const');
            var _settings = require('../../settings');
            var _settings2 = _interopRequireDefault(_settings);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var CanvasRenderer = function(_SystemRenderer) {
                _inherits(CanvasRenderer, _SystemRenderer);

                function CanvasRenderer(options, arg2, arg3) {
                    _classCallCheck(this, CanvasRenderer);
                    var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'Canvas', options, arg2, arg3));
                    _this.type = _const.RENDERER_TYPE.CANVAS;
                    _this.rootContext = _this.view.getContext('2d', { alpha: _this.transparent });
                    _this.refresh = true;
                    _this.maskManager = new _CanvasMaskManager2.default(_this);
                    _this.smoothProperty = 'imageSmoothingEnabled';
                    if (!_this.rootContext.imageSmoothingEnabled) { if (_this.rootContext.webkitImageSmoothingEnabled) { _this.smoothProperty = 'webkitImageSmoothingEnabled'; } else if (_this.rootContext.mozImageSmoothingEnabled) { _this.smoothProperty = 'mozImageSmoothingEnabled'; } else if (_this.rootContext.oImageSmoothingEnabled) { _this.smoothProperty = 'oImageSmoothingEnabled'; } else if (_this.rootContext.msImageSmoothingEnabled) { _this.smoothProperty = 'msImageSmoothingEnabled'; } }
                    _this.initPlugins();
                    _this.blendModes = (0, _mapCanvasBlendModesToPixi2.default)();
                    _this._activeBlendMode = null;
                    _this.context = null;
                    _this.renderingToScreen = false;
                    _this.resize(_this.options.width, _this.options.height);
                    return _this;
                }
                CanvasRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
                    if (!this.view) { return; }
                    this.renderingToScreen = !renderTexture;
                    this.emit('prerender');
                    var rootResolution = this.resolution;
                    if (renderTexture) {
                        renderTexture = renderTexture.baseTexture || renderTexture;
                        if (!renderTexture._canvasRenderTarget) { renderTexture._canvasRenderTarget = new _CanvasRenderTarget2.default(renderTexture.width, renderTexture.height, renderTexture.resolution);
                            renderTexture.source = renderTexture._canvasRenderTarget.canvas;
                            renderTexture.valid = true; }
                        this.context = renderTexture._canvasRenderTarget.context;
                        this.resolution = renderTexture._canvasRenderTarget.resolution;
                    } else { this.context = this.rootContext; }
                    var context = this.context;
                    if (!renderTexture) { this._lastObjectRendered = displayObject; }
                    if (!skipUpdateTransform) {
                        var cacheParent = displayObject.parent;
                        var tempWt = this._tempDisplayObjectParent.transform.worldTransform;
                        if (transform) { transform.copy(tempWt);
                            this._tempDisplayObjectParent.transform._worldID = -1; } else { tempWt.identity(); }
                        displayObject.parent = this._tempDisplayObjectParent;
                        displayObject.updateTransform();
                        displayObject.parent = cacheParent;
                    }
                    context.setTransform(1, 0, 0, 1, 0, 0);
                    context.globalAlpha = 1;
                    context.globalCompositeOperation = this.blendModes[_const.BLEND_MODES.NORMAL];
                    if (navigator.isCocoonJS && this.view.screencanvas) { context.fillStyle = 'black';
                        context.clear(); }
                    if (clear !== undefined ? clear : this.clearBeforeRender) { if (this.renderingToScreen) { if (this.transparent) { context.clearRect(0, 0, this.width, this.height); } else { context.fillStyle = this._backgroundColorString;
                                context.fillRect(0, 0, this.width, this.height); } } }
                    var tempContext = this.context;
                    this.context = context;
                    displayObject.renderCanvas(this);
                    this.context = tempContext;
                    this.resolution = rootResolution;
                    this.emit('postrender');
                };
                CanvasRenderer.prototype.clear = function clear(clearColor) { var context = this.context;
                    clearColor = clearColor || this._backgroundColorString; if (!this.transparent && clearColor) { context.fillStyle = clearColor;
                        context.fillRect(0, 0, this.width, this.height); } else { context.clearRect(0, 0, this.width, this.height); } };
                CanvasRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {
                    if (this._activeBlendMode === blendMode) { return; }
                    this._activeBlendMode = blendMode;
                    this.context.globalCompositeOperation = this.blendModes[blendMode];
                };
                CanvasRenderer.prototype.destroy = function destroy(removeView) { this.destroyPlugins();
                    _SystemRenderer.prototype.destroy.call(this, removeView);
                    this.context = null;
                    this.refresh = true;
                    this.maskManager.destroy();
                    this.maskManager = null;
                    this.smoothProperty = null; };
                CanvasRenderer.prototype.resize = function resize(screenWidth, screenHeight) { _SystemRenderer.prototype.resize.call(this, screenWidth, screenHeight); if (this.smoothProperty) { this.rootContext[this.smoothProperty] = _settings2.default.SCALE_MODE === _const.SCALE_MODES.LINEAR; } };
                return CanvasRenderer;
            }(_SystemRenderer3.default);
            exports.default = CanvasRenderer;
            _utils.pluginTarget.mixin(CanvasRenderer);
        }, { "../../const": 44, "../../settings": 99, "../../utils": 122, "../SystemRenderer": 74, "./utils/CanvasMaskManager": 76, "./utils/CanvasRenderTarget": 77, "./utils/mapCanvasBlendModesToPixi": 79 }],
        76: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _const = require('../../../const');

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var CanvasMaskManager = function() {
                function CanvasMaskManager(renderer) { _classCallCheck(this, CanvasMaskManager);
                    this.renderer = renderer; }
                CanvasMaskManager.prototype.pushMask = function pushMask(maskData) {
                    var renderer = this.renderer;
                    renderer.context.save();
                    var cacheAlpha = maskData.alpha;
                    var transform = maskData.transform.worldTransform;
                    var resolution = renderer.resolution;
                    renderer.context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);
                    if (!maskData._texture) { this.renderGraphicsShape(maskData);
                        renderer.context.clip(); }
                    maskData.worldAlpha = cacheAlpha;
                };
                CanvasMaskManager.prototype.renderGraphicsShape = function renderGraphicsShape(graphics) {
                    var context = this.renderer.context;
                    var len = graphics.graphicsData.length;
                    if (len === 0) { return; }
                    context.beginPath();
                    for (var i = 0; i < len; i++) {
                        var data = graphics.graphicsData[i];
                        var shape = data.shape;
                        if (data.type === _const.SHAPES.POLY) {
                            var points = shape.points;
                            context.moveTo(points[0], points[1]);
                            for (var j = 1; j < points.length / 2; j++) { context.lineTo(points[j * 2], points[j * 2 + 1]); }
                            if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) { context.closePath(); }
                        } else if (data.type === _const.SHAPES.RECT) { context.rect(shape.x, shape.y, shape.width, shape.height);
                            context.closePath(); } else if (data.type === _const.SHAPES.CIRC) { context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);
                            context.closePath(); } else if (data.type === _const.SHAPES.ELIP) { var w = shape.width * 2; var h = shape.height * 2; var x = shape.x - w / 2; var y = shape.y - h / 2; var kappa = 0.5522848; var ox = w / 2 * kappa; var oy = h / 2 * kappa; var xe = x + w; var ye = y + h; var xm = x + w / 2; var ym = y + h / 2;
                            context.moveTo(x, ym);
                            context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                            context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                            context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                            context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                            context.closePath(); } else if (data.type === _const.SHAPES.RREC) { var rx = shape.x; var ry = shape.y; var width = shape.width; var height = shape.height; var radius = shape.radius; var maxRadius = Math.min(width, height) / 2 | 0;
                            radius = radius > maxRadius ? maxRadius : radius;
                            context.moveTo(rx, ry + radius);
                            context.lineTo(rx, ry + height - radius);
                            context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);
                            context.lineTo(rx + width - radius, ry + height);
                            context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);
                            context.lineTo(rx + width, ry + radius);
                            context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);
                            context.lineTo(rx + radius, ry);
                            context.quadraticCurveTo(rx, ry, rx, ry + radius);
                            context.closePath(); }
                    }
                };
                CanvasMaskManager.prototype.popMask = function popMask(renderer) { renderer.context.restore(); };
                CanvasMaskManager.prototype.destroy = function destroy() {};
                return CanvasMaskManager;
            }();
            exports.default = CanvasMaskManager;
        }, { "../../../const": 44 }],
        77: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _settings = require('../../../settings');
            var _settings2 = _interopRequireDefault(_settings);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var CanvasRenderTarget = function() {
                function CanvasRenderTarget(width, height, resolution) { _classCallCheck(this, CanvasRenderTarget);
                    this.canvas = document.createElement('canvas');
                    this.context = this.canvas.getContext('2d');
                    this.resolution = resolution || _settings2.default.RESOLUTION;
                    this.resize(width, height); }
                CanvasRenderTarget.prototype.clear = function clear() { this.context.setTransform(1, 0, 0, 1, 0, 0);
                    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); };
                CanvasRenderTarget.prototype.resize = function resize(width, height) { this.canvas.width = width * this.resolution;
                    this.canvas.height = height * this.resolution; };
                CanvasRenderTarget.prototype.destroy = function destroy() { this.context = null;
                    this.canvas = null; };
                _createClass(CanvasRenderTarget, [{
                    key: 'width',
                    get: function get() { return this.canvas.width; },
                    set: function set(val) { this.canvas.width = val; }
                }, {
                    key: 'height',
                    get: function get() { return this.canvas.height; },
                    set: function set(val) { this.canvas.height = val; }
                }]);
                return CanvasRenderTarget;
            }();
            exports.default = CanvasRenderTarget;
        }, { "../../../settings": 99 }],
        78: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = canUseNewCanvasBlendModes;

            function createColoredCanvas(color) { var canvas = document.createElement('canvas');
                canvas.width = 6;
                canvas.height = 1; var context = canvas.getContext('2d');
                context.fillStyle = color;
                context.fillRect(0, 0, 6, 1); return canvas; }

            function canUseNewCanvasBlendModes() {
                if (typeof document === 'undefined') { return false; }
                var magenta = createColoredCanvas('#ff00ff');
                var yellow = createColoredCanvas('#ffff00');
                var canvas = document.createElement('canvas');
                canvas.width = 6;
                canvas.height = 1;
                var context = canvas.getContext('2d');
                context.globalCompositeOperation = 'multiply';
                context.drawImage(magenta, 0, 0);
                context.drawImage(yellow, 2, 0);
                var imageData = context.getImageData(2, 0, 1, 1);
                if (!imageData) { return false; }
                var data = imageData.data;
                return data[0] === 255 && data[1] === 0 && data[2] === 0;
            }
        }, {}],
        79: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = mapCanvasBlendModesToPixi;
            var _const = require('../../../const');
            var _canUseNewCanvasBlendModes = require('./canUseNewCanvasBlendModes');
            var _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function mapCanvasBlendModesToPixi() {
                var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
                if ((0, _canUseNewCanvasBlendModes2.default)()) { array[_const.BLEND_MODES.NORMAL] = 'source-over';
                    array[_const.BLEND_MODES.ADD] = 'lighter';
                    array[_const.BLEND_MODES.MULTIPLY] = 'multiply';
                    array[_const.BLEND_MODES.SCREEN] = 'screen';
                    array[_const.BLEND_MODES.OVERLAY] = 'overlay';
                    array[_const.BLEND_MODES.DARKEN] = 'darken';
                    array[_const.BLEND_MODES.LIGHTEN] = 'lighten';
                    array[_const.BLEND_MODES.COLOR_DODGE] = 'color-dodge';
                    array[_const.BLEND_MODES.COLOR_BURN] = 'color-burn';
                    array[_const.BLEND_MODES.HARD_LIGHT] = 'hard-light';
                    array[_const.BLEND_MODES.SOFT_LIGHT] = 'soft-light';
                    array[_const.BLEND_MODES.DIFFERENCE] = 'difference';
                    array[_const.BLEND_MODES.EXCLUSION] = 'exclusion';
                    array[_const.BLEND_MODES.HUE] = 'hue';
                    array[_const.BLEND_MODES.SATURATION] = 'saturate';
                    array[_const.BLEND_MODES.COLOR] = 'color';
                    array[_const.BLEND_MODES.LUMINOSITY] = 'luminosity'; } else { array[_const.BLEND_MODES.NORMAL] = 'source-over';
                    array[_const.BLEND_MODES.ADD] = 'lighter';
                    array[_const.BLEND_MODES.MULTIPLY] = 'source-over';
                    array[_const.BLEND_MODES.SCREEN] = 'source-over';
                    array[_const.BLEND_MODES.OVERLAY] = 'source-over';
                    array[_const.BLEND_MODES.DARKEN] = 'source-over';
                    array[_const.BLEND_MODES.LIGHTEN] = 'source-over';
                    array[_const.BLEND_MODES.COLOR_DODGE] = 'source-over';
                    array[_const.BLEND_MODES.COLOR_BURN] = 'source-over';
                    array[_const.BLEND_MODES.HARD_LIGHT] = 'source-over';
                    array[_const.BLEND_MODES.SOFT_LIGHT] = 'source-over';
                    array[_const.BLEND_MODES.DIFFERENCE] = 'source-over';
                    array[_const.BLEND_MODES.EXCLUSION] = 'source-over';
                    array[_const.BLEND_MODES.HUE] = 'source-over';
                    array[_const.BLEND_MODES.SATURATION] = 'source-over';
                    array[_const.BLEND_MODES.COLOR] = 'source-over';
                    array[_const.BLEND_MODES.LUMINOSITY] = 'source-over'; }
                return array;
            }
        }, { "../../../const": 44, "./canUseNewCanvasBlendModes": 78 }],
        80: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _const = require('../../const');
            var _settings = require('../../settings');
            var _settings2 = _interopRequireDefault(_settings);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var TextureGarbageCollector = function() {
                function TextureGarbageCollector(renderer) { _classCallCheck(this, TextureGarbageCollector);
                    this.renderer = renderer;
                    this.count = 0;
                    this.checkCount = 0;
                    this.maxIdle = _settings2.default.GC_MAX_IDLE;
                    this.checkCountMax = _settings2.default.GC_MAX_CHECK_COUNT;
                    this.mode = _settings2.default.GC_MODE; }
                TextureGarbageCollector.prototype.update = function update() {
                    this.count++;
                    if (this.mode === _const.GC_MODES.MANUAL) { return; }
                    this.checkCount++;
                    if (this.checkCount > this.checkCountMax) { this.checkCount = 0;
                        this.run(); }
                };
                TextureGarbageCollector.prototype.run = function run() {
                    var tm = this.renderer.textureManager;
                    var managedTextures = tm._managedTextures;
                    var wasRemoved = false;
                    for (var i = 0; i < managedTextures.length; i++) { var texture = managedTextures[i]; if (!texture._glRenderTargets && this.count - texture.touched > this.maxIdle) { tm.destroyTexture(texture, true);
                            managedTextures[i] = null;
                            wasRemoved = true; } }
                    if (wasRemoved) {
                        var j = 0;
                        for (var _i = 0; _i < managedTextures.length; _i++) { if (managedTextures[_i] !== null) { managedTextures[j++] = managedTextures[_i]; } }
                        managedTextures.length = j;
                    }
                };
                TextureGarbageCollector.prototype.unload = function unload(displayObject) {
                    var tm = this.renderer.textureManager;
                    if (displayObject._texture && displayObject._texture._glRenderTargets) { tm.destroyTexture(displayObject._texture, true); }
                    for (var i = displayObject.children.length - 1; i >= 0; i--) { this.unload(displayObject.children[i]); }
                };
                return TextureGarbageCollector;
            }();
            exports.default = TextureGarbageCollector;
        }, { "../../const": 44, "../../settings": 99 }],
        81: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _pixiGlCore = require('pixi-gl-core');
            var _const = require('../../const');
            var _RenderTarget = require('./utils/RenderTarget');
            var _RenderTarget2 = _interopRequireDefault(_RenderTarget);
            var _utils = require('../../utils');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var TextureManager = function() {
                function TextureManager(renderer) { _classCallCheck(this, TextureManager);
                    this.renderer = renderer;
                    this.gl = renderer.gl;
                    this._managedTextures = []; }
                TextureManager.prototype.bindTexture = function bindTexture() {};
                TextureManager.prototype.getTexture = function getTexture() {};
                TextureManager.prototype.updateTexture = function updateTexture(texture, location) {
                    var gl = this.gl;
                    var isRenderTexture = !!texture._glRenderTargets;
                    if (!texture.hasLoaded) { return null; }
                    var boundTextures = this.renderer.boundTextures;
                    if (location === undefined) { location = 0; for (var i = 0; i < boundTextures.length; ++i) { if (boundTextures[i] === texture) { location = i; break; } } }
                    boundTextures[location] = texture;
                    gl.activeTexture(gl.TEXTURE0 + location);
                    var glTexture = texture._glTextures[this.renderer.CONTEXT_UID];
                    if (!glTexture) {
                        if (isRenderTexture) { var renderTarget = new _RenderTarget2.default(this.gl, texture.width, texture.height, texture.scaleMode, texture.resolution);
                            renderTarget.resize(texture.width, texture.height);
                            texture._glRenderTargets[this.renderer.CONTEXT_UID] = renderTarget;
                            glTexture = renderTarget.texture; } else { glTexture = new _pixiGlCore.GLTexture(this.gl, null, null, null, null);
                            glTexture.bind(location);
                            glTexture.premultiplyAlpha = true;
                            glTexture.upload(texture.source); }
                        texture._glTextures[this.renderer.CONTEXT_UID] = glTexture;
                        texture.on('update', this.updateTexture, this);
                        texture.on('dispose', this.destroyTexture, this);
                        this._managedTextures.push(texture);
                        if (texture.isPowerOfTwo) {
                            if (texture.mipmap) { glTexture.enableMipmap(); }
                            if (texture.wrapMode === _const.WRAP_MODES.CLAMP) { glTexture.enableWrapClamp(); } else if (texture.wrapMode === _const.WRAP_MODES.REPEAT) { glTexture.enableWrapRepeat(); } else { glTexture.enableWrapMirrorRepeat(); }
                        } else { glTexture.enableWrapClamp(); }
                        if (texture.scaleMode === _const.SCALE_MODES.NEAREST) { glTexture.enableNearestScaling(); } else { glTexture.enableLinearScaling(); }
                    } else if (isRenderTexture) { texture._glRenderTargets[this.renderer.CONTEXT_UID].resize(texture.width, texture.height); } else { glTexture.upload(texture.source); }
                    return glTexture;
                };
                TextureManager.prototype.destroyTexture = function destroyTexture(texture, skipRemove) {
                    texture = texture.baseTexture || texture;
                    if (!texture.hasLoaded) { return; }
                    if (texture._glTextures[this.renderer.CONTEXT_UID]) { this.renderer.unbindTexture(texture);
                        texture._glTextures[this.renderer.CONTEXT_UID].destroy();
                        texture.off('update', this.updateTexture, this);
                        texture.off('dispose', this.destroyTexture, this);
                        delete texture._glTextures[this.renderer.CONTEXT_UID]; if (!skipRemove) { var i = this._managedTextures.indexOf(texture); if (i !== -1) {
                                (0, _utils.removeItems)(this._managedTextures, i, 1); } } }
                };
                TextureManager.prototype.removeAll = function removeAll() { for (var i = 0; i < this._managedTextures.length; ++i) { var texture = this._managedTextures[i]; if (texture._glTextures[this.renderer.CONTEXT_UID]) { delete texture._glTextures[this.renderer.CONTEXT_UID]; } } };
                TextureManager.prototype.destroy = function destroy() {
                    for (var i = 0; i < this._managedTextures.length; ++i) { var texture = this._managedTextures[i];
                        this.destroyTexture(texture, true);
                        texture.off('update', this.updateTexture, this);
                        texture.off('dispose', this.destroyTexture, this); }
                    this._managedTextures = null;
                };
                return TextureManager;
            }();
            exports.default = TextureManager;
        }, { "../../const": 44, "../../utils": 122, "./utils/RenderTarget": 94, "pixi-gl-core": 12 }],
        82: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _SystemRenderer2 = require('../SystemRenderer');
            var _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);
            var _MaskManager = require('./managers/MaskManager');
            var _MaskManager2 = _interopRequireDefault(_MaskManager);
            var _StencilManager = require('./managers/StencilManager');
            var _StencilManager2 = _interopRequireDefault(_StencilManager);
            var _FilterManager = require('./managers/FilterManager');
            var _FilterManager2 = _interopRequireDefault(_FilterManager);
            var _RenderTarget = require('./utils/RenderTarget');
            var _RenderTarget2 = _interopRequireDefault(_RenderTarget);
            var _ObjectRenderer = require('./utils/ObjectRenderer');
            var _ObjectRenderer2 = _interopRequireDefault(_ObjectRenderer);
            var _TextureManager = require('./TextureManager');
            var _TextureManager2 = _interopRequireDefault(_TextureManager);
            var _BaseTexture = require('../../textures/BaseTexture');
            var _BaseTexture2 = _interopRequireDefault(_BaseTexture);
            var _TextureGarbageCollector = require('./TextureGarbageCollector');
            var _TextureGarbageCollector2 = _interopRequireDefault(_TextureGarbageCollector);
            var _WebGLState = require('./WebGLState');
            var _WebGLState2 = _interopRequireDefault(_WebGLState);
            var _mapWebGLDrawModesToPixi = require('./utils/mapWebGLDrawModesToPixi');
            var _mapWebGLDrawModesToPixi2 = _interopRequireDefault(_mapWebGLDrawModesToPixi);
            var _validateContext = require('./utils/validateContext');
            var _validateContext2 = _interopRequireDefault(_validateContext);
            var _utils = require('../../utils');
            var _pixiGlCore = require('pixi-gl-core');
            var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);
            var _const = require('../../const');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var CONTEXT_UID = 0;
            var WebGLRenderer = function(_SystemRenderer) {
                _inherits(WebGLRenderer, _SystemRenderer);

                function WebGLRenderer(options, arg2, arg3) {
                    _classCallCheck(this, WebGLRenderer);
                    var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'WebGL', options, arg2, arg3));
                    _this.legacy = _this.options.legacy;
                    if (_this.legacy) { _pixiGlCore2.default.VertexArrayObject.FORCE_NATIVE = true; }
                    _this.type = _const.RENDERER_TYPE.WEBGL;
                    _this.handleContextLost = _this.handleContextLost.bind(_this);
                    _this.handleContextRestored = _this.handleContextRestored.bind(_this);
                    _this.view.addEventListener('webglcontextlost', _this.handleContextLost, false);
                    _this.view.addEventListener('webglcontextrestored', _this.handleContextRestored, false);
                    _this._contextOptions = { alpha: _this.transparent, antialias: _this.options.antialias, premultipliedAlpha: _this.transparent && _this.transparent !== 'notMultiplied', stencil: true, preserveDrawingBuffer: _this.options.preserveDrawingBuffer };
                    _this._backgroundColorRgba[3] = _this.transparent ? 0 : 1;
                    _this.maskManager = new _MaskManager2.default(_this);
                    _this.stencilManager = new _StencilManager2.default(_this);
                    _this.emptyRenderer = new _ObjectRenderer2.default(_this);
                    _this.currentRenderer = _this.emptyRenderer;
                    _this.initPlugins();
                    if (_this.options.context) {
                        (0, _validateContext2.default)(_this.options.context); }
                    _this.gl = _this.options.context || _pixiGlCore2.default.createContext(_this.view, _this._contextOptions);
                    _this.CONTEXT_UID = CONTEXT_UID++;
                    _this.state = new _WebGLState2.default(_this.gl);
                    _this.renderingToScreen = true;
                    _this.boundTextures = null;
                    _this._activeShader = null;
                    _this._activeVao = null;
                    _this._activeRenderTarget = null;
                    _this._initContext();
                    _this.filterManager = new _FilterManager2.default(_this);
                    _this.drawModes = (0, _mapWebGLDrawModesToPixi2.default)(_this.gl);
                    _this._nextTextureLocation = 0;
                    _this.setBlendMode(0);
                    return _this;
                }
                WebGLRenderer.prototype._initContext = function _initContext() {
                    var gl = this.gl;
                    if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) { gl.getExtension('WEBGL_lose_context').restoreContext(); }
                    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
                    this.boundTextures = new Array(maxTextures);
                    this.emptyTextures = new Array(maxTextures);
                    this.textureManager = new _TextureManager2.default(this);
                    this.textureGC = new _TextureGarbageCollector2.default(this);
                    this.state.resetToDefault();
                    this.rootRenderTarget = new _RenderTarget2.default(gl, this.width, this.height, null, this.resolution, true);
                    this.rootRenderTarget.clearColor = this._backgroundColorRgba;
                    this.bindRenderTarget(this.rootRenderTarget);
                    var emptyGLTexture = new _pixiGlCore2.default.GLTexture.fromData(gl, null, 1, 1);
                    var tempObj = { _glTextures: {} };
                    tempObj._glTextures[this.CONTEXT_UID] = {};
                    for (var i = 0; i < maxTextures; i++) { var empty = new _BaseTexture2.default();
                        empty._glTextures[this.CONTEXT_UID] = emptyGLTexture;
                        this.boundTextures[i] = tempObj;
                        this.emptyTextures[i] = empty;
                        this.bindTexture(null, i); }
                    this.emit('context', gl);
                    this.resize(this.screen.width, this.screen.height);
                };
                WebGLRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {
                    this.renderingToScreen = !renderTexture;
                    this.emit('prerender');
                    if (!this.gl || this.gl.isContextLost()) { return; }
                    this._nextTextureLocation = 0;
                    if (!renderTexture) { this._lastObjectRendered = displayObject; }
                    if (!skipUpdateTransform) { var cacheParent = displayObject.parent;
                        displayObject.parent = this._tempDisplayObjectParent;
                        displayObject.updateTransform();
                        displayObject.parent = cacheParent; }
                    this.bindRenderTexture(renderTexture, transform);
                    this.currentRenderer.start();
                    if (clear !== undefined ? clear : this.clearBeforeRender) { this._activeRenderTarget.clear(); }
                    displayObject.renderWebGL(this);
                    this.currentRenderer.flush();
                    this.textureGC.update();
                    this.emit('postrender');
                };
                WebGLRenderer.prototype.setObjectRenderer = function setObjectRenderer(objectRenderer) {
                    if (this.currentRenderer === objectRenderer) { return; }
                    this.currentRenderer.stop();
                    this.currentRenderer = objectRenderer;
                    this.currentRenderer.start();
                };
                WebGLRenderer.prototype.flush = function flush() { this.setObjectRenderer(this.emptyRenderer); };
                WebGLRenderer.prototype.resize = function resize(screenWidth, screenHeight) { _SystemRenderer3.default.prototype.resize.call(this, screenWidth, screenHeight);
                    this.rootRenderTarget.resize(screenWidth, screenHeight); if (this._activeRenderTarget === this.rootRenderTarget) { this.rootRenderTarget.activate(); if (this._activeShader) { this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true); } } };
                WebGLRenderer.prototype.setBlendMode = function setBlendMode(blendMode) { this.state.setBlendMode(blendMode); };
                WebGLRenderer.prototype.clear = function clear(clearColor) { this._activeRenderTarget.clear(clearColor); };
                WebGLRenderer.prototype.setTransform = function setTransform(matrix) { this._activeRenderTarget.transform = matrix; };
                WebGLRenderer.prototype.clearRenderTexture = function clearRenderTexture(renderTexture, clearColor) {
                    var baseTexture = renderTexture.baseTexture;
                    var renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];
                    if (renderTarget) { renderTarget.clear(clearColor); }
                    return this;
                };
                WebGLRenderer.prototype.bindRenderTexture = function bindRenderTexture(renderTexture, transform) {
                    var renderTarget = void 0;
                    if (renderTexture) {
                        var baseTexture = renderTexture.baseTexture;
                        if (!baseTexture._glRenderTargets[this.CONTEXT_UID]) { this.textureManager.updateTexture(baseTexture, 0); }
                        this.unbindTexture(baseTexture);
                        renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];
                        renderTarget.setFrame(renderTexture.frame);
                    } else { renderTarget = this.rootRenderTarget; }
                    renderTarget.transform = transform;
                    this.bindRenderTarget(renderTarget);
                    return this;
                };
                WebGLRenderer.prototype.bindRenderTarget = function bindRenderTarget(renderTarget) {
                    if (renderTarget !== this._activeRenderTarget) {
                        this._activeRenderTarget = renderTarget;
                        renderTarget.activate();
                        if (this._activeShader) { this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true); }
                        this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);
                    }
                    return this;
                };
                WebGLRenderer.prototype.bindShader = function bindShader(shader, autoProject) {
                    if (this._activeShader !== shader) { this._activeShader = shader;
                        shader.bind(); if (autoProject !== false) { shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true); } }
                    return this;
                };
                WebGLRenderer.prototype.bindTexture = function bindTexture(texture, location, forceLocation) {
                    texture = texture || this.emptyTextures[location];
                    texture = texture.baseTexture || texture;
                    texture.touched = this.textureGC.count;
                    if (!forceLocation) {
                        for (var i = 0; i < this.boundTextures.length; i++) { if (this.boundTextures[i] === texture) { return i; } }
                        if (location === undefined) { this._nextTextureLocation++;
                            this._nextTextureLocation %= this.boundTextures.length;
                            location = this.boundTextures.length - this._nextTextureLocation - 1; }
                    } else { location = location || 0; }
                    var gl = this.gl;
                    var glTexture = texture._glTextures[this.CONTEXT_UID];
                    if (!glTexture) { this.textureManager.updateTexture(texture, location); } else { this.boundTextures[location] = texture;
                        gl.activeTexture(gl.TEXTURE0 + location);
                        gl.bindTexture(gl.TEXTURE_2D, glTexture.texture); }
                    return location;
                };
                WebGLRenderer.prototype.unbindTexture = function unbindTexture(texture) {
                    var gl = this.gl;
                    texture = texture.baseTexture || texture;
                    for (var i = 0; i < this.boundTextures.length; i++) { if (this.boundTextures[i] === texture) { this.boundTextures[i] = this.emptyTextures[i];
                            gl.activeTexture(gl.TEXTURE0 + i);
                            gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture); } }
                    return this;
                };
                WebGLRenderer.prototype.createVao = function createVao() { return new _pixiGlCore2.default.VertexArrayObject(this.gl, this.state.attribState); };
                WebGLRenderer.prototype.bindVao = function bindVao(vao) {
                    if (this._activeVao === vao) { return this; }
                    if (vao) { vao.bind(); } else if (this._activeVao) { this._activeVao.unbind(); }
                    this._activeVao = vao;
                    return this;
                };
                WebGLRenderer.prototype.reset = function reset() { this.setObjectRenderer(this.emptyRenderer);
                    this._activeShader = null;
                    this._activeRenderTarget = this.rootRenderTarget;
                    this.rootRenderTarget.activate();
                    this.state.resetToDefault(); return this; };
                WebGLRenderer.prototype.handleContextLost = function handleContextLost(event) { event.preventDefault(); };
                WebGLRenderer.prototype.handleContextRestored = function handleContextRestored() { this._initContext();
                    this.textureManager.removeAll(); };
                WebGLRenderer.prototype.destroy = function destroy(removeView) {
                    this.destroyPlugins();
                    this.view.removeEventListener('webglcontextlost', this.handleContextLost);
                    this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);
                    this.textureManager.destroy();
                    _SystemRenderer.prototype.destroy.call(this, removeView);
                    this.uid = 0;
                    this.maskManager.destroy();
                    this.stencilManager.destroy();
                    this.filterManager.destroy();
                    this.maskManager = null;
                    this.filterManager = null;
                    this.textureManager = null;
                    this.currentRenderer = null;
                    this.handleContextLost = null;
                    this.handleContextRestored = null;
                    this._contextOptions = null;
                    this.gl.useProgram(null);
                    if (this.gl.getExtension('WEBGL_lose_context')) { this.gl.getExtension('WEBGL_lose_context').loseContext(); }
                    this.gl = null;
                };
                return WebGLRenderer;
            }(_SystemRenderer3.default);
            exports.default = WebGLRenderer;
            _utils.pluginTarget.mixin(WebGLRenderer);
        }, { "../../const": 44, "../../textures/BaseTexture": 110, "../../utils": 122, "../SystemRenderer": 74, "./TextureGarbageCollector": 80, "./TextureManager": 81, "./WebGLState": 83, "./managers/FilterManager": 88, "./managers/MaskManager": 89, "./managers/StencilManager": 90, "./utils/ObjectRenderer": 92, "./utils/RenderTarget": 94, "./utils/mapWebGLDrawModesToPixi": 97, "./utils/validateContext": 98, "pixi-gl-core": 12 }],
        83: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _mapWebGLBlendModesToPixi = require('./utils/mapWebGLBlendModesToPixi');
            var _mapWebGLBlendModesToPixi2 = _interopRequireDefault(_mapWebGLBlendModesToPixi);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var BLEND = 0;
            var DEPTH_TEST = 1;
            var FRONT_FACE = 2;
            var CULL_FACE = 3;
            var BLEND_FUNC = 4;
            var WebGLState = function() {
                function WebGLState(gl) { _classCallCheck(this, WebGLState);
                    this.activeState = new Uint8Array(16);
                    this.defaultState = new Uint8Array(16);
                    this.defaultState[0] = 1;
                    this.stackIndex = 0;
                    this.stack = [];
                    this.gl = gl;
                    this.maxAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                    this.attribState = { tempAttribState: new Array(this.maxAttribs), attribState: new Array(this.maxAttribs) };
                    this.blendModes = (0, _mapWebGLBlendModesToPixi2.default)(gl);
                    this.nativeVaoExtension = gl.getExtension('OES_vertex_array_object') || gl.getExtension('MOZ_OES_vertex_array_object') || gl.getExtension('WEBKIT_OES_vertex_array_object'); }
                WebGLState.prototype.push = function push() {
                    var state = this.stack[this.stackIndex];
                    if (!state) { state = this.stack[this.stackIndex] = new Uint8Array(16); }
                    ++this.stackIndex;
                    for (var i = 0; i < this.activeState.length; i++) { state[i] = this.activeState[i]; }
                };
                WebGLState.prototype.pop = function pop() { var state = this.stack[--this.stackIndex];
                    this.setState(state); };
                WebGLState.prototype.setState = function setState(state) { this.setBlend(state[BLEND]);
                    this.setDepthTest(state[DEPTH_TEST]);
                    this.setFrontFace(state[FRONT_FACE]);
                    this.setCullFace(state[CULL_FACE]);
                    this.setBlendMode(state[BLEND_FUNC]); };
                WebGLState.prototype.setBlend = function setBlend(value) {
                    value = value ? 1 : 0;
                    if (this.activeState[BLEND] === value) { return; }
                    this.activeState[BLEND] = value;
                    this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);
                };
                WebGLState.prototype.setBlendMode = function setBlendMode(value) {
                    if (value === this.activeState[BLEND_FUNC]) { return; }
                    this.activeState[BLEND_FUNC] = value;
                    this.gl.blendFunc(this.blendModes[value][0], this.blendModes[value][1]);
                };
                WebGLState.prototype.setDepthTest = function setDepthTest(value) {
                    value = value ? 1 : 0;
                    if (this.activeState[DEPTH_TEST] === value) { return; }
                    this.activeState[DEPTH_TEST] = value;
                    this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
                };
                WebGLState.prototype.setCullFace = function setCullFace(value) {
                    value = value ? 1 : 0;
                    if (this.activeState[CULL_FACE] === value) { return; }
                    this.activeState[CULL_FACE] = value;
                    this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);
                };
                WebGLState.prototype.setFrontFace = function setFrontFace(value) {
                    value = value ? 1 : 0;
                    if (this.activeState[FRONT_FACE] === value) { return; }
                    this.activeState[FRONT_FACE] = value;
                    this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);
                };
                WebGLState.prototype.resetAttributes = function resetAttributes() {
                    for (var i = 0; i < this.attribState.tempAttribState.length; i++) { this.attribState.tempAttribState[i] = 0; }
                    for (var _i = 0; _i < this.attribState.attribState.length; _i++) { this.attribState.attribState[_i] = 0; }
                    for (var _i2 = 1; _i2 < this.maxAttribs; _i2++) { this.gl.disableVertexAttribArray(_i2); }
                };
                WebGLState.prototype.resetToDefault = function resetToDefault() {
                    if (this.nativeVaoExtension) { this.nativeVaoExtension.bindVertexArrayOES(null); }
                    this.resetAttributes();
                    for (var i = 0; i < this.activeState.length; ++i) { this.activeState[i] = 32; }
                    this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
                    this.setState(this.defaultState);
                };
                return WebGLState;
            }();
            exports.default = WebGLState;
        }, { "./utils/mapWebGLBlendModesToPixi": 96 }],
        84: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _extractUniformsFromSrc = require('./extractUniformsFromSrc');
            var _extractUniformsFromSrc2 = _interopRequireDefault(_extractUniformsFromSrc);
            var _utils = require('../../../utils');
            var _const = require('../../../const');
            var _settings = require('../../../settings');
            var _settings2 = _interopRequireDefault(_settings);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var SOURCE_KEY_MAP = {};
            var Filter = function() {
                function Filter(vertexSrc, fragmentSrc, uniforms) {
                    _classCallCheck(this, Filter);
                    this.vertexSrc = vertexSrc || Filter.defaultVertexSrc;
                    this.fragmentSrc = fragmentSrc || Filter.defaultFragmentSrc;
                    this.blendMode = _const.BLEND_MODES.NORMAL;
                    this.uniformData = uniforms || (0, _extractUniformsFromSrc2.default)(this.vertexSrc, this.fragmentSrc, 'projectionMatrix|uSampler');
                    this.uniforms = {};
                    for (var i in this.uniformData) { this.uniforms[i] = this.uniformData[i].value; }
                    this.glShaders = {};
                    if (!SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc]) { SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc] = (0, _utils.uid)(); }
                    this.glShaderKey = SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc];
                    this.padding = 4;
                    this.resolution = _settings2.default.RESOLUTION;
                    this.enabled = true;
                    this.autoFit = true;
                }
                Filter.prototype.apply = function apply(filterManager, input, output, clear, currentState) { filterManager.applyFilter(this, input, output, clear); };
                _createClass(Filter, null, [{ key: 'defaultVertexSrc', get: function get() { return ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'uniform mat3 projectionMatrix;', 'uniform mat3 filterMatrix;', 'varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;', '   vTextureCoord = aTextureCoord ;', '}'].join('\n'); } }, { key: 'defaultFragmentSrc', get: function get() { return ['varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'uniform sampler2D uSampler;', 'uniform sampler2D filterSampler;', 'void main(void){', '   vec4 masky = texture2D(filterSampler, vFilterCoord);', '   vec4 sample = texture2D(uSampler, vTextureCoord);', '   vec4 color;', '   if(mod(vFilterCoord.x, 1.0) > 0.5)', '   {', '     color = vec4(1.0, 0.0, 0.0, 1.0);', '   }', '   else', '   {', '     color = vec4(0.0, 1.0, 0.0, 1.0);', '   }', '   gl_FragColor = mix(sample, masky, 0.5);', '   gl_FragColor *= sample.a;', '}'].join('\n'); } }]);
                return Filter;
            }();
            exports.default = Filter;
        }, { "../../../const": 44, "../../../settings": 99, "../../../utils": 122, "./extractUniformsFromSrc": 85 }],
        85: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = extractUniformsFromSrc;
            var _pixiGlCore = require('pixi-gl-core');
            var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            var defaultValue = _pixiGlCore2.default.shader.defaultValue;

            function extractUniformsFromSrc(vertexSrc, fragmentSrc, mask) { var vertUniforms = extractUniformsFromString(vertexSrc, mask); var fragUniforms = extractUniformsFromString(fragmentSrc, mask); return Object.assign(vertUniforms, fragUniforms); }

            function extractUniformsFromString(string) {
                var maskRegex = new RegExp('^(projectionMatrix|uSampler|filterArea|filterClamp)$');
                var uniforms = {};
                var nameSplit = void 0;
                var lines = string.replace(/\s+/g, ' ').split(/\s*;\s*/);
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i].trim();
                    if (line.indexOf('uniform') > -1) {
                        var splitLine = line.split(' ');
                        var type = splitLine[1];
                        var name = splitLine[2];
                        var size = 1;
                        if (name.indexOf('[') > -1) { nameSplit = name.split(/\[|]/);
                            name = nameSplit[0];
                            size *= Number(nameSplit[1]); }
                        if (!name.match(maskRegex)) { uniforms[name] = { value: defaultValue(type, size), name: name, type: type }; }
                    }
                }
                return uniforms;
            }
        }, { "pixi-gl-core": 12 }],
        86: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.calculateScreenSpaceMatrix = calculateScreenSpaceMatrix;
            exports.calculateNormalizedScreenSpaceMatrix = calculateNormalizedScreenSpaceMatrix;
            exports.calculateSpriteMatrix = calculateSpriteMatrix;
            var _math = require('../../../math');

            function calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize) { var mappedMatrix = outputMatrix.identity();
                mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);
                mappedMatrix.scale(textureSize.width, textureSize.height); return mappedMatrix; }

            function calculateNormalizedScreenSpaceMatrix(outputMatrix, filterArea, textureSize) { var mappedMatrix = outputMatrix.identity();
                mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height); var translateScaleX = textureSize.width / filterArea.width; var translateScaleY = textureSize.height / filterArea.height;
                mappedMatrix.scale(translateScaleX, translateScaleY); return mappedMatrix; }

            function calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite) { var worldTransform = sprite.worldTransform.copy(_math.Matrix.TEMP_MATRIX); var texture = sprite._texture.baseTexture; var mappedMatrix = outputMatrix.identity(); var ratio = textureSize.height / textureSize.width;
                mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);
                mappedMatrix.scale(1, ratio); var translateScaleX = textureSize.width / texture.width; var translateScaleY = textureSize.height / texture.height;
                worldTransform.tx /= texture.width * translateScaleX;
                worldTransform.ty /= texture.width * translateScaleX;
                worldTransform.invert();
                mappedMatrix.prepend(worldTransform);
                mappedMatrix.scale(1, 1 / ratio);
                mappedMatrix.scale(translateScaleX, translateScaleY);
                mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y); return mappedMatrix; }
        }, { "../../../math": 68 }],
        87: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _Filter2 = require('../Filter');
            var _Filter3 = _interopRequireDefault(_Filter2);
            var _math = require('../../../../math');
            var _path = require('path');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var SpriteMaskFilter = function(_Filter) {
                _inherits(SpriteMaskFilter, _Filter);

                function SpriteMaskFilter(sprite) { _classCallCheck(this, SpriteMaskFilter); var maskMatrix = new _math.Matrix(); var _this = _possibleConstructorReturn(this, _Filter.call(this, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 otherMatrix;\n\nvarying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n}\n', 'varying vec2 vMaskCoord;\nvarying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform float alpha;\nuniform sampler2D mask;\n\nvoid main(void)\n{\n    // check clip! this will stop the mask bleeding out from the edges\n    vec2 text = abs( vMaskCoord - 0.5 );\n    text = step(0.5, text);\n\n    float clip = 1.0 - max(text.y, text.x);\n    vec4 original = texture2D(uSampler, vTextureCoord);\n    vec4 masky = texture2D(mask, vMaskCoord);\n\n    original *= (masky.r * masky.a * alpha * clip);\n\n    gl_FragColor = original;\n}\n'));
                    sprite.renderable = false;
                    _this.maskSprite = sprite;
                    _this.maskMatrix = maskMatrix; return _this; }
                SpriteMaskFilter.prototype.apply = function apply(filterManager, input, output) { var maskSprite = this.maskSprite;
                    this.uniforms.mask = maskSprite._texture;
                    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite);
                    this.uniforms.alpha = maskSprite.worldAlpha;
                    filterManager.applyFilter(this, input, output); };
                return SpriteMaskFilter;
            }(_Filter3.default);
            exports.default = SpriteMaskFilter;
        }, { "../../../../math": 68, "../Filter": 84, "path": 22 }],
        88: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _WebGLManager2 = require('./WebGLManager');
            var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);
            var _RenderTarget = require('../utils/RenderTarget');
            var _RenderTarget2 = _interopRequireDefault(_RenderTarget);
            var _Quad = require('../utils/Quad');
            var _Quad2 = _interopRequireDefault(_Quad);
            var _math = require('../../../math');
            var _Shader = require('../../../Shader');
            var _Shader2 = _interopRequireDefault(_Shader);
            var _filterTransforms = require('../filters/filterTransforms');
            var filterTransforms = _interopRequireWildcard(_filterTransforms);
            var _bitTwiddle = require('bit-twiddle');
            var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var FilterState = function FilterState() { _classCallCheck(this, FilterState);
                this.renderTarget = null;
                this.sourceFrame = new _math.Rectangle();
                this.destinationFrame = new _math.Rectangle();
                this.filters = [];
                this.target = null;
                this.resolution = 1; };
            var FilterManager = function(_WebGLManager) {
                _inherits(FilterManager, _WebGLManager);

                function FilterManager(renderer) { _classCallCheck(this, FilterManager); var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));
                    _this.gl = _this.renderer.gl;
                    _this.quad = new _Quad2.default(_this.gl, renderer.state.attribState);
                    _this.shaderCache = {};
                    _this.pool = {};
                    _this.filterData = null; return _this; }
                FilterManager.prototype.pushFilter = function pushFilter(target, filters) {
                    var renderer = this.renderer;
                    var filterData = this.filterData;
                    if (!filterData) { filterData = this.renderer._activeRenderTarget.filterStack; var filterState = new FilterState();
                        filterState.sourceFrame = filterState.destinationFrame = this.renderer._activeRenderTarget.size;
                        filterState.renderTarget = renderer._activeRenderTarget;
                        this.renderer._activeRenderTarget.filterData = filterData = { index: 0, stack: [filterState] };
                        this.filterData = filterData; }
                    var currentState = filterData.stack[++filterData.index];
                    if (!currentState) { currentState = filterData.stack[filterData.index] = new FilterState(); }
                    var resolution = filters[0].resolution;
                    var padding = filters[0].padding | 0;
                    var targetBounds = target.filterArea || target.getBounds(true);
                    var sourceFrame = currentState.sourceFrame;
                    var destinationFrame = currentState.destinationFrame;
                    sourceFrame.x = (targetBounds.x * resolution | 0) / resolution;
                    sourceFrame.y = (targetBounds.y * resolution | 0) / resolution;
                    sourceFrame.width = (targetBounds.width * resolution | 0) / resolution;
                    sourceFrame.height = (targetBounds.height * resolution | 0) / resolution;
                    if (filterData.stack[0].renderTarget.transform) {} else if (filters[0].autoFit) { sourceFrame.fit(filterData.stack[0].destinationFrame); }
                    sourceFrame.pad(padding);
                    destinationFrame.width = sourceFrame.width;
                    destinationFrame.height = sourceFrame.height;
                    var renderTarget = this.getPotRenderTarget(renderer.gl, sourceFrame.width, sourceFrame.height, resolution);
                    currentState.target = target;
                    currentState.filters = filters;
                    currentState.resolution = resolution;
                    currentState.renderTarget = renderTarget;
                    renderTarget.setFrame(destinationFrame, sourceFrame);
                    renderer.bindRenderTarget(renderTarget);
                    renderTarget.clear();
                };
                FilterManager.prototype.popFilter = function popFilter() {
                    var filterData = this.filterData;
                    var lastState = filterData.stack[filterData.index - 1];
                    var currentState = filterData.stack[filterData.index];
                    this.quad.map(currentState.renderTarget.size, currentState.sourceFrame).upload();
                    var filters = currentState.filters;
                    if (filters.length === 1) { filters[0].apply(this, currentState.renderTarget, lastState.renderTarget, false, currentState);
                        this.freePotRenderTarget(currentState.renderTarget); } else {
                        var flip = currentState.renderTarget;
                        var flop = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, currentState.resolution);
                        flop.setFrame(currentState.destinationFrame, currentState.sourceFrame);
                        flop.clear();
                        var i = 0;
                        for (i = 0; i < filters.length - 1; ++i) { filters[i].apply(this, flip, flop, true, currentState); var t = flip;
                            flip = flop;
                            flop = t; }
                        filters[i].apply(this, flip, lastState.renderTarget, false, currentState);
                        this.freePotRenderTarget(flip);
                        this.freePotRenderTarget(flop);
                    }
                    filterData.index--;
                    if (filterData.index === 0) { this.filterData = null; }
                };
                FilterManager.prototype.applyFilter = function applyFilter(filter, input, output, clear) {
                    var renderer = this.renderer;
                    var gl = renderer.gl;
                    var shader = filter.glShaders[renderer.CONTEXT_UID];
                    if (!shader) {
                        if (filter.glShaderKey) { shader = this.shaderCache[filter.glShaderKey]; if (!shader) { shader = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);
                                filter.glShaders[renderer.CONTEXT_UID] = this.shaderCache[filter.glShaderKey] = shader; } } else { shader = filter.glShaders[renderer.CONTEXT_UID] = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc); }
                        renderer.bindVao(null);
                        this.quad.initVao(shader);
                    }
                    renderer.bindVao(this.quad.vao);
                    renderer.bindRenderTarget(output);
                    if (clear) { gl.disable(gl.SCISSOR_TEST);
                        renderer.clear();
                        gl.enable(gl.SCISSOR_TEST); }
                    if (output === renderer.maskManager.scissorRenderTarget) { renderer.maskManager.pushScissorMask(null, renderer.maskManager.scissorData); }
                    renderer.bindShader(shader);
                    var tex = this.renderer.emptyTextures[0];
                    this.renderer.boundTextures[0] = tex;
                    this.syncUniforms(shader, filter);
                    renderer.state.setBlendMode(filter.blendMode);
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, input.texture.texture);
                    this.quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);
                    gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);
                };
                FilterManager.prototype.syncUniforms = function syncUniforms(shader, filter) {
                    var uniformData = filter.uniformData;
                    var uniforms = filter.uniforms;
                    var textureCount = 1;
                    var currentState = void 0;
                    if (shader.uniforms.filterArea) { currentState = this.filterData.stack[this.filterData.index]; var filterArea = shader.uniforms.filterArea;
                        filterArea[0] = currentState.renderTarget.size.width;
                        filterArea[1] = currentState.renderTarget.size.height;
                        filterArea[2] = currentState.sourceFrame.x;
                        filterArea[3] = currentState.sourceFrame.y;
                        shader.uniforms.filterArea = filterArea; }
                    if (shader.uniforms.filterClamp) { currentState = currentState || this.filterData.stack[this.filterData.index]; var filterClamp = shader.uniforms.filterClamp;
                        filterClamp[0] = 0;
                        filterClamp[1] = 0;
                        filterClamp[2] = (currentState.sourceFrame.width - 1) / currentState.renderTarget.size.width;
                        filterClamp[3] = (currentState.sourceFrame.height - 1) / currentState.renderTarget.size.height;
                        shader.uniforms.filterClamp = filterClamp; }
                    for (var i in uniformData) {
                        if (uniformData[i].type === 'sampler2D' && uniforms[i] !== 0) {
                            if (uniforms[i].baseTexture) { shader.uniforms[i] = this.renderer.bindTexture(uniforms[i].baseTexture, textureCount); } else { shader.uniforms[i] = textureCount; var gl = this.renderer.gl;
                                this.renderer.boundTextures[textureCount] = this.renderer.emptyTextures[textureCount];
                                gl.activeTexture(gl.TEXTURE0 + textureCount);
                                uniforms[i].texture.bind(); }
                            textureCount++;
                        } else if (uniformData[i].type === 'mat3') { if (uniforms[i].a !== undefined) { shader.uniforms[i] = uniforms[i].toArray(true); } else { shader.uniforms[i] = uniforms[i]; } } else if (uniformData[i].type === 'vec2') { if (uniforms[i].x !== undefined) { var val = shader.uniforms[i] || new Float32Array(2);
                                val[0] = uniforms[i].x;
                                val[1] = uniforms[i].y;
                                shader.uniforms[i] = val; } else { shader.uniforms[i] = uniforms[i]; } } else if (uniformData[i].type === 'float') { if (shader.uniforms.data[i].value !== uniformData[i]) { shader.uniforms[i] = uniforms[i]; } } else { shader.uniforms[i] = uniforms[i]; }
                    }
                };
                FilterManager.prototype.getRenderTarget = function getRenderTarget(clear, resolution) { var currentState = this.filterData.stack[this.filterData.index]; var renderTarget = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, resolution || currentState.resolution);
                    renderTarget.setFrame(currentState.destinationFrame, currentState.sourceFrame); return renderTarget; };
                FilterManager.prototype.returnRenderTarget = function returnRenderTarget(renderTarget) { this.freePotRenderTarget(renderTarget); };
                FilterManager.prototype.calculateScreenSpaceMatrix = function calculateScreenSpaceMatrix(outputMatrix) { var currentState = this.filterData.stack[this.filterData.index]; return filterTransforms.calculateScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size); };
                FilterManager.prototype.calculateNormalizedScreenSpaceMatrix = function calculateNormalizedScreenSpaceMatrix(outputMatrix) { var currentState = this.filterData.stack[this.filterData.index]; return filterTransforms.calculateNormalizedScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, currentState.destinationFrame); };
                FilterManager.prototype.calculateSpriteMatrix = function calculateSpriteMatrix(outputMatrix, sprite) { var currentState = this.filterData.stack[this.filterData.index]; return filterTransforms.calculateSpriteMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, sprite); };
                FilterManager.prototype.destroy = function destroy() { this.shaderCache = {};
                    this.emptyPool(); };
                FilterManager.prototype.getPotRenderTarget = function getPotRenderTarget(gl, minWidth, minHeight, resolution) {
                    minWidth = _bitTwiddle2.default.nextPow2(minWidth * resolution);
                    minHeight = _bitTwiddle2.default.nextPow2(minHeight * resolution);
                    var key = (minWidth & 0xFFFF) << 16 | minHeight & 0xFFFF;
                    if (!this.pool[key]) { this.pool[key] = []; }
                    var renderTarget = this.pool[key].pop();
                    if (!renderTarget) { var tex = this.renderer.boundTextures[0];
                        gl.activeTexture(gl.TEXTURE0);
                        renderTarget = new _RenderTarget2.default(gl, minWidth, minHeight, null, 1);
                        gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture); }
                    renderTarget.resolution = resolution;
                    renderTarget.defaultFrame.width = renderTarget.size.width = minWidth / resolution;
                    renderTarget.defaultFrame.height = renderTarget.size.height = minHeight / resolution;
                    return renderTarget;
                };
                FilterManager.prototype.emptyPool = function emptyPool() {
                    for (var i in this.pool) { var textures = this.pool[i]; if (textures) { for (var j = 0; j < textures.length; j++) { textures[j].destroy(true); } } }
                    this.pool = {};
                };
                FilterManager.prototype.freePotRenderTarget = function freePotRenderTarget(renderTarget) { var minWidth = renderTarget.size.width * renderTarget.resolution; var minHeight = renderTarget.size.height * renderTarget.resolution; var key = (minWidth & 0xFFFF) << 16 | minHeight & 0xFFFF;
                    this.pool[key].push(renderTarget); };
                return FilterManager;
            }(_WebGLManager3.default);
            exports.default = FilterManager;
        }, { "../../../Shader": 42, "../../../math": 68, "../filters/filterTransforms": 86, "../utils/Quad": 93, "../utils/RenderTarget": 94, "./WebGLManager": 91, "bit-twiddle": 1 }],
        89: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _WebGLManager2 = require('./WebGLManager');
            var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);
            var _SpriteMaskFilter = require('../filters/spriteMask/SpriteMaskFilter');
            var _SpriteMaskFilter2 = _interopRequireDefault(_SpriteMaskFilter);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var MaskManager = function(_WebGLManager) {
                _inherits(MaskManager, _WebGLManager);

                function MaskManager(renderer) { _classCallCheck(this, MaskManager); var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));
                    _this.scissor = false;
                    _this.scissorData = null;
                    _this.scissorRenderTarget = null;
                    _this.enableScissor = true;
                    _this.alphaMaskPool = [];
                    _this.alphaMaskIndex = 0; return _this; }
                MaskManager.prototype.pushMask = function pushMask(target, maskData) { if (maskData.texture) { this.pushSpriteMask(target, maskData); } else if (this.enableScissor && !this.scissor && this.renderer._activeRenderTarget.root && !this.renderer.stencilManager.stencilMaskStack.length && maskData.isFastRect()) { var matrix = maskData.worldTransform; var rot = Math.atan2(matrix.b, matrix.a);
                        rot = Math.round(rot * (180 / Math.PI)); if (rot % 90) { this.pushStencilMask(maskData); } else { this.pushScissorMask(target, maskData); } } else { this.pushStencilMask(maskData); } };
                MaskManager.prototype.popMask = function popMask(target, maskData) { if (maskData.texture) { this.popSpriteMask(target, maskData); } else if (this.enableScissor && !this.renderer.stencilManager.stencilMaskStack.length) { this.popScissorMask(target, maskData); } else { this.popStencilMask(target, maskData); } };
                MaskManager.prototype.pushSpriteMask = function pushSpriteMask(target, maskData) {
                    var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
                    if (!alphaMaskFilter) { alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new _SpriteMaskFilter2.default(maskData)]; }
                    alphaMaskFilter[0].resolution = this.renderer.resolution;
                    alphaMaskFilter[0].maskSprite = maskData;
                    target.filterArea = maskData.getBounds(true);
                    this.renderer.filterManager.pushFilter(target, alphaMaskFilter);
                    this.alphaMaskIndex++;
                };
                MaskManager.prototype.popSpriteMask = function popSpriteMask() { this.renderer.filterManager.popFilter();
                    this.alphaMaskIndex--; };
                MaskManager.prototype.pushStencilMask = function pushStencilMask(maskData) { this.renderer.currentRenderer.stop();
                    this.renderer.stencilManager.pushStencil(maskData); };
                MaskManager.prototype.popStencilMask = function popStencilMask() { this.renderer.currentRenderer.stop();
                    this.renderer.stencilManager.popStencil(); };
                MaskManager.prototype.pushScissorMask = function pushScissorMask(target, maskData) { maskData.renderable = true; var renderTarget = this.renderer._activeRenderTarget; var bounds = maskData.getBounds();
                    bounds.fit(renderTarget.size);
                    maskData.renderable = false;
                    this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST); var resolution = this.renderer.resolution;
                    this.renderer.gl.scissor(bounds.x * resolution, (renderTarget.root ? renderTarget.size.height - bounds.y - bounds.height : bounds.y) * resolution, bounds.width * resolution, bounds.height * resolution);
                    this.scissorRenderTarget = renderTarget;
                    this.scissorData = maskData;
                    this.scissor = true; };
                MaskManager.prototype.popScissorMask = function popScissorMask() { this.scissorRenderTarget = null;
                    this.scissorData = null;
                    this.scissor = false; var gl = this.renderer.gl;
                    gl.disable(gl.SCISSOR_TEST); };
                return MaskManager;
            }(_WebGLManager3.default);
            exports.default = MaskManager;
        }, { "../filters/spriteMask/SpriteMaskFilter": 87, "./WebGLManager": 91 }],
        90: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _WebGLManager2 = require('./WebGLManager');
            var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var StencilManager = function(_WebGLManager) {
                _inherits(StencilManager, _WebGLManager);

                function StencilManager(renderer) { _classCallCheck(this, StencilManager); var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));
                    _this.stencilMaskStack = null; return _this; }
                StencilManager.prototype.setMaskStack = function setMaskStack(stencilMaskStack) { this.stencilMaskStack = stencilMaskStack; var gl = this.renderer.gl; if (stencilMaskStack.length === 0) { gl.disable(gl.STENCIL_TEST); } else { gl.enable(gl.STENCIL_TEST); } };
                StencilManager.prototype.pushStencil = function pushStencil(graphics) {
                    this.renderer.setObjectRenderer(this.renderer.plugins.graphics);
                    this.renderer._activeRenderTarget.attachStencilBuffer();
                    var gl = this.renderer.gl;
                    var sms = this.stencilMaskStack;
                    if (sms.length === 0) { gl.enable(gl.STENCIL_TEST);
                        gl.clear(gl.STENCIL_BUFFER_BIT);
                        gl.stencilFunc(gl.ALWAYS, 1, 1); }
                    sms.push(graphics);
                    gl.colorMask(false, false, false, false);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                    this.renderer.plugins.graphics.render(graphics);
                    gl.colorMask(true, true, true, true);
                    gl.stencilFunc(gl.NOTEQUAL, 0, sms.length);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                };
                StencilManager.prototype.popStencil = function popStencil() { this.renderer.setObjectRenderer(this.renderer.plugins.graphics); var gl = this.renderer.gl; var sms = this.stencilMaskStack; var graphics = sms.pop(); if (sms.length === 0) { gl.disable(gl.STENCIL_TEST); } else { gl.colorMask(false, false, false, false);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                        this.renderer.plugins.graphics.render(graphics);
                        gl.colorMask(true, true, true, true);
                        gl.stencilFunc(gl.NOTEQUAL, 0, sms.length);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP); } };
                StencilManager.prototype.destroy = function destroy() { _WebGLManager3.default.prototype.destroy.call(this);
                    this.stencilMaskStack.stencilStack = null; };
                return StencilManager;
            }(_WebGLManager3.default);
            exports.default = StencilManager;
        }, { "./WebGLManager": 91 }],
        91: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var WebGLManager = function() {
                function WebGLManager(renderer) { _classCallCheck(this, WebGLManager);
                    this.renderer = renderer;
                    this.renderer.on('context', this.onContextChange, this); }
                WebGLManager.prototype.onContextChange = function onContextChange() {};
                WebGLManager.prototype.destroy = function destroy() { this.renderer.off('context', this.onContextChange, this);
                    this.renderer = null; };
                return WebGLManager;
            }();
            exports.default = WebGLManager;
        }, {}],
        92: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _WebGLManager2 = require('../managers/WebGLManager');
            var _WebGLManager3 = _interopRequireDefault(_WebGLManager2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var ObjectRenderer = function(_WebGLManager) {
                _inherits(ObjectRenderer, _WebGLManager);

                function ObjectRenderer() { _classCallCheck(this, ObjectRenderer); return _possibleConstructorReturn(this, _WebGLManager.apply(this, arguments)); }
                ObjectRenderer.prototype.start = function start() {};
                ObjectRenderer.prototype.stop = function stop() { this.flush(); };
                ObjectRenderer.prototype.flush = function flush() {};
                ObjectRenderer.prototype.render = function render(object) {};
                return ObjectRenderer;
            }(_WebGLManager3.default);
            exports.default = ObjectRenderer;
        }, { "../managers/WebGLManager": 91 }],
        93: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _pixiGlCore = require('pixi-gl-core');
            var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);
            var _createIndicesForQuads = require('../../../utils/createIndicesForQuads');
            var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var Quad = function() {
                function Quad(gl, state) {
                    _classCallCheck(this, Quad);
                    this.gl = gl;
                    this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);
                    this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
                    this.interleaved = new Float32Array(8 * 2);
                    for (var i = 0; i < 4; i++) { this.interleaved[i * 4] = this.vertices[i * 2];
                        this.interleaved[i * 4 + 1] = this.vertices[i * 2 + 1];
                        this.interleaved[i * 4 + 2] = this.uvs[i * 2];
                        this.interleaved[i * 4 + 3] = this.uvs[i * 2 + 1]; }
                    this.indices = (0, _createIndicesForQuads2.default)(1);
                    this.vertexBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, this.interleaved, gl.STATIC_DRAW);
                    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);
                    this.vao = new _pixiGlCore2.default.VertexArrayObject(gl, state);
                }
                Quad.prototype.initVao = function initVao(shader) { this.vao.clear().addIndex(this.indexBuffer).addAttribute(this.vertexBuffer, shader.attributes.aVertexPosition, this.gl.FLOAT, false, 4 * 4, 0).addAttribute(this.vertexBuffer, shader.attributes.aTextureCoord, this.gl.FLOAT, false, 4 * 4, 2 * 4); };
                Quad.prototype.map = function map(targetTextureFrame, destinationFrame) { var x = 0; var y = 0;
                    this.uvs[0] = x;
                    this.uvs[1] = y;
                    this.uvs[2] = x + destinationFrame.width / targetTextureFrame.width;
                    this.uvs[3] = y;
                    this.uvs[4] = x + destinationFrame.width / targetTextureFrame.width;
                    this.uvs[5] = y + destinationFrame.height / targetTextureFrame.height;
                    this.uvs[6] = x;
                    this.uvs[7] = y + destinationFrame.height / targetTextureFrame.height;
                    x = destinationFrame.x;
                    y = destinationFrame.y;
                    this.vertices[0] = x;
                    this.vertices[1] = y;
                    this.vertices[2] = x + destinationFrame.width;
                    this.vertices[3] = y;
                    this.vertices[4] = x + destinationFrame.width;
                    this.vertices[5] = y + destinationFrame.height;
                    this.vertices[6] = x;
                    this.vertices[7] = y + destinationFrame.height; return this; };
                Quad.prototype.upload = function upload() {
                    for (var i = 0; i < 4; i++) { this.interleaved[i * 4] = this.vertices[i * 2];
                        this.interleaved[i * 4 + 1] = this.vertices[i * 2 + 1];
                        this.interleaved[i * 4 + 2] = this.uvs[i * 2];
                        this.interleaved[i * 4 + 3] = this.uvs[i * 2 + 1]; }
                    this.vertexBuffer.upload(this.interleaved);
                    return this;
                };
                Quad.prototype.destroy = function destroy() { var gl = this.gl;
                    gl.deleteBuffer(this.vertexBuffer);
                    gl.deleteBuffer(this.indexBuffer); };
                return Quad;
            }();
            exports.default = Quad;
        }, { "../../../utils/createIndicesForQuads": 120, "pixi-gl-core": 12 }],
        94: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _math = require('../../../math');
            var _const = require('../../../const');
            var _settings = require('../../../settings');
            var _settings2 = _interopRequireDefault(_settings);
            var _pixiGlCore = require('pixi-gl-core');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var RenderTarget = function() {
                function RenderTarget(gl, width, height, scaleMode, resolution, root) {
                    _classCallCheck(this, RenderTarget);
                    this.gl = gl;
                    this.frameBuffer = null;
                    this.texture = null;
                    this.clearColor = [0, 0, 0, 0];
                    this.size = new _math.Rectangle(0, 0, 1, 1);
                    this.resolution = resolution || _settings2.default.RESOLUTION;
                    this.projectionMatrix = new _math.Matrix();
                    this.transform = null;
                    this.frame = null;
                    this.defaultFrame = new _math.Rectangle();
                    this.destinationFrame = null;
                    this.sourceFrame = null;
                    this.stencilBuffer = null;
                    this.stencilMaskStack = [];
                    this.filterData = null;
                    this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;
                    this.root = root;
                    if (!this.root) {
                        this.frameBuffer = _pixiGlCore.GLFramebuffer.createRGBA(gl, 100, 100);
                        if (this.scaleMode === _const.SCALE_MODES.NEAREST) { this.frameBuffer.texture.enableNearestScaling(); } else { this.frameBuffer.texture.enableLinearScaling(); }
                        this.texture = this.frameBuffer.texture;
                    } else { this.frameBuffer = new _pixiGlCore.GLFramebuffer(gl, 100, 100);
                        this.frameBuffer.framebuffer = null; }
                    this.setFrame();
                    this.resize(width, height);
                }
                RenderTarget.prototype.clear = function clear(clearColor) { var cc = clearColor || this.clearColor;
                    this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]); };
                RenderTarget.prototype.attachStencilBuffer = function attachStencilBuffer() { if (!this.root) { this.frameBuffer.enableStencil(); } };
                RenderTarget.prototype.setFrame = function setFrame(destinationFrame, sourceFrame) { this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
                    this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame; };
                RenderTarget.prototype.activate = function activate() {
                    var gl = this.gl;
                    this.frameBuffer.bind();
                    this.calculateProjection(this.destinationFrame, this.sourceFrame);
                    if (this.transform) { this.projectionMatrix.append(this.transform); }
                    if (this.destinationFrame !== this.sourceFrame) { gl.enable(gl.SCISSOR_TEST);
                        gl.scissor(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0); } else { gl.disable(gl.SCISSOR_TEST); }
                    gl.viewport(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
                };
                RenderTarget.prototype.calculateProjection = function calculateProjection(destinationFrame, sourceFrame) { var pm = this.projectionMatrix;
                    sourceFrame = sourceFrame || destinationFrame;
                    pm.identity(); if (!this.root) { pm.a = 1 / destinationFrame.width * 2;
                        pm.d = 1 / destinationFrame.height * 2;
                        pm.tx = -1 - sourceFrame.x * pm.a;
                        pm.ty = -1 - sourceFrame.y * pm.d; } else { pm.a = 1 / destinationFrame.width * 2;
                        pm.d = -1 / destinationFrame.height * 2;
                        pm.tx = -1 - sourceFrame.x * pm.a;
                        pm.ty = 1 - sourceFrame.y * pm.d; } };
                RenderTarget.prototype.resize = function resize(width, height) {
                    width = width | 0;
                    height = height | 0;
                    if (this.size.width === width && this.size.height === height) { return; }
                    this.size.width = width;
                    this.size.height = height;
                    this.defaultFrame.width = width;
                    this.defaultFrame.height = height;
                    this.frameBuffer.resize(width * this.resolution, height * this.resolution);
                    var projectionFrame = this.frame || this.size;
                    this.calculateProjection(projectionFrame);
                };
                RenderTarget.prototype.destroy = function destroy() { this.frameBuffer.destroy();
                    this.frameBuffer = null;
                    this.texture = null; };
                return RenderTarget;
            }();
            exports.default = RenderTarget;
        }, { "../../../const": 44, "../../../math": 68, "../../../settings": 99, "pixi-gl-core": 12 }],
        95: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = checkMaxIfStatmentsInShader;
            var _pixiGlCore = require('pixi-gl-core');
            var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            var fragTemplate = ['precision mediump float;', 'void main(void){', 'float test = 0.1;', '%forloop%', 'gl_FragColor = vec4(0.0);', '}'].join('\n');

            function checkMaxIfStatmentsInShader(maxIfs, gl) {
                var createTempContext = !gl;
                if (maxIfs === 0) { throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`'); }
                if (createTempContext) { var tinyCanvas = document.createElement('canvas');
                    tinyCanvas.width = 1;
                    tinyCanvas.height = 1;
                    gl = _pixiGlCore2.default.createContext(tinyCanvas); }
                var shader = gl.createShader(gl.FRAGMENT_SHADER);
                while (true) { var fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));
                    gl.shaderSource(shader, fragmentSrc);
                    gl.compileShader(shader); if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) { maxIfs = maxIfs / 2 | 0; } else { break; } }
                if (createTempContext) { if (gl.getExtension('WEBGL_lose_context')) { gl.getExtension('WEBGL_lose_context').loseContext(); } }
                return maxIfs;
            }

            function generateIfTestSrc(maxIfs) {
                var src = '';
                for (var i = 0; i < maxIfs; ++i) {
                    if (i > 0) { src += '\nelse '; }
                    if (i < maxIfs - 1) { src += 'if(test == ' + i + '.0){}'; }
                }
                return src;
            }
        }, { "pixi-gl-core": 12 }],
        96: [function(require, module, exports) { 'use strict';
            exports.__esModule = true;
            exports.default = mapWebGLBlendModesToPixi; var _const = require('../../../const');

            function mapWebGLBlendModesToPixi(gl) { var array = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
                array[_const.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.ADD] = [gl.ONE, gl.DST_ALPHA];
                array[_const.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR];
                array[_const.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
                array[_const.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA]; return array; } }, { "../../../const": 44 }],
        97: [function(require, module, exports) { 'use strict';
            exports.__esModule = true;
            exports.default = mapWebGLDrawModesToPixi; var _const = require('../../../const');

            function mapWebGLDrawModesToPixi(gl) { var object = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                object[_const.DRAW_MODES.POINTS] = gl.POINTS;
                object[_const.DRAW_MODES.LINES] = gl.LINES;
                object[_const.DRAW_MODES.LINE_LOOP] = gl.LINE_LOOP;
                object[_const.DRAW_MODES.LINE_STRIP] = gl.LINE_STRIP;
                object[_const.DRAW_MODES.TRIANGLES] = gl.TRIANGLES;
                object[_const.DRAW_MODES.TRIANGLE_STRIP] = gl.TRIANGLE_STRIP;
                object[_const.DRAW_MODES.TRIANGLE_FAN] = gl.TRIANGLE_FAN; return object; } }, { "../../../const": 44 }],
        98: [function(require, module, exports) { 'use strict';
            exports.__esModule = true;
            exports.default = validateContext;

            function validateContext(gl) { var attributes = gl.getContextAttributes(); if (!attributes.stencil) { console.warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly'); } } }, {}],
        99: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _maxRecommendedTextures = require('./utils/maxRecommendedTextures');
            var _maxRecommendedTextures2 = _interopRequireDefault(_maxRecommendedTextures);
            var _canUploadSameBuffer = require('./utils/canUploadSameBuffer');
            var _canUploadSameBuffer2 = _interopRequireDefault(_canUploadSameBuffer);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            exports.default = { TARGET_FPMS: 0.06, MIPMAP_TEXTURES: true, RESOLUTION: 1, FILTER_RESOLUTION: 1, SPRITE_MAX_TEXTURES: (0, _maxRecommendedTextures2.default)(32), SPRITE_BATCH_SIZE: 4096, RETINA_PREFIX: /@([0-9\.]+)x/, RENDER_OPTIONS: { view: null, antialias: false, forceFXAA: false, autoResize: false, transparent: false, backgroundColor: 0x000000, clearBeforeRender: true, preserveDrawingBuffer: false, roundPixels: false, width: 800, height: 600, legacy: false }, TRANSFORM_MODE: 0, GC_MODE: 0, GC_MAX_IDLE: 60 * 60, GC_MAX_CHECK_COUNT: 60 * 10, WRAP_MODE: 0, SCALE_MODE: 0, PRECISION_VERTEX: 'highp', PRECISION_FRAGMENT: 'mediump', CAN_UPLOAD_SAME_BUFFER: (0, _canUploadSameBuffer2.default)() };
        }, { "./utils/canUploadSameBuffer": 119, "./utils/maxRecommendedTextures": 123 }],
        100: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _math = require('../math');
            var _utils = require('../utils');
            var _const = require('../const');
            var _Texture = require('../textures/Texture');
            var _Texture2 = _interopRequireDefault(_Texture);
            var _Container2 = require('../display/Container');
            var _Container3 = _interopRequireDefault(_Container2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var tempPoint = new _math.Point();
            var Sprite = function(_Container) {
                _inherits(Sprite, _Container);

                function Sprite(texture) { _classCallCheck(this, Sprite); var _this = _possibleConstructorReturn(this, _Container.call(this));
                    _this._anchor = new _math.ObservablePoint(_this._onAnchorUpdate, _this);
                    _this._texture = null;
                    _this._width = 0;
                    _this._height = 0;
                    _this._tint = null;
                    _this._tintRGB = null;
                    _this.tint = 0xFFFFFF;
                    _this.blendMode = _const.BLEND_MODES.NORMAL;
                    _this.shader = null;
                    _this.cachedTint = 0xFFFFFF;
                    _this.texture = texture || _Texture2.default.EMPTY;
                    _this.vertexData = new Float32Array(8);
                    _this.vertexTrimmedData = null;
                    _this._transformID = -1;
                    _this._textureID = -1;
                    _this._transformTrimmedID = -1;
                    _this._textureTrimmedID = -1;
                    _this.pluginName = 'sprite'; return _this; }
                Sprite.prototype._onTextureUpdate = function _onTextureUpdate() {
                    this._textureID = -1;
                    this._textureTrimmedID = -1;
                    if (this._width) { this.scale.x = (0, _utils.sign)(this.scale.x) * this._width / this._texture.orig.width; }
                    if (this._height) { this.scale.y = (0, _utils.sign)(this.scale.y) * this._height / this._texture.orig.height; }
                };
                Sprite.prototype._onAnchorUpdate = function _onAnchorUpdate() { this._transformID = -1;
                    this._transformTrimmedID = -1; };
                Sprite.prototype.calculateVertices = function calculateVertices() {
                    if (this._transformID === this.transform._worldID && this._textureID === this._texture._updateID) { return; }
                    this._transformID = this.transform._worldID;
                    this._textureID = this._texture._updateID;
                    var texture = this._texture;
                    var wt = this.transform.worldTransform;
                    var a = wt.a;
                    var b = wt.b;
                    var c = wt.c;
                    var d = wt.d;
                    var tx = wt.tx;
                    var ty = wt.ty;
                    var vertexData = this.vertexData;
                    var trim = texture.trim;
                    var orig = texture.orig;
                    var anchor = this._anchor;
                    var w0 = 0;
                    var w1 = 0;
                    var h0 = 0;
                    var h1 = 0;
                    if (trim) { w1 = trim.x - anchor._x * orig.width;
                        w0 = w1 + trim.width;
                        h1 = trim.y - anchor._y * orig.height;
                        h0 = h1 + trim.height; } else { w1 = -anchor._x * orig.width;
                        w0 = w1 + orig.width;
                        h1 = -anchor._y * orig.height;
                        h0 = h1 + orig.height; }
                    vertexData[0] = a * w1 + c * h1 + tx;
                    vertexData[1] = d * h1 + b * w1 + ty;
                    vertexData[2] = a * w0 + c * h1 + tx;
                    vertexData[3] = d * h1 + b * w0 + ty;
                    vertexData[4] = a * w0 + c * h0 + tx;
                    vertexData[5] = d * h0 + b * w0 + ty;
                    vertexData[6] = a * w1 + c * h0 + tx;
                    vertexData[7] = d * h0 + b * w1 + ty;
                };
                Sprite.prototype.calculateTrimmedVertices = function calculateTrimmedVertices() {
                    if (!this.vertexTrimmedData) { this.vertexTrimmedData = new Float32Array(8); } else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) { return; }
                    this._transformTrimmedID = this.transform._worldID;
                    this._textureTrimmedID = this._texture._updateID;
                    var texture = this._texture;
                    var vertexData = this.vertexTrimmedData;
                    var orig = texture.orig;
                    var anchor = this._anchor;
                    var wt = this.transform.worldTransform;
                    var a = wt.a;
                    var b = wt.b;
                    var c = wt.c;
                    var d = wt.d;
                    var tx = wt.tx;
                    var ty = wt.ty;
                    var w1 = -anchor._x * orig.width;
                    var w0 = w1 + orig.width;
                    var h1 = -anchor._y * orig.height;
                    var h0 = h1 + orig.height;
                    vertexData[0] = a * w1 + c * h1 + tx;
                    vertexData[1] = d * h1 + b * w1 + ty;
                    vertexData[2] = a * w0 + c * h1 + tx;
                    vertexData[3] = d * h1 + b * w0 + ty;
                    vertexData[4] = a * w0 + c * h0 + tx;
                    vertexData[5] = d * h0 + b * w0 + ty;
                    vertexData[6] = a * w1 + c * h0 + tx;
                    vertexData[7] = d * h0 + b * w1 + ty;
                };
                Sprite.prototype._renderWebGL = function _renderWebGL(renderer) { this.calculateVertices();
                    renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
                    renderer.plugins[this.pluginName].render(this); };
                Sprite.prototype._renderCanvas = function _renderCanvas(renderer) { renderer.plugins[this.pluginName].render(this); };
                Sprite.prototype._calculateBounds = function _calculateBounds() { var trim = this._texture.trim; var orig = this._texture.orig; if (!trim || trim.width === orig.width && trim.height === orig.height) { this.calculateVertices();
                        this._bounds.addQuad(this.vertexData); } else { this.calculateTrimmedVertices();
                        this._bounds.addQuad(this.vertexTrimmedData); } };
                Sprite.prototype.getLocalBounds = function getLocalBounds(rect) {
                    if (this.children.length === 0) {
                        this._bounds.minX = this._texture.orig.width * -this._anchor._x;
                        this._bounds.minY = this._texture.orig.height * -this._anchor._y;
                        this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
                        this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._x);
                        if (!rect) {
                            if (!this._localBoundsRect) { this._localBoundsRect = new _math.Rectangle(); }
                            rect = this._localBoundsRect;
                        }
                        return this._bounds.getRectangle(rect);
                    }
                    return _Container.prototype.getLocalBounds.call(this, rect);
                };
                Sprite.prototype.containsPoint = function containsPoint(point) {
                    this.worldTransform.applyInverse(point, tempPoint);
                    var width = this._texture.orig.width;
                    var height = this._texture.orig.height;
                    var x1 = -width * this.anchor.x;
                    var y1 = 0;
                    if (tempPoint.x > x1 && tempPoint.x < x1 + width) { y1 = -height * this.anchor.y; if (tempPoint.y > y1 && tempPoint.y < y1 + height) { return true; } }
                    return false;
                };
                Sprite.prototype.destroy = function destroy(options) {
                    _Container.prototype.destroy.call(this, options);
                    this._anchor = null;
                    var destroyTexture = typeof options === 'boolean' ? options : options && options.texture;
                    if (destroyTexture) { var destroyBaseTexture = typeof options === 'boolean' ? options : options && options.baseTexture;
                        this._texture.destroy(!!destroyBaseTexture); }
                    this._texture = null;
                    this.shader = null;
                };
                Sprite.from = function from(source) { return new Sprite(_Texture2.default.from(source)); };
                Sprite.fromFrame = function fromFrame(frameId) {
                    var texture = _utils.TextureCache[frameId];
                    if (!texture) { throw new Error('The frameId "' + frameId + '" does not exist in the texture cache'); }
                    return new Sprite(texture);
                };
                Sprite.fromImage = function fromImage(imageId, crossorigin, scaleMode) { return new Sprite(_Texture2.default.fromImage(imageId, crossorigin, scaleMode)); };
                _createClass(Sprite, [{
                    key: 'width',
                    get: function get() { return Math.abs(this.scale.x) * this._texture.orig.width; },
                    set: function set(value) { var s = (0, _utils.sign)(this.scale.x) || 1;
                        this.scale.x = s * value / this._texture.orig.width;
                        this._width = value; }
                }, {
                    key: 'height',
                    get: function get() { return Math.abs(this.scale.y) * this._texture.orig.height; },
                    set: function set(value) { var s = (0, _utils.sign)(this.scale.y) || 1;
                        this.scale.y = s * value / this._texture.orig.height;
                        this._height = value; }
                }, {
                    key: 'anchor',
                    get: function get() { return this._anchor; },
                    set: function set(value) { this._anchor.copy(value); }
                }, {
                    key: 'tint',
                    get: function get() { return this._tint; },
                    set: function set(value) { this._tint = value;
                        this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16); }
                }, {
                    key: 'texture',
                    get: function get() { return this._texture; },
                    set: function set(value) {
                        if (this._texture === value) { return; }
                        this._texture = value;
                        this.cachedTint = 0xFFFFFF;
                        this._textureID = -1;
                        this._textureTrimmedID = -1;
                        if (value) { if (value.baseTexture.hasLoaded) { this._onTextureUpdate(); } else { value.once('update', this._onTextureUpdate, this); } }
                    }
                }]);
                return Sprite;
            }(_Container3.default);
            exports.default = Sprite;
        }, { "../const": 44, "../display/Container": 46, "../math": 68, "../textures/Texture": 113, "../utils": 122 }],
        101: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _CanvasRenderer = require('../../renderers/canvas/CanvasRenderer');
            var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);
            var _const = require('../../const');
            var _math = require('../../math');
            var _CanvasTinter = require('./CanvasTinter');
            var _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var canvasRenderWorldTransform = new _math.Matrix();
            var CanvasSpriteRenderer = function() {
                function CanvasSpriteRenderer(renderer) { _classCallCheck(this, CanvasSpriteRenderer);
                    this.renderer = renderer; }
                CanvasSpriteRenderer.prototype.render = function render(sprite) {
                    var texture = sprite._texture;
                    var renderer = this.renderer;
                    var width = texture._frame.width;
                    var height = texture._frame.height;
                    var wt = sprite.transform.worldTransform;
                    var dx = 0;
                    var dy = 0;
                    if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.baseTexture.source) { return; }
                    renderer.setBlendMode(sprite.blendMode);
                    if (texture.valid) {
                        renderer.context.globalAlpha = sprite.worldAlpha;
                        var smoothingEnabled = texture.baseTexture.scaleMode === _const.SCALE_MODES.LINEAR;
                        if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled) { renderer.context[renderer.smoothProperty] = smoothingEnabled; }
                        if (texture.trim) { dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;
                            dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height; } else { dx = (0.5 - sprite.anchor.x) * texture.orig.width;
                            dy = (0.5 - sprite.anchor.y) * texture.orig.height; }
                        if (texture.rotate) { wt.copy(canvasRenderWorldTransform);
                            wt = canvasRenderWorldTransform;
                            _math.GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);
                            dx = 0;
                            dy = 0; }
                        dx -= width / 2;
                        dy -= height / 2;
                        if (renderer.roundPixels) { renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution | 0, wt.ty * renderer.resolution | 0);
                            dx = dx | 0;
                            dy = dy | 0; } else { renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution); }
                        var resolution = texture.baseTexture.resolution;
                        if (sprite.tint !== 0xFFFFFF) {
                            if (sprite.cachedTint !== sprite.tint) { sprite.cachedTint = sprite.tint;
                                sprite.tintedTexture = _CanvasTinter2.default.getTintedTexture(sprite, sprite.tint); }
                            renderer.context.drawImage(sprite.tintedTexture, 0, 0, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);
                        } else { renderer.context.drawImage(texture.baseTexture.source, texture._frame.x * resolution, texture._frame.y * resolution, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution); }
                    }
                };
                CanvasSpriteRenderer.prototype.destroy = function destroy() { this.renderer = null; };
                return CanvasSpriteRenderer;
            }();
            exports.default = CanvasSpriteRenderer;
            _CanvasRenderer2.default.registerPlugin('sprite', CanvasSpriteRenderer);
        }, { "../../const": 44, "../../math": 68, "../../renderers/canvas/CanvasRenderer": 75, "./CanvasTinter": 102 }],
        102: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _utils = require('../../utils');
            var _canUseNewCanvasBlendModes = require('../../renderers/canvas/utils/canUseNewCanvasBlendModes');
            var _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            var CanvasTinter = {
                getTintedTexture: function getTintedTexture(sprite, color) {
                    var texture = sprite._texture;
                    color = CanvasTinter.roundColor(color);
                    var stringColor = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
                    texture.tintCache = texture.tintCache || {};
                    if (texture.tintCache[stringColor]) { return texture.tintCache[stringColor]; }
                    var canvas = CanvasTinter.canvas || document.createElement('canvas');
                    CanvasTinter.tintMethod(texture, color, canvas);
                    if (CanvasTinter.convertTintToImage) { var tintImage = new Image();
                        tintImage.src = canvas.toDataURL();
                        texture.tintCache[stringColor] = tintImage; } else { texture.tintCache[stringColor] = canvas;
                        CanvasTinter.canvas = null; }
                    return canvas;
                },
                tintWithMultiply: function tintWithMultiply(texture, color, canvas) { var context = canvas.getContext('2d'); var crop = texture._frame.clone(); var resolution = texture.baseTexture.resolution;
                    crop.x *= resolution;
                    crop.y *= resolution;
                    crop.width *= resolution;
                    crop.height *= resolution;
                    canvas.width = Math.ceil(crop.width);
                    canvas.height = Math.ceil(crop.height);
                    context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
                    context.fillRect(0, 0, crop.width, crop.height);
                    context.globalCompositeOperation = 'multiply';
                    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
                    context.globalCompositeOperation = 'destination-atop';
                    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height); },
                tintWithOverlay: function tintWithOverlay(texture, color, canvas) { var context = canvas.getContext('2d'); var crop = texture._frame.clone(); var resolution = texture.baseTexture.resolution;
                    crop.x *= resolution;
                    crop.y *= resolution;
                    crop.width *= resolution;
                    crop.height *= resolution;
                    canvas.width = Math.ceil(crop.width);
                    canvas.height = Math.ceil(crop.height);
                    context.globalCompositeOperation = 'copy';
                    context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);
                    context.fillRect(0, 0, crop.width, crop.height);
                    context.globalCompositeOperation = 'destination-atop';
                    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height); },
                tintWithPerPixel: function tintWithPerPixel(texture, color, canvas) {
                    var context = canvas.getContext('2d');
                    var crop = texture._frame.clone();
                    var resolution = texture.baseTexture.resolution;
                    crop.x *= resolution;
                    crop.y *= resolution;
                    crop.width *= resolution;
                    crop.height *= resolution;
                    canvas.width = Math.ceil(crop.width);
                    canvas.height = Math.ceil(crop.height);
                    context.globalCompositeOperation = 'copy';
                    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);
                    var rgbValues = (0, _utils.hex2rgb)(color);
                    var r = rgbValues[0];
                    var g = rgbValues[1];
                    var b = rgbValues[2];
                    var pixelData = context.getImageData(0, 0, crop.width, crop.height);
                    var pixels = pixelData.data;
                    for (var i = 0; i < pixels.length; i += 4) { pixels[i + 0] *= r;
                        pixels[i + 1] *= g;
                        pixels[i + 2] *= b; }
                    context.putImageData(pixelData, 0, 0);
                },
                roundColor: function roundColor(color) { var step = CanvasTinter.cacheStepsPerColorChannel; var rgbValues = (0, _utils.hex2rgb)(color);
                    rgbValues[0] = Math.min(255, rgbValues[0] / step * step);
                    rgbValues[1] = Math.min(255, rgbValues[1] / step * step);
                    rgbValues[2] = Math.min(255, rgbValues[2] / step * step); return (0, _utils.rgb2hex)(rgbValues); },
                cacheStepsPerColorChannel: 8,
                convertTintToImage: false,
                canUseMultiply: (0, _canUseNewCanvasBlendModes2.default)(),
                tintMethod: 0
            };
            CanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;
            exports.default = CanvasTinter;
        }, { "../../renderers/canvas/utils/canUseNewCanvasBlendModes": 78, "../../utils": 122 }],
        103: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var Buffer = function() {
                function Buffer(size) { _classCallCheck(this, Buffer);
                    this.vertices = new ArrayBuffer(size);
                    this.float32View = new Float32Array(this.vertices);
                    this.uint32View = new Uint32Array(this.vertices); }
                Buffer.prototype.destroy = function destroy() { this.vertices = null;
                    this.positions = null;
                    this.uvs = null;
                    this.colors = null; };
                return Buffer;
            }();
            exports.default = Buffer;
        }, {}],
        104: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _ObjectRenderer2 = require('../../renderers/webgl/utils/ObjectRenderer');
            var _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);
            var _WebGLRenderer = require('../../renderers/webgl/WebGLRenderer');
            var _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);
            var _createIndicesForQuads = require('../../utils/createIndicesForQuads');
            var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);
            var _generateMultiTextureShader = require('./generateMultiTextureShader');
            var _generateMultiTextureShader2 = _interopRequireDefault(_generateMultiTextureShader);
            var _checkMaxIfStatmentsInShader = require('../../renderers/webgl/utils/checkMaxIfStatmentsInShader');
            var _checkMaxIfStatmentsInShader2 = _interopRequireDefault(_checkMaxIfStatmentsInShader);
            var _BatchBuffer = require('./BatchBuffer');
            var _BatchBuffer2 = _interopRequireDefault(_BatchBuffer);
            var _settings = require('../../settings');
            var _settings2 = _interopRequireDefault(_settings);
            var _pixiGlCore = require('pixi-gl-core');
            var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);
            var _bitTwiddle = require('bit-twiddle');
            var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var TICK = 0;
            var TEXTURE_TICK = 0;
            var SpriteRenderer = function(_ObjectRenderer) {
                _inherits(SpriteRenderer, _ObjectRenderer);

                function SpriteRenderer(renderer) {
                    _classCallCheck(this, SpriteRenderer);
                    var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));
                    _this.vertSize = 5;
                    _this.vertByteSize = _this.vertSize * 4;
                    _this.size = _settings2.default.SPRITE_BATCH_SIZE;
                    _this.buffers = [];
                    for (var i = 1; i <= _bitTwiddle2.default.nextPow2(_this.size); i *= 2) { _this.buffers.push(new _BatchBuffer2.default(i * 4 * _this.vertByteSize)); }
                    _this.indices = (0, _createIndicesForQuads2.default)(_this.size);
                    _this.shader = null;
                    _this.currentIndex = 0;
                    _this.groups = [];
                    for (var k = 0; k < _this.size; k++) { _this.groups[k] = { textures: [], textureCount: 0, ids: [], size: 0, start: 0, blend: 0 }; }
                    _this.sprites = [];
                    _this.vertexBuffers = [];
                    _this.vaos = [];
                    _this.vaoMax = 2;
                    _this.vertexCount = 0;
                    _this.renderer.on('prerender', _this.onPrerender, _this);
                    return _this;
                }
                SpriteRenderer.prototype.onContextChange = function onContextChange() {
                    var gl = this.renderer.gl;
                    if (this.renderer.legacy) { this.MAX_TEXTURES = 1; } else { this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _settings2.default.SPRITE_MAX_TEXTURES);
                        this.MAX_TEXTURES = (0, _checkMaxIfStatmentsInShader2.default)(this.MAX_TEXTURES, gl); }
                    this.shader = (0, _generateMultiTextureShader2.default)(gl, this.MAX_TEXTURES);
                    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);
                    this.renderer.bindVao(null);
                    var attrs = this.shader.attributes;
                    for (var i = 0; i < this.vaoMax; i++) {
                        var vertexBuffer = this.vertexBuffers[i] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);
                        var vao = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);
                        if (attrs.aTextureId) { vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4); }
                        this.vaos[i] = vao;
                    }
                    this.vao = this.vaos[0];
                    this.currentBlendMode = 99999;
                    this.boundTextures = new Array(this.MAX_TEXTURES);
                };
                SpriteRenderer.prototype.onPrerender = function onPrerender() { this.vertexCount = 0; };
                SpriteRenderer.prototype.render = function render(sprite) {
                    if (this.currentIndex >= this.size) { this.flush(); }
                    if (!sprite._texture._uvs) { return; }
                    this.sprites[this.currentIndex++] = sprite;
                };
                SpriteRenderer.prototype.flush = function flush() {
                    if (this.currentIndex === 0) { return; }
                    var gl = this.renderer.gl;
                    var MAX_TEXTURES = this.MAX_TEXTURES;
                    var np2 = _bitTwiddle2.default.nextPow2(this.currentIndex);
                    var log2 = _bitTwiddle2.default.log2(np2);
                    var buffer = this.buffers[log2];
                    var sprites = this.sprites;
                    var groups = this.groups;
                    var float32View = buffer.float32View;
                    var uint32View = buffer.uint32View;
                    var boundTextures = this.boundTextures;
                    var rendererBoundTextures = this.renderer.boundTextures;
                    var touch = this.renderer.textureGC.count;
                    var index = 0;
                    var nextTexture = void 0;
                    var currentTexture = void 0;
                    var groupCount = 1;
                    var textureCount = 0;
                    var currentGroup = groups[0];
                    var vertexData = void 0;
                    var uvs = void 0;
                    var blendMode = sprites[0].blendMode;
                    currentGroup.textureCount = 0;
                    currentGroup.start = 0;
                    currentGroup.blend = blendMode;
                    TICK++;
                    var i = void 0;
                    for (i = 0; i < MAX_TEXTURES; ++i) { boundTextures[i] = rendererBoundTextures[i];
                        boundTextures[i]._virtalBoundId = i; }
                    for (i = 0; i < this.currentIndex; ++i) {
                        var sprite = sprites[i];
                        nextTexture = sprite._texture.baseTexture;
                        if (blendMode !== sprite.blendMode) { blendMode = sprite.blendMode;
                            currentTexture = null;
                            textureCount = MAX_TEXTURES;
                            TICK++; }
                        if (currentTexture !== nextTexture) {
                            currentTexture = nextTexture;
                            if (nextTexture._enabled !== TICK) {
                                if (textureCount === MAX_TEXTURES) { TICK++;
                                    currentGroup.size = i - currentGroup.start;
                                    textureCount = 0;
                                    currentGroup = groups[groupCount++];
                                    currentGroup.blend = blendMode;
                                    currentGroup.textureCount = 0;
                                    currentGroup.start = i; }
                                nextTexture.touched = touch;
                                if (nextTexture._virtalBoundId === -1) { for (var j = 0; j < MAX_TEXTURES; ++j) { var tIndex = (j + TEXTURE_TICK) % MAX_TEXTURES; var t = boundTextures[tIndex]; if (t._enabled !== TICK) { TEXTURE_TICK++;
                                            t._virtalBoundId = -1;
                                            nextTexture._virtalBoundId = tIndex;
                                            boundTextures[tIndex] = nextTexture; break; } } }
                                nextTexture._enabled = TICK;
                                currentGroup.textureCount++;
                                currentGroup.ids[textureCount] = nextTexture._virtalBoundId;
                                currentGroup.textures[textureCount++] = nextTexture;
                            }
                        }
                        vertexData = sprite.vertexData;
                        uvs = sprite._texture._uvs.uvsUint32;
                        if (this.renderer.roundPixels) { var resolution = this.renderer.resolution;
                            float32View[index] = (vertexData[0] * resolution | 0) / resolution;
                            float32View[index + 1] = (vertexData[1] * resolution | 0) / resolution;
                            float32View[index + 5] = (vertexData[2] * resolution | 0) / resolution;
                            float32View[index + 6] = (vertexData[3] * resolution | 0) / resolution;
                            float32View[index + 10] = (vertexData[4] * resolution | 0) / resolution;
                            float32View[index + 11] = (vertexData[5] * resolution | 0) / resolution;
                            float32View[index + 15] = (vertexData[6] * resolution | 0) / resolution;
                            float32View[index + 16] = (vertexData[7] * resolution | 0) / resolution; } else { float32View[index] = vertexData[0];
                            float32View[index + 1] = vertexData[1];
                            float32View[index + 5] = vertexData[2];
                            float32View[index + 6] = vertexData[3];
                            float32View[index + 10] = vertexData[4];
                            float32View[index + 11] = vertexData[5];
                            float32View[index + 15] = vertexData[6];
                            float32View[index + 16] = vertexData[7]; }
                        uint32View[index + 2] = uvs[0];
                        uint32View[index + 7] = uvs[1];
                        uint32View[index + 12] = uvs[2];
                        uint32View[index + 17] = uvs[3];
                        uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = sprite._tintRGB + (Math.min(sprite.worldAlpha, 1) * 255 << 24);
                        float32View[index + 4] = float32View[index + 9] = float32View[index + 14] = float32View[index + 19] = nextTexture._virtalBoundId;
                        index += 20;
                    }
                    currentGroup.size = i - currentGroup.start;
                    if (!_settings2.default.CAN_UPLOAD_SAME_BUFFER) {
                        if (this.vaoMax <= this.vertexCount) {
                            this.vaoMax++;
                            var attrs = this.shader.attributes;
                            var vertexBuffer = this.vertexBuffers[this.vertexCount] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);
                            var vao = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);
                            if (attrs.aTextureId) { vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4); }
                            this.vaos[this.vertexCount] = vao;
                        }
                        this.renderer.bindVao(this.vaos[this.vertexCount]);
                        this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, false);
                        this.vertexCount++;
                    } else { this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, true); }
                    for (i = 0; i < MAX_TEXTURES; ++i) { rendererBoundTextures[i]._virtalBoundId = -1; }
                    for (i = 0; i < groupCount; ++i) {
                        var group = groups[i];
                        var groupTextureCount = group.textureCount;
                        for (var _j = 0; _j < groupTextureCount; _j++) {
                            currentTexture = group.textures[_j];
                            if (rendererBoundTextures[group.ids[_j]] !== currentTexture) { this.renderer.bindTexture(currentTexture, group.ids[_j], true); }
                            currentTexture._virtalBoundId = -1;
                        }
                        this.renderer.state.setBlendMode(group.blend);
                        gl.drawElements(gl.TRIANGLES, group.size * 6, gl.UNSIGNED_SHORT, group.start * 6 * 2);
                    }
                    this.currentIndex = 0;
                };
                SpriteRenderer.prototype.start = function start() { this.renderer.bindShader(this.shader); if (_settings2.default.CAN_UPLOAD_SAME_BUFFER) { this.renderer.bindVao(this.vaos[this.vertexCount]);
                        this.vertexBuffers[this.vertexCount].bind(); } };
                SpriteRenderer.prototype.stop = function stop() { this.flush(); };
                SpriteRenderer.prototype.destroy = function destroy() {
                    for (var i = 0; i < this.vaoMax; i++) {
                        if (this.vertexBuffers[i]) { this.vertexBuffers[i].destroy(); }
                        if (this.vaos[i]) { this.vaos[i].destroy(); }
                    }
                    if (this.indexBuffer) { this.indexBuffer.destroy(); }
                    this.renderer.off('prerender', this.onPrerender, this);
                    _ObjectRenderer.prototype.destroy.call(this);
                    if (this.shader) { this.shader.destroy();
                        this.shader = null; }
                    this.vertexBuffers = null;
                    this.vaos = null;
                    this.indexBuffer = null;
                    this.indices = null;
                    this.sprites = null;
                    for (var _i = 0; _i < this.buffers.length; ++_i) { this.buffers[_i].destroy(); }
                };
                return SpriteRenderer;
            }(_ObjectRenderer3.default);
            exports.default = SpriteRenderer;
            _WebGLRenderer2.default.registerPlugin('sprite', SpriteRenderer);
        }, { "../../renderers/webgl/WebGLRenderer": 82, "../../renderers/webgl/utils/ObjectRenderer": 92, "../../renderers/webgl/utils/checkMaxIfStatmentsInShader": 95, "../../settings": 99, "../../utils/createIndicesForQuads": 120, "./BatchBuffer": 103, "./generateMultiTextureShader": 105, "bit-twiddle": 1, "pixi-gl-core": 12 }],
        105: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = generateMultiTextureShader;
            var _Shader = require('../../Shader');
            var _Shader2 = _interopRequireDefault(_Shader);
            var _path = require('path');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            var fragTemplate = ['varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'varying float vTextureId;', 'uniform sampler2D uSamplers[%count%];', 'void main(void){', 'vec4 color;', 'float textureId = floor(vTextureId+0.5);', '%forloop%', 'gl_FragColor = color * vColor;', '}'].join('\n');

            function generateMultiTextureShader(gl, maxTextures) {
                var vertexSrc = 'precision highp float;\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\nattribute vec4 aColor;\nattribute float aTextureId;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\nvarying float vTextureId;\n\nvoid main(void){\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = aTextureCoord;\n    vTextureId = aTextureId;\n    vColor = vec4(aColor.rgb * aColor.a, aColor.a);\n}\n';
                var fragmentSrc = fragTemplate;
                fragmentSrc = fragmentSrc.replace(/%count%/gi, maxTextures);
                fragmentSrc = fragmentSrc.replace(/%forloop%/gi, generateSampleSrc(maxTextures));
                var shader = new _Shader2.default(gl, vertexSrc, fragmentSrc);
                var sampleValues = [];
                for (var i = 0; i < maxTextures; i++) { sampleValues[i] = i; }
                shader.bind();
                shader.uniforms.uSamplers = sampleValues;
                return shader;
            }

            function generateSampleSrc(maxTextures) {
                var src = '';
                src += '\n';
                src += '\n';
                for (var i = 0; i < maxTextures; i++) {
                    if (i > 0) { src += '\nelse '; }
                    if (i < maxTextures - 1) { src += 'if(textureId == ' + i + '.0)'; }
                    src += '\n{';
                    src += '\n\tcolor = texture2D(uSamplers[' + i + '], vTextureCoord);';
                    src += '\n}';
                }
                src += '\n';
                src += '\n';
                return src;
            }
        }, { "../../Shader": 42, "path": 22 }],
        106: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _Sprite2 = require('../sprites/Sprite');
            var _Sprite3 = _interopRequireDefault(_Sprite2);
            var _Texture = require('../textures/Texture');
            var _Texture2 = _interopRequireDefault(_Texture);
            var _math = require('../math');
            var _utils = require('../utils');
            var _const = require('../const');
            var _settings = require('../settings');
            var _settings2 = _interopRequireDefault(_settings);
            var _TextStyle = require('./TextStyle');
            var _TextStyle2 = _interopRequireDefault(_TextStyle);
            var _TextMetrics = require('./TextMetrics');
            var _TextMetrics2 = _interopRequireDefault(_TextMetrics);
            var _trimCanvas = require('../utils/trimCanvas');
            var _trimCanvas2 = _interopRequireDefault(_trimCanvas);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var defaultDestroyOptions = { texture: true, children: false, baseTexture: true };
            var Text = function(_Sprite) {
                _inherits(Text, _Sprite);

                function Text(text, style, canvas) { _classCallCheck(this, Text);
                    canvas = canvas || document.createElement('canvas');
                    canvas.width = 3;
                    canvas.height = 3; var texture = _Texture2.default.fromCanvas(canvas, _settings2.default.SCALE_MODE, 'text');
                    texture.orig = new _math.Rectangle();
                    texture.trim = new _math.Rectangle(); var _this = _possibleConstructorReturn(this, _Sprite.call(this, texture));
                    _Texture2.default.addToCache(_this._texture, _this._texture.baseTexture.textureCacheIds[0]);
                    _this.canvas = canvas;
                    _this.context = _this.canvas.getContext('2d');
                    _this.resolution = _settings2.default.RESOLUTION;
                    _this._text = null;
                    _this._style = null;
                    _this._styleListener = null;
                    _this._font = '';
                    _this.text = text;
                    _this.style = style;
                    _this.localStyleID = -1; return _this; }
                Text.prototype.updateText = function updateText(respectDirty) {
                    var style = this._style;
                    if (this.localStyleID !== style.styleID) { this.dirty = true;
                        this.localStyleID = style.styleID; }
                    if (!this.dirty && respectDirty) { return; }
                    this._font = this._style.toFontString();
                    var measured = _TextMetrics2.default.measureText(this._text, this._style, this._style.wordWrap, this.canvas);
                    var width = measured.width;
                    var height = measured.height;
                    var lines = measured.lines;
                    var lineHeight = measured.lineHeight;
                    var lineWidths = measured.lineWidths;
                    var maxLineWidth = measured.maxLineWidth;
                    var fontProperties = measured.fontProperties;
                    this.canvas.width = Math.ceil((width + style.padding * 2) * this.resolution);
                    this.canvas.height = Math.ceil((height + style.padding * 2) * this.resolution);
                    this.context.scale(this.resolution, this.resolution);
                    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.context.font = this._font;
                    this.context.strokeStyle = style.stroke;
                    this.context.lineWidth = style.strokeThickness;
                    this.context.textBaseline = style.textBaseline;
                    this.context.lineJoin = style.lineJoin;
                    this.context.miterLimit = style.miterLimit;
                    var linePositionX = void 0;
                    var linePositionY = void 0;
                    if (style.dropShadow) {
                        this.context.shadowBlur = style.dropShadowBlur;
                        this.context.globalAlpha = style.dropShadowAlpha;
                        if (style.dropShadowBlur > 0) { this.context.shadowColor = style.dropShadowColor; } else { this.context.fillStyle = style.dropShadowColor; }
                        var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
                        var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;
                        for (var i = 0; i < lines.length; i++) {
                            linePositionX = style.strokeThickness / 2;
                            linePositionY = style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent;
                            if (style.align === 'right') { linePositionX += maxLineWidth - lineWidths[i]; } else if (style.align === 'center') { linePositionX += (maxLineWidth - lineWidths[i]) / 2; }
                            if (style.fill) { this.drawLetterSpacing(lines[i], linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding); if (style.stroke && style.strokeThickness) { this.context.strokeStyle = style.dropShadowColor;
                                    this.drawLetterSpacing(lines[i], linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding, true);
                                    this.context.strokeStyle = style.stroke; } }
                        }
                    }
                    this.context.shadowBlur = 0;
                    this.context.globalAlpha = 1;
                    this.context.fillStyle = this._generateFillStyle(style, lines);
                    for (var _i = 0; _i < lines.length; _i++) {
                        linePositionX = style.strokeThickness / 2;
                        linePositionY = style.strokeThickness / 2 + _i * lineHeight + fontProperties.ascent;
                        if (style.align === 'right') { linePositionX += maxLineWidth - lineWidths[_i]; } else if (style.align === 'center') { linePositionX += (maxLineWidth - lineWidths[_i]) / 2; }
                        if (style.stroke && style.strokeThickness) { this.drawLetterSpacing(lines[_i], linePositionX + style.padding, linePositionY + style.padding, true); }
                        if (style.fill) { this.drawLetterSpacing(lines[_i], linePositionX + style.padding, linePositionY + style.padding); }
                    }
                    this.updateTexture();
                };
                Text.prototype.drawLetterSpacing = function drawLetterSpacing(text, x, y) {
                    var isStroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
                    var style = this._style;
                    var letterSpacing = style.letterSpacing;
                    if (letterSpacing === 0) {
                        if (isStroke) { this.context.strokeText(text, x, y); } else { this.context.fillText(text, x, y); }
                        return;
                    }
                    var characters = String.prototype.split.call(text, '');
                    var currentPosition = x;
                    var index = 0;
                    var current = '';
                    while (index < text.length) {
                        current = characters[index++];
                        if (isStroke) { this.context.strokeText(current, currentPosition, y); } else { this.context.fillText(current, currentPosition, y); }
                        currentPosition += this.context.measureText(current).width + letterSpacing;
                    }
                };
                Text.prototype.updateTexture = function updateTexture() {
                    if (this._style.trim) { var trimmed = (0, _trimCanvas2.default)(this.canvas);
                        this.canvas.width = trimmed.width;
                        this.canvas.height = trimmed.height;
                        this.context.putImageData(trimmed.data, 0, 0); }
                    var texture = this._texture;
                    var style = this._style;
                    var padding = style.trim ? 0 : style.padding;
                    texture.baseTexture.hasLoaded = true;
                    texture.baseTexture.resolution = this.resolution;
                    texture.baseTexture.realWidth = this.canvas.width;
                    texture.baseTexture.realHeight = this.canvas.height;
                    texture.baseTexture.width = this.canvas.width / this.resolution;
                    texture.baseTexture.height = this.canvas.height / this.resolution;
                    texture.trim.width = texture._frame.width = this.canvas.width / this.resolution;
                    texture.trim.height = texture._frame.height = this.canvas.height / this.resolution;
                    texture.trim.x = -padding;
                    texture.trim.y = -padding;
                    texture.orig.width = texture._frame.width - padding * 2;
                    texture.orig.height = texture._frame.height - padding * 2;
                    this._onTextureUpdate();
                    texture.baseTexture.emit('update', texture.baseTexture);
                    this.dirty = false;
                };
                Text.prototype.renderWebGL = function renderWebGL(renderer) {
                    if (this.resolution !== renderer.resolution) { this.resolution = renderer.resolution;
                        this.dirty = true; }
                    this.updateText(true);
                    _Sprite.prototype.renderWebGL.call(this, renderer);
                };
                Text.prototype._renderCanvas = function _renderCanvas(renderer) {
                    if (this.resolution !== renderer.resolution) { this.resolution = renderer.resolution;
                        this.dirty = true; }
                    this.updateText(true);
                    _Sprite.prototype._renderCanvas.call(this, renderer);
                };
                Text.prototype.getLocalBounds = function getLocalBounds(rect) { this.updateText(true); return _Sprite.prototype.getLocalBounds.call(this, rect); };
                Text.prototype._calculateBounds = function _calculateBounds() { this.updateText(true);
                    this.calculateVertices();
                    this._bounds.addQuad(this.vertexData); };
                Text.prototype._onStyleChange = function _onStyleChange() { this.dirty = true; };
                Text.prototype._generateFillStyle = function _generateFillStyle(style, lines) {
                    if (!Array.isArray(style.fill)) { return style.fill; }
                    if (navigator.isCocoonJS) { return style.fill[0]; }
                    var gradient = void 0;
                    var totalIterations = void 0;
                    var currentIteration = void 0;
                    var stop = void 0;
                    var width = this.canvas.width / this.resolution;
                    var height = this.canvas.height / this.resolution;
                    var fill = style.fill.slice();
                    var fillGradientStops = style.fillGradientStops.slice();
                    if (!fillGradientStops.length) { var lengthPlus1 = fill.length + 1; for (var i = 1; i < lengthPlus1; ++i) { fillGradientStops.push(i / lengthPlus1); } }
                    fill.unshift(style.fill[0]);
                    fillGradientStops.unshift(0);
                    fill.push(style.fill[style.fill.length - 1]);
                    fillGradientStops.push(1);
                    if (style.fillGradientType === _const.TEXT_GRADIENT.LINEAR_VERTICAL) {
                        gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);
                        totalIterations = (fill.length + 1) * lines.length;
                        currentIteration = 0;
                        for (var _i2 = 0; _i2 < lines.length; _i2++) {
                            currentIteration += 1;
                            for (var j = 0; j < fill.length; j++) {
                                if (typeof fillGradientStops[j] === 'number') { stop = fillGradientStops[j] / lines.length + _i2 / lines.length; } else { stop = currentIteration / totalIterations; }
                                gradient.addColorStop(stop, fill[j]);
                                currentIteration++;
                            }
                        }
                    } else {
                        gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);
                        totalIterations = fill.length + 1;
                        currentIteration = 1;
                        for (var _i3 = 0; _i3 < fill.length; _i3++) {
                            if (typeof fillGradientStops[_i3] === 'number') { stop = fillGradientStops[_i3]; } else { stop = currentIteration / totalIterations; }
                            gradient.addColorStop(stop, fill[_i3]);
                            currentIteration++;
                        }
                    }
                    return gradient;
                };
                Text.prototype.destroy = function destroy(options) {
                    if (typeof options === 'boolean') { options = { children: options }; }
                    options = Object.assign({}, defaultDestroyOptions, options);
                    _Sprite.prototype.destroy.call(this, options);
                    this.context = null;
                    this.canvas = null;
                    this._style = null;
                };
                _createClass(Text, [{
                    key: 'width',
                    get: function get() { this.updateText(true); return Math.abs(this.scale.x) * this._texture.orig.width; },
                    set: function set(value) { this.updateText(true); var s = (0, _utils.sign)(this.scale.x) || 1;
                        this.scale.x = s * value / this._texture.orig.width;
                        this._width = value; }
                }, {
                    key: 'height',
                    get: function get() { this.updateText(true); return Math.abs(this.scale.y) * this._texture.orig.height; },
                    set: function set(value) { this.updateText(true); var s = (0, _utils.sign)(this.scale.y) || 1;
                        this.scale.y = s * value / this._texture.orig.height;
                        this._height = value; }
                }, {
                    key: 'style',
                    get: function get() { return this._style; },
                    set: function set(style) {
                        style = style || {};
                        if (style instanceof _TextStyle2.default) { this._style = style; } else { this._style = new _TextStyle2.default(style); }
                        this.localStyleID = -1;
                        this.dirty = true;
                    }
                }, {
                    key: 'text',
                    get: function get() { return this._text; },
                    set: function set(text) {
                        text = String(text === '' || text === null || text === undefined ? ' ' : text);
                        if (this._text === text) { return; }
                        this._text = text;
                        this.dirty = true;
                    }
                }]);
                return Text;
            }(_Sprite3.default);
            exports.default = Text;
        }, { "../const": 44, "../math": 68, "../settings": 99, "../sprites/Sprite": 100, "../textures/Texture": 113, "../utils": 122, "../utils/trimCanvas": 126, "./TextMetrics": 107, "./TextStyle": 108 }],
        107: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var TextMetrics = function() {
                function TextMetrics(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) { _classCallCheck(this, TextMetrics);
                    this.text = text;
                    this.style = style;
                    this.width = width;
                    this.height = height;
                    this.lines = lines;
                    this.lineWidths = lineWidths;
                    this.lineHeight = lineHeight;
                    this.maxLineWidth = maxLineWidth;
                    this.fontProperties = fontProperties; }
                TextMetrics.measureText = function measureText(text, style, wordWrap) {
                    var canvas = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : TextMetrics._canvas;
                    wordWrap = wordWrap || style.wordWrap;
                    var font = style.toFontString();
                    var fontProperties = TextMetrics.measureFont(font);
                    var context = canvas.getContext('2d');
                    context.font = font;
                    var outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;
                    var lines = outputText.split(/(?:\r\n|\r|\n)/);
                    var lineWidths = new Array(lines.length);
                    var maxLineWidth = 0;
                    for (var i = 0; i < lines.length; i++) { var lineWidth = context.measureText(lines[i]).width + (lines[i].length - 1) * style.letterSpacing;
                        lineWidths[i] = lineWidth;
                        maxLineWidth = Math.max(maxLineWidth, lineWidth); }
                    var width = maxLineWidth + style.strokeThickness;
                    if (style.dropShadow) { width += style.dropShadowDistance; }
                    var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
                    var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness) + (lines.length - 1) * lineHeight;
                    if (style.dropShadow) { height += style.dropShadowDistance; }
                    return new TextMetrics(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties);
                };
                TextMetrics.wordWrap = function wordWrap(text, style) {
                    var canvas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : TextMetrics._canvas;
                    var context = canvas.getContext('2d');
                    var result = '';
                    var lines = text.split('\n');
                    var wordWrapWidth = style.wordWrapWidth;
                    var characterCache = {};
                    for (var i = 0; i < lines.length; i++) {
                        var spaceLeft = wordWrapWidth;
                        var words = lines[i].split(' ');
                        for (var j = 0; j < words.length; j++) {
                            var wordWidth = context.measureText(words[j]).width;
                            if (style.breakWords && wordWidth > wordWrapWidth) {
                                var characters = words[j].split('');
                                for (var c = 0; c < characters.length; c++) {
                                    var character = characters[c];
                                    var characterWidth = characterCache[character];
                                    if (characterWidth === undefined) { characterWidth = context.measureText(character).width;
                                        characterCache[character] = characterWidth; }
                                    if (characterWidth > spaceLeft) { result += '\n' + character;
                                        spaceLeft = wordWrapWidth - characterWidth; } else {
                                        if (c === 0) { result += ' '; }
                                        result += character;
                                        spaceLeft -= characterWidth;
                                    }
                                }
                            } else {
                                var wordWidthWithSpace = wordWidth + context.measureText(' ').width;
                                if (j === 0 || wordWidthWithSpace > spaceLeft) {
                                    if (j > 0) { result += '\n'; }
                                    result += words[j];
                                    spaceLeft = wordWrapWidth - wordWidth;
                                } else { spaceLeft -= wordWidthWithSpace;
                                    result += ' ' + words[j]; }
                            }
                        }
                        if (i < lines.length - 1) { result += '\n'; }
                    }
                    return result;
                };
                TextMetrics.measureFont = function measureFont(font) {
                    if (TextMetrics._fonts[font]) { return TextMetrics._fonts[font]; }
                    var properties = {};
                    var canvas = TextMetrics._canvas;
                    var context = TextMetrics._context;
                    context.font = font;
                    var width = Math.ceil(context.measureText('|Mq').width);
                    var baseline = Math.ceil(context.measureText('M').width);
                    var height = 2 * baseline;
                    baseline = baseline * 1.4 | 0;
                    canvas.width = width;
                    canvas.height = height;
                    context.fillStyle = '#f00';
                    context.fillRect(0, 0, width, height);
                    context.font = font;
                    context.textBaseline = 'alphabetic';
                    context.fillStyle = '#000';
                    context.fillText('|Mq', 0, baseline);
                    var imagedata = context.getImageData(0, 0, width, height).data;
                    var pixels = imagedata.length;
                    var line = width * 4;
                    var i = 0;
                    var idx = 0;
                    var stop = false;
                    for (i = 0; i < baseline; ++i) {
                        for (var j = 0; j < line; j += 4) { if (imagedata[idx + j] !== 255) { stop = true; break; } }
                        if (!stop) { idx += line; } else { break; }
                    }
                    properties.ascent = baseline - i;
                    idx = pixels - line;
                    stop = false;
                    for (i = height; i > baseline; --i) {
                        for (var _j = 0; _j < line; _j += 4) { if (imagedata[idx + _j] !== 255) { stop = true; break; } }
                        if (!stop) { idx -= line; } else { break; }
                    }
                    properties.descent = i - baseline;
                    properties.fontSize = properties.ascent + properties.descent;
                    TextMetrics._fonts[font] = properties;
                    return properties;
                };
                return TextMetrics;
            }();
            exports.default = TextMetrics;
            var canvas = document.createElement('canvas');
            canvas.width = canvas.height = 10;
            TextMetrics._canvas = canvas;
            TextMetrics._context = canvas.getContext('2d');
            TextMetrics._fonts = {};
        }, {}],
        108: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _const = require('../const');
            var _utils = require('../utils');

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var defaultStyle = { align: 'left', breakWords: false, dropShadow: false, dropShadowAlpha: 1, dropShadowAngle: Math.PI / 6, dropShadowBlur: 0, dropShadowColor: '#000000', dropShadowDistance: 5, fill: 'black', fillGradientType: _const.TEXT_GRADIENT.LINEAR_VERTICAL, fillGradientStops: [], fontFamily: 'Arial', fontSize: 26, fontStyle: 'normal', fontVariant: 'normal', fontWeight: 'normal', letterSpacing: 0, lineHeight: 0, lineJoin: 'miter', miterLimit: 10, padding: 0, stroke: 'black', strokeThickness: 0, textBaseline: 'alphabetic', trim: false, wordWrap: false, wordWrapWidth: 100 };
            var TextStyle = function() {
                function TextStyle(style) { _classCallCheck(this, TextStyle);
                    this.styleID = 0;
                    Object.assign(this, defaultStyle, style); }
                TextStyle.prototype.clone = function clone() {
                    var clonedProperties = {};
                    for (var key in defaultStyle) { clonedProperties[key] = this[key]; }
                    return new TextStyle(clonedProperties);
                };
                TextStyle.prototype.reset = function reset() { Object.assign(this, defaultStyle); };
                TextStyle.prototype.toFontString = function toFontString() {
                    var fontSizeString = typeof this.fontSize === 'number' ? this.fontSize + 'px' : this.fontSize;
                    var fontFamilies = this.fontFamily;
                    if (!Array.isArray(this.fontFamily)) { fontFamilies = this.fontFamily.split(','); }
                    for (var i = fontFamilies.length - 1; i >= 0; i--) {
                        var fontFamily = fontFamilies[i].trim();
                        if (!/([\"\'])[^\'\"]+\1/.test(fontFamily)) { fontFamily = '"' + fontFamily + '"'; }
                        fontFamilies[i] = fontFamily;
                    }
                    return this.fontStyle + ' ' + this.fontVariant + ' ' + this.fontWeight + ' ' + fontSizeString + ' ' + fontFamilies.join(',');
                };
                _createClass(TextStyle, [{ key: 'align', get: function get() { return this._align; }, set: function set(align) { if (this._align !== align) { this._align = align;
                            this.styleID++; } } }, { key: 'breakWords', get: function get() { return this._breakWords; }, set: function set(breakWords) { if (this._breakWords !== breakWords) { this._breakWords = breakWords;
                            this.styleID++; } } }, { key: 'dropShadow', get: function get() { return this._dropShadow; }, set: function set(dropShadow) { if (this._dropShadow !== dropShadow) { this._dropShadow = dropShadow;
                            this.styleID++; } } }, { key: 'dropShadowAlpha', get: function get() { return this._dropShadowAlpha; }, set: function set(dropShadowAlpha) { if (this._dropShadowAlpha !== dropShadowAlpha) { this._dropShadowAlpha = dropShadowAlpha;
                            this.styleID++; } } }, { key: 'dropShadowAngle', get: function get() { return this._dropShadowAngle; }, set: function set(dropShadowAngle) { if (this._dropShadowAngle !== dropShadowAngle) { this._dropShadowAngle = dropShadowAngle;
                            this.styleID++; } } }, { key: 'dropShadowBlur', get: function get() { return this._dropShadowBlur; }, set: function set(dropShadowBlur) { if (this._dropShadowBlur !== dropShadowBlur) { this._dropShadowBlur = dropShadowBlur;
                            this.styleID++; } } }, { key: 'dropShadowColor', get: function get() { return this._dropShadowColor; }, set: function set(dropShadowColor) { var outputColor = getColor(dropShadowColor); if (this._dropShadowColor !== outputColor) { this._dropShadowColor = outputColor;
                            this.styleID++; } } }, { key: 'dropShadowDistance', get: function get() { return this._dropShadowDistance; }, set: function set(dropShadowDistance) { if (this._dropShadowDistance !== dropShadowDistance) { this._dropShadowDistance = dropShadowDistance;
                            this.styleID++; } } }, { key: 'fill', get: function get() { return this._fill; }, set: function set(fill) { var outputColor = getColor(fill); if (this._fill !== outputColor) { this._fill = outputColor;
                            this.styleID++; } } }, { key: 'fillGradientType', get: function get() { return this._fillGradientType; }, set: function set(fillGradientType) { if (this._fillGradientType !== fillGradientType) { this._fillGradientType = fillGradientType;
                            this.styleID++; } } }, { key: 'fillGradientStops', get: function get() { return this._fillGradientStops; }, set: function set(fillGradientStops) { if (!areArraysEqual(this._fillGradientStops, fillGradientStops)) { this._fillGradientStops = fillGradientStops;
                            this.styleID++; } } }, { key: 'fontFamily', get: function get() { return this._fontFamily; }, set: function set(fontFamily) { if (this.fontFamily !== fontFamily) { this._fontFamily = fontFamily;
                            this.styleID++; } } }, { key: 'fontSize', get: function get() { return this._fontSize; }, set: function set(fontSize) { if (this._fontSize !== fontSize) { this._fontSize = fontSize;
                            this.styleID++; } } }, { key: 'fontStyle', get: function get() { return this._fontStyle; }, set: function set(fontStyle) { if (this._fontStyle !== fontStyle) { this._fontStyle = fontStyle;
                            this.styleID++; } } }, { key: 'fontVariant', get: function get() { return this._fontVariant; }, set: function set(fontVariant) { if (this._fontVariant !== fontVariant) { this._fontVariant = fontVariant;
                            this.styleID++; } } }, { key: 'fontWeight', get: function get() { return this._fontWeight; }, set: function set(fontWeight) { if (this._fontWeight !== fontWeight) { this._fontWeight = fontWeight;
                            this.styleID++; } } }, { key: 'letterSpacing', get: function get() { return this._letterSpacing; }, set: function set(letterSpacing) { if (this._letterSpacing !== letterSpacing) { this._letterSpacing = letterSpacing;
                            this.styleID++; } } }, { key: 'lineHeight', get: function get() { return this._lineHeight; }, set: function set(lineHeight) { if (this._lineHeight !== lineHeight) { this._lineHeight = lineHeight;
                            this.styleID++; } } }, { key: 'lineJoin', get: function get() { return this._lineJoin; }, set: function set(lineJoin) { if (this._lineJoin !== lineJoin) { this._lineJoin = lineJoin;
                            this.styleID++; } } }, { key: 'miterLimit', get: function get() { return this._miterLimit; }, set: function set(miterLimit) { if (this._miterLimit !== miterLimit) { this._miterLimit = miterLimit;
                            this.styleID++; } } }, { key: 'padding', get: function get() { return this._padding; }, set: function set(padding) { if (this._padding !== padding) { this._padding = padding;
                            this.styleID++; } } }, { key: 'stroke', get: function get() { return this._stroke; }, set: function set(stroke) { var outputColor = getColor(stroke); if (this._stroke !== outputColor) { this._stroke = outputColor;
                            this.styleID++; } } }, { key: 'strokeThickness', get: function get() { return this._strokeThickness; }, set: function set(strokeThickness) { if (this._strokeThickness !== strokeThickness) { this._strokeThickness = strokeThickness;
                            this.styleID++; } } }, { key: 'textBaseline', get: function get() { return this._textBaseline; }, set: function set(textBaseline) { if (this._textBaseline !== textBaseline) { this._textBaseline = textBaseline;
                            this.styleID++; } } }, { key: 'trim', get: function get() { return this._trim; }, set: function set(trim) { if (this._trim !== trim) { this._trim = trim;
                            this.styleID++; } } }, { key: 'wordWrap', get: function get() { return this._wordWrap; }, set: function set(wordWrap) { if (this._wordWrap !== wordWrap) { this._wordWrap = wordWrap;
                            this.styleID++; } } }, { key: 'wordWrapWidth', get: function get() { return this._wordWrapWidth; }, set: function set(wordWrapWidth) { if (this._wordWrapWidth !== wordWrapWidth) { this._wordWrapWidth = wordWrapWidth;
                            this.styleID++; } } }]);
                return TextStyle;
            }();
            exports.default = TextStyle;

            function getSingleColor(color) {
                if (typeof color === 'number') { return (0, _utils.hex2string)(color); } else if (typeof color === 'string') { if (color.indexOf('0x') === 0) { color = color.replace('0x', '#'); } }
                return color;
            }

            function getColor(color) {
                if (!Array.isArray(color)) { return getSingleColor(color); } else {
                    for (var i = 0; i < color.length; ++i) { color[i] = getSingleColor(color[i]); }
                    return color;
                }
            }

            function areArraysEqual(array1, array2) {
                if (!Array.isArray(array1) || !Array.isArray(array2)) { return false; }
                if (array1.length !== array2.length) { return false; }
                for (var i = 0; i < array1.length; ++i) { if (array1[i] !== array2[i]) { return false; } }
                return true;
            }
        }, { "../const": 44, "../utils": 122 }],
        109: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _BaseTexture2 = require('./BaseTexture');
            var _BaseTexture3 = _interopRequireDefault(_BaseTexture2);
            var _settings = require('../settings');
            var _settings2 = _interopRequireDefault(_settings);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var BaseRenderTexture = function(_BaseTexture) {
                _inherits(BaseRenderTexture, _BaseTexture);

                function BaseRenderTexture() { var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100; var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100; var scaleMode = arguments[2]; var resolution = arguments[3];
                    _classCallCheck(this, BaseRenderTexture); var _this = _possibleConstructorReturn(this, _BaseTexture.call(this, null, scaleMode));
                    _this.resolution = resolution || _settings2.default.RESOLUTION;
                    _this.width = width;
                    _this.height = height;
                    _this.realWidth = _this.width * _this.resolution;
                    _this.realHeight = _this.height * _this.resolution;
                    _this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;
                    _this.hasLoaded = true;
                    _this._glRenderTargets = {};
                    _this._canvasRenderTarget = null;
                    _this.valid = false; return _this; }
                BaseRenderTexture.prototype.resize = function resize(width, height) {
                    if (width === this.width && height === this.height) { return; }
                    this.valid = width > 0 && height > 0;
                    this.width = width;
                    this.height = height;
                    this.realWidth = this.width * this.resolution;
                    this.realHeight = this.height * this.resolution;
                    if (!this.valid) { return; }
                    this.emit('update', this);
                };
                BaseRenderTexture.prototype.destroy = function destroy() { _BaseTexture.prototype.destroy.call(this, true);
                    this.renderer = null; };
                return BaseRenderTexture;
            }(_BaseTexture3.default);
            exports.default = BaseRenderTexture;
        }, { "../settings": 99, "./BaseTexture": 110 }],
        110: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) { return typeof obj; } : function(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
            var _utils = require('../utils');
            var _settings = require('../settings');
            var _settings2 = _interopRequireDefault(_settings);
            var _eventemitter = require('eventemitter3');
            var _eventemitter2 = _interopRequireDefault(_eventemitter);
            var _determineCrossOrigin = require('../utils/determineCrossOrigin');
            var _determineCrossOrigin2 = _interopRequireDefault(_determineCrossOrigin);
            var _bitTwiddle = require('bit-twiddle');
            var _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var BaseTexture = function(_EventEmitter) {
                _inherits(BaseTexture, _EventEmitter);

                function BaseTexture(source, scaleMode, resolution) {
                    _classCallCheck(this, BaseTexture);
                    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
                    _this.uid = (0, _utils.uid)();
                    _this.touched = 0;
                    _this.resolution = resolution || _settings2.default.RESOLUTION;
                    _this.width = 100;
                    _this.height = 100;
                    _this.realWidth = 100;
                    _this.realHeight = 100;
                    _this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;
                    _this.hasLoaded = false;
                    _this.isLoading = false;
                    _this.source = null;
                    _this.origSource = null;
                    _this.imageType = null;
                    _this.sourceScale = 1.0;
                    _this.premultipliedAlpha = true;
                    _this.imageUrl = null;
                    _this.isPowerOfTwo = false;
                    _this.mipmap = _settings2.default.MIPMAP_TEXTURES;
                    _this.wrapMode = _settings2.default.WRAP_MODE;
                    _this._glTextures = {};
                    _this._enabled = 0;
                    _this._virtalBoundId = -1;
                    _this._destroyed = false;
                    _this.textureCacheIds = [];
                    if (source) { _this.loadSource(source); }
                    return _this;
                }
                BaseTexture.prototype.update = function update() {
                    if (this.imageType !== 'svg') { this.realWidth = this.source.naturalWidth || this.source.videoWidth || this.source.width;
                        this.realHeight = this.source.naturalHeight || this.source.videoHeight || this.source.height;
                        this._updateDimensions(); }
                    this.emit('update', this);
                };
                BaseTexture.prototype._updateDimensions = function _updateDimensions() { this.width = this.realWidth / this.resolution;
                    this.height = this.realHeight / this.resolution;
                    this.isPowerOfTwo = _bitTwiddle2.default.isPow2(this.realWidth) && _bitTwiddle2.default.isPow2(this.realHeight); };
                BaseTexture.prototype.loadSource = function loadSource(source) {
                    var _this2 = this;
                    var wasLoading = this.isLoading;
                    this.hasLoaded = false;
                    this.isLoading = false;
                    if (wasLoading && this.source) { this.source.onload = null;
                        this.source.onerror = null; }
                    var firstSourceLoaded = !this.source;
                    this.source = source;
                    if ((source.src && source.complete || source.getContext) && source.width && source.height) {
                        this._updateImageType();
                        if (this.imageType === 'svg') { this._loadSvgSource(); } else { this._sourceLoaded(); }
                        if (firstSourceLoaded) { this.emit('loaded', this); }
                    } else if (!source.getContext) {
                        var _ret = function() {
                            _this2.isLoading = true;
                            var scope = _this2;
                            source.onload = function() {
                                scope._updateImageType();
                                source.onload = null;
                                source.onerror = null;
                                if (!scope.isLoading) { return; }
                                scope.isLoading = false;
                                scope._sourceLoaded();
                                if (scope.imageType === 'svg') { scope._loadSvgSource(); return; }
                                scope.emit('loaded', scope);
                            };
                            source.onerror = function() {
                                source.onload = null;
                                source.onerror = null;
                                if (!scope.isLoading) { return; }
                                scope.isLoading = false;
                                scope.emit('error', scope);
                            };
                            if (source.complete && source.src) {
                                source.onload = null;
                                source.onerror = null;
                                if (scope.imageType === 'svg') { scope._loadSvgSource(); return { v: void 0 }; }
                                _this2.isLoading = false;
                                if (source.width && source.height) { _this2._sourceLoaded(); if (wasLoading) { _this2.emit('loaded', _this2); } } else if (wasLoading) { _this2.emit('error', _this2); }
                            }
                        }();
                        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
                    }
                };
                BaseTexture.prototype._updateImageType = function _updateImageType() {
                    if (!this.imageUrl) { return; }
                    var dataUri = (0, _utils.decomposeDataUri)(this.imageUrl);
                    var imageType = void 0;
                    if (dataUri && dataUri.mediaType === 'image') { var firstSubType = dataUri.subType.split('+')[0];
                        imageType = (0, _utils.getUrlFileExtension)('.' + firstSubType); if (!imageType) { throw new Error('Invalid image type in data URI.'); } } else { imageType = (0, _utils.getUrlFileExtension)(this.imageUrl); if (!imageType) { imageType = 'png'; } }
                    this.imageType = imageType;
                };
                BaseTexture.prototype._loadSvgSource = function _loadSvgSource() {
                    if (this.imageType !== 'svg') { return; }
                    var dataUri = (0, _utils.decomposeDataUri)(this.imageUrl);
                    if (dataUri) { this._loadSvgSourceUsingDataUri(dataUri); } else { this._loadSvgSourceUsingXhr(); }
                };
                BaseTexture.prototype._loadSvgSourceUsingDataUri = function _loadSvgSourceUsingDataUri(dataUri) {
                    var svgString = void 0;
                    if (dataUri.encoding === 'base64') {
                        if (!atob) { throw new Error('Your browser doesn\'t support base64 conversions.'); }
                        svgString = atob(dataUri.data);
                    } else { svgString = dataUri.data; }
                    this._loadSvgSourceUsingString(svgString);
                };
                BaseTexture.prototype._loadSvgSourceUsingXhr = function _loadSvgSourceUsingXhr() {
                    var _this3 = this;
                    var svgXhr = new XMLHttpRequest();
                    svgXhr.onload = function() {
                        if (svgXhr.readyState !== svgXhr.DONE || svgXhr.status !== 200) { throw new Error('Failed to load SVG using XHR.'); }
                        _this3._loadSvgSourceUsingString(svgXhr.response);
                    };
                    svgXhr.onerror = function() { return _this3.emit('error', _this3); };
                    svgXhr.open('GET', this.imageUrl, true);
                    svgXhr.send();
                };
                BaseTexture.prototype._loadSvgSourceUsingString = function _loadSvgSourceUsingString(svgString) {
                    var svgSize = (0, _utils.getSvgSize)(svgString);
                    var svgWidth = svgSize.width;
                    var svgHeight = svgSize.height;
                    if (!svgWidth || !svgHeight) { throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.'); }
                    this.realWidth = Math.round(svgWidth * this.sourceScale);
                    this.realHeight = Math.round(svgHeight * this.sourceScale);
                    this._updateDimensions();
                    var canvas = document.createElement('canvas');
                    canvas.width = this.realWidth;
                    canvas.height = this.realHeight;
                    canvas._pixiId = 'canvas_' + (0, _utils.uid)();
                    canvas.getContext('2d').drawImage(this.source, 0, 0, svgWidth, svgHeight, 0, 0, this.realWidth, this.realHeight);
                    this.origSource = this.source;
                    this.source = canvas;
                    BaseTexture.addToCache(this, canvas._pixiId);
                    this.isLoading = false;
                    this._sourceLoaded();
                    this.emit('loaded', this);
                };
                BaseTexture.prototype._sourceLoaded = function _sourceLoaded() { this.hasLoaded = true;
                    this.update(); };
                BaseTexture.prototype.destroy = function destroy() {
                    if (this.imageUrl) { delete _utils.TextureCache[this.imageUrl];
                        this.imageUrl = null; if (!navigator.isCocoonJS) { this.source.src = ''; } }
                    this.source = null;
                    this.dispose();
                    BaseTexture.removeFromCache(this);
                    this.textureCacheIds = null;
                    this._destroyed = true;
                };
                BaseTexture.prototype.dispose = function dispose() { this.emit('dispose', this); };
                BaseTexture.prototype.updateSourceImage = function updateSourceImage(newSrc) { this.source.src = newSrc;
                    this.loadSource(this.source); };
                BaseTexture.fromImage = function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {
                    var baseTexture = _utils.BaseTextureCache[imageUrl];
                    if (!baseTexture) {
                        var image = new Image();
                        if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0) { image.crossOrigin = (0, _determineCrossOrigin2.default)(imageUrl); }
                        baseTexture = new BaseTexture(image, scaleMode);
                        baseTexture.imageUrl = imageUrl;
                        if (sourceScale) { baseTexture.sourceScale = sourceScale; }
                        baseTexture.resolution = (0, _utils.getResolutionOfUrl)(imageUrl);
                        image.src = imageUrl;
                        BaseTexture.addToCache(baseTexture, imageUrl);
                    }
                    return baseTexture;
                };
                BaseTexture.fromCanvas = function fromCanvas(canvas, scaleMode) {
                    var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'canvas';
                    if (!canvas._pixiId) { canvas._pixiId = origin + '_' + (0, _utils.uid)(); }
                    var baseTexture = _utils.BaseTextureCache[canvas._pixiId];
                    if (!baseTexture) { baseTexture = new BaseTexture(canvas, scaleMode);
                        BaseTexture.addToCache(baseTexture, canvas._pixiId); }
                    return baseTexture;
                };
                BaseTexture.from = function from(source, scaleMode, sourceScale) {
                    if (typeof source === 'string') { return BaseTexture.fromImage(source, undefined, scaleMode, sourceScale); } else if (source instanceof HTMLImageElement) {
                        var imageUrl = source.src;
                        var baseTexture = _utils.BaseTextureCache[imageUrl];
                        if (!baseTexture) {
                            baseTexture = new BaseTexture(source, scaleMode);
                            baseTexture.imageUrl = imageUrl;
                            if (sourceScale) { baseTexture.sourceScale = sourceScale; }
                            baseTexture.resolution = (0, _utils.getResolutionOfUrl)(imageUrl);
                            BaseTexture.addToCache(baseTexture, imageUrl);
                        }
                        return baseTexture;
                    } else if (source instanceof HTMLCanvasElement) { return BaseTexture.fromCanvas(source, scaleMode); }
                    return source;
                };
                BaseTexture.addToCache = function addToCache(baseTexture, id) {
                    if (id) {
                        if (baseTexture.textureCacheIds.indexOf(id) === -1) { baseTexture.textureCacheIds.push(id); }
                        if (_utils.BaseTextureCache[id]) { console.warn('BaseTexture added to the cache with an id [' + id + '] that already had an entry'); }
                        _utils.BaseTextureCache[id] = baseTexture;
                    }
                };
                BaseTexture.removeFromCache = function removeFromCache(baseTexture) {
                    if (typeof baseTexture === 'string') {
                        var baseTextureFromCache = _utils.BaseTextureCache[baseTexture];
                        if (baseTextureFromCache) {
                            var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
                            if (index > -1) { baseTextureFromCache.textureCacheIds.splice(index, 1); }
                            delete _utils.BaseTextureCache[baseTexture];
                            return baseTextureFromCache;
                        }
                    } else if (baseTexture && baseTexture.textureCacheIds) {
                        for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) { delete _utils.BaseTextureCache[baseTexture.textureCacheIds[i]]; }
                        baseTexture.textureCacheIds.length = 0;
                        return baseTexture;
                    }
                    return null;
                };
                return BaseTexture;
            }(_eventemitter2.default);
            exports.default = BaseTexture;
        }, { "../settings": 99, "../utils": 122, "../utils/determineCrossOrigin": 121, "bit-twiddle": 1, "eventemitter3": 3 }],
        111: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _BaseRenderTexture = require('./BaseRenderTexture');
            var _BaseRenderTexture2 = _interopRequireDefault(_BaseRenderTexture);
            var _Texture2 = require('./Texture');
            var _Texture3 = _interopRequireDefault(_Texture2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var RenderTexture = function(_Texture) {
                _inherits(RenderTexture, _Texture);

                function RenderTexture(baseRenderTexture, frame) {
                    _classCallCheck(this, RenderTexture);
                    var _legacyRenderer = null;
                    if (!(baseRenderTexture instanceof _BaseRenderTexture2.default)) { var width = arguments[1]; var height = arguments[2]; var scaleMode = arguments[3]; var resolution = arguments[4];
                        console.warn('Please use RenderTexture.create(' + width + ', ' + height + ') instead of the ctor directly.');
                        _legacyRenderer = arguments[0];
                        frame = null;
                        baseRenderTexture = new _BaseRenderTexture2.default(width, height, scaleMode, resolution); }
                    var _this = _possibleConstructorReturn(this, _Texture.call(this, baseRenderTexture, frame));
                    _this.legacyRenderer = _legacyRenderer;
                    _this.valid = true;
                    _this._updateUvs();
                    return _this;
                }
                RenderTexture.prototype.resize = function resize(width, height, doNotResizeBaseTexture) {
                    this.valid = width > 0 && height > 0;
                    this._frame.width = this.orig.width = width;
                    this._frame.height = this.orig.height = height;
                    if (!doNotResizeBaseTexture) { this.baseTexture.resize(width, height); }
                    this._updateUvs();
                };
                RenderTexture.create = function create(width, height, scaleMode, resolution) { return new RenderTexture(new _BaseRenderTexture2.default(width, height, scaleMode, resolution)); };
                return RenderTexture;
            }(_Texture3.default);
            exports.default = RenderTexture;
        }, { "./BaseRenderTexture": 109, "./Texture": 113 }],
        112: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _ = require('../');
            var _utils = require('../utils');

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var Spritesheet = function() {
                _createClass(Spritesheet, null, [{ key: 'BATCH_SIZE', get: function get() { return 1000; } }]);

                function Spritesheet(baseTexture, data) { var resolutionFilename = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                    _classCallCheck(this, Spritesheet);
                    this.baseTexture = baseTexture;
                    this.textures = {};
                    this.data = data;
                    this.resolution = this._updateResolution(resolutionFilename || this.baseTexture.imageUrl);
                    this._frames = this.data.frames;
                    this._frameKeys = Object.keys(this._frames);
                    this._batchIndex = 0;
                    this._callback = null; }
                Spritesheet.prototype._updateResolution = function _updateResolution(resolutionFilename) {
                    var scale = this.data.meta.scale;
                    var resolution = (0, _utils.getResolutionOfUrl)(resolutionFilename, null);
                    if (resolution === null) { resolution = scale !== undefined ? parseFloat(scale) : 1; }
                    if (resolution !== 1) { this.baseTexture.resolution = resolution;
                        this.baseTexture.update(); }
                    return resolution;
                };
                Spritesheet.prototype.parse = function parse(callback) { this._batchIndex = 0;
                    this._callback = callback; if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) { this._processFrames(0);
                        this._parseComplete(); } else { this._nextBatch(); } };
                Spritesheet.prototype._processFrames = function _processFrames(initialFrameIndex) {
                    var frameIndex = initialFrameIndex;
                    var maxFrames = Spritesheet.BATCH_SIZE;
                    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
                        var i = this._frameKeys[frameIndex];
                        var rect = this._frames[i].frame;
                        if (rect) {
                            var frame = null;
                            var trim = null;
                            var orig = new _.Rectangle(0, 0, this._frames[i].sourceSize.w / this.resolution, this._frames[i].sourceSize.h / this.resolution);
                            if (this._frames[i].rotated) { frame = new _.Rectangle(rect.x / this.resolution, rect.y / this.resolution, rect.h / this.resolution, rect.w / this.resolution); } else { frame = new _.Rectangle(rect.x / this.resolution, rect.y / this.resolution, rect.w / this.resolution, rect.h / this.resolution); }
                            if (this._frames[i].trimmed) { trim = new _.Rectangle(this._frames[i].spriteSourceSize.x / this.resolution, this._frames[i].spriteSourceSize.y / this.resolution, rect.w / this.resolution, rect.h / this.resolution); }
                            this.textures[i] = new _.Texture(this.baseTexture, frame, orig, trim, this._frames[i].rotated ? 2 : 0);
                            _.Texture.addToCache(this.textures[i], i);
                        }
                        frameIndex++;
                    }
                };
                Spritesheet.prototype._parseComplete = function _parseComplete() { var callback = this._callback;
                    this._callback = null;
                    this._batchIndex = 0;
                    callback.call(this, this.textures); };
                Spritesheet.prototype._nextBatch = function _nextBatch() { var _this = this;
                    this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);
                    this._batchIndex++;
                    setTimeout(function() { if (_this._batchIndex * Spritesheet.BATCH_SIZE < _this._frameKeys.length) { _this._nextBatch(); } else { _this._parseComplete(); } }, 0); };
                Spritesheet.prototype.destroy = function destroy() {
                    var destroyBase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                    for (var i in this.textures) { this.textures[i].destroy(); }
                    this._frames = null;
                    this._frameKeys = null;
                    this.data = null;
                    this.textures = null;
                    if (destroyBase) { this.baseTexture.destroy(); }
                    this.baseTexture = null;
                };
                return Spritesheet;
            }();
            exports.default = Spritesheet;
        }, { "../": 63, "../utils": 122 }],
        113: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _BaseTexture = require('./BaseTexture');
            var _BaseTexture2 = _interopRequireDefault(_BaseTexture);
            var _VideoBaseTexture = require('./VideoBaseTexture');
            var _VideoBaseTexture2 = _interopRequireDefault(_VideoBaseTexture);
            var _TextureUvs = require('./TextureUvs');
            var _TextureUvs2 = _interopRequireDefault(_TextureUvs);
            var _eventemitter = require('eventemitter3');
            var _eventemitter2 = _interopRequireDefault(_eventemitter);
            var _math = require('../math');
            var _utils = require('../utils');
            var _settings = require('../settings');
            var _settings2 = _interopRequireDefault(_settings);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var Texture = function(_EventEmitter) {
                _inherits(Texture, _EventEmitter);

                function Texture(baseTexture, frame, orig, trim, rotate) {
                    _classCallCheck(this, Texture);
                    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
                    _this.noFrame = false;
                    if (!frame) { _this.noFrame = true;
                        frame = new _math.Rectangle(0, 0, 1, 1); }
                    if (baseTexture instanceof Texture) { baseTexture = baseTexture.baseTexture; }
                    _this.baseTexture = baseTexture;
                    _this._frame = frame;
                    _this.trim = trim;
                    _this.valid = false;
                    _this.requiresUpdate = false;
                    _this._uvs = null;
                    _this.orig = orig || frame;
                    _this._rotate = Number(rotate || 0);
                    if (rotate === true) { _this._rotate = 2; } else if (_this._rotate % 2 !== 0) { throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually'); }
                    if (baseTexture.hasLoaded) {
                        if (_this.noFrame) { frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);
                            baseTexture.on('update', _this.onBaseTextureUpdated, _this); }
                        _this.frame = frame;
                    } else { baseTexture.once('loaded', _this.onBaseTextureLoaded, _this); }
                    _this._updateID = 0;
                    _this.transform = null;
                    _this.textureCacheIds = [];
                    return _this;
                }
                Texture.prototype.update = function update() { this.baseTexture.update(); };
                Texture.prototype.onBaseTextureLoaded = function onBaseTextureLoaded(baseTexture) {
                    this._updateID++;
                    if (this.noFrame) { this.frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height); } else { this.frame = this._frame; }
                    this.baseTexture.on('update', this.onBaseTextureUpdated, this);
                    this.emit('update', this);
                };
                Texture.prototype.onBaseTextureUpdated = function onBaseTextureUpdated(baseTexture) { this._updateID++;
                    this._frame.width = baseTexture.width;
                    this._frame.height = baseTexture.height;
                    this.emit('update', this); };
                Texture.prototype.destroy = function destroy(destroyBase) {
                    if (this.baseTexture) {
                        if (destroyBase) {
                            if (_utils.TextureCache[this.baseTexture.imageUrl]) { Texture.removeFromCache(this.baseTexture.imageUrl); }
                            this.baseTexture.destroy();
                        }
                        this.baseTexture.off('update', this.onBaseTextureUpdated, this);
                        this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);
                        this.baseTexture = null;
                    }
                    this._frame = null;
                    this._uvs = null;
                    this.trim = null;
                    this.orig = null;
                    this.valid = false;
                    Texture.removeFromCache(this);
                    this.textureCacheIds = null;
                };
                Texture.prototype.clone = function clone() { return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate); };
                Texture.prototype._updateUvs = function _updateUvs() {
                    if (!this._uvs) { this._uvs = new _TextureUvs2.default(); }
                    this._uvs.set(this._frame, this.baseTexture, this.rotate);
                    this._updateID++;
                };
                Texture.fromImage = function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {
                    var texture = _utils.TextureCache[imageUrl];
                    if (!texture) { texture = new Texture(_BaseTexture2.default.fromImage(imageUrl, crossorigin, scaleMode, sourceScale));
                        Texture.addToCache(texture, imageUrl); }
                    return texture;
                };
                Texture.fromFrame = function fromFrame(frameId) {
                    var texture = _utils.TextureCache[frameId];
                    if (!texture) { throw new Error('The frameId "' + frameId + '" does not exist in the texture cache'); }
                    return texture;
                };
                Texture.fromCanvas = function fromCanvas(canvas, scaleMode) { var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'canvas'; return new Texture(_BaseTexture2.default.fromCanvas(canvas, scaleMode, origin)); };
                Texture.fromVideo = function fromVideo(video, scaleMode) {
                    if (typeof video === 'string') { return Texture.fromVideoUrl(video, scaleMode); }
                    return new Texture(_VideoBaseTexture2.default.fromVideo(video, scaleMode));
                };
                Texture.fromVideoUrl = function fromVideoUrl(videoUrl, scaleMode) { return new Texture(_VideoBaseTexture2.default.fromUrl(videoUrl, scaleMode)); };
                Texture.from = function from(source) {
                    if (typeof source === 'string') {
                        var texture = _utils.TextureCache[source];
                        if (!texture) {
                            var isVideo = source.match(/\.(mp4|webm|ogg|h264|avi|mov)$/) !== null;
                            if (isVideo) { return Texture.fromVideoUrl(source); }
                            return Texture.fromImage(source);
                        }
                        return texture;
                    } else if (source instanceof HTMLImageElement) { return new Texture(_BaseTexture2.default.from(source)); } else if (source instanceof HTMLCanvasElement) { return Texture.fromCanvas(source, _settings2.default.SCALE_MODE, 'HTMLCanvasElement'); } else if (source instanceof HTMLVideoElement) { return Texture.fromVideo(source); } else if (source instanceof _BaseTexture2.default) { return new Texture(source); }
                    return source;
                };
                Texture.fromLoader = function fromLoader(source, imageUrl, name) {
                    var baseTexture = new _BaseTexture2.default(source, undefined, (0, _utils.getResolutionOfUrl)(imageUrl));
                    var texture = new Texture(baseTexture);
                    baseTexture.imageUrl = imageUrl;
                    if (!name) { name = imageUrl; }
                    _BaseTexture2.default.addToCache(texture.baseTexture, name);
                    Texture.addToCache(texture, name);
                    if (name !== imageUrl) { _BaseTexture2.default.addToCache(texture.baseTexture, imageUrl);
                        Texture.addToCache(texture, imageUrl); }
                    return texture;
                };
                Texture.addToCache = function addToCache(texture, id) {
                    if (id) {
                        if (texture.textureCacheIds.indexOf(id) === -1) { texture.textureCacheIds.push(id); }
                        if (_utils.TextureCache[id]) { console.warn('Texture added to the cache with an id [' + id + '] that already had an entry'); }
                        _utils.TextureCache[id] = texture;
                    }
                };
                Texture.removeFromCache = function removeFromCache(texture) {
                    if (typeof texture === 'string') {
                        var textureFromCache = _utils.TextureCache[texture];
                        if (textureFromCache) {
                            var index = textureFromCache.textureCacheIds.indexOf(texture);
                            if (index > -1) { textureFromCache.textureCacheIds.splice(index, 1); }
                            delete _utils.TextureCache[texture];
                            return textureFromCache;
                        }
                    } else if (texture && texture.textureCacheIds) {
                        for (var i = 0; i < texture.textureCacheIds.length; ++i) { delete _utils.TextureCache[texture.textureCacheIds[i]]; }
                        texture.textureCacheIds.length = 0;
                        return texture;
                    }
                    return null;
                };
                _createClass(Texture, [{
                    key: 'frame',
                    get: function get() { return this._frame; },
                    set: function set(frame) {
                        this._frame = frame;
                        this.noFrame = false;
                        if (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height) { throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: ' + ('X: ' + frame.x + ' + ' + frame.width + ' > ' + this.baseTexture.width + ' ') + ('Y: ' + frame.y + ' + ' + frame.height + ' > ' + this.baseTexture.height)); }
                        this.valid = frame && frame.width && frame.height && this.baseTexture.hasLoaded;
                        if (!this.trim && !this.rotate) { this.orig = frame; }
                        if (this.valid) { this._updateUvs(); }
                    }
                }, {
                    key: 'rotate',
                    get: function get() { return this._rotate; },
                    set: function set(rotate) { this._rotate = rotate; if (this.valid) { this._updateUvs(); } }
                }, { key: 'width', get: function get() { return this.orig.width; } }, { key: 'height', get: function get() { return this.orig.height; } }]);
                return Texture;
            }(_eventemitter2.default);
            exports.default = Texture;

            function createWhiteTexture() { var canvas = document.createElement('canvas');
                canvas.width = 10;
                canvas.height = 10; var context = canvas.getContext('2d');
                context.fillStyle = 'white';
                context.fillRect(0, 0, 10, 10); return new Texture(new _BaseTexture2.default(canvas)); }

            function removeAllHandlers(tex) { tex.destroy = function _emptyDestroy() {};
                tex.on = function _emptyOn() {};
                tex.once = function _emptyOnce() {};
                tex.emit = function _emptyEmit() {}; }
            Texture.EMPTY = new Texture(new _BaseTexture2.default());
            removeAllHandlers(Texture.EMPTY);
            removeAllHandlers(Texture.EMPTY.baseTexture);
            Texture.WHITE = createWhiteTexture();
            removeAllHandlers(Texture.WHITE);
            removeAllHandlers(Texture.WHITE.baseTexture);
        }, { "../math": 68, "../settings": 99, "../utils": 122, "./BaseTexture": 110, "./TextureUvs": 114, "./VideoBaseTexture": 115, "eventemitter3": 3 }],
        114: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _GroupD = require('../math/GroupD8');
            var _GroupD2 = _interopRequireDefault(_GroupD);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var TextureUvs = function() {
                function TextureUvs() { _classCallCheck(this, TextureUvs);
                    this.x0 = 0;
                    this.y0 = 0;
                    this.x1 = 1;
                    this.y1 = 0;
                    this.x2 = 1;
                    this.y2 = 1;
                    this.x3 = 0;
                    this.y3 = 1;
                    this.uvsUint32 = new Uint32Array(4); }
                TextureUvs.prototype.set = function set(frame, baseFrame, rotate) {
                    var tw = baseFrame.width;
                    var th = baseFrame.height;
                    if (rotate) { var w2 = frame.width / 2 / tw; var h2 = frame.height / 2 / th; var cX = frame.x / tw + w2; var cY = frame.y / th + h2;
                        rotate = _GroupD2.default.add(rotate, _GroupD2.default.NW);
                        this.x0 = cX + w2 * _GroupD2.default.uX(rotate);
                        this.y0 = cY + h2 * _GroupD2.default.uY(rotate);
                        rotate = _GroupD2.default.add(rotate, 2);
                        this.x1 = cX + w2 * _GroupD2.default.uX(rotate);
                        this.y1 = cY + h2 * _GroupD2.default.uY(rotate);
                        rotate = _GroupD2.default.add(rotate, 2);
                        this.x2 = cX + w2 * _GroupD2.default.uX(rotate);
                        this.y2 = cY + h2 * _GroupD2.default.uY(rotate);
                        rotate = _GroupD2.default.add(rotate, 2);
                        this.x3 = cX + w2 * _GroupD2.default.uX(rotate);
                        this.y3 = cY + h2 * _GroupD2.default.uY(rotate); } else { this.x0 = frame.x / tw;
                        this.y0 = frame.y / th;
                        this.x1 = (frame.x + frame.width) / tw;
                        this.y1 = frame.y / th;
                        this.x2 = (frame.x + frame.width) / tw;
                        this.y2 = (frame.y + frame.height) / th;
                        this.x3 = frame.x / tw;
                        this.y3 = (frame.y + frame.height) / th; }
                    this.uvsUint32[0] = (this.y0 * 65535 & 0xFFFF) << 16 | this.x0 * 65535 & 0xFFFF;
                    this.uvsUint32[1] = (this.y1 * 65535 & 0xFFFF) << 16 | this.x1 * 65535 & 0xFFFF;
                    this.uvsUint32[2] = (this.y2 * 65535 & 0xFFFF) << 16 | this.x2 * 65535 & 0xFFFF;
                    this.uvsUint32[3] = (this.y3 * 65535 & 0xFFFF) << 16 | this.x3 * 65535 & 0xFFFF;
                };
                return TextureUvs;
            }();
            exports.default = TextureUvs;
        }, { "../math/GroupD8": 64 }],
        115: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _BaseTexture2 = require('./BaseTexture');
            var _BaseTexture3 = _interopRequireDefault(_BaseTexture2);
            var _utils = require('../utils');
            var _ticker = require('../ticker');
            var _const = require('../const');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var VideoBaseTexture = function(_BaseTexture) {
                _inherits(VideoBaseTexture, _BaseTexture);

                function VideoBaseTexture(source, scaleMode) {
                    _classCallCheck(this, VideoBaseTexture);
                    if (!source) { throw new Error('No video source element specified.'); }
                    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) { source.complete = true; }
                    var _this = _possibleConstructorReturn(this, _BaseTexture.call(this, source, scaleMode));
                    _this.width = source.videoWidth;
                    _this.height = source.videoHeight;
                    _this._autoUpdate = true;
                    _this._isAutoUpdating = false;
                    _this.autoPlay = true;
                    _this.update = _this.update.bind(_this);
                    _this._onCanPlay = _this._onCanPlay.bind(_this);
                    source.addEventListener('play', _this._onPlayStart.bind(_this));
                    source.addEventListener('pause', _this._onPlayStop.bind(_this));
                    _this.hasLoaded = false;
                    _this.__loaded = false;
                    if (!_this._isSourceReady()) { source.addEventListener('canplay', _this._onCanPlay);
                        source.addEventListener('canplaythrough', _this._onCanPlay); } else { _this._onCanPlay(); }
                    return _this;
                }
                VideoBaseTexture.prototype._isSourcePlaying = function _isSourcePlaying() { var source = this.source; return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2; };
                VideoBaseTexture.prototype._isSourceReady = function _isSourceReady() { return this.source.readyState === 3 || this.source.readyState === 4; };
                VideoBaseTexture.prototype._onPlayStart = function _onPlayStart() {
                    if (!this.hasLoaded) { this._onCanPlay(); }
                    if (!this._isAutoUpdating && this.autoUpdate) { _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);
                        this._isAutoUpdating = true; }
                };
                VideoBaseTexture.prototype._onPlayStop = function _onPlayStop() { if (this._isAutoUpdating) { _ticker.shared.remove(this.update, this);
                        this._isAutoUpdating = false; } };
                VideoBaseTexture.prototype._onCanPlay = function _onCanPlay() {
                    this.hasLoaded = true;
                    if (this.source) {
                        this.source.removeEventListener('canplay', this._onCanPlay);
                        this.source.removeEventListener('canplaythrough', this._onCanPlay);
                        this.width = this.source.videoWidth;
                        this.height = this.source.videoHeight;
                        if (!this.__loaded) { this.__loaded = true;
                            this.emit('loaded', this); }
                        if (this._isSourcePlaying()) { this._onPlayStart(); } else if (this.autoPlay) { this.source.play(); }
                    }
                };
                VideoBaseTexture.prototype.destroy = function destroy() {
                    if (this._isAutoUpdating) { _ticker.shared.remove(this.update, this); }
                    if (this.source && this.source._pixiId) { _BaseTexture3.default.removeFromCache(this.source._pixiId);
                        delete this.source._pixiId; }
                    _BaseTexture.prototype.destroy.call(this);
                };
                VideoBaseTexture.fromVideo = function fromVideo(video, scaleMode) {
                    if (!video._pixiId) { video._pixiId = 'video_' + (0, _utils.uid)(); }
                    var baseTexture = _utils.BaseTextureCache[video._pixiId];
                    if (!baseTexture) { baseTexture = new VideoBaseTexture(video, scaleMode);
                        _BaseTexture3.default.addToCache(baseTexture, video._pixiId); }
                    return baseTexture;
                };
                VideoBaseTexture.fromUrl = function fromUrl(videoSrc, scaleMode) {
                    var video = document.createElement('video');
                    video.setAttribute('webkit-playsinline', '');
                    video.setAttribute('playsinline', '');
                    if (Array.isArray(videoSrc)) { for (var i = 0; i < videoSrc.length; ++i) { video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime)); } } else { video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime)); }
                    video.load();
                    return VideoBaseTexture.fromVideo(video, scaleMode);
                };
                _createClass(VideoBaseTexture, [{
                    key: 'autoUpdate',
                    get: function get() { return this._autoUpdate; },
                    set: function set(value) { if (value !== this._autoUpdate) { this._autoUpdate = value; if (!this._autoUpdate && this._isAutoUpdating) { _ticker.shared.remove(this.update, this);
                                this._isAutoUpdating = false; } else if (this._autoUpdate && !this._isAutoUpdating) { _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);
                                this._isAutoUpdating = true; } } }
                }]);
                return VideoBaseTexture;
            }(_BaseTexture3.default);
            exports.default = VideoBaseTexture;
            VideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;

            function createSource(path, type) {
                if (!type) { type = 'video/' + path.substr(path.lastIndexOf('.') + 1); }
                var source = document.createElement('source');
                source.src = path;
                source.type = type;
                return source;
            }
        }, { "../const": 44, "../ticker": 118, "../utils": 122, "./BaseTexture": 110 }],
        116: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _settings = require('../settings');
            var _settings2 = _interopRequireDefault(_settings);
            var _const = require('../const');
            var _TickerListener = require('./TickerListener');
            var _TickerListener2 = _interopRequireDefault(_TickerListener);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var Ticker = function() {
                function Ticker() { var _this = this;
                    _classCallCheck(this, Ticker);
                    this._head = new _TickerListener2.default(null, null, Infinity);
                    this._requestId = null;
                    this._maxElapsedMS = 100;
                    this.autoStart = false;
                    this.deltaTime = 1;
                    this.elapsedMS = 1 / _settings2.default.TARGET_FPMS;
                    this.lastTime = 0;
                    this.speed = 1;
                    this.started = false;
                    this._tick = function(time) { _this._requestId = null; if (_this.started) { _this.update(time); if (_this.started && _this._requestId === null && _this._head.next) { _this._requestId = requestAnimationFrame(_this._tick); } } }; }
                Ticker.prototype._requestIfNeeded = function _requestIfNeeded() { if (this._requestId === null && this._head.next) { this.lastTime = performance.now();
                        this._requestId = requestAnimationFrame(this._tick); } };
                Ticker.prototype._cancelIfNeeded = function _cancelIfNeeded() { if (this._requestId !== null) { cancelAnimationFrame(this._requestId);
                        this._requestId = null; } };
                Ticker.prototype._startIfPossible = function _startIfPossible() { if (this.started) { this._requestIfNeeded(); } else if (this.autoStart) { this.start(); } };
                Ticker.prototype.add = function add(fn, context) { var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const.UPDATE_PRIORITY.NORMAL; return this._addListener(new _TickerListener2.default(fn, context, priority)); };
                Ticker.prototype.addOnce = function addOnce(fn, context) { var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _const.UPDATE_PRIORITY.NORMAL; return this._addListener(new _TickerListener2.default(fn, context, priority, true)); };
                Ticker.prototype._addListener = function _addListener(listener) {
                    var current = this._head.next;
                    var previous = this._head;
                    if (!current) { listener.connect(previous); } else {
                        while (current) {
                            if (listener.priority > current.priority) { listener.connect(previous); break; }
                            previous = current;
                            current = current.next;
                        }
                        if (!listener.previous) { listener.connect(previous); }
                    }
                    this._startIfPossible();
                    return this;
                };
                Ticker.prototype.remove = function remove(fn, context) {
                    var listener = this._head.next;
                    while (listener) { if (listener.match(fn, context)) { listener = listener.destroy(); } else { listener = listener.next; } }
                    if (!this._head.next) { this._cancelIfNeeded(); }
                    return this;
                };
                Ticker.prototype.start = function start() { if (!this.started) { this.started = true;
                        this._requestIfNeeded(); } };
                Ticker.prototype.stop = function stop() { if (this.started) { this.started = false;
                        this._cancelIfNeeded(); } };
                Ticker.prototype.destroy = function destroy() {
                    this.stop();
                    var listener = this._head.next;
                    while (listener) { listener = listener.destroy(true); }
                    this._head.destroy();
                    this._head = null;
                };
                Ticker.prototype.update = function update() {
                    var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : performance.now();
                    var elapsedMS = void 0;
                    if (currentTime > this.lastTime) {
                        elapsedMS = this.elapsedMS = currentTime - this.lastTime;
                        if (elapsedMS > this._maxElapsedMS) { elapsedMS = this._maxElapsedMS; }
                        this.deltaTime = elapsedMS * _settings2.default.TARGET_FPMS * this.speed;
                        var head = this._head;
                        var listener = head.next;
                        while (listener) { listener = listener.emit(this.deltaTime); }
                        if (!head.next) { this._cancelIfNeeded(); }
                    } else { this.deltaTime = this.elapsedMS = 0; }
                    this.lastTime = currentTime;
                };
                _createClass(Ticker, [{ key: 'FPS', get: function get() { return 1000 / this.elapsedMS; } }, {
                    key: 'minFPS',
                    get: function get() { return 1000 / this._maxElapsedMS; },
                    set: function set(fps) { var minFPMS = Math.min(Math.max(0, fps) / 1000, _settings2.default.TARGET_FPMS);
                        this._maxElapsedMS = 1 / minFPMS; }
                }]);
                return Ticker;
            }();
            exports.default = Ticker;
        }, { "../const": 44, "../settings": 99, "./TickerListener": 117 }],
        117: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var TickerListener = function() {
                function TickerListener(fn) { var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null; var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0; var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
                    _classCallCheck(this, TickerListener);
                    this.fn = fn;
                    this.context = context;
                    this.priority = priority;
                    this.once = once;
                    this.next = null;
                    this.previous = null;
                    this._destroyed = false; }
                TickerListener.prototype.match = function match(fn, context) { context = context || null; return this.fn === fn && this.context === context; };
                TickerListener.prototype.emit = function emit(deltaTime) {
                    if (this.fn) { if (this.context) { this.fn.call(this.context, deltaTime); } else { this.fn(deltaTime); } }
                    var redirect = this.next;
                    if (this.once) { this.destroy(true); }
                    if (this._destroyed) { this.next = null; }
                    return redirect;
                };
                TickerListener.prototype.connect = function connect(previous) {
                    this.previous = previous;
                    if (previous.next) { previous.next.previous = this; }
                    this.next = previous.next;
                    previous.next = this;
                };
                TickerListener.prototype.destroy = function destroy() {
                    var hard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                    this._destroyed = true;
                    this.fn = null;
                    this.context = null;
                    if (this.previous) { this.previous.next = this.next; }
                    if (this.next) { this.next.previous = this.previous; }
                    var redirect = this.previous;
                    this.next = hard ? null : redirect;
                    this.previous = null;
                    return redirect;
                };
                return TickerListener;
            }();
            exports.default = TickerListener;
        }, {}],
        118: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.Ticker = exports.shared = undefined;
            var _Ticker = require('./Ticker');
            var _Ticker2 = _interopRequireDefault(_Ticker);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            var shared = new _Ticker2.default();
            shared.autoStart = true;
            shared.destroy = function() {};
            exports.shared = shared;
            exports.Ticker = _Ticker2.default;
        }, { "./Ticker": 116 }],
        119: [function(require, module, exports) { "use strict";
            exports.__esModule = true;
            exports.default = canUploadSameBuffer;

            function canUploadSameBuffer() { var ios = !!navigator.platform && /iPad|iPhone|iPod/.test(navigator.platform); return !ios; } }, {}],
        120: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;
            exports.default = createIndicesForQuads;

            function createIndicesForQuads(size) {
                var totalIndices = size * 6;
                var indices = new Uint16Array(totalIndices);
                for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) { indices[i + 0] = j + 0;
                    indices[i + 1] = j + 1;
                    indices[i + 2] = j + 2;
                    indices[i + 3] = j + 0;
                    indices[i + 4] = j + 2;
                    indices[i + 5] = j + 3; }
                return indices;
            }
        }, {}],
        121: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = determineCrossOrigin;
            var _url2 = require('url');
            var _url3 = _interopRequireDefault(_url2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            var tempAnchor = void 0;

            function determineCrossOrigin(url) {
                var loc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location;
                if (url.indexOf('data:') === 0) { return ''; }
                loc = loc || window.location;
                if (!tempAnchor) { tempAnchor = document.createElement('a'); }
                tempAnchor.href = url;
                url = _url3.default.parse(tempAnchor.href);
                var samePort = !url.port && loc.port === '' || url.port === loc.port;
                if (url.hostname !== loc.hostname || !samePort || url.protocol !== loc.protocol) { return 'anonymous'; }
                return '';
            }
        }, { "url": 28 }],
        122: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.BaseTextureCache = exports.TextureCache = exports.mixins = exports.pluginTarget = exports.EventEmitter = exports.isMobile = undefined;
            exports.uid = uid;
            exports.hex2rgb = hex2rgb;
            exports.hex2string = hex2string;
            exports.rgb2hex = rgb2hex;
            exports.getResolutionOfUrl = getResolutionOfUrl;
            exports.decomposeDataUri = decomposeDataUri;
            exports.getUrlFileExtension = getUrlFileExtension;
            exports.getSvgSize = getSvgSize;
            exports.skipHello = skipHello;
            exports.sayHello = sayHello;
            exports.isWebGLSupported = isWebGLSupported;
            exports.sign = sign;
            exports.removeItems = removeItems;
            exports.destroyTextureCache = destroyTextureCache;
            exports.clearTextureCache = clearTextureCache;
            var _const = require('../const');
            var _settings = require('../settings');
            var _settings2 = _interopRequireDefault(_settings);
            var _eventemitter = require('eventemitter3');
            var _eventemitter2 = _interopRequireDefault(_eventemitter);
            var _pluginTarget = require('./pluginTarget');
            var _pluginTarget2 = _interopRequireDefault(_pluginTarget);
            var _mixin = require('./mixin');
            var mixins = _interopRequireWildcard(_mixin);
            var _ismobilejs = require('ismobilejs');
            var isMobile = _interopRequireWildcard(_ismobilejs);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            var nextUid = 0;
            var saidHello = false;
            exports.isMobile = isMobile;
            exports.EventEmitter = _eventemitter2.default;
            exports.pluginTarget = _pluginTarget2.default;
            exports.mixins = mixins;

            function uid() { return ++nextUid; }

            function hex2rgb(hex, out) { out = out || [];
                out[0] = (hex >> 16 & 0xFF) / 255;
                out[1] = (hex >> 8 & 0xFF) / 255;
                out[2] = (hex & 0xFF) / 255; return out; }

            function hex2string(hex) { hex = hex.toString(16);
                hex = '000000'.substr(0, 6 - hex.length) + hex; return '#' + hex; }

            function rgb2hex(rgb) { return (rgb[0] * 255 << 16) + (rgb[1] * 255 << 8) + (rgb[2] * 255 | 0); }

            function getResolutionOfUrl(url, defaultValue) {
                var resolution = _settings2.default.RETINA_PREFIX.exec(url);
                if (resolution) { return parseFloat(resolution[1]); }
                return defaultValue !== undefined ? defaultValue : 1;
            }

            function decomposeDataUri(dataUri) {
                var dataUriMatch = _const.DATA_URI.exec(dataUri);
                if (dataUriMatch) { return { mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : undefined, subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : undefined, encoding: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : undefined, data: dataUriMatch[4] }; }
                return undefined;
            }

            function getUrlFileExtension(url) {
                var extension = _const.URL_FILE_EXTENSION.exec(url);
                if (extension) { return extension[1].toLowerCase(); }
                return undefined;
            }

            function getSvgSize(svgString) {
                var sizeMatch = _const.SVG_SIZE.exec(svgString);
                var size = {};
                if (sizeMatch) { size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
                    size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7])); }
                return size;
            }

            function skipHello() { saidHello = true; }

            function sayHello(type) {
                if (saidHello) { return; }
                if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) { var args = ['\n %c %c %c Pixi.js ' + _const.VERSION + ' - \u2730 ' + type + ' \u2730  %c  %c  http://www.pixijs.com/  %c %c \u2665%c\u2665%c\u2665 \n\n', 'background: #ff66a5; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff66a5; background: #030307; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'background: #ffc3dc; padding:5px 0;', 'background: #ff66a5; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;', 'color: #ff2424; background: #fff; padding:5px 0;'];
                    window.console.log.apply(console, args); } else if (window.console) { window.console.log('Pixi.js ' + _const.VERSION + ' - ' + type + ' - http://www.pixijs.com/'); }
                saidHello = true;
            }

            function isWebGLSupported() {
                var contextOptions = { stencil: true, failIfMajorPerformanceCaveat: true };
                try {
                    if (!window.WebGLRenderingContext) { return false; }
                    var canvas = document.createElement('canvas');
                    var gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);
                    var success = !!(gl && gl.getContextAttributes().stencil);
                    if (gl) { var loseContext = gl.getExtension('WEBGL_lose_context'); if (loseContext) { loseContext.loseContext(); } }
                    gl = null;
                    return success;
                } catch (e) { return false; }
            }

            function sign(n) { if (n === 0) return 0; return n < 0 ? -1 : 1; }

            function removeItems(arr, startIdx, removeCount) {
                var length = arr.length;
                if (startIdx >= length || removeCount === 0) { return; }
                removeCount = startIdx + removeCount > length ? length - startIdx : removeCount;
                var len = length - removeCount;
                for (var i = startIdx; i < len; ++i) { arr[i] = arr[i + removeCount]; }
                arr.length = len;
            }
            var TextureCache = exports.TextureCache = Object.create(null);
            var BaseTextureCache = exports.BaseTextureCache = Object.create(null);

            function destroyTextureCache() {
                var key = void 0;
                for (key in TextureCache) { TextureCache[key].destroy(); }
                for (key in BaseTextureCache) { BaseTextureCache[key].destroy(); }
            }

            function clearTextureCache() {
                var key = void 0;
                for (key in TextureCache) { delete TextureCache[key]; }
                for (key in BaseTextureCache) { delete BaseTextureCache[key]; }
            }
        }, { "../const": 44, "../settings": 99, "./mixin": 124, "./pluginTarget": 125, "eventemitter3": 3, "ismobilejs": 4 }],
        123: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = maxRecommendedTextures;
            var _ismobilejs = require('ismobilejs');
            var _ismobilejs2 = _interopRequireDefault(_ismobilejs);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function maxRecommendedTextures(max) {
                if (_ismobilejs2.default.tablet || _ismobilejs2.default.phone) { return 4; }
                return max;
            }
        }, { "ismobilejs": 4 }],
        124: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;
            exports.mixin = mixin;
            exports.delayMixin = delayMixin;
            exports.performMixins = performMixins;

            function mixin(target, source) { if (!target || !source) return; var keys = Object.keys(source); for (var i = 0; i < keys.length; ++i) { var propertyName = keys[i];
                    Object.defineProperty(target, propertyName, Object.getOwnPropertyDescriptor(source, propertyName)); } }
            var mixins = [];

            function delayMixin(target, source) { mixins.push(target, source); }

            function performMixins() {
                for (var i = 0; i < mixins.length; i += 2) { mixin(mixins[i], mixins[i + 1]); }
                mixins.length = 0;
            }
        }, {}],
        125: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;

            function pluginTarget(obj) {
                obj.__plugins = {};
                obj.registerPlugin = function registerPlugin(pluginName, ctor) { obj.__plugins[pluginName] = ctor; };
                obj.prototype.initPlugins = function initPlugins() { this.plugins = this.plugins || {}; for (var o in obj.__plugins) { this.plugins[o] = new obj.__plugins[o](this); } };
                obj.prototype.destroyPlugins = function destroyPlugins() {
                    for (var o in this.plugins) { this.plugins[o].destroy();
                        this.plugins[o] = null; }
                    this.plugins = null;
                };
            }
            exports.default = { mixin: function mixin(obj) { pluginTarget(obj); } };
        }, {}],
        126: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = trimCanvas;

            function trimCanvas(canvas) {
                var width = canvas.width;
                var height = canvas.height;
                var context = canvas.getContext('2d');
                var imageData = context.getImageData(0, 0, width, height);
                var pixels = imageData.data;
                var len = pixels.length;
                var bound = { top: null, left: null, right: null, bottom: null };
                var i = void 0;
                var x = void 0;
                var y = void 0;
                for (i = 0; i < len; i += 4) {
                    if (pixels[i + 3] !== 0) {
                        x = i / 4 % width;
                        y = ~~(i / 4 / width);
                        if (bound.top === null) { bound.top = y; }
                        if (bound.left === null) { bound.left = x; } else if (x < bound.left) { bound.left = x; }
                        if (bound.right === null) { bound.right = x + 1; } else if (bound.right < x) { bound.right = x + 1; }
                        if (bound.bottom === null) { bound.bottom = y; } else if (bound.bottom < y) { bound.bottom = y; }
                    }
                }
                width = bound.right - bound.left;
                height = bound.bottom - bound.top + 1;
                var data = context.getImageData(bound.left, bound.top, width, height);
                return { height: height, width: width, data: data };
            }
        }, {}],
        127: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = deprecation;

            function warn(msg) { var stack = new Error().stack; if (typeof stack === 'undefined') { console.warn('Deprecation Warning: ', msg); } else { stack = stack.split('\n').splice(3).join('\n'); if (console.groupCollapsed) { console.groupCollapsed('%cDeprecation Warning: %c%s', 'color:#614108;background:#fffbe6', 'font-weight:normal;color:#614108;background:#fffbe6', msg);
                        console.warn(stack);
                        console.groupEnd(); } else { console.warn('Deprecation Warning: ', msg);
                        console.warn(stack); } } }

            function deprecation(core) {
                var mesh = core.mesh,
                    particles = core.particles,
                    extras = core.extras,
                    filters = core.filters,
                    prepare = core.prepare,
                    loaders = core.loaders,
                    interaction = core.interaction;
                Object.defineProperties(core, { SpriteBatch: { get: function get() { throw new ReferenceError('SpriteBatch does not exist any more, ' + 'please use the new ParticleContainer instead.'); } }, AssetLoader: { get: function get() { throw new ReferenceError('The loader system was overhauled in pixi v3, ' + 'please see the new PIXI.loaders.Loader class.'); } }, Stage: { get: function get() { warn('You do not need to use a PIXI Stage any more, you can simply render any container.'); return core.Container; } }, DisplayObjectContainer: { get: function get() { warn('DisplayObjectContainer has been shortened to Container, please use Container from now on.'); return core.Container; } }, Strip: { get: function get() { warn('The Strip class has been renamed to Mesh and moved to mesh.Mesh, please use mesh.Mesh from now on.'); return mesh.Mesh; } }, Rope: { get: function get() { warn('The Rope class has been moved to mesh.Rope, please use mesh.Rope from now on.'); return mesh.Rope; } }, ParticleContainer: { get: function get() { warn('The ParticleContainer class has been moved to particles.ParticleContainer, ' + 'please use particles.ParticleContainer from now on.'); return particles.ParticleContainer; } }, MovieClip: { get: function get() { warn('The MovieClip class has been moved to extras.AnimatedSprite, please use extras.AnimatedSprite.'); return extras.AnimatedSprite; } }, TilingSprite: { get: function get() { warn('The TilingSprite class has been moved to extras.TilingSprite, ' + 'please use extras.TilingSprite from now on.'); return extras.TilingSprite; } }, BitmapText: { get: function get() { warn('The BitmapText class has been moved to extras.BitmapText, ' + 'please use extras.BitmapText from now on.'); return extras.BitmapText; } }, blendModes: { get: function get() { warn('The blendModes has been moved to BLEND_MODES, please use BLEND_MODES from now on.'); return core.BLEND_MODES; } }, scaleModes: { get: function get() { warn('The scaleModes has been moved to SCALE_MODES, please use SCALE_MODES from now on.'); return core.SCALE_MODES; } }, BaseTextureCache: { get: function get() { warn('The BaseTextureCache class has been moved to utils.BaseTextureCache, ' + 'please use utils.BaseTextureCache from now on.'); return core.utils.BaseTextureCache; } }, TextureCache: { get: function get() { warn('The TextureCache class has been moved to utils.TextureCache, ' + 'please use utils.TextureCache from now on.'); return core.utils.TextureCache; } }, math: { get: function get() { warn('The math namespace is deprecated, please access members already accessible on PIXI.'); return core; } }, AbstractFilter: { get: function get() { warn('AstractFilter has been renamed to Filter, please use PIXI.Filter'); return core.Filter; } }, TransformManual: { get: function get() { warn('TransformManual has been renamed to TransformBase, please update your pixi-spine'); return core.TransformBase; } }, TARGET_FPMS: { get: function get() { warn('PIXI.TARGET_FPMS has been deprecated, please use PIXI.settings.TARGET_FPMS'); return core.settings.TARGET_FPMS; }, set: function set(value) { warn('PIXI.TARGET_FPMS has been deprecated, please use PIXI.settings.TARGET_FPMS');
                            core.settings.TARGET_FPMS = value; } }, FILTER_RESOLUTION: { get: function get() { warn('PIXI.FILTER_RESOLUTION has been deprecated, please use PIXI.settings.FILTER_RESOLUTION'); return core.settings.FILTER_RESOLUTION; }, set: function set(value) { warn('PIXI.FILTER_RESOLUTION has been deprecated, please use PIXI.settings.FILTER_RESOLUTION');
                            core.settings.FILTER_RESOLUTION = value; } }, RESOLUTION: { get: function get() { warn('PIXI.RESOLUTION has been deprecated, please use PIXI.settings.RESOLUTION'); return core.settings.RESOLUTION; }, set: function set(value) { warn('PIXI.RESOLUTION has been deprecated, please use PIXI.settings.RESOLUTION');
                            core.settings.RESOLUTION = value; } }, MIPMAP_TEXTURES: { get: function get() { warn('PIXI.MIPMAP_TEXTURES has been deprecated, please use PIXI.settings.MIPMAP_TEXTURES'); return core.settings.MIPMAP_TEXTURES; }, set: function set(value) { warn('PIXI.MIPMAP_TEXTURES has been deprecated, please use PIXI.settings.MIPMAP_TEXTURES');
                            core.settings.MIPMAP_TEXTURES = value; } }, SPRITE_BATCH_SIZE: { get: function get() { warn('PIXI.SPRITE_BATCH_SIZE has been deprecated, please use PIXI.settings.SPRITE_BATCH_SIZE'); return core.settings.SPRITE_BATCH_SIZE; }, set: function set(value) { warn('PIXI.SPRITE_BATCH_SIZE has been deprecated, please use PIXI.settings.SPRITE_BATCH_SIZE');
                            core.settings.SPRITE_BATCH_SIZE = value; } }, SPRITE_MAX_TEXTURES: { get: function get() { warn('PIXI.SPRITE_MAX_TEXTURES has been deprecated, please use PIXI.settings.SPRITE_MAX_TEXTURES'); return core.settings.SPRITE_MAX_TEXTURES; }, set: function set(value) { warn('PIXI.SPRITE_MAX_TEXTURES has been deprecated, please use PIXI.settings.SPRITE_MAX_TEXTURES');
                            core.settings.SPRITE_MAX_TEXTURES = value; } }, RETINA_PREFIX: { get: function get() { warn('PIXI.RETINA_PREFIX has been deprecated, please use PIXI.settings.RETINA_PREFIX'); return core.settings.RETINA_PREFIX; }, set: function set(value) { warn('PIXI.RETINA_PREFIX has been deprecated, please use PIXI.settings.RETINA_PREFIX');
                            core.settings.RETINA_PREFIX = value; } }, DEFAULT_RENDER_OPTIONS: { get: function get() { warn('PIXI.DEFAULT_RENDER_OPTIONS has been deprecated, please use PIXI.settings.DEFAULT_RENDER_OPTIONS'); return core.settings.RENDER_OPTIONS; } } });
                var defaults = [{ parent: 'TRANSFORM_MODE', target: 'TRANSFORM_MODE' }, { parent: 'GC_MODES', target: 'GC_MODE' }, { parent: 'WRAP_MODES', target: 'WRAP_MODE' }, { parent: 'SCALE_MODES', target: 'SCALE_MODE' }, { parent: 'PRECISION', target: 'PRECISION_FRAGMENT' }];
                var _loop = function _loop(i) { var deprecation = defaults[i];
                    Object.defineProperty(core[deprecation.parent], 'DEFAULT', { get: function get() { warn('PIXI.' + deprecation.parent + '.DEFAULT has been deprecated, ' + ('please use PIXI.settings.' + deprecation.target)); return core.settings[deprecation.target]; }, set: function set(value) { warn('PIXI.' + deprecation.parent + '.DEFAULT has been deprecated, ' + ('please use PIXI.settings.' + deprecation.target));
                            core.settings[deprecation.target] = value; } }); };
                for (var i = 0; i < defaults.length; i++) { _loop(i); }
                Object.defineProperties(core.settings, { PRECISION: { get: function get() { warn('PIXI.settings.PRECISION has been deprecated, please use PIXI.settings.PRECISION_FRAGMENT'); return core.settings.PRECISION_FRAGMENT; }, set: function set(value) { warn('PIXI.settings.PRECISION has been deprecated, please use PIXI.settings.PRECISION_FRAGMENT');
                            core.settings.PRECISION_FRAGMENT = value; } } });
                Object.defineProperties(extras, { MovieClip: { get: function get() { warn('The MovieClip class has been renamed to AnimatedSprite, please use AnimatedSprite from now on.'); return extras.AnimatedSprite; } } });
                core.DisplayObject.prototype.generateTexture = function generateTexture(renderer, scaleMode, resolution) { warn('generateTexture has moved to the renderer, please use renderer.generateTexture(displayObject)'); return renderer.generateTexture(this, scaleMode, resolution); };
                core.Graphics.prototype.generateTexture = function generateTexture(scaleMode, resolution) { warn('graphics generate texture has moved to the renderer. ' + 'Or to render a graphics to a texture using canvas please use generateCanvasTexture'); return this.generateCanvasTexture(scaleMode, resolution); };
                core.RenderTexture.prototype.render = function render(displayObject, matrix, clear, updateTransform) { this.legacyRenderer.render(displayObject, this, clear, matrix, !updateTransform);
                    warn('RenderTexture.render is now deprecated, please use renderer.render(displayObject, renderTexture)'); };
                core.RenderTexture.prototype.getImage = function getImage(target) { warn('RenderTexture.getImage is now deprecated, please use renderer.extract.image(target)'); return this.legacyRenderer.extract.image(target); };
                core.RenderTexture.prototype.getBase64 = function getBase64(target) { warn('RenderTexture.getBase64 is now deprecated, please use renderer.extract.base64(target)'); return this.legacyRenderer.extract.base64(target); };
                core.RenderTexture.prototype.getCanvas = function getCanvas(target) { warn('RenderTexture.getCanvas is now deprecated, please use renderer.extract.canvas(target)'); return this.legacyRenderer.extract.canvas(target); };
                core.RenderTexture.prototype.getPixels = function getPixels(target) { warn('RenderTexture.getPixels is now deprecated, please use renderer.extract.pixels(target)'); return this.legacyRenderer.pixels(target); };
                core.Sprite.prototype.setTexture = function setTexture(texture) { this.texture = texture;
                    warn('setTexture is now deprecated, please use the texture property, e.g : sprite.texture = texture;'); };
                extras.BitmapText.prototype.setText = function setText(text) { this.text = text;
                    warn('setText is now deprecated, please use the text property, e.g : myBitmapText.text = \'my text\';'); };
                core.Text.prototype.setText = function setText(text) { this.text = text;
                    warn('setText is now deprecated, please use the text property, e.g : myText.text = \'my text\';'); };
                core.Text.calculateFontProperties = function calculateFontProperties(font) { warn('Text.calculateFontProperties is now deprecated, please use the TextMetrics.measureFont'); return core.TextMetrics.measureFont(font); };
                Object.defineProperties(core.Text, { fontPropertiesCache: { get: function get() { warn('Text.fontPropertiesCache is deprecated'); return core.TextMetrics._fonts; } }, fontPropertiesCanvas: { get: function get() { warn('Text.fontPropertiesCanvas is deprecated'); return core.TextMetrics._canvas; } }, fontPropertiesContext: { get: function get() { warn('Text.fontPropertiesContext is deprecated'); return core.TextMetrics._context; } } });
                core.Text.prototype.setStyle = function setStyle(style) { this.style = style;
                    warn('setStyle is now deprecated, please use the style property, e.g : myText.style = style;'); };
                core.Text.prototype.determineFontProperties = function determineFontProperties(fontStyle) { warn('determineFontProperties is now deprecated, please use TextMetrics.measureFont method'); return core.TextMetrics.measureFont(fontStyle); };
                core.Text.getFontStyle = function getFontStyle(style) {
                    warn('getFontStyle is now deprecated, please use TextStyle.toFontString() instead');
                    style = style || {};
                    if (!(style instanceof core.TextStyle)) { style = new core.TextStyle(style); }
                    return style.toFontString();
                };
                Object.defineProperties(core.TextStyle.prototype, {
                    font: {
                        get: function get() { warn('text style property \'font\' is now deprecated, please use the ' + '\'fontFamily\', \'fontSize\', \'fontStyle\', \'fontVariant\' and \'fontWeight\' properties from now on'); var fontSizeString = typeof this._fontSize === 'number' ? this._fontSize + 'px' : this._fontSize; return this._fontStyle + ' ' + this._fontVariant + ' ' + this._fontWeight + ' ' + fontSizeString + ' ' + this._fontFamily; },
                        set: function set(font) {
                            warn('text style property \'font\' is now deprecated, please use the ' + '\'fontFamily\',\'fontSize\',fontStyle\',\'fontVariant\' and \'fontWeight\' properties from now on');
                            if (font.indexOf('italic') > 1) { this._fontStyle = 'italic'; } else if (font.indexOf('oblique') > -1) { this._fontStyle = 'oblique'; } else { this._fontStyle = 'normal'; }
                            if (font.indexOf('small-caps') > -1) { this._fontVariant = 'small-caps'; } else { this._fontVariant = 'normal'; }
                            var splits = font.split(' ');
                            var fontSizeIndex = -1;
                            this._fontSize = 26;
                            for (var i = 0; i < splits.length; ++i) { if (splits[i].match(/(px|pt|em|%)/)) { fontSizeIndex = i;
                                    this._fontSize = splits[i]; break; } }
                            this._fontWeight = 'normal';
                            for (var _i = 0; _i < fontSizeIndex; ++_i) { if (splits[_i].match(/(bold|bolder|lighter|100|200|300|400|500|600|700|800|900)/)) { this._fontWeight = splits[_i]; break; } }
                            if (fontSizeIndex > -1 && fontSizeIndex < splits.length - 1) {
                                this._fontFamily = '';
                                for (var _i2 = fontSizeIndex + 1; _i2 < splits.length; ++_i2) { this._fontFamily += splits[_i2] + ' '; }
                                this._fontFamily = this._fontFamily.slice(0, -1);
                            } else { this._fontFamily = 'Arial'; }
                            this.styleID++;
                        }
                    }
                });
                core.Texture.prototype.setFrame = function setFrame(frame) { this.frame = frame;
                    warn('setFrame is now deprecated, please use the frame property, e.g: myTexture.frame = frame;'); };
                core.Texture.addTextureToCache = function addTextureToCache(texture, id) { core.Texture.addToCache(texture, id);
                    warn('Texture.addTextureToCache is deprecated, please use Texture.addToCache from now on.'); };
                core.Texture.removeTextureFromCache = function removeTextureFromCache(id) { warn('Texture.removeTextureFromCache is deprecated, please use Texture.removeFromCache from now on. ' + 'Be aware that Texture.removeFromCache does not automatically its BaseTexture from the BaseTextureCache. ' + 'For that, use BaseTexture.removeFromCache');
                    core.BaseTexture.removeFromCache(id); return core.Texture.removeFromCache(id); };
                Object.defineProperties(filters, { AbstractFilter: { get: function get() { warn('AstractFilter has been renamed to Filter, please use PIXI.Filter'); return core.AbstractFilter; } }, SpriteMaskFilter: { get: function get() { warn('filters.SpriteMaskFilter is an undocumented alias, please use SpriteMaskFilter from now on.'); return core.SpriteMaskFilter; } } });
                core.utils.uuid = function() { warn('utils.uuid() is deprecated, please use utils.uid() from now on.'); return core.utils.uid(); };
                core.utils.canUseNewCanvasBlendModes = function() { warn('utils.canUseNewCanvasBlendModes() is deprecated, please use CanvasTinter.canUseMultiply from now on'); return core.CanvasTinter.canUseMultiply; };
                var saidHello = true;
                Object.defineProperty(core.utils, '_saidHello', {
                    set: function set(bool) {
                        if (bool) { warn('PIXI.utils._saidHello is deprecated, please use PIXI.utils.skipHello()');
                            this.skipHello(); }
                        saidHello = bool;
                    },
                    get: function get() { return saidHello; }
                });
                prepare.BasePrepare.prototype.register = function register(addHook, uploadHook) {
                    warn('renderer.plugins.prepare.register is now deprecated, ' + 'please use renderer.plugins.prepare.registerFindHook & renderer.plugins.prepare.registerUploadHook');
                    if (addHook) { this.registerFindHook(addHook); }
                    if (uploadHook) { this.registerUploadHook(uploadHook); }
                    return this;
                };
                Object.defineProperty(prepare.canvas, 'UPLOADS_PER_FRAME', { set: function set() { warn('PIXI.CanvasPrepare.UPLOADS_PER_FRAME has been removed. Please set ' + 'renderer.plugins.prepare.limiter.maxItemsPerFrame on your renderer'); }, get: function get() { warn('PIXI.CanvasPrepare.UPLOADS_PER_FRAME has been removed. Please use ' + 'renderer.plugins.prepare.limiter'); return NaN; } });
                Object.defineProperty(prepare.webgl, 'UPLOADS_PER_FRAME', { set: function set() { warn('PIXI.WebGLPrepare.UPLOADS_PER_FRAME has been removed. Please set ' + 'renderer.plugins.prepare.limiter.maxItemsPerFrame on your renderer'); }, get: function get() { warn('PIXI.WebGLPrepare.UPLOADS_PER_FRAME has been removed. Please use ' + 'renderer.plugins.prepare.limiter'); return NaN; } });
                if (loaders.Loader) {
                    (function() { var Resource = loaders.Resource; var Loader = loaders.Loader;
                        Object.defineProperties(Resource.prototype, { isJson: { get: function get() { warn('The isJson property is deprecated, please use `resource.type === Resource.TYPE.JSON`.'); return this.type === Resource.TYPE.JSON; } }, isXml: { get: function get() { warn('The isXml property is deprecated, please use `resource.type === Resource.TYPE.XML`.'); return this.type === Resource.TYPE.XML; } }, isImage: { get: function get() { warn('The isImage property is deprecated, please use `resource.type === Resource.TYPE.IMAGE`.'); return this.type === Resource.TYPE.IMAGE; } }, isAudio: { get: function get() { warn('The isAudio property is deprecated, please use `resource.type === Resource.TYPE.AUDIO`.'); return this.type === Resource.TYPE.AUDIO; } }, isVideo: { get: function get() { warn('The isVideo property is deprecated, please use `resource.type === Resource.TYPE.VIDEO`.'); return this.type === Resource.TYPE.VIDEO; } } });
                        Object.defineProperties(Loader.prototype, { before: { get: function get() { warn('The before() method is deprecated, please use pre().'); return this.pre; } }, after: { get: function get() { warn('The after() method is deprecated, please use use().'); return this.use; } } }); })(); }
                Object.defineProperty(interaction.interactiveTarget, 'defaultCursor', { set: function set(value) { warn('Property defaultCursor has been replaced with \'cursor\'. ');
                        this.cursor = value; }, get: function get() { warn('Property defaultCursor has been replaced with \'cursor\'. '); return this.cursor; } });
                Object.defineProperty(interaction.InteractionManager, 'defaultCursorStyle', { set: function set(value) { warn('Property defaultCursorStyle has been replaced with \'cursorStyles.default\'. ');
                        this.cursorStyles.default = value; }, get: function get() { warn('Property defaultCursorStyle has been replaced with \'cursorStyles.default\'. '); return this.cursorStyles.default; } });
                Object.defineProperty(interaction.InteractionManager, 'currentCursorStyle', { set: function set(value) { warn('Property currentCursorStyle has been removed.' + 'See the currentCursorMode property, which works differently.');
                        this.currentCursorMode = value; }, get: function get() { warn('Property currentCursorStyle has been removed.' + 'See the currentCursorMode property, which works differently.'); return this.currentCursorMode; } });
            }
        }, {}],
        128: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var TEMP_RECT = new core.Rectangle();
            var CanvasExtract = function() {
                function CanvasExtract(renderer) { _classCallCheck(this, CanvasExtract);
                    this.renderer = renderer;
                    renderer.extract = this; }
                CanvasExtract.prototype.image = function image(target) { var image = new Image();
                    image.src = this.base64(target); return image; };
                CanvasExtract.prototype.base64 = function base64(target) { return this.canvas(target).toDataURL(); };
                CanvasExtract.prototype.canvas = function canvas(target) {
                    var renderer = this.renderer;
                    var context = void 0;
                    var resolution = void 0;
                    var frame = void 0;
                    var renderTexture = void 0;
                    if (target) { if (target instanceof core.RenderTexture) { renderTexture = target; } else { renderTexture = renderer.generateTexture(target); } }
                    if (renderTexture) { context = renderTexture.baseTexture._canvasRenderTarget.context;
                        resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
                        frame = renderTexture.frame; } else { context = renderer.rootContext;
                        frame = TEMP_RECT;
                        frame.width = this.renderer.width;
                        frame.height = this.renderer.height; }
                    var width = frame.width * resolution;
                    var height = frame.height * resolution;
                    var canvasBuffer = new core.CanvasRenderTarget(width, height);
                    var canvasData = context.getImageData(frame.x * resolution, frame.y * resolution, width, height);
                    canvasBuffer.context.putImageData(canvasData, 0, 0);
                    return canvasBuffer.canvas;
                };
                CanvasExtract.prototype.pixels = function pixels(target) {
                    var renderer = this.renderer;
                    var context = void 0;
                    var resolution = void 0;
                    var frame = void 0;
                    var renderTexture = void 0;
                    if (target) { if (target instanceof core.RenderTexture) { renderTexture = target; } else { renderTexture = renderer.generateTexture(target); } }
                    if (renderTexture) { context = renderTexture.baseTexture._canvasRenderTarget.context;
                        resolution = renderTexture.baseTexture._canvasRenderTarget.resolution;
                        frame = renderTexture.frame; } else { context = renderer.rootContext;
                        frame = TEMP_RECT;
                        frame.width = renderer.width;
                        frame.height = renderer.height; }
                    return context.getImageData(0, 0, frame.width * resolution, frame.height * resolution).data;
                };
                CanvasExtract.prototype.destroy = function destroy() { this.renderer.extract = null;
                    this.renderer = null; };
                return CanvasExtract;
            }();
            exports.default = CanvasExtract;
            core.CanvasRenderer.registerPlugin('extract', CanvasExtract);
        }, { "../../core": 63 }],
        129: [function(require, module, exports) { 'use strict';
            exports.__esModule = true; var _WebGLExtract = require('./webgl/WebGLExtract');
            Object.defineProperty(exports, 'webgl', { enumerable: true, get: function get() { return _interopRequireDefault(_WebGLExtract).default; } }); var _CanvasExtract = require('./canvas/CanvasExtract');
            Object.defineProperty(exports, 'canvas', { enumerable: true, get: function get() { return _interopRequireDefault(_CanvasExtract).default; } });

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } }, { "./canvas/CanvasExtract": 128, "./webgl/WebGLExtract": 130 }],
        130: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var TEMP_RECT = new core.Rectangle();
            var BYTES_PER_PIXEL = 4;
            var WebGLExtract = function() {
                function WebGLExtract(renderer) { _classCallCheck(this, WebGLExtract);
                    this.renderer = renderer;
                    renderer.extract = this; }
                WebGLExtract.prototype.image = function image(target) { var image = new Image();
                    image.src = this.base64(target); return image; };
                WebGLExtract.prototype.base64 = function base64(target) { return this.canvas(target).toDataURL(); };
                WebGLExtract.prototype.canvas = function canvas(target) {
                    var renderer = this.renderer;
                    var textureBuffer = void 0;
                    var resolution = void 0;
                    var frame = void 0;
                    var flipY = false;
                    var renderTexture = void 0;
                    if (target) { if (target instanceof core.RenderTexture) { renderTexture = target; } else { renderTexture = this.renderer.generateTexture(target); } }
                    if (renderTexture) { textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];
                        resolution = textureBuffer.resolution;
                        frame = renderTexture.frame;
                        flipY = false; } else { textureBuffer = this.renderer.rootRenderTarget;
                        resolution = textureBuffer.resolution;
                        flipY = true;
                        frame = TEMP_RECT;
                        frame.width = textureBuffer.size.width;
                        frame.height = textureBuffer.size.height; }
                    var width = frame.width * resolution;
                    var height = frame.height * resolution;
                    var canvasBuffer = new core.CanvasRenderTarget(width, height);
                    if (textureBuffer) { renderer.bindRenderTarget(textureBuffer); var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height); var gl = renderer.gl;
                        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels); var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
                        canvasData.data.set(webglPixels);
                        canvasBuffer.context.putImageData(canvasData, 0, 0); if (flipY) { canvasBuffer.context.scale(1, -1);
                            canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height); } }
                    return canvasBuffer.canvas;
                };
                WebGLExtract.prototype.pixels = function pixels(target) {
                    var renderer = this.renderer;
                    var textureBuffer = void 0;
                    var resolution = void 0;
                    var frame = void 0;
                    var renderTexture = void 0;
                    if (target) { if (target instanceof core.RenderTexture) { renderTexture = target; } else { renderTexture = this.renderer.generateTexture(target); } }
                    if (renderTexture) { textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];
                        resolution = textureBuffer.resolution;
                        frame = renderTexture.frame; } else { textureBuffer = this.renderer.rootRenderTarget;
                        resolution = textureBuffer.resolution;
                        frame = TEMP_RECT;
                        frame.width = textureBuffer.size.width;
                        frame.height = textureBuffer.size.height; }
                    var width = frame.width * resolution;
                    var height = frame.height * resolution;
                    var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);
                    if (textureBuffer) { renderer.bindRenderTarget(textureBuffer); var gl = renderer.gl;
                        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels); }
                    return webglPixels;
                };
                WebGLExtract.prototype.destroy = function destroy() { this.renderer.extract = null;
                    this.renderer = null; };
                return WebGLExtract;
            }();
            exports.default = WebGLExtract;
            core.WebGLRenderer.registerPlugin('extract', WebGLExtract);
        }, { "../../core": 63 }],
        131: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _core = require('../core');
            var core = _interopRequireWildcard(_core);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var AnimatedSprite = function(_core$Sprite) {
                _inherits(AnimatedSprite, _core$Sprite);

                function AnimatedSprite(textures, autoUpdate) { _classCallCheck(this, AnimatedSprite); var _this = _possibleConstructorReturn(this, _core$Sprite.call(this, textures[0] instanceof core.Texture ? textures[0] : textures[0].texture));
                    _this._textures = null;
                    _this._durations = null;
                    _this.textures = textures;
                    _this._autoUpdate = autoUpdate !== false;
                    _this.animationSpeed = 1;
                    _this.loop = true;
                    _this.onComplete = null;
                    _this.onFrameChange = null;
                    _this._currentTime = 0;
                    _this.playing = false; return _this; }
                AnimatedSprite.prototype.stop = function stop() {
                    if (!this.playing) { return; }
                    this.playing = false;
                    if (this._autoUpdate) { core.ticker.shared.remove(this.update, this); }
                };
                AnimatedSprite.prototype.play = function play() {
                    if (this.playing) { return; }
                    this.playing = true;
                    if (this._autoUpdate) { core.ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.HIGH); }
                };
                AnimatedSprite.prototype.gotoAndStop = function gotoAndStop(frameNumber) { this.stop(); var previousFrame = this.currentFrame;
                    this._currentTime = frameNumber; if (previousFrame !== this.currentFrame) { this.updateTexture(); } };
                AnimatedSprite.prototype.gotoAndPlay = function gotoAndPlay(frameNumber) {
                    var previousFrame = this.currentFrame;
                    this._currentTime = frameNumber;
                    if (previousFrame !== this.currentFrame) { this.updateTexture(); }
                    this.play();
                };
                AnimatedSprite.prototype.update = function update(deltaTime) {
                    var elapsed = this.animationSpeed * deltaTime;
                    var previousFrame = this.currentFrame;
                    if (this._durations !== null) {
                        var lag = this._currentTime % 1 * this._durations[this.currentFrame];
                        lag += elapsed / 60 * 1000;
                        while (lag < 0) { this._currentTime--;
                            lag += this._durations[this.currentFrame]; }
                        var sign = Math.sign(this.animationSpeed * deltaTime);
                        this._currentTime = Math.floor(this._currentTime);
                        while (lag >= this._durations[this.currentFrame]) { lag -= this._durations[this.currentFrame] * sign;
                            this._currentTime += sign; }
                        this._currentTime += lag / this._durations[this.currentFrame];
                    } else { this._currentTime += elapsed; }
                    if (this._currentTime < 0 && !this.loop) { this.gotoAndStop(0); if (this.onComplete) { this.onComplete(); } } else if (this._currentTime >= this._textures.length && !this.loop) { this.gotoAndStop(this._textures.length - 1); if (this.onComplete) { this.onComplete(); } } else if (previousFrame !== this.currentFrame) { this.updateTexture(); }
                };
                AnimatedSprite.prototype.updateTexture = function updateTexture() { this._texture = this._textures[this.currentFrame];
                    this._textureID = -1; if (this.onFrameChange) { this.onFrameChange(this.currentFrame); } };
                AnimatedSprite.prototype.destroy = function destroy() { this.stop();
                    _core$Sprite.prototype.destroy.call(this); };
                AnimatedSprite.fromFrames = function fromFrames(frames) {
                    var textures = [];
                    for (var i = 0; i < frames.length; ++i) { textures.push(core.Texture.fromFrame(frames[i])); }
                    return new AnimatedSprite(textures);
                };
                AnimatedSprite.fromImages = function fromImages(images) {
                    var textures = [];
                    for (var i = 0; i < images.length; ++i) { textures.push(core.Texture.fromImage(images[i])); }
                    return new AnimatedSprite(textures);
                };
                _createClass(AnimatedSprite, [{ key: 'totalFrames', get: function get() { return this._textures.length; } }, {
                    key: 'textures',
                    get: function get() { return this._textures; },
                    set: function set(value) { if (value[0] instanceof core.Texture) { this._textures = value;
                            this._durations = null; } else { this._textures = [];
                            this._durations = []; for (var i = 0; i < value.length; i++) { this._textures.push(value[i].texture);
                                this._durations.push(value[i].time); } } }
                }, {
                    key: 'currentFrame',
                    get: function get() {
                        var currentFrame = Math.floor(this._currentTime) % this._textures.length;
                        if (currentFrame < 0) { currentFrame += this._textures.length; }
                        return currentFrame;
                    }
                }]);
                return AnimatedSprite;
            }(core.Sprite);
            exports.default = AnimatedSprite;
        }, { "../core": 63 }],
        132: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _core = require('../core');
            var core = _interopRequireWildcard(_core);
            var _ObservablePoint = require('../core/math/ObservablePoint');
            var _ObservablePoint2 = _interopRequireDefault(_ObservablePoint);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var BitmapText = function(_core$Container) {
                _inherits(BitmapText, _core$Container);

                function BitmapText(text) { var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
                    _classCallCheck(this, BitmapText); var _this = _possibleConstructorReturn(this, _core$Container.call(this));
                    _this._textWidth = 0;
                    _this._textHeight = 0;
                    _this._glyphs = [];
                    _this._font = { tint: style.tint !== undefined ? style.tint : 0xFFFFFF, align: style.align || 'left', name: null, size: 0 };
                    _this.font = style.font;
                    _this._text = text;
                    _this.maxWidth = 0;
                    _this.maxLineHeight = 0;
                    _this._anchor = new _ObservablePoint2.default(function() { _this.dirty = true; }, _this, 0, 0);
                    _this.dirty = false;
                    _this.updateText(); return _this; }
                BitmapText.prototype.updateText = function updateText() {
                    var data = BitmapText.fonts[this._font.name];
                    var scale = this._font.size / data.size;
                    var pos = new core.Point();
                    var chars = [];
                    var lineWidths = [];
                    var prevCharCode = null;
                    var lastLineWidth = 0;
                    var maxLineWidth = 0;
                    var line = 0;
                    var lastSpace = -1;
                    var lastSpaceWidth = 0;
                    var maxLineHeight = 0;
                    for (var i = 0; i < this.text.length; i++) {
                        var charCode = this.text.charCodeAt(i);
                        if (/(\s)/.test(this.text.charAt(i))) { lastSpace = i;
                            lastSpaceWidth = lastLineWidth; }
                        if (/(?:\r\n|\r|\n)/.test(this.text.charAt(i))) { lineWidths.push(lastLineWidth);
                            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
                            line++;
                            pos.x = 0;
                            pos.y += data.lineHeight;
                            prevCharCode = null; continue; }
                        if (lastSpace !== -1 && this.maxWidth > 0 && pos.x * scale > this.maxWidth) { core.utils.removeItems(chars, lastSpace, i - lastSpace);
                            i = lastSpace;
                            lastSpace = -1;
                            lineWidths.push(lastSpaceWidth);
                            maxLineWidth = Math.max(maxLineWidth, lastSpaceWidth);
                            line++;
                            pos.x = 0;
                            pos.y += data.lineHeight;
                            prevCharCode = null; continue; }
                        var charData = data.chars[charCode];
                        if (!charData) { continue; }
                        if (prevCharCode && charData.kerning[prevCharCode]) { pos.x += charData.kerning[prevCharCode]; }
                        chars.push({ texture: charData.texture, line: line, charCode: charCode, position: new core.Point(pos.x + charData.xOffset, pos.y + charData.yOffset) });
                        lastLineWidth = pos.x + (charData.texture.width + charData.xOffset);
                        pos.x += charData.xAdvance;
                        maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);
                        prevCharCode = charCode;
                    }
                    lineWidths.push(lastLineWidth);
                    maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
                    var lineAlignOffsets = [];
                    for (var _i = 0; _i <= line; _i++) {
                        var alignOffset = 0;
                        if (this._font.align === 'right') { alignOffset = maxLineWidth - lineWidths[_i]; } else if (this._font.align === 'center') { alignOffset = (maxLineWidth - lineWidths[_i]) / 2; }
                        lineAlignOffsets.push(alignOffset);
                    }
                    var lenChars = chars.length;
                    var tint = this.tint;
                    for (var _i2 = 0; _i2 < lenChars; _i2++) {
                        var c = this._glyphs[_i2];
                        if (c) { c.texture = chars[_i2].texture; } else { c = new core.Sprite(chars[_i2].texture);
                            this._glyphs.push(c); }
                        c.position.x = (chars[_i2].position.x + lineAlignOffsets[chars[_i2].line]) * scale;
                        c.position.y = chars[_i2].position.y * scale;
                        c.scale.x = c.scale.y = scale;
                        c.tint = tint;
                        if (!c.parent) { this.addChild(c); }
                    }
                    for (var _i3 = lenChars; _i3 < this._glyphs.length; ++_i3) { this.removeChild(this._glyphs[_i3]); }
                    this._textWidth = maxLineWidth * scale;
                    this._textHeight = (pos.y + data.lineHeight) * scale;
                    if (this.anchor.x !== 0 || this.anchor.y !== 0) { for (var _i4 = 0; _i4 < lenChars; _i4++) { this._glyphs[_i4].x -= this._textWidth * this.anchor.x;
                            this._glyphs[_i4].y -= this._textHeight * this.anchor.y; } }
                    this.maxLineHeight = maxLineHeight * scale;
                };
                BitmapText.prototype.updateTransform = function updateTransform() { this.validate();
                    this.containerUpdateTransform(); };
                BitmapText.prototype.getLocalBounds = function getLocalBounds() { this.validate(); return _core$Container.prototype.getLocalBounds.call(this); };
                BitmapText.prototype.validate = function validate() { if (this.dirty) { this.updateText();
                        this.dirty = false; } };
                BitmapText.registerFont = function registerFont(xml, texture) {
                    var data = {};
                    var info = xml.getElementsByTagName('info')[0];
                    var common = xml.getElementsByTagName('common')[0];
                    data.font = info.getAttribute('face');
                    data.size = parseInt(info.getAttribute('size'), 10);
                    data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10);
                    data.chars = {};
                    var letters = xml.getElementsByTagName('char');
                    for (var i = 0; i < letters.length; i++) { var letter = letters[i]; var charCode = parseInt(letter.getAttribute('id'), 10); var textureRect = new core.Rectangle(parseInt(letter.getAttribute('x'), 10) + texture.frame.x, parseInt(letter.getAttribute('y'), 10) + texture.frame.y, parseInt(letter.getAttribute('width'), 10), parseInt(letter.getAttribute('height'), 10));
                        data.chars[charCode] = { xOffset: parseInt(letter.getAttribute('xoffset'), 10), yOffset: parseInt(letter.getAttribute('yoffset'), 10), xAdvance: parseInt(letter.getAttribute('xadvance'), 10), kerning: {}, texture: new core.Texture(texture.baseTexture, textureRect) }; }
                    var kernings = xml.getElementsByTagName('kerning');
                    for (var _i5 = 0; _i5 < kernings.length; _i5++) { var kerning = kernings[_i5]; var first = parseInt(kerning.getAttribute('first'), 10); var second = parseInt(kerning.getAttribute('second'), 10); var amount = parseInt(kerning.getAttribute('amount'), 10); if (data.chars[second]) { data.chars[second].kerning[first] = amount; } }
                    BitmapText.fonts[data.font] = data;
                    return data;
                };
                _createClass(BitmapText, [{
                    key: 'tint',
                    get: function get() { return this._font.tint; },
                    set: function set(value) { this._font.tint = typeof value === 'number' && value >= 0 ? value : 0xFFFFFF;
                        this.dirty = true; }
                }, {
                    key: 'align',
                    get: function get() { return this._font.align; },
                    set: function set(value) { this._font.align = value || 'left';
                        this.dirty = true; }
                }, {
                    key: 'anchor',
                    get: function get() { return this._anchor; },
                    set: function set(value) { if (typeof value === 'number') { this._anchor.set(value); } else { this._anchor.copy(value); } }
                }, {
                    key: 'font',
                    get: function get() { return this._font; },
                    set: function set(value) {
                        if (!value) { return; }
                        if (typeof value === 'string') { value = value.split(' ');
                            this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');
                            this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size; } else { this._font.name = value.name;
                            this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10); }
                        this.dirty = true;
                    }
                }, {
                    key: 'text',
                    get: function get() { return this._text; },
                    set: function set(value) {
                        value = value.toString() || ' ';
                        if (this._text === value) { return; }
                        this._text = value;
                        this.dirty = true;
                    }
                }, { key: 'textWidth', get: function get() { this.validate(); return this._textWidth; } }, { key: 'textHeight', get: function get() { this.validate(); return this._textHeight; } }]);
                return BitmapText;
            }(core.Container);
            exports.default = BitmapText;
            BitmapText.fonts = {};
        }, { "../core": 63, "../core/math/ObservablePoint": 66 }],
        133: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _Matrix = require('../core/math/Matrix');
            var _Matrix2 = _interopRequireDefault(_Matrix);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var tempMat = new _Matrix2.default();
            var TextureTransform = function() {
                function TextureTransform(texture, clampMargin) { _classCallCheck(this, TextureTransform);
                    this._texture = texture;
                    this.mapCoord = new _Matrix2.default();
                    this.uClampFrame = new Float32Array(4);
                    this.uClampOffset = new Float32Array(2);
                    this._lastTextureID = -1;
                    this.clampOffset = 0;
                    this.clampMargin = typeof clampMargin === 'undefined' ? 0.5 : clampMargin; }
                TextureTransform.prototype.multiplyUvs = function multiplyUvs(uvs, out) {
                    if (out === undefined) { out = uvs; }
                    var mat = this.mapCoord;
                    for (var i = 0; i < uvs.length; i += 2) { var x = uvs[i]; var y = uvs[i + 1];
                        out[i] = x * mat.a + y * mat.c + mat.tx;
                        out[i + 1] = x * mat.b + y * mat.d + mat.ty; }
                    return out;
                };
                TextureTransform.prototype.update = function update(forceUpdate) {
                    var tex = this._texture;
                    if (!tex || !tex.valid) { return false; }
                    if (!forceUpdate && this._lastTextureID === tex._updateID) { return false; }
                    this._lastTextureID = tex._updateID;
                    var uvs = tex._uvs;
                    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
                    var orig = tex.orig;
                    var trim = tex.trim;
                    if (trim) { tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
                        this.mapCoord.append(tempMat); }
                    var texBase = tex.baseTexture;
                    var frame = this.uClampFrame;
                    var margin = this.clampMargin / texBase.resolution;
                    var offset = this.clampOffset;
                    frame[0] = (tex._frame.x + margin + offset) / texBase.width;
                    frame[1] = (tex._frame.y + margin + offset) / texBase.height;
                    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
                    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
                    this.uClampOffset[0] = offset / texBase.realWidth;
                    this.uClampOffset[1] = offset / texBase.realHeight;
                    return true;
                };
                _createClass(TextureTransform, [{
                    key: 'texture',
                    get: function get() { return this._texture; },
                    set: function set(value) { this._texture = value;
                        this._lastTextureID = -1; }
                }]);
                return TextureTransform;
            }();
            exports.default = TextureTransform;
        }, { "../core/math/Matrix": 65 }],
        134: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _core = require('../core');
            var core = _interopRequireWildcard(_core);
            var _CanvasTinter = require('../core/sprites/canvas/CanvasTinter');
            var _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);
            var _TextureTransform = require('./TextureTransform');
            var _TextureTransform2 = _interopRequireDefault(_TextureTransform);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var tempPoint = new core.Point();
            var TilingSprite = function(_core$Sprite) {
                _inherits(TilingSprite, _core$Sprite);

                function TilingSprite(texture) { var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100; var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
                    _classCallCheck(this, TilingSprite); var _this = _possibleConstructorReturn(this, _core$Sprite.call(this, texture));
                    _this.tileTransform = new core.TransformStatic();
                    _this._width = width;
                    _this._height = height;
                    _this._canvasPattern = null;
                    _this.uvTransform = texture.transform || new _TextureTransform2.default(texture);
                    _this.pluginName = 'tilingSprite';
                    _this.uvRespectAnchor = false; return _this; }
                TilingSprite.prototype._onTextureUpdate = function _onTextureUpdate() { if (this.uvTransform) { this.uvTransform.texture = this._texture; } };
                TilingSprite.prototype._renderWebGL = function _renderWebGL(renderer) {
                    var texture = this._texture;
                    if (!texture || !texture.valid) { return; }
                    this.tileTransform.updateLocalTransform();
                    this.uvTransform.update();
                    renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
                    renderer.plugins[this.pluginName].render(this);
                };
                TilingSprite.prototype._renderCanvas = function _renderCanvas(renderer) {
                    var texture = this._texture;
                    if (!texture.baseTexture.hasLoaded) { return; }
                    var context = renderer.context;
                    var transform = this.worldTransform;
                    var resolution = renderer.resolution;
                    var baseTexture = texture.baseTexture;
                    var baseTextureResolution = baseTexture.resolution;
                    var modX = this.tilePosition.x / this.tileScale.x % texture._frame.width * baseTextureResolution;
                    var modY = this.tilePosition.y / this.tileScale.y % texture._frame.height * baseTextureResolution;
                    if (!this._canvasPattern) {
                        var tempCanvas = new core.CanvasRenderTarget(texture._frame.width, texture._frame.height, baseTextureResolution);
                        if (this.tint !== 0xFFFFFF) {
                            if (this.cachedTint !== this.tint) { this.cachedTint = this.tint;
                                this.tintedTexture = _CanvasTinter2.default.getTintedTexture(this, this.tint); }
                            tempCanvas.context.drawImage(this.tintedTexture, 0, 0);
                        } else { tempCanvas.context.drawImage(baseTexture.source, -texture._frame.x, -texture._frame.y); }
                        this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');
                    }
                    context.globalAlpha = this.worldAlpha;
                    context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);
                    renderer.setBlendMode(this.blendMode);
                    context.fillStyle = this._canvasPattern;
                    context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);
                    var anchorX = this.anchor.x * -this._width;
                    var anchorY = this.anchor.y * -this._height;
                    if (this.uvRespectAnchor) { context.translate(modX, modY);
                        context.fillRect(-modX + anchorX, -modY + anchorY, this._width / this.tileScale.x * baseTextureResolution, this._height / this.tileScale.y * baseTextureResolution); } else { context.translate(modX + anchorX, modY + anchorY);
                        context.fillRect(-modX, -modY, this._width / this.tileScale.x * baseTextureResolution, this._height / this.tileScale.y * baseTextureResolution); }
                };
                TilingSprite.prototype._calculateBounds = function _calculateBounds() { var minX = this._width * -this._anchor._x; var minY = this._height * -this._anchor._y; var maxX = this._width * (1 - this._anchor._x); var maxY = this._height * (1 - this._anchor._y);
                    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY); };
                TilingSprite.prototype.getLocalBounds = function getLocalBounds(rect) {
                    if (this.children.length === 0) {
                        this._bounds.minX = this._width * -this._anchor._x;
                        this._bounds.minY = this._height * -this._anchor._y;
                        this._bounds.maxX = this._width * (1 - this._anchor._x);
                        this._bounds.maxY = this._height * (1 - this._anchor._x);
                        if (!rect) {
                            if (!this._localBoundsRect) { this._localBoundsRect = new core.Rectangle(); }
                            rect = this._localBoundsRect;
                        }
                        return this._bounds.getRectangle(rect);
                    }
                    return _core$Sprite.prototype.getLocalBounds.call(this, rect);
                };
                TilingSprite.prototype.containsPoint = function containsPoint(point) {
                    this.worldTransform.applyInverse(point, tempPoint);
                    var width = this._width;
                    var height = this._height;
                    var x1 = -width * this.anchor._x;
                    if (tempPoint.x > x1 && tempPoint.x < x1 + width) { var y1 = -height * this.anchor._y; if (tempPoint.y > y1 && tempPoint.y < y1 + height) { return true; } }
                    return false;
                };
                TilingSprite.prototype.destroy = function destroy() { _core$Sprite.prototype.destroy.call(this);
                    this.tileTransform = null;
                    this.uvTransform = null; };
                TilingSprite.from = function from(source, width, height) { return new TilingSprite(core.Texture.from(source), width, height); };
                TilingSprite.fromFrame = function fromFrame(frameId, width, height) {
                    var texture = core.utils.TextureCache[frameId];
                    if (!texture) { throw new Error('The frameId "' + frameId + '" does not exist in the texture cache ' + this); }
                    return new TilingSprite(texture, width, height);
                };
                TilingSprite.fromImage = function fromImage(imageId, width, height, crossorigin, scaleMode) { return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height); };
                _createClass(TilingSprite, [{
                    key: 'clampMargin',
                    get: function get() { return this.uvTransform.clampMargin; },
                    set: function set(value) { this.uvTransform.clampMargin = value;
                        this.uvTransform.update(true); }
                }, {
                    key: 'tileScale',
                    get: function get() { return this.tileTransform.scale; },
                    set: function set(value) { this.tileTransform.scale.copy(value); }
                }, {
                    key: 'tilePosition',
                    get: function get() { return this.tileTransform.position; },
                    set: function set(value) { this.tileTransform.position.copy(value); }
                }, {
                    key: 'width',
                    get: function get() { return this._width; },
                    set: function set(value) { this._width = value; }
                }, {
                    key: 'height',
                    get: function get() { return this._height; },
                    set: function set(value) { this._height = value; }
                }]);
                return TilingSprite;
            }(core.Sprite);
            exports.default = TilingSprite;
        }, { "../core": 63, "../core/sprites/canvas/CanvasTinter": 102, "./TextureTransform": 133 }],
        135: [function(require, module, exports) {
            'use strict';
            var _core = require('../core');
            var core = _interopRequireWildcard(_core);
            var _Texture = require('../core/textures/Texture');
            var _Texture2 = _interopRequireDefault(_Texture);
            var _BaseTexture = require('../core/textures/BaseTexture');
            var _BaseTexture2 = _interopRequireDefault(_BaseTexture);
            var _utils = require('../core/utils');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var DisplayObject = core.DisplayObject;
            var _tempMatrix = new core.Matrix();
            DisplayObject.prototype._cacheAsBitmap = false;
            DisplayObject.prototype._cacheData = false;
            var CacheData = function CacheData() { _classCallCheck(this, CacheData);
                this.textureCacheId = null;
                this.originalRenderWebGL = null;
                this.originalRenderCanvas = null;
                this.originalCalculateBounds = null;
                this.originalGetLocalBounds = null;
                this.originalUpdateTransform = null;
                this.originalHitTest = null;
                this.originalDestroy = null;
                this.originalMask = null;
                this.originalFilterArea = null;
                this.sprite = null; };
            Object.defineProperties(DisplayObject.prototype, {
                cacheAsBitmap: {
                    get: function get() { return this._cacheAsBitmap; },
                    set: function set(value) {
                        if (this._cacheAsBitmap === value) { return; }
                        this._cacheAsBitmap = value;
                        var data = void 0;
                        if (value) {
                            if (!this._cacheData) { this._cacheData = new CacheData(); }
                            data = this._cacheData;
                            data.originalRenderWebGL = this.renderWebGL;
                            data.originalRenderCanvas = this.renderCanvas;
                            data.originalUpdateTransform = this.updateTransform;
                            data.originalCalculateBounds = this._calculateBounds;
                            data.originalGetLocalBounds = this.getLocalBounds;
                            data.originalDestroy = this.destroy;
                            data.originalContainsPoint = this.containsPoint;
                            data.originalMask = this._mask;
                            data.originalFilterArea = this.filterArea;
                            this.renderWebGL = this._renderCachedWebGL;
                            this.renderCanvas = this._renderCachedCanvas;
                            this.destroy = this._cacheAsBitmapDestroy;
                        } else {
                            data = this._cacheData;
                            if (data.sprite) { this._destroyCachedDisplayObject(); }
                            this.renderWebGL = data.originalRenderWebGL;
                            this.renderCanvas = data.originalRenderCanvas;
                            this._calculateBounds = data.originalCalculateBounds;
                            this.getLocalBounds = data.originalGetLocalBounds;
                            this.destroy = data.originalDestroy;
                            this.updateTransform = data.originalUpdateTransform;
                            this.containsPoint = data.originalContainsPoint;
                            this._mask = data.originalMask;
                            this.filterArea = data.originalFilterArea;
                        }
                    }
                }
            });
            DisplayObject.prototype._renderCachedWebGL = function _renderCachedWebGL(renderer) {
                if (!this.visible || this.worldAlpha <= 0 || !this.renderable) { return; }
                this._initCachedDisplayObject(renderer);
                this._cacheData.sprite._transformID = -1;
                this._cacheData.sprite.worldAlpha = this.worldAlpha;
                this._cacheData.sprite._renderWebGL(renderer);
            };
            DisplayObject.prototype._initCachedDisplayObject = function _initCachedDisplayObject(renderer) {
                if (this._cacheData && this._cacheData.sprite) { return; }
                var cacheAlpha = this.alpha;
                this.alpha = 1;
                renderer.currentRenderer.flush();
                var bounds = this.getLocalBounds().clone();
                if (this._filters) { var padding = this._filters[0].padding;
                    bounds.pad(padding); }
                var cachedRenderTarget = renderer._activeRenderTarget;
                var stack = renderer.filterManager.filterStack;
                var renderTexture = core.RenderTexture.create(bounds.width | 0, bounds.height | 0);
                var textureCacheId = 'cacheAsBitmap_' + (0, _utils.uid)();
                this._cacheData.textureCacheId = textureCacheId;
                _BaseTexture2.default.addToCache(renderTexture.baseTexture, textureCacheId);
                _Texture2.default.addToCache(renderTexture, textureCacheId);
                var m = _tempMatrix;
                m.tx = -bounds.x;
                m.ty = -bounds.y;
                this.transform.worldTransform.identity();
                this.renderWebGL = this._cacheData.originalRenderWebGL;
                renderer.render(this, renderTexture, true, m, true);
                renderer.bindRenderTarget(cachedRenderTarget);
                renderer.filterManager.filterStack = stack;
                this.renderWebGL = this._renderCachedWebGL;
                this.updateTransform = this.displayObjectUpdateTransform;
                this._mask = null;
                this.filterArea = null;
                var cachedSprite = new core.Sprite(renderTexture);
                cachedSprite.transform.worldTransform = this.transform.worldTransform;
                cachedSprite.anchor.x = -(bounds.x / bounds.width);
                cachedSprite.anchor.y = -(bounds.y / bounds.height);
                cachedSprite.alpha = cacheAlpha;
                cachedSprite._bounds = this._bounds;
                this._calculateBounds = this._calculateCachedBounds;
                this.getLocalBounds = this._getCachedLocalBounds;
                this._cacheData.sprite = cachedSprite;
                this.transform._parentID = -1;
                if (!this.parent) { this.parent = renderer._tempDisplayObjectParent;
                    this.updateTransform();
                    this.parent = null; } else { this.updateTransform(); }
                this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
            };
            DisplayObject.prototype._renderCachedCanvas = function _renderCachedCanvas(renderer) {
                if (!this.visible || this.worldAlpha <= 0 || !this.renderable) { return; }
                this._initCachedDisplayObjectCanvas(renderer);
                this._cacheData.sprite.worldAlpha = this.worldAlpha;
                this._cacheData.sprite.renderCanvas(renderer);
            };
            DisplayObject.prototype._initCachedDisplayObjectCanvas = function _initCachedDisplayObjectCanvas(renderer) {
                if (this._cacheData && this._cacheData.sprite) { return; }
                var bounds = this.getLocalBounds();
                var cacheAlpha = this.alpha;
                this.alpha = 1;
                var cachedRenderTarget = renderer.context;
                var renderTexture = core.RenderTexture.create(bounds.width | 0, bounds.height | 0);
                var textureCacheId = 'cacheAsBitmap_' + (0, _utils.uid)();
                this._cacheData.textureCacheId = textureCacheId;
                _BaseTexture2.default.addToCache(renderTexture.baseTexture, textureCacheId);
                _Texture2.default.addToCache(renderTexture, textureCacheId);
                var m = _tempMatrix;
                this.transform.localTransform.copy(m);
                m.invert();
                m.tx -= bounds.x;
                m.ty -= bounds.y;
                this.renderCanvas = this._cacheData.originalRenderCanvas;
                renderer.render(this, renderTexture, true, m, false);
                renderer.context = cachedRenderTarget;
                this.renderCanvas = this._renderCachedCanvas;
                this._calculateBounds = this._calculateCachedBounds;
                this._mask = null;
                this.filterArea = null;
                var cachedSprite = new core.Sprite(renderTexture);
                cachedSprite.transform.worldTransform = this.transform.worldTransform;
                cachedSprite.anchor.x = -(bounds.x / bounds.width);
                cachedSprite.anchor.y = -(bounds.y / bounds.height);
                cachedSprite._bounds = this._bounds;
                cachedSprite.alpha = cacheAlpha;
                if (!this.parent) { this.parent = renderer._tempDisplayObjectParent;
                    this.updateTransform();
                    this.parent = null; } else { this.updateTransform(); }
                this.updateTransform = this.displayObjectUpdateTransform;
                this._cacheData.sprite = cachedSprite;
                this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
            };
            DisplayObject.prototype._calculateCachedBounds = function _calculateCachedBounds() { this._cacheData.sprite._calculateBounds(); };
            DisplayObject.prototype._getCachedLocalBounds = function _getCachedLocalBounds() { return this._cacheData.sprite.getLocalBounds(); };
            DisplayObject.prototype._destroyCachedDisplayObject = function _destroyCachedDisplayObject() { this._cacheData.sprite._texture.destroy(true);
                this._cacheData.sprite = null;
                _BaseTexture2.default.removeFromCache(this._cacheData.textureCacheId);
                _Texture2.default.removeFromCache(this._cacheData.textureCacheId);
                this._cacheData.textureCacheId = null; };
            DisplayObject.prototype._cacheAsBitmapDestroy = function _cacheAsBitmapDestroy(options) { this.cacheAsBitmap = false;
                this.destroy(options); };
        }, { "../core": 63, "../core/textures/BaseTexture": 110, "../core/textures/Texture": 113, "../core/utils": 122 }],
        136: [function(require, module, exports) {
            'use strict';
            var _core = require('../core');
            var core = _interopRequireWildcard(_core);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
            core.DisplayObject.prototype.name = null;
            core.Container.prototype.getChildByName = function getChildByName(name) {
                for (var i = 0; i < this.children.length; i++) { if (this.children[i].name === name) { return this.children[i]; } }
                return null;
            };
        }, { "../core": 63 }],
        137: [function(require, module, exports) {
            'use strict';
            var _core = require('../core');
            var core = _interopRequireWildcard(_core);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
            core.DisplayObject.prototype.getGlobalPosition = function getGlobalPosition() {
                var point = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new core.Point();
                var skipUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                if (this.parent) { this.parent.toGlobal(this.position, point, skipUpdate); } else { point.x = this.position.x;
                    point.y = this.position.y; }
                return point;
            };
        }, { "../core": 63 }],
        138: [function(require, module, exports) { 'use strict';
            exports.__esModule = true;
            exports.BitmapText = exports.TilingSpriteRenderer = exports.TilingSprite = exports.AnimatedSprite = undefined; var _AnimatedSprite = require('./AnimatedSprite');
            Object.defineProperty(exports, 'AnimatedSprite', { enumerable: true, get: function get() { return _interopRequireDefault(_AnimatedSprite).default; } }); var _TilingSprite = require('./TilingSprite');
            Object.defineProperty(exports, 'TilingSprite', { enumerable: true, get: function get() { return _interopRequireDefault(_TilingSprite).default; } }); var _TilingSpriteRenderer = require('./webgl/TilingSpriteRenderer');
            Object.defineProperty(exports, 'TilingSpriteRenderer', { enumerable: true, get: function get() { return _interopRequireDefault(_TilingSpriteRenderer).default; } }); var _BitmapText = require('./BitmapText');
            Object.defineProperty(exports, 'BitmapText', { enumerable: true, get: function get() { return _interopRequireDefault(_BitmapText).default; } });
            require('./cacheAsBitmap');
            require('./getChildByName');
            require('./getGlobalPosition');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } }, { "./AnimatedSprite": 131, "./BitmapText": 132, "./TilingSprite": 134, "./cacheAsBitmap": 135, "./getChildByName": 136, "./getGlobalPosition": 137, "./webgl/TilingSpriteRenderer": 139 }],
        139: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _const = require('../../core/const');
            var _path = require('path');

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var tempMat = new core.Matrix();
            var tempArray = new Float32Array(4);
            var TilingSpriteRenderer = function(_core$ObjectRenderer) {
                _inherits(TilingSpriteRenderer, _core$ObjectRenderer);

                function TilingSpriteRenderer(renderer) { _classCallCheck(this, TilingSpriteRenderer); var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));
                    _this.shader = null;
                    _this.simpleShader = null;
                    _this.quad = null; return _this; }
                TilingSpriteRenderer.prototype.onContextChange = function onContextChange() { var gl = this.renderer.gl;
                    this.shader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n', 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\nuniform mat3 uMapCoord;\nuniform vec4 uClampFrame;\nuniform vec2 uClampOffset;\n\nvoid main(void)\n{\n    vec2 coord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\n\n    vec4 sample = texture2D(uSampler, coord);\n    vec4 color = vec4(uColor.rgb * uColor.a, uColor.a);\n\n    gl_FragColor = sample * color ;\n}\n');
                    this.simpleShader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n', 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\nuniform vec4 uColor;\n\nvoid main(void)\n{\n    vec4 sample = texture2D(uSampler, vTextureCoord);\n    vec4 color = vec4(uColor.rgb * uColor.a, uColor.a);\n    gl_FragColor = sample * color;\n}\n');
                    this.renderer.bindVao(null);
                    this.quad = new core.Quad(gl, this.renderer.state.attribState);
                    this.quad.initVao(this.shader); };
                TilingSpriteRenderer.prototype.render = function render(ts) {
                    var renderer = this.renderer;
                    var quad = this.quad;
                    renderer.bindVao(quad.vao);
                    var vertices = quad.vertices;
                    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;
                    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
                    vertices[2] = vertices[4] = ts._width * (1.0 - ts.anchor.x);
                    vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);
                    if (ts.uvRespectAnchor) { vertices = quad.uvs;
                        vertices[0] = vertices[6] = -ts.anchor.x;
                        vertices[1] = vertices[3] = -ts.anchor.y;
                        vertices[2] = vertices[4] = 1.0 - ts.anchor.x;
                        vertices[5] = vertices[7] = 1.0 - ts.anchor.y; }
                    quad.upload();
                    var tex = ts._texture;
                    var baseTex = tex.baseTexture;
                    var lt = ts.tileTransform.localTransform;
                    var uv = ts.uvTransform;
                    var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
                    if (isSimple) { if (!baseTex._glTextures[renderer.CONTEXT_UID]) { if (baseTex.wrapMode === _const.WRAP_MODES.CLAMP) { baseTex.wrapMode = _const.WRAP_MODES.REPEAT; } } else { isSimple = baseTex.wrapMode !== _const.WRAP_MODES.CLAMP; } }
                    var shader = isSimple ? this.simpleShader : this.shader;
                    renderer.bindShader(shader);
                    var w = tex.width;
                    var h = tex.height;
                    var W = ts._width;
                    var H = ts._height;
                    tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
                    tempMat.invert();
                    if (isSimple) { tempMat.prepend(uv.mapCoord); } else { shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
                        shader.uniforms.uClampFrame = uv.uClampFrame;
                        shader.uniforms.uClampOffset = uv.uClampOffset; }
                    shader.uniforms.uTransform = tempMat.toArray(true);
                    var color = tempArray;
                    core.utils.hex2rgb(ts.tint, color);
                    color[3] = ts.worldAlpha;
                    shader.uniforms.uColor = color;
                    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
                    shader.uniforms.uSampler = renderer.bindTexture(tex);
                    renderer.setBlendMode(ts.blendMode);
                    quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);
                };
                return TilingSpriteRenderer;
            }(core.ObjectRenderer);
            exports.default = TilingSpriteRenderer;
            core.WebGLRenderer.registerPlugin('tilingSprite', TilingSpriteRenderer);
        }, { "../../core": 63, "../../core/const": 44, "path": 22 }],
        140: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _BlurXFilter = require('./BlurXFilter');
            var _BlurXFilter2 = _interopRequireDefault(_BlurXFilter);
            var _BlurYFilter = require('./BlurYFilter');
            var _BlurYFilter2 = _interopRequireDefault(_BlurYFilter);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var BlurFilter = function(_core$Filter) {
                _inherits(BlurFilter, _core$Filter);

                function BlurFilter(strength, quality, resolution, kernelSize) { _classCallCheck(this, BlurFilter); var _this = _possibleConstructorReturn(this, _core$Filter.call(this));
                    _this.blurXFilter = new _BlurXFilter2.default(strength, quality, resolution, kernelSize);
                    _this.blurYFilter = new _BlurYFilter2.default(strength, quality, resolution, kernelSize);
                    _this.padding = 0;
                    _this.resolution = resolution || core.settings.RESOLUTION;
                    _this.quality = quality || 4;
                    _this.blur = strength || 8; return _this; }
                BlurFilter.prototype.apply = function apply(filterManager, input, output) { var renderTarget = filterManager.getRenderTarget(true);
                    this.blurXFilter.apply(filterManager, input, renderTarget, true);
                    this.blurYFilter.apply(filterManager, renderTarget, output, false);
                    filterManager.returnRenderTarget(renderTarget); };
                _createClass(BlurFilter, [{
                    key: 'blur',
                    get: function get() { return this.blurXFilter.blur; },
                    set: function set(value) { this.blurXFilter.blur = this.blurYFilter.blur = value;
                        this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2; }
                }, {
                    key: 'quality',
                    get: function get() { return this.blurXFilter.quality; },
                    set: function set(value) { this.blurXFilter.quality = this.blurYFilter.quality = value; }
                }, {
                    key: 'blurX',
                    get: function get() { return this.blurXFilter.blur; },
                    set: function set(value) { this.blurXFilter.blur = value;
                        this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2; }
                }, {
                    key: 'blurY',
                    get: function get() { return this.blurYFilter.blur; },
                    set: function set(value) { this.blurYFilter.blur = value;
                        this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2; }
                }]);
                return BlurFilter;
            }(core.Filter);
            exports.default = BlurFilter;
        }, { "../../core": 63, "./BlurXFilter": 141, "./BlurYFilter": 142 }],
        141: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _generateBlurVertSource = require('./generateBlurVertSource');
            var _generateBlurVertSource2 = _interopRequireDefault(_generateBlurVertSource);
            var _generateBlurFragSource = require('./generateBlurFragSource');
            var _generateBlurFragSource2 = _interopRequireDefault(_generateBlurFragSource);
            var _getMaxBlurKernelSize = require('./getMaxBlurKernelSize');
            var _getMaxBlurKernelSize2 = _interopRequireDefault(_getMaxBlurKernelSize);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var BlurXFilter = function(_core$Filter) {
                _inherits(BlurXFilter, _core$Filter);

                function BlurXFilter(strength, quality, resolution, kernelSize) { _classCallCheck(this, BlurXFilter);
                    kernelSize = kernelSize || 5; var vertSrc = (0, _generateBlurVertSource2.default)(kernelSize, true); var fragSrc = (0, _generateBlurFragSource2.default)(kernelSize); var _this = _possibleConstructorReturn(this, _core$Filter.call(this, vertSrc, fragSrc));
                    _this.resolution = resolution || core.settings.RESOLUTION;
                    _this._quality = 0;
                    _this.quality = quality || 4;
                    _this.strength = strength || 8;
                    _this.firstRun = true; return _this; }
                BlurXFilter.prototype.apply = function apply(filterManager, input, output, clear) {
                    if (this.firstRun) { var gl = filterManager.renderer.gl; var kernelSize = (0, _getMaxBlurKernelSize2.default)(gl);
                        this.vertexSrc = (0, _generateBlurVertSource2.default)(kernelSize, true);
                        this.fragmentSrc = (0, _generateBlurFragSource2.default)(kernelSize);
                        this.firstRun = false; }
                    this.uniforms.strength = 1 / output.size.width * (output.size.width / input.size.width);
                    this.uniforms.strength *= this.strength;
                    this.uniforms.strength /= this.passes;
                    if (this.passes === 1) { filterManager.applyFilter(this, input, output, clear); } else {
                        var renderTarget = filterManager.getRenderTarget(true);
                        var flip = input;
                        var flop = renderTarget;
                        for (var i = 0; i < this.passes - 1; i++) { filterManager.applyFilter(this, flip, flop, true); var temp = flop;
                            flop = flip;
                            flip = temp; }
                        filterManager.applyFilter(this, flip, output, clear);
                        filterManager.returnRenderTarget(renderTarget);
                    }
                };
                _createClass(BlurXFilter, [{
                    key: 'blur',
                    get: function get() { return this.strength; },
                    set: function set(value) { this.padding = Math.abs(value) * 2;
                        this.strength = value; }
                }, {
                    key: 'quality',
                    get: function get() { return this._quality; },
                    set: function set(value) { this._quality = value;
                        this.passes = value; }
                }]);
                return BlurXFilter;
            }(core.Filter);
            exports.default = BlurXFilter;
        }, { "../../core": 63, "./generateBlurFragSource": 143, "./generateBlurVertSource": 144, "./getMaxBlurKernelSize": 145 }],
        142: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _generateBlurVertSource = require('./generateBlurVertSource');
            var _generateBlurVertSource2 = _interopRequireDefault(_generateBlurVertSource);
            var _generateBlurFragSource = require('./generateBlurFragSource');
            var _generateBlurFragSource2 = _interopRequireDefault(_generateBlurFragSource);
            var _getMaxBlurKernelSize = require('./getMaxBlurKernelSize');
            var _getMaxBlurKernelSize2 = _interopRequireDefault(_getMaxBlurKernelSize);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var BlurYFilter = function(_core$Filter) {
                _inherits(BlurYFilter, _core$Filter);

                function BlurYFilter(strength, quality, resolution, kernelSize) { _classCallCheck(this, BlurYFilter);
                    kernelSize = kernelSize || 5; var vertSrc = (0, _generateBlurVertSource2.default)(kernelSize, false); var fragSrc = (0, _generateBlurFragSource2.default)(kernelSize); var _this = _possibleConstructorReturn(this, _core$Filter.call(this, vertSrc, fragSrc));
                    _this.resolution = resolution || core.settings.RESOLUTION;
                    _this._quality = 0;
                    _this.quality = quality || 4;
                    _this.strength = strength || 8;
                    _this.firstRun = true; return _this; }
                BlurYFilter.prototype.apply = function apply(filterManager, input, output, clear) {
                    if (this.firstRun) { var gl = filterManager.renderer.gl; var kernelSize = (0, _getMaxBlurKernelSize2.default)(gl);
                        this.vertexSrc = (0, _generateBlurVertSource2.default)(kernelSize, false);
                        this.fragmentSrc = (0, _generateBlurFragSource2.default)(kernelSize);
                        this.firstRun = false; }
                    this.uniforms.strength = 1 / output.size.height * (output.size.height / input.size.height);
                    this.uniforms.strength *= this.strength;
                    this.uniforms.strength /= this.passes;
                    if (this.passes === 1) { filterManager.applyFilter(this, input, output, clear); } else {
                        var renderTarget = filterManager.getRenderTarget(true);
                        var flip = input;
                        var flop = renderTarget;
                        for (var i = 0; i < this.passes - 1; i++) { filterManager.applyFilter(this, flip, flop, true); var temp = flop;
                            flop = flip;
                            flip = temp; }
                        filterManager.applyFilter(this, flip, output, clear);
                        filterManager.returnRenderTarget(renderTarget);
                    }
                };
                _createClass(BlurYFilter, [{
                    key: 'blur',
                    get: function get() { return this.strength; },
                    set: function set(value) { this.padding = Math.abs(value) * 2;
                        this.strength = value; }
                }, {
                    key: 'quality',
                    get: function get() { return this._quality; },
                    set: function set(value) { this._quality = value;
                        this.passes = value; }
                }]);
                return BlurYFilter;
            }(core.Filter);
            exports.default = BlurYFilter;
        }, { "../../core": 63, "./generateBlurFragSource": 143, "./generateBlurVertSource": 144, "./getMaxBlurKernelSize": 145 }],
        143: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = generateFragBlurSource;
            var GAUSSIAN_VALUES = { 5: [0.153388, 0.221461, 0.250301], 7: [0.071303, 0.131514, 0.189879, 0.214607], 9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236], 11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596], 13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641], 15: [0.000489, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448] };
            var fragTemplate = ['varying vec2 vBlurTexCoords[%size%];', 'uniform sampler2D uSampler;', 'void main(void)', '{', '    gl_FragColor = vec4(0.0);', '    %blur%', '}'].join('\n');

            function generateFragBlurSource(kernelSize) {
                var kernel = GAUSSIAN_VALUES[kernelSize];
                var halfLength = kernel.length;
                var fragSource = fragTemplate;
                var blurLoop = '';
                var template = 'gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;';
                var value = void 0;
                for (var i = 0; i < kernelSize; i++) {
                    var blur = template.replace('%index%', i);
                    value = i;
                    if (i >= halfLength) { value = kernelSize - i - 1; }
                    blur = blur.replace('%value%', kernel[value]);
                    blurLoop += blur;
                    blurLoop += '\n';
                }
                fragSource = fragSource.replace('%blur%', blurLoop);
                fragSource = fragSource.replace('%size%', kernelSize);
                return fragSource;
            }
        }, {}],
        144: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = generateVertBlurSource;
            var vertTemplate = ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'uniform float strength;', 'uniform mat3 projectionMatrix;', 'varying vec2 vBlurTexCoords[%size%];', 'void main(void)', '{', 'gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);', '%blur%', '}'].join('\n');

            function generateVertBlurSource(kernelSize, x) {
                var halfLength = Math.ceil(kernelSize / 2);
                var vertSource = vertTemplate;
                var blurLoop = '';
                var template = void 0;
                if (x) { template = 'vBlurTexCoords[%index%] = aTextureCoord + vec2(%sampleIndex% * strength, 0.0);'; } else { template = 'vBlurTexCoords[%index%] = aTextureCoord + vec2(0.0, %sampleIndex% * strength);'; }
                for (var i = 0; i < kernelSize; i++) { var blur = template.replace('%index%', i);
                    blur = blur.replace('%sampleIndex%', i - (halfLength - 1) + '.0');
                    blurLoop += blur;
                    blurLoop += '\n'; }
                vertSource = vertSource.replace('%blur%', blurLoop);
                vertSource = vertSource.replace('%size%', kernelSize);
                return vertSource;
            }
        }, {}],
        145: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;
            exports.default = getMaxKernelSize;

            function getMaxKernelSize(gl) {
                var maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
                var kernelSize = 15;
                while (kernelSize > maxVaryings) { kernelSize -= 2; }
                return kernelSize;
            }
        }, {}],
        146: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _path = require('path');

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var ColorMatrixFilter = function(_core$Filter) {
                _inherits(ColorMatrixFilter, _core$Filter);

                function ColorMatrixFilter() { _classCallCheck(this, ColorMatrixFilter); var _this = _possibleConstructorReturn(this, _core$Filter.call(this, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}', 'varying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform float m[20];\nuniform float uAlpha;\n\nvoid main(void)\n{\n    vec4 c = texture2D(uSampler, vTextureCoord);\n\n    if (uAlpha == 0.0) {\n        gl_FragColor = c;\n        return;\n    }\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (c.a > 0.0) {\n      c.rgb /= c.a;\n    }\n\n    vec4 result;\n\n    result.r = (m[0] * c.r);\n        result.r += (m[1] * c.g);\n        result.r += (m[2] * c.b);\n        result.r += (m[3] * c.a);\n        result.r += m[4];\n\n    result.g = (m[5] * c.r);\n        result.g += (m[6] * c.g);\n        result.g += (m[7] * c.b);\n        result.g += (m[8] * c.a);\n        result.g += m[9];\n\n    result.b = (m[10] * c.r);\n       result.b += (m[11] * c.g);\n       result.b += (m[12] * c.b);\n       result.b += (m[13] * c.a);\n       result.b += m[14];\n\n    result.a = (m[15] * c.r);\n       result.a += (m[16] * c.g);\n       result.a += (m[17] * c.b);\n       result.a += (m[18] * c.a);\n       result.a += m[19];\n\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\n\n    // Premultiply alpha again.\n    rgb *= result.a;\n\n    gl_FragColor = vec4(rgb, result.a);\n}\n'));
                    _this.uniforms.m = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
                    _this.alpha = 1; return _this; }
                ColorMatrixFilter.prototype._loadMatrix = function _loadMatrix(matrix) {
                    var multiply = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                    var newMatrix = matrix;
                    if (multiply) { this._multiply(newMatrix, this.uniforms.m, matrix);
                        newMatrix = this._colorMatrix(newMatrix); }
                    this.uniforms.m = newMatrix;
                };
                ColorMatrixFilter.prototype._multiply = function _multiply(out, a, b) { out[0] = a[0] * b[0] + a[1] * b[5] + a[2] * b[10] + a[3] * b[15];
                    out[1] = a[0] * b[1] + a[1] * b[6] + a[2] * b[11] + a[3] * b[16];
                    out[2] = a[0] * b[2] + a[1] * b[7] + a[2] * b[12] + a[3] * b[17];
                    out[3] = a[0] * b[3] + a[1] * b[8] + a[2] * b[13] + a[3] * b[18];
                    out[4] = a[0] * b[4] + a[1] * b[9] + a[2] * b[14] + a[3] * b[19] + a[4];
                    out[5] = a[5] * b[0] + a[6] * b[5] + a[7] * b[10] + a[8] * b[15];
                    out[6] = a[5] * b[1] + a[6] * b[6] + a[7] * b[11] + a[8] * b[16];
                    out[7] = a[5] * b[2] + a[6] * b[7] + a[7] * b[12] + a[8] * b[17];
                    out[8] = a[5] * b[3] + a[6] * b[8] + a[7] * b[13] + a[8] * b[18];
                    out[9] = a[5] * b[4] + a[6] * b[9] + a[7] * b[14] + a[8] * b[19] + a[9];
                    out[10] = a[10] * b[0] + a[11] * b[5] + a[12] * b[10] + a[13] * b[15];
                    out[11] = a[10] * b[1] + a[11] * b[6] + a[12] * b[11] + a[13] * b[16];
                    out[12] = a[10] * b[2] + a[11] * b[7] + a[12] * b[12] + a[13] * b[17];
                    out[13] = a[10] * b[3] + a[11] * b[8] + a[12] * b[13] + a[13] * b[18];
                    out[14] = a[10] * b[4] + a[11] * b[9] + a[12] * b[14] + a[13] * b[19] + a[14];
                    out[15] = a[15] * b[0] + a[16] * b[5] + a[17] * b[10] + a[18] * b[15];
                    out[16] = a[15] * b[1] + a[16] * b[6] + a[17] * b[11] + a[18] * b[16];
                    out[17] = a[15] * b[2] + a[16] * b[7] + a[17] * b[12] + a[18] * b[17];
                    out[18] = a[15] * b[3] + a[16] * b[8] + a[17] * b[13] + a[18] * b[18];
                    out[19] = a[15] * b[4] + a[16] * b[9] + a[17] * b[14] + a[18] * b[19] + a[19]; return out; };
                ColorMatrixFilter.prototype._colorMatrix = function _colorMatrix(matrix) { var m = new Float32Array(matrix);
                    m[4] /= 255;
                    m[9] /= 255;
                    m[14] /= 255;
                    m[19] /= 255; return m; };
                ColorMatrixFilter.prototype.brightness = function brightness(b, multiply) { var matrix = [b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.greyscale = function greyscale(scale, multiply) { var matrix = [scale, scale, scale, 0, 0, scale, scale, scale, 0, 0, scale, scale, scale, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.blackAndWhite = function blackAndWhite(multiply) { var matrix = [0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.hue = function hue(rotation, multiply) { rotation = (rotation || 0) / 180 * Math.PI; var cosR = Math.cos(rotation); var sinR = Math.sin(rotation); var sqrt = Math.sqrt; var w = 1 / 3; var sqrW = sqrt(w); var a00 = cosR + (1.0 - cosR) * w; var a01 = w * (1.0 - cosR) - sqrW * sinR; var a02 = w * (1.0 - cosR) + sqrW * sinR; var a10 = w * (1.0 - cosR) + sqrW * sinR; var a11 = cosR + w * (1.0 - cosR); var a12 = w * (1.0 - cosR) - sqrW * sinR; var a20 = w * (1.0 - cosR) - sqrW * sinR; var a21 = w * (1.0 - cosR) + sqrW * sinR; var a22 = cosR + w * (1.0 - cosR); var matrix = [a00, a01, a02, 0, 0, a10, a11, a12, 0, 0, a20, a21, a22, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.contrast = function contrast(amount, multiply) { var v = (amount || 0) + 1; var o = -128 * (v - 1); var matrix = [v, 0, 0, 0, o, 0, v, 0, 0, o, 0, 0, v, 0, o, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.saturate = function saturate() { var amount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0; var multiply = arguments[1]; var x = amount * 2 / 3 + 1; var y = (x - 1) * -0.5; var matrix = [x, y, y, 0, 0, y, x, y, 0, 0, y, y, x, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.desaturate = function desaturate() { this.saturate(-1); };
                ColorMatrixFilter.prototype.negative = function negative(multiply) { var matrix = [0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.sepia = function sepia(multiply) { var matrix = [0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.technicolor = function technicolor(multiply) { var matrix = [1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.polaroid = function polaroid(multiply) { var matrix = [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.toBGR = function toBGR(multiply) { var matrix = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.kodachrome = function kodachrome(multiply) { var matrix = [1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.browni = function browni(multiply) { var matrix = [0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.vintage = function vintage(multiply) { var matrix = [0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.colorTone = function colorTone(desaturation, toned, lightColor, darkColor, multiply) { desaturation = desaturation || 0.2;
                    toned = toned || 0.15;
                    lightColor = lightColor || 0xFFE580;
                    darkColor = darkColor || 0x338000; var lR = (lightColor >> 16 & 0xFF) / 255; var lG = (lightColor >> 8 & 0xFF) / 255; var lB = (lightColor & 0xFF) / 255; var dR = (darkColor >> 16 & 0xFF) / 255; var dG = (darkColor >> 8 & 0xFF) / 255; var dB = (darkColor & 0xFF) / 255; var matrix = [0.3, 0.59, 0.11, 0, 0, lR, lG, lB, desaturation, 0, dR, dG, dB, toned, 0, lR - dR, lG - dG, lB - dB, 0, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.night = function night(intensity, multiply) { intensity = intensity || 0.1; var matrix = [intensity * -2.0, -intensity, 0, 0, 0, -intensity, 0, intensity, 0, 0, 0, intensity, intensity * 2.0, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.predator = function predator(amount, multiply) { var matrix = [11.224130630493164 * amount, -4.794486999511719 * amount, -2.8746118545532227 * amount, 0 * amount, 0.40342438220977783 * amount, -3.6330697536468506 * amount, 9.193157196044922 * amount, -2.951810836791992 * amount, 0 * amount, -1.316135048866272 * amount, -3.2184197902679443 * amount, -4.2375030517578125 * amount, 7.476448059082031 * amount, 0 * amount, 0.8044459223747253 * amount, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.lsd = function lsd(multiply) { var matrix = [2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, multiply); };
                ColorMatrixFilter.prototype.reset = function reset() { var matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
                    this._loadMatrix(matrix, false); };
                _createClass(ColorMatrixFilter, [{
                    key: 'matrix',
                    get: function get() { return this.uniforms.m; },
                    set: function set(value) { this.uniforms.m = value; }
                }, {
                    key: 'alpha',
                    get: function get() { return this.uniforms.uAlpha; },
                    set: function set(value) { this.uniforms.uAlpha = value; }
                }]);
                return ColorMatrixFilter;
            }(core.Filter);
            exports.default = ColorMatrixFilter;
            ColorMatrixFilter.prototype.grayscale = ColorMatrixFilter.prototype.greyscale;
        }, { "../../core": 63, "path": 22 }],
        147: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _path = require('path');

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var DisplacementFilter = function(_core$Filter) {
                _inherits(DisplacementFilter, _core$Filter);

                function DisplacementFilter(sprite, scale) {
                    _classCallCheck(this, DisplacementFilter);
                    var maskMatrix = new core.Matrix();
                    sprite.renderable = false;
                    var _this = _possibleConstructorReturn(this, _core$Filter.call(this, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 filterMatrix;\n\nvarying vec2 vTextureCoord;\nvarying vec2 vFilterCoord;\n\nvoid main(void)\n{\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;\n   vTextureCoord = aTextureCoord;\n}', 'varying vec2 vFilterCoord;\nvarying vec2 vTextureCoord;\n\nuniform vec2 scale;\n\nuniform sampler2D uSampler;\nuniform sampler2D mapSampler;\n\nuniform vec4 filterClamp;\n\nvoid main(void)\n{\n   vec4 map =  texture2D(mapSampler, vFilterCoord);\n\n   map -= 0.5;\n   map.xy *= scale;\n\n   gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), filterClamp.xy, filterClamp.zw));\n}\n'));
                    _this.maskSprite = sprite;
                    _this.maskMatrix = maskMatrix;
                    _this.uniforms.mapSampler = sprite._texture;
                    _this.uniforms.filterMatrix = maskMatrix;
                    _this.uniforms.scale = { x: 1, y: 1 };
                    if (scale === null || scale === undefined) { scale = 20; }
                    _this.scale = new core.Point(scale, scale);
                    return _this;
                }
                DisplacementFilter.prototype.apply = function apply(filterManager, input, output) { var ratio = 1 / output.destinationFrame.width * (output.size.width / input.size.width);
                    this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
                    this.uniforms.scale.x = this.scale.x * ratio;
                    this.uniforms.scale.y = this.scale.y * ratio;
                    filterManager.applyFilter(this, input, output); };
                _createClass(DisplacementFilter, [{
                    key: 'map',
                    get: function get() { return this.uniforms.mapSampler; },
                    set: function set(value) { this.uniforms.mapSampler = value; }
                }]);
                return DisplacementFilter;
            }(core.Filter);
            exports.default = DisplacementFilter;
        }, { "../../core": 63, "path": 22 }],
        148: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _path = require('path');

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var FXAAFilter = function(_core$Filter) {
                _inherits(FXAAFilter, _core$Filter);

                function FXAAFilter() { _classCallCheck(this, FXAAFilter); return _possibleConstructorReturn(this, _core$Filter.call(this, '\nattribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nuniform vec4 filterArea;\n\nvarying vec2 vTextureCoord;\n\nvec2 mapCoord( vec2 coord )\n{\n    coord *= filterArea.xy;\n    coord += filterArea.zw;\n\n    return coord;\n}\n\nvec2 unmapCoord( vec2 coord )\n{\n    coord -= filterArea.zw;\n    coord /= filterArea.xy;\n\n    return coord;\n}\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n               out vec2 v_rgbNW, out vec2 v_rgbNE,\n               out vec2 v_rgbSW, out vec2 v_rgbSE,\n               out vec2 v_rgbM) {\n    vec2 inverseVP = 1.0 / resolution.xy;\n    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n    v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n   vTextureCoord = aTextureCoord;\n\n   vec2 fragCoord = vTextureCoord * filterArea.xy;\n\n   texcoords(fragCoord, filterArea.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n}', 'varying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvarying vec2 vTextureCoord;\nuniform sampler2D uSampler;\nuniform vec4 filterArea;\n\n/**\n Basic FXAA implementation based on the code on geeks3d.com with the\n modification that the texture2DLod stuff was removed since it\'s\n unsupported by WebGL.\n \n --\n \n From:\n https://github.com/mitsuhiko/webgl-meincraft\n \n Copyright (c) 2011 by Armin Ronacher.\n \n Some rights reserved.\n \n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are\n met:\n \n * Redistributions of source code must retain the above copyright\n notice, this list of conditions and the following disclaimer.\n \n * Redistributions in binary form must reproduce the above\n copyright notice, this list of conditions and the following\n disclaimer in the documentation and/or other materials provided\n with the distribution.\n \n * The names of the contributors may not be used to endorse or\n promote products derived from this software without specific\n prior written permission.\n \n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef FXAA_REDUCE_MIN\n#define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n#define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n#define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent\n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n          vec2 v_rgbNW, vec2 v_rgbNE,\n          vec2 v_rgbSW, vec2 v_rgbSE,\n          vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    \n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    \n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n                  dir * rcpDirMin)) * inverseVP;\n    \n    vec3 rgbA = 0.5 * (\n                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nvoid main() {\n\n      vec2 fragCoord = vTextureCoord * filterArea.xy;\n\n      vec4 color;\n\n    color = fxaa(uSampler, fragCoord, filterArea.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n      gl_FragColor = color;\n}\n')); }
                return FXAAFilter;
            }(core.Filter);
            exports.default = FXAAFilter;
        }, { "../../core": 63, "path": 22 }],
        149: [function(require, module, exports) { 'use strict';
            exports.__esModule = true; var _FXAAFilter = require('./fxaa/FXAAFilter');
            Object.defineProperty(exports, 'FXAAFilter', { enumerable: true, get: function get() { return _interopRequireDefault(_FXAAFilter).default; } }); var _NoiseFilter = require('./noise/NoiseFilter');
            Object.defineProperty(exports, 'NoiseFilter', { enumerable: true, get: function get() { return _interopRequireDefault(_NoiseFilter).default; } }); var _DisplacementFilter = require('./displacement/DisplacementFilter');
            Object.defineProperty(exports, 'DisplacementFilter', { enumerable: true, get: function get() { return _interopRequireDefault(_DisplacementFilter).default; } }); var _BlurFilter = require('./blur/BlurFilter');
            Object.defineProperty(exports, 'BlurFilter', { enumerable: true, get: function get() { return _interopRequireDefault(_BlurFilter).default; } }); var _BlurXFilter = require('./blur/BlurXFilter');
            Object.defineProperty(exports, 'BlurXFilter', { enumerable: true, get: function get() { return _interopRequireDefault(_BlurXFilter).default; } }); var _BlurYFilter = require('./blur/BlurYFilter');
            Object.defineProperty(exports, 'BlurYFilter', { enumerable: true, get: function get() { return _interopRequireDefault(_BlurYFilter).default; } }); var _ColorMatrixFilter = require('./colormatrix/ColorMatrixFilter');
            Object.defineProperty(exports, 'ColorMatrixFilter', { enumerable: true, get: function get() { return _interopRequireDefault(_ColorMatrixFilter).default; } }); var _VoidFilter = require('./void/VoidFilter');
            Object.defineProperty(exports, 'VoidFilter', { enumerable: true, get: function get() { return _interopRequireDefault(_VoidFilter).default; } });

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } }, { "./blur/BlurFilter": 140, "./blur/BlurXFilter": 141, "./blur/BlurYFilter": 142, "./colormatrix/ColorMatrixFilter": 146, "./displacement/DisplacementFilter": 147, "./fxaa/FXAAFilter": 148, "./noise/NoiseFilter": 150, "./void/VoidFilter": 151 }],
        150: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _path = require('path');

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var NoiseFilter = function(_core$Filter) {
                _inherits(NoiseFilter, _core$Filter);

                function NoiseFilter() { var noise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5; var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.random();
                    _classCallCheck(this, NoiseFilter); var _this = _possibleConstructorReturn(this, _core$Filter.call(this, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}', 'precision highp float;\n\nvarying vec2 vTextureCoord;\nvarying vec4 vColor;\n\nuniform float uNoise;\nuniform float uSeed;\nuniform sampler2D uSampler;\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main()\n{\n    vec4 color = texture2D(uSampler, vTextureCoord);\n    float randomValue = rand(gl_FragCoord.xy * uSeed);\n    float diff = (randomValue - 0.5) * uNoise;\n\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\n    if (color.a > 0.0) {\n        color.rgb /= color.a;\n    }\n\n    color.r += diff;\n    color.g += diff;\n    color.b += diff;\n\n    // Premultiply alpha again.\n    color.rgb *= color.a;\n\n    gl_FragColor = color;\n}\n'));
                    _this.noise = noise;
                    _this.seed = seed; return _this; }
                _createClass(NoiseFilter, [{
                    key: 'noise',
                    get: function get() { return this.uniforms.uNoise; },
                    set: function set(value) { this.uniforms.uNoise = value; }
                }, {
                    key: 'seed',
                    get: function get() { return this.uniforms.uSeed; },
                    set: function set(value) { this.uniforms.uSeed = value; }
                }]);
                return NoiseFilter;
            }(core.Filter);
            exports.default = NoiseFilter;
        }, { "../../core": 63, "path": 22 }],
        151: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _path = require('path');

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var VoidFilter = function(_core$Filter) {
                _inherits(VoidFilter, _core$Filter);

                function VoidFilter() { _classCallCheck(this, VoidFilter); var _this = _possibleConstructorReturn(this, _core$Filter.call(this, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n    vTextureCoord = aTextureCoord;\n}', 'varying vec2 vTextureCoord;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\n}\n'));
                    _this.glShaderKey = 'void'; return _this; }
                return VoidFilter;
            }(core.Filter);
            exports.default = VoidFilter;
        }, { "../../core": 63, "path": 22 }],
        152: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../core');
            var core = _interopRequireWildcard(_core);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var InteractionData = function() {
                function InteractionData() { _classCallCheck(this, InteractionData);
                    this.global = new core.Point();
                    this.target = null;
                    this.originalEvent = null;
                    this.identifier = null; }
                InteractionData.prototype.getLocalPosition = function getLocalPosition(displayObject, point, globalPos) { return displayObject.worldTransform.applyInverse(globalPos || this.global, point); };
                return InteractionData;
            }();
            exports.default = InteractionData;
        }, { "../core": 63 }],
        153: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var InteractionEvent = function() {
                function InteractionEvent() { _classCallCheck(this, InteractionEvent);
                    this.stopped = false;
                    this.target = null;
                    this.currentTarget = null;
                    this.type = null;
                    this.data = null; }
                InteractionEvent.prototype.stopPropagation = function stopPropagation() { this.stopped = true; };
                InteractionEvent.prototype._reset = function _reset() { this.stopped = false;
                    this.currentTarget = null;
                    this.target = null; };
                return InteractionEvent;
            }();
            exports.default = InteractionEvent;
        }, {}],
        154: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) { return typeof obj; } : function(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
            var _core = require('../core');
            var core = _interopRequireWildcard(_core);
            var _InteractionData = require('./InteractionData');
            var _InteractionData2 = _interopRequireDefault(_InteractionData);
            var _InteractionEvent = require('./InteractionEvent');
            var _InteractionEvent2 = _interopRequireDefault(_InteractionEvent);
            var _InteractionTrackingData = require('./InteractionTrackingData');
            var _InteractionTrackingData2 = _interopRequireDefault(_InteractionTrackingData);
            var _eventemitter = require('eventemitter3');
            var _eventemitter2 = _interopRequireDefault(_eventemitter);
            var _interactiveTarget = require('./interactiveTarget');
            var _interactiveTarget2 = _interopRequireDefault(_interactiveTarget);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            core.utils.mixins.delayMixin(core.DisplayObject.prototype, _interactiveTarget2.default);
            var MOUSE_POINTER_ID = 'MOUSE';
            var hitTestEvent = { target: null, data: { global: null } };
            var InteractionManager = function(_EventEmitter) {
                _inherits(InteractionManager, _EventEmitter);

                function InteractionManager(renderer, options) { _classCallCheck(this, InteractionManager); var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));
                    options = options || {};
                    _this.renderer = renderer;
                    _this.autoPreventDefault = options.autoPreventDefault !== undefined ? options.autoPreventDefault : true;
                    _this.interactionFrequency = options.interactionFrequency || 10;
                    _this.mouse = new _InteractionData2.default();
                    _this.mouse.identifier = MOUSE_POINTER_ID;
                    _this.mouse.global.set(-999999);
                    _this.activeInteractionData = {};
                    _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;
                    _this.interactionDataPool = [];
                    _this.eventData = new _InteractionEvent2.default();
                    _this.interactionDOMElement = null;
                    _this.moveWhenInside = false;
                    _this.eventsAdded = false;
                    _this.mouseOverRenderer = false;
                    _this.supportsTouchEvents = 'ontouchstart' in window;
                    _this.supportsPointerEvents = !!window.PointerEvent;
                    _this.onPointerUp = _this.onPointerUp.bind(_this);
                    _this.processPointerUp = _this.processPointerUp.bind(_this);
                    _this.onPointerCancel = _this.onPointerCancel.bind(_this);
                    _this.processPointerCancel = _this.processPointerCancel.bind(_this);
                    _this.onPointerDown = _this.onPointerDown.bind(_this);
                    _this.processPointerDown = _this.processPointerDown.bind(_this);
                    _this.onPointerMove = _this.onPointerMove.bind(_this);
                    _this.processPointerMove = _this.processPointerMove.bind(_this);
                    _this.onPointerOut = _this.onPointerOut.bind(_this);
                    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
                    _this.onPointerOver = _this.onPointerOver.bind(_this);
                    _this.cursorStyles = { default: 'inherit', pointer: 'pointer' };
                    _this.currentCursorMode = null;
                    _this.cursor = null;
                    _this._tempPoint = new core.Point();
                    _this.resolution = 1;
                    _this.setTargetElement(_this.renderer.view, _this.renderer.resolution); return _this; }
                InteractionManager.prototype.hitTest = function hitTest(globalPoint, root) {
                    hitTestEvent.target = null;
                    hitTestEvent.data.global = globalPoint;
                    if (!root) { root = this.renderer._lastObjectRendered; }
                    this.processInteractive(hitTestEvent, root, null, true);
                    return hitTestEvent.target;
                };
                InteractionManager.prototype.setTargetElement = function setTargetElement(element) { var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                    this.removeEvents();
                    this.interactionDOMElement = element;
                    this.resolution = resolution;
                    this.addEvents(); };
                InteractionManager.prototype.addEvents = function addEvents() {
                    if (!this.interactionDOMElement) { return; }
                    core.ticker.shared.add(this.update, this, core.UPDATE_PRIORITY.INTERACTION);
                    if (window.navigator.msPointerEnabled) { this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
                        this.interactionDOMElement.style['-ms-touch-action'] = 'none'; } else if (this.supportsPointerEvents) { this.interactionDOMElement.style['touch-action'] = 'none'; }
                    if (this.supportsPointerEvents) { window.document.addEventListener('pointermove', this.onPointerMove, true);
                        this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);
                        this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);
                        this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);
                        window.addEventListener('pointercancel', this.onPointerCancel, true);
                        window.addEventListener('pointerup', this.onPointerUp, true); } else { window.document.addEventListener('mousemove', this.onPointerMove, true);
                        this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);
                        this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);
                        this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);
                        window.addEventListener('mouseup', this.onPointerUp, true); if (this.supportsTouchEvents) { this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);
                            this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);
                            this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);
                            this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true); } }
                    this.eventsAdded = true;
                };
                InteractionManager.prototype.removeEvents = function removeEvents() {
                    if (!this.interactionDOMElement) { return; }
                    core.ticker.shared.remove(this.update, this);
                    if (window.navigator.msPointerEnabled) { this.interactionDOMElement.style['-ms-content-zooming'] = '';
                        this.interactionDOMElement.style['-ms-touch-action'] = ''; } else if (this.supportsPointerEvents) { this.interactionDOMElement.style['touch-action'] = ''; }
                    if (this.supportsPointerEvents) { window.document.removeEventListener('pointermove', this.onPointerMove, true);
                        this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);
                        this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);
                        this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);
                        window.removeEventListener('pointercancel', this.onPointerCancel, true);
                        window.removeEventListener('pointerup', this.onPointerUp, true); } else { window.document.removeEventListener('mousemove', this.onPointerMove, true);
                        this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);
                        this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);
                        this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);
                        window.removeEventListener('mouseup', this.onPointerUp, true); if (this.supportsTouchEvents) { this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);
                            this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);
                            this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);
                            this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true); } }
                    this.interactionDOMElement = null;
                    this.eventsAdded = false;
                };
                InteractionManager.prototype.update = function update(deltaTime) {
                    this._deltaTime += deltaTime;
                    if (this._deltaTime < this.interactionFrequency) { return; }
                    this._deltaTime = 0;
                    if (!this.interactionDOMElement) { return; }
                    if (this.didMove) { this.didMove = false; return; }
                    this.cursor = null;
                    for (var k in this.activeInteractionData) { if (this.activeInteractionData.hasOwnProperty(k)) { var interactionData = this.activeInteractionData[k]; if (interactionData.originalEvent && interactionData.pointerType !== 'touch') { var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
                                this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, true); } } }
                    this.setCursorMode(this.cursor);
                };
                InteractionManager.prototype.setCursorMode = function setCursorMode(mode) {
                    mode = mode || 'default';
                    if (this.currentCursorMode === mode) { return; }
                    this.currentCursorMode = mode;
                    var style = this.cursorStyles[mode];
                    if (style) { switch (typeof style === 'undefined' ? 'undefined' : _typeof(style)) {
                            case 'string':
                                this.interactionDOMElement.style.cursor = style; break;
                            case 'function':
                                style(mode); break;
                            case 'object':
                                Object.assign(this.interactionDOMElement.style, style); break; } }
                };
                InteractionManager.prototype.dispatchEvent = function dispatchEvent(displayObject, eventString, eventData) { if (!eventData.stopped) { eventData.currentTarget = displayObject;
                        eventData.type = eventString;
                        displayObject.emit(eventString, eventData); if (displayObject[eventString]) { displayObject[eventString](eventData); } } };
                InteractionManager.prototype.mapPositionToPoint = function mapPositionToPoint(point, x, y) {
                    var rect = void 0;
                    if (!this.interactionDOMElement.parentElement) { rect = { x: 0, y: 0, width: 0, height: 0 }; } else { rect = this.interactionDOMElement.getBoundingClientRect(); }
                    var resolutionMultiplier = navigator.isCocoonJS ? this.resolution : 1.0 / this.resolution;
                    point.x = (x - rect.left) * (this.interactionDOMElement.width / rect.width) * resolutionMultiplier;
                    point.y = (y - rect.top) * (this.interactionDOMElement.height / rect.height) * resolutionMultiplier;
                };
                InteractionManager.prototype.processInteractive = function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {
                    if (!displayObject || !displayObject.visible) { return false; }
                    var point = interactionEvent.data.global;
                    interactive = displayObject.interactive || interactive;
                    var hit = false;
                    var interactiveParent = interactive;
                    if (displayObject.hitArea) { interactiveParent = false; } else if (hitTest && displayObject._mask) { if (!displayObject._mask.containsPoint(point)) { hitTest = false; } }
                    if (displayObject.interactiveChildren && displayObject.children) {
                        var children = displayObject.children;
                        for (var i = children.length - 1; i >= 0; i--) {
                            var child = children[i];
                            var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);
                            if (childHit) {
                                if (!child.parent) { continue; }
                                interactiveParent = false;
                                if (childHit) {
                                    if (interactionEvent.target) { hitTest = false; }
                                    hit = true;
                                }
                            }
                        }
                    }
                    if (interactive) {
                        if (hitTest && !interactionEvent.target) { if (displayObject.hitArea) { displayObject.worldTransform.applyInverse(point, this._tempPoint); if (displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) { hit = true; } } else if (displayObject.containsPoint) { if (displayObject.containsPoint(point)) { hit = true; } } }
                        if (displayObject.interactive) {
                            if (hit && !interactionEvent.target) { interactionEvent.target = displayObject; }
                            if (func) { func(interactionEvent, displayObject, !!hit); }
                        }
                    }
                    return hit;
                };
                InteractionManager.prototype.onPointerDown = function onPointerDown(originalEvent) {
                    var events = this.normalizeToPointerData(originalEvent);
                    if (this.autoPreventDefault && events[0].isNormalized) { originalEvent.preventDefault(); }
                    var eventLen = events.length;
                    for (var i = 0; i < eventLen; i++) { var event = events[i]; var interactionData = this.getInteractionDataForPointerId(event); var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
                        interactionEvent.data.originalEvent = originalEvent;
                        this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerDown, true);
                        this.emit('pointerdown', interactionEvent); if (event.pointerType === 'touch') { this.emit('touchstart', interactionEvent); } else if (event.pointerType === 'mouse') { var isRightButton = event.button === 2 || event.which === 3;
                            this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData); } }
                };
                InteractionManager.prototype.processPointerDown = function processPointerDown(interactionEvent, displayObject, hit) {
                    var e = interactionEvent.data.originalEvent;
                    var id = interactionEvent.data.identifier;
                    if (hit) {
                        if (!displayObject.trackedPointers[id]) { displayObject.trackedPointers[id] = new _InteractionTrackingData2.default(id); }
                        this.dispatchEvent(displayObject, 'pointerdown', interactionEvent);
                        if (e.type === 'touchstart' || e.pointerType === 'touch') { this.dispatchEvent(displayObject, 'touchstart', interactionEvent); } else if (e.type === 'mousedown' || e.pointerType === 'mouse') {
                            var isRightButton = e.button === 2 || e.which === 3;
                            if (isRightButton) { displayObject.trackedPointers[id].rightDown = true; } else { displayObject.trackedPointers[id].leftDown = true; }
                            this.dispatchEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);
                        }
                    }
                };
                InteractionManager.prototype.onPointerComplete = function onPointerComplete(originalEvent, cancelled, func) { var events = this.normalizeToPointerData(originalEvent); var eventLen = events.length; var eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : ''; for (var i = 0; i < eventLen; i++) { var event = events[i]; var interactionData = this.getInteractionDataForPointerId(event); var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
                        interactionEvent.data.originalEvent = originalEvent;
                        this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, func, cancelled || !eventAppend);
                        this.emit(cancelled ? 'pointercancel' : 'pointerup' + eventAppend, interactionEvent); if (event.pointerType === 'mouse') { var isRightButton = event.button === 2 || event.which === 3;
                            this.emit(isRightButton ? 'rightup' + eventAppend : 'mouseup' + eventAppend, interactionEvent); } else if (event.pointerType === 'touch') { this.emit(cancelled ? 'touchcancel' : 'touchend' + eventAppend, interactionEvent);
                            this.releaseInteractionDataForPointerId(event.pointerId, interactionData); } } };
                InteractionManager.prototype.onPointerCancel = function onPointerCancel(event) { this.onPointerComplete(event, true, this.processPointerCancel); };
                InteractionManager.prototype.processPointerCancel = function processPointerCancel(interactionEvent, displayObject) { var e = interactionEvent.data.originalEvent; var id = interactionEvent.data.identifier; if (displayObject.trackedPointers[id] !== undefined) { delete displayObject.trackedPointers[id];
                        this.dispatchEvent(displayObject, 'pointercancel', interactionEvent); if (e.type === 'touchcancel' || e.pointerType === 'touch') { this.dispatchEvent(displayObject, 'touchcancel', interactionEvent); } } };
                InteractionManager.prototype.onPointerUp = function onPointerUp(event) { this.onPointerComplete(event, false, this.processPointerUp); };
                InteractionManager.prototype.processPointerUp = function processPointerUp(interactionEvent, displayObject, hit) {
                    var e = interactionEvent.data.originalEvent;
                    var id = interactionEvent.data.identifier;
                    var trackingData = displayObject.trackedPointers[id];
                    var isTouch = e.type === 'touchend' || e.pointerType === 'touch';
                    var isMouse = e.type.indexOf('mouse') === 0 || e.pointerType === 'mouse';
                    if (isMouse) {
                        var isRightButton = e.button === 2 || e.which === 3;
                        var flags = _InteractionTrackingData2.default.FLAGS;
                        var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
                        var isDown = trackingData !== undefined && trackingData.flags & test;
                        if (hit) { this.dispatchEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent); if (isDown) { this.dispatchEvent(displayObject, isRightButton ? 'rightclick' : 'click', interactionEvent); } } else if (isDown) { this.dispatchEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent); }
                        if (trackingData) { if (isRightButton) { trackingData.rightDown = false; } else { trackingData.leftDown = false; } }
                    }
                    if (hit) { this.dispatchEvent(displayObject, 'pointerup', interactionEvent); if (isTouch) this.dispatchEvent(displayObject, 'touchend', interactionEvent); if (trackingData) { this.dispatchEvent(displayObject, 'pointertap', interactionEvent); if (isTouch) { this.dispatchEvent(displayObject, 'tap', interactionEvent);
                                trackingData.over = false; } } } else if (trackingData) { this.dispatchEvent(displayObject, 'pointerupoutside', interactionEvent); if (isTouch) this.dispatchEvent(displayObject, 'touchendoutside', interactionEvent); }
                    if (trackingData && trackingData.none) { delete displayObject.trackedPointers[id]; }
                };
                InteractionManager.prototype.onPointerMove = function onPointerMove(originalEvent) {
                    var events = this.normalizeToPointerData(originalEvent);
                    if (events[0].pointerType === 'mouse') { this.didMove = true;
                        this.cursor = null; }
                    var eventLen = events.length;
                    for (var i = 0; i < eventLen; i++) { var event = events[i]; var interactionData = this.getInteractionDataForPointerId(event); var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
                        interactionEvent.data.originalEvent = originalEvent; var interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;
                        this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerMove, interactive);
                        this.emit('pointermove', interactionEvent); if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent); if (event.pointerType === 'mouse') this.emit('mousemove', interactionEvent); }
                    if (events[0].pointerType === 'mouse') { this.setCursorMode(this.cursor); }
                };
                InteractionManager.prototype.processPointerMove = function processPointerMove(interactionEvent, displayObject, hit) {
                    var e = interactionEvent.data.originalEvent;
                    var isTouch = e.type === 'touchmove' || e.pointerType === 'touch';
                    var isMouse = e.type === 'mousemove' || e.pointerType === 'mouse';
                    if (isMouse) { this.processPointerOverOut(interactionEvent, displayObject, hit); }
                    if (!this.moveWhenInside || hit) { this.dispatchEvent(displayObject, 'pointermove', interactionEvent); if (isTouch) this.dispatchEvent(displayObject, 'touchmove', interactionEvent); if (isMouse) this.dispatchEvent(displayObject, 'mousemove', interactionEvent); }
                };
                InteractionManager.prototype.onPointerOut = function onPointerOut(originalEvent) {
                    var events = this.normalizeToPointerData(originalEvent);
                    var event = events[0];
                    if (event.pointerType === 'mouse') { this.mouseOverRenderer = false;
                        this.setCursorMode(null); }
                    var interactionData = this.getInteractionDataForPointerId(event);
                    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
                    interactionEvent.data.originalEvent = event;
                    this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, false);
                    this.emit('pointerout', interactionEvent);
                    if (event.pointerType === 'mouse') { this.emit('mouseout', interactionEvent); } else { this.releaseInteractionDataForPointerId(interactionData.identifier); }
                };
                InteractionManager.prototype.processPointerOverOut = function processPointerOverOut(interactionEvent, displayObject, hit) {
                    var e = interactionEvent.data.originalEvent;
                    var id = interactionEvent.data.identifier;
                    var isMouse = e.type === 'mouseover' || e.type === 'mouseout' || e.pointerType === 'mouse';
                    var trackingData = displayObject.trackedPointers[id];
                    if (hit && !trackingData) { trackingData = displayObject.trackedPointers[id] = new _InteractionTrackingData2.default(id); }
                    if (trackingData === undefined) return;
                    if (hit && this.mouseOverRenderer) {
                        if (!trackingData.over) { trackingData.over = true;
                            this.dispatchEvent(displayObject, 'pointerover', interactionEvent); if (isMouse) { this.dispatchEvent(displayObject, 'mouseover', interactionEvent); } }
                        if (isMouse && this.cursor === null) { this.cursor = displayObject.cursor; }
                    } else if (trackingData.over) {
                        trackingData.over = false;
                        this.dispatchEvent(displayObject, 'pointerout', this.eventData);
                        if (isMouse) { this.dispatchEvent(displayObject, 'mouseout', interactionEvent); }
                        if (trackingData.none) { delete displayObject.trackedPointers[id]; }
                    }
                };
                InteractionManager.prototype.onPointerOver = function onPointerOver(originalEvent) {
                    var events = this.normalizeToPointerData(originalEvent);
                    var event = events[0];
                    var interactionData = this.getInteractionDataForPointerId(event);
                    var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
                    interactionEvent.data.originalEvent = event;
                    if (event.pointerType === 'mouse') { this.mouseOverRenderer = true; }
                    this.emit('pointerover', interactionEvent);
                    if (event.pointerType === 'mouse') { this.emit('mouseover', interactionEvent); }
                };
                InteractionManager.prototype.getInteractionDataForPointerId = function getInteractionDataForPointerId(event) {
                    var pointerId = event.pointerId;
                    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') { return this.mouse; } else if (this.activeInteractionData[pointerId]) { return this.activeInteractionData[pointerId]; }
                    var interactionData = this.interactionDataPool.pop() || new _InteractionData2.default();
                    interactionData.identifier = pointerId;
                    this.activeInteractionData[pointerId] = interactionData;
                    return interactionData;
                };
                InteractionManager.prototype.releaseInteractionDataForPointerId = function releaseInteractionDataForPointerId(pointerId) { var interactionData = this.activeInteractionData[pointerId]; if (interactionData) { delete this.activeInteractionData[pointerId];
                        this.interactionDataPool.push(interactionData); } };
                InteractionManager.prototype.configureInteractionEventForDOMEvent = function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {
                    interactionEvent.data = interactionData;
                    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
                    if (navigator.isCocoonJS && pointerEvent.pointerType === 'touch') { interactionData.global.x = interactionData.global.x / this.resolution;
                        interactionData.global.y = interactionData.global.y / this.resolution; }
                    if (pointerEvent.pointerType === 'touch') { pointerEvent.globalX = interactionData.global.x;
                        pointerEvent.globalY = interactionData.global.y; }
                    interactionData.originalEvent = pointerEvent;
                    interactionEvent._reset();
                    return interactionEvent;
                };
                InteractionManager.prototype.normalizeToPointerData = function normalizeToPointerData(event) {
                    var normalizedEvents = [];
                    if (this.supportsTouchEvents && event instanceof TouchEvent) { for (var i = 0, li = event.changedTouches.length; i < li; i++) { var touch = event.changedTouches[i]; if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0; if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0; if (typeof touch.isPrimary === 'undefined') touch.isPrimary = event.touches.length === 1; if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1; if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1; if (typeof touch.tiltX === 'undefined') touch.tiltX = 0; if (typeof touch.tiltY === 'undefined') touch.tiltY = 0; if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch'; if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0; if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5; if (typeof touch.rotation === 'undefined') touch.rotation = touch.rotationAngle || 0; if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX; if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;
                            touch.isNormalized = true;
                            normalizedEvents.push(touch); } } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) { if (typeof event.isPrimary === 'undefined') event.isPrimary = true; if (typeof event.width === 'undefined') event.width = 1; if (typeof event.height === 'undefined') event.height = 1; if (typeof event.tiltX === 'undefined') event.tiltX = 0; if (typeof event.tiltY === 'undefined') event.tiltY = 0; if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse'; if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID; if (typeof event.pressure === 'undefined') event.pressure = 0.5; if (typeof event.rotation === 'undefined') event.rotation = 0;
                        event.isNormalized = true;
                        normalizedEvents.push(event); } else { normalizedEvents.push(event); }
                    return normalizedEvents;
                };
                InteractionManager.prototype.destroy = function destroy() { this.removeEvents();
                    this.removeAllListeners();
                    this.renderer = null;
                    this.mouse = null;
                    this.eventData = null;
                    this.interactionDOMElement = null;
                    this.onPointerDown = null;
                    this.processPointerDown = null;
                    this.onPointerUp = null;
                    this.processPointerUp = null;
                    this.onPointerCancel = null;
                    this.processPointerCancel = null;
                    this.onPointerMove = null;
                    this.processPointerMove = null;
                    this.onPointerOut = null;
                    this.processPointerOverOut = null;
                    this.onPointerOver = null;
                    this._tempPoint = null; };
                return InteractionManager;
            }(_eventemitter2.default);
            exports.default = InteractionManager;
            core.WebGLRenderer.registerPlugin('interaction', InteractionManager);
            core.CanvasRenderer.registerPlugin('interaction', InteractionManager);
        }, { "../core": 63, "./InteractionData": 152, "./InteractionEvent": 153, "./InteractionTrackingData": 155, "./interactiveTarget": 157, "eventemitter3": 3 }],
        155: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var InteractionTrackingData = function() {
                function InteractionTrackingData(pointerId) { _classCallCheck(this, InteractionTrackingData);
                    this._pointerId = pointerId;
                    this._flags = InteractionTrackingData.FLAGS.NONE; }
                InteractionTrackingData.prototype._doSet = function _doSet(flag, yn) { if (yn) { this._flags = this._flags | flag; } else { this._flags = this._flags & ~flag; } };
                _createClass(InteractionTrackingData, [{ key: "pointerId", get: function get() { return this._pointerId; } }, { key: "flags", get: function get() { return this._flags; }, set: function set(flags) { this._flags = flags; } }, { key: "none", get: function get() { return this._flags === this.constructor.FLAGS.NONE; } }, { key: "over", get: function get() { return (this._flags & this.constructor.FLAGS.OVER) !== 0; }, set: function set(yn) { this._doSet(this.constructor.FLAGS.OVER, yn); } }, { key: "rightDown", get: function get() { return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0; }, set: function set(yn) { this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn); } }, { key: "leftDown", get: function get() { return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0; }, set: function set(yn) { this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn); } }]);
                return InteractionTrackingData;
            }();
            exports.default = InteractionTrackingData;
            InteractionTrackingData.FLAGS = Object.freeze({ NONE: 0, OVER: 1 << 0, LEFT_DOWN: 1 << 1, RIGHT_DOWN: 1 << 2 });
        }, {}],
        156: [function(require, module, exports) { 'use strict';
            exports.__esModule = true; var _InteractionData = require('./InteractionData');
            Object.defineProperty(exports, 'InteractionData', { enumerable: true, get: function get() { return _interopRequireDefault(_InteractionData).default; } }); var _InteractionManager = require('./InteractionManager');
            Object.defineProperty(exports, 'InteractionManager', { enumerable: true, get: function get() { return _interopRequireDefault(_InteractionManager).default; } }); var _interactiveTarget = require('./interactiveTarget');
            Object.defineProperty(exports, 'interactiveTarget', { enumerable: true, get: function get() { return _interopRequireDefault(_interactiveTarget).default; } });

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } }, { "./InteractionData": 152, "./InteractionManager": 154, "./interactiveTarget": 157 }],
        157: [function(require, module, exports) { 'use strict';
            exports.__esModule = true;
            exports.default = { interactive: false, interactiveChildren: true, hitArea: null, get buttonMode() { return this.cursor === 'pointer'; }, set buttonMode(value) { if (value) { this.cursor = 'pointer'; } else if (this.cursor === 'pointer') { this.cursor = null; } }, cursor: null, get trackedPointers() { if (this._trackedPointers === undefined) this._trackedPointers = {}; return this._trackedPointers; }, _trackedPointers: undefined }; }, {}],
        158: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.parse = parse;
            exports.default = function() {
                return function bitmapFontParser(resource, next) {
                    if (!resource.data || resource.type !== _resourceLoader.Resource.TYPE.XML) { next(); return; }
                    if (resource.data.getElementsByTagName('page').length === 0 || resource.data.getElementsByTagName('info').length === 0 || resource.data.getElementsByTagName('info')[0].getAttribute('face') === null) { next(); return; }
                    var xmlUrl = !resource.isDataUrl ? path.dirname(resource.url) : '';
                    if (resource.isDataUrl) {
                        if (xmlUrl === '.') { xmlUrl = ''; }
                        if (this.baseUrl && xmlUrl) {
                            if (this.baseUrl.charAt(this.baseUrl.length - 1) === '/') { xmlUrl += '/'; }
                            xmlUrl = xmlUrl.replace(this.baseUrl, '');
                        }
                    }
                    if (xmlUrl && xmlUrl.charAt(xmlUrl.length - 1) !== '/') { xmlUrl += '/'; }
                    var textureUrl = xmlUrl + resource.data.getElementsByTagName('page')[0].getAttribute('file');
                    if (_core.utils.TextureCache[textureUrl]) { parse(resource, _core.utils.TextureCache[textureUrl]);
                        next(); } else { var loadOptions = { crossOrigin: resource.crossOrigin, loadType: _resourceLoader.Resource.LOAD_TYPE.IMAGE, metadata: resource.metadata.imageMetadata, parentResource: resource };
                        this.add(resource.name + '_image', textureUrl, loadOptions, function(res) { parse(resource, res.texture);
                            next(); }); }
                };
            };
            var _path = require('path');
            var path = _interopRequireWildcard(_path);
            var _core = require('../core');
            var _resourceLoader = require('resource-loader');
            var _extras = require('../extras');

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function parse(resource, texture) { resource.bitmapFont = _extras.BitmapText.registerFont(resource.data, texture); }
        }, { "../core": 63, "../extras": 138, "path": 22, "resource-loader": 34 }],
        159: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.shared = exports.Resource = exports.textureParser = exports.getResourcePath = exports.spritesheetParser = exports.parseBitmapFontData = exports.bitmapFontParser = exports.Loader = undefined;
            var _bitmapFontParser = require('./bitmapFontParser');
            Object.defineProperty(exports, 'bitmapFontParser', { enumerable: true, get: function get() { return _interopRequireDefault(_bitmapFontParser).default; } });
            Object.defineProperty(exports, 'parseBitmapFontData', { enumerable: true, get: function get() { return _bitmapFontParser.parse; } });
            var _spritesheetParser = require('./spritesheetParser');
            Object.defineProperty(exports, 'spritesheetParser', { enumerable: true, get: function get() { return _interopRequireDefault(_spritesheetParser).default; } });
            Object.defineProperty(exports, 'getResourcePath', { enumerable: true, get: function get() { return _spritesheetParser.getResourcePath; } });
            var _textureParser = require('./textureParser');
            Object.defineProperty(exports, 'textureParser', { enumerable: true, get: function get() { return _interopRequireDefault(_textureParser).default; } });
            var _resourceLoader = require('resource-loader');
            Object.defineProperty(exports, 'Resource', { enumerable: true, get: function get() { return _resourceLoader.Resource; } });
            var _Application = require('../core/Application');
            var _Application2 = _interopRequireDefault(_Application);
            var _loader = require('./loader');
            var _loader2 = _interopRequireDefault(_loader);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            exports.Loader = _loader2.default;
            var shared = new _loader2.default();
            shared.destroy = function() {};
            exports.shared = shared;
            var AppPrototype = _Application2.default.prototype;
            AppPrototype._loader = null;
            Object.defineProperty(AppPrototype, 'loader', {
                get: function get() {
                    if (!this._loader) { var sharedLoader = this._options.sharedLoader;
                        this._loader = sharedLoader ? shared : new _loader2.default(); }
                    return this._loader;
                }
            });
            AppPrototype._parentDestroy = AppPrototype.destroy;
            AppPrototype.destroy = function destroy() {
                if (this._loader) { this._loader.destroy();
                    this._loader = null; }
                this._parentDestroy();
            };
        }, { "../core/Application": 41, "./bitmapFontParser": 158, "./loader": 160, "./spritesheetParser": 161, "./textureParser": 162, "resource-loader": 34 }],
        160: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _resourceLoader = require('resource-loader');
            var _resourceLoader2 = _interopRequireDefault(_resourceLoader);
            var _blob = require('resource-loader/lib/middlewares/parsing/blob');
            var _eventemitter = require('eventemitter3');
            var _eventemitter2 = _interopRequireDefault(_eventemitter);
            var _textureParser = require('./textureParser');
            var _textureParser2 = _interopRequireDefault(_textureParser);
            var _spritesheetParser = require('./spritesheetParser');
            var _spritesheetParser2 = _interopRequireDefault(_spritesheetParser);
            var _bitmapFontParser = require('./bitmapFontParser');
            var _bitmapFontParser2 = _interopRequireDefault(_bitmapFontParser);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var Loader = function(_ResourceLoader) {
                _inherits(Loader, _ResourceLoader);

                function Loader(baseUrl, concurrency) {
                    _classCallCheck(this, Loader);
                    var _this = _possibleConstructorReturn(this, _ResourceLoader.call(this, baseUrl, concurrency));
                    _eventemitter2.default.call(_this);
                    for (var i = 0; i < Loader._pixiMiddleware.length; ++i) { _this.use(Loader._pixiMiddleware[i]()); }
                    _this.onStart.add(function(l) { return _this.emit('start', l); });
                    _this.onProgress.add(function(l, r) { return _this.emit('progress', l, r); });
                    _this.onError.add(function(e, l, r) { return _this.emit('error', e, l, r); });
                    _this.onLoad.add(function(l, r) { return _this.emit('load', l, r); });
                    _this.onComplete.add(function(l, r) { return _this.emit('complete', l, r); });
                    return _this;
                }
                Loader.addPixiMiddleware = function addPixiMiddleware(fn) { Loader._pixiMiddleware.push(fn); };
                Loader.prototype.destroy = function destroy() { this.removeAllListeners();
                    this.reset(); };
                return Loader;
            }(_resourceLoader2.default);
            exports.default = Loader;
            for (var k in _eventemitter2.default.prototype) { Loader.prototype[k] = _eventemitter2.default.prototype[k]; }
            Loader._pixiMiddleware = [_blob.blobMiddlewareFactory, _textureParser2.default, _spritesheetParser2.default, _bitmapFontParser2.default];
            var Resource = _resourceLoader2.default.Resource;
            Resource.setExtensionXhrType('fnt', Resource.XHR_RESPONSE_TYPE.DOCUMENT);
        }, { "./bitmapFontParser": 158, "./spritesheetParser": 161, "./textureParser": 162, "eventemitter3": 3, "resource-loader": 34, "resource-loader/lib/middlewares/parsing/blob": 35 }],
        161: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = function() {
                return function spritesheetParser(resource, next) {
                    var imageResourceName = resource.name + '_image';
                    if (!resource.data || resource.type !== _resourceLoader.Resource.TYPE.JSON || !resource.data.frames || this.resources[imageResourceName]) { next(); return; }
                    var loadOptions = { crossOrigin: resource.crossOrigin, loadType: _resourceLoader.Resource.LOAD_TYPE.IMAGE, metadata: resource.metadata.imageMetadata, parentResource: resource };
                    var resourcePath = getResourcePath(resource, this.baseUrl);
                    this.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) { var spritesheet = new _core.Spritesheet(res.texture.baseTexture, resource.data, resource.url);
                        spritesheet.parse(function() { resource.spritesheet = spritesheet;
                            resource.textures = spritesheet.textures;
                            next(); }); });
                };
            };
            exports.getResourcePath = getResourcePath;
            var _resourceLoader = require('resource-loader');
            var _url = require('url');
            var _url2 = _interopRequireDefault(_url);
            var _core = require('../core');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function getResourcePath(resource, baseUrl) {
                if (resource.isDataUrl) { return resource.data.meta.image; }
                return _url2.default.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image);
            }
        }, { "../core": 63, "resource-loader": 34, "url": 28 }],
        162: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            exports.default = function() {
                return function textureParser(resource, next) {
                    if (resource.data && resource.type === _resourceLoader.Resource.TYPE.IMAGE) { resource.texture = _Texture2.default.fromLoader(resource.data, resource.url, resource.name); }
                    next();
                };
            };
            var _resourceLoader = require('resource-loader');
            var _Texture = require('../core/textures/Texture');
            var _Texture2 = _interopRequireDefault(_Texture);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
        }, { "../core/textures/Texture": 113, "resource-loader": 34 }],
        163: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _core = require('../core');
            var core = _interopRequireWildcard(_core);
            var _TextureTransform = require('../extras/TextureTransform');
            var _TextureTransform2 = _interopRequireDefault(_TextureTransform);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var tempPoint = new core.Point();
            var tempPolygon = new core.Polygon();
            var Mesh = function(_core$Container) {
                _inherits(Mesh, _core$Container);

                function Mesh(texture, vertices, uvs, indices, drawMode) { _classCallCheck(this, Mesh); var _this = _possibleConstructorReturn(this, _core$Container.call(this));
                    _this._texture = texture;
                    _this.uvs = uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
                    _this.vertices = vertices || new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);
                    _this.indices = indices || new Uint16Array([0, 1, 3, 2]);
                    _this.dirty = 0;
                    _this.indexDirty = 0;
                    _this.blendMode = core.BLEND_MODES.NORMAL;
                    _this.canvasPadding = 0;
                    _this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;
                    _this.shader = null;
                    _this.tintRgb = new Float32Array([1, 1, 1]);
                    _this._glDatas = {};
                    _this._uvTransform = new _TextureTransform2.default(texture);
                    _this.uploadUvTransform = false;
                    _this.pluginName = 'mesh'; return _this; }
                Mesh.prototype._renderWebGL = function _renderWebGL(renderer) { this.refresh();
                    renderer.setObjectRenderer(renderer.plugins[this.pluginName]);
                    renderer.plugins[this.pluginName].render(this); };
                Mesh.prototype._renderCanvas = function _renderCanvas(renderer) { this.refresh();
                    renderer.plugins[this.pluginName].render(this); };
                Mesh.prototype._onTextureUpdate = function _onTextureUpdate() { this._uvTransform.texture = this._texture;
                    this.refresh(); };
                Mesh.prototype.multiplyUvs = function multiplyUvs() { if (!this.uploadUvTransform) { this._uvTransform.multiplyUvs(this.uvs); } };
                Mesh.prototype.refresh = function refresh(forceUpdate) { if (this._uvTransform.update(forceUpdate)) { this._refresh(); } };
                Mesh.prototype._refresh = function _refresh() {};
                Mesh.prototype._calculateBounds = function _calculateBounds() { this._bounds.addVertices(this.transform, this.vertices, 0, this.vertices.length); };
                Mesh.prototype.containsPoint = function containsPoint(point) {
                    if (!this.getBounds().contains(point.x, point.y)) { return false; }
                    this.worldTransform.applyInverse(point, tempPoint);
                    var vertices = this.vertices;
                    var points = tempPolygon.points;
                    var indices = this.indices;
                    var len = this.indices.length;
                    var step = this.drawMode === Mesh.DRAW_MODES.TRIANGLES ? 3 : 1;
                    for (var i = 0; i + 2 < len; i += step) { var ind0 = indices[i] * 2; var ind1 = indices[i + 1] * 2; var ind2 = indices[i + 2] * 2;
                        points[0] = vertices[ind0];
                        points[1] = vertices[ind0 + 1];
                        points[2] = vertices[ind1];
                        points[3] = vertices[ind1 + 1];
                        points[4] = vertices[ind2];
                        points[5] = vertices[ind2 + 1]; if (tempPolygon.contains(tempPoint.x, tempPoint.y)) { return true; } }
                    return false;
                };
                _createClass(Mesh, [{
                    key: 'texture',
                    get: function get() { return this._texture; },
                    set: function set(value) {
                        if (this._texture === value) { return; }
                        this._texture = value;
                        if (value) { if (value.baseTexture.hasLoaded) { this._onTextureUpdate(); } else { value.once('update', this._onTextureUpdate, this); } }
                    }
                }, {
                    key: 'tint',
                    get: function get() { return core.utils.rgb2hex(this.tintRgb); },
                    set: function set(value) { this.tintRgb = core.utils.hex2rgb(value, this.tintRgb); }
                }]);
                return Mesh;
            }(core.Container);
            exports.default = Mesh;
            Mesh.DRAW_MODES = { TRIANGLE_MESH: 0, TRIANGLES: 1 };
        }, { "../core": 63, "../extras/TextureTransform": 133 }],
        164: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _createClass = function() {
                function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor); } } return function(Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
            var _Plane2 = require('./Plane');
            var _Plane3 = _interopRequireDefault(_Plane2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var DEFAULT_BORDER_SIZE = 10;
            var NineSlicePlane = function(_Plane) {
                _inherits(NineSlicePlane, _Plane);

                function NineSlicePlane(texture, leftWidth, topHeight, rightWidth, bottomHeight) { _classCallCheck(this, NineSlicePlane); var _this = _possibleConstructorReturn(this, _Plane.call(this, texture, 4, 4)); var uvs = _this.uvs;
                    uvs[6] = uvs[14] = uvs[22] = uvs[30] = 1;
                    uvs[25] = uvs[27] = uvs[29] = uvs[31] = 1;
                    _this._origWidth = texture.orig.width;
                    _this._origHeight = texture.orig.height;
                    _this._uvw = 1 / _this._origWidth;
                    _this._uvh = 1 / _this._origHeight;
                    _this.width = _this._origWidth;
                    _this.height = _this._origHeight;
                    uvs[2] = uvs[10] = uvs[18] = uvs[26] = _this._uvw * leftWidth;
                    uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - _this._uvw * rightWidth;
                    uvs[9] = uvs[11] = uvs[13] = uvs[15] = _this._uvh * topHeight;
                    uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - _this._uvh * bottomHeight;
                    _this.leftWidth = typeof leftWidth !== 'undefined' ? leftWidth : DEFAULT_BORDER_SIZE;
                    _this.rightWidth = typeof rightWidth !== 'undefined' ? rightWidth : DEFAULT_BORDER_SIZE;
                    _this.topHeight = typeof topHeight !== 'undefined' ? topHeight : DEFAULT_BORDER_SIZE;
                    _this.bottomHeight = typeof bottomHeight !== 'undefined' ? bottomHeight : DEFAULT_BORDER_SIZE;
                    _this.refresh(true); return _this; }
                NineSlicePlane.prototype.updateHorizontalVertices = function updateHorizontalVertices() { var vertices = this.vertices;
                    vertices[9] = vertices[11] = vertices[13] = vertices[15] = this._topHeight;
                    vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - this._bottomHeight;
                    vertices[25] = vertices[27] = vertices[29] = vertices[31] = this._height; };
                NineSlicePlane.prototype.updateVerticalVertices = function updateVerticalVertices() { var vertices = this.vertices;
                    vertices[2] = vertices[10] = vertices[18] = vertices[26] = this._leftWidth;
                    vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - this._rightWidth;
                    vertices[6] = vertices[14] = vertices[22] = vertices[30] = this._width; };
                NineSlicePlane.prototype._renderCanvas = function _renderCanvas(renderer) {
                    var context = renderer.context;
                    context.globalAlpha = this.worldAlpha;
                    var transform = this.worldTransform;
                    var res = renderer.resolution;
                    if (renderer.roundPixels) { context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res | 0, transform.ty * res | 0); } else { context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res); }
                    var base = this._texture.baseTexture;
                    var textureSource = base.source;
                    var w = base.width;
                    var h = base.height;
                    this.drawSegment(context, textureSource, w, h, 0, 1, 10, 11);
                    this.drawSegment(context, textureSource, w, h, 2, 3, 12, 13);
                    this.drawSegment(context, textureSource, w, h, 4, 5, 14, 15);
                    this.drawSegment(context, textureSource, w, h, 8, 9, 18, 19);
                    this.drawSegment(context, textureSource, w, h, 10, 11, 20, 21);
                    this.drawSegment(context, textureSource, w, h, 12, 13, 22, 23);
                    this.drawSegment(context, textureSource, w, h, 16, 17, 26, 27);
                    this.drawSegment(context, textureSource, w, h, 18, 19, 28, 29);
                    this.drawSegment(context, textureSource, w, h, 20, 21, 30, 31);
                };
                NineSlicePlane.prototype.drawSegment = function drawSegment(context, textureSource, w, h, x1, y1, x2, y2) {
                    var uvs = this.uvs;
                    var vertices = this.vertices;
                    var sw = (uvs[x2] - uvs[x1]) * w;
                    var sh = (uvs[y2] - uvs[y1]) * h;
                    var dw = vertices[x2] - vertices[x1];
                    var dh = vertices[y2] - vertices[y1];
                    if (sw < 1) { sw = 1; }
                    if (sh < 1) { sh = 1; }
                    if (dw < 1) { dw = 1; }
                    if (dh < 1) { dh = 1; }
                    context.drawImage(textureSource, uvs[x1] * w, uvs[y1] * h, sw, sh, vertices[x1], vertices[y1], dw, dh);
                };
                _createClass(NineSlicePlane, [{
                    key: 'width',
                    get: function get() { return this._width; },
                    set: function set(value) { this._width = value;
                        this.updateVerticalVertices(); }
                }, {
                    key: 'height',
                    get: function get() { return this._height; },
                    set: function set(value) { this._height = value;
                        this.updateHorizontalVertices(); }
                }, {
                    key: 'leftWidth',
                    get: function get() { return this._leftWidth; },
                    set: function set(value) { this._leftWidth = value; var uvs = this.uvs; var vertices = this.vertices;
                        uvs[2] = uvs[10] = uvs[18] = uvs[26] = this._uvw * value;
                        vertices[2] = vertices[10] = vertices[18] = vertices[26] = value;
                        this.dirty = true; }
                }, {
                    key: 'rightWidth',
                    get: function get() { return this._rightWidth; },
                    set: function set(value) { this._rightWidth = value; var uvs = this.uvs; var vertices = this.vertices;
                        uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - this._uvw * value;
                        vertices[4] = vertices[12] = vertices[20] = vertices[28] = this._width - value;
                        this.dirty = true; }
                }, {
                    key: 'topHeight',
                    get: function get() { return this._topHeight; },
                    set: function set(value) { this._topHeight = value; var uvs = this.uvs; var vertices = this.vertices;
                        uvs[9] = uvs[11] = uvs[13] = uvs[15] = this._uvh * value;
                        vertices[9] = vertices[11] = vertices[13] = vertices[15] = value;
                        this.dirty = true; }
                }, {
                    key: 'bottomHeight',
                    get: function get() { return this._bottomHeight; },
                    set: function set(value) { this._bottomHeight = value; var uvs = this.uvs; var vertices = this.vertices;
                        uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - this._uvh * value;
                        vertices[17] = vertices[19] = vertices[21] = vertices[23] = this._height - value;
                        this.dirty = true; }
                }]);
                return NineSlicePlane;
            }(_Plane3.default);
            exports.default = NineSlicePlane;
        }, { "./Plane": 165 }],
        165: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _Mesh2 = require('./Mesh');
            var _Mesh3 = _interopRequireDefault(_Mesh2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var Plane = function(_Mesh) {
                _inherits(Plane, _Mesh);

                function Plane(texture, verticesX, verticesY) { _classCallCheck(this, Plane); var _this = _possibleConstructorReturn(this, _Mesh.call(this, texture));
                    _this._ready = true;
                    _this.verticesX = verticesX || 10;
                    _this.verticesY = verticesY || 10;
                    _this.drawMode = _Mesh3.default.DRAW_MODES.TRIANGLES;
                    _this.refresh(); return _this; }
                Plane.prototype._refresh = function _refresh() {
                    var texture = this._texture;
                    var total = this.verticesX * this.verticesY;
                    var verts = [];
                    var colors = [];
                    var uvs = [];
                    var indices = [];
                    var segmentsX = this.verticesX - 1;
                    var segmentsY = this.verticesY - 1;
                    var sizeX = texture.width / segmentsX;
                    var sizeY = texture.height / segmentsY;
                    for (var i = 0; i < total; i++) { var x = i % this.verticesX; var y = i / this.verticesX | 0;
                        verts.push(x * sizeX, y * sizeY);
                        uvs.push(x / segmentsX, y / segmentsY); }
                    var totalSub = segmentsX * segmentsY;
                    for (var _i = 0; _i < totalSub; _i++) { var xpos = _i % segmentsX; var ypos = _i / segmentsX | 0; var value = ypos * this.verticesX + xpos; var value2 = ypos * this.verticesX + xpos + 1; var value3 = (ypos + 1) * this.verticesX + xpos; var value4 = (ypos + 1) * this.verticesX + xpos + 1;
                        indices.push(value, value2, value3);
                        indices.push(value2, value4, value3); }
                    this.vertices = new Float32Array(verts);
                    this.uvs = new Float32Array(uvs);
                    this.colors = new Float32Array(colors);
                    this.indices = new Uint16Array(indices);
                    this.indexDirty = true;
                    this.multiplyUvs();
                };
                Plane.prototype._onTextureUpdate = function _onTextureUpdate() { _Mesh3.default.prototype._onTextureUpdate.call(this); if (this._ready) { this.refresh(); } };
                return Plane;
            }(_Mesh3.default);
            exports.default = Plane;
        }, { "./Mesh": 163 }],
        166: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _Mesh2 = require('./Mesh');
            var _Mesh3 = _interopRequireDefault(_Mesh2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var Rope = function(_Mesh) {
                _inherits(Rope, _Mesh);

                function Rope(texture, points) { _classCallCheck(this, Rope); var _this = _possibleConstructorReturn(this, _Mesh.call(this, texture));
                    _this.points = points;
                    _this.vertices = new Float32Array(points.length * 4);
                    _this.uvs = new Float32Array(points.length * 4);
                    _this.colors = new Float32Array(points.length * 2);
                    _this.indices = new Uint16Array(points.length * 2);
                    _this.autoUpdate = true;
                    _this.refresh(); return _this; }
                Rope.prototype._refresh = function _refresh() {
                    var points = this.points;
                    if (points.length < 1 || !this._texture._uvs) { return; }
                    if (this.vertices.length / 4 !== points.length) { this.vertices = new Float32Array(points.length * 4);
                        this.uvs = new Float32Array(points.length * 4);
                        this.colors = new Float32Array(points.length * 2);
                        this.indices = new Uint16Array(points.length * 2); }
                    var uvs = this.uvs;
                    var indices = this.indices;
                    var colors = this.colors;
                    uvs[0] = 0;
                    uvs[1] = 0;
                    uvs[2] = 0;
                    uvs[3] = 1;
                    colors[0] = 1;
                    colors[1] = 1;
                    indices[0] = 0;
                    indices[1] = 1;
                    var total = points.length;
                    for (var i = 1; i < total; i++) { var index = i * 4; var amount = i / (total - 1);
                        uvs[index] = amount;
                        uvs[index + 1] = 0;
                        uvs[index + 2] = amount;
                        uvs[index + 3] = 1;
                        index = i * 2;
                        colors[index] = 1;
                        colors[index + 1] = 1;
                        index = i * 2;
                        indices[index] = index;
                        indices[index + 1] = index + 1; }
                    this.dirty++;
                    this.indexDirty++;
                    this.multiplyUvs();
                    this.refreshVertices();
                };
                Rope.prototype.refreshVertices = function refreshVertices() {
                    var points = this.points;
                    if (points.length < 1) { return; }
                    var lastPoint = points[0];
                    var nextPoint = void 0;
                    var perpX = 0;
                    var perpY = 0;
                    var vertices = this.vertices;
                    var total = points.length;
                    for (var i = 0; i < total; i++) {
                        var point = points[i];
                        var index = i * 4;
                        if (i < points.length - 1) { nextPoint = points[i + 1]; } else { nextPoint = point; }
                        perpY = -(nextPoint.x - lastPoint.x);
                        perpX = nextPoint.y - lastPoint.y;
                        var ratio = (1 - i / (total - 1)) * 10;
                        if (ratio > 1) { ratio = 1; }
                        var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
                        var num = this._texture.height / 2;
                        perpX /= perpLength;
                        perpY /= perpLength;
                        perpX *= num;
                        perpY *= num;
                        vertices[index] = point.x + perpX;
                        vertices[index + 1] = point.y + perpY;
                        vertices[index + 2] = point.x - perpX;
                        vertices[index + 3] = point.y - perpY;
                        lastPoint = point;
                    }
                };
                Rope.prototype.updateTransform = function updateTransform() {
                    if (this.autoUpdate) { this.refreshVertices(); }
                    this.containerUpdateTransform();
                };
                return Rope;
            }(_Mesh3.default);
            exports.default = Rope;
        }, { "./Mesh": 163 }],
        167: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _Mesh = require('../Mesh');
            var _Mesh2 = _interopRequireDefault(_Mesh);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var MeshSpriteRenderer = function() {
                function MeshSpriteRenderer(renderer) { _classCallCheck(this, MeshSpriteRenderer);
                    this.renderer = renderer; }
                MeshSpriteRenderer.prototype.render = function render(mesh) {
                    var renderer = this.renderer;
                    var context = renderer.context;
                    var transform = mesh.worldTransform;
                    var res = renderer.resolution;
                    if (renderer.roundPixels) { context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res | 0, transform.ty * res | 0); } else { context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res); }
                    renderer.setBlendMode(mesh.blendMode);
                    if (mesh.drawMode === _Mesh2.default.DRAW_MODES.TRIANGLE_MESH) { this._renderTriangleMesh(mesh); } else { this._renderTriangles(mesh); }
                };
                MeshSpriteRenderer.prototype._renderTriangleMesh = function _renderTriangleMesh(mesh) { var length = mesh.vertices.length / 2; for (var i = 0; i < length - 2; i++) { var index = i * 2;
                        this._renderDrawTriangle(mesh, index, index + 2, index + 4); } };
                MeshSpriteRenderer.prototype._renderTriangles = function _renderTriangles(mesh) { var indices = mesh.indices; var length = indices.length; for (var i = 0; i < length; i += 3) { var index0 = indices[i] * 2; var index1 = indices[i + 1] * 2; var index2 = indices[i + 2] * 2;
                        this._renderDrawTriangle(mesh, index0, index1, index2); } };
                MeshSpriteRenderer.prototype._renderDrawTriangle = function _renderDrawTriangle(mesh, index0, index1, index2) {
                    var context = this.renderer.context;
                    var uvs = mesh.uvs;
                    var vertices = mesh.vertices;
                    var texture = mesh._texture;
                    if (!texture.valid) { return; }
                    var base = texture.baseTexture;
                    var textureSource = base.source;
                    var textureWidth = base.width;
                    var textureHeight = base.height;
                    var u0 = void 0;
                    var u1 = void 0;
                    var u2 = void 0;
                    var v0 = void 0;
                    var v1 = void 0;
                    var v2 = void 0;
                    if (mesh.uploadUvTransform) { var ut = mesh._uvTransform.mapCoord;
                        u0 = (uvs[index0] * ut.a + uvs[index0 + 1] * ut.c + ut.tx) * base.width;
                        u1 = (uvs[index1] * ut.a + uvs[index1 + 1] * ut.c + ut.tx) * base.width;
                        u2 = (uvs[index2] * ut.a + uvs[index2 + 1] * ut.c + ut.tx) * base.width;
                        v0 = (uvs[index0] * ut.b + uvs[index0 + 1] * ut.d + ut.ty) * base.height;
                        v1 = (uvs[index1] * ut.b + uvs[index1 + 1] * ut.d + ut.ty) * base.height;
                        v2 = (uvs[index2] * ut.b + uvs[index2 + 1] * ut.d + ut.ty) * base.height; } else { u0 = uvs[index0] * base.width;
                        u1 = uvs[index1] * base.width;
                        u2 = uvs[index2] * base.width;
                        v0 = uvs[index0 + 1] * base.height;
                        v1 = uvs[index1 + 1] * base.height;
                        v2 = uvs[index2 + 1] * base.height; }
                    var x0 = vertices[index0];
                    var x1 = vertices[index1];
                    var x2 = vertices[index2];
                    var y0 = vertices[index0 + 1];
                    var y1 = vertices[index1 + 1];
                    var y2 = vertices[index2 + 1];
                    if (mesh.canvasPadding > 0) { var paddingX = mesh.canvasPadding / mesh.worldTransform.a; var paddingY = mesh.canvasPadding / mesh.worldTransform.d; var centerX = (x0 + x1 + x2) / 3; var centerY = (y0 + y1 + y2) / 3; var normX = x0 - centerX; var normY = y0 - centerY; var dist = Math.sqrt(normX * normX + normY * normY);
                        x0 = centerX + normX / dist * (dist + paddingX);
                        y0 = centerY + normY / dist * (dist + paddingY);
                        normX = x1 - centerX;
                        normY = y1 - centerY;
                        dist = Math.sqrt(normX * normX + normY * normY);
                        x1 = centerX + normX / dist * (dist + paddingX);
                        y1 = centerY + normY / dist * (dist + paddingY);
                        normX = x2 - centerX;
                        normY = y2 - centerY;
                        dist = Math.sqrt(normX * normX + normY * normY);
                        x2 = centerX + normX / dist * (dist + paddingX);
                        y2 = centerY + normY / dist * (dist + paddingY); }
                    context.save();
                    context.beginPath();
                    context.moveTo(x0, y0);
                    context.lineTo(x1, y1);
                    context.lineTo(x2, y2);
                    context.closePath();
                    context.clip();
                    var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;
                    var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;
                    var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;
                    var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;
                    var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;
                    var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;
                    var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;
                    context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);
                    context.drawImage(textureSource, 0, 0, textureWidth * base.resolution, textureHeight * base.resolution, 0, 0, textureWidth, textureHeight);
                    context.restore();
                };
                MeshSpriteRenderer.prototype.renderMeshFlat = function renderMeshFlat(mesh) {
                    var context = this.renderer.context;
                    var vertices = mesh.vertices;
                    var length = vertices.length / 2;
                    context.beginPath();
                    for (var i = 1; i < length - 2; ++i) { var index = i * 2; var x0 = vertices[index]; var y0 = vertices[index + 1]; var x1 = vertices[index + 2]; var y1 = vertices[index + 3]; var x2 = vertices[index + 4]; var y2 = vertices[index + 5];
                        context.moveTo(x0, y0);
                        context.lineTo(x1, y1);
                        context.lineTo(x2, y2); }
                    context.fillStyle = '#FF0000';
                    context.fill();
                    context.closePath();
                };
                MeshSpriteRenderer.prototype.destroy = function destroy() { this.renderer = null; };
                return MeshSpriteRenderer;
            }();
            exports.default = MeshSpriteRenderer;
            core.CanvasRenderer.registerPlugin('mesh', MeshSpriteRenderer);
        }, { "../../core": 63, "../Mesh": 163 }],
        168: [function(require, module, exports) { 'use strict';
            exports.__esModule = true; var _Mesh = require('./Mesh');
            Object.defineProperty(exports, 'Mesh', { enumerable: true, get: function get() { return _interopRequireDefault(_Mesh).default; } }); var _MeshRenderer = require('./webgl/MeshRenderer');
            Object.defineProperty(exports, 'MeshRenderer', { enumerable: true, get: function get() { return _interopRequireDefault(_MeshRenderer).default; } }); var _CanvasMeshRenderer = require('./canvas/CanvasMeshRenderer');
            Object.defineProperty(exports, 'CanvasMeshRenderer', { enumerable: true, get: function get() { return _interopRequireDefault(_CanvasMeshRenderer).default; } }); var _Plane = require('./Plane');
            Object.defineProperty(exports, 'Plane', { enumerable: true, get: function get() { return _interopRequireDefault(_Plane).default; } }); var _NineSlicePlane = require('./NineSlicePlane');
            Object.defineProperty(exports, 'NineSlicePlane', { enumerable: true, get: function get() { return _interopRequireDefault(_NineSlicePlane).default; } }); var _Rope = require('./Rope');
            Object.defineProperty(exports, 'Rope', { enumerable: true, get: function get() { return _interopRequireDefault(_Rope).default; } });

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } }, { "./Mesh": 163, "./NineSlicePlane": 164, "./Plane": 165, "./Rope": 166, "./canvas/CanvasMeshRenderer": 167, "./webgl/MeshRenderer": 169 }],
        169: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _pixiGlCore = require('pixi-gl-core');
            var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);
            var _Mesh = require('../Mesh');
            var _Mesh2 = _interopRequireDefault(_Mesh);
            var _path = require('path');

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var matrixIdentity = core.Matrix.IDENTITY;
            var MeshRenderer = function(_core$ObjectRenderer) {
                _inherits(MeshRenderer, _core$ObjectRenderer);

                function MeshRenderer(renderer) { _classCallCheck(this, MeshRenderer); var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));
                    _this.shader = null; return _this; }
                MeshRenderer.prototype.onContextChange = function onContextChange() { var gl = this.renderer.gl;
                    this.shader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\nattribute vec2 aTextureCoord;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform mat3 uTransform;\n\nvarying vec2 vTextureCoord;\n\nvoid main(void)\n{\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\n\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\n}\n', 'varying vec2 vTextureCoord;\nuniform float alpha;\nuniform vec3 tint;\n\nuniform sampler2D uSampler;\n\nvoid main(void)\n{\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * vec4(tint * alpha, alpha);\n}\n'); };
                MeshRenderer.prototype.render = function render(mesh) {
                    var renderer = this.renderer;
                    var gl = renderer.gl;
                    var texture = mesh._texture;
                    if (!texture.valid) { return; }
                    var glData = mesh._glDatas[renderer.CONTEXT_UID];
                    if (!glData) { renderer.bindVao(null);
                        glData = { shader: this.shader, vertexBuffer: _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW), uvBuffer: _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, mesh.uvs, gl.STREAM_DRAW), indexBuffer: _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW), vao: null, dirty: mesh.dirty, indexDirty: mesh.indexDirty };
                        glData.vao = new _pixiGlCore2.default.VertexArrayObject(gl).addIndex(glData.indexBuffer).addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0).addAttribute(glData.uvBuffer, glData.shader.attributes.aTextureCoord, gl.FLOAT, false, 2 * 4, 0);
                        mesh._glDatas[renderer.CONTEXT_UID] = glData; }
                    renderer.bindVao(glData.vao);
                    if (mesh.dirty !== glData.dirty) { glData.dirty = mesh.dirty;
                        glData.uvBuffer.upload(mesh.uvs); }
                    if (mesh.indexDirty !== glData.indexDirty) { glData.indexDirty = mesh.indexDirty;
                        glData.indexBuffer.upload(mesh.indices); }
                    glData.vertexBuffer.upload(mesh.vertices);
                    renderer.bindShader(glData.shader);
                    glData.shader.uniforms.uSampler = renderer.bindTexture(texture);
                    renderer.state.setBlendMode(mesh.blendMode);
                    if (glData.shader.uniforms.uTransform) { if (mesh.uploadUvTransform) { glData.shader.uniforms.uTransform = mesh._uvTransform.mapCoord.toArray(true); } else { glData.shader.uniforms.uTransform = matrixIdentity.toArray(true); } }
                    glData.shader.uniforms.translationMatrix = mesh.worldTransform.toArray(true);
                    glData.shader.uniforms.alpha = mesh.worldAlpha;
                    glData.shader.uniforms.tint = mesh.tintRgb;
                    var drawMode = mesh.drawMode === _Mesh2.default.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;
                    glData.vao.draw(drawMode, mesh.indices.length, 0);
                };
                return MeshRenderer;
            }(core.ObjectRenderer);
            exports.default = MeshRenderer;
            core.WebGLRenderer.registerPlugin('mesh', MeshRenderer);
        }, { "../../core": 63, "../Mesh": 163, "path": 22, "pixi-gl-core": 12 }],
        170: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../core');
            var core = _interopRequireWildcard(_core);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var ParticleContainer = function(_core$Container) {
                _inherits(ParticleContainer, _core$Container);

                function ParticleContainer() {
                    var maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1500;
                    var properties = arguments[1];
                    var batchSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16384;
                    _classCallCheck(this, ParticleContainer);
                    var _this = _possibleConstructorReturn(this, _core$Container.call(this));
                    var maxBatchSize = 16384;
                    if (batchSize > maxBatchSize) { batchSize = maxBatchSize; }
                    if (batchSize > maxSize) { batchSize = maxSize; }
                    _this._properties = [false, true, false, false, false];
                    _this._maxSize = maxSize;
                    _this._batchSize = batchSize;
                    _this._glBuffers = {};
                    _this._bufferToUpdate = 0;
                    _this.interactiveChildren = false;
                    _this.blendMode = core.BLEND_MODES.NORMAL;
                    _this.roundPixels = true;
                    _this.baseTexture = null;
                    _this.setProperties(properties);
                    return _this;
                }
                ParticleContainer.prototype.setProperties = function setProperties(properties) { if (properties) { this._properties[0] = 'scale' in properties ? !!properties.scale : this._properties[0];
                        this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];
                        this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];
                        this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];
                        this._properties[4] = 'alpha' in properties ? !!properties.alpha : this._properties[4]; } };
                ParticleContainer.prototype.updateTransform = function updateTransform() { this.displayObjectUpdateTransform(); };
                ParticleContainer.prototype.renderWebGL = function renderWebGL(renderer) {
                    var _this2 = this;
                    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) { return; }
                    if (!this.baseTexture) { this.baseTexture = this.children[0]._texture.baseTexture; if (!this.baseTexture.hasLoaded) { this.baseTexture.once('update', function() { return _this2.onChildrenChange(0); }); } }
                    renderer.setObjectRenderer(renderer.plugins.particle);
                    renderer.plugins.particle.render(this);
                };
                ParticleContainer.prototype.onChildrenChange = function onChildrenChange(smallestChildIndex) { var bufferIndex = Math.floor(smallestChildIndex / this._batchSize); if (bufferIndex < this._bufferToUpdate) { this._bufferToUpdate = bufferIndex; } };
                ParticleContainer.prototype.renderCanvas = function renderCanvas(renderer) {
                    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) { return; }
                    var context = renderer.context;
                    var transform = this.worldTransform;
                    var isRotated = true;
                    var positionX = 0;
                    var positionY = 0;
                    var finalWidth = 0;
                    var finalHeight = 0;
                    var compositeOperation = renderer.blendModes[this.blendMode];
                    if (compositeOperation !== context.globalCompositeOperation) { context.globalCompositeOperation = compositeOperation; }
                    context.globalAlpha = this.worldAlpha;
                    this.displayObjectUpdateTransform();
                    for (var i = 0; i < this.children.length; ++i) {
                        var child = this.children[i];
                        if (!child.visible) { continue; }
                        var frame = child._texture.frame;
                        context.globalAlpha = this.worldAlpha * child.alpha;
                        if (child.rotation % (Math.PI * 2) === 0) {
                            if (isRotated) { context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx * renderer.resolution, transform.ty * renderer.resolution);
                                isRotated = false; }
                            positionX = child.anchor.x * (-frame.width * child.scale.x) + child.position.x + 0.5;
                            positionY = child.anchor.y * (-frame.height * child.scale.y) + child.position.y + 0.5;
                            finalWidth = frame.width * child.scale.x;
                            finalHeight = frame.height * child.scale.y;
                        } else {
                            if (!isRotated) { isRotated = true; }
                            child.displayObjectUpdateTransform();
                            var childTransform = child.worldTransform;
                            if (renderer.roundPixels) { context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx * renderer.resolution | 0, childTransform.ty * renderer.resolution | 0); } else { context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx * renderer.resolution, childTransform.ty * renderer.resolution); }
                            positionX = child.anchor.x * -frame.width + 0.5;
                            positionY = child.anchor.y * -frame.height + 0.5;
                            finalWidth = frame.width;
                            finalHeight = frame.height;
                        }
                        var resolution = child._texture.baseTexture.resolution;
                        context.drawImage(child._texture.baseTexture.source, frame.x * resolution, frame.y * resolution, frame.width * resolution, frame.height * resolution, positionX * renderer.resolution, positionY * renderer.resolution, finalWidth * renderer.resolution, finalHeight * renderer.resolution);
                    }
                };
                ParticleContainer.prototype.destroy = function destroy(options) {
                    _core$Container.prototype.destroy.call(this, options);
                    if (this._buffers) { for (var i = 0; i < this._buffers.length; ++i) { this._buffers[i].destroy(); } }
                    this._properties = null;
                    this._buffers = null;
                };
                return ParticleContainer;
            }(core.Container);
            exports.default = ParticleContainer;
        }, { "../core": 63 }],
        171: [function(require, module, exports) { 'use strict';
            exports.__esModule = true; var _ParticleContainer = require('./ParticleContainer');
            Object.defineProperty(exports, 'ParticleContainer', { enumerable: true, get: function get() { return _interopRequireDefault(_ParticleContainer).default; } }); var _ParticleRenderer = require('./webgl/ParticleRenderer');
            Object.defineProperty(exports, 'ParticleRenderer', { enumerable: true, get: function get() { return _interopRequireDefault(_ParticleRenderer).default; } });

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } }, { "./ParticleContainer": 170, "./webgl/ParticleRenderer": 173 }],
        172: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _pixiGlCore = require('pixi-gl-core');
            var _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);
            var _createIndicesForQuads = require('../../core/utils/createIndicesForQuads');
            var _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var ParticleBuffer = function() {
                function ParticleBuffer(gl, properties, dynamicPropertyFlags, size) {
                    _classCallCheck(this, ParticleBuffer);
                    this.gl = gl;
                    this.vertSize = 2;
                    this.vertByteSize = this.vertSize * 4;
                    this.size = size;
                    this.dynamicProperties = [];
                    this.staticProperties = [];
                    for (var i = 0; i < properties.length; ++i) { var property = properties[i];
                        property = { attribute: property.attribute, size: property.size, uploadFunction: property.uploadFunction, offset: property.offset }; if (dynamicPropertyFlags[i]) { this.dynamicProperties.push(property); } else { this.staticProperties.push(property); } }
                    this.staticStride = 0;
                    this.staticBuffer = null;
                    this.staticData = null;
                    this.dynamicStride = 0;
                    this.dynamicBuffer = null;
                    this.dynamicData = null;
                    this.initBuffers();
                }
                ParticleBuffer.prototype.initBuffers = function initBuffers() {
                    var gl = this.gl;
                    var dynamicOffset = 0;
                    this.indices = (0, _createIndicesForQuads2.default)(this.size);
                    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);
                    this.dynamicStride = 0;
                    for (var i = 0; i < this.dynamicProperties.length; ++i) { var property = this.dynamicProperties[i];
                        property.offset = dynamicOffset;
                        dynamicOffset += property.size;
                        this.dynamicStride += property.size; }
                    this.dynamicData = new Float32Array(this.size * this.dynamicStride * 4);
                    this.dynamicBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, this.dynamicData, gl.STREAM_DRAW);
                    var staticOffset = 0;
                    this.staticStride = 0;
                    for (var _i = 0; _i < this.staticProperties.length; ++_i) { var _property = this.staticProperties[_i];
                        _property.offset = staticOffset;
                        staticOffset += _property.size;
                        this.staticStride += _property.size; }
                    this.staticData = new Float32Array(this.size * this.staticStride * 4);
                    this.staticBuffer = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, this.staticData, gl.STATIC_DRAW);
                    this.vao = new _pixiGlCore2.default.VertexArrayObject(gl).addIndex(this.indexBuffer);
                    for (var _i2 = 0; _i2 < this.dynamicProperties.length; ++_i2) { var _property2 = this.dynamicProperties[_i2];
                        this.vao.addAttribute(this.dynamicBuffer, _property2.attribute, gl.FLOAT, false, this.dynamicStride * 4, _property2.offset * 4); }
                    for (var _i3 = 0; _i3 < this.staticProperties.length; ++_i3) { var _property3 = this.staticProperties[_i3];
                        this.vao.addAttribute(this.staticBuffer, _property3.attribute, gl.FLOAT, false, this.staticStride * 4, _property3.offset * 4); }
                };
                ParticleBuffer.prototype.uploadDynamic = function uploadDynamic(children, startIndex, amount) {
                    for (var i = 0; i < this.dynamicProperties.length; i++) { var property = this.dynamicProperties[i];
                        property.uploadFunction(children, startIndex, amount, this.dynamicData, this.dynamicStride, property.offset); }
                    this.dynamicBuffer.upload();
                };
                ParticleBuffer.prototype.uploadStatic = function uploadStatic(children, startIndex, amount) {
                    for (var i = 0; i < this.staticProperties.length; i++) { var property = this.staticProperties[i];
                        property.uploadFunction(children, startIndex, amount, this.staticData, this.staticStride, property.offset); }
                    this.staticBuffer.upload();
                };
                ParticleBuffer.prototype.destroy = function destroy() { this.dynamicProperties = null;
                    this.dynamicData = null;
                    this.dynamicBuffer.destroy();
                    this.staticProperties = null;
                    this.staticData = null;
                    this.staticBuffer.destroy(); };
                return ParticleBuffer;
            }();
            exports.default = ParticleBuffer;
        }, { "../../core/utils/createIndicesForQuads": 120, "pixi-gl-core": 12 }],
        173: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _ParticleShader = require('./ParticleShader');
            var _ParticleShader2 = _interopRequireDefault(_ParticleShader);
            var _ParticleBuffer = require('./ParticleBuffer');
            var _ParticleBuffer2 = _interopRequireDefault(_ParticleBuffer);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var ParticleRenderer = function(_core$ObjectRenderer) {
                _inherits(ParticleRenderer, _core$ObjectRenderer);

                function ParticleRenderer(renderer) { _classCallCheck(this, ParticleRenderer); var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));
                    _this.shader = null;
                    _this.indexBuffer = null;
                    _this.properties = null;
                    _this.tempMatrix = new core.Matrix();
                    _this.CONTEXT_UID = 0; return _this; }
                ParticleRenderer.prototype.onContextChange = function onContextChange() { var gl = this.renderer.gl;
                    this.CONTEXT_UID = this.renderer.CONTEXT_UID;
                    this.shader = new _ParticleShader2.default(gl);
                    this.properties = [{ attribute: this.shader.attributes.aVertexPosition, size: 2, uploadFunction: this.uploadVertices, offset: 0 }, { attribute: this.shader.attributes.aPositionCoord, size: 2, uploadFunction: this.uploadPosition, offset: 0 }, { attribute: this.shader.attributes.aRotation, size: 1, uploadFunction: this.uploadRotation, offset: 0 }, { attribute: this.shader.attributes.aTextureCoord, size: 2, uploadFunction: this.uploadUvs, offset: 0 }, { attribute: this.shader.attributes.aColor, size: 1, uploadFunction: this.uploadAlpha, offset: 0 }]; };
                ParticleRenderer.prototype.start = function start() { this.renderer.bindShader(this.shader); };
                ParticleRenderer.prototype.render = function render(container) {
                    var children = container.children;
                    var maxSize = container._maxSize;
                    var batchSize = container._batchSize;
                    var renderer = this.renderer;
                    var totalChildren = children.length;
                    if (totalChildren === 0) { return; } else if (totalChildren > maxSize) { totalChildren = maxSize; }
                    var buffers = container._glBuffers[renderer.CONTEXT_UID];
                    if (!buffers) { buffers = container._glBuffers[renderer.CONTEXT_UID] = this.generateBuffers(container); }
                    this.renderer.setBlendMode(container.blendMode);
                    var gl = renderer.gl;
                    var m = container.worldTransform.copy(this.tempMatrix);
                    m.prepend(renderer._activeRenderTarget.projectionMatrix);
                    this.shader.uniforms.projectionMatrix = m.toArray(true);
                    this.shader.uniforms.uAlpha = container.worldAlpha;
                    var baseTexture = children[0]._texture.baseTexture;
                    this.shader.uniforms.uSampler = renderer.bindTexture(baseTexture);
                    for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
                        var amount = totalChildren - i;
                        if (amount > batchSize) { amount = batchSize; }
                        var buffer = buffers[j];
                        buffer.uploadDynamic(children, i, amount);
                        if (container._bufferToUpdate === j) { buffer.uploadStatic(children, i, amount);
                            container._bufferToUpdate = j + 1; }
                        renderer.bindVao(buffer.vao);
                        buffer.vao.draw(gl.TRIANGLES, amount * 6);
                    }
                };
                ParticleRenderer.prototype.generateBuffers = function generateBuffers(container) {
                    var gl = this.renderer.gl;
                    var buffers = [];
                    var size = container._maxSize;
                    var batchSize = container._batchSize;
                    var dynamicPropertyFlags = container._properties;
                    for (var i = 0; i < size; i += batchSize) { buffers.push(new _ParticleBuffer2.default(gl, this.properties, dynamicPropertyFlags, batchSize)); }
                    return buffers;
                };
                ParticleRenderer.prototype.uploadVertices = function uploadVertices(children, startIndex, amount, array, stride, offset) {
                    var w0 = 0;
                    var w1 = 0;
                    var h0 = 0;
                    var h1 = 0;
                    for (var i = 0; i < amount; ++i) {
                        var sprite = children[startIndex + i];
                        var texture = sprite._texture;
                        var sx = sprite.scale.x;
                        var sy = sprite.scale.y;
                        var trim = texture.trim;
                        var orig = texture.orig;
                        if (trim) { w1 = trim.x - sprite.anchor.x * orig.width;
                            w0 = w1 + trim.width;
                            h1 = trim.y - sprite.anchor.y * orig.height;
                            h0 = h1 + trim.height; } else { w0 = orig.width * (1 - sprite.anchor.x);
                            w1 = orig.width * -sprite.anchor.x;
                            h0 = orig.height * (1 - sprite.anchor.y);
                            h1 = orig.height * -sprite.anchor.y; }
                        array[offset] = w1 * sx;
                        array[offset + 1] = h1 * sy;
                        array[offset + stride] = w0 * sx;
                        array[offset + stride + 1] = h1 * sy;
                        array[offset + stride * 2] = w0 * sx;
                        array[offset + stride * 2 + 1] = h0 * sy;
                        array[offset + stride * 3] = w1 * sx;
                        array[offset + stride * 3 + 1] = h0 * sy;
                        offset += stride * 4;
                    }
                };
                ParticleRenderer.prototype.uploadPosition = function uploadPosition(children, startIndex, amount, array, stride, offset) { for (var i = 0; i < amount; i++) { var spritePosition = children[startIndex + i].position;
                        array[offset] = spritePosition.x;
                        array[offset + 1] = spritePosition.y;
                        array[offset + stride] = spritePosition.x;
                        array[offset + stride + 1] = spritePosition.y;
                        array[offset + stride * 2] = spritePosition.x;
                        array[offset + stride * 2 + 1] = spritePosition.y;
                        array[offset + stride * 3] = spritePosition.x;
                        array[offset + stride * 3 + 1] = spritePosition.y;
                        offset += stride * 4; } };
                ParticleRenderer.prototype.uploadRotation = function uploadRotation(children, startIndex, amount, array, stride, offset) { for (var i = 0; i < amount; i++) { var spriteRotation = children[startIndex + i].rotation;
                        array[offset] = spriteRotation;
                        array[offset + stride] = spriteRotation;
                        array[offset + stride * 2] = spriteRotation;
                        array[offset + stride * 3] = spriteRotation;
                        offset += stride * 4; } };
                ParticleRenderer.prototype.uploadUvs = function uploadUvs(children, startIndex, amount, array, stride, offset) { for (var i = 0; i < amount; ++i) { var textureUvs = children[startIndex + i]._texture._uvs; if (textureUvs) { array[offset] = textureUvs.x0;
                            array[offset + 1] = textureUvs.y0;
                            array[offset + stride] = textureUvs.x1;
                            array[offset + stride + 1] = textureUvs.y1;
                            array[offset + stride * 2] = textureUvs.x2;
                            array[offset + stride * 2 + 1] = textureUvs.y2;
                            array[offset + stride * 3] = textureUvs.x3;
                            array[offset + stride * 3 + 1] = textureUvs.y3;
                            offset += stride * 4; } else { array[offset] = 0;
                            array[offset + 1] = 0;
                            array[offset + stride] = 0;
                            array[offset + stride + 1] = 0;
                            array[offset + stride * 2] = 0;
                            array[offset + stride * 2 + 1] = 0;
                            array[offset + stride * 3] = 0;
                            array[offset + stride * 3 + 1] = 0;
                            offset += stride * 4; } } };
                ParticleRenderer.prototype.uploadAlpha = function uploadAlpha(children, startIndex, amount, array, stride, offset) { for (var i = 0; i < amount; i++) { var spriteAlpha = children[startIndex + i].alpha;
                        array[offset] = spriteAlpha;
                        array[offset + stride] = spriteAlpha;
                        array[offset + stride * 2] = spriteAlpha;
                        array[offset + stride * 3] = spriteAlpha;
                        offset += stride * 4; } };
                ParticleRenderer.prototype.destroy = function destroy() {
                    if (this.renderer.gl) { this.renderer.gl.deleteBuffer(this.indexBuffer); }
                    _core$ObjectRenderer.prototype.destroy.call(this);
                    this.shader.destroy();
                    this.indices = null;
                    this.tempMatrix = null;
                };
                return ParticleRenderer;
            }(core.ObjectRenderer);
            exports.default = ParticleRenderer;
            core.WebGLRenderer.registerPlugin('particle', ParticleRenderer);
        }, { "../../core": 63, "./ParticleBuffer": 172, "./ParticleShader": 174 }],
        174: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _Shader2 = require('../../core/Shader');
            var _Shader3 = _interopRequireDefault(_Shader2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var ParticleShader = function(_Shader) {
                _inherits(ParticleShader, _Shader);

                function ParticleShader(gl) { _classCallCheck(this, ParticleShader); return _possibleConstructorReturn(this, _Shader.call(this, gl, ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'attribute float aColor;', 'attribute vec2 aPositionCoord;', 'attribute vec2 aScale;', 'attribute float aRotation;', 'uniform mat3 projectionMatrix;', 'varying vec2 vTextureCoord;', 'varying float vColor;', 'void main(void){', '   vec2 v = aVertexPosition;', '   v.x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);', '   v.y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);', '   v = v + aPositionCoord;', '   gl_Position = vec4((projectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);', '   vTextureCoord = aTextureCoord;', '   vColor = aColor;', '}'].join('\n'), ['varying vec2 vTextureCoord;', 'varying float vColor;', 'uniform sampler2D uSampler;', 'uniform float uAlpha;', 'void main(void){', '  vec4 color = texture2D(uSampler, vTextureCoord) * vColor * uAlpha;', '  if (color.a == 0.0) discard;', '  gl_FragColor = color;', '}'].join('\n'))); }
                return ParticleShader;
            }(_Shader3.default);
            exports.default = ParticleShader;
        }, { "../../core/Shader": 42 }],
        175: [function(require, module, exports) {
            "use strict";
            if (!Math.sign) {
                Math.sign = function mathSign(x) {
                    x = Number(x);
                    if (x === 0 || isNaN(x)) { return x; }
                    return x > 0 ? 1 : -1;
                };
            }
        }, {}],
        176: [function(require, module, exports) {
            'use strict';
            var _objectAssign = require('object-assign');
            var _objectAssign2 = _interopRequireDefault(_objectAssign);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
            if (!Object.assign) { Object.assign = _objectAssign2.default; }
        }, { "object-assign": 5 }],
        177: [function(require, module, exports) {
            'use strict';
            require('./Object.assign');
            require('./requestAnimationFrame');
            require('./Math.sign');
            if (!window.ArrayBuffer) { window.ArrayBuffer = Array; }
            if (!window.Float32Array) { window.Float32Array = Array; }
            if (!window.Uint32Array) { window.Uint32Array = Array; }
            if (!window.Uint16Array) { window.Uint16Array = Array; }
        }, { "./Math.sign": 175, "./Object.assign": 176, "./requestAnimationFrame": 178 }],
        178: [function(require, module, exports) {
            (function(global) {
                'use strict';
                var ONE_FRAME_TIME = 16;
                if (!(Date.now && Date.prototype.getTime)) { Date.now = function now() { return new Date().getTime(); }; }
                if (!(global.performance && global.performance.now)) {
                    (function() {
                        var startTime = Date.now();
                        if (!global.performance) { global.performance = {}; }
                        global.performance.now = function() { return Date.now() - startTime; };
                    })();
                }
                var lastTime = Date.now();
                var vendors = ['ms', 'moz', 'webkit', 'o'];
                for (var x = 0; x < vendors.length && !global.requestAnimationFrame; ++x) { var p = vendors[x];
                    global.requestAnimationFrame = global[p + 'RequestAnimationFrame'];
                    global.cancelAnimationFrame = global[p + 'CancelAnimationFrame'] || global[p + 'CancelRequestAnimationFrame']; }
                if (!global.requestAnimationFrame) {
                    global.requestAnimationFrame = function(callback) {
                        if (typeof callback !== 'function') { throw new TypeError(callback + 'is not a function'); }
                        var currentTime = Date.now();
                        var delay = ONE_FRAME_TIME + lastTime - currentTime;
                        if (delay < 0) { delay = 0; }
                        lastTime = currentTime;
                        return setTimeout(function() { lastTime = Date.now();
                            callback(performance.now()); }, delay);
                    };
                }
                if (!global.cancelAnimationFrame) { global.cancelAnimationFrame = function(id) { return clearTimeout(id); }; }
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, {}],
        179: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../core');
            var core = _interopRequireWildcard(_core);
            var _CountLimiter = require('./limiters/CountLimiter');
            var _CountLimiter2 = _interopRequireDefault(_CountLimiter);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var SharedTicker = core.ticker.shared;
            core.settings.UPLOADS_PER_FRAME = 4;
            var BasePrepare = function() {
                function BasePrepare(renderer) {
                    var _this = this;
                    _classCallCheck(this, BasePrepare);
                    this.limiter = new _CountLimiter2.default(core.settings.UPLOADS_PER_FRAME);
                    this.renderer = renderer;
                    this.uploadHookHelper = null;
                    this.queue = [];
                    this.addHooks = [];
                    this.uploadHooks = [];
                    this.completes = [];
                    this.ticking = false;
                    this.delayedTick = function() {
                        if (!_this.queue) { return; }
                        _this.prepareItems();
                    };
                    this.registerFindHook(findText);
                    this.registerFindHook(findTextStyle);
                    this.registerFindHook(findMultipleBaseTextures);
                    this.registerFindHook(findBaseTexture);
                    this.registerFindHook(findTexture);
                    this.registerUploadHook(drawText);
                    this.registerUploadHook(calculateTextStyle);
                }
                BasePrepare.prototype.upload = function upload(item, done) {
                    if (typeof item === 'function') { done = item;
                        item = null; }
                    if (item) { this.add(item); }
                    if (this.queue.length) {
                        if (done) { this.completes.push(done); }
                        if (!this.ticking) { this.ticking = true;
                            SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY); }
                    } else if (done) { done(); }
                };
                BasePrepare.prototype.tick = function tick() { setTimeout(this.delayedTick, 0); };
                BasePrepare.prototype.prepareItems = function prepareItems() {
                    this.limiter.beginFrame();
                    while (this.queue.length && this.limiter.allowedToUpload()) {
                        var item = this.queue[0];
                        var uploaded = false;
                        if (item && !item._destroyed) { for (var i = 0, len = this.uploadHooks.length; i < len; i++) { if (this.uploadHooks[i](this.uploadHookHelper, item)) { this.queue.shift();
                                    uploaded = true; break; } } }
                        if (!uploaded) { this.queue.shift(); }
                    }
                    if (!this.queue.length) { this.ticking = false; var completes = this.completes.slice(0);
                        this.completes.length = 0; for (var _i = 0, _len = completes.length; _i < _len; _i++) { completes[_i](); } } else { SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY); }
                };
                BasePrepare.prototype.registerFindHook = function registerFindHook(addHook) {
                    if (addHook) { this.addHooks.push(addHook); }
                    return this;
                };
                BasePrepare.prototype.registerUploadHook = function registerUploadHook(uploadHook) {
                    if (uploadHook) { this.uploadHooks.push(uploadHook); }
                    return this;
                };
                BasePrepare.prototype.add = function add(item) {
                    for (var i = 0, len = this.addHooks.length; i < len; i++) { if (this.addHooks[i](item, this.queue)) { break; } }
                    if (item instanceof core.Container) { for (var _i2 = item.children.length - 1; _i2 >= 0; _i2--) { this.add(item.children[_i2]); } }
                    return this;
                };
                BasePrepare.prototype.destroy = function destroy() {
                    if (this.ticking) { SharedTicker.remove(this.tick, this); }
                    this.ticking = false;
                    this.addHooks = null;
                    this.uploadHooks = null;
                    this.renderer = null;
                    this.completes = null;
                    this.queue = null;
                    this.limiter = null;
                    this.uploadHookHelper = null;
                };
                return BasePrepare;
            }();
            exports.default = BasePrepare;

            function findMultipleBaseTextures(item, queue) {
                var result = false;
                if (item && item._textures && item._textures.length) { for (var i = 0; i < item._textures.length; i++) { if (item._textures[i] instanceof core.Texture) { var baseTexture = item._textures[i].baseTexture; if (queue.indexOf(baseTexture) === -1) { queue.push(baseTexture);
                                result = true; } } } }
                return result;
            }

            function findBaseTexture(item, queue) {
                if (item instanceof core.BaseTexture) {
                    if (queue.indexOf(item) === -1) { queue.push(item); }
                    return true;
                }
                return false;
            }

            function findTexture(item, queue) {
                if (item._texture && item._texture instanceof core.Texture) {
                    var texture = item._texture.baseTexture;
                    if (queue.indexOf(texture) === -1) { queue.push(texture); }
                    return true;
                }
                return false;
            }

            function drawText(helper, item) {
                if (item instanceof core.Text) { item.updateText(true); return true; }
                return false;
            }

            function calculateTextStyle(helper, item) {
                if (item instanceof core.TextStyle) {
                    var font = core.Text.getFontStyle(item);
                    if (!core.Text.fontPropertiesCache[font]) { core.Text.calculateFontProperties(font); }
                    return true;
                }
                return false;
            }

            function findText(item, queue) {
                if (item instanceof core.Text) {
                    if (queue.indexOf(item.style) === -1) { queue.push(item.style); }
                    if (queue.indexOf(item) === -1) { queue.push(item); }
                    var texture = item._texture.baseTexture;
                    if (queue.indexOf(texture) === -1) { queue.push(texture); }
                    return true;
                }
                return false;
            }

            function findTextStyle(item, queue) {
                if (item instanceof core.TextStyle) {
                    if (queue.indexOf(item) === -1) { queue.push(item); }
                    return true;
                }
                return false;
            }
        }, { "../core": 63, "./limiters/CountLimiter": 182 }],
        180: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _BasePrepare2 = require('../BasePrepare');
            var _BasePrepare3 = _interopRequireDefault(_BasePrepare2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var CANVAS_START_SIZE = 16;
            var CanvasPrepare = function(_BasePrepare) {
                _inherits(CanvasPrepare, _BasePrepare);

                function CanvasPrepare(renderer) { _classCallCheck(this, CanvasPrepare); var _this = _possibleConstructorReturn(this, _BasePrepare.call(this, renderer));
                    _this.uploadHookHelper = _this;
                    _this.canvas = document.createElement('canvas');
                    _this.canvas.width = CANVAS_START_SIZE;
                    _this.canvas.height = CANVAS_START_SIZE;
                    _this.ctx = _this.canvas.getContext('2d');
                    _this.registerUploadHook(uploadBaseTextures); return _this; }
                CanvasPrepare.prototype.destroy = function destroy() { _BasePrepare.prototype.destroy.call(this);
                    this.ctx = null;
                    this.canvas = null; };
                return CanvasPrepare;
            }(_BasePrepare3.default);
            exports.default = CanvasPrepare;

            function uploadBaseTextures(prepare, item) {
                if (item instanceof core.BaseTexture) { var image = item.source; var imageWidth = image.width === 0 ? prepare.canvas.width : Math.min(prepare.canvas.width, image.width); var imageHeight = image.height === 0 ? prepare.canvas.height : Math.min(prepare.canvas.height, image.height);
                    prepare.ctx.drawImage(image, 0, 0, imageWidth, imageHeight, 0, 0, prepare.canvas.width, prepare.canvas.height); return true; }
                return false;
            }
            core.CanvasRenderer.registerPlugin('prepare', CanvasPrepare);
        }, { "../../core": 63, "../BasePrepare": 179 }],
        181: [function(require, module, exports) { 'use strict';
            exports.__esModule = true; var _WebGLPrepare = require('./webgl/WebGLPrepare');
            Object.defineProperty(exports, 'webgl', { enumerable: true, get: function get() { return _interopRequireDefault(_WebGLPrepare).default; } }); var _CanvasPrepare = require('./canvas/CanvasPrepare');
            Object.defineProperty(exports, 'canvas', { enumerable: true, get: function get() { return _interopRequireDefault(_CanvasPrepare).default; } }); var _BasePrepare = require('./BasePrepare');
            Object.defineProperty(exports, 'BasePrepare', { enumerable: true, get: function get() { return _interopRequireDefault(_BasePrepare).default; } }); var _CountLimiter = require('./limiters/CountLimiter');
            Object.defineProperty(exports, 'CountLimiter', { enumerable: true, get: function get() { return _interopRequireDefault(_CountLimiter).default; } }); var _TimeLimiter = require('./limiters/TimeLimiter');
            Object.defineProperty(exports, 'TimeLimiter', { enumerable: true, get: function get() { return _interopRequireDefault(_TimeLimiter).default; } });

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } }, { "./BasePrepare": 179, "./canvas/CanvasPrepare": 180, "./limiters/CountLimiter": 182, "./limiters/TimeLimiter": 183, "./webgl/WebGLPrepare": 184 }],
        182: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var CountLimiter = function() {
                function CountLimiter(maxItemsPerFrame) { _classCallCheck(this, CountLimiter);
                    this.maxItemsPerFrame = maxItemsPerFrame;
                    this.itemsLeft = 0; }
                CountLimiter.prototype.beginFrame = function beginFrame() { this.itemsLeft = this.maxItemsPerFrame; };
                CountLimiter.prototype.allowedToUpload = function allowedToUpload() { return this.itemsLeft-- > 0; };
                return CountLimiter;
            }();
            exports.default = CountLimiter;
        }, {}],
        183: [function(require, module, exports) {
            "use strict";
            exports.__esModule = true;

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
            var TimeLimiter = function() {
                function TimeLimiter(maxMilliseconds) { _classCallCheck(this, TimeLimiter);
                    this.maxMilliseconds = maxMilliseconds;
                    this.frameStart = 0; }
                TimeLimiter.prototype.beginFrame = function beginFrame() { this.frameStart = Date.now(); };
                TimeLimiter.prototype.allowedToUpload = function allowedToUpload() { return Date.now() - this.frameStart < this.maxMilliseconds; };
                return TimeLimiter;
            }();
            exports.default = TimeLimiter;
        }, {}],
        184: [function(require, module, exports) {
            'use strict';
            exports.__esModule = true;
            var _core = require('../../core');
            var core = _interopRequireWildcard(_core);
            var _BasePrepare2 = require('../BasePrepare');
            var _BasePrepare3 = _interopRequireDefault(_BasePrepare2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
            var WebGLPrepare = function(_BasePrepare) {
                _inherits(WebGLPrepare, _BasePrepare);

                function WebGLPrepare(renderer) { _classCallCheck(this, WebGLPrepare); var _this = _possibleConstructorReturn(this, _BasePrepare.call(this, renderer));
                    _this.uploadHookHelper = _this.renderer;
                    _this.registerFindHook(findGraphics);
                    _this.registerUploadHook(uploadBaseTextures);
                    _this.registerUploadHook(uploadGraphics); return _this; }
                return WebGLPrepare;
            }(_BasePrepare3.default);
            exports.default = WebGLPrepare;

            function uploadBaseTextures(renderer, item) {
                if (item instanceof core.BaseTexture) {
                    if (!item._glTextures[renderer.CONTEXT_UID]) { renderer.textureManager.updateTexture(item); }
                    return true;
                }
                return false;
            }

            function uploadGraphics(renderer, item) {
                if (item instanceof core.Graphics) {
                    if (item.dirty || item.clearDirty || !item._webGL[renderer.plugins.graphics.CONTEXT_UID]) { renderer.plugins.graphics.updateGraphics(item); }
                    return true;
                }
                return false;
            }

            function findGraphics(item, queue) {
                if (item instanceof core.Graphics) { queue.push(item); return true; }
                return false;
            }
            core.WebGLRenderer.registerPlugin('prepare', WebGLPrepare);
        }, { "../../core": 63, "../BasePrepare": 179 }],
        185: [function(require, module, exports) {
            (function(global) {
                'use strict';
                exports.__esModule = true;
                exports.loader = exports.prepare = exports.particles = exports.mesh = exports.loaders = exports.interaction = exports.filters = exports.extras = exports.extract = exports.accessibility = undefined;
                var _polyfill = require('./polyfill');
                Object.keys(_polyfill).forEach(function(key) { if (key === "default" || key === "__esModule") return;
                    Object.defineProperty(exports, key, { enumerable: true, get: function get() { return _polyfill[key]; } }); });
                var _core = require('./core');
                Object.keys(_core).forEach(function(key) { if (key === "default" || key === "__esModule") return;
                    Object.defineProperty(exports, key, { enumerable: true, get: function get() { return _core[key]; } }); });
                var _deprecation = require('./deprecation');
                var _deprecation2 = _interopRequireDefault(_deprecation);
                var _accessibility = require('./accessibility');
                var accessibility = _interopRequireWildcard(_accessibility);
                var _extract = require('./extract');
                var extract = _interopRequireWildcard(_extract);
                var _extras = require('./extras');
                var extras = _interopRequireWildcard(_extras);
                var _filters = require('./filters');
                var filters = _interopRequireWildcard(_filters);
                var _interaction = require('./interaction');
                var interaction = _interopRequireWildcard(_interaction);
                var _loaders = require('./loaders');
                var loaders = _interopRequireWildcard(_loaders);
                var _mesh = require('./mesh');
                var mesh = _interopRequireWildcard(_mesh);
                var _particles = require('./particles');
                var particles = _interopRequireWildcard(_particles);
                var _prepare = require('./prepare');
                var prepare = _interopRequireWildcard(_prepare);

                function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                _core.utils.mixins.performMixins();
                var loader = loaders.shared || null;
                exports.accessibility = accessibility;
                exports.extract = extract;
                exports.extras = extras;
                exports.filters = filters;
                exports.interaction = interaction;
                exports.loaders = loaders;
                exports.mesh = mesh;
                exports.particles = particles;
                exports.prepare = prepare;
                exports.loader = loader;
                if (typeof _deprecation2.default === 'function') {
                    (0, _deprecation2.default)(exports); }
                global.PIXI = exports;
            }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
        }, { "./accessibility": 40, "./core": 63, "./deprecation": 127, "./extract": 129, "./extras": 138, "./filters": 149, "./interaction": 156, "./loaders": 159, "./mesh": 168, "./particles": 171, "./polyfill": 177, "./prepare": 181 }]
    }, {}, [185])(185)
});
(function() {
    'use strict';
    var SETTINGS_SELECTOR = 'script[type="application/vnd.nebula-settings+json"]';
    var winAPI;
    var modules = {};
    var constructors = {};
    var namePattern = /^[a-z0-9_]+(?:\/[a-z0-9_]+)*$/;
    var codeSettingsDefined = false;
    var oldRequire = window.nw ? window.nw.require : window.require;

    function format(template, moduleName) { return template.replace(/{module}/g, moduleName); }

    function exception(parentClass, name, template) {
        function Exception(arg) { this.message = template ? format(template, arg) : arg; }
        Exception.prototype = Object.create(parentClass.prototype);
        Exception.prototype.name = name;
        Exception.prototype.constructor = Exception;
        return Exception;
    }
    var DefineError = exception(TypeError, 'define.Error');
    var DefineArgumentCountError = exception(DefineError, 'define.ArgumentCountError');
    var DefineInvalidModuleNameError = exception(DefineError, 'define.InvalidModuleNameError', "module name '{module}' is invalid, allowed characters: a-z, 0-9, _ and /");
    var DefineInvalidModuleError = exception(DefineError, 'define.InvalidModuleError', "module '{module}' doesn't export any definitions");
    var DefineDuplicateModuleError = exception(DefineError, 'define.DuplicateModuleError', "module '{module}' is already defined");
    var RequireError = exception(TypeError, 'require.Error', "no module named '{module}'");
    var RequireArgumentsError = exception(RequireError, 'require.ArgumentsError');

    function instantiate(Constructor, dependencies) { return new(Function.prototype.bind.apply(Constructor, [{}].concat(dependencies))); }

    function exists(path) { var parts = path.split('.'),
            name = parts[0],
            member = parts[1],
            module = modules[name]; return module && (typeof member === 'undefined' || member in module); }

    function require(path, overrides) {
        if (arguments.length < 1 || arguments.length > 2 || typeof path !== 'string')
            throw new RequireArgumentsError('`require()` accepts only one or two arguments');
        var parts = path.split('.'),
            name = parts[0],
            module;
        if (overrides) {
            if (!(path in constructors))
                throw new RequireError(path);
            var dependencies = [];
            for (var i = 0; i < constructors[path].dependencies.length; i++) { var depPath = constructors[path].dependencies[i];
                dependencies.push(depPath in overrides ? overrides[depPath] : require(depPath)); }
            module = instantiate(constructors[path].constructor, dependencies);
        } else
            module = modules[name];
        if (module) {
            if (parts.length === 1)
                return module;
            for (var i = 1; i < parts.length; i++)
                if (parts[i] in module) {
                    module = module[parts[i]];
                    if (i === parts.length - 1)
                        return module;
                } else
                    break;
        }
        if (oldRequire)
            return oldRequire(path);
        else
            throw new RequireError(path);
    }

    function optionally(path, overrides) {
        try { return require(path, overrides); } catch (exception) {
            if (!(exception instanceof RequireError || exception.code === 'MODULE_NOT_FOUND'))
                throw exception;
        }
        return null;
    }

    function define(moduleName) {
        var dependencies = [],
            moduleCode;
        if (arguments.length < 2 || arguments.length > 3)
            throw new DefineArgumentCountError('`define()` accepts only two or three arguments');
        if (typeof moduleName !== 'string')
            throw new DefineInvalidModuleNameError(moduleName);
        if (!namePattern.test(moduleName)) {
            var settings = require('settings');
            var ALIASES = settings('ALIASES', {});
            if (moduleName in ALIASES) { var callArgs = [ALIASES[moduleName]].concat(Array.prototype.slice.call(arguments, 1)); return define.apply(undefined, callArgs); }
            throw new DefineInvalidModuleNameError(moduleName);
        }
        if ((moduleName in modules && moduleName !== 'settings') || (codeSettingsDefined && moduleName === 'settings'))
            throw new DefineDuplicateModuleError(moduleName);
        moduleCode = arguments[arguments.length - 1];
        if (arguments.length === 3) {
            if (typeof moduleCode !== 'function')
                throw new DefineError('redundant dependecies specified when module is not a function');
            dependencies = arguments[1];
        }
        if (typeof moduleCode === 'function') {
            constructors[moduleName] = { 'constructor': moduleCode, 'dependencies': dependencies };
            var args = [];
            for (var i = 0; i < dependencies.length; i++)
                args.push(require(dependencies[i]));
            moduleCode = instantiate(moduleCode, args);
        }
        if (arguments.length < 2 || typeof moduleCode === 'undefined')
            throw new DefineInvalidModuleError(moduleName);
        if (moduleName === 'settings') {
            codeSettingsDefined = true;
            for (var name in moduleCode)
                if (!(name in modules._settings))
                    modules._settings[name] = moduleCode[name];
        } else
            modules[moduleName] = moduleCode;
        if (modules.settings('DEBUG')) {
            window.nebula = window.nebula || {};
            var path = moduleName.split('/');
            var node = window.nebula;
            for (var i = 0; i < path.length; i++)
                if (!(i === 0 && path[i] === 'nebula')) {
                    var isLast = (i === path.length - 1);
                    if (!node[path[i]])
                        node[path[i]] = {};
                    if (isLast)
                        node[path[i]] = moduleCode;
                    else
                        node = node[path[i]];
                }
        }
    }

    function functionName(func) { var pattern = /^\s*function\s+([^\s\(]+).*/i; var body = String(func); var match = pattern.exec(body); return match.length === 2 ? match[1] : null; }

    function functions() {
        var map = {},
            name;
        for (var i = 0; i < arguments.length; i++) {
            if (typeof arguments[i] !== 'function')
                throw new TypeError('argument ' + (i + 1) + ' is not a function');
            name = functionName(arguments[i]);
            if (name === null)
                throw new Error("couldn't get function name for argument " + (i + 1));
            map[name] = arguments[i];
        }
        return map;
    }

    function getSetting(name, fallback) {
        if (arguments.length < 1 || arguments.length > 2)
            throw new TypeError('settings getter accepts only one or two arguments');
        var value = modules._settings[name];
        return typeof value !== 'undefined' ? value : fallback;
    }

    function getHTMLSettings(initial) {
        initial = initial || {};
        var tags = winAPI.document.querySelectorAll(SETTINGS_SELECTOR);
        if (tags.length > 1)
            throw new DefineError('multiple settings defined in HTML, only one `<script>` tag with settings is allowed');
        if (tags.length) {
            try { var settings = winAPI.JSON.parse(tags[0].innerHTML); } catch (e) {
                if (e instanceof SyntaxError)
                    throw new DefineError('invalid syntax in the HTML settings: ' + e.message);
                throw e;
            }
            for (var name in settings)
                initial[name] = settings[name];
        }
        return initial;
    }

    function init(_modules, _constructors, _winAPI) { var old = modules;
        winAPI = _winAPI || window;
        codeSettingsDefined = false;
        define._constructors = constructors = _constructors || {};
        define._modules = modules = _modules || { 'settings': getSetting, '_settings': {} };
        modules._settings = getHTMLSettings(); return old; }
    require.Error = RequireError;
    require.ArgumentsError = RequireArgumentsError;
    require.exists = exists;
    require.optionally = optionally;
    define.Error = DefineError;
    define.ArgumentCountError = DefineArgumentCountError;
    define.InvalidModuleNameError = DefineInvalidModuleNameError;
    define.InvalidModuleError = DefineInvalidModuleError;
    define.DuplicateModuleError = DefineDuplicateModuleError;
    define.functions = functions;
    define._init = init;
    define._modules = modules;
    define._constructors = constructors;
    window.define = define;
    window.require = require;
    init(null, null, window);
})();
define('nebula/window', function() { 'use strict'; return window; });
define('nebula/signal', function() {
    'use strict';

    function connect() {
        var kwargs = typeof arguments[0] === 'function' ? { 'receiver': arguments[0], 'context': arguments[1] } : arguments[0];
        if (typeof kwargs.receiver !== 'function')
            throw new Error("Can't connect receiver to a signal, receiver is not a function");
        for (var i = 0; i < this.receivers.length; i++)
            if (this.receivers[i].receiver === kwargs.receiver && this.receivers[i].context == kwargs.context && this.receivers[i].sender == kwargs.sender)
                throw new Error("Can't connect receiver to a signal, this receiver with same context and same sender is already connected");
        this.receivers.push({ 'callback': kwargs.context ? kwargs.receiver.bind(kwargs.context) : kwargs.receiver, 'receiver': kwargs.receiver, 'sender': kwargs.sender, 'context': kwargs.context, 'once': kwargs.once });
    }

    function once() { var kwargs = typeof arguments[0] === 'function' ? { 'receiver': arguments[0], 'context': arguments[1] } : arguments[0];
        kwargs.once = true; return connect.call(this, kwargs); }

    function disconnect(receiver, context) {
        var kwargs = typeof receiver === 'function' ? { 'receiver': receiver, 'context': context } : receiver;
        if (typeof kwargs.receiver !== 'function')
            throw new Error("Can't disconnect receiver from a signal, receiver is not a function");
        if (this.sending)
            this._toDisconnect.push(kwargs);
        else
            for (var i = 0; i < this.receivers.length; i++) { var entry = this.receivers[i]; if (entry.receiver === kwargs.receiver && entry.context === kwargs.context && entry.sender === kwargs.sender) { this.receivers.splice(i, 1); return; } }
    }

    function send(sender, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        this.sending = true;
        for (var i = 0; i < this.receivers.length; i++) { var entry = this.receivers[i]; if (typeof entry.sender === 'undefined' || entry.sender === sender) { entry.callback(sender, a1, a2, a3, a4, a5, a6, a7, a8); if (entry.once) { this.receivers.splice(i, 1);
                    i -= 1; } } }
        this.sending = false;
        if (this._toDisconnect.length) {
            for (var i = 0; i < this._toDisconnect.length; i++)
                this.disconnect(this._toDisconnect[i]);
            this._toDisconnect = [];
        }
    }

    function Signal() {
        function signal() { connect.apply(signal, arguments); }
        signal.sending = false;
        signal.receivers = [];
        signal._toDisconnect = [];
        signal.connect = connect.bind(signal);
        signal.once = once.bind(signal);
        signal.disconnect = disconnect.bind(signal);
        signal.send = send.bind(signal);
        return signal;
    }
    return Signal;
});
define('nebula/numbers', function() {
    'use strict';

    function sum() {
        var total = 0;
        for (var i = 0, j = arguments.length; i < j; i++)
            total += arguments[i];
        return total;
    }

    function multiply() {
        var total = 0;
        for (var i = 0, j = arguments.length; i < j; i++)
            total *= arguments[i];
        return total;
    }

    function fract(n) { return n - Math.trunc(n); }

    function mod(n, m) { return ((n % m) + m) % m; }

    function clamp(value, min, max) {
        if (value < min)
            return min;
        else if (value > max)
            return max;
        else
            return value;
    }

    function suppress(value, suppressor) {
        var s = Math.abs(suppressor);
        if (suppressor !== s)
            throw new Error('Suppressor must be positive');
        return Math.sign(value) * Math.max(0, Math.abs(value) - s);
    }

    function interpolate(min, max, alpha) { return min * (1 - alpha) + max * alpha; }

    function step(edge, n) { return n < edge ? 0 : 1; }

    function smoothStep(minEdge, maxEdge, n) { var t = this.clamp((n - minEdge) / (maxEdge - minEdge), 0, 1); return t * t * (3 - 2 * t); }

    function scale(n, currentMin, currentMax, newMin, newMax) { return newMin + (n - currentMin) * (newMax - newMin) / (currentMax - currentMin); }

    function range(start, stop, step) {
        if (arguments.length < 2) { stop = start;
            start = 0; }
        if (arguments.length < 3)
            step = start > stop ? -1 : 1;
        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = new Array(length);
        while (idx < length) { range[idx++] = start;
            start += step; }
        return range;
    }

    function toFixed(num, precision) { return (+(Math.round(+(num + 'e' + precision)) + 'e' + -precision)).toFixed(precision); }

    function format(number, decimalPlaces, decimalSeparator, thousandsSeparator) {
        if (isNaN(number) || number == null)
            return '';
        if (arguments.length < 4)
            thousandsSeparator = ',';
        if (arguments.length < 3)
            decimalSeparator = '.';
        if (arguments.length < 2)
            decimalPlaces = 2;
        number = toFixed(number, decimalPlaces);
        var parts = number.split('.');
        var fnums = parts[0];
        var decimals = parts[1] ? decimalSeparator + parts[1] : '';
        return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, '$1' + thousandsSeparator) + decimals;
    }
    try { var swig = require('swig');
        format.safe = true;
        swig.setFilter('numberFormat', format); } catch (e) {}

    function distance(x1, y1, x2, y2) { var dx = x1 - x2,
            dy = y1 - y2; return Math.sqrt(dx * dx + dy * dy); }

    function length(x, y) { return Math.sqrt(x * x + y * y); }

    function radians(angle) { return angle * Math.PI / 180; }

    function degrees(angle) { return angle * 180 / Math.PI; }

    function isPowerOfTwo(n) {
        if (n <= 0 || (n !== 2147483648 && n !== ~~n))
            return false;
        return !(n & (n - 1));
    }

    function nextPowerOfTwo(n) {
        if (n < 1)
            return 1;
        if (this.isPowerOfTwo(n))
            return n;
        n -= 1;
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;
        return n + 1;
    }

    function popCount(x) { var a = x - ((x >> 1) & 0x55555555); var b = ((a >> 2) & 0x33333333) + (a & 0x33333333); var c = ((b >> 4) + b) & 0x0f0f0f0f; var d = c + (c >> 8); return (d + (d >> 16)) & 0x0000003f; }

    function log2(x) { var a = x | (x >> 1); var b = a | (a >> 2); var c = b | (b >> 4); var d = c | (c >> 8); return popCount((d | (d >> 16)) >> 1); }

    function bits(min, max) { return log2(max - min) + 1; }
    return { 'sum': sum, 'multiply': multiply, 'fract': fract, 'mod': mod, 'clamp': clamp, 'suppress': suppress, 'interpolate': interpolate, 'step': step, 'smoothStep': smoothStep, 'scale': scale, 'range': range, 'format': format, 'distance': distance, 'length': length, 'radians': radians, 'degrees': degrees, 'isPowerOfTwo': isPowerOfTwo, 'nextPowerOfTwo': nextPowerOfTwo, 'bits': bits };
});
define('nebula/easings', function() {
    'use strict';
    var numbers = require('nebula/numbers');

    function mirror(p) { return 1 - 2 * Math.abs(p - 0.5); }

    function linear(p) { return p; }
    var quadratic = {
        'in': function(p) { return p * p; },
        'out': function(p) { return p * (2 - p); },
        'inOut': function(p) {
            if (p < 0.5)
                return 2 * p * p;
            else
                return -2 * p * p + 4 * p - 1;
        }
    };
    var cubic = {
        'in': function(p) { return p * p * p; },
        'out': function(p) { var f = p - 1; return f * f * f + 1; },
        'inOut': function(p) {
            if (p < 0.5)
                return 4 * p * p * p;
            else { var f = 2 * p - 2; return 0.5 * f * f * f + 1; }
        }
    };
    var quartic = {
        'in': function(p) { return p * p * p * p; },
        'out': function(p) { var f = p - 1; return f * f * f * (1 - p) + 1; },
        'inOut': function(p) {
            if (p < 0.5)
                return 8 * p * p * p * p;
            else { var f = p - 1; return -8 * f * f * f * f + 1; }
        }
    };
    var quintic = {
        'in': function(p) { return p * p * p * p * p; },
        'out': function(p) { var f = p - 1; return f * f * f * f * f + 1; },
        'inOut': function(p) {
            if (p < 0.5)
                return 16 * p * p * p * p * p;
            else { var f = 2 * p - 2; return 0.5 * f * f * f * f * f + 1; }
        }
    };
    var sine = { 'in': function(p) { return Math.sin((p - 1) * Math.PI / 2) + 1; }, 'out': function(p) { return Math.sin(p * Math.PI / 2); }, 'inOut': function(p) { return 0.5 * (1 - Math.cos(p * Math.PI)); } };
    var circular = {
        'in': function(p) { return 1 - Math.sqrt(1 - p * p); },
        'out': function(p) { return Math.sqrt((2 - p) * p); },
        'inOut': function(p) {
            if (p < 0.5)
                return 0.5 * (1 - Math.sqrt(1 - 4 * p * p));
            else
                return 0.5 * (Math.sqrt(-(2 * p - 3) * (2 * p - 1)) + 1);
        }
    };
    var exponential = {
        'in': function(p) { return (p == 0) ? p : Math.pow(2, 10 * (p - 1)); },
        'out': function(p) { return (p == 1) ? p : 1 - Math.pow(2, -10 * p); },
        'inOut': function(p) {
            if (p == 0.0 || p == 1.0)
                return p;
            if (p < 0.5)
                return 0.5 * Math.pow(2, 20 * p - 10);
            else
                return -0.5 * Math.pow(2, -20 * p + 10) + 1;
        }
    };
    var elastic = {
        'in': function(p) { return Math.sin(13 * Math.PI / 2 * p) * Math.pow(2, 10 * (p - 1)); },
        'out': function(p) { return Math.sin(-13 * Math.PI / 2 * (p + 1)) * Math.pow(2, -10 * p) + 1; },
        'inOut': function(p) {
            if (p < 0.5)
                return 0.5 * Math.sin(13 * Math.PI / 2 * 2 * p) * Math.pow(2, 10 * (2 * p - 1));
            else
                return 0.5 * (Math.sin(-13 * Math.PI / 2 * ((2 * p - 1) + 1)) * Math.pow(2, -10 * (2 * p - 1)) + 2);
        }
    };
    var back = { 'in': function(p) { return p * p * p - p * Math.sin(p * Math.PI); }, 'out': function(p) { var f = 1 - p; return 1 - (f * f * f - f * Math.sin(f * Math.PI)); }, 'inOut': function(p) { if (p < 0.5) { var f = 2 * p; return 0.5 * (f * f * f - f * Math.sin(f * Math.PI)); } else { var f = 1 - (2 * p - 1); return 0.5 * (1 - (f * f * f - f * Math.sin(f * Math.PI))) + 0.5; } } };
    var bounce = {
        'in': function(p) { return 1 - bounce.out(1 - p); },
        'out': function(p) {
            if (p < 4 / 11)
                return (121 * p * p) / 16;
            else if (p < 8 / 11)
                return 363 / 40 * p * p - 99 / 10 * p + 17 / 5;
            else if (p < 9 / 10)
                return 4356 / 361 * p * p - 35442 / 1805 * p + 16061 / 1805;
            else
                return 54 / 5 * p * p - 513 / 25 * p + 268 / 25;
        },
        'inOut': function(p) {
            if (p < 0.5)
                return 0.5 * bounce.in(p * 2);
            else
                return 0.5 * bounce.out(p * 2 - 1) + 0.5;
        }
    };

    function cubicBezier(x1, y1, x2, y2) {
        if (arguments.length !== 4)
            throw new Error('`cubicBezier()` requires 4 arguments.');
        for (var i = 0; i < 4; ++i)
            if (typeof arguments[i] !== 'number' || isNaN(arguments[i]) || !isFinite(arguments[i]))
                throw new Error('`cubicBezier()` arguments must be numbers.');
        if (x1 < 0 || x1 > 1 || x2 < 0 || x2 > 1)
            throw new Error('`cubicBezier()` x values must be in [0, 1] range.');
        if (x1 === y1 && x2 === y2)
            return linear;

        function calcBezier(t, a1, a2) { return (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t; }

        function slope(t, a1, a2) { return (3 - 9 * a2 + 9 * a1) * t * t + (6 * a2 - 12 * a1) * t + 3 * a1; }

        function getTForX(x) {
            var t = x;
            for (var i = 0; i < 8; ++i) {
                var currentSlope = slope(t, x1, x2);
                if (currentSlope === 0)
                    return t;
                var currentX = calcBezier(t, x1, x2) - x;
                t -= currentX / currentSlope;
            }
            return t;
        }

        function f(x) { return calcBezier(getTForX(x), y1, y2); }
        f.toString = function() { return '[cubicBezier ' + [x1, y1, x2, y2] + ']'; };
        return f;
    }

    function merge(f1, f2, f1Percentage) { return function(p) { return p < f1Percentage ? f1(numbers.scale(p, 0, f1Percentage, 0, 1)) : f2(numbers.scale(p, f1Percentage, 1, 0, 1)); }; }

    function flipX(f) { return function(p) { return f(1 - p); }; }

    function flipY(f) { return function(p) { return 1 - f(p); }; }

    function scale(f, newMin, newMax) {
        return function(p) {
            if (p < newMin)
                return f(0);
            if (p > newMax)
                return f(1);
            return f(numbers.scale(p, newMin, newMax, 0, 1));
        }
    }

    function render(easing) {
        var padding = 30;
        var canvas = document.createElement('canvas');
        canvas.width = 400;
        canvas.height = 400;
        var ctx = canvas.getContext('2d');
        var width = (canvas.width - 2 * padding);
        var height = (canvas.height - 2 * padding);
        ctx.strokeStyle = '#cccccc';
        ctx.strokeRect(padding, padding, width, height);
        ctx.strokeStyle = '#000000';
        ctx.beginPath();
        ctx.moveTo(padding, padding + (1 - easing(0)) * height);
        for (var i = 1; i <= 1000; i++) { var p = i / 1000;
            ctx.lineTo(padding + p * width, padding + (1 - easing(p)) * height); }
        ctx.stroke();
        window.open(canvas.toDataURL());
    }
    return { 'mirror': mirror, 'linear': linear, 'quadratic': quadratic, 'cubic': cubic, 'quartic': quartic, 'quintic': quintic, 'sine': sine, 'circular': circular, 'exponential': exponential, 'elastic': elastic, 'back': back, 'bounce': bounce, 'cubicBezier': cubicBezier, 'flipX': flipX, 'flipY': flipY, 'scale': scale, 'merge': merge, 'render': render };
});
define('nebula/format', function() {
    'use strict';

    function _int(n) { return parseInt(n, 10); }

    function _float(n) { return parseFloat(n); }

    function _has(s, c) { return !!s && s.indexOf(c) !== -1; }

    function getType(o) {
        var t = typeof o;
        if (t === 'object') {
            if (o.callee)
                return 'array';
            t = /^\[object\s(.+?)\]$/.test(Object.prototype.toString.call(o)) && RegExp.$1.toLowerCase();
        }
        return t;
    }

    function getPadding(val, wid, chr) { val = val + ''; var d = Math.abs(wid) - val.length; return (d > 0) ? Array(d + 1).join(chr || ' ') : ''; }

    function pad(str, wid, p) { p = (wid != null) ? getPadding(str, wid, p) : ''; return (wid < 0) ? str + p : p + str; }

    function repr(v) {
        var r = [],
            i = 0;
        switch (getType(v)) {
            case 'array':
                for (; i < v.length; i++)
                    r.push(repr(v[i]));
                return '[' + r.join(', ') + ']';
            case 'object':
                var l = [];
                for (i in v)
                    l.push(i);
                l.sort();
                for (i = 0; i < l.length; i++)
                    r.push("'" + l[i] + "': " + repr(v[l[i]]));
                return '{' + r.join(', ') + '}';
            case 'string':
                return "'" + v.replace(/'/g, "\\'") + "'";
            case 'function':
                return '(' + m.toSource() + ')';
        }
        return String(v);
    }

    function sign(n, force, space) { return n < 0 && '-' || force && '+' || space && ' ' || ''; }
    var convert = {
        'd': function(v, o) { var i = _int(v); var n = Math.abs(i); var s = sign(i, o.sign, o.space); var w = o.pad == '0' ? Math.max(!!o.precision, (o.minwidth || 0) - s.length) : o.precision; return pad(s + getPadding(n, w, '0') + n, o.minwidth, o.pad); },
        'o': function(v, o) {
            var i = _int(v);
            var n = Math.abs(i).toString(8);
            var s = sign(i, o.sign, o.space);
            var a = o.alt ? '0' : '';
            var w = o.pad == '0' ? Math.max(!!o.precision, (o.minwidth || 0) - s.length - a.length) : o.precision;
            var p = getPadding(n, w, '0');
            if (p.charAt(0) === '0' || n.charAt(0) === '0')
                a = '';
            return pad(s + a + p + n, o.minwidth, o.pad);
        },
        'x': function(v, o) { var i = _int(v); var n = Math.abs(i).toString(16); var s = sign(i, o.sign, o.space); var a = o.alt ? '0x' : ''; var w = o.pad == '0' ? Math.max(!!o.precision, (o.minwidth || 0) - s.length - a.length) : o.precision; return pad(s + a + getPadding(n, w, '0') + n, o.minwidth, o.pad); },
        'e': function(v, o) { var i = _float(v); var p = o.precision == null ? 6 : o.precision; var n = Math.abs(i).toExponential(p).split('e+'); var s = sign(i, o.sign, o.space);
            n = n[0] + (!p && o.alt && '.' || '') + 'e+' + pad(n[1], 2, '0'); return s + pad(n, o.minwidth - s.length, o.pad); },
        'f': function(v, o) {
            var i = _float(v);
            var p = o.precision == null ? 6 : Math.min(Math.abs(o.precision), 50);
            if (v > 1e+25)
                return convert.g(v, o);
            var n = Math.abs(i).toFixed(p);
            var s = sign(i, o.sign, o.space);
            var d = (o.alt && p == 0) ? '.' : '';
            var w = o.minwidth > 0 ? o.minwidth - s.length : o.minwidth + s.length;
            return s + pad(n + d, w, o.pad);
        },
        'g': function(v, o) {
            var i = _float(v);
            var p = o.precision == null ? 5 : o.precision;
            if (Math.abs(i) >= Math.pow(10, p || 1))
                return convert.e(v, o);
            var n;
            if (o.alt) { var a = Math.abs(i).toFixed(p).split('.');
                n = a[0] + '.' + (a[1] || ''); } else
                n = o.precision != null ? Math.abs(i).toPrecision(p).replace(/\.?0+$/, '') : Math.abs(i) + '';
            var s = sign(i, o.sign, o.space);
            var w = o.minwidth > 0 ? o.minwidth - s.length : o.minwidth + s.length;
            return s + pad(n, w, o.pad);
        },
        'c': function(v, o) {
            var t = getType(v);
            if (t === 'number')
                return String.fromCharCode(v);
            if (t === 'string')
                return v.charAt(0);
            throw new TypeError('%c requires number or string');
        },
        'r': function(v, o) { var s = repr(v); var p = o.precision == null ? s.length : o.precision; return pad(s.substring(0, p), o.minwidth, ' '); },
        's': function(v, o) { var s = '' + v; var p = o.precision == null ? s.length : o.precision; return pad(s.substring(0, p), o.minwidth, ' '); },
        '%': function(v, o) { return '%'; }
    };
    convert.i = convert.u = convert.d;
    var CHUNKER = /^%(?:\(([^)]*?)\))?([ 0#+\-]+)?(\d+|\*)?(\.\d*|\*)?([hlL])?([diouxefgcrs%])/i;

    function format(subject) {
        subject = String(subject);
        var res = '';
        var a = 1;
        for (var i = 0; i < subject.length; i++) {
            var chr = subject.charAt(i);
            if (chr != '%') { res += chr; continue; }
            var m = CHUNKER.exec(subject.substr(i));
            if (!m)
                return res + subject.substr(i);
            var value = m[1] ? arguments[1][m[1]] : arguments[a];
            var o = { 'type': m[6].toLowerCase(), 'alt': _has(m[2], '#'), 'padleft': _has(m[2], '-'), 'space': _has(m[2], ' '), 'sign': _has(m[2], '+'), 'pad': _has(m[2], '0') && !_has(m[2], '-') ? '0' : ' ', 'lenmod': m[5] ? _int(m[5]) : '' };
            a += (m[1] || m[6] === '%') ? 0 : 1;
            if (m[3] == '*') {
                if (m[1])
                    throw new SyntaxError('* expects a number');
                o.minwidth = arguments[a++];
            } else if (m[3])
                o.minwidth = _int(m[3]);
            if (o.minwidth && _has(m[2], '-'))
                o.minwidth = -o.minwidth;
            if (m[4] == '*') {
                if (m[1])
                    throw new SyntaxError('* expects a number');
                o.precision = arguments[a++];
            } else if (m[4])
                o.precision = _int(m[4].substr(1)) || 0;
            var fn = convert[o.type] || convert.s;
            var r = fn(value, o);
            res += m[6] !== o.type ? r.toUpperCase() : r;
            i += m[0].length - 1;
        }
        return res;
    }
    return format;
});
define('nebula/math/vector2', function() {
    'use strict';
    var tempPool = array(1000);
    var tempCurrent = -1;

    function Vector2(x, y) { this.x = x || 0;
        this.y = y || 0; }

    function is(obj) { return obj instanceof Vector2; }

    function create(x, y) { return new Vector2(x, y); }

    function temp(x, y) { tempCurrent = (tempCurrent + 1) % tempPool.length; var v = tempPool[tempCurrent];
        v.x = x || 0;
        v.y = y || 0; return v; }

    function array(count, x, y) {
        var result = new Array(count);
        for (var i = 0; i < count; i++)
            result[i] = new Vector2(x, y);
        return result;
    }

    function copy(vector, out) {
        if (out) { out.x = vector.x;
            out.y = vector.y; return undefined; } else
            return new Vector2(vector.x, vector.y);
    }

    function zero(out) { out.x = out.y = 0; }

    function add(vectorA, vectorB, out) { out.x = vectorA.x + vectorB.x;
        out.y = vectorA.y + vectorB.y; }

    function subtract(vectorA, vectorB, out) { out.x = vectorA.x - vectorB.x;
        out.y = vectorA.y - vectorB.y; }

    function multiply(vectorA, vectorB, out) { out.x = vectorA.x * vectorB.x;
        out.y = vectorA.y * vectorB.y; }

    function divide(vectorA, vectorB, out) { out.x = vectorA.x / vectorB.x;
        out.y = vectorA.y / vectorB.y; }

    function addNumber(vector, n, out) { out.x = vector.x + n;
        out.y = vector.y + n; }

    function subtractNumber(vector, n, out) { out.x = vector.x - n;
        out.y = vector.y - n; }

    function multiplyNumber(vector, n, out) { out.x = vector.x * n;
        out.y = vector.y * n; }

    function divideNumber(vector, n, out) { out.x = vector.x / n;
        out.y = vector.y / n; }

    function radians(vector, out) { out.x = vector.x * Math.PI / 180;
        out.y = vector.y * Math.PI / 180; }

    function degrees(vector, out) { out.x = vector.x * 180 / Math.PI;
        out.y = vector.y * 180 / Math.PI; }

    function sin(vector, out) { out.x = Math.sin(vector.x);
        out.y = Math.sin(vector.y); }

    function cos(vector, out) { out.x = Math.cos(vector.x);
        out.y = Math.cos(vector.y); }

    function tan(vector, out) { out.x = Math.tan(vector.x);
        out.y = Math.tan(vector.y); }

    function asin(vector, out) { out.x = Math.asin(vector.x);
        out.y = Math.asin(vector.y); }

    function acos(vector, out) { out.x = Math.acos(vector.x);
        out.y = Math.acos(vector.y); }

    function atan(vector, out) { out.x = Math.atan(vector.x);
        out.y = Math.atan(vector.y); }

    function pow(vectorA, vectorB, out) { out.x = Math.pow(vectorA.x, vectorB.x);
        out.y = Math.pow(vectorA.y, vectorB.y); }

    function exp(vector, out) { out.x = Math.exp(vector.x);
        out.y = Math.exp(vector.y); }

    function log(vector, out) { out.x = Math.log(vector.x);
        out.y = Math.log(vector.y); }

    function exp2(vector, out) { out.x = Math.pow(2, vector.x);
        out.y = Math.pow(2, vector.y); }

    function log2(vector, out) { out.x = Math.log2(vector.x);
        out.y = Math.log2(vector.y); }

    function abs(vector, out) { out.x = Math.abs(vector.x);
        out.y = Math.abs(vector.y); }

    function sign(vector, out) { out.x = Math.sign(vector.x);
        out.y = Math.sign(vector.y); }

    function sign2(vectorA, vectorB) { return vectorA.y * vectorB.x > vectorA.x * vectorB.y ? -1 : 1; }

    function floor(vector, out) { out.x = Math.floor(vector.x);
        out.y = Math.floor(vector.y); }

    function ceil(vector, out) { out.x = Math.ceil(vector.x);
        out.y = Math.ceil(vector.y); }

    function fract(vector, out) { out.x = vector.x - Math.trunc(vector.x);
        out.y = vector.y - Math.trunc(vector.y); }

    function mod(vectorA, vectorB, out) { out.x = vectorA.x - vectorB.x * Math.trunc(vectorA.x / vectorB.x);
        out.y = vectorA.y - vectorB.y * Math.trunc(vectorA.y / vectorB.y); }

    function min(vectorA, vectorB, out) { out.x = Math.min(vectorA.x, vectorB.x);
        out.y = Math.min(vectorA.y, vectorB.y); }

    function minNumber(vector, n, out) { out.x = Math.min(vector.x, n);
        out.y = Math.min(vector.y, n); }

    function max(vectorA, vectorB, out) { out.x = Math.max(vectorA.x, vectorB.x);
        out.y = Math.max(vectorA.y, vectorB.y); }

    function maxNumber(vector, n, out) { out.x = Math.max(vector.x, n);
        out.y = Math.max(vector.y, n); }

    function clamp(vector, minVector, maxVector, out) { out.x = Math.min(Math.max(vector.x, minVector.x), maxVector.x);
        out.y = Math.min(Math.max(vector.y, minVector.y), maxVector.y); }

    function clampNumber(vector, min, max, out) { out.x = Math.min(Math.max(vector.x, min), max);
        out.y = Math.min(Math.max(vector.y, min), max); }

    function interpolate(previous, next, alpha, out) { out.x = next.x * alpha + previous.x * (1 - alpha);
        out.y = next.y * alpha + previous.y * (1 - alpha); }

    function mix(minVector, maxVector, alphaVector, out) { out.x = minVector.x * (1 - alphaVector.x) + maxVector.x * alphaVector.x;
        out.y = minVector.y * (1 - alphaVector.y) + maxVector.y * alphaVector.y; }

    function step(edgeVector, vector, out) { out.x = vector.x < edgeVector.x ? 0 : 1;
        out.y = vector.y < edgeVector.y ? 0 : 1; }

    function stepNumber(edge, vector, out) { out.x = vector.x < edge ? 0 : 1;
        out.y = vector.y < edge ? 0 : 1; }

    function smoothStep(minEdgeVector, maxEdgeVector, vector, out) { var t;
        t = Math.min(Math.max((vector.x - minEdgeVector.x) / (maxEdgeVector.x - minEdgeVector.x), 0), 1);
        out.x = t * t * (3 - 2 * t);
        t = Math.min(Math.max((vector.y - minEdgeVector.y) / (maxEdgeVector.y - minEdgeVector.y), 0), 1);
        out.y = t * t * (3 - 2 * t); }

    function smoothStepNumber(minEdge, maxEdge, vector, out) { var t;
        t = Math.min(Math.max((vector.x - minEdge) / (maxEdge - minEdge), 0), 1);
        out.x = t * t * (3 - 2 * t);
        t = Math.min(Math.max((vector.y - minEdge) / (maxEdge - minEdge), 0), 1);
        out.y = t * t * (3 - 2 * t); }

    function invert(vector, out) { out.x = -vector.x;
        out.y = -vector.y; }

    function length(vector) { return Math.sqrt(vector.x * vector.x + vector.y * vector.y); }

    function dot(vectorA, vectorB) { return vectorA.x * vectorB.x + vectorA.y * vectorB.y; }

    function cross(vectorA, vectorB) { return vectorA.x * vectorB.y - vectorA.y * vectorB.x; }

    function normalize(vector, out) {
        var l = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
        if (l > 0) { out.x = vector.x / l;
            out.y = vector.y / l; } else
            out.x = out.y = 0;
    }

    function reflect(vector, normal, out) { var p = 2 * dot(vector, normal);
        out.x = vector.x - normal.x * p;
        out.y = vector.y - normal.y * p; }

    function refract(vector, normal, eta, out) {
        normalize(vector, out);
        vector = out;
        var dot = vector.x * normal.x + vector.y * normal.y;
        var k = 1 - eta * eta * (1 - dot * dot);
        if (k < 0)
            out.x = out.y = 0;
        else { out.x = eta * vector.x - (eta * dot + Math.sqrt(k)) * normal.x;
            out.y = eta * vector.y - (eta * dot + Math.sqrt(k)) * normal.y; }
    }

    function faceForward(vector, incidentVector, referenceVector, out) { if (dot(referenceVector, incidentVector) < 0) { out.x = vector.x;
            out.y = vector.y; } else { out.x = -vector.x;
            out.y = -vector.y; } }

    function perpendicular(vector, out) { var x = vector.x;
        out.x = -vector.y;
        out.y = x; }

    function slope(vectorA, vectorB) { return (vectorB.y - vectorA.y) / (vectorB.x - vectorA.x); }

    function direction(angle, out) { out.x = Math.cos(angle);
        out.y = Math.sin(angle); }

    function rotate(vector, angle, out) { var cos = Math.cos(angle),
            sin = Math.sin(angle); var x = vector.x * cos - vector.y * sin; var y = vector.x * sin + vector.y * cos;
        out.x = x;
        out.y = y; }

    function rotate2(vector, direction, out) { var l = length(vector);
        out.x = direction.x * l;
        out.y = direction.y * l; }

    function angle(vector) { return Math.atan2(vector.y, vector.x); }

    function angle2(vectorA, vectorB) { return Math.atan2(vectorB.y, vectorB.x) - Math.atan2(vectorA.y, vectorA.x); }

    function look(current, desired, turnRate, out) {
        var direction = temp();
        normalize(current, direction);
        var d = Math.min(Math.max(dot(direction, desired), -1), 1);
        var angle = Math.acos(d);
        if (angle < 0.00001) { resize(desired, length(current), out); return true; }
        if (angle > turnRate)
            angle = turnRate;
        rotate(current, angle * sign2(current, desired), out);
        return false;
    }

    function resize(vector, length, out) { normalize(vector, out);
        out.x *= length;
        out.y *= length; }

    function truncateLength(vector, max, out) { var l = length(vector); if (l > max) { out.x = vector.x / l * max;
            out.y = vector.y / l * max; } }

    function clampLength(vector, min, max, out) {
        var l = length(vector);
        if (l === 0)
            throw new Error("Can't clamp vector, it's length is 0");
        if (l > max) { out.x = vector.x / l * max;
            out.y = vector.y / l * max; } else if (l < min) { out.x = vector.x / l * min;
            out.y = vector.y / l * min; }
    }

    function coincidence(from, to, direction) {
        var x = to.x - from.x,
            y = to.y - from.y,
            length = Math.sqrt(x * x + y * y);
        if (length) { x /= length;
            y /= length; }
        return direction.x * x + direction.y * y;
    }

    function isZero(vector) { return vector.x === 0 && vector.y === 0; }

    function notZero(vector) { return vector.x !== 0 || vector.y !== 0; }

    function lessThan(vectorA, vectorB) { return vectorA.x < vectorB.x && vectorA.y < vectorB.y; }

    function lessThanEqual(vectorA, vectorB) { return vectorA.x <= vectorB.x && vectorA.y <= vectorB.y; }

    function greaterThan(vectorA, vectorB) { return vectorA.x > vectorB.x && vectorA.y > vectorB.y; }

    function greaterThanEqual(vectorA, vectorB) { return vectorA.x >= vectorB.x && vectorA.y >= vectorB.y; }

    function equals(vectorA, vectorB) { return vectorA.x === vectorB.x && vectorA.y === vectorB.y; }
    var exports = { 'is': is, 'create': create, 'temp': temp, 'array': array, 'copy': copy, 'zero': zero, 'add': add, 'subtract': subtract, 'multiply': multiply, 'divide': divide, 'addNumber': addNumber, 'subtractNumber': subtractNumber, 'multiplyNumber': multiplyNumber, 'divideNumber': divideNumber, 'radians': radians, 'degrees': degrees, 'sin': sin, 'cos': cos, 'tan': tan, 'asin': asin, 'acos': acos, 'atan': atan, 'pow': pow, 'exp': exp, 'log': log, 'exp2': exp2, 'log2': log2, 'abs': abs, 'sign': sign, 'sign2': sign2, 'floor': floor, 'ceil': ceil, 'fract': fract, 'mod': mod, 'min': min, 'minNumber': minNumber, 'max': max, 'maxNumber': maxNumber, 'clamp': clamp, 'clampNumber': clampNumber, 'interpolate': interpolate, 'mix': mix, 'step': step, 'stepNumber': stepNumber, 'smoothStep': smoothStep, 'smoothStepNumber': smoothStepNumber, 'invert': invert, 'length': length, 'dot': dot, 'cross': cross, 'normalize': normalize, 'reflect': reflect, 'refract': refract, 'faceForward': faceForward, 'perpendicular': perpendicular, 'slope': slope, 'direction': direction, 'rotate': rotate, 'rotate2': rotate2, 'angle': angle, 'angle2': angle2, 'look': look, 'resize': resize, 'truncateLength': truncateLength, 'clampLength': clampLength, 'coincidence': coincidence, 'isZero': isZero, 'notZero': notZero, 'lessThan': lessThan, 'lessThanEqual': lessThanEqual, 'greaterThan': greaterThan, 'greaterThanEqual': greaterThanEqual, 'equals': equals, 'ZERO': create() };
    return exports;
});
define('nebula/input/key', function() {
    'use strict';

    function Key(code, name, codeName, location) { this.code = code;
        this.name = name;
        this.codeName = codeName || ('key' + code);
        this.location = location != null ? location : KeyboardEvent.DOM_KEY_LOCATION_STANDARD;
        this.isLocked = false;
        this.resetState(); }
    Key.prototype.resetState = function() { this.isUp = true;
        this.isDown = false;
        this.pressTime = 0; };
    Key.prototype.lock = function() { this.isLocked = true; };
    Key.prototype.unlock = function() { this.isLocked = false; };
    Object.defineProperty(Key.prototype, 'value', { 'get': function() { return this.isDown ? 1 : 0; } });
    return Key;
});
define('nebula/input/keyboard', ['nebula/window', 'nebula/signal', 'nebula/input/key', 'nebula/math/vector2'], function(window, Signal, Key, vector2) {
    'use strict';
    var enabled = false;
    var keysByCode = {};
    var keys = {};
    var onUp = new Signal();
    var onDown = new Signal();
    var onDownRepeat = new Signal();
    var dir = vector2.create();
    var length = Math.sqrt(2);

    function _getKey(event) {
        var code = event.keyCode;
        var key = keysByCode[code];
        if (!key) { key = new Key(code);
            keys[key.code] = keysByCode[code] = key;
            _keys.push(key); } else if (key.length) {
            for (var i = 0; i < key.length; i++)
                if (key[i].location === event.location)
                    return key[i];
            return key[0];
        }
        return key;
    }

    function handleKeyDown(event) {
        var key = _getKey(event);
        if (key.isLocked)
            event.preventDefault();
        var justPressed = key.isUp;
        key.isUp = !(key.isDown = true);
        if (justPressed) { key.pressTime = 0;
            onDown.send(key); } else
            onDownRepeat.send(key);
    }

    function handleKeyUp(event) {
        var key = _getKey(event);
        if (key.isLocked)
            event.preventDefault();
        var justReleased = key.isDown;
        key.isUp = !(key.isDown = false);
        if (justReleased)
            onUp.send(key);
    }

    function _isUp(key) { return key.isUp; }

    function isUp() { return Array.prototype.every.call(arguments, _isUp); }

    function _isDown(key) { return key.isDown; }

    function isDown() { return Array.prototype.every.call(arguments, _isDown); }

    function clearBuffer() {
        for (var i = 0; i < _keys.length; i++)
            _keys[i].resetState();
    }

    function _lock(key) { key.lock(); }

    function lock() { Array.prototype.forEach.call(arguments, _lock); }

    function _unlock(key) { key.unlock(); }

    function unlock() { Array.prototype.forEach.call(arguments, _unlock); }

    function lockAll() {
        for (var i = 0; i < _keys.length; i++)
            _keys[i].lock();
    }

    function unlockAll() {
        for (var i = 0; i < _keys.length; i++)
            _keys[i].unlock();
    }

    function keyCodeToCodeName(keyCode) {
        for (var i = 0; i < _keys.length; i++)
            if (_keys[i].code === keyCode)
                return _keys[i].name;
        return 'key' + keyCode;
    }

    function keyCodeToName(keyCode) {
        for (var i = 0; i < _keys.length; i++)
            if (_keys[i].code === keyCode)
                return _keys[i].name;
        return 'Key ' + keyCode;
    }

    function parseKeyNames(names) {
        var output = names.split(' ');
        for (var i = 0; i < output.length; i++) {
            var name = output[i];
            if (!(name in keys))
                throw new Error('Invalid key name `' + name + '`');
            output[i] = keys[name];
        }
        return output;
    }

    function acceptKeyNames(callback) {
        return function() {
            if (typeof arguments[0] === 'string')
                return callback.apply(this, parseKeyNames(arguments[0]));
            return callback.apply(this, arguments);
        }
    }

    function resume() { window.addEventListener('blur', clearBuffer);
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp); }

    function enable(kwargs) {
        if (kwargs) {
            if (kwargs.lockAll)
                lockAll();
            else if (kwargs.lock)
                lock.apply(undefined, kwargs.lock);
        }
        resume();
        enabled = true;
    }

    function update(elapsed) {
        var key;
        for (var i = 0; i < _keys.length; i++) {
            key = _keys[i];
            if (key.isDown)
                key.pressTime += elapsed;
        }
    }

    function pause() { clearBuffer();
        window.removeEventListener('blur', clearBuffer);
        window.removeEventListener('keydown', handleKeyDown);
        window.removeEventListener('keyup', handleKeyUp); }

    function disable() { unlockAll();
        pause();
        enabled = false; }

    function direction(up, right, down, left) {
        up = up || keys.up;
        right = right || keys.right;
        down = down || keys.down;
        left = left || keys.left;
        dir.x = right.isDown - left.isDown;
        dir.y = down.isDown - up.isDown;
        if (dir.x && dir.y) { dir.x /= length;
            dir.y /= length; }
        return dir;
    }
    var LOCATION_STANDARD = KeyboardEvent.DOM_KEY_LOCATION_STANDARD;
    var LOCATION_LEFT = KeyboardEvent.DOM_KEY_LOCATION_LEFT;
    var LOCATION_RIGHT = KeyboardEvent.DOM_KEY_LOCATION_RIGHT;
    var LOCATION_NUMPAD = KeyboardEvent.DOM_KEY_LOCATION_NUMPAD;
    var _keys = [new Key(8, 'Backspace', 'backspace'), new Key(9, 'Tab', 'tab'), new Key(12, 'Clear', 'clear'), new Key(13, 'Enter', 'enter'), new Key(13, 'Num Enter', 'numpadEnter', LOCATION_NUMPAD), new Key(16, 'Shift', 'shift'), new Key(17, 'Ctrl', 'ctrl'), new Key(18, 'Alt', 'alt'), new Key(19, 'Pause/Break', 'pauseBreak'), new Key(20, 'Caps Lock', 'capsLock'), new Key(27, 'Esc', 'esc'), new Key(32, 'Space', 'space'), new Key(33, 'Page Up', 'pageUp'), new Key(33, 'Num Page Up', 'numpadPageUp', LOCATION_NUMPAD), new Key(34, 'Page Down', 'pageDown'), new Key(34, 'Num Page Down', 'numpadPageDown', LOCATION_NUMPAD), new Key(35, 'End', 'end'), new Key(35, 'Num End', 'numpadEnd', LOCATION_NUMPAD), new Key(36, 'Home', 'home'), new Key(36, 'Num Home', 'numpadHome', LOCATION_NUMPAD), new Key(37, '', 'left'), new Key(37, 'Num Left', 'numpadLeft', LOCATION_NUMPAD), new Key(38, '', 'up'), new Key(38, 'Num Up', 'numpadUp', LOCATION_NUMPAD), new Key(39, '', 'right'), new Key(39, 'Num Right', 'numpadRight', LOCATION_NUMPAD), new Key(40, '', 'down'), new Key(40, 'Num Down', 'numpadDown', LOCATION_NUMPAD), new Key(45, 'Insert', 'insert'), new Key(45, 'Num Insert', 'numpadInsert', LOCATION_NUMPAD), new Key(46, 'Delete', 'delete'), new Key(46, 'Num Delete', 'numpadDelete', LOCATION_NUMPAD), new Key(47, 'Help', 'help'), new Key(48, '0', 'zero'), new Key(49, '1', 'one'), new Key(50, '2', 'two'), new Key(51, '3', 'three'), new Key(52, '4', 'four'), new Key(53, '5', 'five'), new Key(54, '6', 'six'), new Key(55, '7', 'seven'), new Key(56, '8', 'eight'), new Key(57, '9', 'nine'), new Key(65, 'A', 'a'), new Key(66, 'B', 'b'), new Key(67, 'C', 'c'), new Key(68, 'D', 'd'), new Key(69, 'E', 'e'), new Key(70, 'F', 'f'), new Key(71, 'G', 'g'), new Key(72, 'H', 'h'), new Key(73, 'I', 'i'), new Key(74, 'J', 'j'), new Key(75, 'K', 'k'), new Key(76, 'L', 'l'), new Key(77, 'M', 'm'), new Key(78, 'N', 'n'), new Key(79, 'O', 'o'), new Key(80, 'P', 'p'), new Key(81, 'Q', 'q'), new Key(82, 'R', 'r'), new Key(83, 'S', 's'), new Key(84, 'T', 't'), new Key(85, 'U', 'u'), new Key(86, 'V', 'v'), new Key(87, 'W', 'w'), new Key(88, 'X', 'x'), new Key(89, 'Y', 'y'), new Key(90, 'Z', 'z'), new Key(91, 'Left Windows', 'leftWindows'), new Key(92, 'Right Windows', 'rightWindows'), new Key(93, 'Menu', 'menu'), new Key(96, 'Num 0', 'numpad0'), new Key(97, 'Num 1', 'numpad1'), new Key(98, 'Num 2', 'numpad2'), new Key(99, 'Num 3', 'numpad3'), new Key(100, 'Num 4', 'numpad4'), new Key(101, 'Num 5', 'numpad5'), new Key(102, 'Num 6', 'numpad6'), new Key(103, 'Num 7', 'numpad7'), new Key(104, 'Num 8', 'numpad8'), new Key(105, 'Num 9', 'numpad9'), new Key(106, 'Num *', 'numpadMultiply'), new Key(107, 'Num +', 'numpadAdd'), new Key(108, 'Num Enter', 'numpadEnter'), new Key(109, 'Num -', 'numpadSubtract'), new Key(110, 'Num .', 'numpadDecimal'), new Key(111, 'Num /', 'numpadDivide'), new Key(112, 'F1', 'f1'), new Key(113, 'F2', 'f2'), new Key(114, 'F3', 'f3'), new Key(115, 'F4', 'f4'), new Key(116, 'F5', 'f5'), new Key(117, 'F6', 'f6'), new Key(118, 'F7', 'f7'), new Key(119, 'F8', 'f8'), new Key(120, 'F9', 'f9'), new Key(121, 'F10', 'f10'), new Key(122, 'F11', 'f11'), new Key(123, 'F12', 'f12'), new Key(124, 'F13', 'f13'), new Key(125, 'F14', 'f14'), new Key(126, 'F15', 'f15'), new Key(144, 'Num Lock', 'numLock'), new Key(145, 'Scroll Lock', 'scrollLock'), new Key(186, ';', 'semiColon'), new Key(187, '=', 'equals'), new Key(188, ',', 'comma'), new Key(189, '-', 'minus'), new Key(190, '.', 'period'), new Key(191, '/', 'slash'), new Key(192, '`', 'tilde'), new Key(219, '[', 'openBracket'), new Key(220, '\\', 'backSlash'), new Key(221, ']', 'closeBracket'), new Key(222, '\'', 'quote')];
    for (var i = 0; i < _keys.length; i++) {
        var key = _keys[i];
        if (!keysByCode[key.code])
            keysByCode[key.code] = key;
        else {
            var old = keysByCode[key.code];
            if (old.length)
                keysByCode[key.code].push(key);
            else
                keysByCode[key.code] = [old, key];
        }
        keys[key.codeName] = key;
    }
    return { 'type': 'keyboard', 'keysByCode': keysByCode, 'parseKeyNames': parseKeyNames, 'keys': keys, 'resume': resume, 'isEnabled': function() { return enabled }, 'enable': enable, 'update': update, 'pause': pause, 'disable': disable, 'lock': acceptKeyNames(lock), 'unlock': acceptKeyNames(unlock), 'lockAll': lockAll, 'unlockAll': unlockAll, 'clearBuffer': clearBuffer, 'keyCodeToName': keyCodeToName, 'keyCodeToCodeName': keyCodeToCodeName, 'isUp': acceptKeyNames(isUp), 'isDown': acceptKeyNames(isDown), 'onUp': onUp, 'onDown': onDown, 'onDownRepeat': onDownRepeat, 'direction': acceptKeyNames(direction) };
});
define('settings', { 'DEBUG': true, 'GAME_SPEED': 1.5, 'MUSIC_VOLUME': .49, 'PLAYER_PLASMA_VOLUME': .273, 'PLAYER_STORM_VOLUME': .273, 'PLAYER_RAY_VOLUME': .753, 'PLAYER_ROCKETS_VOLUME': .333, 'PLAYER_ELECTRO_VOLUME': .383, 'WEAPON_CHANGE_VOLUME': .5, 'LOW_LIFE_VOLUME': 1, 'ENEMY_LASER_VOLUME': .333, 'ENEMY_ELECTRO_VOLUME': .333, 'ENEMY_FLAK_VOLUME': .333, 'POWERUP_SCORE_VOLUME': 1, 'POWERUP_SCORE_MULTIPLIER_VOLUME': 1, 'POWERUP_DAMAGE_MULTIPLIER_VOLUME': 1, 'POWERUP_REPAIR_VOLUME': 1, 'POWERUP_LIFE_VOLUME': 1, 'POWERUP_INVINCIBILITY_VOLUME': 1, 'POWERUP_WEAPON_UPGRADE_VOLUME': 1, 'ROCKET_EXPLODE_VOLUME': .5, 'ROCKET_FLYING_VOLUME': .1, 'MINE_APPROACH_VOLUME': .05, 'SHIP_EXPLODE_VOLUME': 1, 'SHIP_INVINCIBILITY_VOLUME': .9, 'PLASMA_EXPLODE_VOLUME': .333, });
define('skytte/assets', function() { return ['images/640/background/crust/layer_2.json', 'images/640/background/crust/layer_3.json', 'images/640/background/crust/layer_4.json', 'images/640/background/mantle/layer_2.json', 'images/640/background/mantle/layer_3.json', 'images/640/background/mantle/layer_4.json', 'images/640/background/core/layer_2.json', 'images/640/background/core/layer_3.json', 'images/640/background/core/layer_4.json', 'images/640/misc.json', ['hint_touchscreen', 'images/640/hint_touchscreen.png']]; });
define('skytte/utils', function() {
    function copy(other) {
        if (typeof other === 'undefined' || other === null)
            return other;
        var target = other instanceof Array ? [] : {},
            property;
        for (property in other)
            if (other.hasOwnProperty(property))
                target[property] = typeof other[property] === 'object' ? copy(other[property]) : other[property];
        return target;
    }

    function _merge(target, other) {
        if (typeof target === 'undefined' || target === null)
            return typeof other === 'object' ? copy(other) : other;
        for (var property in other)
            if (other.hasOwnProperty(property)) {
                if (typeof target[property] === 'object' || typeof other[property] === 'object')
                    target[property] = _merge(target[property], other[property]);
                else
                    target[property] = other[property];
            }
        return target;
    }

    function merge() {
        var target = copy(arguments[0]),
            i;
        for (i = 1; i < arguments.length; i++)
            target = _merge(target, arguments[i]);
        return target;
    }

    function inArray(item, array) {
        for (var i = 0; i < array.length; i++)
            if (array[i] === item)
                return true;
        return false;
    }
    return { 'copy': copy, 'merge': merge, '_merge': _merge, 'inArray': inArray };
});
define('skytte/tween', function() {
    function Tween(begin, change, duration, easingFunc, mode) { this.begin = begin;
        this.change = change;
        this.mode = mode || Tween.MODE_ONCE;
        this.duration = duration / 1000;
        this.easingFunc = easingFunc;
        this.restart(); }
    Tween.MODE_ONCE = 'once';
    Tween.MODE_REPEAT = 'repeat';
    Tween.prototype.restart = function() { this.time = 0;
        this.hasEnded = false; };
    Tween.prototype.toEnd = function() { this.time = this.duration;
        this.value = this.begin + this.change;
        this.hasEnded = true; };
    Tween.prototype.update = function(elapsed) {
        if (this.hasEnded)
            return;
        this.value = this.begin + this.easingFunc(this.time / this.duration) * this.change;
        if (this.time >= this.duration && this.mode == Tween.MODE_REPEAT)
            this.restart();
        else
            this.time = Math.min(this.time + elapsed, this.duration);
        if (this.time >= this.duration && this.mode == Tween.MODE_ONCE)
            this.toEnd();
    };
    Tween.prototype.toNumber = function() { return this.value; };
    return Tween;
});
define('skytte/per_second', function() {
    function PerSecond(timesPerSecond, func) { this.fps = timesPerSecond;
        this.func = func;
        this.delay = 0; }
    PerSecond.prototype.update = function(elapsed) { this.delay -= elapsed; if (this.delay <= 0) { this.delay += 1000 / this.fps / 1000;
            this.func(); } };
    return PerSecond;
});
define('skytte/vector2', function() {
    function Vector2(x, y) { this.x = x || 0;
        this.y = y || 0; }
    Vector2.prototype.toString = function(decPlaces) { return '<Vector2 ' + this.x + ',' + this.y + '>'; };
    Vector2.copy = function(vector) { return new Vector2(vector.x, vector.y); };
    Vector2.distance = function(a, b) { var x = a.x - b.x,
            y = a.y - b.y; return Math.sqrt(x * x + y * y); };
    Vector2.prototype.copy = function() { return new Vector2(this.x, this.y); };
    Vector2.prototype.zero = function() { this.x = 0;
        this.y = 0; return this; };
    Vector2.prototype.set = function(x, y) { this.x = x;
        this.y = y; return this; };
    Vector2.prototype.lengthSquared = function() { return this.x * this.x + this.y * this.y; };
    Vector2.prototype.length = function() { return Math.sqrt(this.x * this.x + this.y * this.y); };
    Vector2.prototype.normalize = function() {
        var l = Math.sqrt(this.x * this.x + this.y * this.y);
        if (l > 0) { this.x /= l;
            this.y /= l; }
        return this;
    };
    Vector2.prototype.add = function(v) { this.x += v.x;
        this.y += v.y; return this; };
    Vector2.prototype.sub = function(v) { this.x -= v.x;
        this.y -= v.y; return this; };
    Vector2.prototype.scale = function(x, y) { this.x *= x;
        this.y *= typeof y !== 'undefined' ? y : x; return this; };
    Vector2.prototype.div = function(scalar) { this.x /= scalar;
        this.y /= scalar; return this; };
    Vector2.prototype.dot = function(v) { return this.x * v.x + this.y * v.y; };
    Vector2.prototype.angle = function() { return Math.atan2(this.y, this.x); };
    Vector2.prototype.perp = function() { var x = this.x;
        this.x = this.y;
        this.y = -x; return this; };
    Vector2.prototype.rotate = function(angle) { var cos = Math.cos(angle); var sin = Math.sin(angle); var tempX = this.x; var tempY = this.y;
        this.x = tempX * cos - tempY * sin;
        this.y = tempX * sin + tempY * cos; return this; };
    return Vector2;
});
define('skytte/bounding_box', function() {
    function BoundingBox(x, y, w, h) { this.x = x || 0;
        this.y = y || 0;
        this.width = w || 0;
        this.height = h || 0; }
    BoundingBox.fromString = function(str) { var points = str.split(' '); var pos = points[0].split(','); var size = points[1].split(','); return new BoundingBox(parseFloat(pos[0]), parseFloat(pos[1]), parseFloat(size[0]), parseFloat(size[1])); };
    BoundingBox.fromPolygon = function(polygon) { return (new BoundingBox()).fromPolygon(polygon); };
    BoundingBox.prototype.toString = function() { return '<Rectangle ' + this.x + ',' + this.y + ' ' + this.width + ',' + this.height + '>'; };
    BoundingBox.prototype.fromPolygon = function(polygon) {
        var minX = Number.MAX_VALUE,
            minY = Number.MAX_VALUE,
            maxX = Number.MIN_VALUE,
            maxY = Number.MIN_VALUE,
            i, p;
        for (i = 0; i < polygon.points.length; i++) { p = polygon.points[i];
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y); }
        this.x = minX;
        this.y = minY;
        this.width = maxX - minX;
        this.height = maxY - minY;
        return this;
    };
    BoundingBox.prototype.copy = function() { return new BoundingBox(this.x, this.y, this.width, this.height); };
    BoundingBox.prototype.draw = function(context, x, y, lineColor) { context.save();
        context.strokeStyle = lineColor || '#fff';
        context.lineWidth = 1.25;
        context.strokeRect(x + this.x, y + this.y, this.width, this.height);
        context.restore(); };
    return BoundingBox;
});
define('skytte/polygon', ['skytte/vector2'], function(Vector2) {
    'use strict';

    function Polygon(points) {
        this.points = points;
        this.normals = [];
        if (this.points)
            this.recalcNormals();
    };
    Polygon.fromString = function(coords) {
        var pointsStr = coords.split(' '),
            points = new Array(pointsStr.length),
            point;
        for (var i = 0; i < pointsStr.length; i++) { point = pointsStr[i].split(',');
            points[i] = new Vector2(parseFloat(point[0]), parseFloat(point[1])); }
        return new Polygon(points);
    };
    Polygon.fromBox = function(box) { return (new Polygon()).fromBox(box); };
    Polygon.prototype.fromBox = function(box) { this.points = [new Vector2(box.x, box.y), new Vector2(box.x + box.width, box.y), new Vector2(box.x + box.width, box.y + box.height), new Vector2(box.x, box.y + box.height)]; return this.recalcNormals(); };
    Polygon.prototype.toString = function(decPlaces) { return '<Polygon ' + this.points.join(' ') + '>'; };
    Polygon.prototype.recalcNormals = function() {
        var edge = new Vector2(),
            normal = new Vector2();
        for (var i = 0; i < this.points.length; i++) { var p1 = this.points[i]; var p2 = i < this.points.length - 1 ? this.points[i + 1] : this.points[0];
            edge.set(p2.x, p2.y).sub(p1);
            normal.set(edge.x, edge.y).perp().normalize();
            this.normals[i] = normal.copy(); }
        return this;
    };
    Polygon.prototype.render = function() {
        var points = this.points;
        var count = points.length;
        var gfx = new PIXI.Graphics();
        gfx.lineStyle(1, 0xffffff, 1);
        gfx.moveTo(points[0].x, points[0].y);
        for (var i = 1; i < count; i++)
            gfx.lineTo(points[i].x, points[i].y);
        gfx.closePath();
        return gfx;
    };
    return Polygon;
});
define('skytte/collision', function() {
    var collision = {};
    collision._flattenPointsOn = function(points, normal) {
        var min = Number.MAX_VALUE,
            max = -Number.MAX_VALUE,
            dot, i;
        for (i = 0; i < points.length; i++) {
            dot = points[i].x * normal.x + points[i].y * normal.y;
            if (dot < min)
                min = dot;
            if (dot > max)
                max = dot;
        }
        return [min, max];
    };
    collision._isSeparatingAxis = function(posA, pointsA, posB, pointsB, axis) { var offset = (posB.x - posA.x) * axis.x + (posB.y - posA.y) * axis.y; var rangeA = collision._flattenPointsOn(pointsA, axis); var rangeB = collision._flattenPointsOn(pointsB, axis);
        rangeB[0] += offset;
        rangeB[1] += offset; return rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]; };
    collision.testPolygons = function(posA, polygonA, posB, polygonB) {
        var i;
        for (i = 0; i < polygonA.points.length; i++)
            if (collision._isSeparatingAxis(posA, polygonA.points, posB, polygonB.points, polygonA.normals[i]))
                return false;
        for (i = 0; i < polygonB.points.length; i++)
            if (collision._isSeparatingAxis(posA, polygonA.points, posB, polygonB.points, polygonB.normals[i]))
                return false;
        return true;
    };
    collision.testBoundingBoxes = function(posA, boxA, posB, boxB) { return !(posA.x + boxA.x > posB.x + boxB.x + boxB.width || posB.x + boxB.x > posA.x + boxA.x + boxA.width || posA.y + boxA.y > posB.y + boxB.y + boxB.height || posB.y + boxB.y > posA.y + boxA.y + boxA.height); };
    collision.testPointInBoundingBox = function(point, box) {
        if (point.x < box.x || point.x > box.x + box.width || point.y < box.y || point.y > box.y + box.height)
            return false;
        return true;
    };
    return collision;
});
define('skytte/sound', ['nebula/signal'], function(Signal) {
    function Sound(url, minDelay) { this.url = url;
        this.minDelay = minDelay || 0;
        this.loaded = new Signal();
        this.hasLoaded = false;
        this.toLoad = 0;
        this.lastPlay = null;
        this._onLoadProxy = this._onLoad.bind(this);
        createjs.Sound.addEventListener('fileload', this._onLoadProxy); }
    Sound.id = 0;
    Sound.prototype.load = function() { this._soundIds = []; var urls = this.url.split(' '),
            id;
        this.toLoad = urls.length; for (var i = 0; i < urls.length; i++) { var id = 'sound' + Sound.id;
            this._soundIds.push(id);
            Sound.id += 1;
            createjs.Sound.registerSound({ 'id': id, 'src': urls[i] }); } };
    Sound.prototype._onLoad = function(event) {
        for (var i = 0; i < this._soundIds.length; i++)
            if (event.id === this._soundIds[i]) {
                this.toLoad -= 1;
                if (this.toLoad === 0) { this.hasLoaded = true;
                    this.loaded.send(this);
                    createjs.Sound.removeEventListener('fileload', this._onLoadProxy); }
                break;
            }
    };
    Sound.prototype.getInstance = function() { var id = this._soundIds[Math.floor(Math.random() * this._soundIds.length)]; return createjs.Sound.createInstance(id); };
    Sound.prototype.play = function(kwargs) {
        kwargs = kwargs || {};
        if (this.minDelay && this.lastPlay) {
            var time = new Date();
            if (time - this.lastPlay < this.minDelay)
                return createjs.Sound.defaultSoundInstance;
            this.lastPlay = time;
        } else if (this.minDelay)
            this.lastPlay = new Date();
        var id = this._soundIds[Math.floor(Math.random() * this._soundIds.length)];
        return createjs.Sound.play(id, kwargs);
    };
    Sound.prototype.playLoop = function(kwargs) { kwargs = kwargs || {};
        kwargs.loop = -1; return this.play(kwargs); };
    return Sound;
});
define('skytte/text', function() {
    'use strict';

    function Text(kwargs) {
        PIXI.Container.call(this);
        this.textures = {};
        for (var c in kwargs.textures)
            this.textures[c] = PIXI.Texture.fromImage(kwargs.textures[c]);
        this.spacing = kwargs.spacing || 0;
        this.align = kwargs.align || 'left';
        this._text = kwargs.text || '';
        if ('scale' in kwargs)
            this.scale.set(kwargs.scale.x, kwargs.scale.y);
        if (this._text.length)
            this.updateText();
    }
    Text.prototype = Object.create(PIXI.Container.prototype);
    Text.prototype.updateText = function() {
        var sprites = this.children,
            sprite, width = 0;
        for (var i = 0; i < this._text.length; i++) {
            if (i >= sprites.length)
                this.addChild(new PIXI.Sprite());
            sprite = sprites[i];
            sprite.texture = this.textures[this._text[i]];
            sprite.position.x = width;
            sprite.visible = true;
            width += sprite.texture.width + this.spacing;
        }
        for (; i < sprites.length; i++)
            sprites[i].visible = false;
        var offset = 0;
        if (this.align === 'center')
            offset = -width / 2;
        else if (this.align === 'right')
            offset = -width;
        if (offset)
            for (i = 0; i < this._text.length; i++)
                sprites[i].position.x += offset;
    };
    Object.defineProperties(Text.prototype, { 'text': { 'get': function() { return this._text; }, 'set': function(text) { if (this._text !== text) { this._text = typeof text !== 'string' ? String(text) : text;
                    this.updateText(); } } } });
    var GREEN_TEXTURES = { ' ': 'font_space.png', 'x': 'font_green_x.png', '+': 'font_green_plus.png', '0': 'font_green_0.png', '1': 'font_green_1.png', '2': 'font_green_2.png', '3': 'font_green_3.png', '4': 'font_green_4.png', '5': 'font_green_5.png', '6': 'font_green_6.png', '7': 'font_green_7.png', '8': 'font_green_8.png', '9': 'font_green_9.png' };
    var ORANGE_TEXTURES = { ' ': 'font_space.png', 'x': 'font_orange_x.png', '+': 'font_orange_plus.png', '0': 'font_orange_0.png', '1': 'font_orange_1.png', '2': 'font_orange_2.png', '3': 'font_orange_3.png', '4': 'font_orange_4.png', '5': 'font_orange_5.png', '6': 'font_orange_6.png', '7': 'font_orange_7.png', '8': 'font_orange_8.png', '9': 'font_orange_9.png' };
    var RED_TEXTURES = { ' ': 'font_space.png', 'x': 'font_red_x.png', '+': 'font_red_plus.png', '-': 'font_red_minus.png', '0': 'font_red_0.png', '1': 'font_red_1.png', '2': 'font_red_2.png', '3': 'font_red_3.png', '4': 'font_red_4.png', '5': 'font_red_5.png', '6': 'font_red_6.png', '7': 'font_red_7.png', '8': 'font_red_8.png', '9': 'font_red_9.png' };

    function createGreenText(kwargs) { kwargs = kwargs || {};
        kwargs.textures = GREEN_TEXTURES; return new Text(kwargs); }

    function createOrangeText(kwargs) { kwargs = kwargs || {};
        kwargs.textures = ORANGE_TEXTURES; return new Text(kwargs); }

    function createRedText(kwargs) { kwargs = kwargs || {};
        kwargs.textures = RED_TEXTURES; return new Text(kwargs); }
    return { 'Text': Text, 'GREEN_TEXTURES': GREEN_TEXTURES, 'ORANGE_TEXTURES': ORANGE_TEXTURES, 'RED_TEXTURES': RED_TEXTURES, 'createGreenText': createGreenText, 'createOrangeText': createOrangeText, 'createRedText': createRedText };
});
define('skytte/beam', ['nebula/numbers', 'skytte/vector2'], function(numbers, Vector2) {
    'use strict';

    function Beam(tint, maxOffset, rayCount, divisions) {
        PIXI.Container.call(this);
        this.maxOffset = maxOffset;
        this.start = new Vector2();
        this.end = new Vector2();
        this.points = new Array(rayCount);
        for (var i = 0; i < rayCount; i++) {
            var points = this.points[i] = new Array(divisions);
            points[0] = this.start;
            points[points.length - 1] = this.end;
            for (var j = 1; j < points.length - 1; j++)
                points[j] = new Vector2();
            var rope = new PIXI.mesh.Rope(PIXI.Texture.fromImage('beam.png'), points);
            rope.tint = tint;
            rope.blendMode = PIXI.BLEND_MODES.ADD;
            this.addChild(rope);
        }
        this.alpha = 0;
        this.update();
    }
    Beam.prototype = Object.create(PIXI.Container.prototype);
    Beam.prototype.update = function() {
        var distance = Vector2.distance(this.start, this.end);
        var lx = this.end.x - this.start.x,
            ly = this.end.y - this.start.y;
        var dir = new Vector2((this.end.x - this.start.x) / distance, (this.end.y - this.start.y) / distance);
        dir.perp();
        for (var j = 0; j < this.points.length; j++) { var points = this.points[j]; for (var i = 1; i < points.length - 1; i++) { var a = i / points.length; var r = Math.random() * this.maxOffset * 2 - this.maxOffset;
                points[i].x = this.start.x + lx * a + dir.x * r + Math.random() * 6 - 3;
                points[i].y = this.start.y + ly * a + dir.y * r + Math.random() * 6 - 3; } }
        this.alpha = 0.2 + Math.random() * 0.8;
    };
    return Beam;
});
define('skytte/entity', ['nebula/numbers', 'skytte/vector2', 'skytte/bounding_box', 'skytte/polygon'], function(numbers, Vector2, BoundingBox, Polygon) {
    function Entity(game, name, x, y, kwargs) {
        this.game = game;
        this.name = name;
        this.position = new Vector2(x, y);
        this._center = new Vector2();
        kwargs = kwargs || {};
        if (typeof kwargs.box === 'string')
            this.box = BoundingBox.fromString(kwargs.box);
        else if (kwargs.box)
            this.box = kwargs.box;
        if (typeof kwargs.polygon === 'string')
            this.polygon = Polygon.fromString(kwargs.polygon);
        else if (kwargs.polygon)
            this.polygon = kwargs.polygon;
        if (this.polygon && !this.box)
            this.box = BoundingBox.fromPolygon(this.polygon);
        else if (!this.polygon && this.box)
            this.polygon = Polygon.fromBox(this.box);
        this.collectible = Boolean(kwargs.collectible);
        this.velocity = new Vector2(kwargs.vx || 0, kwargs.vy || 0);
        this.force = new Vector2(kwargs.fx || 0, kwargs.fy || 0);
        this.mass = kwargs.mass || 0;
        this.ai = kwargs.ai;
        this.team = kwargs.team || 0;
        this.score = kwargs.score || 0;
        this.killWhenOffScreen = typeof kwargs.killWhenOffScreen !== 'undefined' ? kwargs.killWhenOffScreen : true;
        this.dead = typeof kwargs.dead === 'undefined' ? false : kwargs.dead;
    }
    Entity.prototype.toString = function() { return '<' + this.name + '>'; };
    Entity.prototype.update = function(elapsed) {
        if (this.ai)
            this.ai.update(elapsed);
        var forceLength = this.force.length();
        if (forceLength > this.mass * elapsed) { this.force.x = this.force.x / forceLength * (forceLength - this.mass * elapsed);
            this.force.y = this.force.y / forceLength * (forceLength - this.mass * elapsed); } else
            this.force.zero();
        this.position.x += (this.velocity.x + this.force.x) * elapsed;
        this.position.y += (this.velocity.y + this.force.y) * elapsed;
        if (this.killWhenOffScreen && this.game) { var worldW = this.game.cameraWidth,
                worldH = this.game.WORLD.HEIGHT,
                center = this.center; if ((center.x < -worldW / 2 && this.velocity.x <= 0) || (center.x > worldW * 1.5 && this.velocity.x >= 0) || (center.y < -worldH / 2 && this.velocity.y <= 0) || (center.y > worldH * 1.5 && this.velocity.y >= 0)) { this.score = 0;
                this.dead = true; } }
    };
    Entity.prototype.collidesWith = function(other) {};
    Entity.prototype.draw = function(context, x, y) {};
    Entity.prototype.add = function() {};
    Entity.prototype.remove = function() {};
    Object.defineProperties(Entity.prototype, {
        'center': {
            'get': function() {
                if (this.box) { this._center.set(this.position.x + this.box.x + this.box.width / 2, this.position.y + this.box.y + this.box.height / 2); return this._center; } else
                    return this.position;
            }
        }
    });
    return Entity;
});
define('skytte/particles/particle', ['nebula/numbers', 'skytte/vector2', 'skytte/entity'], function(numbers, Vector2, Entity) {
    'use strict';

    function Particle(kwargs) { this.emitter = kwargs.emitter;
        this.position = new Vector2(kwargs.x, kwargs.y);
        this.velocity = new Vector2(kwargs.vx || 0, kwargs.vy || 0);
        this.force = new Vector2(kwargs.fx || 0, kwargs.fy || 0);
        this.mass = kwargs.mass || 0;
        this.dead = typeof kwargs.dead === 'undefined' ? false : kwargs.dead;
        this.life = this.time = kwargs.life;
        this.game = kwargs.game;
        this.sprite = PIXI.Sprite.fromImage(kwargs.texture);
        this.sprite.anchor.set(0.5, 0.5);
        this.tint = (typeof kwargs.tint === 'number') ? kwargs.tint : 0xffffff;
        this.size = kwargs.size; };
    Particle.prototype = Object.create(Entity.prototype);
    Particle.prototype.update = function(elapsed) {
        if (Math.abs(this.force.x) - this.mass * elapsed <= 0)
            this.force.x = 0;
        else
            this.force.x -= Math.sign(this.force.x) * this.mass * elapsed;
        if (Math.abs(this.force.y) - this.mass * elapsed <= 0)
            this.force.y = 0;
        else
            this.force.y -= Math.sign(this.force.y) * this.mass * elapsed;
        this.position.x += (this.velocity.x + this.force.x) * elapsed;
        this.position.y += (this.velocity.y + this.force.y) * elapsed;
        this.time -= elapsed;
        this.p = Math.max(0, this.time / this.life);
        if (this.time <= 0)
            this.dead = true;
    };
    Particle.prototype.render = function(elapsed) { this.sprite.position.x = this.position.x;
        this.sprite.position.y = this.position.y;
        this.sprite.width = this.size;
        this.sprite.height = this.size;
        this.sprite.tint = this.tint; };
    Particle.prototype.add = function(game, layer) { layer.addChild(this.sprite); };
    Particle.prototype.remove = function() { this.sprite.parent.removeChild(this.sprite); };
    return Particle;
});
define('skytte/particles/emitter', ['skytte/utils', 'nebula/numbers', 'skytte/entity', 'skytte/particles/particle'], function(utils, numbers, Entity, Particle) {
    'use strict';
    var DEFAULTS = { 'spawnCount': 0, 'spawnSpeed': 0, 'spawn': true, 'time': 0, 'particle': { 'offsetX': 0, 'offsetY': 0, 'spreadX': 0, 'spreadY': 0, 'direction': 0, 'directionSpread': 0, 'size': 1, 'sizeSpread': 0, 'vx': 0, 'vy': 0, 'speed': 0, 'speedSpread': 0, 'mass': 0, 'life': 0, 'tint': 0xffffff } };

    function Emitter(game, x, y, kwargs) {
        Entity.call(this, game, 'EmitterEntity', x, y, kwargs);
        kwargs = utils.merge(DEFAULTS, kwargs);
        this.container = new PIXI.Sprite();
        this.container.anchor.set(0.5, 0.5);
        this.spawnTime = 0;
        this.spawnCount = kwargs.spawnCount;
        this.spawnSpeed = kwargs.spawnSpeed;
        this.spawn = Boolean(kwargs.spawn);
        this.particle = kwargs.particle;
        this.stopped = false;
        if (kwargs.life)
            this.life = this.time = kwargs.life;
        if (kwargs.tints)
            this.tints = kwargs.tints;
        this.particleTime = 1 / this.spawnSpeed;
        this.particles = [];
    };
    Emitter.prototype = Object.create(Entity.prototype);
    Emitter.prototype.spawnParticle = function() { var direction = numbers.radians(this.particle.direction + (Math.random() - 0.5) * this.particle.directionSpread); var particleConfig = { 'game': this.game, 'emitter': this, 'life': this.particle.life * (Math.random() + 0.5), 'x': this.position.x + this.particle.offsetX + (Math.random() - 0.5) * this.particle.spreadX, 'y': this.position.y + this.particle.offsetY + (Math.random() - 0.5) * this.particle.spreadY, 'size': this.particle.size + (Math.random() - 0.5) * this.particle.sizeSpread, 'vx': this.particle.vx + Math.cos(direction) * (this.particle.speed + (Math.random() - 0.5) * this.particle.speedSpread), 'vy': this.particle.vy + Math.sin(direction) * (this.particle.speed + (Math.random() - 0.5) * this.particle.speedSpread), 'tint': this.particle.tint, 'mass': this.particle.mass, 'texture': this.particle.texture }; var particle = new Particle(particleConfig);
        this.particles.push(particle);
        particle.add(this.game, this.container.parent); return particle; };
    Emitter.prototype.stop = function() { this.stopped = true; };
    Emitter.prototype.update = function(elapsed) {
        Entity.prototype.update.call(this, elapsed);
        if (!this.stopped) {
            if (this.spawn && !this.spawnCount) {
                this.spawnTime += elapsed;
                var particlesToGenerate = Math.floor(this.spawnTime / this.particleTime);
                for (var i = 0; i < particlesToGenerate; i++)
                    this.spawnParticle();
                this.spawnTime -= particlesToGenerate * this.particleTime;
            }
            if (!this.spawn && this.spawnCount) {
                for (var i = 0; i < this.spawnCount; i++)
                    this.spawnParticle();
                this.stopped = true;
            }
        }
        var i = this.particles.length;
        while (--i >= 0)
            if (!this.particles[i].dead) {
                if (this.particle.update)
                    this.particle.update.call(this.particles[i], elapsed);
                else
                    this.particles[i].update(elapsed);
            } else { this.particles[i].remove();
                this.particles.splice(i, 1); }
        if (this.stopped && !this.particles.length)
            this.dead = true;
        this.time -= elapsed;
        if (this.life) {
            this.p = Math.max(0, this.time / this.life);
            if (this.time <= 0)
                this.dead = true;
        }
    };
    Emitter.prototype.render = function(elapsed) {
        this.container.position.x = this.position.x;
        this.container.position.y = this.position.y;
        if (this.particle.render)
            for (var i = 0; i < this.particles.length; i++)
                this.particle.render.call(this.particles[i], elapsed);
        else
            for (var i = 0; i < this.particles.length; i++)
                this.particles[i].render(elapsed);
    };
    Emitter.prototype.add = function(game, layer) {
        layer.addChild(this.container);
        for (var i = 0; i < this.particles.length; i++)
            this.particles[i].add(game, this.container);
    };
    Emitter.prototype.remove = function() {
        for (var i = 0; i < this.particles.length; i++)
            this.particles[i].remove();
        this.container.parent.removeChild(this.container);
    };
    return Emitter;
});
define('skytte/particles/mushroom', ['skytte/utils', 'skytte/particles/emitter'], function(utils, Emitter) {
    'use strict';

    function MushroomEmitter(game, kwargs) {
        kwargs = utils.merge(MushroomEmitter.DEFAULTS, kwargs);
        Emitter.call(this, game, 0, 0, kwargs);
        this.textures = [];
        for (var i = 0; i < kwargs.textures.length; i++)
            this.textures.push(PIXI.Texture.fromImage(kwargs.textures[i]));
        this.container.tint = kwargs.tint;
        this.container.anchor.y = 1;
        this.reset(true);
    }
    MushroomEmitter.DEFAULTS = {
        'vx': -140,
        'spawnSpeed': 1,
        'particle': {
            'offsetX': 0,
            'offsetY': -140,
            'spreadX': 20,
            'direction': 270,
            'directionSpread': 90,
            'size': 1.25,
            'sizeSpread': 0.5,
            'vx': 0,
            'vy': -8,
            'speed': 10,
            'speedSpread': 15,
            'life': 4,
            'update': function(elapsed) {
                this.update(elapsed);
                if (typeof this._originalSize === 'undefined')
                    this._originalSize = this.size;
                this.size = this._originalSize * this.p;
            }
        }
    };
    MushroomEmitter.prototype = Object.create(Emitter.prototype);
    MushroomEmitter.prototype.reset = function(firstTime) {
        this.container.texture = this.textures[Math.floor(Math.random() * this.textures.length)];
        this.position.x = this.game.cameraWidth * Math.random();
        if (!firstTime)
            this.position.x += this.game.cameraWidth;
        this.position.y = this.game.WORLD.FULL_HEIGHT + Math.random() * 30;
    };
    MushroomEmitter.prototype.update = function(elapsed) {
        Emitter.prototype.update.call(this, elapsed);
        if (this.position.x + this.container.width < 0)
            this.reset(false);
    };
    MushroomEmitter.prototype.add = function(game, layer) { layer.addChild(this.container); };
    MushroomEmitter.prototype.remove = function() { this.container.parent.removeChild(this.container); };
    return MushroomEmitter;
});
define('skytte/weapons/weapon', ['nebula/numbers', 'nebula/easings', 'skytte/vector2', 'skytte/tween', 'skytte/entity'], function(numbers, easings, Vector2, Tween, Entity) {
    function Weapon(game, ownerOrTeam, x, y, kwargs) {
        Entity.call(this, game, 'WeaponEntity', x, y, kwargs);
        if (kwargs.fireSound)
            this.fireSound = this.game.getResource(kwargs.fireSound);
        this.fireSoundVolume = typeof kwargs.fireSoundVolume !== 'undefined' ? kwargs.fireSoundVolume : 1;
        this.sprite = PIXI.Sprite.fromImage(kwargs.texture);
        this.hitSprite = PIXI.Sprite.fromImage(kwargs.texture);
        this.hitSprite.alpha = 0;
        this.hitSprite.blendMode = PIXI.BLEND_MODES.ADD;
        this.sprite.addChild(this.hitSprite);
        this.direction = kwargs.direction || 0;
        if (typeof ownerOrTeam === 'number')
            this.team = ownerOrTeam;
        else { this.owner = ownerOrTeam;
            this.team = this.owner.team; }
        this.rateOfFire = kwargs.rateOfFire;
        this.barrelOffset = new Vector2(kwargs.barrelOffset[0], kwargs.barrelOffset[1]);
        this.damage = kwargs.damage;
        this._originalDamage = -1;
        this.level = kwargs.level || 1;
        this.delay = 0;
        this.shooting = false;
        this._barrel = new Vector2();
        if (this.rateOfFire > 0) { this.recoil = new Tween(0, 3, numbers.clamp(1000 / this.rateOfFire / 2, 100, 500), easings.quadratic.in);
            this.recoil.toEnd(); }
    }
    Weapon.prototype = Object.create(Entity.prototype);
    Weapon.prototype.spawnProjectile = function() {
        if (this.fireSound)
            this.fireSound.play({ 'volume': this.fireSoundVolume });
    };
    Weapon.prototype.startShooting = function() { this.shooting = true;
        this.delay = 1000 / this.rateOfFire / 1000; };
    Weapon.prototype.stopShooting = function() { this.shooting = false; };
    Weapon.prototype.update = function(elapsed) {
        if (this.shooting && (this.delay <= 0 || this.rateOfFire <= 0)) { this.spawnProjectile(); if (this.recoil) { this.recoil.restart();
                this.delay = 1000 / this.rateOfFire / 1000; } }
        if (this.recoil)
            this.recoil.update(elapsed);
        this.delay = Math.max(0, this.delay - elapsed);
    };
    Weapon.prototype.render = function(elapsed) { var recoilOffsetX = Math.cos(numbers.radians(this.direction)); var recoilOffsetY = (this.direction === 90 || this.direction === 270) ? -1 : Math.sin(numbers.radians(this.direction));
        this.sprite.position.x = this.position.x + (this.recoil ? this.recoil.value : 3) * recoilOffsetX;
        this.sprite.position.y = this.position.y + (this.recoil ? this.recoil.value : 3) * recoilOffsetY;
        this.sprite.rotation = -this.sprite.parent.rotation;
        this.sprite.tint = this.owner.sprite.tint;
        this.hitSprite.alpha = this.owner.hit.value; };
    Weapon.prototype.add = function(game, layer) { layer.addChild(this.sprite); };
    Weapon.prototype.remove = function(game, layer) {
        if (this.sprite.parent)
            this.sprite.parent.removeChild(this.sprite);
    };
    Weapon.prototype.draw = function(context, x, y) {
        var dx, dy;
        var recoilOffsetX = Math.cos(numbers.radians(this.direction));
        var recoilOffsetY = Math.sin(numbers.radians(this.direction));
        if (this.recoil)
            dx = Math.floor(x + this.position.x + this.recoil.value * recoilOffsetX);
        else
            dx = Math.floor(x + this.position.x + 3 * recoilOffsetX);
        if (this.recoil)
            dy = Math.floor(y + this.position.y + this.recoil.value * recoilOffsetY);
        else
            dy = Math.floor(y + this.position.y + 3 * recoilOffsetY);
        this.sprite.draw(context, dx, dy);
        if (this.owner.hit.value) { context.save();
            context.globalAlpha = this.owner.hit.value;
            this.hitSprite.draw(context, dx, dy);
            context.restore(); }
        if (this.game.debug) { context.save();
            context.fillStyle = '#ff0';
            context.fillRect(x + this.position.x + this.barrelOffset.x - 1, y + this.position.y + this.barrelOffset.y - 1, 3, 3);
            context.restore(); }
    };
    Object.defineProperties(Weapon.prototype, { 'barrel': { 'get': function() { this._barrel.set(this.position.x + this.owner.position.x + this.barrelOffset.x, this.position.y + this.owner.position.y + this.barrelOffset.y); return this._barrel; } } });
    return Weapon;
});
define('skytte/weapons/projectile', ['nebula/numbers', 'skytte/entity'], function(numbers, Entity) {
    'use strict';
    var settings = require('settings');
    var DEBUG = settings('DEBUG');

    function Projectile(game, x, y, kwargs) {
        Entity.call(this, game, 'Projectile', x, y, kwargs);
        this.weapon = kwargs.weapon;
        this.damage = kwargs.damage;
        this.sprite = new PIXI.Sprite();
        if (kwargs.texture)
            this.sprite.texture = PIXI.Texture.fromImage(kwargs.texture);
        this.sprite.anchor.set(0.5, 0.5);
        this.size = typeof kwargs.size === 'undefined' ? 1 : kwargs.size;
        this.angle = typeof kwargs.angle === 'undefined' ? 0 : kwargs.angle;
        if (this.box) { this.box.x = -this.box.width / 2;
            this.box.y = -this.box.height / 2; }
        if (DEBUG && this.polygon);
    };
    Projectile.prototype = Object.create(Entity.prototype);
    Projectile.prototype.explode = function() { this.dead = true; };
    Projectile.prototype.collidesWith = function(other) {
        var ShipEntity = require('skytte/entities/ship');
        if (other instanceof ShipEntity && this.team !== other.team)
            this.explode();
    };
    Projectile.prototype.render = function(elapsed) { this.sprite.position.x = this.position.x;
        this.sprite.position.y = this.position.y;
        this.sprite.rotation = numbers.radians(this.angle);
        this.sprite.scale.set(this.size, this.size); };
    Projectile.prototype.add = function(game, layer) { layer.addChild(this.sprite); };
    Projectile.prototype.remove = function() { this.sprite.parent.removeChild(this.sprite); };
    return Projectile;
});
define('skytte/weapons/plasma', ['settings', 'nebula/numbers', 'skytte/bounding_box', 'skytte/polygon', 'skytte/entity', 'skytte/weapons/weapon', 'skytte/weapons/projectile'], function(settings, numbers, BoundingBox, Polygon, Entity, Weapon, Projectile) {
    'use strict';

    function PlasmaProjectile(game, x, y, kwargs) { Projectile.apply(this, arguments);
        this.sprite.blendMode = PIXI.BLEND_MODES.ADD;
        this.rotationSpeed = -360;
        this.explodeSound = kwargs.explodeSound; }
    PlasmaProjectile.prototype = Object.create(Projectile.prototype);
    PlasmaProjectile.prototype.explode = function() { Projectile.prototype.explode.call(this);
        this.game.addExplosion(this.position.x, this.position.y, 50, this.damage, this.team);
        this.explodeSound.play({ 'volume': settings('PLASMA_EXPLODE_VOLUME', 1) }); };
    PlasmaProjectile.prototype.update = function(elapsed) { Projectile.prototype.update.call(this, elapsed);
        this.angle += this.rotationSpeed * Math.sign(this.velocity.x) * elapsed; };

    function PlasmaWeapon(game, ownerOrTeam, x, y, kwargs) { Weapon.apply(this, arguments);
        this.projectileExplodeSound = this.game.getResource(kwargs.projectileExplodeSound);
        this.projectileTexture = kwargs.projectileTexture;
        this.initialProjectileSpeed = 350;
        this.projectileBox = BoundingBox.fromString('-10,-10 20,20');
        this.projectilePolygon = Polygon.fromBox(this.projectileBox); };
    PlasmaWeapon.prototype = Object.create(Weapon.prototype);
    PlasmaWeapon.prototype.spawnProjectile = function() { var x = this.position.x + this.owner.position.x + this.barrelOffset.x; var y = this.position.y + this.owner.position.y + this.barrelOffset.y; var config = { 'vx': Math.cos(numbers.radians(this.direction)) * this.initialProjectileSpeed, 'explodeSound': this.projectileExplodeSound, 'texture': this.projectileTexture, 'box': this.projectileBox, 'polygon': this.projectilePolygon, 'damage': this.damage, 'team': this.team }; var bullet = new PlasmaProjectile(this.game, x, y, config);
        this.game.queueEntity(bullet);
        Weapon.prototype.spawnProjectile.call(this); };
    return { 'PlasmaWeapon': PlasmaWeapon, 'PlasmaProjectile': PlasmaProjectile };
});
define('skytte/weapons/storm', ['nebula/numbers', 'skytte/bounding_box', 'skytte/polygon', 'skytte/weapons/weapon', 'skytte/weapons/projectile'], function(numbers, BoundingBox, Polygon, Weapon, Projectile) {
    'use strict';
    var PROJECTILE_BOX = BoundingBox.fromString('-5,-5 10,10');
    var PROJECTILE_POLYGON = Polygon.fromBox(PROJECTILE_BOX);

    function StormProjectile() { this.box = PROJECTILE_BOX;
        this.polygon = PROJECTILE_POLYGON;
        Projectile.apply(this, arguments);
        this.sprite.blendMode = PIXI.BLEND_MODES.ADD; }
    StormProjectile.prototype = Object.create(Projectile.prototype);

    function StormWeapon(game, ownerOrTeam, x, y, kwargs) { Weapon.apply(this, arguments);
        this.projectileSpread = kwargs.projectileSpread || 100;
        this.projectileCount = kwargs.projectileCount || 3;
        this.projectileTexture = kwargs.projectileTexture;
        this.initialProjectileSpeed = 700; };
    StormWeapon.prototype = Object.create(Weapon.prototype);
    StormWeapon.prototype.spawnProjectile = function() {
        var x = this.position.x + this.owner.position.x + this.barrelOffset.x;
        var y = this.position.y + this.owner.position.y + this.barrelOffset.y;
        var vx = this.initialProjectileSpeed * .75;
        var vy = -this.projectileSpread / 2;
        var vyi = this.projectileSpread / (this.projectileCount - 1);
        var config;
        for (var i = 0; i < this.projectileCount; i++) { config = { 'texture': this.projectileTexture, 'vx': vx + Math.random() * this.initialProjectileSpeed / 2, 'vy': vy + i * vyi, 'damage': this.damage, 'team': this.team };
            this.game.queueEntity(new StormProjectile(this.game, x, y, config)); }
        Weapon.prototype.spawnProjectile.call(this);
    };
    return { 'StormWeapon': StormWeapon, 'StormProjectile': StormProjectile };
});
define('skytte/weapons/laser', ['nebula/numbers', 'skytte/bounding_box', 'skytte/polygon', 'skytte/weapons/weapon', 'skytte/weapons/projectile', 'skytte/weapons/storm'], function(numbers, BoundingBox, Polygon, Weapon, Projectile, storm) {
    'use strict';

    function LaserWeapon(game, ownerOrTeam, x, y, kwargs) {
        Weapon.apply(this, arguments);
        this.projectileTexture = kwargs.projectileTexture;
        if (typeof kwargs.projectileSpeed !== 'undefined')
            this.projectileSpeed = kwargs.projectileSpeed;
        else { this.projectileSpeedX = kwargs.projectileSpeedX;
            this.projectileSpeedY = kwargs.projectileSpeedY; }
        this.projectileAngle = kwargs.projectileAngle || 0;
    };
    LaserWeapon.prototype = Object.create(Weapon.prototype);
    LaserWeapon.prototype.spawnProjectile = function() {
        var dir = numbers.radians(this.direction);
        var x = this.position.x + this.owner.position.x + this.barrelOffset.x;
        var y = this.position.y + this.owner.position.y + this.barrelOffset.y;
        var vx, vy;
        if (typeof this.projectileSpeed !== 'undefined') { vx = this.projectileSpeed * Math.cos(dir);
            vy = this.projectileSpeed * Math.sin(dir); } else { vx = this.projectileSpeedX;
            vy = this.projectileSpeedY; }
        var config = { 'texture': this.projectileTexture, 'team': this.team, 'vx': vx, 'vy': vy, 'damage': this.damage, 'angle': this.projectileAngle };
        var bullet = new storm.StormProjectile(this.game, x, y, config);
        this.game.queueEntity(bullet);
        Weapon.prototype.spawnProjectile.call(this);
    };
    return { 'LaserWeapon': LaserWeapon };
});
define('skytte/weapons/ray', ['nebula/numbers', 'skytte/vector2', 'skytte/per_second', 'skytte/polygon', 'skytte/beam', 'skytte/entity', 'skytte/weapons/weapon', 'skytte/weapons/projectile'], function(numbers, Vector2, PerSecond, Polygon, Beam, Entity, Weapon, Projectile) {
    'use strict';

    function RayProjectile(game, x, y, kwargs) { Projectile.apply(this, arguments);
        this.sprite1 = PIXI.Sprite.fromImage('electro_flash.png');
        this.sprite1.blendMode = PIXI.BLEND_MODES.ADD;
        this.sprite1.tint = kwargs.beamTint;
        this.sprite1.alpha = 0.75;
        this.sprite1.anchor.set(0.5, 0.5);
        this.sprite1.scale.set(1 / 3, 1 / 3);
        this.sprite.addChild(this.sprite1);
        this.sprite2 = PIXI.Sprite.fromImage('electro_flash.png');
        this.sprite2.blendMode = PIXI.BLEND_MODES.ADD;
        this.sprite2.tint = kwargs.beamTint;
        this.sprite2.alpha = 0.75;
        this.sprite2.anchor.set(0.5, 0.5);
        this.sprite2.scale.set(1 / 3, 1 / 3);
        this.sprite2.position.set(this.game.WORLD.WIDTH, 0);
        this.sprite.addChild(this.sprite2);
        this.damagePerSecond = this.damage;
        this.damage = 0;
        this.beam = new Beam(kwargs.beamTint, 8, 2, 27);
        this.beam.start.x = 0;
        this.beam.start.y = 0;
        this.beam.end.x = this.game.WORLD.WIDTH;
        this.beam.end.y = 0;
        this.sprite.addChild(this.beam);
        this.updateBeam = new PerSecond(20, this.beam.update.bind(this.beam)); }
    RayProjectile.prototype = Object.create(Projectile.prototype);
    RayProjectile.prototype.update = function(elapsed) {
        if (this.weapon.owner && this.weapon.owner.dead)
            this.dead = true;
        else { this.damage = this.damagePerSecond * elapsed;
            this.updateBeam.update(elapsed); }
    };
    RayProjectile.prototype.collidesWith = function(other) {};

    function RayWeapon(game, ownerOrTeam, x, y, kwargs) { Weapon.apply(this, arguments);
        this.projectile = new RayProjectile(this.game, 0, 0, { 'damage': this.damage, 'box': '-5,-5 10,10', 'team': this.team, 'weapon': this, 'beamTint': kwargs.beamTint });
        this.projectile.polygon = Polygon.fromBox(this.projectile.box);
        this.projectile.dead = true; };
    RayWeapon.prototype = Object.create(Weapon.prototype);
    RayWeapon.prototype.startShooting = function() {
        Weapon.prototype.startShooting.call(this);
        this.projectile.dead = false;
        if (!this.game.isEntityInGame(this.projectile)) {
            this.game.addEntity(this.projectile);
            if (!this._fireSoundInstance)
                this._fireSoundInstance = this.fireSound.playLoop({ 'volume': this.fireSoundVolume });
        }
        this._fireSoundInstance.play({ 'loop': -1, 'volume': this.fireSoundVolume });
    };
    RayWeapon.prototype.spawnProjectile = function() {};
    RayWeapon.prototype.stopShooting = function() { Weapon.prototype.stopShooting.call(this);
        this.projectile.dead = true;
        this._fireSoundInstance.stop(); };
    RayWeapon.prototype.update = function(elapsed) {
        Weapon.prototype.update.call(this, elapsed);
        if (this.shooting) {
            var x = this.position.x + this.owner.position.x + this.barrelOffset.x;
            var y = this.position.y + this.owner.position.y + this.barrelOffset.y;
            var w = this.game.WORLD.WIDTH;
            this.projectile.box.width = w;
            this.projectile.polygon.points[1].x = w;
            this.projectile.polygon.points[2].x = w;
            this.projectile.position.x = x;
            this.projectile.position.y = y;
            this.projectile.damagePerSecond = this.damage;
            if (!this.game.isEntityInGame(this.projectile))
                this.game.addEntity(this.projectile);
        } else if (this._fireSoundInstance)
            this._fireSoundInstance.stop();
    };
    return { 'RayWeapon': RayWeapon, 'RayProjectile': RayProjectile };
});
define('skytte/weapons/rockets', ['settings', 'nebula/numbers', 'skytte/bounding_box', 'skytte/polygon', 'skytte/particles/particle', 'skytte/particles/emitter', 'skytte/weapons/weapon', 'skytte/weapons/projectile'], function(settings, numbers, BoundingBox, Polygon, Particle, Emitter, Weapon, Projectile) {
    'use strict';
    var SMOKE = { 'spawnSpeed': 50, 'particle': { 'direction': 270, 'spreadY': 8, 'spreadX': 8, 'speed': 0, 'life': 0.5, 'texture': 'particle.png', 'render': function(elapsed) { this.size = this.p * 10;
                this.tint = this.p * 255 << 16 | this.p * 255 << 8 | this.p * 255 << 0;
                this.render(elapsed); } } };

    function RocketProjectile(game, x, y, kwargs) { Projectile.apply(this, arguments);
        this.turningSpeed = 135;
        this.minSpeed = kwargs.minSpeed;
        this.speed = kwargs.speed;
        this.maxSpeed = kwargs.maxSpeed;
        this.acceleration = kwargs.acceleration;
        this.explosionRadius = kwargs.explosionRadius;
        this.smoke = new Emitter(this.game, this.position.x, this.position.y, SMOKE);
        this.game.queueEntity(this.smoke);
        this.target = null;
        this.searchAfter = 50;
        this.distance = 0;
        this.maxDistance = game.cameraWidth * 2;
        this.explodeSound = kwargs.explodeSound;
        this.flyingSound = kwargs.flyingSound;
        this._flyingSoundInstance = this.flyingSound.playLoop({ 'volume': settings('ROCKET_FLYING_VOLUME', 1) }); }
    RocketProjectile.prototype = Object.create(Projectile.prototype);
    RocketProjectile.prototype.searchForTarget = function() { var ShipEntity = require('skytte/entities/ship'); var x = this.position.x,
            y = this.position.y,
            projectile = this; var result = this.game.findClosest(this.position.x, this.position.y, ShipEntity, 0, function(target) { return target.team && projectile.team !== target.team && target.position.x > projectile.position.x; });
        this.target = result.target; };
    RocketProjectile.prototype.explode = function() { if (!this.dead) { this.smoke.dead = this.dead = true;
            this.smoke.stop();
            this.smoke = null;
            this.game.addExplosion(this.position.x, this.position.y, this.explosionRadius, this.damage, this.team);
            this.explodeSound.play({ 'volume': settings('ROCKET_EXPLODE_VOLUME', 1) }); } };
    RocketProjectile.prototype.remove = function() { Projectile.prototype.remove.call(this);
        this._flyingSoundInstance.stop(); };
    RocketProjectile.prototype.update = function(elapsed) {
        if (this.distance >= this.searchAfter && (!this.target || (this.target && this.target.dead)))
            this.searchForTarget();
        if (this.target) {
            var targetCenter = this.target.center;
            var targetAngle = numbers.degrees(Math.atan2(targetCenter.y - this.position.y, targetCenter.x - this.position.x));
            var diff = targetAngle - this.angle;
            var dist = Math.abs(diff);
            if (diff > 180)
                diff -= 360;
            else if (diff < -180)
                diff += 360;
            var change = Math.sign(diff) * this.turningSpeed * elapsed;
            if (Math.abs(change) > dist)
                change = dist * Math.sign(change);
            this.angle += change;
        }
        var dir = numbers.radians(this.angle);
        this.speed = numbers.clamp(this.speed + this.acceleration * elapsed, this.minSpeed, this.maxSpeed);
        this.velocity.x = Math.cos(dir) * this.speed;
        this.velocity.y = Math.sin(dir) * this.speed;
        this.distance += (Math.abs(this.velocity.x) + Math.abs(this.velocity.y)) * elapsed;
        Projectile.prototype.update.call(this, elapsed);
        this.smoke.position.x = this.position.x + Math.cos(dir) * -10;
        this.smoke.position.y = this.position.y + Math.sin(dir) * -10;
        if (this.dead)
            this.smoke.dead = true;
        if (this.game.player) { var pan = this.game.getPanForPosition(this.position, this.game.player.center.x);
            this._flyingSoundInstance.setPan(pan); }
        this._flyingSoundInstance.setVolume((1 - this.distance / this.maxDistance) * .1);
        if (this.distance >= this.maxDistance || this.position.y <= 0 || this.position.y >= this.game.WORLD.HEIGHT - 1)
            this.explode();
    };

    function RocketsWeapon(game, ownerOrTeam, x, y, kwargs) { Weapon.apply(this, arguments);
        this.projectileTexture = kwargs.projectileTexture;
        this.rocketFlyingSound = this.game.getResource(kwargs.rocketFlyingSound);
        this.rocketExplodeSound = this.game.getResource(kwargs.rocketExplodeSound);
        this.minProjectileSpeed = 200;
        this.initialProjectileSpeed = 200;
        this.maxProjectileSpeed = 700;
        this.projectileAccel = 200;
        this.explosionRadius = 75;
        this.projectileBox = BoundingBox.fromString('-7,-7 14,14');
        this.projectilePolygon = Polygon.fromBox(this.projectileBox); };
    RocketsWeapon.prototype = Object.create(Weapon.prototype);
    RocketsWeapon.prototype.spawnProjectile = function() { var barrel = this.barrel; var config = { 'team': this.team, 'texture': this.projectileTexture, 'flyingSound': this.rocketFlyingSound, 'explodeSound': this.rocketExplodeSound, 'damage': this.damage, 'minSpeed': this.minProjectileSpeed, 'speed': this.initialProjectileSpeed, 'maxSpeed': this.maxProjectileSpeed, 'acceleration': this.projectileAccel, 'explosionRadius': this.explosionRadius, 'box': this.projectileBox, 'polygon': this.projectilePolygon };
        this.game.queueEntity(new RocketProjectile(this.game, barrel.x, barrel.y, config));
        Weapon.prototype.spawnProjectile.call(this); };
    return { 'RocketsWeapon': RocketsWeapon, 'RocketProjectile': RocketProjectile };
});
define('skytte/weapons/flak', ['nebula/numbers', 'skytte/bounding_box', 'skytte/polygon', 'skytte/weapons/weapon', 'skytte/weapons/projectile'], function(numbers, BoundingBox, Polygon, Weapon, Projectile) {
    function FlakProjectile(game, x, y, kwargs) { Projectile.apply(this, arguments);
        this.sprite.blendMode = PIXI.BLEND_MODES.ADD;
        this.time = kwargs.time; }
    FlakProjectile.prototype = Object.create(Projectile.prototype);
    FlakProjectile.prototype.update = function(elapsed) {
        Projectile.prototype.update.call(this, elapsed);
        this.time -= elapsed * 1000;
        if (this.time <= 0)
            this.dead = true;
    };

    function FlakWeapon(game, ownerOrTeam, x, y, kwargs) {
        Weapon.apply(this, arguments);
        this.projectileTexture = kwargs.projectileTexture;
        this.radius = 300;
        this.spread = 20;
        this.bullets = [];
        this.bulletTime = 200;
        if (typeof kwargs.projectileSpeed !== 'undefined') { this.projectileSpeed = kwargs.projectileSpeed;
            this.projectileSpeedX = this.projectileSpeed;
            this.projectileSpeedY = this.projectileSpeed; } else { this.projectileSpeedX = kwargs.projectileSpeedX || 0;
            this.projectileSpeedY = kwargs.projectileSpeedY || 0; }
        var bulletPolygon = Polygon.fromString('-3,-3 3,-3 3,3 -3,3');
        var bulletBox = BoundingBox.fromPolygon(bulletPolygon);
        for (var i = 0; i < 100; i++)
            this.bullets.push(new FlakProjectile(this.game, 0, 0, { 'texture': this.projectileTexture, 'box': bulletBox, 'team': this.team, 'polygon': bulletPolygon, 'weapon': this, 'dead': true }));
    };
    FlakWeapon.prototype = Object.create(Weapon.prototype);
    FlakWeapon.prototype.spawnProjectile = function() {
        var startX = this.position.x + this.owner.position.x + this.barrelOffset.x;
        var startY = this.position.y + this.owner.position.y + this.barrelOffset.y;
        var x, y, vx, vy, angle, distance, bullet;
        for (var i = 0; i < 50; i++) { bullet = this.bullets[i]; if (bullet.dead) { angle = this.direction + Math.round(Math.random() * this.spread * 2) - this.spread;
                distance = Math.random();
                vx = Math.cos(numbers.radians(angle));
                vy = Math.sin(numbers.radians(angle));
                x = vx * distance * this.radius;
                y = vy * distance * this.radius;
                bullet.size = 2 - distance;
                bullet.position.x = startX + x;
                bullet.position.y = startY + y;
                bullet.velocity.x = this.projectileSpeedX + vx * 50 * Math.random();
                bullet.velocity.y = this.projectileSpeedY + vy * 50 * Math.random();
                bullet.time = 50 + this.bulletTime * Math.random() * 2;
                bullet.damage = this.damage * distance;
                bullet.dead = false;
                this.game.queueEntity(bullet); } }
        Weapon.prototype.spawnProjectile.call(this);
    };
    return { 'FlakWeapon': FlakWeapon, 'FlakProjectile': FlakProjectile };
});
define('skytte/weapons/electro', ['skytte/utils', 'nebula/numbers', 'skytte/vector2', 'skytte/per_second', 'skytte/bounding_box', 'skytte/polygon', 'skytte/beam', 'skytte/entity', 'skytte/weapons/weapon', 'skytte/weapons/projectile'], function(utils, numbers, Vector2, PerSecond, BoundingBox, Polygon, Beam, Entity, Weapon, Projectile) {
    'use strict';

    function ElectroProjectile(game, x, y, kwargs) { Projectile.apply(this, arguments);
        this.sprite.blendMode = PIXI.BLEND_MODES.ADD;
        this.damagePerSecond = this.damage;
        this.barrelOffset = kwargs.barrelOffset;
        this.damage = 0;
        this.beam = new Beam(kwargs.beamTint, 12, 2, 9);
        this.target = null;
        this.updateBeam = new PerSecond(20, this.beam.update.bind(this.beam)); }
    ElectroProjectile.prototype = Object.create(Projectile.prototype);
    ElectroProjectile.prototype.setTarget = function(target) { this.target = target;
        this.updateBeamPosition();
        this.beam.update(); };
    ElectroProjectile.prototype.updateBeamPosition = function() { if (this.target) { var targetCenter = this.target.center,
                barrel = this.weapon.barrel;
            this.beam.start.x = barrel.x;
            this.beam.start.y = barrel.y;
            this.position.x = this.beam.end.x = targetCenter.x + Math.random() * 20 - 10;
            this.position.y = this.beam.end.y = targetCenter.y + Math.random() * 20 - 10; } };
    ElectroProjectile.prototype.update = function(elapsed) {
        if (this.weapon.owner && this.weapon.owner.dead) { this.dead = true;
            this.target = null; }
        this.damage = this.damagePerSecond * elapsed;
        Projectile.prototype.update.call(this, elapsed);
    };
    ElectroProjectile.prototype.render = function(elapsed) {
        if (this.target) { this.updateBeamPosition();
            this.updateBeam.update(elapsed); }
        this.sprite.alpha = 0.25 + Math.random() * 0.75;
        Projectile.prototype.render.call(this, elapsed);
    };
    ElectroProjectile.prototype.collidesWith = function(other) {};
    ElectroProjectile.prototype.add = function(game, layer) { layer.addChild(this.beam);
        layer.addChild(this.sprite); };
    ElectroProjectile.prototype.remove = function() {
        if (this.sprite.parent)
            this.sprite.parent.removeChild(this.sprite);
        if (this.beam.parent)
            this.beam.parent.removeChild(this.beam);
    };

    function ElectroWeapon(game, ownerOrTeam, x, y, kwargs) {
        Weapon.apply(this, arguments);
        this.radius = kwargs.radius;
        this.projectiles = [];
        var bulletPolygon = Polygon.fromString('-10,-10 10,-10 10,10 -10,10');
        var bulletBox = BoundingBox.fromPolygon(bulletPolygon);
        var config, i, projectile
        for (i = 0; i < kwargs.rayCount; i++) { config = { 'box': bulletBox, 'polygon': bulletPolygon, 'texture': kwargs.projectileFlashTexture, 'damage': kwargs.damage, 'barrelOffset': this.barrelOffset, 'team': this.team, 'weapon': this, 'beamTint': kwargs.beamTint };
            projectile = new ElectroProjectile(this.game, this.position.x, this.position.y, config);
            projectile.dead = true;
            this.projectiles.push(projectile); }
        this.flash = PIXI.Sprite.fromImage('electro_flash.png');
        this.flash.anchor.set(0.5, 0.5);
        this.flash.scale.set(0.5, 0.5);
        this.flash.blendMode = PIXI.BLEND_MODES.ADD;
        this.flash.position.set(this.barrelOffset.x - 3, this.barrelOffset.y);
        this.flash.alpha = 0;
        this.sprite.addChild(this.flash);
        this._fireSoundInstance = this.fireSound.getInstance();
    };
    ElectroWeapon.prototype = Object.create(Weapon.prototype);
    ElectroWeapon.prototype.spawnProjectile = function() {};
    ElectroWeapon.prototype.stopShooting = function() {
        Weapon.prototype.stopShooting.call(this);
        for (var i = 0; i < this.projectiles.length; i++) { this.projectiles[i].dead = true;
            this.projectiles[i].target = null; }
        this._fireSoundInstance.stop();
    };
    ElectroWeapon.prototype.update = function(elapsed) {
        Weapon.prototype.update.call(this, elapsed);
        var oneRayAtLeast = false;
        if (this.shooting) {
            var ShipEntity = require('skytte/entities/ship');
            var targets = [],
                weapon = this;
            var weaponX = this.position.x + this.owner.position.x + this.barrelOffset.x;
            var weaponY = this.position.y + this.owner.position.y + this.barrelOffset.y;
            for (var i = 0; i < this.projectiles.length; i++) {
                var result = this.game.findClosest(weaponX, weaponY, ShipEntity, 0, function(target) { return target.team && weapon.team !== target.team && !utils.inArray(target, targets); });
                this.projectiles[i].damagePerSecond = this.damage;
                if (result.target && result.distance <= this.radius) {
                    if (this.projectiles[i].target !== result.target)
                        this.projectiles[i].setTarget(result.target);
                    if (this.projectiles[i].dead) { this.game.queueEntity(this.projectiles[i], 0, this.game.layers.middleground2);
                        this.projectiles[i].dead = false; }
                    targets.push(result.target);
                    oneRayAtLeast = true;
                } else { this.projectiles[i].dead = true;
                    this.projectiles[i].target = null; }
            }
        }
        if (oneRayAtLeast) {
            this.flash.alpha = 0.25 + Math.random() * 0.75;
            if (this._fireSoundInstance.playState !== createjs.Sound.PLAY_SUCCEEDED)
                this._fireSoundInstance.play({ 'loop': -1, 'volume': this.fireSoundVolume });
        } else { this.flash.alpha = 0;
            this._fireSoundInstance.stop(); }
        if (this.owner.dead)
            for (var i = 0; i < this.projectiles.length; i++) { this.projectiles[i].dead = true;
                this.projectiles[i].target = null; }
    };
    return { 'ElectroWeapon': ElectroWeapon, 'ElectroProjectile': ElectroProjectile };
});
define('skytte/particles/explosion', ['skytte/utils', 'nebula/easings', 'skytte/bounding_box', 'skytte/polygon', 'skytte/weapons/projectile', 'skytte/particles/emitter'], function(utils, easings, BoundingBox, Polygon, Projectile, Emitter) {
    'use strict';

    function SmokeEmitter() { Emitter.apply(this, arguments);
        this.container = PIXI.Sprite.fromImage('particle.png');
        this.container.anchor.set(0.5, 0.5); }
    SmokeEmitter.prototype = Object.create(Emitter.prototype);
    SmokeEmitter.prototype.render = function(elapsed) { Emitter.prototype.render.call(this, elapsed);
        this.container.scale.set(this.p, this.p); };
    var CLOUD = {
        'spawn': false,
        'particle': {
            'directionSpread': 360,
            'life': 0.65,
            'texture': 'particle.png',
            'render': function(elapsed) {
                if (typeof this._originalSize === 'undefined')
                    this._originalSize = this.size;
                this.size = this._originalSize * this.p;
                var c = easings.quartic.out(this.p);
                this.tint = c * 255 << 16 | c * 255 << 8 | c * 255 << 0;
                this.render(elapsed);
            }
        }
    };
    var SMOKE = { 'spawnSpeed': 5, 'life': 1, 'particle': { 'direction': 270, 'life': 0.25, 'speed': 5, 'speedSpread': 2, 'texture': 'particle.png', 'render': function(elapsed) { this.size = 1 + this.p * this.emitter.p * 20;
                this.tint = this.p * 255 << 16 | this.p * 255 << 8 | this.p * 255 << 0;
                this.render(elapsed); } } };

    function Explosion(game, x, y, kwargs) { kwargs = kwargs || {};
        Projectile.call(this, game, x, y, kwargs);
        this.maxDamage = this.damage = kwargs.damage;
        this.life = 1;
        this.radius = kwargs.radius;
        this.box = new BoundingBox(-this.radius, -this.radius, this.radius * 2, this.radius * 2);
        this.polygon = Polygon.fromBox(this.box); }
    Explosion.prototype = Object.create(Projectile.prototype);
    Explosion.prototype.collidesWith = function(other) { var ShipEntity = require('skytte/entities/ship'); if (other instanceof ShipEntity && this.team !== other.team) { var otherCenter = other.center; var recoil = this.position.copy().sub(otherCenter); var distance = recoil.length();
            other.force.add(recoil.normalize().scale(-Math.max(0, this.radius - distance))); } };
    Explosion.prototype.update = function(elapsed) {
        this.life--;
        if (this.life < 0) {
            for (var i = 0; i < 6; i++) { var smoke = new SmokeEmitter(this.game, this.position.x, this.position.y, SMOKE);
                smoke.force.x = Math.random() * 400 - 200;
                smoke.force.y = Math.random() * 400 - 200;
                this.game.addEntity(smoke); }
            var size = this.radius / 3;
            var cloudConfig = utils.merge(CLOUD, { 'spawnCount': this.radius / 15, 'particle': { 'speed': size * 2, 'speedSpread': size, 'size': size, 'sizeSpread': size / 2 } });
            this.game.addEntity(new Emitter(this.game, this.position.x, this.position.y, cloudConfig));
            this.dead = true;
        } else
            Projectile.prototype.update.call(this, elapsed);
    };
    return Explosion;
});
define('skytte/entities/sprite', ['skytte/entity'], function(Entity) {
    'use strict';

    function SpriteEntity(game, x, y, kwargs) { Entity.call(this, game, 'SpriteEntity', x, y, kwargs);
        this.sprite = PIXI.Sprite.fromImage(kwargs.texture); }
    SpriteEntity.prototype = Object.create(Entity.prototype);
    SpriteEntity.prototype.update = function(elapsed) { Entity.prototype.update.call(this, elapsed); if (this.sprite) { this.sprite.position.x = this.position.x;
            this.sprite.position.y = this.position.y; } };
    SpriteEntity.prototype.add = function(game, layer) { layer.addChild(this.sprite); };
    SpriteEntity.prototype.remove = function() { this.sprite.parent.removeChild(this.sprite); };
    Object.defineProperties(SpriteEntity.prototype, { 'center': { 'get': function() { this._center.set(this.position.x + this.sprite.width / 2, this.position.y + this.sprite.height / 2); return this._center; } } });
    return SpriteEntity;
});
define('skytte/entities/background', ['skytte/entity'], function(Entity) {
    'use strict';

    function BackgroundEntity(game, kwargs) {
        Entity.call(this, game, 'BackgroundEntity', 0, 0, kwargs);
        this.align = kwargs.align;
        this.segments = [];
        this.chance = 'chance' in kwargs ? kwargs.chance : 1;
        this.textures = [];
        for (var i = 0; i < kwargs.textures.length; i++)
            this.textures.push(PIXI.Texture.fromImage(kwargs.textures[i]));
        this.container = new PIXI.Container();
        if ('scale' in kwargs)
            this.container.scale.set(kwargs.scale.x, kwargs.scale.y);
        if (this.align === BackgroundEntity.ALIGN_TOP)
            this.container.position.y = 0;
        else if (this.align === BackgroundEntity.ALIGN_MIDDLE)
            this.container.position.y = this.game.WORLD.FULL_HEIGHT / 2;
        else if (this.align === BackgroundEntity.ALIGN_BOTTOM)
            this.container.position.y = this.game.WORLD.FULL_HEIGHT;
        for (var i = 0; i < 4; i++)
            this.addSprite();
    }
    BackgroundEntity.ALIGN_TOP = 1;
    BackgroundEntity.ALIGN_MIDDLE = 2;
    BackgroundEntity.ALIGN_BOTTOM = 3;
    BackgroundEntity.prototype = Object.create(Entity.prototype);
    BackgroundEntity.prototype.addSprite = function() {
        var sprite = new PIXI.Sprite();
        sprite.visible = false;
        if (this.align === BackgroundEntity.ALIGN_TOP)
            sprite.anchor.y = 0;
        else if (this.align === BackgroundEntity.ALIGN_MIDDLE)
            sprite.anchor.y = 0.5;
        else if (this.align === BackgroundEntity.ALIGN_BOTTOM)
            sprite.anchor.y = 1;
        this.container.addChild(sprite);
        return sprite;
    };
    BackgroundEntity.prototype.getFirstSegment = function() {
        var minX = Infinity,
            best = null;
        for (var i = 0; i < this.container.children.length; i++)
            if (this.container.children[i].visible && this.container.children[i].position.x < minX) { best = this.container.children[i];
                minX = best.position.x; }
        return best;
    };
    BackgroundEntity.prototype.getLastSegment = function() {
        var maxX = -Infinity,
            best = null;
        for (var i = 0; i < this.container.children.length; i++)
            if (this.container.children[i].visible && this.container.children[i].position.x > maxX) { best = this.container.children[i];
                maxX = best.position.x; }
        return best;
    };
    BackgroundEntity.prototype.getFreeSegment = function() {
        for (var i = 0; i < this.container.children.length; i++)
            if (!this.container.children[i].visible)
                return this.container.children[i];
        return null;
    };
    BackgroundEntity.prototype.removeSegment = function(segment) {
        this.position.x += segment.width * this.container.scale.x;
        for (var i = 0; i < this.container.children.length; i++)
            if (this.container.children[i].visible)
                this.container.children[i].position.x -= segment.width;
        segment.visible = false;
        segment.texture = PIXI.Texture.EMPTY;
    };
    BackgroundEntity.prototype.addSegment = function() {
        var segment = this.getFreeSegment();
        if (!segment)
            segment = this.addSprite();
        var lastSegment = this.getLastSegment();
        segment.position.x = lastSegment ? lastSegment.position.x + lastSegment.width : 0;
        if (Math.random() >= this.chance) { segment.texture = PIXI.Texture.EMPTY;
            segment.width = this.game.cameraWidth / this.container.scale.x; } else {
            if (this.textures.length === 1)
                segment.texture = this.textures[0];
            else
                do { segment.texture = this.textures[Math.floor(Math.random() * this.textures.length)]; } while (lastSegment && segment.texture === lastSegment.texture);
            segment.scale.x = 1;
        }
        segment.visible = true;
    };
    BackgroundEntity.prototype.update = function(elapsed) {
        Entity.prototype.update.call(this, elapsed);
        this.dead = false;
        var first = this.getFirstSegment();
        if (first && this.position.x + first.position.x + first.width * this.container.scale.x < 0)
            this.removeSegment(first);
        var last = this.getLastSegment();
        if (!last || this.position.x + (last.position.x + last.width) * this.container.scale.x < this.game.cameraWidth)
            this.addSegment();
        this.container.position.x = this.position.x;
    };
    BackgroundEntity.prototype.add = function(game, layer) { layer.addChild(this.container); };
    BackgroundEntity.prototype.remove = function() {
        this.container.parent.removeChild(this.container);
        for (var i = 0; i < this.textures.length; i++)
            this.textures[i].baseTexture.dispose();
    };
    return BackgroundEntity;
});
define('skytte/entities/fog', ['nebula/numbers', 'skytte/entity'], function(numbers, Entity) {
    function FogEntity(game, kwargs) {
        Entity.call(this, game, 'FogEntity', 0, 0, kwargs);
        this.sprite = PIXI.Sprite.fromImage(kwargs.texture);
        if ('tint' in kwargs)
            this.sprite.tint = kwargs.tint;
        if ('scale' in kwargs)
            this.sprite.scale.set(kwargs.scale.x, kwargs.scale.y);
        this.killWhenOffScreen = false;
        this.velocity.x = -140;
        this.reset(true);
    }
    FogEntity.prototype = Object.create(Entity.prototype);
    FogEntity.prototype.reset = function(firstTime) {
        if (firstTime)
            this.position.x = this.game.cameraWidth * (Math.random() - .5) * 2;
        else
            this.position.x = this.game.cameraWidth + this.game.cameraWidth * Math.random();
        this.position.y = this.game.WORLD.HEIGHT - this.sprite.height / 2 - 80;
        this.angle = Math.random() * 360;
    };
    FogEntity.prototype.update = function(elapsed) {
        this.angle += 45 * elapsed;
        this.velocity.y = Math.cos(numbers.radians(this.angle)) * 40;
        Entity.prototype.update.call(this, elapsed);
        if (this.position.x + this.sprite.width < 0)
            this.reset(false);
        this.sprite.position.x = this.position.x;
        this.sprite.position.y = this.position.y;
    };
    FogEntity.prototype.add = function(game, layer) { layer.addChild(this.sprite); };
    FogEntity.prototype.remove = function() { this.sprite.parent.removeChild(this.sprite); };
    return FogEntity;
});
define('skytte/entities/ship', ['nebula/numbers', 'nebula/easings', 'skytte/tween', 'skytte/entity', 'skytte/weapons/projectile', 'skytte/particles/emitter', 'skytte/particles/explosion'], function(numbers, easings, Tween, Entity, Projectile, Emitter, Explosion) {
    'use strict';
    var settings = require('settings');
    var DEBUG = settings('DEBUG');

    function ShipEntity(game, x, y, kwargs) {
        Entity.call(this, game, 'ShipEntity', x, y, kwargs);
        if (kwargs.explosionSound)
            this.explosionSound = this.game.getResource(kwargs.explosionSound);
        this.sprite = PIXI.Sprite.fromImage(kwargs.texture);
        this.hitSprite = PIXI.Sprite.fromImage(kwargs.texture);
        this.hitSprite.alpha = 0;
        this.hitSprite.blendMode = PIXI.BLEND_MODES.ADD;
        this.sprite.addChild(this.hitSprite);
        if ('scale' in kwargs)
            this.sprite.scale.set(kwargs.scale.x, kwargs.scale.y);
        if (kwargs.invincibleShieldSprite)
            this.invincibleShieldSprite = this.game.getResource(kwargs.invincibleShieldSprite);
        this.health = this.maxHealth = kwargs.health;
        this.healthPerSecond = kwargs.healthPerSecond || 0;
        this.shield = this.maxShield = kwargs.shield;
        this.shieldPerSecond = kwargs.shieldPerSecond || 0;
        this.regenerationDelay = 1500;
        this.engines = [];
        if (kwargs.engines)
            for (var i = 0; i < kwargs.engines.length; i++)
                this.engines.push(new Emitter(this.game, kwargs.engines[i].x, kwargs.engines[i].y, kwargs.engines[i].emitter));
        this.weapons = [];
        if (kwargs.weapons)
            for (var i = 0; i < kwargs.weapons.length; i++)
                this.weapons.push(new kwargs.weapons[i].weapon.cls(this.game, this, kwargs.weapons[i].x, kwargs.weapons[i].y, kwargs.weapons[i].weapon));
        this.speed = kwargs.speed || 0;
        this.explosionRadius = kwargs.explosionRadius || 0;
        this.explosionDamage = kwargs.explosionDamage || 0;
        this.score = kwargs.score || 0;
        this.invincibleTime = kwargs.invincibleTime || 0;
        this.hit = new Tween(0, 0, 250, easings.quadratic.out);
        this.hit.toEnd();
        this.powerUps = kwargs.powerUps;
        this._invincibilitySound = this.game.getResource('soundPlayerInvincibility');
        this.angle = 0;
        this.shieldSprite = PIXI.Sprite.fromImage('shield.png');
        this.shieldSprite.anchor.set(0.5, 0.5);
        this.shieldSprite.position.set(this.box.x + this.box.width / 2, this.box.y + this.box.height / 2);
        this.shieldSprite.width = this.box.width * 1.4;
        this.shieldSprite.height = this.box.height * 1.4;
        this.shieldSprite.blendMode = PIXI.BLEND_MODES.ADD;
        this.sprite.addChild(this.shieldSprite);
        if (DEBUG);
    }
    ShipEntity.prototype = Object.create(Entity.prototype);
    ShipEntity.prototype.hasWeapon = function() { return this.weapons.length > 0; };
    ShipEntity.prototype.startShooting = function() {
        for (var i = 0; i < this.weapons.length; i++)
            this.weapons[i].startShooting();
    };
    ShipEntity.prototype.stopShooting = function() {
        for (var i = 0; i < this.weapons.length; i++)
            this.weapons[i].stopShooting();
    };
    ShipEntity.prototype.move = function(x, y) { this.velocity.x += this.speed * x;
        this.velocity.y += this.speed * y;
        numbers.clamp(this.velocity.x, -this.speed, this.speed);
        numbers.clamp(this.velocity.y, -this.speed, this.speed); };
    ShipEntity.prototype.update = function(elapsed) {
        var particle, i;
        this.regenerationDelay -= elapsed * 1000;
        if (this.regenerationDelay <= 0 && this.shieldPerSecond && this.maxShield)
            this.shield = Math.min(this.maxShield, this.shield + this.shieldPerSecond * elapsed);
        if (this.regenerationDelay <= 0 && this.healthPerSecond && this.maxShield)
            this.health = Math.min(this.maxHealth, this.health + this.healthPerSecond * elapsed);
        Entity.prototype.update.call(this, elapsed);
        this.hit.update(elapsed);
        if (this.hit.hasEnded && this.health > 0) { this.hit.begin = this.hit.change = 0;
            this.hit.toEnd(); }
        if (this === this.game.player) {
            for (i = 0; i < this.engines.length; i++) { this.engines[i].particle.direction = 180 + (this.velocity.y / this.speed) * 45;
                this.engines[i].particle.speed = 40 + 40 * (this.velocity.x / this.speed); }
            this.position.x = numbers.clamp(this.position.x, 0 - this.box.x - this.box.width / 2, this.game.cameraWidth - this.box.x - this.box.width);
            this.position.y = numbers.clamp(this.position.y, 0 - this.box.y, this.game.WORLD.HEIGHT - this.box.y - this.box.height);
            this.velocity.scale(1 - elapsed * 4);
        } else if (this.box) { if (this.position.y + this.box.y < 0 && this.velocity.y + this.force.y <= 0) { this.position.y = -this.box.y;
                this.velocity.y = Math.abs(this.velocity.y);
                this.force.y = Math.abs(this.force.y / 2); } else if (this.position.y + this.box.y + this.box.height > this.game.WORLD.HEIGHT && this.velocity.y + this.force.y >= 0) { this.position.y = this.game.WORLD.HEIGHT - this.box.y - this.box.height;
                this.velocity.y = -Math.abs(this.velocity.y);
                this.force.y = -Math.abs(this.force.y / 2); } }
        if (this === this.game.player)
            this.angle = this.speed ? this.velocity.y / this.speed * 5 : 0;
        else
            this.angle = this.speed ? this.velocity.y / this.speed * 15 : 0;
        if (this !== this.game.player)
            this.angle *= -1;
        for (i = 0; i < this.engines.length; i++)
            this.engines[i].update(elapsed);
        for (i = 0; i < this.weapons.length; i++)
            this.weapons[i].update(elapsed);
        this.invincibleTime = Math.max(0, this.invincibleTime - elapsed * 1000);
        if (this === this.game.player) {
            if (this.invincibleTime > 0) {
                if (!this._invincibilitySoundInstance)
                    this._invincibilitySoundInstance = this._invincibilitySound.playLoop({ 'volume': settings('SHIP_INVINCIBILITY_VOLUME', 1) });
            } else if (this._invincibilitySoundInstance) { this._invincibilitySoundInstance.stop();
                this._invincibilitySoundInstance = null; }
        }
    };
    ShipEntity.prototype.explode = function() {
        if (!this.dead) {
            this.dead = true;
            var center = this.center;
            if (this.explosionRadius) {
                this.game.addExplosion(center.x, center.y, this.explosionRadius, this.explosionDamage, this.game.PLAYER_TEAM);
                if (this.explosionSound)
                    this.explosionSound.play({ 'volume': settings('SHIP_EXPLODE_VOLUME', 1) });
            }
            if (this.powerUps && Math.random() <= this.powerUps.chance) { var powerUp = this.powerUps.choices[Math.floor(Math.random() * this.powerUps.choices.length)];
                powerUp.fx = (this.force.x + this.velocity.x) / 2;
                powerUp.fy = (this.force.y + this.velocity.y) / 2;
                this.game.makePowerUp(center.x, center.y, powerUp); }
        }
    };
    ShipEntity.prototype.detonate = function() {
        if (!this.dead) {
            this.dead = true;
            if (this.explosionRadius) {
                var center = this.center;
                this.game.addExplosion(center.x, center.y, this.explosionRadius, this.explosionDamage, this.game.ENEMY_TEAM);
                if (this.explosionSound)
                    this.explosionSound.play({ 'volume': settings('SHIP_EXPLODE_VOLUME', 1) });
            }
        }
    };
    ShipEntity.prototype.collidesWith = function(other) {
        if (!this.invincibleTime && other instanceof Projectile && other.team !== this.team) { this.regenerationDelay = 1500;
            this.health = numbers.clamp(this.health + Math.min(0, this.shield - other.damage), 0, this.maxHealth);
            this.shield = numbers.clamp(this.shield - other.damage, 0, this.maxShield); if (this.health > 0) { if (!this.hit.value) { this.hit.begin = .9;
                    this.hit.change = -this.hit.begin;
                    this.hit.restart(); } } else { this.hit.hasEnded = true;
                this.hit.value = .9;
                this.explode(); } } else if (other === this.game.player)
            this.detonate();
    };
    ShipEntity.prototype.render = function(elapsed) {
        this.sprite.position.x = this.position.x;
        this.sprite.position.y = this.position.y;
        this.sprite.rotation = numbers.radians(this.angle);
        var shieldAlpha = numbers.clamp(this.shield / this.maxShield + Math.random() * 0.75 - 0.375, 0.1, 1);
        this.shieldSprite.alpha = this.shield > 0 ? shieldAlpha : 0;
        this.shieldSprite.rotation = -numbers.radians(this.angle);
        if (this.health !== this.maxHealth) { var p = (this.health / this.maxHealth * 0.9 + 0.1) * 255;
            this.sprite.tint = Math.floor(p << 16 | p << 8 | p << 0); } else
            this.sprite.tint = 0xffffff;
        this.hitSprite.alpha = this.hit.value;
        for (var i = 0; i < this.weapons.length; i++)
            this.weapons[i].render(elapsed);
        for (var i = 0; i < this.engines.length; i++) { this.engines[i].position.x = this.position.x;
            this.engines[i].position.y = this.position.y;
            this.engines[i].render(elapsed); }
    };
    ShipEntity.prototype.add = function(game, layer) {
        layer.addChild(this.sprite);
        for (var i = 0; i < this.engines.length; i++)
            this.engines[i].add(game, layer);
        for (var i = 0; i < this.weapons.length; i++)
            this.weapons[i].add(game, this.sprite);
    };
    ShipEntity.prototype.remove = function() {
        this.stopShooting();
        if (this._invincibilitySoundInstance)
            this._invincibilitySoundInstance.stop();
        for (var i = 0; i < this.engines.length; i++)
            this.engines[i].remove();
        for (var i = 0; i < this.weapons.length; i++)
            this.weapons[i].remove();
        this.sprite.parent.removeChild(this.sprite);
    };
    return ShipEntity;
});
define('skytte/entities/mine', ['settings', 'skytte/vector2', 'nebula/numbers', 'skytte/entities/ship'], function(settings, Vector2, numbers, ShipEntity) {
    function MineEntity(game, x, y, kwargs) { ShipEntity.apply(this, arguments);
        this.detonateDamage = kwargs.detonateDamage;
        this.detonateRadius = kwargs.detonateRadius;
        this.angle = Math.random() * 360; }
    MineEntity.prototype = Object.create(ShipEntity.prototype);
    MineEntity.prototype.detonate = function() {
        if (!this.dead) {
            this.dead = true;
            var center = this.center;
            this.game.addExplosion(center.x, center.y, this.detonateRadius, this.detonateDamage, this.game.ENEMY_TEAM);
            if (this.explosionSound)
                this.explosionSound.play({ 'volume': settings('SHIP_EXPLODE_VOLUME', 1) });
        }
    };
    return MineEntity;
});
define('skytte/entities/swarm', ['nebula/numbers', 'skytte/entity', 'skytte/entities/ship'], function(numbers, Entity, ShipEntity) {
    function SwarmEntity(game, x, y, kwargs) { ShipEntity.apply(this, arguments); }
    SwarmEntity.prototype = Object.create(ShipEntity.prototype);
    return SwarmEntity;
});
define('skytte/entities/teleporter', ['skytte/entities/ship'], function(ShipEntity) {
    'use strict';

    function TeleporterEntity(game, x, y, kwargs) { ShipEntity.apply(this, arguments);
        this.teleportSound = this.game.getResource('soundShipTeleport'); }
    TeleporterEntity.prototype = Object.create(ShipEntity.prototype);
    TeleporterEntity.prototype.render = function(elapsed) { ShipEntity.prototype.render.call(this, elapsed);
        this.sprite.alpha = Math.ceil(this.ai.alpha * 10) % 2 ? 0.1 : 1; };
    return TeleporterEntity;
});
define('skytte/entities/turret', ['skytte/entity', 'skytte/entities/ship'], function(Entity, ShipEntity) {
    function TurretEntity(game, x, y, kwargs) { ShipEntity.apply(this, arguments); }
    TurretEntity.prototype = Object.create(ShipEntity.prototype);
    TurretEntity.prototype.update = function(elapsed) {
        this.regenerationDelay -= elapsed * 1000;
        if (this.regenerationDelay <= 0 && this.shieldPerSecond && this.maxShield)
            this.shield = Math.min(this.maxShield, this.shield + this.shieldPerSecond * elapsed);
        if (this.regenerationDelay <= 0 && this.healthPerSecond && this.maxShield)
            this.health = Math.min(this.maxHealth, this.health + this.healthPerSecond * elapsed);
        Entity.prototype.update.call(this, elapsed);
        this.hit.update(elapsed);
        if (this.hit.hasEnded && this.health > 0) { this.hit.begin = this.hit.change = 0;
            this.hit.toEnd(); }
        for (var i = 0; i < this.weapons.length; i++)
            this.weapons[i].update(elapsed);
    };
    return TurretEntity;
});
define('skytte/entities/cart', ['skytte/entity', 'skytte/entities/turret'], function(Entity, TurretEntity) {
    function CartEntity(game, x, y, kwargs) { TurretEntity.apply(this, arguments);
        this.verticalSpeed = kwargs.verticalSpeed; }
    CartEntity.prototype = Object.create(TurretEntity.prototype);
    CartEntity.prototype.draw = function(context, x, y) { var dx = Math.floor(this.position.x + x); var dy = Math.floor(this.position.y + y);
        this.drawShield(context, dx, dy);
        this.drawEngines(context, this.position.x + x, this.position.y + y);
        this.drawWeapons(context, this.position.x + x, this.position.y + y);
        this.drawShip(context, dx, dy);
        this.drawHit(context, dx, dy);
        Entity.prototype.draw.call(this, context, x, y); };
    return CartEntity;
});
define('skytte/entities/power_up', ['skytte/utils', 'nebula/numbers', 'nebula/easings', 'skytte/tween', 'skytte/vector2', 'skytte/entity'], function(utils, numbers, easings, Tween, Vector2, Entity) {
    'use strict';
    var settings = require('settings');
    var DEBUG = settings('DEBUG');

    function PowerUpEntity(game, x, y, kwargs) { Entity.call(this, game, 'PowerUpEntity', x, y, kwargs);
        utils._merge(this, kwargs);
        this.sprite = PIXI.Sprite.fromImage(kwargs.texture);
        this.sprite.anchor.set(0.5, 0.5);
        this.sound = kwargs.sound ? this.game.getResource(kwargs.sound) : null;
        this.soundVolume = typeof kwargs.soundVolume !== 'undefined' ? kwargs.soundVolume : 1;
        this.angle = Math.random() * 360;
        this.collectAnim = null;
        this.collectible = true;
        this.speed = 0;
        this.maxSpeed = 350;
        this.accel = 100;
        this.distance = new Vector2();
        this._originalVelocity = new Vector2(this.velocity.x, this.velocity.y); if (DEBUG); }
    PowerUpEntity.prototype = Object.create(Entity.prototype);
    PowerUpEntity.prototype.collect = function() {
        this.collectAnim = new Tween(1, -1, 750, easings.exponential.out);
        this.velocity.x = 0;
        this.velocity.y = -100;
        if (this.collectFunc)
            this.collectFunc.call(this, this.game);
        if (this.score)
            this.game.addScoreLabel(this, this.game.addCombo(this.score));
        if (this.sound)
            this.sound.play({ 'volume': this.soundVolume });
        this.score = 0;
    };
    PowerUpEntity.prototype.active = function(elapsed) {
        if (this.activeFunc)
            this.activeFunc.call(this, this.game, elapsed);
    };
    PowerUpEntity.prototype.expired = function() {
        if (this.expiredFunc)
            this.expiredFunc.call(this, this.game);
    };
    PowerUpEntity.prototype.collidesWith = function(other) {
        if (other === this.game.player && !this.collectAnim)
            this.game.collectPowerUp(this);
    };
    PowerUpEntity.prototype.update = function(elapsed) {
        if (this.collectAnim) {
            this.collectAnim.update(elapsed);
            if (this.collectAnim.hasEnded)
                this.dead = true;
        } else if (this.game.player) {
            var playerCenter = this.game.player.center;
            this.distance.set(playerCenter.x, playerCenter.y).sub(this.center);
            var length = this.distance.length();
            if (length <= 90)
                this.speed = this.maxSpeed;
            else
                this.speed = Math.max(this.speed - this.accel * elapsed, 0);
            this.velocity.set(this._originalVelocity.x, this._originalVelocity.y).add(this.distance.normalize().scale(this.speed));
            if (this.speed === 0) { this.angle += 90 * elapsed;
                this.velocity.y = Math.cos(numbers.radians(this.angle)) * 10; }
        } else { this.angle += 90 * elapsed;
            this.velocity.y = Math.cos(numbers.radians(this.angle)) * 10; }
        Entity.prototype.update.call(this, elapsed);
        if (this.position.y + this.box.y < 0 && this.velocity.y + this.force.y <= 0) { this.position.y = -this.box.y;
            this.velocity.y = Math.abs(this.velocity.y);
            this.force.y = Math.abs(this.force.y / 2); } else if (this.position.y + this.box.y + this.box.height > this.game.WORLD.HEIGHT && this.velocity.y + this.force.y >= 0) { this.position.y = this.game.WORLD.HEIGHT - this.box.y - this.box.height;
            this.velocity.y = -Math.abs(this.velocity.y);
            this.force.y = -Math.abs(this.force.y / 2); }
        this.sprite.position.x = this.position.x;
        this.sprite.position.y = this.position.y;
        if (!this.collectAnim && this.angle)
            this.sprite.rotation = numbers.radians(this.velocity.y);
        else
            this.sprite.rotation = 0;
        if (this.collectAnim) { this.sprite.alpha = easings.quartic.out(this.collectAnim.value);
            this.sprite.scale.set(2 - this.collectAnim.value, 2 - this.collectAnim.value); } else { this.sprite.alpha = 1;
            this.sprite.scale.set(1, 1); }
    };
    PowerUpEntity.prototype.add = function(game, layer) { layer.addChild(this.sprite); };
    PowerUpEntity.prototype.remove = function() { this.sprite.parent.removeChild(this.sprite); };
    return PowerUpEntity;
});
define('skytte/entities/hud', ['nebula/numbers', 'nebula/easings', 'skytte/vector2', 'skytte/tween', 'skytte/entity'], function(numbers, easings, Vector2, Tween, Entity) {
    'use strict';
    var createRedText = require('skytte/text.createRedText');
    var createOrangeText = require('skytte/text.createOrangeText');
    var createGreenText = require('skytte/text.createGreenText');

    function displayWhenBlinking(time, total) { return total - time > 1500 || Math.floor(time * 0.01333333333333333) % 2; }

    function Weapon(game) { Entity.call(this, game, 'HUDWeapon', 0, 0);
        this.container = new PIXI.Container();
        this.levelBackground = PIXI.Sprite.fromImage('hud_weapon_level_background.png');
        this.levelBackground.position.set(7, 80);
        this.container.addChild(this.levelBackground);
        this.level1 = PIXI.Sprite.fromImage('hud_weapon_level_1.png');
        this.level1.position.set(7, 80);
        this.level1.blendMode = PIXI.BLEND_MODES.ADD;
        this.container.addChild(this.level1);
        this.level2 = PIXI.Sprite.fromImage('hud_weapon_level_2.png');
        this.level2.position.set(37, 80);
        this.level2.visible = false;
        this.level2.blendMode = PIXI.BLEND_MODES.ADD;
        this.container.addChild(this.level2);
        this.level3 = PIXI.Sprite.fromImage('hud_weapon_level_3.png');
        this.level3.position.set(67, 80);
        this.level3.visible = false;
        this.level3.blendMode = PIXI.BLEND_MODES.ADD;
        this.container.addChild(this.level3);
        this.background = PIXI.Sprite.fromImage('hud_weapon_background.png');
        this.container.addChild(this.background);
        this.icon = new PIXI.Sprite();
        this.icon.anchor.set(0.5, 0.5);
        this.icon.position.set(51, 46);
        this.container.addChild(this.icon);
        this.icons = [PIXI.Texture.fromImage('hud_weapons_plasma.png'), PIXI.Texture.fromImage('hud_weapons_storm.png'), PIXI.Texture.fromImage('hud_weapons_ray.png'), PIXI.Texture.fromImage('hud_weapons_rockets.png'), PIXI.Texture.fromImage('hud_weapons_electro.png')]; }
    Weapon.prototype = Object.create(Entity.prototype);
    Weapon.prototype.render = function(elapsed) {
        this.container.position.x = this.game.cameraWidth - 102 - 10;
        this.container.position.y = this.game.cameraHeight - 122;
        if (this.game.currentWeapon >= 0) { this.icon.texture = this.icons[this.game.currentWeapon];
            this.level2.visible = this.game.weapons[this.game.currentWeapon].level >= 2;
            this.level3.visible = this.game.weapons[this.game.currentWeapon].level >= 3; } else
            this.level2.visible = this.level3.visible = false;
    };
    Weapon.prototype.add = function(game, layer) { layer.addChild(this.container); };
    Weapon.prototype.remove = function() { this.container.parent.removeChild(this.container); };

    function HealthBar(game) { Entity.call(this, game, 'HUDHealthBar', 0, 0);
        this.container = new PIXI.Container();
        this.container.position.y = 21;
        this.pause = PIXI.Sprite.fromImage('hud_pause.png');
        this.pause.position.set(274, 0);
        this.container.addChild(this.pause); var barBackground = PIXI.Sprite.fromImage('hud_bar_background.png');
        barBackground.position.set(56, 7);
        barBackground.width = 151;
        this.container.addChild(barBackground);
        barBackground = PIXI.Sprite.fromImage('hud_bar_background.png');
        barBackground.position.set(62, 37);
        barBackground.width = 151;
        this.container.addChild(barBackground);
        this.healthBar = PIXI.Sprite.fromImage('hud_bar_health.png');
        this.healthBar.position.set(56, 7);
        this.healthBar.width = 151;
        this.container.addChild(this.healthBar);
        this.healthHitBar = PIXI.Sprite.fromImage('hud_bar_hit.png');
        this.healthHitBar.alpha = 0;
        this.healthHitBar.position.set(56, 7);
        this.healthHitBar.width = 151;
        this.container.addChild(this.healthHitBar);
        this.shieldBar = PIXI.Sprite.fromImage('hud_bar_shield.png');
        this.shieldBar.position.set(62, 37);
        this.shieldBar.width = 151;
        this.container.addChild(this.shieldBar);
        this.shieldHitBar = PIXI.Sprite.fromImage('hud_bar_hit.png');
        this.shieldHitBar.position.set(62, 37);
        this.shieldHitBar.width = 151;
        this.container.addChild(this.shieldHitBar); var background = PIXI.Sprite.fromImage('hud_health_background.png');
        this.container.addChild(background); var heartIcon = PIXI.Sprite.fromImage('hud_health.png');
        heartIcon.scale.set(0.6, 0.6);
        heartIcon.position.set(10, 20);
        this.container.addChild(heartIcon); var shieldIcon = PIXI.Sprite.fromImage('hud_shield.png');
        shieldIcon.position.set(270 - 43, 10);
        this.container.addChild(shieldIcon);
        this.lifesText = createRedText({ 'spacing': -1 });
        this.lifesText.position.set(23, 13);
        this.container.addChild(this.lifesText); }
    HealthBar.prototype = Object.create(Entity.prototype);
    HealthBar.prototype.add = function(game, layer) { layer.addChild(this.container); };
    HealthBar.prototype.remove = function() { this.container.parent.removeChild(this.container); };
    HealthBar.prototype.render = function(elapsed) {
        this.container.position.x = this.game.cameraWidth - 270 - 4 - 53 - 8;
        if (this.game.player) {
            this.healthBar.width = this.healthHitBar.width = Math.max(0, this.game.player.health / this.game.player.maxHealth * 151);
            this.shieldBar.width = this.shieldHitBar.width = Math.max(0, this.game.player.shield / this.game.player.maxShield * 151);
            this.healthHitBar.alpha = this.shieldHitBar.alpha = this.game.player.hit.value
            this.lifesText.text = this.game.lifes;
        } else { this.lifesText.text = '0';
            this.healthBar.width = this.shieldBar.width = 0;
            this.healthHitBar.alpha = this.shieldHitBar.alpha = 0; }
    };

    function Score(game) { Entity.call(this, game, 'HUDScore', 5, 0);
        this.startScore = this.score = this.game.score;
        this.startCombo = this.combo = this.game.combo;
        this.container = new PIXI.Container();
        this.scoreIcon = PIXI.Sprite.fromImage('hud_score.png');
        this.container.addChild(this.scoreIcon);
        this.scoreText = createGreenText({ 'spacing': -3 });
        this.scoreText.position.y = 32;
        this.container.addChild(this.scoreText);
        this.comboIcon = PIXI.Sprite.fromImage('hud_combo.png');
        this.comboIcon.position.y = 20;
        this.comboIcon.visible = false;
        this.container.addChild(this.comboIcon);
        this.comboText = createOrangeText({ 'spacing': -3 });
        this.comboText.position.y = 32;
        this.container.addChild(this.comboText);
        this.multiplierIcon = PIXI.Sprite.fromImage('hud_multiplier.png');
        this.multiplierIcon.position.y = 20;
        this.multiplierIcon.visible = false;
        this.container.addChild(this.multiplierIcon);
        this.multiplierText = createRedText({ 'spacing': -3 });
        this.multiplierText.position.y = 32;
        this.container.addChild(this.multiplierText); }
    Score.prototype = Object.create(Entity.prototype);
    Score.prototype.add = function(game, layer) { layer.addChild(this.container); };
    Score.prototype.remove = function() { this.container.parent.removeChild(this.container); };
    Score.prototype.render = function(elapsed) {
        if (this.game.combo < this.combo)
            this.combo = 0;
        if (this.combo === this.game.combo)
            this.startCombo = this.game.combo;
        if (this.score === this.game.score)
            this.startScore = this.game.score;
        this.score = numbers.clamp(this.score + (this.game.score - this.startScore) * elapsed, 0, this.game.score);
        this.combo = numbers.clamp(this.combo + (this.game.combo - this.startCombo) * elapsed, 0, this.game.combo);
        this.container.position.x = this.position.x;
        this.container.position.y = this.position.y;
        var x = this.scoreIcon.width + 5;
        this.scoreText.text = numbers.format(Math.round(this.score), 0, ' ', ' ');
        this.scoreText.position.x = x;
        x += this.scoreText.width + 20;
        if ((this.game.combo > 0 || this.game.multiplier > 1) && displayWhenBlinking(this.game.comboTime, this.game.COMBO_DELAY) && this.game.cameraWidth >= 790) { this.comboIcon.position.x = x;
            this.comboIcon.visible = true;
            x += this.comboIcon.width + 5;
            this.comboText.text = numbers.format(Math.round(this.combo), 0, ' ', ' ');
            this.comboText.position.x = x;
            this.comboText.visible = true;
            x += this.comboText.width + 20;
            this.multiplierIcon.position.x = x;
            this.multiplierIcon.visible = true;
            x += this.multiplierIcon.width + 5;
            this.multiplierText.text = numbers.format(this.game.multiplier, 0, ' ', ' ');
            this.multiplierText.position.x = x;
            this.multiplierText.visible = true; } else { this.comboIcon.visible = this.comboText.visible = false;
            this.multiplierIcon.visible = this.multiplierText.visible = false; }
    };

    function PowerUp(game) { Entity.call(this, game, 'HUDPowerUp', 0, 0);
        this.background = PIXI.Sprite.fromImage('hud_power_up.png');
        this.background.position.y = 0;
        this.icon = new PIXI.Sprite();
        this.icon.position.set(this.background.width / 2, 46);
        this.icon.anchor.set(0.5, 0.5);
        this.background.addChild(this.icon); }
    PowerUp.prototype = Object.create(Entity.prototype);
    PowerUp.prototype.add = function(game, layer) { layer.addChild(this.background); };
    PowerUp.prototype.remove = function() { this.background.parent.removeChild(this.background); };
    PowerUp.prototype.render = function(elapsed) {
        this.background.position.x = this.game.cameraWidth - 270 - 53 - 8 - 4 - 53 - 8;
        if (this.game.activePowerUp) { this.icon.texture = this.game.activePowerUp.sprite.texture;
            this.icon.visible = displayWhenBlinking(this.game.activePowerUpTime, this.game.activePowerUp.duration); } else
            this.icon.visible = false;
    };

    function LevelProgress(game) { Entity.call(this, game, 'HUDLevelProgress', 0, 0);
        this.background = PIXI.Sprite.fromImage('hud_level_progress.png');
        this.background.anchor.set(0.5, 0.5);
        this.ship = PIXI.Sprite.fromImage('hud_ship.png');
        this.ship.anchor.set(0.5, 0.5);
        this.background.addChild(this.ship); }
    LevelProgress.prototype = Object.create(Entity.prototype);
    LevelProgress.prototype.render = function(elapsed) { var level = this.game.level; var progressWidth = 480 - 60 * 2; var progress = level ? Math.min(1, level.time / (level.duration + 10)) : 1;
        this.background.scale.set(Math.min(1, this.game.cameraWidth / 480));
        this.background.position.x = this.game.cameraWidth / 2;
        this.background.position.y = this.game.cameraHeight - 40;
        this.ship.position.x = progress * progressWidth - progressWidth / 2; };
    LevelProgress.prototype.add = function(game, layer) { layer.addChild(this.background); };
    LevelProgress.prototype.remove = function() { this.background.parent.removeChild(this.background); };
    return { 'Weapon': Weapon, 'HealthBar': HealthBar, 'Score': Score, 'PowerUp': PowerUp, 'LevelProgress': LevelProgress };
});
define('skytte/entities/label', ['nebula/easings', 'skytte/entity'], function(easings, Entity) {
    'use strict';
    var Text = require('skytte/text.Text');
    var GREEN_TEXTURES = require('skytte/text.GREEN_TEXTURES');
    var DEFAULT_SCALE = { 'x': 1, 'y': 1 };

    function LabelEntity(game, x, y, kwargs) { Entity.call(this, game, 'LabelEntity', x, y, kwargs);
        this.velocity.x = -80;
        this.velocity.y = -40;
        this.text = new Text({ 'textures': kwargs.textures || GREEN_TEXTURES, 'scale': kwargs.scale || DEFAULT_SCALE, 'spacing': -3, 'align': kwargs.align || 'left', 'text': kwargs.text });
        this.life = kwargs.life;
        this.time = 0; }
    LabelEntity.prototype = Object.create(Entity.prototype);
    LabelEntity.prototype.update = function(elapsed) { Entity.prototype.update.call(this, elapsed);
        this.time += elapsed; if (this.time >= this.life) { this.time = this.life;
            this.dead = true; } };
    LabelEntity.prototype.add = function(game, layer) { layer.addChild(this.text); };
    LabelEntity.prototype.remove = function() { this.text.parent.removeChild(this.text); };
    LabelEntity.prototype.render = function(elapsed) { this.text.position.x = this.position.x;
        this.text.position.y = this.position.y;
        this.text.alpha = 1 - easings.exponential.in(this.time / this.life); };
    return LabelEntity;
});
define('skytte/ai/base', function() {
    function BaseAI(game, entity, kwargs) { this.game = game;
        this.entity = entity; }
    BaseAI.prototype.update = function(elapsed) {};
    return BaseAI;
});
define('skytte/ai/idle', ['nebula/numbers', 'skytte/ai/base', 'skytte/entities/turret'], function(numbers, BaseAI, TurretEntity) {
    function IdleAI(game, entity, kwargs) { BaseAI.apply(this, arguments);
        this.angle = Math.random() * 360;
        this.shooting = kwargs && kwargs.shooting; }
    IdleAI.prototype = Object.create(BaseAI.prototype);
    IdleAI.prototype.update = function(elapsed) {
        if (!(this.entity instanceof TurretEntity)) { this.angle += 135 * elapsed;
            this.entity.velocity.x = 0;
            this.entity.velocity.y = Math.cos(numbers.radians(this.angle)) * 16; }
        if (!this.shooting)
            for (var i = 0; i < this.entity.weapons.length; i++)
                if (!this.entity.weapons[i].shooting)
                    this.entity.weapons[i].startShooting();
    };
    return IdleAI;
});
define('skytte/ai/move_left', ['skytte/ai/idle'], function(IdleAI) {
    function MoveLeftAI() { IdleAI.apply(this, arguments); }
    MoveLeftAI.prototype = Object.create(IdleAI.prototype);
    MoveLeftAI.prototype.update = function(elapsed) {
        IdleAI.prototype.update.call(this, elapsed);
        this.entity.velocity.x = -this.entity.speed;
        if (this.entity.position.x + this.entity.sprite.width * 2 < 0)
            this.entity.dead = true;
    };
    return MoveLeftAI;
});
define('skytte/ai/wave', ['nebula/numbers', 'skytte/vector2', 'skytte/ai/base'], function(numbers, Vector2, BaseAI) {
    function WaveAI(game, entity, x, y, width, height, offset, rotateSpeed) { BaseAI.call(this, game, entity);
        this.height = height;
        this.moveAngle = 0;
        this.rotateSpeed = rotateSpeed;
        this.delay = offset * width / this.entity.speed * 1000;
        this.entity.position.x = x;
        this.entity.position.y = y - this.entity.box.height / 2; }
    WaveAI.prototype = Object.create(BaseAI.prototype);
    WaveAI.prototype.update = function(elapsed) {
        if (this.delay > 0)
            this.delay -= elapsed * 1000;
        else if (this.delay <= 0) { this.moveAngle += this.rotateSpeed * elapsed; var dir = numbers.radians(this.moveAngle);
            this.entity.velocity.x = -this.entity.speed;
            this.entity.velocity.y = Math.cos(dir) * this.height / (180 / this.rotateSpeed) * Math.SQRT2;
            this.entity.angle = numbers.degrees(Math.atan2(this.entity.velocity.y, this.entity.velocity.x)) - 180; }
    };
    return WaveAI;
});
define('skytte/ai/kamikaze', ['skytte/vector2', 'skytte/ai/base'], function(Vector2, BaseAI) {
    function KamikazeAI(game, entity, target) { BaseAI.call(this, game, entity);
        this.target = target; }
    KamikazeAI.prototype = Object.create(BaseAI.prototype);
    KamikazeAI.prototype.update = function(elapsed) { if (this.target && !this.target.dead) { var targetCenter = this.target.center;
            this.entity.velocity.set(targetCenter.x, targetCenter.y).sub(this.entity.center).normalize().scale(this.entity.speed); } else { this.entity.velocity.x = -this.entity.speed;
            this.entity.velocity.y = 0;
            this.target = null; } };
    return KamikazeAI;
});
define('skytte/ai/teleporter', ['skytte/vector2', 'nebula/easings', 'skytte/tween', 'skytte/ai/base'], function(Vector2, easings, Tween, BaseAI) {
    function TeleporterAI(game, entity, kwargs) { BaseAI.apply(this, arguments);
        this.alpha = 1;
        this.delay = kwargs.delay / 1000;
        this.teleportTime = kwargs.teleportTime;
        this.teleportLimit = 10;
        this.time = 0;
        this.show = null;
        this.hide = null; }
    TeleporterAI.prototype = Object.create(BaseAI.prototype);
    TeleporterAI.prototype.teleport = function() { this.hide = null; var worldW = this.game.WORLD.WIDTH; var worldH = this.game.WORLD.HEIGHT; var x = (worldW * .25) + Math.random() * (worldW * .7); var y = Math.random() * (worldH * .9 - this.entity.sprite.height);
        this.entity.position.x = x;
        this.entity.position.y = y;
        this.show = new Tween(0, 1, this.teleportTime, easings.linear);
        this.teleportLimit--; };
    TeleporterAI.prototype.update = function(elapsed) {
        if (this.hide) {
            this.hide.update(elapsed);
            this.alpha = this.hide.value;
            if (this.hide.hasEnded)
                this.teleport();
        } else if (this.show) {
            this.show.update(elapsed);
            this.alpha = this.show.value;
            if (this.show.hasEnded)
                this.show = null;
        } else if (this.teleportLimit > 0) { this.time += elapsed; if (this.time >= this.delay) { this.time = 0;
                this.hide = new Tween(1, -1, this.teleportTime, easings.linear);
                this.entity.teleportSound.play(); } }
        this.entity.velocity.x = -this.entity.speed;
        for (var i = 0; i < this.entity.weapons.length; i++)
            if (!this.entity.weapons[i].shooting)
                this.entity.weapons[i].startShooting();
    };
    return TeleporterAI;
});
define('skytte/ai/follow', ['nebula/numbers', 'skytte/vector2', 'skytte/ai/base'], function(numbers, Vector2, BaseAI) {
    function FollowAI(game, entity, target) { BaseAI.call(this, game, entity);
        this.target = target; }
    FollowAI.prototype = Object.create(BaseAI.prototype);
    FollowAI.prototype.update = function(elapsed) {
        if (this.target && !this.target.dead) { var targetCenter = this.target.center; var heading = new Vector2(targetCenter.x, targetCenter.y).sub(this.entity.center); var radius = new Vector2(heading.x, heading.y).normalize().scale(200); var speed = numbers.clamp(heading.length() - 200, 0, this.entity.speed);
            this.entity.velocity.set(heading.x, heading.y).sub(radius).normalize().scale(speed); } else
            this.entity.velocity.x = -this.entity.speed;
        for (var i = 0; i < this.entity.weapons.length; i++)
            if (!this.entity.weapons[i].shooting)
                this.entity.weapons[i].startShooting();
    };
    return FollowAI;
});
define('skytte/ai/cart', ['skytte/ai/base'], function(BaseAI) {
    function CartAI(game, entity, kwargs) { BaseAI.apply(this, arguments);
        this.direction = kwargs.direction || -1; }
    CartAI.prototype = Object.create(BaseAI.prototype);
    CartAI.prototype.update = function(elapsed) {
        var center = this.entity.center;
        if ((center.y <= 0 && this.direction === -1) || (center.y >= this.game.WORLD.HEIGHT && this.direction === 1))
            this.direction *= -1;
        this.entity.velocity.y = this.entity.verticalSpeed * this.direction;
        this.entity.velocity.x = -this.entity.speed;
        for (var i = 0; i < this.entity.weapons.length; i++)
            if (!this.entity.weapons[i].shooting)
                this.entity.weapons[i].startShooting();
    };
    return CartAI;
});
define('skytte/keys', function() { return { 'PAUSE': 19, 'ESC': 27, 'SPACE': 32, 'ARROW_LEFT': 37, 'ARROW_UP': 38, 'ARROW_RIGHT': 39, 'ARROW_DOWN': 40, 'CHAR_1': 49, 'CHAR_2': 50, 'CHAR_3': 51, 'CHAR_4': 52, 'CHAR_5': 53, 'CHAR_6': 54, 'CHAR_P': 80 }; });
define('skytte/level', ['skytte/utils'], function(utils) {
    function Level(game, kwargs) {
        this.game = game;
        this.events = utils.merge([], kwargs.events);
        this.recurring = [];
        this.time = 0;
        this.processTime = 0;
        this.PROCESS_EVERY = 0.05;
        this.duration = 0;
        this._signals = [];
        var i = this.events.length,
            event;
        while (--i >= 0) {
            event = this.events[i];
            if (event.at)
                this.duration = Math.max(event.at, this.duration);
            if (event.signal) { this.game[event.signal].connect(event.receiver);
                this._signals.push([event.signal, event.receiver]);
                this.events.splice(i, 1); }
        }
        this._processEventQueue();
    }
    Level.prototype.eventScenery = function(event) { this.game.makeScenery(event.config); };
    Level.prototype.eventHUD = function(event) { this.game.makeHUD(); };
    Level.prototype.eventPlayerWeapons = function(event) { this.game.makePlayerWeapons(event.config); };
    Level.prototype.eventPlayerShip = function(event) { this.game.makePlayerShip(event.x, event.y, event.config); };
    Level.prototype.eventChangeWeapon = function(event) { this.game.changeWeapon.call(this.game, event.weapon); };
    Level.prototype.eventPowerUp = function(event) { this.game.makePowerUp(event.x, event.y, event.config); };
    Level.prototype.eventHint = function(event) { this.game.makeHint(event.x, event.y, event.config); };
    Level.prototype.eventMine = function(event) { this.game.makeMine(event.x, event.y, event.config); };
    Level.prototype.eventAggressiveMine = function(event) { this.game.makeAggressiveMine(event.x, event.y, event.config); };
    Level.prototype.eventSwarm = function(event) { this.game.makeSwarm(event.x, event.y, event.config, event.args[0], event.args[1], event.args[2], event.args[3]); };
    Level.prototype.eventSwarmUnit = function(event) { this.game.makeSwarmUnit(event.x, event.y, event.config); };
    Level.prototype.eventFighter = function(event) { this.game.makeFighter(event.x, event.y, event.config); };
    Level.prototype.eventTeleporter = function(event) { this.game.makeTeleporter(event.x, event.y, event.config); };
    Level.prototype.eventElectrician = function(event) { this.game.makeElectrician(event.x, event.y, event.config); };
    Level.prototype.eventTank = function(event) { this.game.makeTank(event.x, event.y, event.config); };
    Level.prototype.eventFrigate = function(event) { this.game.makeFrigate(event.x, event.y, event.config); };
    Level.prototype.eventLaserTurretUp = function(event) { this.game.makeLaserTurretUp(event.x, event.config); };
    Level.prototype.eventLaserTurretDown = function(event) { this.game.makeLaserTurretDown(event.x, event.config); };
    Level.prototype.eventFlakTurretUp = function(event) { this.game.makeFlakTurretUp(event.x, event.config); };
    Level.prototype.eventFlakTurretDown = function(event) { this.game.makeFlakTurretDown(event.x, event.config); };
    Level.prototype.eventCartTurret = function(event) { this.game.makeCartTurret(event.x, event.y, event.config); };
    Level.prototype.processEvent = function(event) {
        event = utils.merge({}, event);
        if (typeof event.x === 'undefined')
            event.x = this.game.cameraWidth + 100;
        if (typeof event.y === 'undefined')
            event.y = this.game.cameraHeight * Math.random();
        if (typeof event.type === 'string')
            this['event' + event.type](event);
        else
            event.type.call(event, this.game, this);
    };
    Level.prototype._processEventQueue = function() {
        var i = 0;
        while (i < this.events.length) {
            var event = this.events[i];
            if (this.time >= (event.at || 0)) { this.processEvent(event);
                this.events.splice(i, 1); if (typeof event.every !== 'undefined') { event.time = 0;
                    this.recurring.push(event); } } else
                i += 1;
        }
    };
    Level.prototype.update = function(elapsed) {
        this.time += elapsed;
        this.processTime += elapsed;
        if (this.processTime >= this.PROCESS_EVERY && this.events.length) {
            for (var i = 0; i < this.recurring.length; i++) { var event = this.recurring[i];
                event.time += elapsed; if (event.time >= event.every) { this.processEvent(event);
                    event.time -= event.every; } }
            this._processEventQueue();
            this.processTime -= this.PROCESS_EVERY;
        }
    };
    Level.prototype.hasEnded = function() {
        for (var i = 0; i < this.events.length; i++)
            if (this.events[i].at)
                return false;
        return true;
    };
    Level.prototype.end = function() {
        for (var i = 0; i < this._signals.length; i++)
            this.game[this._signals[i][0]].disconnect(this._signals[i][1]);
        this._signals = [];
    };
    return Level;
});
define('skytte/game', function() {
    'use strict';
    var settings = require('settings');
    var Signal = require('nebula/signal');
    var numbers = require('nebula/numbers');
    var keyboard = require('nebula/input/keyboard');
    var collision = require('skytte/collision');
    var FogEntity = require('skytte/entities/fog');
    var ShipEntity = require('skytte/entities/ship');
    var LabelEntity = require('skytte/entities/label');
    var Explosion = require('skytte/particles/explosion');
    var KEYS = require('skytte/keys');
    var BackgroundEntity = require('skytte/entities/background');
    var SpriteEntity = require('skytte/entities/sprite');
    var MushroomEmitter = require('skytte/particles/mushroom');
    var hud = require('skytte/entities/hud');
    var PowerUpEntity = require('skytte/entities/power_up');
    var TurretEntity = require('skytte/entities/turret');
    var CartEntity = require('skytte/entities/cart');
    var MineEntity = require('skytte/entities/mine');
    var SwarmEntity = require('skytte/entities/swarm');
    var TeleporterEntity = require('skytte/entities/teleporter');
    var MoveLeftAI = require('skytte/ai/move_left');
    var KamikazeAI = require('skytte/ai/kamikaze');
    var TeleporterAI = require('skytte/ai/teleporter');
    var FollowAI = require('skytte/ai/follow');
    var WaveAI = require('skytte/ai/wave');
    var CartAI = require('skytte/ai/cart');
    var Level = require('skytte/level');
    var ASSETS = require('skytte/assets');

    function Game(canvas, scale, debug, data) {
        this.COMBO_DELAY = 2500;
        this.resolution = Math.min(2, window.devicePixelRatio);
        this.renderer = new PIXI.WebGLRenderer(canvas.width, canvas.height, { 'view': canvas });
        this.stage = new PIXI.Container();
        this.layers = { 'background': new PIXI.Container(), 'background2': new PIXI.Container(), 'middleground': new PIXI.Container(), 'middleground2': new PIXI.Container(), 'foreground': new PIXI.Container(), 'hud': new PIXI.Container() };
        this.stage.addChild(this.layers.background);
        this.stage.addChild(this.layers.background2);
        this.stage.addChild(this.layers.middleground);
        this.stage.addChild(this.layers.middleground2);
        this.stage.addChild(this.layers.foreground);
        this.stage.addChild(this.layers.hud);
        this.debug = debug;
        this.data = data;
        this.toLoad = this.loaded = 0;
        this.paused = true;
        this.autofire = true;
        this._enemyCount = 0;
        this.fps = this._frame = this._fpsTime = 0;
        this._prevTimestamp = 0;
        this.NEUTRAL_TEAM = 0;
        this.PLAYER_TEAM = 1;
        this.ENEMY_TEAM = 2;
        this.WORLD = { 'WIDTH': canvas.width, 'HEIGHT': canvas.height - 60, 'FULL_HEIGHT': canvas.height };
        this._tickProxy = this._tick.bind(this);
        this._touchscreen = true;
        this.gamePaused = new Signal();
        this.gameResumed = new Signal();
        this.playerDied = new Signal();
        this.levelEnded = new Signal();
        this.resourceLoaded = new Signal();
        this.allResourcesLoaded = new Signal();
        this.beforeUpdate = new Signal();
        this.afterUpdate = new Signal();
        this.beforeRender = new Signal();
        this.afterRender = new Signal();
        for (var i = 0; i < ASSETS.length; i++)
            if (Array.isArray(ASSETS[i]))
                PIXI.loader.add(ASSETS[i][0], window.STATIC_URL + ASSETS[i][1]);
            else
                PIXI.loader.add(window.STATIC_URL + ASSETS[i]);
        keyboard.onDown({ 'sender': keyboard.keys.space, 'receiver': this.nextWeapon, 'context': this });
        this.newGame();
    }
    Game.prototype.nextWeapon = function() { this.changeWeapon((this.currentWeapon + 1) % this.weapons.length); };
    Game.prototype.resize = function(width, height, scale) { this.renderer.resize(width * this.resolution, height * this.resolution);
        this.renderer.view.style.transform = 'scale(' + (1 / this.resolution) + ', ' + (1 / this.resolution) + ')';
        this.stage.scale.set(height / 640 * this.resolution, height / 640 * this.resolution); };
    Game.prototype.getCurrentWeapon = function() {
        if (this.currentWeapon >= 0)
            return this.weapons[this.currentWeapon];
        return null;
    };
    Game.prototype._onResourceLoad = function() {
        this.loaded++;
        this.resourceLoaded.send(this);
        if (this.loaded === this.toLoad)
            this.allResourcesLoaded.send(this);
    };
    Game.prototype.load = function() {
        PIXI.loader.load(this._onResourceLoad.bind(this));
        this.toLoad += 1;
        var resource;
        if (this.toLoad > 0 && this.loaded === this.toLoad) { this.allResourcesLoaded.send(this); return; }
        for (var name in this.data)
            if (this.data.hasOwnProperty(name)) { resource = this.data[name]; if (!resource.hasLoaded) { resource.loaded.connect(this._onResourceLoad, this);
                    resource.load();
                    this.toLoad += 1; } }
        if (this.toLoad === 0)
            this.allResourcesLoaded.send(this);
    };
    Game.prototype.getResource = function(resource) {
        var parts = resource.split(' ');
        var name = parts[0];
        if (!(name in this.data))
            throw new Error('invalid resource name: "' + String(resource) + '"');
        if (parts.length === 1)
            return this.data[name];
        else if (parts.length === 2) { var pos = parts[1].split(','); var x = parseInt(pos[0], 10); var y = parseInt(pos[1], 10); return this.data[name].getSprite(x, y); } else
            throw new Error('invalid resource name: "' + String(resource) + '"');
    };
    Game.prototype.addEntity = function(entity, layer) { this.entities.push(entity);
        entity.add(this, layer || this.layers.middleground); };
    Game.prototype.queueEntity = function(entity, delay, layer) { this._entitiesToAdd.push({ 'entity': entity, 'delay': delay || 0, 'where': 'append', 'layer': layer || this.layers.middleground }); };
    Game.prototype.isEntityInGame = function(entity) { return this.entities.indexOf(entity) >= 0; };
    Game.prototype.addExplosion = function(x, y, radius, damage, team, delay) { this.shake = Math.min(6, this.shake + (radius + (damage || 0)) / 200);
        this.queueEntity(new Explosion(this, x, y, { 'radius': radius, 'damage': damage, 'team': team }), delay, this.layers.middleground); };
    Game.prototype.addScoreLabel = function(killedEntity, score) { var center = killedEntity.center; var label = new LabelEntity(this, center.x, center.y, { 'text': '+' + score, 'life': 1, 'scale': { 'x': 0.7, 'y': 0.7 }, 'align': 'center' });
        this.entities.push(label);
        label.add(this, this.layers.foreground); };
    Game.prototype.addCombo = function(points) {
        points *= this.multiplier;
        this.combo += points;
        while (this.combo > Math.pow(this.multiplier, 2) * 250)
            this.multiplier += 1;
        this.comboTime = 0;
        return points;
    };
    Game.prototype.resetCombo = function() { this.score += this.combo;
        this.bestCombo = Math.max(this.combo, this.bestCombo);
        this.bestMultiplier = Math.max(this.multiplier, this.bestMultiplier);
        this.comboTime = this.combo = 0;
        this.multiplier = 1; };
    Game.prototype.makeScenery = function(scenery) {
        if (scenery.backgroundColor)
            this.renderer.backgroundColor = scenery.backgroundColor;
        if (scenery.layer6)
            this.addEntity(new BackgroundEntity(this, scenery.layer6), this.layers.background);
        if (scenery.layer5)
            this.addEntity(new BackgroundEntity(this, scenery.layer5), this.layers.background);
        if (scenery.layer4)
            this.addEntity(new BackgroundEntity(this, scenery.layer4), this.layers.background);
        if (scenery.layer3)
            this.addEntity(new BackgroundEntity(this, scenery.layer3), this.layers.background);
        if (scenery.fog)
            for (var i = 0; i < 8; i++)
                this.addEntity(new FogEntity(this, scenery.fog), this.layers.foreground);
        if (scenery.mushroom)
            for (var i = 0; i < (scenery.mushroom.count || 3); i++)
                this.addEntity(new MushroomEmitter(this, scenery.mushroom), this.layers.middleground);
        if (scenery.layer2)
            this.addEntity(new BackgroundEntity(this, scenery.layer2), this.layers.foreground);
        if (scenery.layer1)
            this.addEntity(new BackgroundEntity(this, scenery.layer1), this.layers.foreground);
    };
    Game.prototype.makeHUD = function() { this.addEntity(new hud.LevelProgress(this), this.layers.hud);
        this.addEntity(new hud.Weapon(this), this.layers.hud);
        this.addEntity(new hud.HealthBar(this), this.layers.hud);
        this.addEntity(new hud.Score(this), this.layers.hud);
        this.addEntity(new hud.PowerUp(this), this.layers.hud); };
    Game.prototype.makePlayerWeapons = function(config) {
        var plasma = require('skytte/weapons/plasma');
        var storm = require('skytte/weapons/storm');
        var laser = require('skytte/weapons/laser');
        var ray = require('skytte/weapons/ray');
        var rockets = require('skytte/weapons/rockets');
        var flak = require('skytte/weapons/flak');
        var electro = require('skytte/weapons/electro');
        var weapon, x = -1,
            y = 37;
        var weaponNames = ['PLASMA', 'STORM', 'RAY', 'ROCKETS', 'ELECTRO'];
        var weaponConstructors = [plasma.PlasmaWeapon, storm.StormWeapon, ray.RayWeapon, rockets.RocketsWeapon, electro.ElectroWeapon];
        this.allWeapons = [];
        for (var l = 1; l < 4; l++) { this.allWeapons.push([]); for (var n = 0; n < weaponNames.length; n++) { weapon = new(weaponConstructors[n])(this, this.player, x, y, config[weaponNames[n] + '_' + l]);
                this.allWeapons[l - 1].push(weapon); } }
        this.weapons = this.allWeapons[0];
        this.currentWeapon = -1;
        this.changeWeapon(0);
    };
    Game.prototype.makePlayerShip = function(x, y, config) { this.player = new ShipEntity(this, x, y, config);
        this.changeWeapon(this.currentWeapon);
        this.queueEntity(this.player, 0, this.layers.middleground); };
    Game.prototype.makePowerUp = function(x, y, config) { this.queueEntity(new PowerUpEntity(this, x - (config.box.x + config.box.width) / 2, y - (config.box.y + config.box.height) / 2, config), 0, this.layers.middleground); };
    Game.prototype.makeHint = function(x, y, config) { this.addEntity(new SpriteEntity(this, x, y, config), this.layers.background); };
    Game.prototype.makeShip = function(ShipClass, x, y, config, AIClass, aiArgs) {
        var ship = new(ShipClass.bind.call(ShipClass, null, this, x, y, config));
        if (AIClass) {
            if (!aiArgs)
                aiArgs = [];
            aiArgs.unshift(null, this, ship);
            ship.ai = new(AIClass.bind.apply(AIClass, aiArgs));
        }
        return ship;
    };
    Game.prototype.makeMine = function(x, y, config) { this.queueEntity(this.makeShip(MineEntity, x, y, config, config.ai || MoveLeftAI), 0, this.layers.middleground); };
    Game.prototype.makeAggressiveMine = function(x, y, config) { this.queueEntity(this.makeShip(MineEntity, x, y, config, config.ai || KamikazeAI, [this.player]), 0, this.layers.middleground); };
    Game.prototype.makeSwarmUnit = function(x, y, config) { this.queueEntity(this.makeShip(SwarmEntity, x, y, config, config.ai), 0, this.layers.middleground); };
    Game.prototype.makeSwarm = function(x, y, config, width, height, count, rotateSpeed) {
        for (var i = 0; i < count; i++)
            this.queueEntity(this.makeShip(SwarmEntity, x, y, config, config.ai || WaveAI, [x, y, width, height, i / count, rotateSpeed]), 0, this.layers.middleground);
    };
    Game.prototype.makeFighter = function(x, y, config) { var ship = this.makeShip(ShipEntity, x, y, config, config.ai || MoveLeftAI, config.aiArgs);
        this.queueEntity(ship, 0, this.layers.middleground); return ship; };
    Game.prototype.makeTeleporter = function(x, y, config) { var ship = this.makeShip(TeleporterEntity, x, y, config, config.ai || TeleporterAI, config.aiArgs || [config.AI]);
        this.queueEntity(ship, 0, this.layers.middleground); return ship; };
    Game.prototype.makeElectrician = function(x, y, config) { var ship = this.makeShip(ShipEntity, x, y, config, config.ai || FollowAI, config.aiArgs || [this.player]);
        this.queueEntity(ship, 0, this.layers.middleground); return ship; };
    Game.prototype.makeTank = function(x, y, config) { var ship = this.makeShip(ShipEntity, x, y, config, config.ai || MoveLeftAI, config.aiArgs);
        this.queueEntity(ship, 0, this.layers.middleground); return ship; };
    Game.prototype.makeFrigate = function(x, y, config) { var ship = this.makeShip(ShipEntity, x, y, config, config.ai || MoveLeftAI, config.aiArgs);
        this.queueEntity(ship, 0, this.layers.middleground); return ship; };
    Game.prototype.makeLaserTurretUp = function(x, config) { var y = this.WORLD.HEIGHT + 45 - 140 + 40; var ship = this.makeShip(TurretEntity, x, y, config, config.ai || MoveLeftAI, config.aiArgs);
        this.queueEntity(ship, 0, this.layers.middleground); return ship; };
    Game.prototype.makeLaserTurretDown = function(x, config) { var ship = this.makeShip(TurretEntity, x, 95, config, config.ai || MoveLeftAI, config.aiArgs);
        this.queueEntity(ship, 0, this.layers.middleground); return ship; };
    Game.prototype.makeFlakTurretUp = function(x, config) { var y = this.WORLD.HEIGHT + 48 - 136 + 30; var ship = this.makeShip(TurretEntity, x, y, config, config.ai || MoveLeftAI, config.aiArgs);
        this.queueEntity(ship, 0, this.layers.middleground); return ship; };
    Game.prototype.makeFlakTurretDown = function(x, config) { var ship = this.makeShip(TurretEntity, x, 88, config, config.ai || MoveLeftAI, config.aiArgs);
        this.queueEntity(ship, 0, this.layers.middleground); return ship; };
    Game.prototype.makeCartTurret = function(x, y, config) { var ship = this.makeShip(CartEntity, x, y, config, config.ai || CartAI, config.aiArgs || [{ 'direction': -1 }]);
        this.queueEntity(ship, 0, this.layers.middleground);
        this.queueEntity(new SpriteEntity(this, x + 10, 0, { 'texture': 'rail.png', 'vx': -config.speed })); return ship; };
    Game.prototype.collectPowerUp = function(powerUp) {
        if (powerUp.duration) {
            if (this.activePowerUp)
                this.activePowerUp.expired();
            this.activePowerUp = powerUp;
            this.activePowerUpTime = 0;
        }
        powerUp.collect();
    };
    Game.prototype.expireActivePowerUp = function() { if (this.activePowerUp) { this.activePowerUp.expired();
            this.activePowerUp = null;
            this.activePowerUpTime = 0; } };
    Game.prototype.findClosest = function(x, y, entityClass, minDistance, conditionFunc) {
        var target, targetCenter, targetCenterY, closestTarget = null,
            closestDistance = Number.MAX_VALUE,
            distance;
        minDistance = minDistance || 0;
        for (var i = 0; i < this.entities.length; i++) { target = this.entities[i]; if (!target.dead && target instanceof entityClass && (!conditionFunc || conditionFunc(target))) { targetCenter = target.center;
                distance = Math.pow(targetCenter.x - x, 2) + Math.pow(targetCenter.y - y, 2); if (distance < closestDistance && distance > minDistance) { closestDistance = distance;
                    closestTarget = target; } } }
        return { 'target': closestTarget, 'distance': Math.sqrt(closestDistance) };
    };
    Game.prototype.newGame = function() {
        if (this.level)
            this.level.end();
        else { keyboard.enable();
            keyboard.lockAll();
            keyboard.unlock('alt f4 f5 f11'); }
        if (this.entities)
            for (var i = 0; i < this.entities.length; i++)
                this.entities[i].remove();
        this.player = null;
        this.entities = [];
        this.allWeapons = [];
        this.weapons = [];
        this.currentWeapon = -1;
        this.lifes = 3;
        this.score = 0;
        this.combo = this.bestCombo = 0;
        this.multiplier = this.bestMultiplier = 1;
        this.kills = 0;
        this.comboTime = 0;
        this.distance = 0;
        this.activePowerUp = null;
        this.activePowerUpTime = 0;
        this.shake = 0;
        this.level = null;
        this._entitiesToAdd = [];
    };
    Game.prototype.loadLevel = function(levelConfig) {
        if (this.level)
            this.level.end();
        this.score += this.combo;
        if (this.entities)
            for (var i = 0; i < this.entities.length; i++)
                this.entities[i].remove();
        this.player = null;
        this.entities = [];
        this.combo = 0;
        this.multiplier = 1;
        this.comboTime = 0;
        this.activePowerUp = null;
        this.activePowerUpTime = 0;
        this.shake = 0;
        this.level = null;
        this._entitiesToAdd = [];
        this.level = new Level(this, levelConfig);
        if (!this._playerLowLifeSoundInstance)
            this._playerLowLifeSoundInstance = this.getResource('soundPlayerLowLife').getInstance();
        if (this.player && this.autofire)
            this.player.startShooting();
    };
    Game.prototype.input = function(elapsed) {
        keyboard.update(elapsed);
        if (!this.player || this.paused)
            return;
        if (keyboard.keys.p.isDown || keyboard.keys.esc.isDown || keyboard.keys.pauseBreak.isDown)
            this.pause();
        var dir = keyboard.direction();
        this.player.move(dir.x * 0.125, dir.y * 0.125);
        if (keyboard.keys.one.isDown)
            this.changeWeapon(0);
        if (keyboard.keys.two.isDown)
            this.changeWeapon(1);
        if (keyboard.keys.three.isDown)
            this.changeWeapon(2);
        if (keyboard.keys.four.isDown)
            this.changeWeapon(3);
        if (keyboard.keys.five.isDown)
            this.changeWeapon(4);
    };
    Game.prototype.isPlayerShooting = function() { return this.player && this.player.hasWeapon() && this.player.weapons[0].shooting; };
    Game.prototype.changeWeapon = function(index) {
        if (this.weapons[index] === this.player.weapons[0])
            return;
        var shooting = this.isPlayerShooting();
        if (shooting)
            this.player.stopShooting();
        if (this.currentWeapon !== -1)
            this.getResource('soundPlayerWeaponChange').play({ 'volume': settings('WEAPON_CHANGE_VOLUME', 1) });
        if (this.player.weapons.length)
            this.player.weapons[0].remove();
        this.currentWeapon = index;
        var weapon = this.weapons[this.currentWeapon];
        this.player.weapons[0] = weapon;
        weapon.owner = this.player;
        weapon.add(this, this.player.sprite);
        if (shooting)
            this.player.startShooting();
    };
    Game.prototype.upgradeWeapon = function(index) {
        var weapon = this.weapons[index];
        if (weapon.level >= 3)
            return;
        var shooting = false;
        if (this.player.hasWeapon() && this.player.weapons[0] === weapon) { shooting = this.player.weapons[0].shooting;
            this.player.stopShooting();
            this.player.weapons[0].remove(); }
        this.weapons[index] = this.allWeapons[weapon.level][index];
        this.weapons[index].owner = this.player;
        if (this.player.weapons[0] === weapon) {
            this.player.weapons[0] = this.weapons[index];
            this.player.weapons[0].add(this, this.player.sprite);
            if (shooting)
                this.player.startShooting();
        }
    };
    Game.prototype.spawnQueuedEntities = function(elapsed) {
        var i = this._entitiesToAdd.length,
            item;
        while (--i >= 0) {
            item = this._entitiesToAdd[i];
            item.delay -= elapsed * 1000;
            if (item.delay <= 0) {
                if (item.where === 'prepend')
                    this.entities.unshift(item.entity);
                else
                    this.entities.push(item.entity);
                this._entitiesToAdd.splice(i, 1);
                item.entity.add(this, item.layer);
            }
        }
    };
    Game.prototype.checkCollisions = function() {
        var entityCount = this.entities.length;
        for (var i = 0; i < entityCount - 1; i++) {
            var a = this.entities[i];
            if (!a.dead && a.box && a.polygon)
                for (var j = i + 1; j < entityCount; j++) {
                    var b = this.entities[j];
                    if ((!b.dead && (a.team !== b.team || ((a.collectible || b.collectible) && (a.team === b.team)))) && (b.box && collision.testBoundingBoxes(a.position, a.box, b.position, b.box) && b.polygon && collision.testPolygons(a.position, a.polygon, b.position, b.polygon))) {
                        a.collidesWith(b);
                        b.collidesWith(a);
                        if (a.dead)
                            break;
                    }
                }
        }
    };
    Game.prototype.update = function(elapsed) {
        this.beforeUpdate.send(this, elapsed);
        if (this.level)
            this.level.update(elapsed);
        this.shake = Math.max(0, this.shake - 4 * elapsed);
        if (this.activePowerUp) {
            this.activePowerUp.active(elapsed);
            this.activePowerUpTime += elapsed * 1000;
            if (this.activePowerUpTime >= this.activePowerUp.duration)
                this.expireActivePowerUp();
        }
        this.spawnQueuedEntities(elapsed);
        this.checkCollisions();
        this._enemyCount = 0;
        var i = this.entities.length;
        while (--i >= 0) {
            var entity = this.entities[i];
            if (!entity.dead) {
                entity.update(elapsed);
                if (entity.team === this.ENEMY_TEAM || entity instanceof PowerUpEntity)
                    this._enemyCount += 1;
            } else {
                entity.remove();
                if (entity instanceof ShipEntity && entity.health <= 0 && entity.team !== this.PLAYER_TEAM) {
                    this.kills += 1;
                    if (entity.score)
                        this.addScoreLabel(entity, this.addCombo(entity.score));
                } else if (entity === this.player) { this.playerDied.send(this);
                    this._playerLowLifeSoundInstance.stop(); }
                this.entities.splice(i, 1);
            }
        }
        if (this.combo || this.multiplier > 1) {
            this.comboTime += elapsed * 1000;
            if (this.comboTime >= this.COMBO_DELAY)
                this.resetCombo();
        }
        if (this.player && !this.player.dead && this.level) {
            this.distance += 80 * elapsed;
            if (this.player.health / this.player.maxHealth <= .25) {
                if (this._playerLowLifeSoundInstance.playState !== createjs.Sound.PLAY_SUCCEEDED)
                    this._playerLowLifeSoundInstance.play({ 'volume': settings('LOW_LIFE_VOLUME', 1), 'loop': -1 });
            } else
                this._playerLowLifeSoundInstance.stop();
        } else if (this._playerLowLifeSoundInstance)
            this._playerLowLifeSoundInstance.stop();
        if (this.level && this.level.hasEnded() && !this._enemyCount && this.player && !this.player.dead) { this.resetCombo();
            this.levelEnded.send(this); }
        this.afterUpdate.send(this, elapsed);
    };
    Game.prototype.render = function(elapsed) {
        this.beforeRender.send(this);
        this.layers.background.position.x = (Math.random() - 0.5) * this.shake * 2;
        this.layers.background.position.y = (Math.random() - 0.5) * this.shake * 2;
        this.layers.middleground.position.x = (Math.random() - 0.5) * this.shake * 2;
        this.layers.middleground.position.y = (Math.random() - 0.5) * this.shake * 2;
        this.layers.foreground.position.x = (Math.random() - 0.5) * this.shake * 2;
        this.layers.foreground.position.y = (Math.random() - 0.5) * this.shake * 2;
        for (var i = 0; i < this.entities.length; i++)
            if (this.entities[i].render)
                this.entities[i].render(elapsed);
        this.renderer.render(this.stage);
        this.afterRender.send(this);
    };
    Game.prototype._tick = function() {
        var milliseconds = 0;
        var now = Date.now();
        if (this._prevTimestamp)
            milliseconds = now - this._prevTimestamp;
        this._prevTimestamp = now;
        var elapsed = milliseconds / 1000 * settings('GAME_SPEED', 1);
        if (elapsed > 0 && elapsed < .2) { this.input(elapsed);
            this.update(elapsed);
            this.render(elapsed); }
        this._frame += 1;
        this._fpsTime += milliseconds;
        if (this._fpsTime >= 1000) { this.fps = Math.floor(this._frame / (this._fpsTime / 1000));
            this._frame -= this._frame / (this._fpsTime / 1000);
            this._fpsTime -= 1000; }
        if (!this.paused)
            requestAnimationFrame(this._tickProxy);
    };
    Game.prototype.enableAutofire = function() {
        this.autofire = true;
        if (this.player && !this.isPlayerShooting())
            this.player.startShooting();
    };
    Game.prototype.disableAutofire = function() {
        this.autofire = false;
        if (this.player && this.isPlayerShooting())
            this.player.stopShooting();
    };
    Game.prototype.resume = function() { if (this.paused) { keyboard.resume();
            this.paused = false;
            this._prevTimestamp = Date.now();
            this._tick();
            this.gameResumed.send(this); } };
    Game.prototype.pause = function() { keyboard.pause();
        this.paused = true;
        this.gamePaused.send(this); };
    Game.prototype.getPanForPosition = function(position, centerX) {
        if (typeof centerX === 'undefined')
            centerX = this.cameraWidth / 2;
        return numbers.clamp((position.x - centerX) / this.cameraWidth * 2, -1, 1);
    };
    Object.defineProperties(Game.prototype, { 'viewportWidth': { 'get': function() { return this.renderer.view.width; } }, 'cameraWidth': { 'get': function() { return this.renderer.view.width / this.stage.scale.x; } }, 'cameraHeight': { 'get': function() { return this.renderer.view.height / this.stage.scale.y; } } });
    return Game;
});
define('skytte/data/resources', function() {
    'use strict';
    var Sound = require('skytte/sound');
    var STATIC_URL = window.STATIC_URL || '';

    function sh(names, minDelay) {
        var formats = ['mp3'],
            paths, variants = [];
        names = names.split(' ');
        for (var n = 0; n < names.length; n++) {
            paths = [];
            for (var f = 0; f < formats.length; f++)
                paths.push(STATIC_URL + 'sounds/' + names[n] + '.' + formats[f]);
            variants.push(paths.join('|'));
        }
        return new Sound(variants.join(' '), minDelay);
    }
    return { 'soundPowerUpCollect': sh('powerup_points', 100), 'soundPowerUpScoreMultiplier': sh('powerup_multiplier'), 'soundPowerUpDamageMultiplier': sh('powerup_extra_firepower'), 'soundPowerUpWeaponUpgrade': sh('powerup_weapon'), 'soundPowerUpInvincibility': sh('powerup_immune'), 'soundPowerUpRepair': sh('powerup_repair'), 'soundPowerUpLife': sh('powerup_1up'), 'soundPlayerWeaponChange': sh('weapon_change', 200), 'soundPlayerExplosion': sh('ship_destroyed_respawn'), 'soundPlayerLowLife': sh('warning_life'), 'soundPlayerInvincibility': sh('shield_on_loop'), 'soundPlayerPlasma': sh('fire1'), 'soundPlayerStorm': sh('fire_triple2'), 'soundPlayerRay': sh('fire_ray'), 'soundPlayerRocket': sh('fire_rocket_launch'), 'soundPlayerElectro': sh('fire_electric'), 'soundEnemyPlasma': sh('enemy_plasma', 75), 'soundEnemyLaser': sh('enemy_laser', 75), 'soundEnemyFlak': sh('enemy_flac enemy_flac_alt1 enemy_flac_alt2', 75), 'soundEnemyElectro': sh('enemy_ray_electric'), 'soundRocketFlying': sh('rocket_fly'), 'soundExplosionSmall': sh('explosion_small explosion_small1 explosion_small2 explosion_small3', 75), 'soundExplosionMedium': sh('explosion_medium explosion_medium1 explosion_medium2', 75), 'soundExplosionBig': sh('explosion_big', 75), 'soundShipTeleport': sh('enemy_teleport', 75) };
});
define('skytte/data/backgrounds', ['skytte/entities/background'], function(BackgroundEntity) {
    'use strict';
    var format = require('nebula/format');

    function pathHelper(str, min, max) {
        var result = [];
        for (var i = min; i <= max; i++)
            result.push(format(str, i));
        return result;
    }
    var RED_MUSHROOM = { 'particle': { 'texture': 'mushroom_spore.png', 'tint': 0xd13600 }, 'textures': ['mushroom_1.png', 'mushroom_2.png', 'mushroom_3.png', 'mushroom_4.png'], 'tint': 0xd13600 };
    var GREEN_MUSHROOM = { 'particle': { 'texture': 'mushroom_spore.png', 'tint': 0x86c366 }, 'textures': ['mushroom_1.png', 'mushroom_2.png', 'mushroom_3.png', 'mushroom_4.png'], 'tint': 0x86c366 };
    var WHITE_FOG = { 'texture': 'fog.png', 'tint': 0xffffff, 'scale': { 'x': 8, 'y': 8 } };
    var RED_FOG = { 'texture': 'fog.png', 'tint': 0xd23600, 'scale': { 'x': 8, 'y': 8 } };
    var CRUST = { 'backgroundColor': 0x545204, 'layer4': { 'vx': -40, 'scale': { 'x': 1.875, 'y': 1.875 }, 'align': BackgroundEntity.ALIGN_BOTTOM, 'textures': pathHelper('crust_layer_4_segment_%i.png', 1, 4) }, 'layer3': { 'vx': -80, 'scale': { 'x': 1.875, 'y': 1.25 }, 'align': BackgroundEntity.ALIGN_TOP, 'textures': pathHelper('crust_layer_3_segment_%i.png', 1, 4) }, 'layer2': { 'vx': -160, 'scale': { 'x': 1.875, 'y': 1 }, 'align': BackgroundEntity.ALIGN_BOTTOM, 'textures': pathHelper('crust_layer_2_segment_%i.png', 1, 5) }, 'layer1': { 'vx': -320, 'scale': { 'x': 2, 'y': 2 }, 'align': BackgroundEntity.ALIGN_BOTTOM, 'textures': pathHelper('layer_1_segment_%i.png', 1, 3), 'chance': 0.2 }, 'mushroom': RED_MUSHROOM, 'fog': WHITE_FOG };
    var MANTLE = { 'backgroundColor': 0x505184, 'layer4': { 'vx': -40, 'scale': { 'x': 1.875, 'y': 1.875 }, 'align': BackgroundEntity.ALIGN_BOTTOM, 'textures': pathHelper('mantle_layer_4_segment_%i.png', 1, 4) }, 'layer3': { 'vx': -80, 'scale': { 'x': 1.875, 'y': 1.25 }, 'align': BackgroundEntity.ALIGN_TOP, 'textures': pathHelper('mantle_layer_3_segment_%i.png', 1, 4) }, 'layer2': { 'vx': -160, 'scale': { 'x': 1.875, 'y': 1 }, 'align': BackgroundEntity.ALIGN_BOTTOM, 'textures': pathHelper('mantle_layer_2_segment_%i.png', 1, 5) }, 'layer1': { 'vx': -320, 'scale': { 'x': 2, 'y': 2 }, 'align': BackgroundEntity.ALIGN_BOTTOM, 'textures': pathHelper('layer_1_segment_%i.png', 1, 3), 'chance': 0.2 }, 'mushroom': GREEN_MUSHROOM };
    var CORE = { 'backgroundColor': 0x1a292d, 'layer4': { 'vx': -40, 'scale': { 'x': 1.875, 'y': 2.5 }, 'align': BackgroundEntity.ALIGN_BOTTOM, 'textures': pathHelper('core_layer_4_segment_%i.png', 1, 4) }, 'layer3': { 'vx': -80, 'scale': { 'x': 1.875, 'y': 1.25 }, 'align': BackgroundEntity.ALIGN_TOP, 'textures': pathHelper('core_layer_3_segment_%i.png', 1, 4) }, 'layer2': { 'vx': -160, 'scale': { 'x': 1.875, 'y': 1 }, 'align': BackgroundEntity.ALIGN_BOTTOM, 'textures': pathHelper('core_layer_2_segment_%i.png', 1, 4) }, 'layer1': { 'vx': -320, 'scale': { 'x': 2, 'y': 2 }, 'align': BackgroundEntity.ALIGN_BOTTOM, 'textures': pathHelper('layer_1_segment_%i.png', 1, 3), 'chance': 0.2 }, 'fog': RED_FOG };
    return { 'CRUST': CRUST, 'MANTLE': MANTLE, 'CORE': CORE, 'RED_MUSHROOM': RED_MUSHROOM, 'GREEN_MUSHROOM': GREEN_MUSHROOM, 'WHITE_FOG': WHITE_FOG, };
});
define('skytte/data/weapons', function() { var settings = require('settings'); var Polygon = require('skytte/polygon'); var plasma = require('skytte/weapons/plasma'); var laser = require('skytte/weapons/laser'); var flak = require('skytte/weapons/flak'); var electro = require('skytte/weapons/electro'); var PLAYER_WEAPONS = { 'PLASMA_1': { 'barrelOffset': [63, 13], 'level': 1, 'rateOfFire': 1, 'damage': 50, 'fireSound': 'soundPlayerPlasma', 'fireSoundVolume': settings('PLAYER_PLASMA_VOLUME', 1), 'projectileTexture': 'plasma_1.png', 'projectileExplodeSound': 'soundExplosionSmall', 'texture': 'player_plasma_weapon.png' }, 'PLASMA_2': { 'barrelOffset': [63, 13], 'level': 2, 'rateOfFire': 1.5, 'damage': 85, 'fireSound': 'soundPlayerPlasma', 'fireSoundVolume': settings('PLAYER_PLASMA_VOLUME', 1), 'projectileTexture': 'plasma_2.png', 'projectileExplodeSound': 'soundExplosionSmall', 'texture': 'player_plasma_weapon.png' }, 'PLASMA_3': { 'barrelOffset': [63, 13], 'level': 3, 'rateOfFire': 2, 'damage': 120, 'fireSound': 'soundPlayerPlasma', 'fireSoundVolume': settings('PLAYER_PLASMA_VOLUME', 1), 'projectileTexture': 'plasma_3.png', 'projectileExplodeSound': 'soundExplosionSmall', 'texture': 'player_plasma_weapon.png' }, 'STORM_1': { 'barrelOffset': [63, 12], 'level': 1, 'rateOfFire': 3, 'damage': 20, 'projectileSpread': 80, 'projectileCount': 3, 'fireSound': 'soundPlayerStorm', 'fireSoundVolume': settings('PLAYER_STORM_VOLUME', 1), 'projectileTexture': 'laser_1.png', 'texture': 'player_storm_weapon.png' }, 'STORM_2': { 'barrelOffset': [63, 12], 'level': 2, 'rateOfFire': 3, 'damage': 20, 'projectileSpread': 160, 'projectileCount': 5, 'fireSound': 'soundPlayerStorm', 'fireSoundVolume': settings('PLAYER_STORM_VOLUME', 1), 'projectileTexture': 'laser_2.png', 'texture': 'player_storm_weapon.png' }, 'STORM_3': { 'barrelOffset': [63, 12], 'level': 3, 'rateOfFire': 3, 'damage': 20, 'projectileSpread': 240, 'projectileCount': 7, 'fireSound': 'soundPlayerStorm', 'fireSoundVolume': settings('PLAYER_STORM_VOLUME', 1), 'projectileTexture': 'laser_3.png', 'texture': 'player_storm_weapon.png' }, 'RAY_1': { 'barrelOffset': [62, 13], 'level': 1, 'damage': 100, 'fireSound': 'soundPlayerRay', 'fireSoundVolume': settings('PLAYER_RAY_VOLUME', 1), 'beamTint': 0xc5ff9f, 'texture': 'player_ray_weapon.png' }, 'RAY_2': { 'barrelOffset': [62, 13], 'level': 2, 'damage': 175, 'fireSound': 'soundPlayerRay', 'fireSoundVolume': settings('PLAYER_RAY_VOLUME', 1), 'beamTint': 0xffe2aa, 'texture': 'player_ray_weapon.png' }, 'RAY_3': { 'barrelOffset': [62, 13], 'level': 3, 'damage': 250, 'fireSound': 'soundPlayerRay', 'fireSoundVolume': settings('PLAYER_RAY_VOLUME', 1), 'beamTint': 0xffb0b0, 'texture': 'player_ray_weapon.png' }, 'ROCKETS_1': { 'barrelOffset': [64, 15], 'level': 1, 'rateOfFire': 0.75, 'damage': 80, 'fireSound': 'soundPlayerRocket', 'fireSoundVolume': settings('PLAYER_ROCKETS_VOLUME', 1), 'rocketFlyingSound': 'soundRocketFlying', 'rocketExplodeSound': 'soundExplosionMedium', 'projectileTexture': 'rocket.png', 'texture': 'player_rockets_weapon.png' }, 'ROCKETS_2': { 'barrelOffset': [64, 15], 'level': 2, 'rateOfFire': 1, 'damage': 80, 'fireSound': 'soundPlayerRocket', 'fireSoundVolume': settings('PLAYER_ROCKETS_VOLUME', 1), 'rocketFlyingSound': 'soundRocketFlying', 'rocketExplodeSound': 'soundExplosionMedium', 'projectileTexture': 'rocket.png', 'texture': 'player_rockets_weapon.png' }, 'ROCKETS_3': { 'barrelOffset': [64, 15], 'level': 3, 'rateOfFire': 1.25, 'damage': 80, 'fireSound': 'soundPlayerRocket', 'fireSoundVolume': settings('PLAYER_ROCKETS_VOLUME', 1), 'rocketFlyingSound': 'soundRocketFlying', 'rocketExplodeSound': 'soundExplosionMedium', 'projectileTexture': 'rocket.png', 'texture': 'player_rockets_weapon.png' }, 'ELECTRO_1': { 'barrelOffset': [57, 17], 'level': 1, 'rayCount': 1, 'radius': 240, 'damage': 100, 'fireSound': 'soundPlayerElectro', 'fireSoundVolume': settings('PLAYER_ELECTRO_VOLUME', 1), 'beamTint': 0xc5ff9f, 'projectileFlashTexture': 'electro_flash.png', 'texture': 'player_electro_weapon.png' }, 'ELECTRO_2': { 'barrelOffset': [57, 17], 'level': 2, 'rayCount': 2, 'radius': 280, 'damage': 120, 'fireSound': 'soundPlayerElectro', 'fireSoundVolume': settings('PLAYER_ELECTRO_VOLUME', 1), 'beamTint': 0xffe2aa, 'projectileFlashTexture': 'electro_flash.png', 'texture': 'player_electro_weapon.png' }, 'ELECTRO_3': { 'barrelOffset': [57, 17], 'level': 3, 'rayCount': 3, 'radius': 320, 'damage': 140, 'fireSound': 'soundPlayerElectro', 'fireSoundVolume': settings('PLAYER_ELECTRO_VOLUME', 1), 'beamTint': 0xffb0b0, 'projectileFlashTexture': 'electro_flash.png', 'texture': 'player_electro_weapon.png' } }; var ENEMY_WEAPONS = { 'LASER1': { 'cls': laser.LaserWeapon, 'barrelOffset': [5, 15], 'rateOfFire': 0.5, 'damage': 50, 'direction': 180, 'fireSound': 'soundEnemyLaser', 'fireSoundVolume': settings('ENEMY_LASER_VOLUME', 1), 'projectileSpeed': 300, 'texture': 'laser_weapon.png', 'projectileTexture': 'laser_3.png' }, 'ELECTRO': { 'cls': electro.ElectroWeapon, 'barrelOffset': [16, 12], 'rayCount': 1, 'damage': 40, 'radius': 250, 'fireSound': 'soundEnemyElectro', 'fireSoundVolume': settings('ENEMY_ELECTRO_VOLUME', 1), 'beamTint': 0xffb0b0, 'texture': 'electro_weapon.png', 'projectileFlashTexture': 'electro_flash.png' }, 'PLASMA1': { 'cls': plasma.PlasmaWeapon, 'barrelOffset': [7, 21], 'rateOfFire': 0.75, 'damage': 25, 'direction': 180, 'fireSound': 'soundEnemyPlasma', 'fireSoundVolume': settings('ENEMY_PLASMA_VOLUME', 1), 'texture': 'plasma_weapon.png', 'projectileExplodeSound': 'soundExplosionSmall', 'projectileTexture': 'plasma_3.png' }, 'PLASMA2': { 'cls': plasma.PlasmaWeapon, 'barrelOffset': [6, 24], 'rateOfFire': 0.25, 'damage': 50, 'direction': 180, 'fireSound': 'soundEnemyPlasma', 'fireSoundVolume': settings('ENEMY_PLASMA_VOLUME', 1), 'texture': 'plasma_weapon.png', 'projectileExplodeSound': 'soundExplosionSmall', 'projectileTexture': 'plasma_3.png' }, 'FLAK': { 'cls': flak.FlakWeapon, 'barrelOffset': [0, 18], 'rateOfFire': 0.75, 'damage': 8, 'direction': 180, 'projectileSpeedX': -80, 'fireSound': 'soundEnemyFlak', 'fireSoundVolume': settings('ENEMY_FLAK_VOLUME', 1), 'texture': 'flak_weapon.png', 'projectileTexture': 'flak_3.png' }, 'TURRET_LASER_UP': { 'cls': laser.LaserWeapon, 'barrelOffset': [16, 0], 'rateOfFire': 0.5, 'damage': 20, 'direction': 270, 'fireSound': 'soundEnemyLaser', 'fireSoundVolume': settings('ENEMY_LASER_VOLUME', 1), 'projectileSpeedX': -80, 'projectileSpeedY': -300, 'projectileAngle': 90, 'texture': 'turret_laser_weapon.png', 'projectileTexture': 'laser_3.png' }, 'TURRET_LASER_DOWN': { 'cls': laser.LaserWeapon, 'barrelOffset': [16, 90], 'rateOfFire': 0.5, 'damage': 20, 'direction': 90, 'fireSound': 'soundEnemyLaser', 'fireSoundVolume': settings('ENEMY_LASER_VOLUME', 1), 'projectileSpeedX': -80, 'projectileSpeedY': 300, 'projectileAngle': 90, 'texture': 'turret_laser_weapon.png', 'projectileTexture': 'laser_3.png' }, 'TURRET_FLAK_UP': { 'cls': flak.FlakWeapon, 'barrelOffset': [34, 0], 'rateOfFire': 0.5, 'damage': 8, 'direction': 270, 'projectileSpeedX': -80, 'fireSound': 'soundEnemyFlak', 'fireSoundVolume': settings('ENEMY_FLAK_VOLUME', 1), 'texture': 'turret_flak_weapon.png', 'projectileTexture': 'flak_3.png' }, 'TURRET_FLAK_DOWN': { 'cls': flak.FlakWeapon, 'barrelOffset': [34, 94], 'rateOfFire': 0.5, 'damage': 8, 'direction': 90, 'projectileSpeedX': -80, 'fireSound': 'soundEnemyFlak', 'fireSoundVolume': settings('ENEMY_FLAK_VOLUME', 1), 'texture': 'turret_flak_weapon.png', 'projectileTexture': 'flak_3.png' }, 'TURRET_PLASMA': { 'cls': plasma.PlasmaWeapon, 'barrelOffset': [10, 32], 'rateOfFire': 0.5, 'damage': 75, 'direction': 180, 'fireSound': 'soundEnemyPlasma', 'fireSoundVolume': settings('ENEMY_PLASMA_VOLUME', 1), 'projectileExplodeSound': 'soundExplosionSmall', 'texture': 'cart_plasma_weapon.png', 'projectileTexture': 'plasma_3.png' } }; return { 'PLAYER_WEAPONS': PLAYER_WEAPONS, 'ENEMY_WEAPONS': ENEMY_WEAPONS }; });
define('skytte/data/powerups', ['settings', 'skytte/bounding_box', 'skytte/entities/ship'], function(settings, BoundingBox, ShipEntity) {
    function multiplyWeaponsDamage(game, multiplier) {
        var weapon;
        for (var l = 0; l < game.allWeapons.length; l++)
            for (var i = 0; i < game.allWeapons[l].length; i++) {
                weapon = game.allWeapons[l][i];
                if (weapon._originalDamage === -1)
                    weapon._originalDamage = weapon.damage;
                weapon.damage *= multiplier;
            }
    }

    function restoreWeaponsDamage(game) {
        var weapon;
        for (var l = 0; l < game.allWeapons.length; l++)
            for (var i = 0; i < game.allWeapons[l].length; i++) { weapon = game.allWeapons[l][i]; if (weapon._originalDamage !== -1) { weapon.damage = weapon._originalDamage;
                    weapon._originalDamage = -1; } }
    }
    var PLAYER_TEAM = 1;
    var ENEMY_TEAM = 2;
    var POWERUP_BOX = BoundingBox.fromString('-12,-12 24,24');
    var POWERUP_MASS = 40;
    var POWERUP_SCORE_1 = { 'texture': 'powerup_score_1.png', 'sound': 'soundPowerUpCollect', 'soundVolume': settings('POWERUP_SCORE_VOLUME', 1), 'score': 50, 'vx': -80, 'box': POWERUP_BOX, 'mass': POWERUP_MASS, 'team': PLAYER_TEAM };
    var POWERUP_SCORE_2 = { 'texture': 'powerup_score_2.png', 'sound': 'soundPowerUpCollect', 'soundVolume': settings('POWERUP_SCORE_VOLUME', 1), 'score': 150, 'vx': -80, 'box': POWERUP_BOX, 'mass': POWERUP_MASS, 'team': PLAYER_TEAM };
    var POWERUP_SCORE_3 = { 'texture': 'powerup_score_3.png', 'sound': 'soundPowerUpCollect', 'soundVolume': settings('POWERUP_SCORE_VOLUME', 1), 'score': 500, 'vx': -80, 'box': POWERUP_BOX, 'mass': POWERUP_MASS, 'team': PLAYER_TEAM };
    var POWERUP_REPAIR = { 'sound': 'soundPowerUpRepair', 'soundVolume': settings('POWERUP_REPAIR_VOLUME', 1), 'texture': 'powerup_repair.png', 'box': POWERUP_BOX, 'team': PLAYER_TEAM, 'vx': -80, 'mass': POWERUP_MASS, 'collectFunc': function(game, powerUp) { game.player.health = game.player.maxHealth;
            game.player.shield = game.player.maxShield; } };
    var POWERUP_SCORE_MULTIPLIER_X2 = { 'sound': 'soundPowerUpScoreMultiplier', 'soundVolume': settings('POWERUP_SCORE_MULTIPLIER_VOLUME', 1), 'texture': 'powerup_multiplier_1.png', 'box': POWERUP_BOX, 'team': PLAYER_TEAM, 'vx': -80, 'mass': POWERUP_MASS, 'score': 50, 'collectFunc': function(game) { game.multiplier += 2; } };
    var POWERUP_SCORE_MULTIPLIER_X3 = { 'sound': 'soundPowerUpScoreMultiplier', 'soundVolume': settings('POWERUP_SCORE_MULTIPLIER_VOLUME', 1), 'texture': 'powerup_multiplier_2.png', 'box': POWERUP_BOX, 'team': PLAYER_TEAM, 'vx': -80, 'mass': POWERUP_MASS, 'score': 50, 'collectFunc': function(game) { game.multiplier += 3; } };
    var POWERUP_SCORE_MULTIPLIER_X4 = { 'sound': 'soundPowerUpScoreMultiplier', 'soundVolume': settings('POWERUP_SCORE_MULTIPLIER_VOLUME', 1), 'texture': 'powerup_multiplier_3.png', 'box': POWERUP_BOX, 'team': PLAYER_TEAM, 'vx': -80, 'mass': POWERUP_MASS, 'score': 50, 'collectFunc': function(game) { game.multiplier += 4; } };
    var POWERUP_DAMAGE_MULTIPLIER_X2 = { 'sound': 'soundPowerUpDamageMultiplier', 'soundVolume': settings('POWERUP_DAMAGE_MULTIPLIER_VOLUME', 1), 'texture': 'powerup_damage_1.png', 'box': POWERUP_BOX, 'team': PLAYER_TEAM, 'duration': 15000, 'vx': -80, 'mass': POWERUP_MASS, 'collectFunc': function(game) { multiplyWeaponsDamage(game, 2); }, 'expiredFunc': restoreWeaponsDamage };
    var POWERUP_DAMAGE_MULTIPLIER_X3 = { 'sound': 'soundPowerUpDamageMultiplier', 'soundVolume': settings('POWERUP_DAMAGE_MULTIPLIER_VOLUME', 1), 'texture': 'powerup_damage_2.png', 'box': POWERUP_BOX, 'team': PLAYER_TEAM, 'duration': 15000, 'vx': -80, 'mass': POWERUP_MASS, 'collectFunc': function(game) { multiplyWeaponsDamage(game, 3); }, 'expiredFunc': restoreWeaponsDamage };
    var POWERUP_DAMAGE_MULTIPLIER_X4 = { 'sound': 'soundPowerUpDamageMultiplier', 'soundVolume': settings('POWERUP_DAMAGE_MULTIPLIER_VOLUME', 1), 'texture': 'powerup_damage_3.png', 'box': POWERUP_BOX, 'team': PLAYER_TEAM, 'duration': 15000, 'vx': -80, 'mass': POWERUP_MASS, 'collectFunc': function(game) { multiplyWeaponsDamage(game, 4); }, 'expiredFunc': restoreWeaponsDamage };
    var POWERUP_LIFE = { 'sound': 'soundPowerUpLife', 'soundVolume': settings('POWERUP_LIFE_VOLUME', 1), 'texture': 'powerup_life.png', 'box': POWERUP_BOX, 'team': PLAYER_TEAM, 'vx': -80, 'mass': POWERUP_MASS, 'collectFunc': function(game) { game.lifes += 1; } };
    var POWERUP_INVINCIBILITY = { 'sound': 'soundPowerUpInvincibility', 'soundVolume': settings('POWERUP_INVINCIBILITY_VOLUME', 1), 'texture': 'powerup_invincibility.png', 'box': POWERUP_BOX, 'team': PLAYER_TEAM, 'duration': 25000, 'vx': -80, 'mass': POWERUP_MASS, 'collectFunc': function(game) { game.player.invincibleTime += 20000; } };
    var POWERUP_KILL_ALL = { 'texture': 'powerup_kill_all.png', 'box': POWERUP_BOX, 'team': PLAYER_TEAM, 'vx': -80, 'mass': POWERUP_MASS, 'collectFunc': function(game) { var entity; for (var i = 0; i < game.entities.length; i++) { entity = game.entities[i]; if (entity instanceof ShipEntity && entity.team === game.ENEMY_TEAM) { entity.health = 0;
                    entity.explode(); } } } };
    var POWERUP_WEAPON_UPGRADE = {
        'sound': 'soundPowerUpWeaponUpgrade',
        'soundVolume': settings('POWERUP_WEAPON_UPGRADE_VOLUME', 1),
        'texture': 'powerup_weapon_upgrade.png',
        'box': POWERUP_BOX,
        'team': PLAYER_TEAM,
        'vx': -80,
        'mass': POWERUP_MASS,
        'collectFunc': function(game) {
            if (game.getCurrentWeapon().level < 3)
                game.upgradeWeapon(game.currentWeapon);
            else {
                for (var i = 0; i < game.weapons.length; i++)
                    if (game.weapons[i].level < 3) { game.upgradeWeapon(i); return }
                game.makePowerUp(this.position.x, this.position.y, POWERUP_SCORE_3);
                this.dead = true;
            }
        }
    };
    var POWERUP_RANDOM = { 'texture': 'powerup_random.png', 'box': POWERUP_BOX, 'team': PLAYER_TEAM, 'vx': -80, 'mass': POWERUP_MASS, 'choices': [POWERUP_SCORE_3, POWERUP_SCORE_MULTIPLIER_X4, POWERUP_DAMAGE_MULTIPLIER_X4, POWERUP_LIFE, POWERUP_INVINCIBILITY, POWERUP_KILL_ALL, POWERUP_WEAPON_UPGRADE], 'collectFunc': function(game) { var powerUpConfig = this.choices[Math.floor(Math.random() * this.choices.length)];
            game.makePowerUp(this.position.x, this.position.y, powerUpConfig);
            this.dead = true; } };
    return { 'POWERUP_SCORE_1': POWERUP_SCORE_1, 'POWERUP_SCORE_2': POWERUP_SCORE_2, 'POWERUP_SCORE_3': POWERUP_SCORE_3, 'POWERUP_REPAIR': POWERUP_REPAIR, 'POWERUP_SCORE_MULTIPLIER_X2': POWERUP_SCORE_MULTIPLIER_X2, 'POWERUP_SCORE_MULTIPLIER_X3': POWERUP_SCORE_MULTIPLIER_X3, 'POWERUP_SCORE_MULTIPLIER_X4': POWERUP_SCORE_MULTIPLIER_X4, 'POWERUP_DAMAGE_MULTIPLIER_X2': POWERUP_DAMAGE_MULTIPLIER_X2, 'POWERUP_DAMAGE_MULTIPLIER_X3': POWERUP_DAMAGE_MULTIPLIER_X3, 'POWERUP_DAMAGE_MULTIPLIER_X4': POWERUP_DAMAGE_MULTIPLIER_X4, 'POWERUP_LIFE': POWERUP_LIFE, 'POWERUP_INVINCIBILITY': POWERUP_INVINCIBILITY, 'POWERUP_KILL_ALL': POWERUP_KILL_ALL, 'POWERUP_WEAPON_UPGRADE': POWERUP_WEAPON_UPGRADE, 'POWERUP_RANDOM': POWERUP_RANDOM };
});
define('skytte/data/ships', function() { 'use strict'; var BoundingBox = require('skytte/bounding_box'); var Polygon = require('skytte/polygon'); var weapons = require('skytte/data/weapons'); var powerups = require('skytte/data/powerups'); var PLAYER_TEAM = 1; var ENEMY_TEAM = 2; var PLAYER_FIRE_WHITE = { 'spawnSpeed': 15, 'particle': { 'direction': 180, 'directionSpread': 5, 'speed': 30, 'life': 0.5, 'texture': 'fire.png', 'tint': 0xffffff, 'update': function(elapsed) { this.update(elapsed);
                this.size = this.p * 0.5 * 0.5; } } }; var PLAYER_FIRE_ORANGE = { 'spawnSpeed': 15, 'particle': { 'direction': 180, 'directionSpread': 10, 'speed': 30, 'life': 1, 'texture': 'fire.png', 'tint': 0xffb649, 'update': function(elapsed) { this.update(elapsed);
                this.size = this.p * 1.25 * 0.5; } } }; var PLAYER_FIRE_RED = { 'spawnSpeed': 15, 'particle': { 'direction': 180, 'directionSpread': 15, 'speed': 30, 'life': 1.5, 'texture': 'fire.png', 'tint': 0xf04b2d, 'update': function(elapsed) { this.update(elapsed);
                this.size = this.p * 2.25 * 0.5; } } }; var MEDIUM_ENEMY_FIRE_WHITE = { 'spawnSpeed': 10, 'particle': { 'direction': 0, 'directionSpread': 90, 'speed': 30, 'life': 0.4, 'texture': 'fire.png', 'tint': 0xffffff, 'update': function(elapsed) { this.update(elapsed);
                this.size = this.p * 0.75 * 2;
                this.velocity.y *= 0.7; } } }; var MEDIUM_ENEMY_FIRE_ORANGE = { 'spawnSpeed': 15, 'particle': { 'direction': 0, 'directionSpread': 90, 'speed': 30, 'life': 0.8, 'texture': 'fire.png', 'tint': 0xffb649, 'update': function(elapsed) { this.update(elapsed);
                this.size = this.p * 1.5 * 2;
                this.velocity.y *= 0.8; } } }; var MEDIUM_ENEMY_FIRE_RED = { 'spawnSpeed': 20, 'particle': { 'direction': 0, 'directionSpread': 90, 'speed': 35, 'life': 1.2, 'texture': 'fire.png', 'tint': 0xf04b2d, 'update': function(elapsed) { this.update(elapsed);
                this.size = this.p * 2 * 2;
                this.velocity.y *= 0.85; } } }; var BIG_ENEMY_FIRE_WHITE = { 'spawnSpeed': 10, 'particle': { 'direction': 0, 'directionSpread': 90, 'speed': 40, 'life': 0.5, 'texture': 'fire.png', 'tint': 0xffffff, 'update': function(elapsed) { this.update(elapsed);
                this.size = this.p * 1 * 2;
                this.velocity.y *= 0.8; } } }; var BIG_ENEMY_FIRE_ORANGE = { 'spawnSpeed': 15, 'particle': { 'direction': 0, 'directionSpread': 90, 'speed': 40, 'life': 1, 'texture': 'fire.png', 'tint': 0xffb649, 'update': function(elapsed) { this.update(elapsed);
                this.size = this.p * 1.75 * 2;
                this.velocity.y *= 0.85; } } }; var BIG_ENEMY_FIRE_RED = { 'spawnSpeed': 20, 'particle': { 'direction': 0, 'directionSpread': 90, 'speed': 45, 'life': 1.5, 'texture': 'fire.png', 'tint': 0xf04b2d, 'update': function(elapsed) { this.update(elapsed);
                this.size = this.p * 3 * 2;
                this.velocity.y *= 0.9; } } }; var PLAYER_SHIP = { 'texture': 'player_ship.png', 'team': PLAYER_TEAM, 'speed': 300, 'mass': 750, 'health': 250, 'shield': 500, 'shieldPerSecond': 10, 'healthPerSecond': 2, 'explosionRadius': 250, 'explosionDamage': 100, 'explosionSound': 'soundPlayerExplosion', 'polygon': '5,0 20,0 53,24 64,52 54,69 26,76 13,76 1,26', 'engines': [] }; var MINE = { 'explosionSound': 'soundExplosionMedium', 'texture': 'mine_ship.png', 'team': ENEMY_TEAM, 'speed': 80, 'mass': 75, 'health': 10, 'shield': 0, 'score': 5, 'explosionDamage': 5, 'explosionRadius': 100, 'detonateDamage': 50, 'detonateRadius': 100, 'box': '10,8 52,54', 'powerUps': { 'chance': 0.5, 'choices': [powerups.POWERUP_SCORE_1], } }; var AGGRESSIVE_MINE = { 'explosionSound': 'soundExplosionMedium', 'texture': 'advanced_mine_ship.png', 'team': ENEMY_TEAM, 'speed': 140, 'mass': 75, 'health': 15, 'shield': 0, 'score': 10, 'explosionDamage': 5, 'explosionRadius': 100, 'detonateDamage': 50, 'detonateRadius': 100, 'box': '10,8 52,54', 'powerUps': { 'chance': 0.5, 'choices': [powerups.POWERUP_SCORE_2], } }; var SWARM = { 'explosionSound': 'soundExplosionSmall', 'texture': 'swarm_ship.png', 'team': ENEMY_TEAM, 'speed': 150, 'mass': 50, 'health': 15, 'shield': 0, 'score': 2, 'explosionDamage': 0.25, 'explosionRadius': 75, 'box': '-1,5 43,43', 'powerUps': { 'chance': 0.25, 'choices': [powerups.POWERUP_SCORE_1], } }; var FIGHTER = { 'explosionSound': 'soundExplosionMedium', 'texture': 'fighter_ship.png', 'team': ENEMY_TEAM, 'speed': 140, 'mass': 200, 'health': 100, 'shield': 0, 'score': 75, 'explosionDamage': 50, 'explosionRadius': 150, 'polygon': '38,-7 91,-14 95,48 76,51 4,51 -1,33 18,8', 'engines': [], 'weapons': [{ 'x': 28, 'y': -15, 'weapon': weapons.ENEMY_WEAPONS.LASER1 }], 'powerUps': { 'chance': 0.5, 'choices': [powerups.POWERUP_SCORE_1, powerups.POWERUP_SCORE_MULTIPLIER_X2], } }; var TELEPORTER = { 'explosionSound': 'soundExplosionMedium', 'texture': 'teleporter_ship.png', 'team': ENEMY_TEAM, 'speed': 140, 'mass': 200, 'health': 50, 'shield': 200, 'score': 100, 'explosionDamage': 50, 'explosionRadius': 130, 'polygon': '58,2 70,3 78,28 80,46 71,56 34,57 -4,50 3,22', 'engines': [], 'weapons': [{ 'x': 4, 'y': 36, 'weapon': weapons.ENEMY_WEAPONS.LASER1 }], 'AI': { 'delay': 2000, 'teleportTime': 1000 }, 'powerUps': { 'chance': 0.5, 'choices': [powerups.POWERUP_SCORE_2, powerups.POWERUP_SCORE_MULTIPLIER_X3], } }; var ELECTRICIAN = { 'explosionSound': 'soundExplosionMedium', 'texture': 'electrician_ship.png', 'team': ENEMY_TEAM, 'speed': 250, 'mass': 200, 'health': 250, 'shield': 500, 'score': 100, 'explosionDamage': 50, 'explosionRadius': 170, 'polygon': '45,-1 84,21 103,45 104,62 58,81 14,66 1,29 20,7', 'engines': [], 'weapons': [{ 'x': 4, 'y': 54, 'weapon': weapons.ENEMY_WEAPONS.ELECTRO }], 'powerUps': { 'chance': 0.5, 'choices': [powerups.POWERUP_SCORE_2, powerups.POWERUP_SCORE_MULTIPLIER_X3], } }; var TANK = { 'explosionSound': 'soundExplosionBig', 'texture': 'tank_ship.png', 'team': ENEMY_TEAM, 'speed': 90, 'mass': 400, 'health': 350, 'shield': 1000, 'score': 200, 'explosionDamage': 150, 'explosionRadius': 150, 'polygon': '47,2 97,16 109,27 109,46 100,108 13,116 -8,103 -4,55 3,25 21,8', 'engines': [], 'weapons': [{ 'x': -18, 'y': 73, 'weapon': weapons.ENEMY_WEAPONS.PLASMA1 }], 'powerUps': { 'chance': 0.5, 'choices': [powerups.POWERUP_SCORE_3, powerups.POWERUP_SCORE_MULTIPLIER_X4, powerups.POWERUP_DAMAGE_MULTIPLIER_X3], } }; var FRIGATE = { 'explosionSound': 'soundExplosionBig', 'texture': 'frigate_ship.png', 'team': ENEMY_TEAM, 'speed': 90, 'mass': 700, 'health': 500, 'shield': 1500, 'score': 300, 'explosionDamage': 200, 'explosionRadius': 250, 'polygon': '66,-19 114,-20 186,3 187,53 178,117 108,161 50,162 6,113 -13,76 17,18', 'engines': [], 'weapons': [{ 'x': 45, 'y': -29, 'weapon': weapons.ENEMY_WEAPONS.PLASMA2 }, { 'x': 48, 'y': 134, 'weapon': weapons.ENEMY_WEAPONS.PLASMA2 }, { 'x': -10, 'y': 69, 'weapon': weapons.ENEMY_WEAPONS.FLAK }], 'powerUps': { 'chance': 0.5, 'choices': [powerups.POWERUP_SCORE_MULTIPLIER_X4, powerups.POWERUP_DAMAGE_MULTIPLIER_X4, powerups.POWERUP_INVINCIBILITY], } }; var LASER_TURRET_UP = { 'explosionSound': 'soundExplosionMedium', 'texture': 'turret_2_ship.png', 'team': ENEMY_TEAM, 'speed': 80, 'health': 500, 'shield': 0, 'mass': 100000, 'score': 40, 'explosionDamage': 50, 'explosionRadius': 150, 'box': '23,-45 42,140', 'weapons': [{ 'x': 28, 'y': -44, 'weapon': weapons.ENEMY_WEAPONS.TURRET_LASER_UP }], 'powerUps': { 'chance': 0.25, 'choices': [powerups.POWERUP_SCORE_2, powerups.POWERUP_SCORE_MULTIPLIER_X2, powerups.POWERUP_DAMAGE_MULTIPLIER_X2], } }; var LASER_TURRET_DOWN = { 'explosionSound': 'soundExplosionMedium', 'texture': 'turret_2_ship.png', 'team': ENEMY_TEAM, 'speed': 80, 'health': 500, 'shield': 0, 'mass': 100000, 'score': 40, 'explosionDamage': 50, 'explosionRadius': 150, 'box': '23,-45 42,140', 'scale': { 'x': 1, 'y': -1 }, 'weapons': [{ 'x': 28, 'y': -44, 'weapon': weapons.ENEMY_WEAPONS.TURRET_LASER_DOWN }], 'powerUps': { 'chance': 0.25, 'choices': [powerups.POWERUP_SCORE_2, powerups.POWERUP_SCORE_MULTIPLIER_X2, powerups.POWERUP_DAMAGE_MULTIPLIER_X2], } }; var FLAK_TURRET_UP = { 'explosionSound': 'soundExplosionMedium', 'texture': 'turret_1_ship.png', 'team': ENEMY_TEAM, 'speed': 80, 'health': 700, 'shield': 0, 'mass': 100000, 'score': 40, 'explosionDamage': 50, 'explosionRadius': 150, 'box': '23,-48 42,136', 'weapons': [{ 'x': 16, 'y': -45, 'weapon': weapons.ENEMY_WEAPONS.TURRET_FLAK_UP }], 'powerUps': { 'chance': 0.25, 'choices': [powerups.POWERUP_SCORE_3, powerups.POWERUP_SCORE_MULTIPLIER_X3, powerups.POWERUP_DAMAGE_MULTIPLIER_X2], } }; var FLAK_TURRET_DOWN = { 'explosionSound': 'soundExplosionMedium', 'texture': 'turret_1_ship.png', 'team': ENEMY_TEAM, 'speed': 80, 'health': 700, 'shield': 0, 'mass': 100000, 'score': 40, 'explosionDamage': 50, 'explosionRadius': 150, 'box': '23,-50 42,136', 'scale': { 'x': 1, 'y': -1 }, 'weapons': [{ 'x': 16, 'y': -45, 'weapon': weapons.ENEMY_WEAPONS.TURRET_FLAK_DOWN }], 'powerUps': { 'chance': 0.25, 'choices': [powerups.POWERUP_SCORE_3, powerups.POWERUP_SCORE_MULTIPLIER_X3, powerups.POWERUP_DAMAGE_MULTIPLIER_X2], } }; var CART_TURRET = { 'explosionSound': 'soundExplosionBig', 'texture': 'cart_ship.png', 'team': ENEMY_TEAM, 'speed': 80, 'verticalSpeed': 100, 'health': 1100, 'shield': 0, 'mass': 100000, 'score': 100, 'explosionDamage': 50, 'explosionRadius': 150, 'box': '-67,32 124,60', 'weapons': [{ 'x': -65, 'y': 38, 'weapon': weapons.ENEMY_WEAPONS.TURRET_PLASMA }], 'powerUps': { 'chance': 0.25, 'choices': [powerups.POWERUP_SCORE_MULTIPLIER_X4, powerups.POWERUP_DAMAGE_MULTIPLIER_X4], } }; return { 'PLAYER_SHIP': PLAYER_SHIP, 'MINE': MINE, 'AGGRESSIVE_MINE': AGGRESSIVE_MINE, 'SWARM': SWARM, 'FIGHTER': FIGHTER, 'TELEPORTER': TELEPORTER, 'ELECTRICIAN': ELECTRICIAN, 'TANK': TANK, 'FRIGATE': FRIGATE, 'LASER_TURRET_UP': LASER_TURRET_UP, 'LASER_TURRET_DOWN': LASER_TURRET_DOWN, 'FLAK_TURRET_UP': FLAK_TURRET_UP, 'FLAK_TURRET_DOWN': FLAK_TURRET_DOWN, 'CART_TURRET': CART_TURRET, }; });
define('skytte/data/levels', function() {
    var utils = require('skytte/utils');
    var LabelEntity = require('skytte/entities/label');
    var backgrounds = require('skytte/data/backgrounds');
    var weapons = require('skytte/data/weapons');
    var powerups = require('skytte/data/powerups');
    var ships = require('skytte/data/ships');
    var LEVEL_1_CHOICES = [{ 'type': 'Swarm', 'config': ships.SWARM, 'args': [640, 80, 10, 170], 'difficulty': 20 }, { 'type': 'Fighter', 'config': ships.FIGHTER, 'difficulty': 30 }];
    var LEVEL_2_CHOICES = [{ 'type': 'Swarm', 'config': ships.SWARM, 'args': [640, 160, 10, 170], 'difficulty': 15 }, { 'type': 'Fighter', 'config': ships.FIGHTER, 'difficulty': 30 }, { 'type': 'LaserTurretUp', 'config': ships.LASER_TURRET_UP, 'difficulty': 30 }, { 'type': 'LaserTurretDown', 'config': ships.LASER_TURRET_DOWN, 'difficulty': 30 }, { 'type': 'Teleporter', 'config': ships.TELEPORTER, 'difficulty': 45 }];
    var LEVEL_3_CHOICES = [{ 'type': 'Swarm', 'config': ships.SWARM, 'args': [640, 320, 15, 170], 'difficulty': 15 }, { 'type': 'Fighter', 'config': ships.FIGHTER, 'difficulty': 30 }, { 'type': 'Teleporter', 'config': ships.TELEPORTER, 'difficulty': 45 }, { 'type': 'Tank', 'config': ships.TANK, 'difficulty': 100 }, { 'type': 'LaserTurretUp', 'config': ships.LASER_TURRET_UP, 'difficulty': 30 }, { 'type': 'LaserTurretDown', 'config': ships.LASER_TURRET_DOWN, 'difficulty': 30 }];
    var LEVEL_4_CHOICES = [{ 'type': 'Swarm', 'config': ships.SWARM, 'args': [640, 320, 15, 170], 'difficulty': 15 }, { 'type': 'Fighter', 'config': ships.FIGHTER, 'difficulty': 30 }, { 'type': 'Teleporter', 'config': ships.TELEPORTER, 'difficulty': 45 }, { 'type': 'Electrician', 'config': ships.ELECTRICIAN, 'difficulty': 60 }, { 'type': 'Tank', 'config': ships.TANK, 'difficulty': 100 }, { 'type': 'LaserTurretUp', 'config': ships.LASER_TURRET_UP, 'difficulty': 30 }, { 'type': 'LaserTurretDown', 'config': ships.LASER_TURRET_DOWN, 'difficulty': 30 }];
    var LEVEL_5_CHOICES = [{ 'type': 'Swarm', 'y': 0, 'config': ships.SWARM, 'args': [640, 320, 15, 170], 'difficulty': 10 }, { 'type': 'Fighter', 'config': ships.FIGHTER, 'difficulty': 10 }, { 'type': 'Teleporter', 'config': ships.TELEPORTER, 'difficulty': 15 }, { 'type': 'Electrician', 'config': ships.ELECTRICIAN, 'difficulty': 15 }, { 'type': 'Tank', 'config': ships.TANK, 'difficulty': 35 }, { 'type': 'Frigate', 'config': ships.FRIGATE, 'difficulty': 50 }, { 'type': 'LaserTurretUp', 'config': ships.LASER_TURRET_UP, 'difficulty': 15 }, { 'type': 'LaserTurretDown', 'config': ships.LASER_TURRET_DOWN, 'difficulty': 15 }, { 'type': 'FlakTurretUp', 'config': ships.FLAK_TURRET_UP, 'difficulty': 25 }, { 'type': 'FlakTurretDown', 'config': ships.FLAK_TURRET_DOWN, 'difficulty': 25 }, { 'type': 'CartTurret', 'config': ships.CART_TURRET, 'difficulty': 40 }];
    var LEVEL_6_CHOICES = [{ 'type': 'Swarm', 'y': 0, 'config': ships.SWARM, 'args': [640, 320, 15, 170], 'difficulty': 10 }, { 'type': 'Fighter', 'config': ships.FIGHTER, 'difficulty': 10 }, { 'type': 'Teleporter', 'config': ships.TELEPORTER, 'difficulty': 15 }, { 'type': 'Electrician', 'config': ships.ELECTRICIAN, 'difficulty': 15 }, { 'type': 'Tank', 'config': ships.TANK, 'difficulty': 35 }, { 'type': 'Frigate', 'config': ships.FRIGATE, 'difficulty': 50 }, { 'type': 'LaserTurretUp', 'config': ships.LASER_TURRET_UP, 'difficulty': 15 }, { 'type': 'LaserTurretDown', 'config': ships.LASER_TURRET_DOWN, 'difficulty': 15 }, { 'type': 'FlakTurretUp', 'config': ships.FLAK_TURRET_UP, 'difficulty': 25 }, { 'type': 'FlakTurretDown', 'config': ships.FLAK_TURRET_DOWN, 'difficulty': 25 }, { 'type': 'CartTurret', 'config': ships.CART_TURRET, 'difficulty': 40 }];
    var RESPAWN_TEXT_TEXTURES = { ' ': 'font_space.png', '-': 'font_red_minus.png', '1': 'font_red_1.png', 'h': 'powerup_life.png' };

    function respawnPlayer(game, level) {
        game.expireActivePowerUp();
        var center = game.player.center;
        var label = new LabelEntity(game, center.x, center.y, { 'textures': RESPAWN_TEXT_TEXTURES, 'text': '-1 h', 'life': 3500 });
        game.addEntity(label);
        if (game.lifes > 0) {
            game.lifes -= 1;
            game.makePlayerShip(game.player.position.x, game.player.position.y, ships.PLAYER_SHIP);
            game.player.invincibleTime += 5000;
            if (game.currentWeapon >= 0) {
                game.changeWeapon(game.currentWeapon);
                if (game.autofire)
                    game.player.startShooting();
            }
        } else { game.resetCombo();
            game.player = null; }
    }

    function randomEnemies(time, difficulty, interval, choices) {
        var choice, events = [];
        while (difficulty > 0) { choice = choices[Math.floor(Math.random() * choices.length)];
            events.push(utils.merge({ 'at': time }, choice));
            time += interval;
            difficulty -= choice.difficulty; }
        return events;
    }

    function smartPowerUp(game) {
        if (!game.level.events.length || !game.player)
            return;
        var x = game.cameraWidth,
            y = Math.random() * game.WORLD.HEIGHT;
        var r = Math.random();
        if (game.player.health <= game.player.maxHealth / 2 && game.player.shield <= game.player.maxShield) {
            if (game.lifes === 0)
                game.makePowerUp(x, y, powerups.POWERUP_LIFE);
            else
                game.makePowerUp(x, y, powerups.POWERUP_REPAIR);
        } else if (game._enemyCount > 35)
            game.makePowerUp(x, y, powerups.POWERUP_KILL_ALL);
        else {
            if (r < .6)
                game.makePowerUp(x, y, powerups.POWERUP_WEAPON_UPGRADE);
            else if (r < .7)
                game.makePowerUp(x, y, powerups.POWERUP_INVINCIBILITY);
            else if (r < .8)
                game.makePowerUp(x, y, powerups.POWERUP_RANDOM);
        }
    }

    function generateLevel(n, scenery, choices, difficulty, segmentCount) {
        var segments = [{ 'type': 'Scenery', 'config': scenery }, { 'type': 'HUD' }, { 'type': 'PlayerShip', 'x': 100, 'y': 100, 'config': ships.PLAYER_SHIP }, { 'signal': 'playerDied', 'receiver': respawnPlayer }];
        if (n === 1) { segments.push({ 'type': 'PlayerWeapons', 'config': weapons.PLAYER_WEAPONS });
            segments.push({ 'at': 3, 'type': 'Hint', 'y': 200, 'config': { 'texture': 'hint_touchscreen', 'vx': -80 } });
            segments = segments.concat([{ 'at': 90, 'type': 'PowerUp', 'config': powerups.POWERUP_WEAPON_UPGRADE }, { 'at': 20, 'every': 1.5, 'type': 'Mine', 'config': ships.MINE }]); } else
            segments = segments.concat([{ 'at': 25, 'every': 25, 'type': smartPowerUp }, { 'at': 5, 'every': Math.max(0.5, 1.5 - (n - 1) / 10), 'type': 'Mine', 'config': ships.MINE }, { 'at': 5, 'every': Math.max(1, 4 - (n - 1) / 10), 'type': 'AggressiveMine', 'config': ships.AGGRESSIVE_MINE }, ]);
        if (choices && choices.length) { var time = n === 1 ? 40 : 3; for (var i = 1; i < segmentCount + 1; i++) { segments = segments.concat(randomEnemies(time, difficulty * 10 + difficulty * i * i, 2.5 - Math.min(2, i * i * 5 / 1000), choices));
                time = segments[segments.length - 1].at + 2; } }
        return { 'events': segments };
    }

    function generateGame() { return [generateLevel(1, backgrounds.CRUST, LEVEL_1_CHOICES, 1, 12), generateLevel(2, backgrounds.CRUST, LEVEL_2_CHOICES, 3, 12), generateLevel(3, backgrounds.MANTLE, LEVEL_3_CHOICES, 4, 12), generateLevel(4, backgrounds.MANTLE, LEVEL_4_CHOICES, 5, 12), generateLevel(4, backgrounds.CORE, LEVEL_5_CHOICES, 6, 12), generateLevel(5, backgrounds.CORE, LEVEL_6_CHOICES, 7, 12)]; }
    return { 'generateGame': generateGame, 'generateLevel': generateLevel, 'respawnPlayer': respawnPlayer, 'randomEnemies': randomEnemies };
});
define('main', ['settings', 'nebula/numbers', 'skytte/level', 'skytte/game', 'skytte/data/levels', 'skytte/data/resources'], function(settings, numbers, Level, Game, levels, RESOURCES) {
    var format = require('nebula/format');
    var keyboard = require('nebula/input/keyboard');
    var Vector2 = require('skytte/vector2');
    var DEBUG = settings('DEBUG');
    PIXI.ticker.shared.autoStart = false;
    PIXI.ticker.shared.stop();
    PIXI.loader._queue.concurrency = 100;
    createjs.Sound.defaultInterruptBehavior = createjs.Sound.INTERRUPT_LATE;
    var screen = document.getElementById('screen');
    var game = new Game(screen, 1, DEBUG, RESOURCES);
    var gameLevels = null;
    var currentLevel = -1;
    var highscore = {};
    var audio = true;
    var music = true;
    try { audio = JSON.parse(localStorage.getItem('skytte.audio'));
        music = JSON.parse(localStorage.getItem('skytte.music')); } catch (e) {}
    var musicTrack = document.getElementById('music');
    var menu = jQuery('.game>.menu');
    var mainMenu = jQuery('@menu-main');
    var loadingMenu = jQuery('@menu-loading');
    var pauseMenu = jQuery('@menu-pause');
    var restartMenu = jQuery('@menu-restart');
    var gameSummaryMenu = jQuery('@menu-game-summary');
    var levelSummaryMenu = jQuery('@menu-level-summary');
    try { loadHighscore(localStorage.getItem('skytte.highscore') || '{}', highscore); } catch (e) { loadHighscore('{}', highscore); }

    function resize() { var width = window.innerWidth; var height = window.innerHeight; var scaleX = width / 960; var scaleY = height / 640; var scale = Math.min(scaleX, scaleY); var menuX = (width / scale - 960) / 2; var menuY = (height / scale - 640) / 2;
        menu.children().css('transform', 'scale(' + scale + ') translate(' + menuX + 'px, ' + menuY + 'px)');
        game.resize(width, height, scale);
        jQuery('@pause-game').css('transform', 'scale(' + (height / 640) + ')'); }
    resize();
    window.addEventListener('resize', resize);
    if (typeof audio !== 'boolean')
        audio = true;
    if (typeof music !== 'boolean')
        music = true;
    jQuery('@toggle-audio').toggleClass('active', audio);
    jQuery('@toggle-music').toggleClass('active', music);
    musicTrack.volume = settings('MUSIC_VOLUME', 1);
    updateStatsTables();
    menu.addClass('visible');
    showMenuScreen(mainMenu);
    mainMenu.find('@new-game').focus();
    loadingMenu.find('@play-game').hide();

    function loadHighscore(str, out) { var score = JSON.parse(str || '{}');
        out.score = parseInt(score.score, 10) || 0;
        out.bestCombo = parseInt(score.bestCombo, 10) || 0;
        out.bestMultiplier = parseInt(score.bestMultiplier, 10) || 1;
        out.kills = parseInt(score.kills, 10) || 0;
        out.distance = parseInt(score.distance, 10) || 0; }

    function saveHighscore(keyName, highscore) {
        var highscoreString = JSON.stringify(highscore);
        try { localStorage.setItem(keyName, highscoreString); } catch (e) {}
        if (window.parent !== window)
            window.parent.postMessage({ 'method': 'updateHighScore', 'responseID': 'unused', 'score': highscoreString }, '*');
    }

    function showMenuScreen(menuScreen) {
        keyboard.pause();
        menu.addClass('visible').children().hide();
        menuScreen.show();
        jQuery('@pause-game').hide();
        if (game.paused)
            createjs.Sound.setMute(true);
        setTimeout(function() { menuScreen.find('button:first')[0].focus(); }, 250);
    }

    function hideMenuScreen() { keyboard.resume();
        menu.removeClass('visible').children().hide();
        menu.find('button').blur();
        jQuery('@pause-game').show();
        createjs.Sound.setMute(!audio); }

    function newGame() {
        if (music)
            musicTrack.play();
        gameLevels = levels.generateGame();
        currentLevel = -1;
        showMenuScreen(loadingMenu);
        game.load();
    }

    function onGameLoad() { loadingMenu.find('@play-game').show()[0].focus();
        loadingMenu.find('.progress').hide(); }

    function playGame() {
        game.newGame();
        nextLevel();
        jQuery(screen).show();
        createjs.Sound.setMute(!audio);
        if (game.paused)
            game.resume();
    }

    function pauseGame() { game.pause();
        showMenuScreen(pauseMenu); }

    function resumeGame() { hideMenuScreen();
        game.resume(); }

    function nextLevel() { if (currentLevel < gameLevels.length - 1) { currentLevel += 1;
            game.loadLevel(gameLevels[currentLevel]);
            hideMenuScreen();
            game.enableAutofire(); } }

    function updateStatsTables() { jQuery('@player-score-game').text(numbers.format(game.score + game.combo, 0, ' ', ' '));
        jQuery('@player-best-combo-game').text('+' + numbers.format(game.bestCombo, 0, ' ', ' '));
        jQuery('@player-best-multiplier-game').text('x' + numbers.format(game.bestMultiplier, 0, ' ', ' '));
        jQuery('@player-kill-count-game').text(numbers.format(game.kills, 0, ' ', ' '));
        jQuery('@player-distance-game').text(numbers.format(Math.ceil(game.distance / 2000), 0, ' ', ' ') + ' km');
        jQuery('@player-score-best').text(numbers.format(highscore.score, 0, ' ', ' '));
        jQuery('@player-best-combo-best').text('+' + numbers.format(highscore.bestCombo, 0, ' ', ' '));
        jQuery('@player-best-multiplier-best').text('x' + numbers.format(highscore.bestMultiplier, 0, ' ', ' '));
        jQuery('@player-kill-count-best').text(numbers.format(highscore.kills, 0, ' ', ' '));
        jQuery('@player-distance-best').text(numbers.format(Math.ceil(highscore.distance / 2000), 0, ' ', ' ') + ' km'); }

    function onLevelEnd() {
        game.disableAutofire();
        game.level.end();
        game.level = null;
        game.player.health = game.player.maxHealth;
        game.player.shield = game.player.maxShield;
        if (currentLevel === gameLevels.length - 1) { game.score += game.lifes * 50000;
            gameSummaryMenu.find('h1').text('Mission Complete'); } else
            levelSummaryMenu.find('@level').text(currentLevel + 1);
        updateStatsTables();
        updateHighscore();
        saveHighscore('skytte.highscore', highscore);
        showMenuScreen(currentLevel < gameLevels.length - 1 ? levelSummaryMenu : gameSummaryMenu);
    }

    function updateHighscore() { highscore.score = Math.max(highscore.score, game.score + game.combo);
        highscore.bestCombo = Math.max(highscore.bestCombo, game.bestCombo);
        highscore.bestMultiplier = Math.max(highscore.bestMultiplier, game.bestMultiplier);
        highscore.kills = Math.max(highscore.kills, game.kills);
        highscore.distance = Math.max(highscore.distance, game.distance); }

    function onPlayerDied() { if (game.lifes === 0 || !game.player) { gameSummaryMenu.find('h1').text('Destroyed on level ' + (currentLevel + 1));
            updateStatsTables();
            updateHighscore();
            saveHighscore('skytte.highscore', highscore);
            showMenuScreen(gameSummaryMenu); } }
    game.allResourcesLoaded.connect(onGameLoad);
    game.gamePaused.connect(function() { showMenuScreen(pauseMenu); });
    game.levelEnded.connect(onLevelEnd);
    game.playerDied.connect(onPlayerDied);
    if (DEBUG) { var debugElement = document.getElementById('debug');
        game.afterRender(function(game) { debugElement.textContent = format('%2i FPS (%ix%i)', game.fps, screen.width, screen.height); }); } else
        document.addEventListener('contextmenu', function(event) { event.preventDefault(); });
    game.resourceLoaded.connect(function() { var percent = Math.round(game.loaded / game.toLoad * 100) + '%';
        jQuery('@load-progress').text(percent);
        jQuery('@load-progress-bar').width(percent); });
    jQuery('@new-game').click(newGame);
    jQuery('@resume-game').click(resumeGame);
    jQuery('@play-game').click(playGame);
    jQuery('@next-level').click(nextLevel);
    jQuery('@restart-game').click(function() { showMenuScreen(restartMenu); });
    jQuery('@cancel-game-restart').click(function() { showMenuScreen(pauseMenu); });
    jQuery('@toggle-audio').click(function(event) { audio = !audio;
        jQuery('@toggle-audio').toggleClass('active', audio); try { localStorage.setItem('skytte.audio', JSON.stringify(audio)); } catch (e) {} });
    jQuery('@toggle-music').click(function(event) {
        music = !music;
        jQuery('@toggle-music').toggleClass('active', music);
        try { localStorage.setItem('skytte.music', JSON.stringify(music)); } catch (e) {}
        if (music)
            musicTrack.play();
        else
            musicTrack.pause();
    });
    var touchD = 15;
    var touchMoveId = null;
    var touchMoveStart = new Vector2();
    var touchTapId = null;
    var touchTapStart = new Vector2();

    function enableTouch() { screen.addEventListener('touchstart', onTouchStart, false);
        screen.addEventListener('touchmove', onTouchMove, false);
        screen.addEventListener('touchend', onTouchEnd, false);
        jQuery('@pause-game').click(function(event) { event.preventDefault();
            pauseGame(); }); }

    function onTouchStart(event) {
        event.preventDefault();
        var touch = event.changedTouches[0];
        if (touchMoveId === null) { touchMoveId = touch.identifier;
            touchMoveStart.set(touch.pageX, touch.pageY); }
        if (touchTapId === null) { touchTapId = touch.identifier;
            touchTapStart.set(touch.pageX, touch.pageY); }
    }

    function onTouchMove(event) {
        event.preventDefault();
        if (touchMoveId !== null) {
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                if (touch.identifier === touchMoveId) {
                    var touchX = touch.pageX - touchMoveStart.x;
                    var touchY = touch.pageY - touchMoveStart.y;
                    if (game.player)
                        game.player.move(numbers.clamp(touchX / touchD, -1, 1), numbers.clamp(touchY / touchD, -1, 1));
                    touchMoveStart.set(touch.pageX, touch.pageY);
                    break;
                }
            }
        }
        if (touchTapId !== null)
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                if (touch.identifier === touchTapId)
                    if (Math.abs(touch.pageX - touchTapStart.x) > 4 || Math.abs(touch.pageY - touchTapStart.y) > 4)
                        touchTapId = null;
            }
    }

    function onTouchEnd(event) {
        event.preventDefault();
        if (touchMoveId !== null)
            for (var i = 0; i < event.changedTouches.length; i++)
                if (event.changedTouches[i].identifier === touchMoveId) { touchMoveId = null; break; }
        if (touchTapId !== null) { game.nextWeapon();
            touchTapId = null; }
    }
    enableTouch();
    return game;
});