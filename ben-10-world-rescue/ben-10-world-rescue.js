! function(t) { if ("object" == typeof exports) module.exports = t();
    else { var e; "undefined" != typeof window ? e = window : "undefined" != typeof global ? e = global : "undefined" != typeof self && (e = self), e.p2 = t() } }(function() { return function t(e, i, o) {
        function n(r, a) { if (!i[r]) { if (!e[r]) { var h = "function" == typeof require && require; if (!a && h) return h(r, !0); if (s) return s(r, !0); throw new Error("Cannot find module '" + r + "'") } var l = i[r] = { exports: {} };
                e[r][0].call(l.exports, function(t) { var i = e[r][1][t]; return n(i || t) }, l, l.exports, t, e, i, o) } return i[r].exports } for (var s = "function" == typeof require && require, r = 0; r < o.length; r++) n(o[r]); return n }({ 1: [function(t, e, i) {
            function o() {} var n = t("./Scalar");
            e.exports = o, o.lineInt = function(t, e, i) { i = i || 0; var o, s, r, a, h, l, c, d = [0, 0]; return o = t[1][1] - t[0][1], s = t[0][0] - t[1][0], r = o * t[0][0] + s * t[0][1], a = e[1][1] - e[0][1], h = e[0][0] - e[1][0], l = a * e[0][0] + h * e[0][1], c = o * h - a * s, n.eq(c, 0, i) || (d[0] = (h * r - s * l) / c, d[1] = (o * l - a * r) / c), d }, o.segmentsIntersect = function(t, e, i, o) { var n = e[0] - t[0],
                    s = e[1] - t[1],
                    r = o[0] - i[0],
                    a = o[1] - i[1]; if (r * s - a * n == 0) return !1; var h = (n * (i[1] - t[1]) + s * (t[0] - i[0])) / (r * s - a * n),
                    l = (r * (t[1] - i[1]) + a * (i[0] - t[0])) / (a * n - r * s); return h >= 0 && h <= 1 && l >= 0 && l <= 1 } }, { "./Scalar": 4 }], 2: [function(t, e, i) {
            function o() {} e.exports = o, o.area = function(t, e, i) { return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]) }, o.left = function(t, e, i) { return o.area(t, e, i) > 0 }, o.leftOn = function(t, e, i) { return o.area(t, e, i) >= 0 }, o.right = function(t, e, i) { return o.area(t, e, i) < 0 }, o.rightOn = function(t, e, i) { return o.area(t, e, i) <= 0 }; var n = [],
                s = [];
            o.collinear = function(t, e, i, r) { if (r) { var a = n,
                        h = s;
                    a[0] = e[0] - t[0], a[1] = e[1] - t[1], h[0] = i[0] - e[0], h[1] = i[1] - e[1]; var l = a[0] * h[0] + a[1] * h[1],
                        c = Math.sqrt(a[0] * a[0] + a[1] * a[1]),
                        d = Math.sqrt(h[0] * h[0] + h[1] * h[1]); return Math.acos(l / (c * d)) < r } return 0 == o.area(t, e, i) }, o.sqdist = function(t, e) { var i = e[0] - t[0],
                    o = e[1] - t[1]; return i * i + o * o } }, {}], 3: [function(t, e, i) {
            function o() { this.vertices = [] }

            function n(t, e, i, o, n) { n = n || 0; var s = e[1] - t[1],
                    r = t[0] - e[0],
                    h = s * t[0] + r * t[1],
                    l = o[1] - i[1],
                    c = i[0] - o[0],
                    d = l * i[0] + c * i[1],
                    u = s * c - l * r; return a.eq(u, 0, n) ? [0, 0] : [(c * h - r * d) / u, (s * d - l * h) / u] } var s = t("./Line"),
                r = t("./Point"),
                a = t("./Scalar");
            e.exports = o, o.prototype.at = function(t) { var e = this.vertices,
                    i = e.length; return e[t < 0 ? t % i + i : t % i] }, o.prototype.first = function() { return this.vertices[0] }, o.prototype.last = function() { return this.vertices[this.vertices.length - 1] }, o.prototype.clear = function() { this.vertices.length = 0 }, o.prototype.append = function(t, e, i) { if (void 0 === e) throw new Error("From is not given!"); if (void 0 === i) throw new Error("To is not given!"); if (i - 1 < e) throw new Error("lol1"); if (i > t.vertices.length) throw new Error("lol2"); if (e < 0) throw new Error("lol3"); for (var o = e; o < i; o++) this.vertices.push(t.vertices[o]) }, o.prototype.makeCCW = function() { for (var t = 0, e = this.vertices, i = 1; i < this.vertices.length; ++i)(e[i][1] < e[t][1] || e[i][1] == e[t][1] && e[i][0] > e[t][0]) && (t = i);
                r.left(this.at(t - 1), this.at(t), this.at(t + 1)) || this.reverse() }, o.prototype.reverse = function() { for (var t = [], e = 0, i = this.vertices.length; e !== i; e++) t.push(this.vertices.pop());
                this.vertices = t }, o.prototype.isReflex = function(t) { return r.right(this.at(t - 1), this.at(t), this.at(t + 1)) }; var h = [],
                l = [];
            o.prototype.canSee = function(t, e) { var i, o, n = h,
                    a = l; if (r.leftOn(this.at(t + 1), this.at(t), this.at(e)) && r.rightOn(this.at(t - 1), this.at(t), this.at(e))) return !1;
                o = r.sqdist(this.at(t), this.at(e)); for (var c = 0; c !== this.vertices.length; ++c)
                    if ((c + 1) % this.vertices.length !== t && c !== t && r.leftOn(this.at(t), this.at(e), this.at(c + 1)) && r.rightOn(this.at(t), this.at(e), this.at(c)) && (n[0] = this.at(t), n[1] = this.at(e), a[0] = this.at(c), a[1] = this.at(c + 1), i = s.lineInt(n, a), r.sqdist(this.at(t), i) < o)) return !1; return !0 }, o.prototype.copy = function(t, e, i) { var n = i || new o; if (n.clear(), t < e)
                    for (s = t; s <= e; s++) n.vertices.push(this.vertices[s]);
                else { for (s = 0; s <= e; s++) n.vertices.push(this.vertices[s]); for (var s = t; s < this.vertices.length; s++) n.vertices.push(this.vertices[s]) } return n }, o.prototype.getCutEdges = function() { for (var t = [], e = [], i = [], n = new o, s = Number.MAX_VALUE, r = 0; r < this.vertices.length; ++r)
                    if (this.isReflex(r))
                        for (var a = 0; a < this.vertices.length; ++a)
                            if (this.canSee(r, a)) { e = this.copy(r, a, n).getCutEdges(), i = this.copy(a, r, n).getCutEdges(); for (var h = 0; h < i.length; h++) e.push(i[h]);
                                e.length < s && (t = e, s = e.length, t.push([this.at(r), this.at(a)])) } return t }, o.prototype.decomp = function() { var t = this.getCutEdges(); return t.length > 0 ? this.slice(t) : [this] }, o.prototype.slice = function(t) { if (0 == t.length) return [this]; if (t instanceof Array && t.length && t[0] instanceof Array && 2 == t[0].length && t[0][0] instanceof Array) { for (var e = [this], i = 0; i < t.length; i++)
                        for (var o = t[i], n = 0; n < e.length; n++) { var s = e[n].slice(o); if (s) { e.splice(n, 1), e.push(s[0], s[1]); break } }
                    return e } var o = t,
                    i = this.vertices.indexOf(o[0]),
                    n = this.vertices.indexOf(o[1]); return -1 != i && -1 != n && [this.copy(i, n), this.copy(n, i)] }, o.prototype.isSimple = function() { for (var t = this.vertices, e = 0; e < t.length - 1; e++)
                    for (var i = 0; i < e - 1; i++)
                        if (s.segmentsIntersect(t[e], t[e + 1], t[i], t[i + 1])) return !1; for (e = 1; e < t.length - 2; e++)
                    if (s.segmentsIntersect(t[0], t[t.length - 1], t[e], t[e + 1])) return !1; return !0 }, o.prototype.quickDecomp = function(t, e, i, s, a, h) { a = a || 100, h = h || 0, s = s || 25, t = void 0 !== t ? t : [], e = e || [], i = i || []; var l = [0, 0],
                    c = [0, 0],
                    d = [0, 0],
                    u = 0,
                    p = 0,
                    m = 0,
                    f = 0,
                    y = 0,
                    b = 0,
                    g = 0,
                    _ = new o,
                    v = new o,
                    x = this,
                    S = this.vertices; if (S.length < 3) return t; if (++h > a) return t; for (var C = 0; C < this.vertices.length; ++C)
                    if (x.isReflex(C)) { e.push(x.vertices[C]), u = p = Number.MAX_VALUE; for (w = 0; w < this.vertices.length; ++w) r.left(x.at(C - 1), x.at(C), x.at(w)) && r.rightOn(x.at(C - 1), x.at(C), x.at(w - 1)) && (d = n(x.at(C - 1), x.at(C), x.at(w), x.at(w - 1)), r.right(x.at(C + 1), x.at(C), d) && (m = r.sqdist(x.vertices[C], d)) < p && (p = m, c = d, b = w)), r.left(x.at(C + 1), x.at(C), x.at(w + 1)) && r.rightOn(x.at(C + 1), x.at(C), x.at(w)) && (d = n(x.at(C + 1), x.at(C), x.at(w), x.at(w + 1)), r.left(x.at(C - 1), x.at(C), d) && (m = r.sqdist(x.vertices[C], d)) < u && (u = m, l = d, y = w)); if (b == (y + 1) % this.vertices.length) d[0] = (c[0] + l[0]) / 2, d[1] = (c[1] + l[1]) / 2, i.push(d), C < y ? (_.append(x, C, y + 1), _.vertices.push(d), v.vertices.push(d), 0 != b && v.append(x, b, x.vertices.length), v.append(x, 0, C + 1)) : (0 != C && _.append(x, C, x.vertices.length), _.append(x, 0, y + 1), _.vertices.push(d), v.vertices.push(d), v.append(x, b, C + 1));
                        else { if (b > y && (y += this.vertices.length), f = Number.MAX_VALUE, y < b) return t; for (var w = b; w <= y; ++w) r.leftOn(x.at(C - 1), x.at(C), x.at(w)) && r.rightOn(x.at(C + 1), x.at(C), x.at(w)) && (m = r.sqdist(x.at(C), x.at(w))) < f && (f = m, g = w % this.vertices.length);
                            C < g ? (_.append(x, C, g + 1), 0 != g && v.append(x, g, S.length), v.append(x, 0, C + 1)) : (0 != C && _.append(x, C, S.length), _.append(x, 0, g + 1), v.append(x, g, C + 1)) } return _.vertices.length < v.vertices.length ? (_.quickDecomp(t, e, i, s, a, h), v.quickDecomp(t, e, i, s, a, h)) : (v.quickDecomp(t, e, i, s, a, h), _.quickDecomp(t, e, i, s, a, h)), t } return t.push(this), t }, o.prototype.removeCollinearPoints = function(t) { for (var e = 0, i = this.vertices.length - 1; this.vertices.length > 3 && i >= 0; --i) r.collinear(this.at(i - 1), this.at(i), this.at(i + 1), t) && (this.vertices.splice(i % this.vertices.length, 1), i--, e++); return e } }, { "./Line": 1, "./Point": 2, "./Scalar": 4 }], 4: [function(t, e, i) {
            function o() {} e.exports = o, o.eq = function(t, e, i) { return i = i || 0, Math.abs(t - e) < i } }, {}], 5: [function(t, e, i) { e.exports = { Polygon: t("./Polygon"), Point: t("./Point") } }, { "./Point": 2, "./Polygon": 3 }], 6: [function(t, e, i) { e.exports = { name: "p2", version: "0.7.0", description: "A JavaScript 2D physics engine.", author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)", keywords: ["p2.js", "p2", "physics", "engine", "2d"], main: "./src/p2.js", engines: { node: "*" }, repository: { type: "git", url: "https://github.com/schteppe/p2.js.git" }, bugs: { url: "https://github.com/schteppe/p2.js/issues" }, licenses: [{ type: "MIT" }], devDependencies: { grunt: "^0.4.5", "grunt-contrib-jshint": "^0.11.2", "grunt-contrib-nodeunit": "^0.4.1", "grunt-contrib-uglify": "~0.4.0", "grunt-contrib-watch": "~0.5.0", "grunt-browserify": "~2.0.1", "grunt-contrib-concat": "^0.4.0" }, dependencies: { "poly-decomp": "0.1.0" } } }, {}], 7: [function(t, e, i) {
            function o(t) { this.lowerBound = n.create(), t && t.lowerBound && n.copy(this.lowerBound, t.lowerBound), this.upperBound = n.create(), t && t.upperBound && n.copy(this.upperBound, t.upperBound) } var n = t("../math/vec2");
            t("../utils/Utils");
            e.exports = o; var s = n.create();
            o.prototype.setFromPoints = function(t, e, i, o) { var r = this.lowerBound,
                    a = this.upperBound; "number" != typeof i && (i = 0), 0 !== i ? n.rotate(r, t[0], i) : n.copy(r, t[0]), n.copy(a, r); for (var h = Math.cos(i), l = Math.sin(i), c = 1; c < t.length; c++) { var d = t[c]; if (0 !== i) { var u = d[0],
                            p = d[1];
                        s[0] = h * u - l * p, s[1] = l * u + h * p, d = s } for (var m = 0; m < 2; m++) d[m] > a[m] && (a[m] = d[m]), d[m] < r[m] && (r[m] = d[m]) } e && (n.add(this.lowerBound, this.lowerBound, e), n.add(this.upperBound, this.upperBound, e)), o && (this.lowerBound[0] -= o, this.lowerBound[1] -= o, this.upperBound[0] += o, this.upperBound[1] += o) }, o.prototype.copy = function(t) { n.copy(this.lowerBound, t.lowerBound), n.copy(this.upperBound, t.upperBound) }, o.prototype.extend = function(t) { for (var e = 2; e--;) { var i = t.lowerBound[e];
                    this.lowerBound[e] > i && (this.lowerBound[e] = i); var o = t.upperBound[e];
                    this.upperBound[e] < o && (this.upperBound[e] = o) } }, o.prototype.overlaps = function(t) { var e = this.lowerBound,
                    i = this.upperBound,
                    o = t.lowerBound,
                    n = t.upperBound; return (o[0] <= i[0] && i[0] <= n[0] || e[0] <= n[0] && n[0] <= i[0]) && (o[1] <= i[1] && i[1] <= n[1] || e[1] <= n[1] && n[1] <= i[1]) }, o.prototype.containsPoint = function(t) { var e = this.lowerBound,
                    i = this.upperBound; return e[0] <= t[0] && t[0] <= i[0] && e[1] <= t[1] && t[1] <= i[1] }, o.prototype.overlapsRay = function(t) { var e = 1 / t.direction[0],
                    i = 1 / t.direction[1],
                    o = (this.lowerBound[0] - t.from[0]) * e,
                    n = (this.upperBound[0] - t.from[0]) * e,
                    s = (this.lowerBound[1] - t.from[1]) * i,
                    r = (this.upperBound[1] - t.from[1]) * i,
                    a = Math.max(Math.max(Math.min(o, n), Math.min(s, r))),
                    h = Math.min(Math.min(Math.max(o, n), Math.max(s, r))); return h < 0 ? -1 : a > h ? -1 : a } }, { "../math/vec2": 30, "../utils/Utils": 57 }], 8: [function(t, e, i) {
            function o(t) { this.type = t, this.result = [], this.world = null, this.boundingVolumeType = o.AABB } var n = t("../math/vec2"),
                s = t("../objects/Body");
            e.exports = o, o.AABB = 1, o.BOUNDING_CIRCLE = 2, o.prototype.setWorld = function(t) { this.world = t }, o.prototype.getCollisionPairs = function(t) {}; var r = n.create();
            o.boundingRadiusCheck = function(t, e) { n.sub(r, t.position, e.position); var i = n.squaredLength(r),
                    o = t.boundingRadius + e.boundingRadius; return i <= o * o }, o.aabbCheck = function(t, e) { return t.getAABB().overlaps(e.getAABB()) }, o.prototype.boundingVolumeCheck = function(t, e) { var i; switch (this.boundingVolumeType) {
                    case o.BOUNDING_CIRCLE:
                        i = o.boundingRadiusCheck(t, e); break;
                    case o.AABB:
                        i = o.aabbCheck(t, e); break;
                    default:
                        throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType) } return i }, o.canCollide = function(t, e) { var i = s.KINEMATIC,
                    o = s.STATIC; return (t.type !== o || e.type !== o) && (!(t.type === i && e.type === o || t.type === o && e.type === i) && ((t.type !== i || e.type !== i) && ((t.sleepState !== s.SLEEPING || e.sleepState !== s.SLEEPING) && !(t.sleepState === s.SLEEPING && e.type === o || e.sleepState === s.SLEEPING && t.type === o)))) }, o.NAIVE = 1, o.SAP = 2 }, { "../math/vec2": 30, "../objects/Body": 31 }], 9: [function(t, e, i) {
            function o() { n.call(this, n.NAIVE) } t("../shapes/Circle"), t("../shapes/Plane"), t("../shapes/Shape"), t("../shapes/Particle"); var n = t("../collision/Broadphase");
            t("../math/vec2");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.getCollisionPairs = function(t) { var e = t.bodies,
                    i = this.result;
                i.length = 0; for (var o = 0, s = e.length; o !== s; o++)
                    for (var r = e[o], a = 0; a < o; a++) { var h = e[a];
                        n.canCollide(r, h) && this.boundingVolumeCheck(r, h) && i.push(r, h) }
                return i }, o.prototype.aabbQuery = function(t, e, i) { i = i || []; for (var o = t.bodies, n = 0; n < o.length; n++) { var s = o[n];
                    s.aabbNeedsUpdate && s.updateAABB(), s.aabb.overlaps(e) && i.push(s) } return i } }, { "../collision/Broadphase": 8, "../math/vec2": 30, "../shapes/Circle": 39, "../shapes/Particle": 43, "../shapes/Plane": 44, "../shapes/Shape": 45 }], 10: [function(t, e, i) {
            function o() { this.contactEquations = [], this.frictionEquations = [], this.enableFriction = !0, this.enabledEquations = !0, this.slipForce = 10, this.frictionCoefficient = .3, this.surfaceVelocity = 0, this.contactEquationPool = new c({ size: 32 }), this.frictionEquationPool = new d({ size: 64 }), this.restitution = 0, this.stiffness = p.DEFAULT_STIFFNESS, this.relaxation = p.DEFAULT_RELAXATION, this.frictionStiffness = p.DEFAULT_STIFFNESS, this.frictionRelaxation = p.DEFAULT_RELAXATION, this.enableFrictionReduction = !0, this.collidingBodiesLastStep = new u, this.contactSkinSize = .01 }

            function n(t, e) { r.set(t.vertices[0], .5 * -e.length, -e.radius), r.set(t.vertices[1], .5 * e.length, -e.radius), r.set(t.vertices[2], .5 * e.length, e.radius), r.set(t.vertices[3], .5 * -e.length, e.radius) }

            function s(t, e, i, o) { for (var n = H, s = z, l = J, c = q, d = t, u = e.vertices, p = null, m = 0; m !== u.length + 1; m++) { var f = u[m % u.length],
                        y = u[(m + 1) % u.length];
                    r.rotate(n, f, o), r.rotate(s, y, o), h(n, n, i), h(s, s, i), a(l, n, d), a(c, s, d); var b = r.crossLength(l, c); if (null === p && (p = b), b * p <= 0) return !1;
                    p = b } return !0 } var r = t("../math/vec2"),
                a = r.sub,
                h = r.add,
                l = r.dot,
                c = (t("../utils/Utils"), t("../utils/ContactEquationPool")),
                d = t("../utils/FrictionEquationPool"),
                u = t("../utils/TupleDictionary"),
                p = t("../equations/Equation"),
                m = (t("../equations/ContactEquation"), t("../equations/FrictionEquation"), t("../shapes/Circle")),
                f = t("../shapes/Convex"),
                y = t("../shapes/Shape"),
                b = (t("../objects/Body"), t("../shapes/Box"));
            e.exports = o; var g = r.fromValues(0, 1),
                _ = r.fromValues(0, 0),
                v = r.fromValues(0, 0),
                x = r.fromValues(0, 0),
                S = r.fromValues(0, 0),
                C = r.fromValues(0, 0),
                w = r.fromValues(0, 0),
                A = r.fromValues(0, 0),
                T = r.fromValues(0, 0),
                P = r.fromValues(0, 0),
                k = r.fromValues(0, 0),
                M = r.fromValues(0, 0),
                E = r.fromValues(0, 0),
                B = r.fromValues(0, 0),
                I = r.fromValues(0, 0),
                D = r.fromValues(0, 0),
                L = r.fromValues(0, 0),
                O = r.fromValues(0, 0),
                R = r.fromValues(0, 0),
                F = [],
                V = r.create(),
                G = r.create();
            o.prototype.bodiesOverlap = function(t, e) { for (var i = V, o = G, n = 0, s = t.shapes.length; n !== s; n++) { var r = t.shapes[n];
                    t.toWorldFrame(i, r.position); for (var a = 0, h = e.shapes.length; a !== h; a++) { var l = e.shapes[a]; if (e.toWorldFrame(o, l.position), this[r.type | l.type](t, r, i, r.angle + t.angle, e, l, o, l.angle + e.angle, !0)) return !0 } } return !1 }, o.prototype.collidedLastStep = function(t, e) { var i = 0 | t.id,
                    o = 0 | e.id; return !!this.collidingBodiesLastStep.get(i, o) }, o.prototype.reset = function() { this.collidingBodiesLastStep.reset(); for (var t = this.contactEquations, e = t.length; e--;) { var i = t[e],
                        o = i.bodyA.id,
                        n = i.bodyB.id;
                    this.collidingBodiesLastStep.set(o, n, !0) } for (var s = this.contactEquations, r = this.frictionEquations, a = 0; a < s.length; a++) this.contactEquationPool.release(s[a]); for (a = 0; a < r.length; a++) this.frictionEquationPool.release(r[a]);
                this.contactEquations.length = this.frictionEquations.length = 0 }, o.prototype.createContactEquation = function(t, e, i, o) { var n = this.contactEquationPool.get(); return n.bodyA = t, n.bodyB = e, n.shapeA = i, n.shapeB = o, n.restitution = this.restitution, n.firstImpact = !this.collidedLastStep(t, e), n.stiffness = this.stiffness, n.relaxation = this.relaxation, n.needsUpdate = !0, n.enabled = this.enabledEquations, n.offset = this.contactSkinSize, n }, o.prototype.createFrictionEquation = function(t, e, i, o) { var n = this.frictionEquationPool.get(); return n.bodyA = t, n.bodyB = e, n.shapeA = i, n.shapeB = o, n.setSlipForce(this.slipForce), n.frictionCoefficient = this.frictionCoefficient, n.relativeVelocity = this.surfaceVelocity, n.enabled = this.enabledEquations, n.needsUpdate = !0, n.stiffness = this.frictionStiffness, n.relaxation = this.frictionRelaxation, n.contactEquations.length = 0, n }, o.prototype.createFrictionFromContact = function(t) { var e = this.createFrictionEquation(t.bodyA, t.bodyB, t.shapeA, t.shapeB); return r.copy(e.contactPointA, t.contactPointA), r.copy(e.contactPointB, t.contactPointB), r.rotate90cw(e.t, t.normalA), e.contactEquations.push(t), e }, o.prototype.createFrictionFromAverage = function(t) { var e = this.contactEquations[this.contactEquations.length - 1],
                    i = this.createFrictionEquation(e.bodyA, e.bodyB, e.shapeA, e.shapeB),
                    o = e.bodyA;
                e.bodyB;
                r.set(i.contactPointA, 0, 0), r.set(i.contactPointB, 0, 0), r.set(i.t, 0, 0); for (var n = 0; n !== t; n++)(e = this.contactEquations[this.contactEquations.length - 1 - n]).bodyA === o ? (r.add(i.t, i.t, e.normalA), r.add(i.contactPointA, i.contactPointA, e.contactPointA), r.add(i.contactPointB, i.contactPointB, e.contactPointB)) : (r.sub(i.t, i.t, e.normalA), r.add(i.contactPointA, i.contactPointA, e.contactPointB), r.add(i.contactPointB, i.contactPointB, e.contactPointA)), i.contactEquations.push(e); var s = 1 / t; return r.scale(i.contactPointA, i.contactPointA, s), r.scale(i.contactPointB, i.contactPointB, s), r.normalize(i.t, i.t), r.rotate90cw(i.t, i.t), i }, o.prototype[y.LINE | y.CONVEX] = o.prototype.convexLine = function(t, e, i, o, n, s, r, a, h) { return !h && 0 }, o.prototype[y.LINE | y.BOX] = o.prototype.lineBox = function(t, e, i, o, n, s, r, a, h) { return !h && 0 }; var U = new b({ width: 1, height: 1 }),
                N = r.create();
            o.prototype[y.CAPSULE | y.CONVEX] = o.prototype[y.CAPSULE | y.BOX] = o.prototype.convexCapsule = function(t, e, i, o, s, a, h, l, c) { var d = N;
                r.set(d, a.length / 2, 0), r.rotate(d, d, l), r.add(d, d, h); var u = this.circleConvex(s, a, d, l, t, e, i, o, c, a.radius);
                r.set(d, -a.length / 2, 0), r.rotate(d, d, l), r.add(d, d, h); var p = this.circleConvex(s, a, d, l, t, e, i, o, c, a.radius); if (c && (u || p)) return !0; var m = U; return n(m, a), this.convexConvex(t, e, i, o, s, m, h, l, c) + u + p }, o.prototype[y.CAPSULE | y.LINE] = o.prototype.lineCapsule = function(t, e, i, o, n, s, r, a, h) { return !h && 0 }; var j = r.create(),
                W = r.create(),
                X = new b({ width: 1, height: 1 });
            o.prototype[y.CAPSULE | y.CAPSULE] = o.prototype.capsuleCapsule = function(t, e, i, o, s, a, h, l, c) { for (var d = j, u = W, p = 0, m = 0; m < 2; m++) { r.set(d, (0 === m ? -1 : 1) * e.length / 2, 0), r.rotate(d, d, o), r.add(d, d, i); for (var f = 0; f < 2; f++) { r.set(u, (0 === f ? -1 : 1) * a.length / 2, 0), r.rotate(u, u, l), r.add(u, u, h), this.enableFrictionReduction && (_ = this.enableFriction, this.enableFriction = !1); var y = this.circleCircle(t, e, d, o, s, a, u, l, c, e.radius, a.radius); if (this.enableFrictionReduction && (this.enableFriction = _), c && y) return !0;
                        p += y } } this.enableFrictionReduction && (_ = this.enableFriction, this.enableFriction = !1); var b = X;
                n(b, e); var g = this.convexCapsule(t, b, i, o, s, a, h, l, c); if (this.enableFrictionReduction && (this.enableFriction = _), c && g) return !0; if (p += g, this.enableFrictionReduction) { var _ = this.enableFriction;
                    this.enableFriction = !1 } n(b, a); var v = this.convexCapsule(s, b, h, l, t, e, i, o, c); return this.enableFrictionReduction && (this.enableFriction = _), !(!c || !v) || (p += v, this.enableFrictionReduction && p && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(p)), p) }, o.prototype[y.LINE | y.LINE] = o.prototype.lineLine = function(t, e, i, o, n, s, r, a, h) { return !h && 0 }, o.prototype[y.PLANE | y.LINE] = o.prototype.planeLine = function(t, e, i, o, n, s, c, d, u) { var p = _,
                    m = v,
                    f = x,
                    y = S,
                    b = C,
                    k = w,
                    M = A,
                    E = T,
                    B = P,
                    I = F,
                    D = 0;
                r.set(p, -s.length / 2, 0), r.set(m, s.length / 2, 0), r.rotate(f, p, d), r.rotate(y, m, d), h(f, f, c), h(y, y, c), r.copy(p, f), r.copy(m, y), a(b, m, p), r.normalize(k, b), r.rotate90cw(B, k), r.rotate(E, g, o), I[0] = p, I[1] = m; for (var L = 0; L < I.length; L++) { var O = I[L];
                    a(M, O, i); var R = l(M, E); if (R < 0) { if (u) return !0; var V = this.createContactEquation(t, n, e, s);
                        D++, r.copy(V.normalA, E), r.normalize(V.normalA, V.normalA), r.scale(M, E, R), a(V.contactPointA, O, M), a(V.contactPointA, V.contactPointA, t.position), a(V.contactPointB, O, c), h(V.contactPointB, V.contactPointB, c), a(V.contactPointB, V.contactPointB, n.position), this.contactEquations.push(V), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(V)) } } return !u && (this.enableFrictionReduction || D && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(D)), D) }, o.prototype[y.PARTICLE | y.CAPSULE] = o.prototype.particleCapsule = function(t, e, i, o, n, s, r, a, h) { return this.circleLine(t, e, i, o, n, s, r, a, h, s.radius, 0) }, o.prototype[y.CIRCLE | y.LINE] = o.prototype.circleLine = function(t, e, i, o, n, s, c, d, u, p, m) { var p = p || 0,
                    m = void 0 !== m ? m : e.radius,
                    f = _,
                    y = v,
                    b = x,
                    g = S,
                    D = C,
                    L = w,
                    O = A,
                    R = T,
                    V = P,
                    G = k,
                    U = M,
                    N = E,
                    j = B,
                    W = I,
                    X = F;
                r.set(R, -s.length / 2, 0), r.set(V, s.length / 2, 0), r.rotate(G, R, d), r.rotate(U, V, d), h(G, G, c), h(U, U, c), r.copy(R, G), r.copy(V, U), a(L, V, R), r.normalize(O, L), r.rotate90cw(D, O), a(N, i, R); var H = l(N, D);
                a(g, R, c), a(j, i, c); var z = m + p; if (Math.abs(H) < z) { r.scale(f, D, H), a(b, i, f), r.scale(y, D, l(D, j)), r.normalize(y, y), r.scale(y, y, p), h(b, b, y); var J = l(O, b),
                        q = l(O, R),
                        Y = l(O, V); if (J > q && J < Y) { if (u) return !0;
                        Q = this.createContactEquation(t, n, e, s); return r.scale(Q.normalA, f, -1), r.normalize(Q.normalA, Q.normalA), r.scale(Q.contactPointA, Q.normalA, m), h(Q.contactPointA, Q.contactPointA, i), a(Q.contactPointA, Q.contactPointA, t.position), a(Q.contactPointB, b, c), h(Q.contactPointB, Q.contactPointB, c), a(Q.contactPointB, Q.contactPointB, n.position), this.contactEquations.push(Q), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Q)), 1 } } X[0] = R, X[1] = V; for (var K = 0; K < X.length; K++) { var Z = X[K]; if (a(N, Z, i), r.squaredLength(N) < Math.pow(z, 2)) { if (u) return !0; var Q = this.createContactEquation(t, n, e, s); return r.copy(Q.normalA, N), r.normalize(Q.normalA, Q.normalA), r.scale(Q.contactPointA, Q.normalA, m), h(Q.contactPointA, Q.contactPointA, i), a(Q.contactPointA, Q.contactPointA, t.position), a(Q.contactPointB, Z, c), r.scale(W, Q.normalA, -p), h(Q.contactPointB, Q.contactPointB, W), h(Q.contactPointB, Q.contactPointB, c), a(Q.contactPointB, Q.contactPointB, n.position), this.contactEquations.push(Q), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Q)), 1 } } return 0 }, o.prototype[y.CIRCLE | y.CAPSULE] = o.prototype.circleCapsule = function(t, e, i, o, n, s, r, a, h) { return this.circleLine(t, e, i, o, n, s, r, a, h, s.radius) }, o.prototype[y.CIRCLE | y.CONVEX] = o.prototype[y.CIRCLE | y.BOX] = o.prototype.circleConvex = function(t, e, i, o, n, l, c, d, u, p) { for (var p = "number" == typeof p ? p : e.radius, m = _, f = v, y = x, b = S, g = C, w = k, A = M, T = B, P = I, E = D, O = L, R = !1, F = Number.MAX_VALUE, V = l.vertices, G = 0; G !== V.length + 1; G++) { var U = V[G % V.length],
                        N = V[(G + 1) % V.length]; if (r.rotate(m, U, d), r.rotate(f, N, d), h(m, m, c), h(f, f, c), a(y, f, m), r.normalize(b, y), r.rotate90cw(g, b), r.scale(P, g, -e.radius), h(P, P, i), s(P, l, c, d)) { r.sub(E, m, P); var j = Math.abs(r.dot(E, g));
                        j < F && (r.copy(O, P), F = j, r.scale(T, g, j), r.add(T, T, P), R = !0) } } if (R) { if (u) return !0;
                    X = this.createContactEquation(t, n, e, l); return r.sub(X.normalA, O, i), r.normalize(X.normalA, X.normalA), r.scale(X.contactPointA, X.normalA, p), h(X.contactPointA, X.contactPointA, i), a(X.contactPointA, X.contactPointA, t.position), a(X.contactPointB, T, c), h(X.contactPointB, X.contactPointB, c), a(X.contactPointB, X.contactPointB, n.position), this.contactEquations.push(X), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(X)), 1 } if (p > 0)
                    for (G = 0; G < V.length; G++) { var W = V[G]; if (r.rotate(A, W, d), h(A, A, c), a(w, A, i), r.squaredLength(w) < Math.pow(p, 2)) { if (u) return !0; var X = this.createContactEquation(t, n, e, l); return r.copy(X.normalA, w), r.normalize(X.normalA, X.normalA), r.scale(X.contactPointA, X.normalA, p), h(X.contactPointA, X.contactPointA, i), a(X.contactPointA, X.contactPointA, t.position), a(X.contactPointB, A, c), h(X.contactPointB, X.contactPointB, c), a(X.contactPointB, X.contactPointB, n.position), this.contactEquations.push(X), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(X)), 1 } }
                return 0 }; var H = r.create(),
                z = r.create(),
                J = r.create(),
                q = r.create();
            o.prototype[y.PARTICLE | y.CONVEX] = o.prototype[y.PARTICLE | y.BOX] = o.prototype.particleConvex = function(t, e, i, o, n, c, d, u, p) { var m = _,
                    f = v,
                    y = x,
                    b = S,
                    g = C,
                    T = w,
                    P = A,
                    M = k,
                    E = B,
                    I = O,
                    D = R,
                    L = Number.MAX_VALUE,
                    F = !1,
                    V = c.vertices; if (!s(i, c, d, u)) return 0; if (p) return !0; for (var G = 0; G !== V.length + 1; G++) { var U = V[G % V.length],
                        N = V[(G + 1) % V.length];
                    r.rotate(m, U, u), r.rotate(f, N, u), h(m, m, d), h(f, f, d), a(y, f, m), r.normalize(b, y), r.rotate90cw(g, b), a(M, i, m);
                    l(M, g);
                    a(T, m, d), a(P, i, d), r.sub(I, m, i); var j = Math.abs(r.dot(I, g));
                    j < L && (L = j, r.scale(E, g, j), r.add(E, E, i), r.copy(D, g), F = !0) } if (F) { var W = this.createContactEquation(t, n, e, c); return r.scale(W.normalA, D, -1), r.normalize(W.normalA, W.normalA), r.set(W.contactPointA, 0, 0), h(W.contactPointA, W.contactPointA, i), a(W.contactPointA, W.contactPointA, t.position), a(W.contactPointB, E, d), h(W.contactPointB, W.contactPointB, d), a(W.contactPointB, W.contactPointB, n.position), this.contactEquations.push(W), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(W)), 1 } return 0 }, o.prototype[y.CIRCLE] = o.prototype.circleCircle = function(t, e, i, o, n, s, l, c, d, u, p) { var m = _,
                    u = u || e.radius,
                    p = p || s.radius;
                a(m, i, l); var f = u + p; if (r.squaredLength(m) > Math.pow(f, 2)) return 0; if (d) return !0; var y = this.createContactEquation(t, n, e, s); return a(y.normalA, l, i), r.normalize(y.normalA, y.normalA), r.scale(y.contactPointA, y.normalA, u), r.scale(y.contactPointB, y.normalA, -p), h(y.contactPointA, y.contactPointA, i), a(y.contactPointA, y.contactPointA, t.position), h(y.contactPointB, y.contactPointB, l), a(y.contactPointB, y.contactPointB, n.position), this.contactEquations.push(y), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(y)), 1 }, o.prototype[y.PLANE | y.CONVEX] = o.prototype[y.PLANE | y.BOX] = o.prototype.planeConvex = function(t, e, i, o, n, s, c, d, u) { var p = _,
                    m = v,
                    f = x,
                    y = 0;
                r.rotate(m, g, o); for (var b = 0; b !== s.vertices.length; b++) { var S = s.vertices[b]; if (r.rotate(p, S, d), h(p, p, c), a(f, p, i), l(f, m) <= 0) { if (u) return !0;
                        y++; var C = this.createContactEquation(t, n, e, s);
                        a(f, p, i), r.copy(C.normalA, m); var w = l(f, C.normalA);
                        r.scale(f, C.normalA, w), a(C.contactPointB, p, n.position), a(C.contactPointA, p, f), a(C.contactPointA, C.contactPointA, t.position), this.contactEquations.push(C), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(C)) } } return this.enableFrictionReduction && this.enableFriction && y && this.frictionEquations.push(this.createFrictionFromAverage(y)), y }, o.prototype[y.PARTICLE | y.PLANE] = o.prototype.particlePlane = function(t, e, i, o, n, s, h, c, d) { var u = _,
                    p = v;
                c = c || 0, a(u, i, h), r.rotate(p, g, c); var m = l(u, p); if (m > 0) return 0; if (d) return !0; var f = this.createContactEquation(n, t, s, e); return r.copy(f.normalA, p), r.scale(u, f.normalA, m), a(f.contactPointA, i, u), a(f.contactPointA, f.contactPointA, n.position), a(f.contactPointB, i, t.position), this.contactEquations.push(f), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(f)), 1 }, o.prototype[y.CIRCLE | y.PARTICLE] = o.prototype.circleParticle = function(t, e, i, o, n, s, l, c, d) { var u = _; if (a(u, l, i), r.squaredLength(u) > Math.pow(e.radius, 2)) return 0; if (d) return !0; var p = this.createContactEquation(t, n, e, s); return r.copy(p.normalA, u), r.normalize(p.normalA, p.normalA), r.scale(p.contactPointA, p.normalA, e.radius), h(p.contactPointA, p.contactPointA, i), a(p.contactPointA, p.contactPointA, t.position), a(p.contactPointB, l, n.position), this.contactEquations.push(p), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(p)), 1 }; var Y = new m({ radius: 1 }),
                K = r.create(),
                Z = r.create();
            r.create();
            o.prototype[y.PLANE | y.CAPSULE] = o.prototype.planeCapsule = function(t, e, i, o, n, s, a, l, c) { var d = K,
                    u = Z,
                    p = Y;
                r.set(d, -s.length / 2, 0), r.rotate(d, d, l), h(d, d, a), r.set(u, s.length / 2, 0), r.rotate(u, u, l), h(u, u, a), p.radius = s.radius; var m;
                this.enableFrictionReduction && (m = this.enableFriction, this.enableFriction = !1); var f = this.circlePlane(n, p, d, 0, t, e, i, o, c),
                    y = this.circlePlane(n, p, u, 0, t, e, i, o, c); if (this.enableFrictionReduction && (this.enableFriction = m), c) return f || y; var b = f + y; return this.enableFrictionReduction && b && this.frictionEquations.push(this.createFrictionFromAverage(b)), b }, o.prototype[y.CIRCLE | y.PLANE] = o.prototype.circlePlane = function(t, e, i, o, n, s, c, d, u) { var p = t,
                    m = e,
                    f = i,
                    y = n,
                    b = c,
                    S = d;
                S = S || 0; var C = _,
                    w = v,
                    A = x;
                a(C, f, b), r.rotate(w, g, S); var T = l(w, C); if (T > m.radius) return 0; if (u) return !0; var P = this.createContactEquation(y, p, s, e); return r.copy(P.normalA, w), r.scale(P.contactPointB, P.normalA, -m.radius), h(P.contactPointB, P.contactPointB, f), a(P.contactPointB, P.contactPointB, p.position), r.scale(A, P.normalA, T), a(P.contactPointA, C, A), h(P.contactPointA, P.contactPointA, b), a(P.contactPointA, P.contactPointA, y.position), this.contactEquations.push(P), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(P)), 1 }, o.prototype[y.CONVEX] = o.prototype[y.CONVEX | y.BOX] = o.prototype[y.BOX] = o.prototype.convexConvex = function(t, e, i, n, s, c, d, u, p, m) { var f = _,
                    y = v,
                    b = x,
                    g = S,
                    w = C,
                    k = A,
                    M = T,
                    E = P,
                    B = 0,
                    m = "number" == typeof m ? m : 0; if (!o.findSeparatingAxis(e, i, n, c, d, u, f)) return 0;
                a(M, d, i), l(f, M) > 0 && r.scale(f, f, -1); var I = o.getClosestEdge(e, n, f, !0),
                    D = o.getClosestEdge(c, u, f); if (-1 === I || -1 === D) return 0; for (var L = 0; L < 2; L++) { var O = I,
                        R = D,
                        F = e,
                        V = c,
                        G = i,
                        U = d,
                        N = n,
                        j = u,
                        W = t,
                        X = s; if (0 === L) { var H;
                        H = O, O = R, R = H, H = F, F = V, V = H, H = G, G = U, U = H, H = N, N = j, j = H, H = W, W = X, X = H } for (var z = R; z < R + 2; z++) { var J = V.vertices[(z + V.vertices.length) % V.vertices.length];
                        r.rotate(y, J, j), h(y, y, U); for (var q = 0, Y = O - 1; Y < O + 2; Y++) { var K = F.vertices[(Y + F.vertices.length) % F.vertices.length],
                                Z = F.vertices[(Y + 1 + F.vertices.length) % F.vertices.length];
                            r.rotate(b, K, N), r.rotate(g, Z, N), h(b, b, G), h(g, g, G), a(w, g, b), r.rotate90cw(E, w), r.normalize(E, E), a(M, y, b);
                            $ = l(E, M);
                            (Y === O && $ <= m || Y !== O && $ <= 0) && q++ } if (q >= 3) { if (p) return !0; var Q = this.createContactEquation(W, X, F, V);
                            B++; var K = F.vertices[O % F.vertices.length],
                                Z = F.vertices[(O + 1) % F.vertices.length];
                            r.rotate(b, K, N), r.rotate(g, Z, N), h(b, b, G), h(g, g, G), a(w, g, b), r.rotate90cw(Q.normalA, w), r.normalize(Q.normalA, Q.normalA), a(M, y, b); var $ = l(Q.normalA, M);
                            r.scale(k, Q.normalA, $), a(Q.contactPointA, y, G), a(Q.contactPointA, Q.contactPointA, k), h(Q.contactPointA, Q.contactPointA, G), a(Q.contactPointA, Q.contactPointA, W.position), a(Q.contactPointB, y, U), h(Q.contactPointB, Q.contactPointB, U), a(Q.contactPointB, Q.contactPointB, X.position), this.contactEquations.push(Q), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(Q)) } } } return this.enableFrictionReduction && this.enableFriction && B && this.frictionEquations.push(this.createFrictionFromAverage(B)), B }; var Q = r.fromValues(0, 0);
            o.projectConvexOntoAxis = function(t, e, i, o, n) { var s, a, h = null,
                    c = null,
                    d = Q;
                r.rotate(d, o, -i); for (var u = 0; u < t.vertices.length; u++) s = t.vertices[u], a = l(s, d), (null === h || a > h) && (h = a), (null === c || a < c) && (c = a); if (c > h) { var p = c;
                    c = h, h = p } var m = l(e, o);
                r.set(n, c + m, h + m) }; var $ = r.fromValues(0, 0),
                tt = r.fromValues(0, 0),
                et = r.fromValues(0, 0),
                it = r.fromValues(0, 0),
                ot = r.fromValues(0, 0),
                nt = r.fromValues(0, 0);
            o.findSeparatingAxis = function(t, e, i, n, s, h, l) { var c = null,
                    d = !1,
                    u = !1,
                    p = $,
                    m = tt,
                    f = et,
                    y = it,
                    g = ot,
                    _ = nt; if (t instanceof b && n instanceof b)
                    for (w = 0; 2 !== w; w++) { var v = t,
                            x = i;
                        1 === w && (v = n, x = h); for (A = 0; 2 !== A; A++) { 0 === A ? r.set(y, 0, 1) : 1 === A && r.set(y, 1, 0), 0 !== x && r.rotate(y, y, x), o.projectConvexOntoAxis(t, e, i, y, g), o.projectConvexOntoAxis(n, s, h, y, _); var S = g,
                                C = _;
                            g[0] > _[0] && (C = g, S = _, !0), d = (T = C[0] - S[1]) <= 0, (null === c || T > c) && (r.copy(l, y), c = T, u = d) } } else
                        for (var w = 0; 2 !== w; w++) { var v = t,
                                x = i;
                            1 === w && (v = n, x = h); for (var A = 0; A !== v.vertices.length; A++) { r.rotate(m, v.vertices[A], x), r.rotate(f, v.vertices[(A + 1) % v.vertices.length], x), a(p, f, m), r.rotate90cw(y, p), r.normalize(y, y), o.projectConvexOntoAxis(t, e, i, y, g), o.projectConvexOntoAxis(n, s, h, y, _); var S = g,
                                    C = _;
                                g[0] > _[0] && (C = g, S = _, !0); var T = C[0] - S[1];
                                d = T <= 0, (null === c || T > c) && (r.copy(l, y), c = T, u = d) } }
                return u }; var st = r.fromValues(0, 0),
                rt = r.fromValues(0, 0),
                at = r.fromValues(0, 0);
            o.getClosestEdge = function(t, e, i, o) { var n = st,
                    s = rt,
                    h = at;
                r.rotate(n, i, -e), o && r.scale(n, n, -1); for (var c = -1, d = t.vertices.length, u = -1, p = 0; p !== d; p++) { a(s, t.vertices[(p + 1) % d], t.vertices[p % d]), r.rotate90cw(h, s), r.normalize(h, h); var m = l(h, n);
                    (-1 === c || m > u) && (c = p % d, u = m) } return c }; var ht = r.create(),
                lt = r.create(),
                ct = r.create(),
                dt = r.create(),
                ut = r.create(),
                pt = r.create(),
                mt = r.create();
            o.prototype[y.CIRCLE | y.HEIGHTFIELD] = o.prototype.circleHeightfield = function(t, e, i, o, n, s, l, c, d, u) { var p = s.heights,
                    u = u || e.radius,
                    m = s.elementWidth,
                    f = lt,
                    y = ht,
                    b = ut,
                    g = mt,
                    _ = pt,
                    v = ct,
                    x = dt,
                    S = Math.floor((i[0] - u - l[0]) / m),
                    C = Math.ceil((i[0] + u - l[0]) / m);
                S < 0 && (S = 0), C >= p.length && (C = p.length - 1); for (var w = p[S], A = p[C], T = S; T < C; T++) p[T] < A && (A = p[T]), p[T] > w && (w = p[T]); if (i[1] - u > w) return !d && 0; for (var P = !1, T = S; T < C; T++) { r.set(v, T * m, p[T]), r.set(x, (T + 1) * m, p[T + 1]), r.add(v, v, l), r.add(x, x, l), r.sub(_, x, v), r.rotate(_, _, Math.PI / 2), r.normalize(_, _), r.scale(y, _, -u), r.add(y, y, i), r.sub(f, y, v); var k = r.dot(f, _); if (y[0] >= v[0] && y[0] < x[0] && k <= 0) { if (d) return !0;
                        P = !0, r.scale(f, _, -k), r.add(b, y, f), r.copy(g, _);
                        M = this.createContactEquation(n, t, s, e);
                        r.copy(M.normalA, g), r.scale(M.contactPointB, M.normalA, -u), h(M.contactPointB, M.contactPointB, i), a(M.contactPointB, M.contactPointB, t.position), r.copy(M.contactPointA, b), r.sub(M.contactPointA, M.contactPointA, n.position), this.contactEquations.push(M), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M)) } } if (P = !1, u > 0)
                    for (T = S; T <= C; T++)
                        if (r.set(v, T * m, p[T]), r.add(v, v, l), r.sub(f, i, v), r.squaredLength(f) < Math.pow(u, 2)) { if (d) return !0;
                            P = !0; var M = this.createContactEquation(n, t, s, e);
                            r.copy(M.normalA, f), r.normalize(M.normalA, M.normalA), r.scale(M.contactPointB, M.normalA, -u), h(M.contactPointB, M.contactPointB, i), a(M.contactPointB, M.contactPointB, t.position), a(M.contactPointA, v, l), h(M.contactPointA, M.contactPointA, l), a(M.contactPointA, M.contactPointA, n.position), this.contactEquations.push(M), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(M)) } return P ? 1 : 0 }; var ft = r.create(),
                yt = r.create(),
                bt = r.create(),
                gt = new f({ vertices: [r.create(), r.create(), r.create(), r.create()] });
            o.prototype[y.BOX | y.HEIGHTFIELD] = o.prototype[y.CONVEX | y.HEIGHTFIELD] = o.prototype.convexHeightfield = function(t, e, i, o, n, s, a, h, l) { var c = s.heights,
                    d = s.elementWidth,
                    u = ft,
                    p = yt,
                    m = bt,
                    f = gt,
                    y = Math.floor((t.aabb.lowerBound[0] - a[0]) / d),
                    b = Math.ceil((t.aabb.upperBound[0] - a[0]) / d);
                y < 0 && (y = 0), b >= c.length && (b = c.length - 1); for (var g = c[y], _ = c[b], v = y; v < b; v++) c[v] < _ && (_ = c[v]), c[v] > g && (g = c[v]); if (t.aabb.lowerBound[1] > g) return !l && 0; for (var x = 0, v = y; v < b; v++) { r.set(u, v * d, c[v]), r.set(p, (v + 1) * d, c[v + 1]), r.add(u, u, a), r.add(p, p, a);
                    r.set(m, .5 * (p[0] + u[0]), .5 * (p[1] + u[1] - 100)), r.sub(f.vertices[0], p, m), r.sub(f.vertices[1], u, m), r.copy(f.vertices[2], f.vertices[1]), r.copy(f.vertices[3], f.vertices[0]), f.vertices[2][1] -= 100, f.vertices[3][1] -= 100, x += this.convexConvex(t, e, i, o, n, f, m, 0, l) } return x } }, { "../equations/ContactEquation": 21, "../equations/Equation": 22, "../equations/FrictionEquation": 23, "../math/vec2": 30, "../objects/Body": 31, "../shapes/Box": 37, "../shapes/Circle": 39, "../shapes/Convex": 40, "../shapes/Shape": 45, "../utils/ContactEquationPool": 48, "../utils/FrictionEquationPool": 49, "../utils/TupleDictionary": 56, "../utils/Utils": 57 }], 11: [function(t, e, i) {
            function o(t) { t = t || {}, this.from = t.from ? s.fromValues(t.from[0], t.from[1]) : s.create(), this.to = t.to ? s.fromValues(t.to[0], t.to[1]) : s.create(), this.checkCollisionResponse = void 0 === t.checkCollisionResponse || t.checkCollisionResponse, this.skipBackfaces = !!t.skipBackfaces, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : -1, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : -1, this.mode = void 0 !== t.mode ? t.mode : o.ANY, this.callback = t.callback || function(t) {}, this.direction = s.create(), this.length = 1, this.update() }

            function n(t, e, i) { s.sub(a, i, t); var o = s.dot(a, e); return s.scale(h, e, o), s.add(h, h, t), s.squaredDistance(i, h) } e.exports = o; var s = t("../math/vec2");
            t("../collision/RaycastResult"), t("../shapes/Shape"), t("../collision/AABB");
            o.prototype.constructor = o, o.CLOSEST = 1, o.ANY = 2, o.ALL = 4, o.prototype.update = function() { var t = this.direction;
                s.sub(t, this.to, this.from), this.length = s.length(t), s.normalize(t, t) }, o.prototype.intersectBodies = function(t, e) { for (var i = 0, o = e.length; !t.shouldStop(this) && i < o; i++) { var n = e[i],
                        s = n.getAABB();
                    (s.overlapsRay(this) >= 0 || s.containsPoint(this.from)) && this.intersectBody(t, n) } }; var r = s.create();
            o.prototype.intersectBody = function(t, e) { var i = this.checkCollisionResponse; if (!i || e.collisionResponse)
                    for (var o = r, n = 0, a = e.shapes.length; n < a; n++) { var h = e.shapes[n]; if ((!i || h.collisionResponse) && (0 != (this.collisionGroup & h.collisionMask) && 0 != (h.collisionGroup & this.collisionMask))) { s.rotate(o, h.position, e.angle), s.add(o, o, e.position); var l = h.angle + e.angle; if (this.intersectShape(t, h, l, o, e), t.shouldStop(this)) break } } }, o.prototype.intersectShape = function(t, e, i, o, s) { n(this.from, this.direction, o) > e.boundingRadius * e.boundingRadius || (this._currentBody = s, this._currentShape = e, e.raycast(t, this, o, i), this._currentBody = this._currentShape = null) }, o.prototype.getAABB = function(t) { var e = this.to,
                    i = this.from;
                s.set(t.lowerBound, Math.min(e[0], i[0]), Math.min(e[1], i[1])), s.set(t.upperBound, Math.max(e[0], i[0]), Math.max(e[1], i[1])) };
            s.create();
            o.prototype.reportIntersection = function(t, e, i, n) { this.from, this.to; var r = this._currentShape,
                    a = this._currentBody; if (!(this.skipBackfaces && s.dot(i, this.direction) > 0)) switch (this.mode) {
                    case o.ALL:
                        t.set(i, r, a, e, n), this.callback(t); break;
                    case o.CLOSEST:
                        (e < t.fraction || !t.hasHit()) && t.set(i, r, a, e, n); break;
                    case o.ANY:
                        t.set(i, r, a, e, n) } }; var a = s.create(),
                h = s.create() }, { "../collision/AABB": 7, "../collision/RaycastResult": 12, "../math/vec2": 30, "../shapes/Shape": 45 }], 12: [function(t, e, i) {
            function o() { this.normal = n.create(), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1 } var n = t("../math/vec2"),
                s = t("../collision/Ray");
            e.exports = o, o.prototype.reset = function() { n.set(this.normal, 0, 0), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1 }, o.prototype.getHitDistance = function(t) { return n.distance(t.from, t.to) * this.fraction }, o.prototype.hasHit = function() { return -1 !== this.fraction }, o.prototype.getHitPoint = function(t, e) { n.lerp(t, e.from, e.to, this.fraction) }, o.prototype.stop = function() { this.isStopped = !0 }, o.prototype.shouldStop = function(t) { return this.isStopped || -1 !== this.fraction && t.mode === s.ANY }, o.prototype.set = function(t, e, i, o, s) { n.copy(this.normal, t), this.shape = e, this.body = i, this.fraction = o, this.faceIndex = s } }, { "../collision/Ray": 11, "../math/vec2": 30 }], 13: [function(t, e, i) {
            function o() { s.call(this, s.SAP), this.axisList = [], this.axisIndex = 0; var t = this;
                this._addBodyHandler = function(e) { t.axisList.push(e.body) }, this._removeBodyHandler = function(e) { var i = t.axisList.indexOf(e.body); - 1 !== i && t.axisList.splice(i, 1) } } var n = t("../utils/Utils"),
                s = t("../collision/Broadphase");
            e.exports = o, (o.prototype = new s).constructor = o, o.prototype.setWorld = function(t) { this.axisList.length = 0, n.appendArray(this.axisList, t.bodies), t.off("addBody", this._addBodyHandler).off("removeBody", this._removeBodyHandler), t.on("addBody", this._addBodyHandler).on("removeBody", this._removeBodyHandler), this.world = t }, o.sortAxisList = function(t, e) { e |= 0; for (var i = 1, o = t.length; i < o; i++) { for (var n = t[i], s = i - 1; s >= 0 && !(t[s].aabb.lowerBound[e] <= n.aabb.lowerBound[e]); s--) t[s + 1] = t[s];
                    t[s + 1] = n } return t }, o.prototype.sortList = function() { var t = this.axisList,
                    e = this.axisIndex;
                o.sortAxisList(t, e) }, o.prototype.getCollisionPairs = function(t) { var e = this.axisList,
                    i = this.result,
                    o = this.axisIndex;
                i.length = 0; for (var n = e.length; n--;) { var r = e[n];
                    r.aabbNeedsUpdate && r.updateAABB() } this.sortList(); for (var a = 0, h = 0 | e.length; a !== h; a++)
                    for (var l = e[a], c = a + 1; c < h; c++) { var d = e[c]; if (!(d.aabb.lowerBound[o] <= l.aabb.upperBound[o])) break;
                        s.canCollide(l, d) && this.boundingVolumeCheck(l, d) && i.push(l, d) }
                return i }, o.prototype.aabbQuery = function(t, e, i) { i = i || [], this.sortList(); var o = this.axisIndex,
                    n = "x";
                1 === o && (n = "y"), 2 === o && (n = "z"); for (var s = this.axisList, r = (e.lowerBound[n], e.upperBound[n], 0); r < s.length; r++) { var a = s[r];
                    a.aabbNeedsUpdate && a.updateAABB(), a.aabb.overlaps(e) && i.push(a) } return i } }, { "../collision/Broadphase": 8, "../utils/Utils": 57 }], 14: [function(t, e, i) {
            function o(t, e, i, o) { this.type = i, o = n.defaults(o, { collideConnected: !0, wakeUpBodies: !0 }), this.equations = [], this.bodyA = t, this.bodyB = e, this.collideConnected = o.collideConnected, o.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp()) } e.exports = o; var n = t("../utils/Utils");
            o.prototype.update = function() { throw new Error("method update() not implmemented in this Constraint subclass!") }, o.DISTANCE = 1, o.GEAR = 2, o.LOCK = 3, o.PRISMATIC = 4, o.REVOLUTE = 5, o.prototype.setStiffness = function(t) { for (var e = this.equations, i = 0; i !== e.length; i++) { var o = e[i];
                    o.stiffness = t, o.needsUpdate = !0 } }, o.prototype.setRelaxation = function(t) { for (var e = this.equations, i = 0; i !== e.length; i++) { var o = e[i];
                    o.relaxation = t, o.needsUpdate = !0 } } }, { "../utils/Utils": 57 }], 15: [function(t, e, i) {
            function o(t, e, i) { i = a.defaults(i, { localAnchorA: [0, 0], localAnchorB: [0, 0] }), n.call(this, t, e, n.DISTANCE, i), this.localAnchorA = r.fromValues(i.localAnchorA[0], i.localAnchorA[1]), this.localAnchorB = r.fromValues(i.localAnchorB[0], i.localAnchorB[1]); var o = this.localAnchorA,
                    h = this.localAnchorB; if (this.distance = 0, "number" == typeof i.distance) this.distance = i.distance;
                else { var l = r.create(),
                        c = r.create(),
                        d = r.create();
                    r.rotate(l, o, t.angle), r.rotate(c, h, e.angle), r.add(d, e.position, c), r.sub(d, d, l), r.sub(d, d, t.position), this.distance = r.length(d) } var u;
                u = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce; var p = new s(t, e, -u, u);
                this.equations = [p], this.maxForce = u; var d = r.create(),
                    m = r.create(),
                    f = r.create(),
                    y = this;
                p.computeGq = function() { var t = this.bodyA,
                        e = this.bodyB,
                        i = t.position,
                        n = e.position; return r.rotate(m, o, t.angle), r.rotate(f, h, e.angle), r.add(d, n, f), r.sub(d, d, m), r.sub(d, d, i), r.length(d) - y.distance }, this.setMaxForce(u), this.upperLimitEnabled = !1, this.upperLimit = 1, this.lowerLimitEnabled = !1, this.lowerLimit = 0, this.position = 0 } var n = t("./Constraint"),
                s = t("../equations/Equation"),
                r = t("../math/vec2"),
                a = t("../utils/Utils");
            e.exports = o, (o.prototype = new n).constructor = o; var h = r.create(),
                l = r.create(),
                c = r.create();
            o.prototype.update = function() { var t = this.equations[0],
                    e = this.bodyA,
                    i = this.bodyB,
                    o = (this.distance, e.position),
                    n = i.position,
                    s = this.equations[0],
                    a = t.G;
                r.rotate(l, this.localAnchorA, e.angle), r.rotate(c, this.localAnchorB, i.angle), r.add(h, n, c), r.sub(h, h, l), r.sub(h, h, o), this.position = r.length(h); var d = !1; if (this.upperLimitEnabled && this.position > this.upperLimit && (s.maxForce = 0, s.minForce = -this.maxForce, this.distance = this.upperLimit, d = !0), this.lowerLimitEnabled && this.position < this.lowerLimit && (s.maxForce = this.maxForce, s.minForce = 0, this.distance = this.lowerLimit, d = !0), !this.lowerLimitEnabled && !this.upperLimitEnabled || d) { s.enabled = !0, r.normalize(h, h); var u = r.crossLength(l, h),
                        p = r.crossLength(c, h);
                    a[0] = -h[0], a[1] = -h[1], a[2] = -u, a[3] = h[0], a[4] = h[1], a[5] = p } else s.enabled = !1 }, o.prototype.setMaxForce = function(t) { var e = this.equations[0];
                e.minForce = -t, e.maxForce = t }, o.prototype.getMaxForce = function() { return this.equations[0].maxForce } }, { "../equations/Equation": 22, "../math/vec2": 30, "../utils/Utils": 57, "./Constraint": 14 }], 16: [function(t, e, i) {
            function o(t, e, i) { i = i || {}, n.call(this, t, e, n.GEAR, i), this.ratio = void 0 !== i.ratio ? i.ratio : 1, this.angle = void 0 !== i.angle ? i.angle : e.angle - this.ratio * t.angle, i.angle = this.angle, i.ratio = this.ratio, this.equations = [new s(t, e, i)], void 0 !== i.maxTorque && this.setMaxTorque(i.maxTorque) } var n = t("./Constraint"),
                s = (t("../equations/Equation"), t("../equations/AngleLockEquation"));
            t("../math/vec2");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.update = function() { var t = this.equations[0];
                t.ratio !== this.ratio && t.setRatio(this.ratio), t.angle = this.angle }, o.prototype.setMaxTorque = function(t) { this.equations[0].setMaxTorque(t) }, o.prototype.getMaxTorque = function(t) { return this.equations[0].maxForce } }, { "../equations/AngleLockEquation": 20, "../equations/Equation": 22, "../math/vec2": 30, "./Constraint": 14 }], 17: [function(t, e, i) {
            function o(t, e, i) { i = i || {}, n.call(this, t, e, n.LOCK, i); var o = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce,
                    a = (i.localAngleB, new r(t, e, -o, o)),
                    h = new r(t, e, -o, o),
                    l = new r(t, e, -o, o),
                    c = s.create(),
                    d = s.create(),
                    u = this;
                a.computeGq = function() { return s.rotate(c, u.localOffsetB, t.angle), s.sub(d, e.position, t.position), s.sub(d, d, c), d[0] }, h.computeGq = function() { return s.rotate(c, u.localOffsetB, t.angle), s.sub(d, e.position, t.position), s.sub(d, d, c), d[1] }; var p = s.create(),
                    m = s.create();
                l.computeGq = function() { return s.rotate(p, u.localOffsetB, e.angle - u.localAngleB), s.scale(p, p, -1), s.sub(d, t.position, e.position), s.add(d, d, p), s.rotate(m, p, -Math.PI / 2), s.normalize(m, m), s.dot(d, m) }, this.localOffsetB = s.create(), i.localOffsetB ? s.copy(this.localOffsetB, i.localOffsetB) : (s.sub(this.localOffsetB, e.position, t.position), s.rotate(this.localOffsetB, this.localOffsetB, -t.angle)), this.localAngleB = 0, "number" == typeof i.localAngleB ? this.localAngleB = i.localAngleB : this.localAngleB = e.angle - t.angle, this.equations.push(a, h, l), this.setMaxForce(o) } var n = t("./Constraint"),
                s = t("../math/vec2"),
                r = t("../equations/Equation");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.setMaxForce = function(t) { for (var e = this.equations, i = 0; i < this.equations.length; i++) e[i].maxForce = t, e[i].minForce = -t }, o.prototype.getMaxForce = function() { return this.equations[0].maxForce }; var a = s.create(),
                h = s.create(),
                l = s.create(),
                c = s.fromValues(1, 0),
                d = s.fromValues(0, 1);
            o.prototype.update = function() { var t = this.equations[0],
                    e = this.equations[1],
                    i = this.equations[2],
                    o = this.bodyA,
                    n = this.bodyB;
                s.rotate(a, this.localOffsetB, o.angle), s.rotate(h, this.localOffsetB, n.angle - this.localAngleB), s.scale(h, h, -1), s.rotate(l, h, Math.PI / 2), s.normalize(l, l), t.G[0] = -1, t.G[1] = 0, t.G[2] = -s.crossLength(a, c), t.G[3] = 1, e.G[0] = 0, e.G[1] = -1, e.G[2] = -s.crossLength(a, d), e.G[4] = 1, i.G[0] = -l[0], i.G[1] = -l[1], i.G[3] = l[0], i.G[4] = l[1], i.G[5] = s.crossLength(h, l) } }, { "../equations/Equation": 22, "../math/vec2": 30, "./Constraint": 14 }], 18: [function(t, e, i) {
            function o(t, e, i) { i = i || {}, n.call(this, t, e, n.PRISMATIC, i); var o = a.fromValues(0, 0),
                    l = a.fromValues(1, 0),
                    c = a.fromValues(0, 0);
                i.localAnchorA && a.copy(o, i.localAnchorA), i.localAxisA && a.copy(l, i.localAxisA), i.localAnchorB && a.copy(c, i.localAnchorB), this.localAnchorA = o, this.localAnchorB = c, this.localAxisA = l; var d = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE,
                    u = new r(t, e, -d, d),
                    p = new a.create,
                    m = new a.create,
                    f = new a.create,
                    y = new a.create; if (u.computeGq = function() { return a.dot(f, y) }, u.updateJacobian = function() { var i = this.G,
                            n = t.position,
                            s = e.position;
                        a.rotate(p, o, t.angle), a.rotate(m, c, e.angle), a.add(f, s, m), a.sub(f, f, n), a.sub(f, f, p), a.rotate(y, l, t.angle + Math.PI / 2), i[0] = -y[0], i[1] = -y[1], i[2] = -a.crossLength(p, y) + a.crossLength(y, f), i[3] = y[0], i[4] = y[1], i[5] = a.crossLength(m, y) }, this.equations.push(u), !i.disableRotationalLock) { var b = new h(t, e, -d, d);
                    this.equations.push(b) } this.position = 0, this.velocity = 0, this.lowerLimitEnabled = void 0 !== i.lowerLimit, this.upperLimitEnabled = void 0 !== i.upperLimit, this.lowerLimit = void 0 !== i.lowerLimit ? i.lowerLimit : 0, this.upperLimit = void 0 !== i.upperLimit ? i.upperLimit : 1, this.upperLimitEquation = new s(t, e), this.lowerLimitEquation = new s(t, e), this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0, this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = d, this.motorEquation = new r(t, e), this.motorEnabled = !1, this.motorSpeed = 0; var g = this,
                    _ = this.motorEquation;
                _.computeGW;
                _.computeGq = function() { return 0 }, _.computeGW = function() { var t = this.G,
                        e = this.bodyA,
                        i = this.bodyB,
                        o = e.velocity,
                        n = i.velocity,
                        s = e.angularVelocity,
                        r = i.angularVelocity; return this.gmult(t, o, s, n, r) + g.motorSpeed } } var n = t("./Constraint"),
                s = t("../equations/ContactEquation"),
                r = t("../equations/Equation"),
                a = t("../math/vec2"),
                h = t("../equations/RotationalLockEquation");
            e.exports = o, (o.prototype = new n).constructor = o; var l = a.create(),
                c = a.create(),
                d = a.create(),
                u = a.create(),
                p = a.create(),
                m = a.create();
            o.prototype.update = function() { var t = this.equations,
                    e = t[0],
                    i = this.upperLimit,
                    o = this.lowerLimit,
                    n = this.upperLimitEquation,
                    s = this.lowerLimitEquation,
                    r = this.bodyA,
                    h = this.bodyB,
                    f = this.localAxisA,
                    y = this.localAnchorA,
                    b = this.localAnchorB;
                e.updateJacobian(), a.rotate(l, f, r.angle), a.rotate(u, y, r.angle), a.add(c, u, r.position), a.rotate(p, b, h.angle), a.add(d, p, h.position); var g = this.position = a.dot(d, l) - a.dot(c, l); if (this.motorEnabled) { var _ = this.motorEquation.G;
                    _[0] = l[0], _[1] = l[1], _[2] = a.crossLength(l, p), _[3] = -l[0], _[4] = -l[1], _[5] = -a.crossLength(l, u) } if (this.upperLimitEnabled && g > i ? (a.scale(n.normalA, l, -1), a.sub(n.contactPointA, c, r.position), a.sub(n.contactPointB, d, h.position), a.scale(m, l, i), a.add(n.contactPointA, n.contactPointA, m), -1 === t.indexOf(n) && t.push(n)) : -1 !== (v = t.indexOf(n)) && t.splice(v, 1), this.lowerLimitEnabled && g < o) a.scale(s.normalA, l, 1), a.sub(s.contactPointA, c, r.position), a.sub(s.contactPointB, d, h.position), a.scale(m, l, o), a.sub(s.contactPointB, s.contactPointB, m), -1 === t.indexOf(s) && t.push(s);
                else { var v = t.indexOf(s); - 1 !== v && t.splice(v, 1) } }, o.prototype.enableMotor = function() { this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0) }, o.prototype.disableMotor = function() { if (this.motorEnabled) { var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1), this.motorEnabled = !1 } }, o.prototype.setLimits = function(t, e) { "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1), "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1) } }, { "../equations/ContactEquation": 21, "../equations/Equation": 22, "../equations/RotationalLockEquation": 24, "../math/vec2": 30, "./Constraint": 14 }], 19: [function(t, e, i) {
            function o(t, e, i) { i = i || {}, n.call(this, t, e, n.REVOLUTE, i); var o = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE;
                this.pivotA = h.create(), this.pivotB = h.create(), i.worldPivot ? (h.sub(this.pivotA, i.worldPivot, t.position), h.sub(this.pivotB, i.worldPivot, e.position), h.rotate(this.pivotA, this.pivotA, -t.angle), h.rotate(this.pivotB, this.pivotB, -e.angle)) : (h.copy(this.pivotA, i.localPivotA), h.copy(this.pivotB, i.localPivotB)); var m = this.equations = [new s(t, e, -o, o), new s(t, e, -o, o)],
                    f = m[0],
                    y = m[1],
                    b = this;
                f.computeGq = function() { return h.rotate(l, b.pivotA, t.angle), h.rotate(c, b.pivotB, e.angle), h.add(p, e.position, c), h.sub(p, p, t.position), h.sub(p, p, l), h.dot(p, d) }, y.computeGq = function() { return h.rotate(l, b.pivotA, t.angle), h.rotate(c, b.pivotB, e.angle), h.add(p, e.position, c), h.sub(p, p, t.position), h.sub(p, p, l), h.dot(p, u) }, y.minForce = f.minForce = -o, y.maxForce = f.maxForce = o, this.motorEquation = new r(t, e), this.motorEnabled = !1, this.angle = 0, this.lowerLimitEnabled = !1, this.upperLimitEnabled = !1, this.lowerLimit = 0, this.upperLimit = 0, this.upperLimitEquation = new a(t, e), this.lowerLimitEquation = new a(t, e), this.upperLimitEquation.minForce = 0, this.lowerLimitEquation.maxForce = 0 } var n = t("./Constraint"),
                s = t("../equations/Equation"),
                r = t("../equations/RotationalVelocityEquation"),
                a = t("../equations/RotationalLockEquation"),
                h = t("../math/vec2");
            e.exports = o; var l = h.create(),
                c = h.create(),
                d = h.fromValues(1, 0),
                u = h.fromValues(0, 1),
                p = h.create();
            (o.prototype = new n).constructor = o, o.prototype.setLimits = function(t, e) { "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1), "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1) }, o.prototype.update = function() { var t = this.bodyA,
                    e = this.bodyB,
                    i = this.pivotA,
                    o = this.pivotB,
                    n = this.equations,
                    s = (n[0], n[1], n[0]),
                    r = n[1],
                    a = this.upperLimit,
                    p = this.lowerLimit,
                    m = this.upperLimitEquation,
                    f = this.lowerLimitEquation,
                    y = this.angle = e.angle - t.angle; if (this.upperLimitEnabled && y > a ? (m.angle = a, -1 === n.indexOf(m) && n.push(m)) : -1 !== (b = n.indexOf(m)) && n.splice(b, 1), this.lowerLimitEnabled && y < p) f.angle = p, -1 === n.indexOf(f) && n.push(f);
                else { var b = n.indexOf(f); - 1 !== b && n.splice(b, 1) } h.rotate(l, i, t.angle), h.rotate(c, o, e.angle), s.G[0] = -1, s.G[1] = 0, s.G[2] = -h.crossLength(l, d), s.G[3] = 1, s.G[4] = 0, s.G[5] = h.crossLength(c, d), r.G[0] = 0, r.G[1] = -1, r.G[2] = -h.crossLength(l, u), r.G[3] = 0, r.G[4] = 1, r.G[5] = h.crossLength(c, u) }, o.prototype.enableMotor = function() { this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0) }, o.prototype.disableMotor = function() { if (this.motorEnabled) { var t = this.equations.indexOf(this.motorEquation);
                    this.equations.splice(t, 1), this.motorEnabled = !1 } }, o.prototype.motorIsEnabled = function() { return !!this.motorEnabled }, o.prototype.setMotorSpeed = function(t) { if (this.motorEnabled) { var e = this.equations.indexOf(this.motorEquation);
                    this.equations[e].relativeVelocity = t } }, o.prototype.getMotorSpeed = function() { return !!this.motorEnabled && this.motorEquation.relativeVelocity } }, { "../equations/Equation": 22, "../equations/RotationalLockEquation": 24, "../equations/RotationalVelocityEquation": 25, "../math/vec2": 30, "./Constraint": 14 }], 20: [function(t, e, i) {
            function o(t, e, i) { i = i || {}, n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0, this.ratio = "number" == typeof i.ratio ? i.ratio : 1, this.setRatio(this.ratio) } var n = t("./Equation");
            t("../math/vec2");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.computeGq = function() { return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle }, o.prototype.setRatio = function(t) { var e = this.G;
                e[2] = t, e[5] = -1, this.ratio = t }, o.prototype.setMaxTorque = function(t) { this.maxForce = t, this.minForce = -t } }, { "../math/vec2": 30, "./Equation": 22 }], 21: [function(t, e, i) {
            function o(t, e) { n.call(this, t, e, 0, Number.MAX_VALUE), this.contactPointA = s.create(), this.penetrationVec = s.create(), this.contactPointB = s.create(), this.normalA = s.create(), this.restitution = 0, this.firstImpact = !1, this.shapeA = null, this.shapeB = null } var n = t("./Equation"),
                s = t("../math/vec2");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.computeB = function(t, e, i) { var o = this.bodyA,
                    n = this.bodyB,
                    r = this.contactPointA,
                    a = this.contactPointB,
                    h = o.position,
                    l = n.position,
                    c = this.penetrationVec,
                    d = this.normalA,
                    u = this.G,
                    p = s.crossLength(r, d),
                    m = s.crossLength(a, d);
                u[0] = -d[0], u[1] = -d[1], u[2] = -p, u[3] = d[0], u[4] = d[1], u[5] = m, s.add(c, l, a), s.sub(c, c, h), s.sub(c, c, r); var f, y; return this.firstImpact && 0 !== this.restitution ? (y = 0, f = 1 / e * (1 + this.restitution) * this.computeGW()) : (y = s.dot(d, c) + this.offset, f = this.computeGW()), -y * t - f * e - i * this.computeGiMf() } }, { "../math/vec2": 30, "./Equation": 22 }], 22: [function(t, e, i) {
            function o(t, e, i, n) { this.minForce = void 0 === i ? -Number.MAX_VALUE : i, this.maxForce = void 0 === n ? Number.MAX_VALUE : n, this.bodyA = t, this.bodyB = e, this.stiffness = o.DEFAULT_STIFFNESS, this.relaxation = o.DEFAULT_RELAXATION, this.G = new s.ARRAY_TYPE(6); for (var r = 0; r < 6; r++) this.G[r] = 0;
                this.offset = 0, this.a = 0, this.b = 0, this.epsilon = 0, this.timeStep = 1 / 60, this.needsUpdate = !0, this.multiplier = 0, this.relativeVelocity = 0, this.enabled = !0 } e.exports = o; var n = t("../math/vec2"),
                s = t("../utils/Utils");
            t("../objects/Body");
            o.prototype.constructor = o, o.DEFAULT_STIFFNESS = 1e6, o.DEFAULT_RELAXATION = 4, o.prototype.update = function() { var t = this.stiffness,
                    e = this.relaxation,
                    i = this.timeStep;
                this.a = 4 / (i * (1 + 4 * e)), this.b = 4 * e / (1 + 4 * e), this.epsilon = 4 / (i * i * t * (1 + 4 * e)), this.needsUpdate = !1 }, o.prototype.gmult = function(t, e, i, o, n) { return t[0] * e[0] + t[1] * e[1] + t[2] * i + t[3] * o[0] + t[4] * o[1] + t[5] * n }, o.prototype.computeB = function(t, e, i) { var o = this.computeGW(); return -this.computeGq() * t - o * e - this.computeGiMf() * i }; var r = n.create(),
                a = n.create();
            o.prototype.computeGq = function() { var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    o = (e.position, i.position, e.angle),
                    n = i.angle; return this.gmult(t, r, o, a, n) + this.offset }, o.prototype.computeGW = function() { var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    o = e.velocity,
                    n = i.velocity,
                    s = e.angularVelocity,
                    r = i.angularVelocity; return this.gmult(t, o, s, n, r) + this.relativeVelocity }, o.prototype.computeGWlambda = function() { var t = this.G,
                    e = this.bodyA,
                    i = this.bodyB,
                    o = e.vlambda,
                    n = i.vlambda,
                    s = e.wlambda,
                    r = i.wlambda; return this.gmult(t, o, s, n, r) }; var h = n.create(),
                l = n.create();
            o.prototype.computeGiMf = function() { var t = this.bodyA,
                    e = this.bodyB,
                    i = t.force,
                    o = t.angularForce,
                    s = e.force,
                    r = e.angularForce,
                    a = t.invMassSolve,
                    c = e.invMassSolve,
                    d = t.invInertiaSolve,
                    u = e.invInertiaSolve,
                    p = this.G; return n.scale(h, i, a), n.multiply(h, t.massMultiplier, h), n.scale(l, s, c), n.multiply(l, e.massMultiplier, l), this.gmult(p, h, o * d, l, r * u) }, o.prototype.computeGiMGt = function() { var t = this.bodyA,
                    e = this.bodyB,
                    i = t.invMassSolve,
                    o = e.invMassSolve,
                    n = t.invInertiaSolve,
                    s = e.invInertiaSolve,
                    r = this.G; return r[0] * r[0] * i * t.massMultiplier[0] + r[1] * r[1] * i * t.massMultiplier[1] + r[2] * r[2] * n + r[3] * r[3] * o * e.massMultiplier[0] + r[4] * r[4] * o * e.massMultiplier[1] + r[5] * r[5] * s }; var c = n.create(),
                d = n.create(),
                u = n.create();
            n.create(), n.create(), n.create();
            o.prototype.addToWlambda = function(t) { var e = this.bodyA,
                    i = this.bodyB,
                    o = c,
                    s = d,
                    r = u,
                    a = e.invMassSolve,
                    h = i.invMassSolve,
                    l = e.invInertiaSolve,
                    p = i.invInertiaSolve,
                    m = this.G;
                s[0] = m[0], s[1] = m[1], r[0] = m[3], r[1] = m[4], n.scale(o, s, a * t), n.multiply(o, o, e.massMultiplier), n.add(e.vlambda, e.vlambda, o), e.wlambda += l * m[2] * t, n.scale(o, r, h * t), n.multiply(o, o, i.massMultiplier), n.add(i.vlambda, i.vlambda, o), i.wlambda += p * m[5] * t }, o.prototype.computeInvC = function(t) { return 1 / (this.computeGiMGt() + t) } }, { "../math/vec2": 30, "../objects/Body": 31, "../utils/Utils": 57 }], 23: [function(t, e, i) {
            function o(t, e, i) { s.call(this, t, e, -i, i), this.contactPointA = n.create(), this.contactPointB = n.create(), this.t = n.create(), this.contactEquations = [], this.shapeA = null, this.shapeB = null, this.frictionCoefficient = .3 } var n = t("../math/vec2"),
                s = t("./Equation");
            t("../utils/Utils");
            e.exports = o, (o.prototype = new s).constructor = o, o.prototype.setSlipForce = function(t) { this.maxForce = t, this.minForce = -t }, o.prototype.getSlipForce = function() { return this.maxForce }, o.prototype.computeB = function(t, e, i) { this.bodyA, this.bodyB; var o = this.contactPointA,
                    s = this.contactPointB,
                    r = this.t,
                    a = this.G; return a[0] = -r[0], a[1] = -r[1], a[2] = -n.crossLength(o, r), a[3] = r[0], a[4] = r[1], a[5] = n.crossLength(s, r), -this.computeGW() * e - i * this.computeGiMf() } }, { "../math/vec2": 30, "../utils/Utils": 57, "./Equation": 22 }], 24: [function(t, e, i) {
            function o(t, e, i) { i = i || {}, n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0; var o = this.G;
                o[2] = 1, o[5] = -1 } var n = t("./Equation"),
                s = t("../math/vec2");
            e.exports = o, (o.prototype = new n).constructor = o; var r = s.create(),
                a = s.create(),
                h = s.fromValues(1, 0),
                l = s.fromValues(0, 1);
            o.prototype.computeGq = function() { return s.rotate(r, h, this.bodyA.angle + this.angle), s.rotate(a, l, this.bodyB.angle), s.dot(r, a) } }, { "../math/vec2": 30, "./Equation": 22 }], 25: [function(t, e, i) {
            function o(t, e) { n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.relativeVelocity = 1, this.ratio = 1 } var n = t("./Equation");
            t("../math/vec2");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.computeB = function(t, e, i) { var o = this.G;
                o[2] = -1, o[5] = this.ratio; var n = this.computeGiMf(); return -this.computeGW() * e - i * n } }, { "../math/vec2": 30, "./Equation": 22 }], 26: [function(t, e, i) { var o = function() {};
            e.exports = o, o.prototype = { constructor: o, on: function(t, e, i) { e.context = i || this, void 0 === this._listeners && (this._listeners = {}); var o = this._listeners; return void 0 === o[t] && (o[t] = []), -1 === o[t].indexOf(e) && o[t].push(e), this }, has: function(t, e) { if (void 0 === this._listeners) return !1; var i = this._listeners; if (e) { if (void 0 !== i[t] && -1 !== i[t].indexOf(e)) return !0 } else if (void 0 !== i[t]) return !0; return !1 }, off: function(t, e) { if (void 0 === this._listeners) return this; var i = this._listeners,
                        o = i[t].indexOf(e); return -1 !== o && i[t].splice(o, 1), this }, emit: function(t) { if (void 0 === this._listeners) return this; var e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; for (var i = 0, o = e.length; i < o; i++) { var n = e[i];
                            n.call(n.context, t) } } return this } } }, {}], 27: [function(t, e, i) {
            function o(t, e, i) { if (i = i || {}, !(t instanceof n && e instanceof n)) throw new Error("First two arguments must be Material instances.");
                this.id = o.idCounter++, this.materialA = t, this.materialB = e, this.friction = void 0 !== i.friction ? Number(i.friction) : .3, this.restitution = void 0 !== i.restitution ? Number(i.restitution) : 0, this.stiffness = void 0 !== i.stiffness ? Number(i.stiffness) : s.DEFAULT_STIFFNESS, this.relaxation = void 0 !== i.relaxation ? Number(i.relaxation) : s.DEFAULT_RELAXATION, this.frictionStiffness = void 0 !== i.frictionStiffness ? Number(i.frictionStiffness) : s.DEFAULT_STIFFNESS, this.frictionRelaxation = void 0 !== i.frictionRelaxation ? Number(i.frictionRelaxation) : s.DEFAULT_RELAXATION, this.surfaceVelocity = void 0 !== i.surfaceVelocity ? Number(i.surfaceVelocity) : 0, this.contactSkinSize = .005 } var n = t("./Material"),
                s = t("../equations/Equation");
            e.exports = o, o.idCounter = 0 }, { "../equations/Equation": 22, "./Material": 28 }], 28: [function(t, e, i) {
            function o(t) { this.id = t || o.idCounter++ } e.exports = o, o.idCounter = 0 }, {}], 29: [function(t, e, i) { var o = {};
            o.GetArea = function(t) { if (t.length < 6) return 0; for (var e = t.length - 2, i = 0, o = 0; o < e; o += 2) i += (t[o + 2] - t[o]) * (t[o + 1] + t[o + 3]); return .5 * -(i += (t[0] - t[e]) * (t[e + 1] + t[1])) }, o.Triangulate = function(t) { var e = t.length >> 1; if (e < 3) return []; for (var i = [], n = [], s = 0; s < e; s++) n.push(s); for (var s = 0, r = e; r > 3;) { var a = n[(s + 0) % r],
                        h = n[(s + 1) % r],
                        l = n[(s + 2) % r],
                        c = t[2 * a],
                        d = t[2 * a + 1],
                        u = t[2 * h],
                        p = t[2 * h + 1],
                        m = t[2 * l],
                        f = t[2 * l + 1],
                        y = !1; if (o._convex(c, d, u, p, m, f)) { y = !0; for (var b = 0; b < r; b++) { var g = n[b]; if (g != a && g != h && g != l && o._PointInTriangle(t[2 * g], t[2 * g + 1], c, d, u, p, m, f)) { y = !1; break } } } if (y) i.push(a, h, l), n.splice((s + 1) % r, 1), r--, s = 0;
                    else if (s++ > 3 * r) break } return i.push(n[0], n[1], n[2]), i }, o._PointInTriangle = function(t, e, i, o, n, s, r, a) { var h = r - i,
                    l = a - o,
                    c = n - i,
                    d = s - o,
                    u = t - i,
                    p = e - o,
                    m = h * h + l * l,
                    f = h * c + l * d,
                    y = h * u + l * p,
                    b = c * c + d * d,
                    g = c * u + d * p,
                    _ = 1 / (m * b - f * f),
                    v = (b * y - f * g) * _,
                    x = (m * g - f * y) * _; return v >= 0 && x >= 0 && v + x < 1 }, o._convex = function(t, e, i, o, n, s) { return (e - o) * (n - i) + (i - t) * (s - o) >= 0 }, e.exports = o }, {}], 30: [function(t, e, i) { var o = e.exports = {},
                n = t("../utils/Utils");
            o.crossLength = function(t, e) { return t[0] * e[1] - t[1] * e[0] }, o.crossVZ = function(t, e, i) { return o.rotate(t, e, -Math.PI / 2), o.scale(t, t, i), t }, o.crossZV = function(t, e, i) { return o.rotate(t, i, Math.PI / 2), o.scale(t, t, e), t }, o.rotate = function(t, e, i) { if (0 !== i) { var o = Math.cos(i),
                        n = Math.sin(i),
                        s = e[0],
                        r = e[1];
                    t[0] = o * s - n * r, t[1] = n * s + o * r } else t[0] = e[0], t[1] = e[1] }, o.rotate90cw = function(t, e) { var i = e[0],
                    o = e[1];
                t[0] = o, t[1] = -i }, o.toLocalFrame = function(t, e, i, n) { o.copy(t, e), o.sub(t, t, i), o.rotate(t, t, -n) }, o.toGlobalFrame = function(t, e, i, n) { o.copy(t, e), o.rotate(t, t, n), o.add(t, t, i) }, o.vectorToLocalFrame = function(t, e, i) { o.rotate(t, e, -i) }, o.vectorToGlobalFrame = function(t, e, i) { o.rotate(t, e, i) }, o.centroid = function(t, e, i, n) { return o.add(t, e, i), o.add(t, t, n), o.scale(t, t, 1 / 3), t }, o.create = function() { var t = new n.ARRAY_TYPE(2); return t[0] = 0, t[1] = 0, t }, o.clone = function(t) { var e = new n.ARRAY_TYPE(2); return e[0] = t[0], e[1] = t[1], e }, o.fromValues = function(t, e) { var i = new n.ARRAY_TYPE(2); return i[0] = t, i[1] = e, i }, o.copy = function(t, e) { return t[0] = e[0], t[1] = e[1], t }, o.set = function(t, e, i) { return t[0] = e, t[1] = i, t }, o.add = function(t, e, i) { return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t }, o.subtract = function(t, e, i) { return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t }, o.sub = o.subtract, o.multiply = function(t, e, i) { return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t }, o.mul = o.multiply, o.divide = function(t, e, i) { return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t }, o.div = o.divide, o.scale = function(t, e, i) { return t[0] = e[0] * i, t[1] = e[1] * i, t }, o.distance = function(t, e) { var i = e[0] - t[0],
                    o = e[1] - t[1]; return Math.sqrt(i * i + o * o) }, o.dist = o.distance, o.squaredDistance = function(t, e) { var i = e[0] - t[0],
                    o = e[1] - t[1]; return i * i + o * o }, o.sqrDist = o.squaredDistance, o.length = function(t) { var e = t[0],
                    i = t[1]; return Math.sqrt(e * e + i * i) }, o.len = o.length, o.squaredLength = function(t) { var e = t[0],
                    i = t[1]; return e * e + i * i }, o.sqrLen = o.squaredLength, o.negate = function(t, e) { return t[0] = -e[0], t[1] = -e[1], t }, o.normalize = function(t, e) { var i = e[0],
                    o = e[1],
                    n = i * i + o * o; return n > 0 && (n = 1 / Math.sqrt(n), t[0] = e[0] * n, t[1] = e[1] * n), t }, o.dot = function(t, e) { return t[0] * e[0] + t[1] * e[1] }, o.str = function(t) { return "vec2(" + t[0] + ", " + t[1] + ")" }, o.lerp = function(t, e, i, o) { var n = e[0],
                    s = e[1]; return t[0] = n + o * (i[0] - n), t[1] = s + o * (i[1] - s), t }, o.reflect = function(t, e, i) { var o = e[0] * i[0] + e[1] * i[1];
                t[0] = e[0] - 2 * i[0] * o, t[1] = e[1] - 2 * i[1] * o }, o.getLineSegmentsIntersection = function(t, e, i, n, s) { var r = o.getLineSegmentsIntersectionFraction(e, i, n, s); return !(r < 0) && (t[0] = e[0] + r * (i[0] - e[0]), t[1] = e[1] + r * (i[1] - e[1]), !0) }, o.getLineSegmentsIntersectionFraction = function(t, e, i, o) { var n, s, r = e[0] - t[0],
                    a = e[1] - t[1],
                    h = o[0] - i[0],
                    l = o[1] - i[1]; return n = (-a * (t[0] - i[0]) + r * (t[1] - i[1])) / (-h * a + r * l), s = (h * (t[1] - i[1]) - l * (t[0] - i[0])) / (-h * a + r * l), n >= 0 && n <= 1 && s >= 0 && s <= 1 ? s : -1 } }, { "../utils/Utils": 57 }], 31: [function(t, e, i) {
            function o(t) { t = t || {}, c.call(this), this.id = t.id || ++o._idCounter, this.world = null, this.shapes = [], this.mass = t.mass || 0, this.invMass = 0, this.inertia = 0, this.invInertia = 0, this.invMassSolve = 0, this.invInertiaSolve = 0, this.fixedRotation = !!t.fixedRotation, this.fixedX = !!t.fixedX, this.fixedY = !!t.fixedY, this.massMultiplier = n.create(), this.position = n.fromValues(0, 0), t.position && n.copy(this.position, t.position), this.interpolatedPosition = n.fromValues(0, 0), this.interpolatedAngle = 0, this.previousPosition = n.fromValues(0, 0), this.previousAngle = 0, this.velocity = n.fromValues(0, 0), t.velocity && n.copy(this.velocity, t.velocity), this.vlambda = n.fromValues(0, 0), this.wlambda = 0, this.angle = t.angle || 0, this.angularVelocity = t.angularVelocity || 0, this.force = n.create(), t.force && n.copy(this.force, t.force), this.angularForce = t.angularForce || 0, this.damping = "number" == typeof t.damping ? t.damping : .1, this.angularDamping = "number" == typeof t.angularDamping ? t.angularDamping : .1, this.type = o.STATIC, void 0 !== t.type ? this.type = t.type : t.mass ? this.type = o.DYNAMIC : this.type = o.STATIC, this.boundingRadius = 0, this.aabb = new l, this.aabbNeedsUpdate = !0, this.allowSleep = void 0 === t.allowSleep || t.allowSleep, this.wantsToSleep = !1, this.sleepState = o.AWAKE, this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .2, this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1, this.gravityScale = void 0 !== t.gravityScale ? t.gravityScale : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.idleTime = 0, this.timeLastSleepy = 0, this.ccdSpeedThreshold = void 0 !== t.ccdSpeedThreshold ? t.ccdSpeedThreshold : -1, this.ccdIterations = void 0 !== t.ccdIterations ? t.ccdIterations : 10, this.concavePath = null, this._wakeUpAfterNarrowphase = !1, this.updateMassProperties() } var n = t("../math/vec2"),
                s = t("poly-decomp"),
                r = t("../shapes/Convex"),
                a = t("../collision/RaycastResult"),
                h = t("../collision/Ray"),
                l = t("../collision/AABB"),
                c = t("../events/EventEmitter");
            e.exports = o, o.prototype = new c, o.prototype.constructor = o, o._idCounter = 0, o.prototype.updateSolveMassProperties = function() { this.sleepState === o.SLEEPING || this.type === o.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass, this.invInertiaSolve = this.invInertia) }, o.prototype.setDensity = function(t) { var e = this.getArea();
                this.mass = e * t, this.updateMassProperties() }, o.prototype.getArea = function() { for (var t = 0, e = 0; e < this.shapes.length; e++) t += this.shapes[e].area; return t }, o.prototype.getAABB = function() { return this.aabbNeedsUpdate && this.updateAABB(), this.aabb }; var d = new l,
                u = n.create();
            o.prototype.updateAABB = function() { for (var t = this.shapes, e = t.length, i = u, o = this.angle, s = 0; s !== e; s++) { var r = t[s],
                        a = r.angle + o;
                    n.rotate(i, r.position, o), n.add(i, i, this.position), r.computeAABB(d, i, a), 0 === s ? this.aabb.copy(d) : this.aabb.extend(d) } this.aabbNeedsUpdate = !1 }, o.prototype.updateBoundingRadius = function() { for (var t = this.shapes, e = t.length, i = 0, o = 0; o !== e; o++) { var s = t[o],
                        r = n.length(s.position),
                        a = s.boundingRadius;
                    r + a > i && (i = r + a) } this.boundingRadius = i }, o.prototype.addShape = function(t, e, i) { if (t.body) throw new Error("A shape can only be added to one body.");
                t.body = this, e ? n.copy(t.position, e) : n.set(t.position, 0, 0), t.angle = i || 0, this.shapes.push(t), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0 }, o.prototype.removeShape = function(t) { var e = this.shapes.indexOf(t); return -1 !== e && (this.shapes.splice(e, 1), this.aabbNeedsUpdate = !0, t.body = null, !0) }, o.prototype.updateMassProperties = function() { if (this.type === o.STATIC || this.type === o.KINEMATIC) this.mass = Number.MAX_VALUE, this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                else { var t = this.shapes,
                        e = t.length,
                        i = this.mass / e,
                        s = 0; if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                    else { for (var r = 0; r < e; r++) { var a = t[r],
                                h = n.squaredLength(a.position);
                            s += a.computeMomentOfInertia(i) + i * h } this.inertia = s, this.invInertia = s > 0 ? 1 / s : 0 } this.invMass = 1 / this.mass, n.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1) } };
            n.create();
            o.prototype.applyForce = function(t, e) { if (n.add(this.force, this.force, t), e) { var i = n.crossLength(e, t);
                    this.angularForce += i } }; var p = n.create(),
                m = n.create(),
                f = n.create();
            o.prototype.applyForceLocal = function(t, e) { e = e || f; var i = p,
                    o = m;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(o, e), this.applyForce(i, o) }; var y = n.create();
            o.prototype.applyImpulse = function(t, e) { if (this.type === o.DYNAMIC) { var i = y; if (n.scale(i, t, this.invMass), n.multiply(i, this.massMultiplier, i), n.add(this.velocity, i, this.velocity), e) { var s = n.crossLength(e, t);
                        s *= this.invInertia, this.angularVelocity += s } } }; var b = n.create(),
                g = n.create(),
                _ = n.create();
            o.prototype.applyImpulseLocal = function(t, e) { e = e || _; var i = b,
                    o = g;
                this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(o, e), this.applyImpulse(i, o) }, o.prototype.toLocalFrame = function(t, e) { n.toLocalFrame(t, e, this.position, this.angle) }, o.prototype.toWorldFrame = function(t, e) { n.toGlobalFrame(t, e, this.position, this.angle) }, o.prototype.vectorToLocalFrame = function(t, e) { n.vectorToLocalFrame(t, e, this.angle) }, o.prototype.vectorToWorldFrame = function(t, e) { n.vectorToGlobalFrame(t, e, this.angle) }, o.prototype.fromPolygon = function(t, e) { e = e || {}; for (h = this.shapes.length; h >= 0; --h) this.removeShape(this.shapes[h]); var i = new s.Polygon; if (i.vertices = t, i.makeCCW(), "number" == typeof e.removeCollinearPoints && i.removeCollinearPoints(e.removeCollinearPoints), void 0 === e.skipSimpleCheck && !i.isSimple()) return !1;
                this.concavePath = i.vertices.slice(0); for (h = 0; h < this.concavePath.length; h++) { d = [0, 0];
                    n.copy(d, this.concavePath[h]), this.concavePath[h] = d } var o;
                o = e.optimalDecomp ? i.decomp() : i.quickDecomp(); for (var a = n.create(), h = 0; h !== o.length; h++) { for (var l = new r({ vertices: o[h].vertices }), c = 0; c !== l.vertices.length; c++) { var d = l.vertices[c];
                        n.sub(d, d, l.centerOfMass) } n.scale(a, l.centerOfMass, 1), l.updateTriangles(), l.updateCenterOfMass(), l.updateBoundingRadius(), this.addShape(l, a) } return this.adjustCenterOfMass(), this.aabbNeedsUpdate = !0, !0 };
            n.fromValues(0, 0); var v = n.fromValues(0, 0),
                x = n.fromValues(0, 0),
                S = n.fromValues(0, 0);
            o.prototype.adjustCenterOfMass = function() { var t = v,
                    e = x,
                    i = S,
                    o = 0;
                n.set(e, 0, 0); for (r = 0; r !== this.shapes.length; r++) { s = this.shapes[r];
                    n.scale(t, s.position, s.area), n.add(e, e, t), o += s.area } n.scale(i, e, 1 / o); for (r = 0; r !== this.shapes.length; r++) { var s = this.shapes[r];
                    n.sub(s.position, s.position, i) } n.add(this.position, this.position, i); for (var r = 0; this.concavePath && r < this.concavePath.length; r++) n.sub(this.concavePath[r], this.concavePath[r], i);
                this.updateMassProperties(), this.updateBoundingRadius() }, o.prototype.setZeroForce = function() { n.set(this.force, 0, 0), this.angularForce = 0 }, o.prototype.resetConstraintVelocity = function() { var t = this,
                    e = t.vlambda;
                n.set(e, 0, 0), t.wlambda = 0 }, o.prototype.addConstraintVelocity = function() { var t = this,
                    e = t.velocity;
                n.add(e, e, t.vlambda), t.angularVelocity += t.wlambda }, o.prototype.applyDamping = function(t) { if (this.type === o.DYNAMIC) { var e = this.velocity;
                    n.scale(e, e, Math.pow(1 - this.damping, t)), this.angularVelocity *= Math.pow(1 - this.angularDamping, t) } }, o.prototype.wakeUp = function() { var t = this.sleepState;
                this.sleepState = o.AWAKE, this.idleTime = 0, t !== o.AWAKE && this.emit(o.wakeUpEvent) }, o.prototype.sleep = function() { this.sleepState = o.SLEEPING, this.angularVelocity = 0, this.angularForce = 0, n.set(this.velocity, 0, 0), n.set(this.force, 0, 0), this.emit(o.sleepEvent) }, o.prototype.sleepTick = function(t, e, i) { if (this.allowSleep && this.type !== o.SLEEPING) { this.wantsToSleep = !1;
                    this.sleepState;
                    n.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2) >= Math.pow(this.sleepSpeedLimit, 2) ? (this.idleTime = 0, this.sleepState = o.AWAKE) : (this.idleTime += i, this.sleepState = o.SLEEPY), this.idleTime > this.sleepTimeLimit && (e ? this.wantsToSleep = !0 : this.sleep()) } }, o.prototype.overlaps = function(t) { return this.world.overlapKeeper.bodiesAreOverlapping(this, t) }; var C = n.create(),
                w = n.create();
            o.prototype.integrate = function(t) { var e = this.invMass,
                    i = this.force,
                    o = this.position,
                    s = this.velocity;
                n.copy(this.previousPosition, this.position), this.previousAngle = this.angle, this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * t), n.scale(C, i, t * e), n.multiply(C, this.massMultiplier, C), n.add(s, C, s), this.integrateToTimeOfImpact(t) || (n.scale(w, s, t), n.add(o, o, w), this.fixedRotation || (this.angle += this.angularVelocity * t)), this.aabbNeedsUpdate = !0 }; var A = new a,
                T = new h({ mode: h.ALL }),
                P = n.create(),
                k = n.create(),
                M = n.create(),
                E = n.create();
            o.prototype.integrateToTimeOfImpact = function(t) { if (this.ccdSpeedThreshold < 0 || n.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return !1;
                n.normalize(P, this.velocity), n.scale(k, this.velocity, t), n.add(k, k, this.position), n.sub(M, k, this.position); var e, i = this.angularVelocity * t,
                    o = n.length(M),
                    s = 1,
                    r = this; if (A.reset(), T.callback = function(t) { t.body !== r && (e = t.body, t.getHitPoint(k, T), n.sub(M, k, r.position), s = n.length(M) / o, t.stop()) }, n.copy(T.from, this.position), n.copy(T.to, k), T.update(), this.world.raycast(A, T), !e) return !1; var a = this.angle;
                n.copy(E, this.position); for (var h = 0, l = 0, c = 0, d = s; d >= l && h < this.ccdIterations;) h++, c = (d - l) / 2, n.scale(w, M, s), n.add(this.position, E, w), this.angle = a + i * s, this.updateAABB(), this.aabb.overlaps(e.aabb) && this.world.narrowphase.bodiesOverlap(this, e) ? l = c : d = c; return s = c, n.copy(this.position, E), this.angle = a, n.scale(w, M, s), n.add(this.position, this.position, w), this.fixedRotation || (this.angle += i * s), !0 }, o.prototype.getVelocityAtPoint = function(t, e) { return n.crossVZ(t, e, this.angularVelocity), n.subtract(t, this.velocity, t), t }, o.sleepyEvent = { type: "sleepy" }, o.sleepEvent = { type: "sleep" }, o.wakeUpEvent = { type: "wakeup" }, o.DYNAMIC = 1, o.STATIC = 2, o.KINEMATIC = 4, o.AWAKE = 0, o.SLEEPY = 1, o.SLEEPING = 2 }, { "../collision/AABB": 7, "../collision/Ray": 11, "../collision/RaycastResult": 12, "../events/EventEmitter": 26, "../math/vec2": 30, "../shapes/Convex": 40, "poly-decomp": 5 }], 32: [function(t, e, i) {
            function o(t, e, i) { i = i || {}, s.call(this, t, e, i), this.localAnchorA = n.fromValues(0, 0), this.localAnchorB = n.fromValues(0, 0), i.localAnchorA && n.copy(this.localAnchorA, i.localAnchorA), i.localAnchorB && n.copy(this.localAnchorB, i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB); var o = n.create(),
                    r = n.create();
                this.getWorldAnchorA(o), this.getWorldAnchorB(r); var a = n.distance(o, r);
                this.restLength = "number" == typeof i.restLength ? i.restLength : a } var n = t("../math/vec2"),
                s = t("./Spring");
            t("../utils/Utils");
            e.exports = o, (o.prototype = new s).constructor = o, o.prototype.setWorldAnchorA = function(t) { this.bodyA.toLocalFrame(this.localAnchorA, t) }, o.prototype.setWorldAnchorB = function(t) { this.bodyB.toLocalFrame(this.localAnchorB, t) }, o.prototype.getWorldAnchorA = function(t) { this.bodyA.toWorldFrame(t, this.localAnchorA) }, o.prototype.getWorldAnchorB = function(t) { this.bodyB.toWorldFrame(t, this.localAnchorB) }; var r = n.create(),
                a = n.create(),
                h = n.create(),
                l = n.create(),
                c = n.create(),
                d = n.create(),
                u = n.create(),
                p = n.create(),
                m = n.create();
            o.prototype.applyForce = function() { var t = this.stiffness,
                    e = this.damping,
                    i = this.restLength,
                    o = this.bodyA,
                    s = this.bodyB,
                    f = r,
                    y = a,
                    b = h,
                    g = l,
                    _ = m,
                    v = c,
                    x = d,
                    S = u,
                    C = p;
                this.getWorldAnchorA(v), this.getWorldAnchorB(x), n.sub(S, v, o.position), n.sub(C, x, s.position), n.sub(f, x, v); var w = n.len(f);
                n.normalize(y, f), n.sub(b, s.velocity, o.velocity), n.crossZV(_, s.angularVelocity, C), n.add(b, b, _), n.crossZV(_, o.angularVelocity, S), n.sub(b, b, _), n.scale(g, y, -t * (w - i) - e * n.dot(b, y)), n.sub(o.force, o.force, g), n.add(s.force, s.force, g); var A = n.crossLength(S, g),
                    T = n.crossLength(C, g);
                o.angularForce -= A, s.angularForce += T } }, { "../math/vec2": 30, "../utils/Utils": 57, "./Spring": 34 }], 33: [function(t, e, i) {
            function o(t, e, i) { i = i || {}, n.call(this, t, e, i), this.restAngle = "number" == typeof i.restAngle ? i.restAngle : e.angle - t.angle } t("../math/vec2"); var n = t("./Spring");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.applyForce = function() { var t = this.stiffness,
                    e = this.damping,
                    i = this.restAngle,
                    o = this.bodyA,
                    n = this.bodyB,
                    s = -t * (n.angle - o.angle - i) - e * (n.angularVelocity - o.angularVelocity) * 0;
                o.angularForce -= s, n.angularForce += s } }, { "../math/vec2": 30, "./Spring": 34 }], 34: [function(t, e, i) {
            function o(t, e, i) { i = n.defaults(i, { stiffness: 100, damping: 1 }), this.stiffness = i.stiffness, this.damping = i.damping, this.bodyA = t, this.bodyB = e } t("../math/vec2"); var n = t("../utils/Utils");
            e.exports = o, o.prototype.applyForce = function() {} }, { "../math/vec2": 30, "../utils/Utils": 57 }], 35: [function(t, e, i) {
            function o(t, e) { e = e || {}, this.chassisBody = t, this.wheels = [], this.groundBody = new h({ mass: 0 }), this.world = null; var i = this;
                this.preStepCallback = function() { i.update() } }

            function n(t, e) { e = e || {}, this.vehicle = t, this.forwardEquation = new a(t.chassisBody, t.groundBody), this.sideEquation = new a(t.chassisBody, t.groundBody), this.steerValue = 0, this.engineForce = 0, this.setSideFriction(void 0 !== e.sideFriction ? e.sideFriction : 5), this.localForwardVector = s.fromValues(0, 1), e.localForwardVector && s.copy(this.localForwardVector, e.localForwardVector), this.localPosition = s.fromValues(0, 0), e.localPosition && s.copy(this.localPosition, e.localPosition), r.apply(this, t.chassisBody, t.groundBody), this.equations.push(this.forwardEquation, this.sideEquation), this.setBrakeForce(0) } var s = t("../math/vec2"),
                r = (t("../utils/Utils"), t("../constraints/Constraint")),
                a = t("../equations/FrictionEquation"),
                h = t("../objects/Body");
            e.exports = o, o.prototype.addToWorld = function(t) { this.world = t, t.addBody(this.groundBody), t.on("preStep", this.preStepCallback); for (var e = 0; e < this.wheels.length; e++) { var i = this.wheels[e];
                    t.addConstraint(i) } }, o.prototype.removeFromWorld = function() { var t = this.world;
                t.removeBody(this.groundBody), t.off("preStep", this.preStepCallback); for (var e = 0; e < this.wheels.length; e++) { var i = this.wheels[e];
                    t.removeConstraint(i) } this.world = null }, o.prototype.addWheel = function(t) { var e = new n(this, t); return this.wheels.push(e), e }, o.prototype.update = function() { for (var t = 0; t < this.wheels.length; t++) this.wheels[t].update() }, (n.prototype = new r).setBrakeForce = function(t) { this.forwardEquation.setSlipForce(t) }, n.prototype.setSideFriction = function(t) { this.sideEquation.setSlipForce(t) }; var l = s.create(),
                c = s.create();
            n.prototype.getSpeed = function() { return this.vehicle.chassisBody.vectorToWorldFrame(c, this.localForwardVector), this.vehicle.chassisBody.getVelocityAtPoint(l, c), s.dot(l, c) }; var d = s.create();
            n.prototype.update = function() { this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector), s.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2), this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t), s.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue), s.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue), this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition), s.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB), this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition), s.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA), s.normalize(d, this.forwardEquation.t), s.scale(d, d, this.engineForce), this.vehicle.chassisBody.applyForce(d, this.forwardEquation.contactPointA) } }, { "../constraints/Constraint": 14, "../equations/FrictionEquation": 23, "../math/vec2": 30, "../objects/Body": 31, "../utils/Utils": 57 }], 36: [function(t, e, i) { var o = e.exports = { AABB: t("./collision/AABB"), AngleLockEquation: t("./equations/AngleLockEquation"), Body: t("./objects/Body"), Broadphase: t("./collision/Broadphase"), Capsule: t("./shapes/Capsule"), Circle: t("./shapes/Circle"), Constraint: t("./constraints/Constraint"), ContactEquation: t("./equations/ContactEquation"), ContactEquationPool: t("./utils/ContactEquationPool"), ContactMaterial: t("./material/ContactMaterial"), Convex: t("./shapes/Convex"), DistanceConstraint: t("./constraints/DistanceConstraint"), Equation: t("./equations/Equation"), EventEmitter: t("./events/EventEmitter"), FrictionEquation: t("./equations/FrictionEquation"), FrictionEquationPool: t("./utils/FrictionEquationPool"), GearConstraint: t("./constraints/GearConstraint"), GSSolver: t("./solver/GSSolver"), Heightfield: t("./shapes/Heightfield"), Line: t("./shapes/Line"), LockConstraint: t("./constraints/LockConstraint"), Material: t("./material/Material"), Narrowphase: t("./collision/Narrowphase"), NaiveBroadphase: t("./collision/NaiveBroadphase"), Particle: t("./shapes/Particle"), Plane: t("./shapes/Plane"), Pool: t("./utils/Pool"), RevoluteConstraint: t("./constraints/RevoluteConstraint"), PrismaticConstraint: t("./constraints/PrismaticConstraint"), Ray: t("./collision/Ray"), RaycastResult: t("./collision/RaycastResult"), Box: t("./shapes/Box"), RotationalVelocityEquation: t("./equations/RotationalVelocityEquation"), SAPBroadphase: t("./collision/SAPBroadphase"), Shape: t("./shapes/Shape"), Solver: t("./solver/Solver"), Spring: t("./objects/Spring"), TopDownVehicle: t("./objects/TopDownVehicle"), LinearSpring: t("./objects/LinearSpring"), RotationalSpring: t("./objects/RotationalSpring"), Utils: t("./utils/Utils"), World: t("./world/World"), vec2: t("./math/vec2"), version: t("../package.json").version };
            Object.defineProperty(o, "Rectangle", { get: function() { return this.Box } }) }, { "../package.json": 6, "./collision/AABB": 7, "./collision/Broadphase": 8, "./collision/NaiveBroadphase": 9, "./collision/Narrowphase": 10, "./collision/Ray": 11, "./collision/RaycastResult": 12, "./collision/SAPBroadphase": 13, "./constraints/Constraint": 14, "./constraints/DistanceConstraint": 15, "./constraints/GearConstraint": 16, "./constraints/LockConstraint": 17, "./constraints/PrismaticConstraint": 18, "./constraints/RevoluteConstraint": 19, "./equations/AngleLockEquation": 20, "./equations/ContactEquation": 21, "./equations/Equation": 22, "./equations/FrictionEquation": 23, "./equations/RotationalVelocityEquation": 25, "./events/EventEmitter": 26, "./material/ContactMaterial": 27, "./material/Material": 28, "./math/vec2": 30, "./objects/Body": 31, "./objects/LinearSpring": 32, "./objects/RotationalSpring": 33, "./objects/Spring": 34, "./objects/TopDownVehicle": 35, "./shapes/Box": 37, "./shapes/Capsule": 38, "./shapes/Circle": 39, "./shapes/Convex": 40, "./shapes/Heightfield": 41, "./shapes/Line": 42, "./shapes/Particle": 43, "./shapes/Plane": 44, "./shapes/Shape": 45, "./solver/GSSolver": 46, "./solver/Solver": 47, "./utils/ContactEquationPool": 48, "./utils/FrictionEquationPool": 49, "./utils/Pool": 55, "./utils/Utils": 57, "./world/World": 61 }], 37: [function(t, e, i) {
            function o(t) { "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = { width: arguments[0], height: arguments[1] }), t = t || {}; var e = this.width = t.width || 1,
                    i = this.height = t.height || 1,
                    o = [n.fromValues(-e / 2, -i / 2), n.fromValues(e / 2, -i / 2), n.fromValues(e / 2, i / 2), n.fromValues(-e / 2, i / 2)],
                    a = [n.fromValues(1, 0), n.fromValues(0, 1)];
                t.vertices = o, t.axes = a, t.type = s.BOX, r.call(this, t) } var n = t("../math/vec2"),
                s = t("./Shape"),
                r = t("./Convex");
            e.exports = o, (o.prototype = new r).constructor = o, o.prototype.computeMomentOfInertia = function(t) { var e = this.width,
                    i = this.height; return t * (i * i + e * e) / 12 }, o.prototype.updateBoundingRadius = function() { var t = this.width,
                    e = this.height;
                this.boundingRadius = Math.sqrt(t * t + e * e) / 2 };
            n.create(), n.create(), n.create(), n.create();
            o.prototype.computeAABB = function(t, e, i) { t.setFromPoints(this.vertices, e, i, 0) }, o.prototype.updateArea = function() { this.area = this.width * this.height } }, { "../math/vec2": 30, "./Convex": 40, "./Shape": 45 }], 38: [function(t, e, i) {
            function o(t) { "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = { length: arguments[0], radius: arguments[1] }), t = t || {}, this.length = t.length || 1, this.radius = t.radius || 1, t.type = n.CAPSULE, n.call(this, t) } var n = t("./Shape"),
                s = t("../math/vec2");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.computeMomentOfInertia = function(t) { var e = this.radius,
                    i = this.length + e,
                    o = 2 * e; return t * (o * o + i * i) / 12 }, o.prototype.updateBoundingRadius = function() { this.boundingRadius = this.radius + this.length / 2 }, o.prototype.updateArea = function() { this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length }; var r = s.create();
            o.prototype.computeAABB = function(t, e, i) { var o = this.radius;
                s.set(r, this.length / 2, 0), 0 !== i && s.rotate(r, r, i), s.set(t.upperBound, Math.max(r[0] + o, -r[0] + o), Math.max(r[1] + o, -r[1] + o)), s.set(t.lowerBound, Math.min(r[0] - o, -r[0] - o), Math.min(r[1] - o, -r[1] - o)), s.add(t.lowerBound, t.lowerBound, e), s.add(t.upperBound, t.upperBound, e) }; var a = s.create(),
                h = s.create(),
                l = s.create(),
                c = s.create(),
                d = s.fromValues(0, 1);
            o.prototype.raycast = function(t, e, i, o) { for (var n = e.from, r = e.to, u = (e.direction, a), p = h, m = l, f = c, y = this.length / 2, b = 0; b < 2; b++) { var g = this.radius * (2 * b - 1); if (s.set(m, -y, g), s.set(f, y, g), s.toGlobalFrame(m, m, i, o), s.toGlobalFrame(f, f, i, o), (C = s.getLineSegmentsIntersectionFraction(n, r, m, f)) >= 0 && (s.rotate(p, d, o), s.scale(p, p, 2 * b - 1), e.reportIntersection(t, C, p, -1), t.shouldStop(e))) return } for (var _ = Math.pow(this.radius, 2) + Math.pow(y, 2), b = 0; b < 2; b++) { s.set(m, y * (2 * b - 1), 0), s.toGlobalFrame(m, m, i, o); var v = Math.pow(r[0] - n[0], 2) + Math.pow(r[1] - n[1], 2),
                        x = 2 * ((r[0] - n[0]) * (n[0] - m[0]) + (r[1] - n[1]) * (n[1] - m[1])),
                        S = Math.pow(n[0] - m[0], 2) + Math.pow(n[1] - m[1], 2) - Math.pow(this.radius, 2),
                        C = Math.pow(x, 2) - 4 * v * S; if (!(C < 0))
                        if (0 === C) { if (s.lerp(u, n, r, C), s.squaredDistance(u, i) > _ && (s.sub(p, u, m), s.normalize(p, p), e.reportIntersection(t, C, p, -1), t.shouldStop(e))) return } else { var w = Math.sqrt(C),
                                A = 1 / (2 * v),
                                T = (-x - w) * A,
                                P = (-x + w) * A; if (T >= 0 && T <= 1 && (s.lerp(u, n, r, T), s.squaredDistance(u, i) > _ && (s.sub(p, u, m), s.normalize(p, p), e.reportIntersection(t, T, p, -1), t.shouldStop(e)))) return; if (P >= 0 && P <= 1 && (s.lerp(u, n, r, P), s.squaredDistance(u, i) > _ && (s.sub(p, u, m), s.normalize(p, p), e.reportIntersection(t, P, p, -1), t.shouldStop(e)))) return } } } }, { "../math/vec2": 30, "./Shape": 45 }], 39: [function(t, e, i) {
            function o(t) { "number" == typeof arguments[0] && (t = { radius: arguments[0] }), t = t || {}, this.radius = t.radius || 1, t.type = n.CIRCLE, n.call(this, t) } var n = t("./Shape"),
                s = t("../math/vec2");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.computeMomentOfInertia = function(t) { var e = this.radius; return t * e * e / 2 }, o.prototype.updateBoundingRadius = function() { this.boundingRadius = this.radius }, o.prototype.updateArea = function() { this.area = Math.PI * this.radius * this.radius }, o.prototype.computeAABB = function(t, e, i) { var o = this.radius;
                s.set(t.upperBound, o, o), s.set(t.lowerBound, -o, -o), e && (s.add(t.lowerBound, t.lowerBound, e), s.add(t.upperBound, t.upperBound, e)) }; var r = s.create(),
                a = s.create();
            o.prototype.raycast = function(t, e, i, o) { var n = e.from,
                    h = e.to,
                    l = this.radius,
                    c = Math.pow(h[0] - n[0], 2) + Math.pow(h[1] - n[1], 2),
                    d = 2 * ((h[0] - n[0]) * (n[0] - i[0]) + (h[1] - n[1]) * (n[1] - i[1])),
                    u = Math.pow(n[0] - i[0], 2) + Math.pow(n[1] - i[1], 2) - Math.pow(l, 2),
                    p = Math.pow(d, 2) - 4 * c * u,
                    m = r,
                    f = a; if (!(p < 0))
                    if (0 === p) s.lerp(m, n, h, p), s.sub(f, m, i), s.normalize(f, f), e.reportIntersection(t, p, f, -1);
                    else { var y = Math.sqrt(p),
                            b = 1 / (2 * c),
                            g = (-d - y) * b,
                            _ = (-d + y) * b; if (g >= 0 && g <= 1 && (s.lerp(m, n, h, g), s.sub(f, m, i), s.normalize(f, f), e.reportIntersection(t, g, f, -1), t.shouldStop(e))) return;
                        _ >= 0 && _ <= 1 && (s.lerp(m, n, h, _), s.sub(f, m, i), s.normalize(f, f), e.reportIntersection(t, _, f, -1)) } } }, { "../math/vec2": 30, "./Shape": 45 }], 40: [function(t, e, i) {
            function o(t) { Array.isArray(arguments[0]) && (t = { vertices: arguments[0], axes: arguments[1] }), t = t || {}, this.vertices = []; for (var e = void 0 !== t.vertices ? t.vertices : [], i = 0; i < e.length; i++) { var o = s.create();
                    s.copy(o, e[i]), this.vertices.push(o) } if (this.axes = [], t.axes)
                    for (i = 0; i < t.axes.length; i++) { var r = s.create();
                        s.copy(r, t.axes[i]), this.axes.push(r) } else
                        for (i = 0; i < this.vertices.length; i++) { var a = this.vertices[i],
                                h = this.vertices[(i + 1) % this.vertices.length],
                                l = s.create();
                            s.sub(l, h, a), s.rotate90cw(l, l), s.normalize(l, l), this.axes.push(l) }
                if (this.centerOfMass = s.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()), this.boundingRadius = 0, t.type = n.CONVEX, n.call(this, t), this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.") } var n = t("./Shape"),
                s = t("../math/vec2"),
                r = t("../math/polyk");
            t("poly-decomp");
            e.exports = o, (o.prototype = new n).constructor = o; var a = s.create(),
                h = s.create();
            o.prototype.projectOntoLocalAxis = function(t, e) { for (var i, o, n = null, r = null, t = a, h = 0; h < this.vertices.length; h++) i = this.vertices[h], o = s.dot(i, t), (null === n || o > n) && (n = o), (null === r || o < r) && (r = o); if (r > n) { var l = r;
                    r = n, n = l } s.set(e, r, n) }, o.prototype.projectOntoWorldAxis = function(t, e, i, o) { var n = h;
                this.projectOntoLocalAxis(t, o), 0 !== i ? s.rotate(n, t, i) : n = t; var r = s.dot(e, n);
                s.set(o, o[0] + r, o[1] + r) }, o.prototype.updateTriangles = function() { this.triangles.length = 0; for (var t = [], e = 0; e < this.vertices.length; e++) { var i = this.vertices[e];
                    t.push(i[0], i[1]) } for (var o = r.Triangulate(t), e = 0; e < o.length; e += 3) { var n = o[e],
                        s = o[e + 1],
                        a = o[e + 2];
                    this.triangles.push([n, s, a]) } }; var l = s.create(),
                c = s.create(),
                d = s.create(),
                u = s.create(),
                p = s.create();
            s.create(), s.create(), s.create(), s.create();
            o.prototype.updateCenterOfMass = function() { var t = this.triangles,
                    e = this.vertices,
                    i = this.centerOfMass,
                    n = l,
                    r = d,
                    a = u,
                    h = p,
                    m = c;
                s.set(i, 0, 0); for (var f = 0, y = 0; y !== t.length; y++) { var b = t[y],
                        r = e[b[0]],
                        a = e[b[1]],
                        h = e[b[2]];
                    s.centroid(n, r, a, h); var g = o.triangleArea(r, a, h);
                    f += g, s.scale(m, n, g), s.add(i, i, m) } s.scale(i, i, 1 / f) }, o.prototype.computeMomentOfInertia = function(t) { for (var e = 0, i = 0, o = this.vertices.length, n = o - 1, r = 0; r < o; n = r, r++) { var a = this.vertices[n],
                        h = this.vertices[r],
                        l = Math.abs(s.crossLength(a, h));
                    e += l * (s.dot(h, h) + s.dot(h, a) + s.dot(a, a)), i += l } return t / 6 * (e / i) }, o.prototype.updateBoundingRadius = function() { for (var t = this.vertices, e = 0, i = 0; i !== t.length; i++) { var o = s.squaredLength(t[i]);
                    o > e && (e = o) } this.boundingRadius = Math.sqrt(e) }, o.triangleArea = function(t, e, i) { return .5 * ((e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1])) }, o.prototype.updateArea = function() { this.updateTriangles(), this.area = 0; for (var t = this.triangles, e = this.vertices, i = 0; i !== t.length; i++) { var n = t[i],
                        s = e[n[0]],
                        r = e[n[1]],
                        a = e[n[2]],
                        h = o.triangleArea(s, r, a);
                    this.area += h } }, o.prototype.computeAABB = function(t, e, i) { t.setFromPoints(this.vertices, e, i, 0) }; var m = s.create(),
                f = s.create(),
                y = s.create();
            o.prototype.raycast = function(t, e, i, o) { var n = m,
                    r = f,
                    a = y,
                    h = this.vertices;
                s.toLocalFrame(n, e.from, i, o), s.toLocalFrame(r, e.to, i, o); for (var l = h.length, c = 0; c < l && !t.shouldStop(e); c++) { var d = h[c],
                        u = h[(c + 1) % l],
                        p = s.getLineSegmentsIntersectionFraction(n, r, d, u);
                    p >= 0 && (s.sub(a, u, d), s.rotate(a, a, -Math.PI / 2 + o), s.normalize(a, a), e.reportIntersection(t, p, a, c)) } } }, { "../math/polyk": 29, "../math/vec2": 30, "./Shape": 45, "poly-decomp": 5 }], 41: [function(t, e, i) {
            function o(t) { if (Array.isArray(arguments[0]) && (t = { heights: arguments[0] }, "object" == typeof arguments[1]))
                    for (var e in arguments[1]) t[e] = arguments[1][e];
                t = t || {}, this.heights = t.heights ? t.heights.slice(0) : [], this.maxValue = t.maxValue || null, this.minValue = t.minValue || null, this.elementWidth = t.elementWidth || .1, void 0 !== t.maxValue && void 0 !== t.minValue || this.updateMaxMinValues(), t.type = n.HEIGHTFIELD, n.call(this, t) } var n = t("./Shape"),
                s = t("../math/vec2");
            t("../utils/Utils");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.updateMaxMinValues = function() { for (var t = this.heights, e = t[0], i = t[0], o = 0; o !== t.length; o++) { var n = t[o];
                    n > e && (e = n), n < i && (i = n) } this.maxValue = e, this.minValue = i }, o.prototype.computeMomentOfInertia = function(t) { return Number.MAX_VALUE }, o.prototype.updateBoundingRadius = function() { this.boundingRadius = Number.MAX_VALUE }, o.prototype.updateArea = function() { for (var t = this.heights, e = 0, i = 0; i < t.length - 1; i++) e += (t[i] + t[i + 1]) / 2 * this.elementWidth;
                this.area = e }; var r = [s.create(), s.create(), s.create(), s.create()];
            o.prototype.computeAABB = function(t, e, i) { s.set(r[0], 0, this.maxValue), s.set(r[1], this.elementWidth * this.heights.length, this.maxValue), s.set(r[2], this.elementWidth * this.heights.length, this.minValue), s.set(r[3], 0, this.minValue), t.setFromPoints(r, e, i) }, o.prototype.getLineSegment = function(t, e, i) { var o = this.heights,
                    n = this.elementWidth;
                s.set(t, i * n, o[i]), s.set(e, (i + 1) * n, o[i + 1]) }, o.prototype.getSegmentIndex = function(t) { return Math.floor(t[0] / this.elementWidth) }, o.prototype.getClampedSegmentIndex = function(t) { var e = this.getSegmentIndex(t); return e = Math.min(this.heights.length, Math.max(e, 0)) };
            s.create(); var a = s.create(),
                h = s.create(),
                l = s.create(),
                c = s.create(),
                d = s.create();
            s.fromValues(0, 1);
            o.prototype.raycast = function(t, e, i, o) { var n = e.from,
                    r = e.to,
                    u = (e.direction, a),
                    p = h,
                    m = l,
                    f = c,
                    y = d;
                s.toLocalFrame(f, n, i, o), s.toLocalFrame(y, r, i, o); var b = this.getClampedSegmentIndex(f),
                    g = this.getClampedSegmentIndex(y); if (b > g) { var _ = b;
                    b = g, g = _ } for (var v = 0; v < this.heights.length - 1; v++) { this.getLineSegment(p, m, v); var x = s.getLineSegmentsIntersectionFraction(f, y, p, m); if (x >= 0 && (s.sub(u, m, p), s.rotate(u, u, o + Math.PI / 2), s.normalize(u, u), e.reportIntersection(t, x, u, -1), t.shouldStop(e))) return } } }, { "../math/vec2": 30, "../utils/Utils": 57, "./Shape": 45 }], 42: [function(t, e, i) {
            function o(t) { "number" == typeof arguments[0] && (t = { length: arguments[0] }), t = t || {}, this.length = t.length || 1, t.type = n.LINE, n.call(this, t) } var n = t("./Shape"),
                s = t("../math/vec2");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.computeMomentOfInertia = function(t) { return t * Math.pow(this.length, 2) / 12 }, o.prototype.updateBoundingRadius = function() { this.boundingRadius = this.length / 2 }; var r = [s.create(), s.create()];
            o.prototype.computeAABB = function(t, e, i) { var o = this.length / 2;
                s.set(r[0], -o, 0), s.set(r[1], o, 0), t.setFromPoints(r, e, i, 0) };
            s.create(); var a = s.create(),
                h = s.create(),
                l = s.create(),
                c = s.fromValues(0, 1);
            o.prototype.raycast = function(t, e, i, o) { var n = e.from,
                    r = e.to,
                    d = h,
                    u = l,
                    p = this.length / 2;
                s.set(d, -p, 0), s.set(u, p, 0), s.toGlobalFrame(d, d, i, o), s.toGlobalFrame(u, u, i, o); var m = s.getLineSegmentsIntersectionFraction(d, u, n, r); if (m >= 0) { var f = a;
                    s.rotate(f, c, o), e.reportIntersection(t, m, f, -1) } } }, { "../math/vec2": 30, "./Shape": 45 }], 43: [function(t, e, i) {
            function o(t) {
                (t = t || {}).type = n.PARTICLE, n.call(this, t) } var n = t("./Shape"),
                s = t("../math/vec2");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.computeMomentOfInertia = function(t) { return 0 }, o.prototype.updateBoundingRadius = function() { this.boundingRadius = 0 }, o.prototype.computeAABB = function(t, e, i) { s.copy(t.lowerBound, e), s.copy(t.upperBound, e) } }, { "../math/vec2": 30, "./Shape": 45 }], 44: [function(t, e, i) {
            function o(t) {
                (t = t || {}).type = n.PLANE, n.call(this, t) } var n = t("./Shape"),
                s = t("../math/vec2");
            t("../utils/Utils");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.computeMomentOfInertia = function(t) { return 0 }, o.prototype.updateBoundingRadius = function() { this.boundingRadius = Number.MAX_VALUE }, o.prototype.computeAABB = function(t, e, i) { var o = i % (2 * Math.PI),
                    n = s.set,
                    r = Number.MAX_VALUE,
                    a = t.lowerBound,
                    h = t.upperBound;
                0 === o ? (n(a, -r, -r), n(h, r, 0)) : o === Math.PI / 2 ? (n(a, 0, -r), n(h, r, r)) : o === Math.PI ? (n(a, -r, 0), n(h, r, r)) : o === 3 * Math.PI / 2 ? (n(a, -r, -r), n(h, 0, r)) : (n(a, -r, -r), n(h, r, r)), s.add(a, a, e), s.add(h, h, e) }, o.prototype.updateArea = function() { this.area = Number.MAX_VALUE }; var r = s.create(),
                a = (s.create(), s.create(), s.create()),
                h = s.create();
            o.prototype.raycast = function(t, e, i, o) { var n = e.from,
                    l = e.to,
                    c = e.direction,
                    d = r,
                    u = a,
                    p = h;
                s.set(u, 0, 1), s.rotate(u, u, o), s.sub(p, n, i); var m = s.dot(p, u); if (s.sub(p, l, i), !(m * s.dot(p, u) > 0 || s.squaredDistance(n, l) < m * m)) { var f = s.dot(u, c);
                    s.sub(d, n, i); var y = -s.dot(u, d) / f / e.length;
                    e.reportIntersection(t, y, u, -1) } } }, { "../math/vec2": 30, "../utils/Utils": 57, "./Shape": 45 }], 45: [function(t, e, i) {
            function o(t) { t = t || {}, this.body = null, this.position = n.fromValues(0, 0), t.position && n.copy(this.position, t.position), this.angle = t.angle || 0, this.type = t.type || 0, this.id = o.idCounter++, this.boundingRadius = 0, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : 1, this.material = t.material || null, this.area = 0, this.sensor = void 0 !== t.sensor && t.sensor, this.type && this.updateBoundingRadius(), this.updateArea() } e.exports = o; var n = t("../math/vec2");
            o.idCounter = 0, o.CIRCLE = 1, o.PARTICLE = 2, o.PLANE = 4, o.CONVEX = 8, o.LINE = 16, o.BOX = 32, Object.defineProperty(o, "RECTANGLE", { get: function() { return o.BOX } }), o.CAPSULE = 64, o.HEIGHTFIELD = 128, o.prototype.computeMomentOfInertia = function(t) {}, o.prototype.updateBoundingRadius = function() {}, o.prototype.updateArea = function() {}, o.prototype.computeAABB = function(t, e, i) {}, o.prototype.raycast = function(t, e, i, o) {} }, { "../math/vec2": 30 }], 46: [function(t, e, i) {
            function o(t) { r.call(this, t, r.GS), t = t || {}, this.iterations = t.iterations || 10, this.tolerance = t.tolerance || 1e-7, this.arrayStep = 30, this.lambda = new a.ARRAY_TYPE(this.arrayStep), this.Bs = new a.ARRAY_TYPE(this.arrayStep), this.invCs = new a.ARRAY_TYPE(this.arrayStep), this.useZeroRHS = !1, this.frictionIterations = 0, this.usedIterations = 0 }

            function n(t) { for (var e = t.length; e--;) t[e] = 0 } var s = t("../math/vec2"),
                r = t("./Solver"),
                a = t("../utils/Utils"),
                h = t("../equations/FrictionEquation");
            e.exports = o, (o.prototype = new r).constructor = o, o.prototype.solve = function(t, e) { this.sortEquations(); var i = 0,
                    r = this.iterations,
                    l = this.frictionIterations,
                    c = this.equations,
                    d = c.length,
                    u = Math.pow(this.tolerance * d, 2),
                    p = e.bodies,
                    m = e.bodies.length,
                    f = (s.add, s.set, this.useZeroRHS),
                    y = this.lambda; if (this.usedIterations = 0, d)
                    for (_ = 0; _ !== m; _++)(C = p[_]).updateSolveMassProperties();
                y.length < d && (y = this.lambda = new a.ARRAY_TYPE(d + this.arrayStep), this.Bs = new a.ARRAY_TYPE(d + this.arrayStep), this.invCs = new a.ARRAY_TYPE(d + this.arrayStep)), n(y); for (var b = this.invCs, g = this.Bs, y = this.lambda, _ = 0; _ !== c.length; _++)((v = c[_]).timeStep !== t || v.needsUpdate) && (v.timeStep = t, v.update()), g[_] = v.computeB(v.a, v.b, t), b[_] = v.computeInvC(v.epsilon); var v, x, S; if (0 !== d) { for (_ = 0; _ !== m; _++) { var C = p[_];
                        C.resetConstraintVelocity() } if (l) { for (i = 0; i !== l; i++) { for (x = 0, S = 0; S !== d; S++) { v = c[S];
                                P = o.iterateEquation(S, v, v.epsilon, g, b, y, f, t, i);
                                x += Math.abs(P) } if (this.usedIterations++, x * x <= u) break } for (o.updateMultipliers(c, y, 1 / t), S = 0; S !== d; S++) { var w = c[S]; if (w instanceof h) { for (var A = 0, T = 0; T !== w.contactEquations.length; T++) A += w.contactEquations[T].multiplier;
                                A *= w.frictionCoefficient / w.contactEquations.length, w.maxForce = A, w.minForce = -A } } } for (i = 0; i !== r; i++) { for (x = 0, S = 0; S !== d; S++) { v = c[S]; var P = o.iterateEquation(S, v, v.epsilon, g, b, y, f, t, i);
                            x += Math.abs(P) } if (this.usedIterations++, x * x <= u) break } for (_ = 0; _ !== m; _++) p[_].addConstraintVelocity();
                    o.updateMultipliers(c, y, 1 / t) } }, o.updateMultipliers = function(t, e, i) { for (var o = t.length; o--;) t[o].multiplier = e[o] * i }, o.iterateEquation = function(t, e, i, o, n, s, r, a, h) { var l = o[t],
                    c = n[t],
                    d = s[t],
                    u = e.computeGWlambda(),
                    p = e.maxForce,
                    m = e.minForce;
                r && (l = 0); var f = c * (l - u - i * d),
                    y = d + f; return y < m * a ? f = m * a - d : y > p * a && (f = p * a - d), s[t] += f, e.addToWlambda(f), f } }, { "../equations/FrictionEquation": 23, "../math/vec2": 30, "../utils/Utils": 57, "./Solver": 47 }], 47: [function(t, e, i) {
            function o(t, e) { t = t || {}, n.call(this), this.type = e, this.equations = [], this.equationSortFunction = t.equationSortFunction || !1 } t("../utils/Utils"); var n = t("../events/EventEmitter");
            e.exports = o, (o.prototype = new n).constructor = o, o.prototype.solve = function(t, e) { throw new Error("Solver.solve should be implemented by subclasses!") }; var s = { bodies: [] };
            o.prototype.solveIsland = function(t, e) { this.removeAllEquations(), e.equations.length && (this.addEquations(e.equations), s.bodies.length = 0, e.getBodies(s.bodies), s.bodies.length && this.solve(t, s)) }, o.prototype.sortEquations = function() { this.equationSortFunction && this.equations.sort(this.equationSortFunction) }, o.prototype.addEquation = function(t) { t.enabled && this.equations.push(t) }, o.prototype.addEquations = function(t) { for (var e = 0, i = t.length; e !== i; e++) { var o = t[e];
                    o.enabled && this.equations.push(o) } }, o.prototype.removeEquation = function(t) { var e = this.equations.indexOf(t); - 1 !== e && this.equations.splice(e, 1) }, o.prototype.removeAllEquations = function() { this.equations.length = 0 }, o.GS = 1, o.ISLAND = 2 }, { "../events/EventEmitter": 26, "../utils/Utils": 57 }], 48: [function(t, e, i) {
            function o() { s.apply(this, arguments) } var n = t("../equations/ContactEquation"),
                s = t("./Pool");
            e.exports = o, (o.prototype = new s).constructor = o, o.prototype.create = function() { return new n }, o.prototype.destroy = function(t) { return t.bodyA = t.bodyB = null, this } }, { "../equations/ContactEquation": 21, "./Pool": 55 }], 49: [function(t, e, i) {
            function o() { s.apply(this, arguments) } var n = t("../equations/FrictionEquation"),
                s = t("./Pool");
            e.exports = o, (o.prototype = new s).constructor = o, o.prototype.create = function() { return new n }, o.prototype.destroy = function(t) { return t.bodyA = t.bodyB = null, this } }, { "../equations/FrictionEquation": 23, "./Pool": 55 }], 50: [function(t, e, i) {
            function o() { s.apply(this, arguments) } var n = t("../world/IslandNode"),
                s = t("./Pool");
            e.exports = o, (o.prototype = new s).constructor = o, o.prototype.create = function() { return new n }, o.prototype.destroy = function(t) { return t.reset(), this } }, { "../world/IslandNode": 60, "./Pool": 55 }], 51: [function(t, e, i) {
            function o() { s.apply(this, arguments) } var n = t("../world/Island"),
                s = t("./Pool");
            e.exports = o, (o.prototype = new s).constructor = o, o.prototype.create = function() { return new n }, o.prototype.destroy = function(t) { return t.reset(), this } }, { "../world/Island": 58, "./Pool": 55 }], 52: [function(t, e, i) {
            function o() { this.overlappingShapesLastState = new n, this.overlappingShapesCurrentState = new n, this.recordPool = new s({ size: 16 }), this.tmpDict = new n, this.tmpArray1 = [] } var n = t("./TupleDictionary"),
                s = (t("./OverlapKeeperRecord"), t("./OverlapKeeperRecordPool"));
            t("./Utils");
            e.exports = o, o.prototype.tick = function() { for (var t = this.overlappingShapesLastState, e = this.overlappingShapesCurrentState, i = t.keys.length; i--;) { var o = t.keys[i],
                        n = t.getByKey(o);
                    e.getByKey(o);
                    n && this.recordPool.release(n) } t.reset(), t.copy(e), e.reset() }, o.prototype.setOverlapping = function(t, e, i, o) { this.overlappingShapesLastState; var n = this.overlappingShapesCurrentState; if (!n.get(e.id, o.id)) { var s = this.recordPool.get();
                    s.set(t, e, i, o), n.set(e.id, o.id, s) } }, o.prototype.getNewOverlaps = function(t) { return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, t) }, o.prototype.getEndOverlaps = function(t) { return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, t) }, o.prototype.bodiesAreOverlapping = function(t, e) { for (var i = this.overlappingShapesCurrentState, o = i.keys.length; o--;) { var n = i.keys[o],
                        s = i.data[n]; if (s.bodyA === t && s.bodyB === e || s.bodyA === e && s.bodyB === t) return !0 } return !1 }, o.prototype.getDiff = function(t, e, i) { var o = t,
                    n = e;
                (i = i || []).length = 0; for (var s = n.keys.length; s--;) { var r = n.keys[s],
                        a = n.data[r]; if (!a) throw new Error("Key " + r + " had no data!");
                    o.data[r] || i.push(a) } return i }, o.prototype.isNewOverlap = function(t, e) { var i = 0 | t.id,
                    o = 0 | e.id,
                    n = this.overlappingShapesLastState,
                    s = this.overlappingShapesCurrentState; return !n.get(i, o) && !!s.get(i, o) }, o.prototype.getNewBodyOverlaps = function(t) { this.tmpArray1.length = 0; var e = this.getNewOverlaps(this.tmpArray1); return this.getBodyDiff(e, t) }, o.prototype.getEndBodyOverlaps = function(t) { this.tmpArray1.length = 0; var e = this.getEndOverlaps(this.tmpArray1); return this.getBodyDiff(e, t) }, o.prototype.getBodyDiff = function(t, e) { e = e || []; for (var i = this.tmpDict, o = t.length; o--;) { var n = t[o];
                    i.set(0 | n.bodyA.id, 0 | n.bodyB.id, n) } for (o = i.keys.length; o--;)(n = i.getByKey(i.keys[o])) && e.push(n.bodyA, n.bodyB); return i.reset(), e } }, { "./OverlapKeeperRecord": 53, "./OverlapKeeperRecordPool": 54, "./TupleDictionary": 56, "./Utils": 57 }], 53: [function(t, e, i) {
            function o(t, e, i, o) { this.shapeA = e, this.shapeB = o, this.bodyA = t, this.bodyB = i } e.exports = o, o.prototype.set = function(t, e, i, n) { o.call(this, t, e, i, n) } }, {}], 54: [function(t, e, i) {
            function o() { s.apply(this, arguments) } var n = t("./OverlapKeeperRecord"),
                s = t("./Pool");
            e.exports = o, (o.prototype = new s).constructor = o, o.prototype.create = function() { return new n }, o.prototype.destroy = function(t) { return t.bodyA = t.bodyB = t.shapeA = t.shapeB = null, this } }, { "./OverlapKeeperRecord": 53, "./Pool": 55 }], 55: [function(t, e, i) {
            function o(t) { t = t || {}, this.objects = [], void 0 !== t.size && this.resize(t.size) } e.exports = o, o.prototype.resize = function(t) { for (var e = this.objects; e.length > t;) e.pop(); for (; e.length < t;) e.push(this.create()); return this }, o.prototype.get = function() { var t = this.objects; return t.length ? t.pop() : this.create() }, o.prototype.release = function(t) { return this.destroy(t), this.objects.push(t), this } }, {}], 56: [function(t, e, i) {
            function o() { this.data = {}, this.keys = [] } var n = t("./Utils");
            e.exports = o, o.prototype.getKey = function(t, e) { return t |= 0, e |= 0, (0 | t) == (0 | e) ? -1 : 0 | ((0 | t) > (0 | e) ? t << 16 | 65535 & e : e << 16 | 65535 & t) }, o.prototype.getByKey = function(t) { return t |= 0, this.data[t] }, o.prototype.get = function(t, e) { return this.data[this.getKey(t, e)] }, o.prototype.set = function(t, e, i) { if (!i) throw new Error("No data!"); var o = this.getKey(t, e); return this.data[o] || this.keys.push(o), this.data[o] = i, o }, o.prototype.reset = function() { for (var t = this.data, e = this.keys, i = e.length; i--;) delete t[e[i]];
                e.length = 0 }, o.prototype.copy = function(t) { this.reset(), n.appendArray(this.keys, t.keys); for (var e = t.keys.length; e--;) { var i = t.keys[e];
                    this.data[i] = t.data[i] } } }, { "./Utils": 57 }], 57: [function(t, e, i) {
            function o() {} e.exports = o, o.appendArray = function(t, e) { if (e.length < 15e4) t.push.apply(t, e);
                else
                    for (var i = 0, o = e.length; i !== o; ++i) t.push(e[i]) }, o.splice = function(t, e, i) { i = i || 1; for (var o = e, n = t.length - i; o < n; o++) t[o] = t[o + i];
                t.length = n }, o.ARRAY_TYPE = "undefined" != typeof P2_ARRAY_TYPE ? P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? Float32Array : Array, o.extend = function(t, e) { for (var i in e) t[i] = e[i] }, o.defaults = function(t, e) { t = t || {}; for (var i in e) i in t || (t[i] = e[i]); return t } }, {}], 58: [function(t, e, i) {
            function o() { this.equations = [], this.bodies = [] } var n = t("../objects/Body");
            e.exports = o, o.prototype.reset = function() { this.equations.length = this.bodies.length = 0 }; var s = [];
            o.prototype.getBodies = function(t) { var e = t || [],
                    i = this.equations;
                s.length = 0; for (var o = 0; o !== i.length; o++) { var n = i[o]; - 1 === s.indexOf(n.bodyA.id) && (e.push(n.bodyA), s.push(n.bodyA.id)), -1 === s.indexOf(n.bodyB.id) && (e.push(n.bodyB), s.push(n.bodyB.id)) } return e }, o.prototype.wantsToSleep = function() { for (var t = 0; t < this.bodies.length; t++) { var e = this.bodies[t]; if (e.type === n.DYNAMIC && !e.wantsToSleep) return !1 } return !0 }, o.prototype.sleep = function() { for (var t = 0; t < this.bodies.length; t++) this.bodies[t].sleep(); return !0 } }, { "../objects/Body": 31 }], 59: [function(t, e, i) {
            function o(t) { this.nodePool = new n({ size: 16 }), this.islandPool = new s({ size: 8 }), this.equations = [], this.islands = [], this.nodes = [], this.queue = [] } t("../math/vec2"), t("./Island"), t("./IslandNode"); var n = t("./../utils/IslandNodePool"),
                s = t("./../utils/IslandPool"),
                r = t("../objects/Body");
            e.exports = o, o.getUnvisitedNode = function(t) { for (var e = t.length, i = 0; i !== e; i++) { var o = t[i]; if (!o.visited && o.body.type === r.DYNAMIC) return o } return !1 }, o.prototype.visit = function(t, e, i) { e.push(t.body); for (var o = t.equations.length, n = 0; n !== o; n++) { var s = t.equations[n]; - 1 === i.indexOf(s) && i.push(s) } }, o.prototype.bfs = function(t, e, i) { var n = this.queue; for (n.length = 0, n.push(t), t.visited = !0, this.visit(t, e, i); n.length;)
                    for (var s, a = n.pop(); s = o.getUnvisitedNode(a.neighbors);) s.visited = !0, this.visit(s, e, i), s.body.type === r.DYNAMIC && n.push(s) }, o.prototype.split = function(t) { for (var e = t.bodies, i = this.nodes, n = this.equations; i.length;) this.nodePool.release(i.pop()); for (h = 0; h !== e.length; h++) { var s = this.nodePool.get();
                    s.body = e[h], i.push(s) } for (var r = 0; r !== n.length; r++) { var a = n[r],
                        h = e.indexOf(a.bodyA),
                        l = e.indexOf(a.bodyB),
                        c = i[h],
                        d = i[l];
                    c.neighbors.push(d), d.neighbors.push(c), c.equations.push(a), d.equations.push(a) } for (var u = this.islands, h = 0; h < u.length; h++) this.islandPool.release(u[h]);
                u.length = 0; for (var p; p = o.getUnvisitedNode(i);) { var m = this.islandPool.get();
                    this.bfs(p, m.bodies, m.equations), u.push(m) } return u } }, { "../math/vec2": 30, "../objects/Body": 31, "./../utils/IslandNodePool": 50, "./../utils/IslandPool": 51, "./Island": 58, "./IslandNode": 60 }], 60: [function(t, e, i) {
            function o(t) { this.body = t, this.neighbors = [], this.equations = [], this.visited = !1 } e.exports = o, o.prototype.reset = function() { this.equations.length = 0, this.neighbors.length = 0, this.visited = !1, this.body = null } }, {}], 61: [function(t, e, i) {
            function o(t) { d.apply(this), t = t || {}, this.springs = [], this.bodies = [], this.disabledBodyCollisionPairs = [], this.solver = t.solver || new n, this.narrowphase = new b(this), this.islandManager = new v, this.gravity = s.fromValues(0, -9.78), t.gravity && s.copy(this.gravity, t.gravity), this.frictionGravity = s.length(this.gravity) || 10, this.useWorldGravityAsFrictionGravity = !0, this.useFrictionGravityOnZeroGravity = !0, this.broadphase = t.broadphase || new y, this.broadphase.setWorld(this), this.constraints = [], this.defaultMaterial = new p, this.defaultContactMaterial = new m(this.defaultMaterial, this.defaultMaterial), this.lastTimeStep = 1 / 60, this.applySpringForces = !0, this.applyDamping = !0, this.applyGravity = !0, this.solveConstraints = !0, this.contactMaterials = [], this.time = 0, this.accumulator = 0, this.stepping = !1, this.bodiesToBeRemoved = [], this.islandSplit = void 0 === t.islandSplit || !!t.islandSplit, this.emitImpactEvent = !0, this._constraintIdCounter = 0, this._bodyIdCounter = 0, this.postStepEvent = { type: "postStep" }, this.addBodyEvent = { type: "addBody", body: null }, this.removeBodyEvent = { type: "removeBody", body: null }, this.addSpringEvent = { type: "addSpring", spring: null }, this.impactEvent = { type: "impact", bodyA: null, bodyB: null, shapeA: null, shapeB: null, contactEquation: null }, this.postBroadphaseEvent = { type: "postBroadphase", pairs: null }, this.sleepMode = o.NO_SLEEPING, this.beginContactEvent = { type: "beginContact", shapeA: null, shapeB: null, bodyA: null, bodyB: null, contactEquations: [] }, this.endContactEvent = { type: "endContact", shapeA: null, shapeB: null, bodyA: null, bodyB: null }, this.preSolveEvent = { type: "preSolve", contactEquations: null, frictionEquations: null }, this.overlappingShapesLastState = { keys: [] }, this.overlappingShapesCurrentState = { keys: [] }, this.overlapKeeper = new _ } var n = t("../solver/GSSolver"),
                s = (t("../solver/Solver"), t("../collision/Ray"), t("../math/vec2")),
                r = t("../shapes/Circle"),
                a = t("../shapes/Convex"),
                h = (t("../shapes/Line"), t("../shapes/Plane")),
                l = t("../shapes/Capsule"),
                c = t("../shapes/Particle"),
                d = t("../events/EventEmitter"),
                u = t("../objects/Body"),
                p = (t("../shapes/Shape"), t("../objects/LinearSpring"), t("../material/Material")),
                m = t("../material/ContactMaterial"),
                f = (t("../constraints/DistanceConstraint"), t("../constraints/Constraint"), t("../constraints/LockConstraint"), t("../constraints/RevoluteConstraint"), t("../constraints/PrismaticConstraint"), t("../constraints/GearConstraint"), t("../../package.json"), t("../collision/Broadphase"), t("../collision/AABB")),
                y = t("../collision/SAPBroadphase"),
                b = t("../collision/Narrowphase"),
                g = t("../utils/Utils"),
                _ = t("../utils/OverlapKeeper"),
                v = t("./IslandManager");
            t("../objects/RotationalSpring");
            e.exports = o, o.prototype = new Object(d.prototype), o.prototype.constructor = o, o.NO_SLEEPING = 1, o.BODY_SLEEPING = 2, o.ISLAND_SLEEPING = 4, o.prototype.addConstraint = function(t) { this.constraints.push(t) }, o.prototype.addContactMaterial = function(t) { this.contactMaterials.push(t) }, o.prototype.removeContactMaterial = function(t) { var e = this.contactMaterials.indexOf(t); - 1 !== e && g.splice(this.contactMaterials, e, 1) }, o.prototype.getContactMaterial = function(t, e) { for (var i = this.contactMaterials, o = 0, n = i.length; o !== n; o++) { var s = i[o]; if (s.materialA.id === t.id && s.materialB.id === e.id || s.materialA.id === e.id && s.materialB.id === t.id) return s } return !1 }, o.prototype.removeConstraint = function(t) { var e = this.constraints.indexOf(t); - 1 !== e && g.splice(this.constraints, e, 1) };
            s.create(), s.create(), s.create(), s.create(), s.create(), s.create(); var x = s.create(),
                S = s.fromValues(0, 0),
                C = s.fromValues(0, 0);
            s.fromValues(0, 0), s.fromValues(0, 0);
            o.prototype.step = function(t, e, i) { if (i = i || 10, 0 === (e = e || 0)) this.internalStep(t), this.time += t;
                else { this.accumulator += e; for (var o = 0; this.accumulator >= t && o < i;) this.internalStep(t), this.time += t, this.accumulator -= t, o++; for (var n = this.accumulator % t / t, r = 0; r !== this.bodies.length; r++) { var a = this.bodies[r];
                        s.lerp(a.interpolatedPosition, a.previousPosition, a.position, n), a.interpolatedAngle = a.previousAngle + n * (a.angle - a.previousAngle) } } }; var w = [];
            o.prototype.internalStep = function(t) { this.stepping = !0; var e = this.springs.length,
                    i = this.springs,
                    n = this.bodies,
                    r = this.gravity,
                    a = this.solver,
                    h = this.bodies.length,
                    l = this.broadphase,
                    c = this.narrowphase,
                    d = this.constraints,
                    p = x,
                    m = (s.scale, s.add),
                    f = (s.rotate, this.islandManager); if (this.overlapKeeper.tick(), this.lastTimeStep = t, this.useWorldGravityAsFrictionGravity) { var y = s.length(this.gravity);
                    0 === y && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = y) } if (this.applyGravity)
                    for (C = 0; C !== h; C++) { var b = (_ = n[C]).force;
                        _.type === u.DYNAMIC && _.sleepState !== u.SLEEPING && (s.scale(p, r, _.mass * _.gravityScale), m(b, b, p)) }
                if (this.applySpringForces)
                    for (C = 0; C !== e; C++) i[C].applyForce(); if (this.applyDamping)
                    for (C = 0; C !== h; C++) { var _ = n[C];
                        _.type === u.DYNAMIC && _.applyDamping(t) }
                for (var v = l.getCollisionPairs(this), S = this.disabledBodyCollisionPairs, C = S.length - 2; C >= 0; C -= 2)
                    for (T = v.length - 2; T >= 0; T -= 2)(S[C] === v[T] && S[C + 1] === v[T + 1] || S[C + 1] === v[T] && S[C] === v[T + 1]) && v.splice(T, 2);
                H = d.length; for (C = 0; C !== H; C++) { var A = d[C]; if (!A.collideConnected)
                        for (var T = v.length - 2; T >= 0; T -= 2)(A.bodyA === v[T] && A.bodyB === v[T + 1] || A.bodyB === v[T] && A.bodyA === v[T + 1]) && v.splice(T, 2) } this.postBroadphaseEvent.pairs = v, this.emit(this.postBroadphaseEvent), this.postBroadphaseEvent.pairs = null, c.reset(this); for (var C = 0, P = v.length; C !== P; C += 2)
                    for (var k = v[C], M = v[C + 1], E = 0, B = k.shapes.length; E !== B; E++)
                        for (var I = k.shapes[E], D = I.position, L = I.angle, O = 0, R = M.shapes.length; O !== R; O++) { var F = M.shapes[O],
                                V = F.position,
                                G = F.angle,
                                U = this.defaultContactMaterial; if (I.material && F.material) { var N = this.getContactMaterial(I.material, F.material);
                                N && (U = N) } this.runNarrowphase(c, k, I, D, L, M, F, V, G, U, this.frictionGravity) }
                for (C = 0; C !== h; C++)(z = n[C])._wakeUpAfterNarrowphase && (z.wakeUp(), z._wakeUpAfterNarrowphase = !1); if (this.has("endContact")) { this.overlapKeeper.getEndOverlaps(w); for (var j = this.endContactEvent, O = w.length; O--;) { var W = w[O];
                        j.shapeA = W.shapeA, j.shapeB = W.shapeB, j.bodyA = W.bodyA, j.bodyB = W.bodyB, this.emit(j) } w.length = 0 } var X = this.preSolveEvent;
                X.contactEquations = c.contactEquations, X.frictionEquations = c.frictionEquations, this.emit(X), X.contactEquations = X.frictionEquations = null; var H = d.length; for (C = 0; C !== H; C++) d[C].update(); if (c.contactEquations.length || c.frictionEquations.length || H)
                    if (this.islandSplit) { for (f.equations.length = 0, g.appendArray(f.equations, c.contactEquations), g.appendArray(f.equations, c.frictionEquations), C = 0; C !== H; C++) g.appendArray(f.equations, d[C].equations);
                        f.split(this); for (C = 0; C !== f.islands.length; C++)(Y = f.islands[C]).equations.length && a.solveIsland(t, Y) } else { for (a.addEquations(c.contactEquations), a.addEquations(c.frictionEquations), C = 0; C !== H; C++) a.addEquations(d[C].equations);
                        this.solveConstraints && a.solve(t, this), a.removeAllEquations() } for (C = 0; C !== h; C++) { var z = n[C];
                    z.integrate(t) } for (C = 0; C !== h; C++) n[C].setZeroForce(); if (this.emitImpactEvent && this.has("impact"))
                    for (var J = this.impactEvent, C = 0; C !== c.contactEquations.length; C++) { var q = c.contactEquations[C];
                        q.firstImpact && (J.bodyA = q.bodyA, J.bodyB = q.bodyB, J.shapeA = q.shapeA, J.shapeB = q.shapeB, J.contactEquation = q, this.emit(J)) }
                if (this.sleepMode === o.BODY_SLEEPING)
                    for (C = 0; C !== h; C++) n[C].sleepTick(this.time, !1, t);
                else if (this.sleepMode === o.ISLAND_SLEEPING && this.islandSplit) { for (C = 0; C !== h; C++) n[C].sleepTick(this.time, !0, t); for (C = 0; C < this.islandManager.islands.length; C++) { var Y = this.islandManager.islands[C];
                        Y.wantsToSleep() && Y.sleep() } } this.stepping = !1; for (var K = this.bodiesToBeRemoved, C = 0; C !== K.length; C++) this.removeBody(K[C]);
                K.length = 0, this.emit(this.postStepEvent) }, o.prototype.runNarrowphase = function(t, e, i, o, n, r, a, h, l, c, d) { if (0 != (i.collisionGroup & a.collisionMask) && 0 != (a.collisionGroup & i.collisionMask)) { s.rotate(S, o, e.angle), s.rotate(C, h, r.angle), s.add(S, S, e.position), s.add(C, C, r.position); var p = n + e.angle,
                        m = l + r.angle;
                    t.enableFriction = c.friction > 0, t.frictionCoefficient = c.friction; var f;
                    f = e.type === u.STATIC || e.type === u.KINEMATIC ? r.mass : r.type === u.STATIC || r.type === u.KINEMATIC ? e.mass : e.mass * r.mass / (e.mass + r.mass), t.slipForce = c.friction * d * f, t.restitution = c.restitution, t.surfaceVelocity = c.surfaceVelocity, t.frictionStiffness = c.frictionStiffness, t.frictionRelaxation = c.frictionRelaxation, t.stiffness = c.stiffness, t.relaxation = c.relaxation, t.contactSkinSize = c.contactSkinSize, t.enabledEquations = e.collisionResponse && r.collisionResponse && i.collisionResponse && a.collisionResponse; var y = t[i.type | a.type],
                        b = 0; if (y) { var g = i.sensor || a.sensor,
                            _ = t.frictionEquations.length;
                        b = i.type < a.type ? y.call(t, e, i, S, p, r, a, C, m, g) : y.call(t, r, a, C, m, e, i, S, p, g); var v = t.frictionEquations.length - _; if (b) { if (e.allowSleep && e.type === u.DYNAMIC && e.sleepState === u.SLEEPING && r.sleepState === u.AWAKE && r.type !== u.STATIC && s.squaredLength(r.velocity) + Math.pow(r.angularVelocity, 2) >= 2 * Math.pow(r.sleepSpeedLimit, 2) && (e._wakeUpAfterNarrowphase = !0), r.allowSleep && r.type === u.DYNAMIC && r.sleepState === u.SLEEPING && e.sleepState === u.AWAKE && e.type !== u.STATIC && s.squaredLength(e.velocity) + Math.pow(e.angularVelocity, 2) >= 2 * Math.pow(e.sleepSpeedLimit, 2) && (r._wakeUpAfterNarrowphase = !0), this.overlapKeeper.setOverlapping(e, i, r, a), this.has("beginContact") && this.overlapKeeper.isNewOverlap(i, a)) { var x = this.beginContactEvent; if (x.shapeA = i, x.shapeB = a, x.bodyA = e, x.bodyB = r, x.contactEquations.length = 0, "number" == typeof b)
                                    for (w = t.contactEquations.length - b; w < t.contactEquations.length; w++) x.contactEquations.push(t.contactEquations[w]);
                                this.emit(x) } if ("number" == typeof b && v > 1)
                                for (var w = t.frictionEquations.length - v; w < t.frictionEquations.length; w++) { var A = t.frictionEquations[w];
                                    A.setSlipForce(A.getSlipForce() / v) } } } } }, o.prototype.addSpring = function(t) { this.springs.push(t); var e = this.addSpringEvent;
                e.spring = t, this.emit(e), e.spring = null }, o.prototype.removeSpring = function(t) { var e = this.springs.indexOf(t); - 1 !== e && g.splice(this.springs, e, 1) }, o.prototype.addBody = function(t) { if (-1 === this.bodies.indexOf(t)) { this.bodies.push(t), t.world = this; var e = this.addBodyEvent;
                    e.body = t, this.emit(e), e.body = null } }, o.prototype.removeBody = function(t) { if (this.stepping) this.bodiesToBeRemoved.push(t);
                else { t.world = null; var e = this.bodies.indexOf(t); - 1 !== e && (g.splice(this.bodies, e, 1), this.removeBodyEvent.body = t, t.resetConstraintVelocity(), this.emit(this.removeBodyEvent), this.removeBodyEvent.body = null) } }, o.prototype.getBodyById = function(t) { for (var e = this.bodies, i = 0; i < e.length; i++) { var o = e[i]; if (o.id === t) return o } return !1 }, o.prototype.disableBodyCollision = function(t, e) { this.disabledBodyCollisionPairs.push(t, e) }, o.prototype.enableBodyCollision = function(t, e) { for (var i = this.disabledBodyCollisionPairs, o = 0; o < i.length; o += 2)
                    if (i[o] === t && i[o + 1] === e || i[o + 1] === t && i[o] === e) return void i.splice(o, 2) }, o.prototype.clear = function() { this.time = 0, this.solver && this.solver.equations.length && this.solver.removeAllEquations(); for (var t = this.constraints, e = t.length - 1; e >= 0; e--) this.removeConstraint(t[e]); for (var i = this.bodies, e = i.length - 1; e >= 0; e--) this.removeBody(i[e]); for (var n = this.springs, e = n.length - 1; e >= 0; e--) this.removeSpring(n[e]); for (var s = this.contactMaterials, e = s.length - 1; e >= 0; e--) this.removeContactMaterial(s[e]);
                o.apply(this) }; var A = s.create(),
                T = (s.fromValues(0, 0), s.fromValues(0, 0));
            o.prototype.hitTest = function(t, e, i) { i = i || 0; var o = new u({ position: t }),
                    n = new c,
                    d = t,
                    p = A,
                    m = T;
                o.addShape(n); for (var f = this.narrowphase, y = [], b = 0, g = e.length; b !== g; b++)
                    for (var _ = e[b], v = 0, x = _.shapes.length; v !== x; v++) { var S = _.shapes[v];
                        s.rotate(p, S.position, _.angle), s.add(p, p, _.position); var C = S.angle + _.angle;
                        (S instanceof r && f.circleParticle(_, S, p, C, o, n, d, 0, !0) || S instanceof a && f.particleConvex(o, n, d, 0, _, S, p, C, !0) || S instanceof h && f.particlePlane(o, n, d, 0, _, S, p, C, !0) || S instanceof l && f.particleCapsule(o, n, d, 0, _, S, p, C, !0) || S instanceof c && s.squaredLength(s.sub(m, p, t)) < i * i) && y.push(_) }
                return y }, o.prototype.setGlobalStiffness = function(t) { for (var e = this.constraints, i = 0; i !== e.length; i++)
                    for (var o = e[i], n = 0; n !== o.equations.length; n++) { var s = o.equations[n];
                        s.stiffness = t, s.needsUpdate = !0 }
                for (var r = this.contactMaterials, i = 0; i !== r.length; i++)(o = r[i]).stiffness = o.frictionStiffness = t;
                (o = this.defaultContactMaterial).stiffness = o.frictionStiffness = t }, o.prototype.setGlobalRelaxation = function(t) { for (n = 0; n !== this.constraints.length; n++)
                    for (var e = this.constraints[n], i = 0; i !== e.equations.length; i++) { var o = e.equations[i];
                        o.relaxation = t, o.needsUpdate = !0 }
                for (var n = 0; n !== this.contactMaterials.length; n++)(e = this.contactMaterials[n]).relaxation = e.frictionRelaxation = t;
                (e = this.defaultContactMaterial).relaxation = e.frictionRelaxation = t }; var P = new f,
                k = [];
            o.prototype.raycast = function(t, e) { return e.getAABB(P), this.broadphase.aabbQuery(this, P, k), e.intersectBodies(t, k), k.length = 0, t.hasHit() } }, { "../../package.json": 6, "../collision/AABB": 7, "../collision/Broadphase": 8, "../collision/Narrowphase": 10, "../collision/Ray": 11, "../collision/SAPBroadphase": 13, "../constraints/Constraint": 14, "../constraints/DistanceConstraint": 15, "../constraints/GearConstraint": 16, "../constraints/LockConstraint": 17, "../constraints/PrismaticConstraint": 18, "../constraints/RevoluteConstraint": 19, "../events/EventEmitter": 26, "../material/ContactMaterial": 27, "../material/Material": 28, "../math/vec2": 30, "../objects/Body": 31, "../objects/LinearSpring": 32, "../objects/RotationalSpring": 33, "../shapes/Capsule": 38, "../shapes/Circle": 39, "../shapes/Convex": 40, "../shapes/Line": 42, "../shapes/Particle": 43, "../shapes/Plane": 44, "../shapes/Shape": 45, "../solver/GSSolver": 46, "../solver/Solver": 47, "../utils/OverlapKeeper": 52, "../utils/Utils": 57, "./IslandManager": 59 }] }, {}, [36])(36) }),
function() { var t = this,
        e = e || {}; return e.game = null, e.WEBGL_RENDERER = 0, e.CANVAS_RENDERER = 1, e.VERSION = "v2.2.9", e._UID = 0, "undefined" != typeof Float32Array ? (e.Float32Array = Float32Array, e.Uint16Array = Uint16Array, e.Uint32Array = Uint32Array, e.ArrayBuffer = ArrayBuffer) : (e.Float32Array = Array, e.Uint16Array = Array), e.PI_2 = 2 * Math.PI, e.RAD_TO_DEG = 180 / Math.PI, e.DEG_TO_RAD = Math.PI / 180, e.RETINA_PREFIX = "@2x", e.DisplayObject = function() { this.position = new e.Point(0, 0), this.scale = new e.Point(1, 1), this.pivot = new e.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new e.Matrix, this.worldPosition = new e.Point(0, 0), this.worldScale = new e.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new e.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1 }, e.DisplayObject.prototype.constructor = e.DisplayObject, e.DisplayObject.prototype = { destroy: function() { if (this.children) { for (var t = this.children.length; t--;) this.children[t].destroy();
                this.children = [] } this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite() }, updateTransform: function(t) { if (!t && !this.parent && !this.game) return this; var i = this.parent;
            t ? i = t : this.parent || (i = this.game.world); var o, n, s, r, a, h, l = i.worldTransform,
                c = this.worldTransform; return this.rotation % e.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), o = this._cr * this.scale.x, n = this._sr * this.scale.x, s = -this._sr * this.scale.y, r = this._cr * this.scale.y, a = this.position.x, h = this.position.y, (this.pivot.x || this.pivot.y) && (a -= this.pivot.x * o + this.pivot.y * s, h -= this.pivot.x * n + this.pivot.y * r), c.a = o * l.a + n * l.c, c.b = o * l.b + n * l.d, c.c = s * l.a + r * l.c, c.d = s * l.b + r * l.d, c.tx = a * l.a + h * l.c + l.tx, c.ty = a * l.b + h * l.d + l.ty) : (o = this.scale.x, r = this.scale.y, a = this.position.x - this.pivot.x * o, h = this.position.y - this.pivot.y * r, c.a = o * l.a, c.b = o * l.b, c.c = r * l.c, c.d = r * l.d, c.tx = a * l.a + h * l.c + l.tx, c.ty = a * l.b + h * l.d + l.ty), this.worldAlpha = this.alpha * i.worldAlpha, this.worldPosition.set(c.tx, c.ty), this.worldScale.set(this.scale.x * Math.sqrt(c.a * c.a + c.c * c.c), this.scale.y * Math.sqrt(c.b * c.b + c.d * c.d)), this.worldRotation = Math.atan2(-c.c, c.d), this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, c, l), this }, preUpdate: function() {}, generateTexture: function(t, i, o) { var n = this.getLocalBounds(),
                s = new e.RenderTexture(0 | n.width, 0 | n.height, o, i, t); return e.DisplayObject._tempMatrix.tx = -n.x, e.DisplayObject._tempMatrix.ty = -n.y, s.render(this, e.DisplayObject._tempMatrix), s }, updateCache: function() { return this._generateCachedSprite(), this }, toGlobal: function(t) { return this.updateTransform(), this.worldTransform.apply(t) }, toLocal: function(t, e) { return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t) }, _renderCachedSprite: function(t) { this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? e.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : e.Sprite.prototype._renderCanvas.call(this._cachedSprite, t) }, _generateCachedSprite: function() { this._cacheAsBitmap = !1; var t = this.getLocalBounds(); if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height);
            else { var i = new e.RenderTexture(t.width, t.height);
                this._cachedSprite = new e.Sprite(i), this._cachedSprite.worldTransform = this.worldTransform } var o = this._filters;
            this._filters = null, this._cachedSprite.filters = o, e.DisplayObject._tempMatrix.tx = -t.x, e.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, e.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = o, this._cacheAsBitmap = !0 }, _destroyCachedSprite: function() { this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null) } }, e.DisplayObject.prototype.displayObjectUpdateTransform = e.DisplayObject.prototype.updateTransform, Object.defineProperties(e.DisplayObject.prototype, { x: { get: function() { return this.position.x }, set: function(t) { this.position.x = t } }, y: { get: function() { return this.position.y }, set: function(t) { this.position.y = t } }, worldVisible: { get: function() { if (this.visible) { var t = this.parent; if (!t) return this.visible;
                    do { if (!t.visible) return !1;
                        t = t.parent } while (t); return !0 } return !1 } }, mask: { get: function() { return this._mask }, set: function(t) { this._mask && (this._mask.isMask = !1), this._mask = t, t && (this._mask.isMask = !0) } }, filters: { get: function() { return this._filters }, set: function(t) { if (Array.isArray(t)) { for (var i = [], o = 0; o < t.length; o++)
                        for (var n = t[o].passes, s = 0; s < n.length; s++) i.push(n[s]);
                    this._filterBlock = { target: this, filterPasses: i } } this._filters = t, this.blendMode && this.blendMode === e.blendModes.MULTIPLY && (this.blendMode = e.blendModes.NORMAL) } }, cacheAsBitmap: { get: function() { return this._cacheAsBitmap }, set: function(t) { this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t) } } }), e.DisplayObjectContainer = function() { e.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1 }, e.DisplayObjectContainer.prototype = Object.create(e.DisplayObject.prototype), e.DisplayObjectContainer.prototype.constructor = e.DisplayObjectContainer, e.DisplayObjectContainer.prototype.addChild = function(t) { return this.addChildAt(t, this.children.length) }, e.DisplayObjectContainer.prototype.addChildAt = function(t, e) { if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), t; throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length) }, e.DisplayObjectContainer.prototype.swapChildren = function(t, e) { if (t !== e) { var i = this.getChildIndex(t),
                o = this.getChildIndex(e); if (i < 0 || o < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
            this.children[i] = e, this.children[o] = t } }, e.DisplayObjectContainer.prototype.getChildIndex = function(t) { var e = this.children.indexOf(t); if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller"); return e }, e.DisplayObjectContainer.prototype.setChildIndex = function(t, e) { if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds"); var i = this.getChildIndex(t);
        this.children.splice(i, 1), this.children.splice(e, 0, t) }, e.DisplayObjectContainer.prototype.getChildAt = function(t) { if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller"); return this.children[t] }, e.DisplayObjectContainer.prototype.removeChild = function(t) { var e = this.children.indexOf(t); if (-1 !== e) return this.removeChildAt(e) }, e.DisplayObjectContainer.prototype.removeChildAt = function(t) { var e = this.getChildAt(t); return e && (e.parent = void 0, this.children.splice(t, 1)), e }, e.DisplayObjectContainer.prototype.removeChildren = function(t, e) { void 0 === t && (t = 0), void 0 === e && (e = this.children.length); var i = e - t; if (i > 0 && i <= e) { for (var o = this.children.splice(begin, i), n = 0; n < o.length; n++) o[n].parent = void 0; return o } if (0 === i && 0 === this.children.length) return []; throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range") }, e.DisplayObjectContainer.prototype.updateTransform = function() { if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
            for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform() }, e.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = e.DisplayObjectContainer.prototype.updateTransform, e.DisplayObjectContainer.prototype.getBounds = function(t) { var i = t && t instanceof e.DisplayObject,
            o = !0;
        i ? o = t instanceof e.DisplayObjectContainer && t.contains(this) : t = this; var n; if (i) { var s = t.worldTransform; for (t.worldTransform = e.identityMatrix, n = 0; n < t.children.length; n++) t.children[n].updateTransform() } var r, a, h, l = 1 / 0,
            c = 1 / 0,
            d = -1 / 0,
            u = -1 / 0,
            p = !1; for (n = 0; n < this.children.length; n++) this.children[n].visible && (p = !0, l = l < (r = this.children[n].getBounds()).x ? l : r.x, c = c < r.y ? c : r.y, a = r.width + r.x, h = r.height + r.y, d = d > a ? d : a, u = u > h ? u : h); var m = this._bounds; if (!p) { var f = (m = new e.Rectangle).x,
                y = m.width + m.x,
                b = m.y,
                g = m.height + m.y,
                _ = this.worldTransform,
                v = _.a,
                x = _.b,
                S = _.c,
                C = _.d,
                w = _.tx,
                A = _.ty,
                T = v * y + S * g + w,
                P = C * g + x * y + A,
                k = v * f + S * g + w,
                M = C * g + x * f + A,
                E = v * f + S * b + w,
                B = C * b + x * f + A,
                I = v * y + S * b + w,
                D = C * b + x * y + A;
            d = T, u = P, c = P, l = I < (l = E < (l = k < (l = T) ? k : l) ? E : l) ? I : l, c = D < (c = B < (c = M < c ? M : c) ? B : c) ? D : c, d = I > (d = E > (d = k > d ? k : d) ? E : d) ? I : d, u = D > (u = B > (u = M > u ? M : u) ? B : u) ? D : u } if (m.x = l, m.y = c, m.width = d - l, m.height = u - c, i)
            for (t.worldTransform = s, n = 0; n < t.children.length; n++) t.children[n].updateTransform(); if (!o) { var L = t.getBounds();
            m.x -= L.x, m.y -= L.y } return m }, e.DisplayObjectContainer.prototype.getLocalBounds = function() { return this.getBounds(this) }, e.DisplayObjectContainer.prototype.contains = function(t) { return !!t && (t === this || this.contains(t.parent)) }, e.DisplayObjectContainer.prototype._renderWebGL = function(t) { if (this.visible && !(this.alpha <= 0))
            if (this._cacheAsBitmap) this._renderCachedSprite(t);
            else { var e; if (this._mask || this._filters) { for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                    t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start() } else
                    for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t) } }, e.DisplayObjectContainer.prototype._renderCanvas = function(t) { if (!1 !== this.visible && 0 !== this.alpha)
            if (this._cacheAsBitmap) this._renderCachedSprite(t);
            else { this._mask && t.maskManager.pushMask(this._mask, t); for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t) } }, Object.defineProperty(e.DisplayObjectContainer.prototype, "width", { get: function() { return this.getLocalBounds().width * this.scale.x }, set: function(t) { var e = this.getLocalBounds().width;
            this.scale.x = 0 !== e ? t / e : 1, this._width = t } }), Object.defineProperty(e.DisplayObjectContainer.prototype, "height", { get: function() { return this.getLocalBounds().height * this.scale.y }, set: function(t) { var e = this.getLocalBounds().height;
            this.scale.y = 0 !== e ? t / e : 1, this._height = t } }), e.Sprite = function(t) { e.DisplayObjectContainer.call(this), this.anchor = new e.Point, this.texture = t || e.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = e.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0 }, e.Sprite.prototype = Object.create(e.DisplayObjectContainer.prototype), e.Sprite.prototype.constructor = e.Sprite, Object.defineProperty(e.Sprite.prototype, "width", { get: function() { return this.scale.x * this.texture.frame.width }, set: function(t) { this.scale.x = t / this.texture.frame.width, this._width = t } }), Object.defineProperty(e.Sprite.prototype, "height", { get: function() { return this.scale.y * this.texture.frame.height }, set: function(t) { this.scale.y = t / this.texture.frame.height, this._height = t } }), e.Sprite.prototype.setTexture = function(t, e) { void 0 !== e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1 }, e.Sprite.prototype.onTextureUpdate = function() { this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height) }, e.Sprite.prototype.getBounds = function(t) { var e = this.texture.frame.width,
            i = this.texture.frame.height,
            o = e * (1 - this.anchor.x),
            n = e * -this.anchor.x,
            s = i * (1 - this.anchor.y),
            r = i * -this.anchor.y,
            a = t || this.worldTransform,
            h = a.a,
            l = a.b,
            c = a.c,
            d = a.d,
            u = a.tx,
            p = a.ty,
            m = -1 / 0,
            f = -1 / 0,
            y = 1 / 0,
            b = 1 / 0; if (0 === l && 0 === c) { if (h < 0) { h *= -1;
                g = o;
                o = -n, n = -g } if (d < 0) { d *= -1; var g = s;
                s = -r, r = -g } y = h * n + u, m = h * o + u, b = d * r + p, f = d * s + p } else { var _ = h * n + c * r + u,
                v = d * r + l * n + p,
                x = h * o + c * r + u,
                S = d * r + l * o + p,
                C = h * o + c * s + u,
                w = d * s + l * o + p,
                A = h * n + c * s + u,
                T = d * s + l * n + p;
            y = A < (y = C < (y = x < (y = _ < y ? _ : y) ? x : y) ? C : y) ? A : y, b = T < (b = w < (b = S < (b = v < b ? v : b) ? S : b) ? w : b) ? T : b, m = A > (m = C > (m = x > (m = _ > m ? _ : m) ? x : m) ? C : m) ? A : m, f = T > (f = w > (f = S > (f = v > f ? v : f) ? S : f) ? w : f) ? T : f } var P = this._bounds; return P.x = y, P.width = m - y, P.y = b, P.height = f - b, this._currentBounds = P, P }, e.Sprite.prototype.getLocalBounds = function() { var t = this.worldTransform;
        this.worldTransform = e.identityMatrix; for (var i = 0; i < this.children.length; i++) this.children[i].updateTransform(); var o = this.getBounds(); for (this.worldTransform = t, i = 0; i < this.children.length; i++) this.children[i].updateTransform(); return o }, e.Sprite.prototype._renderWebGL = function(t, e) { if (this.visible && !(this.alpha <= 0) && this.renderable) { var i = this.worldTransform; if (e && (i = e), this._mask || this._filters) { var o = t.spriteBatch;
                this._filters && (o.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (o.stop(), t.maskManager.pushMask(this.mask, t), o.start()), o.render(this); for (n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t);
                o.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), o.start() } else { t.spriteBatch.render(this); for (var n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t, i) } } }, e.Sprite.prototype._renderCanvas = function(t, i) { if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) { var o = this.worldTransform; if (i && (o = i), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = e.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) { var n = this.texture.baseTexture.resolution / t.resolution;
                t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === e.scaleModes.LINEAR); var s = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                    r = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                    a = o.tx * t.resolution + t.shakeX,
                    h = o.ty * t.resolution + t.shakeY;
                t.roundPixels ? (t.context.setTransform(o.a, o.b, o.c, o.d, 0 | a, 0 | h), s |= 0, r |= 0) : t.context.setTransform(o.a, o.b, o.c, o.d, a, h); var l = this.texture.crop.width,
                    c = this.texture.crop.height; if (s /= n, r /= n, 16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = e.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, l, c, s, r, l / n, c / n);
                else { var d = this.texture.crop.x,
                        u = this.texture.crop.y;
                    t.context.drawImage(this.texture.baseTexture.source, d, u, l, c, s, r, l / n, c / n) } } for (var p = 0; p < this.children.length; p++) this.children[p]._renderCanvas(t);
            this._mask && t.maskManager.popMask(t) } }, e.SpriteBatch = function(t) { e.DisplayObjectContainer.call(this), this.textureThing = t, this.ready = !1 }, e.SpriteBatch.prototype = Object.create(e.DisplayObjectContainer.prototype), e.SpriteBatch.prototype.constructor = e.SpriteBatch, e.SpriteBatch.prototype.initWebGL = function(t) { this.fastSpriteBatch = new e.WebGLFastSpriteBatch(t), this.ready = !0 }, e.SpriteBatch.prototype.updateTransform = function() { this.displayObjectUpdateTransform() }, e.SpriteBatch.prototype._renderWebGL = function(t) {!this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(t.gl), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start()) }, e.SpriteBatch.prototype._renderCanvas = function(t) { if (this.visible && !(this.alpha <= 0) && this.children.length) { var e = t.context;
            e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform(); for (var i = this.worldTransform, o = !0, n = 0; n < this.children.length; n++) { var s = this.children[n]; if (s.visible) { var r = s.texture,
                        a = r.frame; if (e.globalAlpha = this.worldAlpha * s.alpha, s.rotation % (2 * Math.PI) == 0) o && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), o = !1), e.drawImage(r.baseTexture.source, a.x, a.y, a.width, a.height, s.anchor.x * (-a.width * s.scale.x) + s.position.x + .5 + t.shakeX | 0, s.anchor.y * (-a.height * s.scale.y) + s.position.y + .5 + t.shakeY | 0, a.width * s.scale.x, a.height * s.scale.y);
                    else { o || (o = !0), s.displayObjectUpdateTransform(); var h = s.worldTransform,
                            l = h.tx * t.resolution + t.shakeX,
                            c = h.ty * t.resolution + t.shakeY;
                        t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | c) : e.setTransform(h.a, h.b, h.c, h.d, l, c), e.drawImage(r.baseTexture.source, a.x, a.y, a.width, a.height, s.anchor.x * -a.width + .5 | 0, s.anchor.y * -a.height + .5 | 0, a.width, a.height) } } } } }, e.hex2rgb = function(t) { return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255] }, e.rgb2hex = function(t) { return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2] }, e.canUseNewCanvasBlendModes = function() { if (void 0 === document) return !1; var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
            i = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
            o = new Image;
        o.src = t + "AP804Oa6" + i; var n = new Image;
        n.src = t + "/wCKxvRF" + i; var s = e.CanvasPool.create(this, 6, 1).getContext("2d"); if (s.globalCompositeOperation = "multiply", s.drawImage(o, 0, 0), s.drawImage(n, 2, 0), !s.getImageData(2, 0, 1, 1)) return !1; var r = s.getImageData(2, 0, 1, 1).data; return e.CanvasPool.remove(this), 255 === r[0] && 0 === r[1] && 0 === r[2] }, e.getNextPowerOfTwo = function(t) { if (t > 0 && 0 == (t & t - 1)) return t; for (var e = 1; e < t;) e <<= 1; return e }, e.isPowerOfTwo = function(t, e) { return t > 0 && 0 == (t & t - 1) && e > 0 && 0 == (e & e - 1) }, e.CanvasPool = { create: function(t, i, o) { var n, s = e.CanvasPool.getFirst(); if (-1 === s) { var r = { parent: t, canvas: document.createElement("canvas") };
                e.CanvasPool.pool.push(r), n = r.canvas } else e.CanvasPool.pool[s].parent = t, n = e.CanvasPool.pool[s].canvas; return void 0 !== i && (n.width = i, n.height = o), n }, getFirst: function() { for (var t = e.CanvasPool.pool, i = 0; i < t.length; i++)
                if (!t[i].parent) return i; return -1 }, remove: function(t) { for (var i = e.CanvasPool.pool, o = 0; o < i.length; o++) i[o].parent === t && (i[o].parent = null, i[o].canvas.width = 1, i[o].canvas.height = 1) }, removeByCanvas: function(t) { for (var i = e.CanvasPool.pool, o = 0; o < i.length; o++) i[o].canvas === t && (i[o].parent = null, i[o].canvas.width = 1, i[o].canvas.height = 1) }, getTotal: function() { for (var t = e.CanvasPool.pool, i = 0, o = 0; o < t.length; o++) t[o].parent && i++; return i }, getFree: function() { for (var t = e.CanvasPool.pool, i = 0, o = 0; o < t.length; o++) t[o].parent || i++; return i } }, e.CanvasPool.pool = [], e.initDefaultShaders = function() {}, e.CompileVertexShader = function(t, i) { return e._CompileShader(t, i, t.VERTEX_SHADER) }, e.CompileFragmentShader = function(t, i) { return e._CompileShader(t, i, t.FRAGMENT_SHADER) }, e._CompileShader = function(t, e, i) { var o = e;
        Array.isArray(e) && (o = e.join("\n")); var n = t.createShader(i); return t.shaderSource(n, o), t.compileShader(n), t.getShaderParameter(n, t.COMPILE_STATUS) ? n : (window.console.log(t.getShaderInfoLog(n)), null) }, e.compileProgram = function(t, i, o) { var n = e.CompileFragmentShader(t, o),
            s = e.CompileVertexShader(t, i),
            r = t.createProgram(); return t.attachShader(r, s), t.attachShader(r, n), t.linkProgram(r), t.getProgramParameter(r, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(r)), window.console.log("Could not initialise shaders")), r }, e.PixiShader = function(t) { this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init() }, e.PixiShader.prototype.constructor = e.PixiShader, e.PixiShader.prototype.init = function() { var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc || e.PixiShader.defaultVertexSrc, this.fragmentSrc);
        t.useProgram(i), this.uSampler = t.getUniformLocation(i, "uSampler"), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.dimensions = t.getUniformLocation(i, "dimensions"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(i, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(i, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute]; for (var o in this.uniforms) this.uniforms[o].uniformLocation = t.getUniformLocation(i, o);
        this.initUniforms(), this.program = i }, e.PixiShader.prototype.initUniforms = function() { this.textureCount = 1; var t, e = this.gl; for (var i in this.uniforms) { var o = (t = this.uniforms[i]).type; "sampler2D" === o ? (t._init = !1, null !== t.value && this.initSampler2D(t)) : "mat2" === o || "mat3" === o || "mat4" === o ? (t.glMatrix = !0, t.glValueLength = 1, "mat2" === o ? t.glFunc = e.uniformMatrix2fv : "mat3" === o ? t.glFunc = e.uniformMatrix3fv : "mat4" === o && (t.glFunc = e.uniformMatrix4fv)) : (t.glFunc = e["uniform" + o], t.glValueLength = "2f" === o || "2i" === o ? 2 : "3f" === o || "3i" === o ? 3 : "4f" === o || "4i" === o ? 4 : 1) } }, e.PixiShader.prototype.initSampler2D = function(t) { if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) { var e = this.gl; if (e.activeTexture(e["TEXTURE" + this.textureCount]), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) { var i = t.textureData,
                    o = i.magFilter ? i.magFilter : e.LINEAR,
                    n = i.minFilter ? i.minFilter : e.LINEAR,
                    s = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                    r = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE,
                    a = i.luminance ? e.LUMINANCE : e.RGBA; if (i.repeat && (s = e.REPEAT, r = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) { var h = i.width ? i.width : 512,
                        l = i.height ? i.height : 2,
                        c = i.border ? i.border : 0;
                    e.texImage2D(e.TEXTURE_2D, 0, a, h, l, c, a, e.UNSIGNED_BYTE, null) } else e.texImage2D(e.TEXTURE_2D, 0, a, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, o), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, r) } e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++ } }, e.PixiShader.prototype.syncUniforms = function() { this.textureCount = 1; var t, i = this.gl; for (var o in this.uniforms) 1 === (t = this.uniforms[o]).glValueLength ? !0 === t.glMatrix ? t.glFunc.call(i, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(i, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(i, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (i.activeTexture(i["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[i.id] ? e.instances[i.id].updateTexture(t.value.baseTexture) : i.bindTexture(i.TEXTURE_2D, t.value.baseTexture._glTextures[i.id]), i.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t)) }, e.PixiShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null }, e.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"], e.PixiFastShader = function(t) { this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init() }, e.PixiFastShader.prototype.constructor = e.PixiFastShader, e.PixiFastShader.prototype.init = function() { var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(i), this.uSampler = t.getUniformLocation(i, "uSampler"), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.dimensions = t.getUniformLocation(i, "dimensions"), this.uMatrix = t.getUniformLocation(i, "uMatrix"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(i, "aPositionCoord"), this.aScale = t.getAttribLocation(i, "aScale"), this.aRotation = t.getAttribLocation(i, "aRotation"), this.aTextureCoord = t.getAttribLocation(i, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(i, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute], this.program = i }, e.PixiFastShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null }, e.StripShader = function(t) { this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], this.init() }, e.StripShader.prototype.constructor = e.StripShader, e.StripShader.prototype.init = function() { var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(i), this.uSampler = t.getUniformLocation(i, "uSampler"), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.colorAttribute = t.getAttribLocation(i, "aColor"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(i, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord], this.translationMatrix = t.getUniformLocation(i, "translationMatrix"), this.alpha = t.getUniformLocation(i, "alpha"), this.program = i }, e.StripShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null }, e.PrimitiveShader = function(t) { this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init() }, e.PrimitiveShader.prototype.constructor = e.PrimitiveShader, e.PrimitiveShader.prototype.init = function() { var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(i), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.tintColor = t.getUniformLocation(i, "tint"), this.flipY = t.getUniformLocation(i, "flipY"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(i, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(i, "translationMatrix"), this.alpha = t.getUniformLocation(i, "alpha"), this.program = i }, e.PrimitiveShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null }, e.ComplexPrimitiveShader = function(t) { this._UID = e._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init() }, e.ComplexPrimitiveShader.prototype.constructor = e.ComplexPrimitiveShader, e.ComplexPrimitiveShader.prototype.init = function() { var t = this.gl,
            i = e.compileProgram(t, this.vertexSrc, this.fragmentSrc);
        t.useProgram(i), this.projectionVector = t.getUniformLocation(i, "projectionVector"), this.offsetVector = t.getUniformLocation(i, "offsetVector"), this.tintColor = t.getUniformLocation(i, "tint"), this.color = t.getUniformLocation(i, "color"), this.flipY = t.getUniformLocation(i, "flipY"), this.aVertexPosition = t.getAttribLocation(i, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(i, "translationMatrix"), this.alpha = t.getUniformLocation(i, "alpha"), this.program = i }, e.ComplexPrimitiveShader.prototype.destroy = function() { this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null }, e.glContexts = [], e.instances = [], e.WebGLRenderer = function(t) { this.game = t, e.defaultRenderer || (e.defaultRenderer = this), this.type = e.WEBGL_RENDERER, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = { alpha: this.transparent, antialias: t.antialias, premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent, stencil: !0, preserveDrawingBuffer: this.preserveDrawingBuffer }, this.projection = new e.Point, this.offset = new e.Point, this.shaderManager = new e.WebGLShaderManager, this.spriteBatch = new e.WebGLSpriteBatch, this.maskManager = new e.WebGLMaskManager, this.filterManager = new e.WebGLFilterManager, this.stencilManager = new e.WebGLStencilManager, this.blendModeManager = new e.WebGLBlendModeManager, this.renderSession = {}, this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, this.renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes() }, e.WebGLRenderer.prototype.constructor = e.WebGLRenderer, e.WebGLRenderer.prototype.initContext = function() { var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions); if (this.gl = t, !t) throw new Error("This browser does not support webGL. Try using the canvas renderer");
        this.glContextId = t.id = e.WebGLRenderer.glContextId++, e.glContexts[this.glContextId] = t, e.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height) }, e.WebGLRenderer.prototype.render = function(t) { if (!this.contextLost) { var e = this.gl;
            e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection) } }, e.WebGLRenderer.prototype.renderDisplayObject = function(t, i, o, n) { this.renderSession.blendModeManager.setBlendMode(e.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = o ? -1 : 1, this.renderSession.projection = i, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, o), t._renderWebGL(this.renderSession, n), this.spriteBatch.end() }, e.WebGLRenderer.prototype.resize = function(t, e) { this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution }, e.WebGLRenderer.prototype.updateTexture = function(t) { if (!t.hasLoaded) return !1; var i = this.gl; return t._glTextures[i.id] || (t._glTextures[i.id] = i.createTexture()), i.bindTexture(i.TEXTURE_2D, t._glTextures[i.id]), i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, i.RGBA, i.UNSIGNED_BYTE, t.source), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, t.scaleMode === e.scaleModes.LINEAR ? i.LINEAR : i.NEAREST), t.mipmap && e.isPowerOfTwo(t.width, t.height) ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, t.scaleMode === e.scaleModes.LINEAR ? i.LINEAR_MIPMAP_LINEAR : i.NEAREST_MIPMAP_NEAREST), i.generateMipmap(i.TEXTURE_2D)) : i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, t.scaleMode === e.scaleModes.LINEAR ? i.LINEAR : i.NEAREST), t._powerOf2 ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE)), t._dirty[i.id] = !1, !0 }, e.WebGLRenderer.prototype.destroy = function() { e.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, e.CanvasPool.remove(this), e.instances[this.glContextId] = null, e.WebGLRenderer.glContextId-- }, e.WebGLRenderer.prototype.mapBlendModes = function() { var t = this.gl; if (!e.blendModesWebGL) { var i = [],
                o = e.blendModes;
            i[o.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.ADD] = [t.SRC_ALPHA, t.DST_ALPHA], i[o.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], i[o.SCREEN] = [t.SRC_ALPHA, t.ONE], i[o.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], i[o.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e.blendModesWebGL = i } }, e.WebGLRenderer.glContextId = 0, e.WebGLBlendModeManager = function() { this.currentBlendMode = 99999 }, e.WebGLBlendModeManager.prototype.constructor = e.WebGLBlendModeManager, e.WebGLBlendModeManager.prototype.setContext = function(t) { this.gl = t }, e.WebGLBlendModeManager.prototype.setBlendMode = function(t) { if (this.currentBlendMode === t) return !1;
        this.currentBlendMode = t; var i = e.blendModesWebGL[this.currentBlendMode]; return i && this.gl.blendFunc(i[0], i[1]), !0 }, e.WebGLBlendModeManager.prototype.destroy = function() { this.gl = null }, e.WebGLMaskManager = function() {}, e.WebGLMaskManager.prototype.constructor = e.WebGLMaskManager, e.WebGLMaskManager.prototype.setContext = function(t) { this.gl = t }, e.WebGLMaskManager.prototype.pushMask = function(t, i) { var o = i.gl;
        t.dirty && e.WebGLGraphics.updateGraphics(t, o), void 0 !== t._webGL[o.id] && void 0 !== t._webGL[o.id].data && 0 !== t._webGL[o.id].data.length && i.stencilManager.pushStencil(t, t._webGL[o.id].data[0], i) }, e.WebGLMaskManager.prototype.popMask = function(t, e) { var i = this.gl;
        void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e) }, e.WebGLMaskManager.prototype.destroy = function() { this.gl = null }, e.WebGLStencilManager = function() { this.stencilStack = [], this.reverse = !0, this.count = 0 }, e.WebGLStencilManager.prototype.setContext = function(t) { this.gl = t }, e.WebGLStencilManager.prototype.pushStencil = function(t, e, i) { var o = this.gl;
        this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (o.enable(o.STENCIL_TEST), o.clear(o.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e); var n = this.count;
        o.colorMask(!1, !1, !1, !1), o.stencilFunc(o.ALWAYS, 0, 255), o.stencilOp(o.KEEP, o.KEEP, o.INVERT), 1 === e.mode ? (o.drawElements(o.TRIANGLE_FAN, e.indices.length - 4, o.UNSIGNED_SHORT, 0), this.reverse ? (o.stencilFunc(o.EQUAL, 255 - n, 255), o.stencilOp(o.KEEP, o.KEEP, o.DECR)) : (o.stencilFunc(o.EQUAL, n, 255), o.stencilOp(o.KEEP, o.KEEP, o.INCR)), o.drawElements(o.TRIANGLE_FAN, 4, o.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? o.stencilFunc(o.EQUAL, 255 - (n + 1), 255) : o.stencilFunc(o.EQUAL, n + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (o.stencilFunc(o.EQUAL, n, 255), o.stencilOp(o.KEEP, o.KEEP, o.INCR)) : (o.stencilFunc(o.EQUAL, 255 - n, 255), o.stencilOp(o.KEEP, o.KEEP, o.DECR)), o.drawElements(o.TRIANGLE_STRIP, e.indices.length, o.UNSIGNED_SHORT, 0), this.reverse ? o.stencilFunc(o.EQUAL, n + 1, 255) : o.stencilFunc(o.EQUAL, 255 - (n + 1), 255)), o.colorMask(!0, !0, !0, !0), o.stencilOp(o.KEEP, o.KEEP, o.KEEP), this.count++ }, e.WebGLStencilManager.prototype.bindGraphics = function(t, i, o) { this._currentGraphics = t; var n, s = this.gl,
            r = o.projection,
            a = o.offset;
        1 === i.mode ? (n = o.shaderManager.complexPrimitiveShader, o.shaderManager.setShader(n), s.uniform1f(n.flipY, o.flipY), s.uniformMatrix3fv(n.translationMatrix, !1, t.worldTransform.toArray(!0)), s.uniform2f(n.projectionVector, r.x, -r.y), s.uniform2f(n.offsetVector, -a.x, -a.y), s.uniform3fv(n.tintColor, e.hex2rgb(t.tint)), s.uniform3fv(n.color, i.color), s.uniform1f(n.alpha, t.worldAlpha * i.alpha), s.bindBuffer(s.ARRAY_BUFFER, i.buffer), s.vertexAttribPointer(n.aVertexPosition, 2, s.FLOAT, !1, 8, 0), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, i.indexBuffer)) : (n = o.shaderManager.primitiveShader, o.shaderManager.setShader(n), s.uniformMatrix3fv(n.translationMatrix, !1, t.worldTransform.toArray(!0)), s.uniform1f(n.flipY, o.flipY), s.uniform2f(n.projectionVector, r.x, -r.y), s.uniform2f(n.offsetVector, -a.x, -a.y), s.uniform3fv(n.tintColor, e.hex2rgb(t.tint)), s.uniform1f(n.alpha, t.worldAlpha), s.bindBuffer(s.ARRAY_BUFFER, i.buffer), s.vertexAttribPointer(n.aVertexPosition, 2, s.FLOAT, !1, 24, 0), s.vertexAttribPointer(n.colorAttribute, 4, s.FLOAT, !1, 24, 8), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, i.indexBuffer)) }, e.WebGLStencilManager.prototype.popStencil = function(t, e, i) { var o = this.gl; if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) o.disable(o.STENCIL_TEST);
        else { var n = this.count;
            this.bindGraphics(t, e, i), o.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (o.stencilFunc(o.EQUAL, 255 - (n + 1), 255), o.stencilOp(o.KEEP, o.KEEP, o.INCR)) : (o.stencilFunc(o.EQUAL, n + 1, 255), o.stencilOp(o.KEEP, o.KEEP, o.DECR)), o.drawElements(o.TRIANGLE_FAN, 4, o.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), o.stencilFunc(o.ALWAYS, 0, 255), o.stencilOp(o.KEEP, o.KEEP, o.INVERT), o.drawElements(o.TRIANGLE_FAN, e.indices.length - 4, o.UNSIGNED_SHORT, 0), this.reverse ? o.stencilFunc(o.EQUAL, n, 255) : o.stencilFunc(o.EQUAL, 255 - n, 255)) : (this.reverse ? (o.stencilFunc(o.EQUAL, n + 1, 255), o.stencilOp(o.KEEP, o.KEEP, o.DECR)) : (o.stencilFunc(o.EQUAL, 255 - (n + 1), 255), o.stencilOp(o.KEEP, o.KEEP, o.INCR)), o.drawElements(o.TRIANGLE_STRIP, e.indices.length, o.UNSIGNED_SHORT, 0), this.reverse ? o.stencilFunc(o.EQUAL, n, 255) : o.stencilFunc(o.EQUAL, 255 - n, 255)), o.colorMask(!0, !0, !0, !0), o.stencilOp(o.KEEP, o.KEEP, o.KEEP) } }, e.WebGLStencilManager.prototype.destroy = function() { this.stencilStack = null, this.gl = null }, e.WebGLShaderManager = function() { this.maxAttibs = 10, this.attribState = [], this.tempAttribState = []; for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
        this.stack = [] }, e.WebGLShaderManager.prototype.constructor = e.WebGLShaderManager, e.WebGLShaderManager.prototype.setContext = function(t) { this.gl = t, this.primitiveShader = new e.PrimitiveShader(t), this.complexPrimitiveShader = new e.ComplexPrimitiveShader(t), this.defaultShader = new e.PixiShader(t), this.fastShader = new e.PixiFastShader(t), this.stripShader = new e.StripShader(t), this.setShader(this.defaultShader) }, e.WebGLShaderManager.prototype.setAttribs = function(t) { var e; for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1; for (e = 0; e < t.length; e++) { var i = t[e];
            this.tempAttribState[i] = !0 } var o = this.gl; for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? o.enableVertexAttribArray(e) : o.disableVertexAttribArray(e)) }, e.WebGLShaderManager.prototype.setShader = function(t) { return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0) }, e.WebGLShaderManager.prototype.destroy = function() { this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.gl = null }, e.WebGLSpriteBatch = function() { this.vertSize = 5, this.size = 2e3; var t = 4 * this.size * 4 * this.vertSize,
            i = 6 * this.size;
        this.vertices = new e.ArrayBuffer(t), this.positions = new e.Float32Array(this.vertices), this.colors = new e.Uint32Array(this.vertices), this.indices = new e.Uint16Array(i), this.lastIndexCount = 0; for (var o = 0, n = 0; o < i; o += 6, n += 4) this.indices[o + 0] = n + 0, this.indices[o + 1] = n + 1, this.indices[o + 2] = n + 2, this.indices[o + 3] = n + 0, this.indices[o + 4] = n + 2, this.indices[o + 5] = n + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = new e.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"]) }, e.WebGLSpriteBatch.prototype.setContext = function(t) { this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999; var i = new e.PixiShader(t);
        i.fragmentSrc = this.defaultShader.fragmentSrc, i.uniforms = {}, i.init(), this.defaultShader.shaders[t.id] = i }, e.WebGLSpriteBatch.prototype.begin = function(t) { this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start() }, e.WebGLSpriteBatch.prototype.end = function() { this.flush() }, e.WebGLSpriteBatch.prototype.render = function(t, e) { var i = t.texture,
            o = t.worldTransform;
        e && (o = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture); var n = i._uvs; if (n) { var s, r, a, h, l = t.anchor.x,
                c = t.anchor.y; if (i.trim) { var d = i.trim;
                s = (r = d.x - l * d.width) + i.crop.width, a = (h = d.y - c * d.height) + i.crop.height } else s = i.frame.width * (1 - l), r = i.frame.width * -l, a = i.frame.height * (1 - c), h = i.frame.height * -c; var u = 4 * this.currentBatchSize * this.vertSize,
                p = i.baseTexture.resolution,
                m = o.a / p,
                f = o.b / p,
                y = o.c / p,
                b = o.d / p,
                g = o.tx,
                _ = o.ty,
                v = this.colors,
                x = this.positions;
            this.renderSession.roundPixels ? (x[u] = m * r + y * h + g | 0, x[u + 1] = b * h + f * r + _ | 0, x[u + 5] = m * s + y * h + g | 0, x[u + 6] = b * h + f * s + _ | 0, x[u + 10] = m * s + y * a + g | 0, x[u + 11] = b * a + f * s + _ | 0, x[u + 15] = m * r + y * a + g | 0, x[u + 16] = b * a + f * r + _ | 0) : (x[u] = m * r + y * h + g, x[u + 1] = b * h + f * r + _, x[u + 5] = m * s + y * h + g, x[u + 6] = b * h + f * s + _, x[u + 10] = m * s + y * a + g, x[u + 11] = b * a + f * s + _, x[u + 15] = m * r + y * a + g, x[u + 16] = b * a + f * r + _), x[u + 2] = n.x0, x[u + 3] = n.y0, x[u + 7] = n.x1, x[u + 8] = n.y1, x[u + 12] = n.x2, x[u + 13] = n.y2, x[u + 17] = n.x3, x[u + 18] = n.y3; var S = t.tint;
            v[u + 4] = v[u + 9] = v[u + 14] = v[u + 19] = (S >> 16) + (65280 & S) + ((255 & S) << 16) + (255 * t.worldAlpha << 24), this.sprites[this.currentBatchSize++] = t } }, e.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) { var i = t.tilingTexture;
        this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture), t._uvs || (t._uvs = new e.TextureUvs); var o = t._uvs,
            n = i.baseTexture.width,
            s = i.baseTexture.height;
        t.tilePosition.x %= n * t.tileScaleOffset.x, t.tilePosition.y %= s * t.tileScaleOffset.y; var r = t.tilePosition.x / (n * t.tileScaleOffset.x),
            a = t.tilePosition.y / (s * t.tileScaleOffset.y),
            h = t.width / n / (t.tileScale.x * t.tileScaleOffset.x),
            l = t.height / s / (t.tileScale.y * t.tileScaleOffset.y);
        o.x0 = 0 - r, o.y0 = 0 - a, o.x1 = 1 * h - r, o.y1 = 0 - a, o.x2 = 1 * h - r, o.y2 = 1 * l - a, o.x3 = 0 - r, o.y3 = 1 * l - a; var c = t.tint,
            d = (c >> 16) + (65280 & c) + ((255 & c) << 16) + (255 * t.worldAlpha << 24),
            u = this.positions,
            p = this.colors,
            m = t.width,
            f = t.height,
            y = t.anchor.x,
            b = t.anchor.y,
            g = m * (1 - y),
            _ = m * -y,
            v = f * (1 - b),
            x = f * -b,
            S = 4 * this.currentBatchSize * this.vertSize,
            C = i.baseTexture.resolution,
            w = t.worldTransform,
            A = w.a / C,
            T = w.b / C,
            P = w.c / C,
            k = w.d / C,
            M = w.tx,
            E = w.ty;
        u[S++] = A * _ + P * x + M, u[S++] = k * x + T * _ + E, u[S++] = o.x0, u[S++] = o.y0, p[S++] = d, u[S++] = A * g + P * x + M, u[S++] = k * x + T * g + E, u[S++] = o.x1, u[S++] = o.y1, p[S++] = d, u[S++] = A * g + P * v + M, u[S++] = k * v + T * g + E, u[S++] = o.x2, u[S++] = o.y2, p[S++] = d, u[S++] = A * _ + P * v + M, u[S++] = k * v + T * _ + E, u[S++] = o.x3, u[S++] = o.y3, p[S++] = d, this.sprites[this.currentBatchSize++] = t }, e.WebGLSpriteBatch.prototype.flush = function() { if (0 !== this.currentBatchSize) { var t, i = this.gl; if (this.dirty) { this.dirty = !1, i.activeTexture(i.TEXTURE0), i.bindBuffer(i.ARRAY_BUFFER, this.vertexBuffer), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t = this.defaultShader.shaders[i.id]; var o = 4 * this.vertSize;
                i.vertexAttribPointer(t.aVertexPosition, 2, i.FLOAT, !1, o, 0), i.vertexAttribPointer(t.aTextureCoord, 2, i.FLOAT, !1, o, 8), i.vertexAttribPointer(t.colorAttribute, 4, i.UNSIGNED_BYTE, !0, o, 16) } if (this.currentBatchSize > .5 * this.size) i.bufferSubData(i.ARRAY_BUFFER, 0, this.vertices);
            else { var n = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                i.bufferSubData(i.ARRAY_BUFFER, 0, n) } for (var s, r, a, h, l = 0, c = 0, d = null, u = this.renderSession.blendModeManager.currentBlendMode, p = null, m = !1, f = !1, y = 0, b = this.currentBatchSize; y < b; y++) { s = (h = this.sprites[y]).tilingTexture ? h.tilingTexture.baseTexture : h.texture.baseTexture, m = u !== (r = h.blendMode), f = p !== (a = h.shader || this.defaultShader); var g = s.skipRender; if (g && h.children.length > 0 && (g = !1), (d !== s && !g || m || f) && (this.renderBatch(d, l, c), c = y, l = 0, d = s, m && (u = r, this.renderSession.blendModeManager.setBlendMode(u)), f)) {
                    (t = (p = a).shaders[i.id]) || ((t = new e.PixiShader(i)).fragmentSrc = p.fragmentSrc, t.uniforms = p.uniforms, t.init(), p.shaders[i.id] = t), this.renderSession.shaderManager.setShader(t), t.dirty && t.syncUniforms(); var _ = this.renderSession.projection;
                    i.uniform2f(t.projectionVector, _.x, _.y); var v = this.renderSession.offset;
                    i.uniform2f(t.offsetVector, v.x, v.y) } l++ } this.renderBatch(d, l, c), this.currentBatchSize = 0 } }, e.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) { if (0 !== e) { var o = this.gl; if (t._dirty[o.id]) { if (!this.renderSession.renderer.updateTexture(t)) return } else o.bindTexture(o.TEXTURE_2D, t._glTextures[o.id]);
            o.drawElements(o.TRIANGLES, 6 * e, o.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++ } }, e.WebGLSpriteBatch.prototype.stop = function() { this.flush(), this.dirty = !0 }, e.WebGLSpriteBatch.prototype.start = function() { this.dirty = !0 }, e.WebGLSpriteBatch.prototype.destroy = function() { this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null }, e.WebGLFastSpriteBatch = function(t) { this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize; var i = 4 * this.size * this.vertSize,
            o = 6 * this.maxSize;
        this.vertices = new e.Float32Array(i), this.indices = new e.Uint16Array(o), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0; for (var n = 0, s = 0; n < o; n += 6, s += 4) this.indices[n + 0] = s + 0, this.indices[n + 1] = s + 1, this.indices[n + 2] = s + 2, this.indices[n + 3] = s + 0, this.indices[n + 4] = s + 2, this.indices[n + 5] = s + 3;
        this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t) }, e.WebGLFastSpriteBatch.prototype.constructor = e.WebGLFastSpriteBatch, e.WebGLFastSpriteBatch.prototype.setContext = function(t) { this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW) }, e.WebGLFastSpriteBatch.prototype.begin = function(t, e) { this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start() }, e.WebGLFastSpriteBatch.prototype.end = function() { this.flush() }, e.WebGLFastSpriteBatch.prototype.render = function(t) { var e = t.children,
            i = e[0]; if (i.texture._uvs) { this.currentBaseTexture = i.texture.baseTexture, i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(i.blendMode)); for (var o = 0, n = e.length; o < n; o++) this.renderSprite(e[o]);
            this.flush() } }, e.WebGLFastSpriteBatch.prototype.renderSprite = function(t) { if (t.visible && (t.texture.baseTexture === this.currentBaseTexture || t.texture.baseTexture.skipRender || (this.flush(), this.currentBaseTexture = t.texture.baseTexture, t.texture._uvs))) { var e, i, o, n, s, r, a = this.vertices; if (e = t.texture._uvs, t.texture.frame.width, t.texture.frame.height, t.texture.trim) { var h = t.texture.trim;
                i = (o = h.x - t.anchor.x * h.width) + t.texture.crop.width, n = (s = h.y - t.anchor.y * h.height) + t.texture.crop.height } else i = t.texture.frame.width * (1 - t.anchor.x), o = t.texture.frame.width * -t.anchor.x, n = t.texture.frame.height * (1 - t.anchor.y), s = t.texture.frame.height * -t.anchor.y;
            r = 4 * this.currentBatchSize * this.vertSize, a[r++] = o, a[r++] = s, a[r++] = t.position.x, a[r++] = t.position.y, a[r++] = t.scale.x, a[r++] = t.scale.y, a[r++] = t.rotation, a[r++] = e.x0, a[r++] = e.y1, a[r++] = t.alpha, a[r++] = i, a[r++] = s, a[r++] = t.position.x, a[r++] = t.position.y, a[r++] = t.scale.x, a[r++] = t.scale.y, a[r++] = t.rotation, a[r++] = e.x1, a[r++] = e.y1, a[r++] = t.alpha, a[r++] = i, a[r++] = n, a[r++] = t.position.x, a[r++] = t.position.y, a[r++] = t.scale.x, a[r++] = t.scale.y, a[r++] = t.rotation, a[r++] = e.x2, a[r++] = e.y2, a[r++] = t.alpha, a[r++] = o, a[r++] = n, a[r++] = t.position.x, a[r++] = t.position.y, a[r++] = t.scale.x, a[r++] = t.scale.y, a[r++] = t.rotation, a[r++] = e.x3, a[r++] = e.y3, a[r++] = t.alpha, ++this.currentBatchSize >= this.size && this.flush() } }, e.WebGLFastSpriteBatch.prototype.flush = function() { if (0 !== this.currentBatchSize) { var t = this.gl; if (this.currentBaseTexture._glTextures[t.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, t), t.bindTexture(t.TEXTURE_2D, this.currentBaseTexture._glTextures[t.id]), this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
            else { var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                t.bufferSubData(t.ARRAY_BUFFER, 0, e) } t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++ } }, e.WebGLFastSpriteBatch.prototype.stop = function() { this.flush() }, e.WebGLFastSpriteBatch.prototype.start = function() { var t = this.gl;
        t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer); var e = this.renderSession.projection;
        t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix); var i = 4 * this.vertSize;
        t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36) }, e.WebGLFilterManager = function() { this.filterStack = [], this.offsetX = 0, this.offsetY = 0 }, e.WebGLFilterManager.prototype.constructor = e.WebGLFilterManager, e.WebGLFilterManager.prototype.setContext = function(t) { this.gl = t, this.texturePool = [], this.initShaderBuffers() }, e.WebGLFilterManager.prototype.begin = function(t, e) { this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader; var i = this.renderSession.projection;
        this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e }, e.WebGLFilterManager.prototype.pushFilter = function(t) { var i = this.gl,
            o = this.renderSession.projection,
            n = this.renderSession.offset;
        t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new e.WebGLStencilManager, this.renderSession.stencilManager.setContext(i), i.disable(i.STENCIL_TEST), this.filterStack.push(t); var s = t.filterPasses[0];
        this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y; var r = this.texturePool.pop();
        r ? r.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : r = new e.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), i.bindTexture(i.TEXTURE_2D, r.texture); var a = t._filterArea,
            h = s.padding;
        a.x -= h, a.y -= h, a.width += 2 * h, a.height += 2 * h, a.x < 0 && (a.x = 0), a.width > this.width && (a.width = this.width), a.y < 0 && (a.y = 0), a.height > this.height && (a.height = this.height), i.bindFramebuffer(i.FRAMEBUFFER, r.frameBuffer), i.viewport(0, 0, a.width * this.renderSession.resolution, a.height * this.renderSession.resolution), o.x = a.width / 2, o.y = -a.height / 2, n.x = -a.x, n.y = -a.y, i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.clear(i.COLOR_BUFFER_BIT), t._glFilterTexture = r }, e.WebGLFilterManager.prototype.popFilter = function() { var t = this.gl,
            i = this.filterStack.pop(),
            o = i._filterArea,
            n = i._glFilterTexture,
            s = this.renderSession.projection,
            r = this.renderSession.offset; if (i.filterPasses.length > 1) { t.viewport(0, 0, o.width * this.renderSession.resolution, o.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = o.height, this.vertexArray[2] = o.width, this.vertexArray[3] = o.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = o.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = o.width / this.width, this.uvArray[5] = o.height / this.height, this.uvArray[6] = o.width / this.width, this.uvArray[7] = o.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray); var a = n,
                h = this.texturePool.pop();
            h || (h = new e.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), h.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND); for (var l = 0; l < i.filterPasses.length - 1; l++) { var c = i.filterPasses[l];
                t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, a.texture), this.applyFilterPass(c, o, o.width, o.height); var d = a;
                a = h, h = d } t.enable(t.BLEND), n = a, this.texturePool.push(h) } var u = i.filterPasses[i.filterPasses.length - 1];
        this.offsetX -= o.x, this.offsetY -= o.y; var p = this.width,
            m = this.height,
            f = 0,
            y = 0,
            b = this.buffer; if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
        else { var g = this.filterStack[this.filterStack.length - 1];
            p = (o = g._filterArea).width, m = o.height, f = o.x, y = o.y, b = g._glFilterTexture.frameBuffer } s.x = p / 2, s.y = -m / 2, r.x = f, r.y = y; var _ = (o = i._filterArea).x - f,
            v = o.y - y;
        t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = _, this.vertexArray[1] = v + o.height, this.vertexArray[2] = _ + o.width, this.vertexArray[3] = v + o.height, this.vertexArray[4] = _, this.vertexArray[5] = v, this.vertexArray[6] = _ + o.width, this.vertexArray[7] = v, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = o.width / this.width, this.uvArray[5] = o.height / this.height, this.uvArray[6] = o.width / this.width, this.uvArray[7] = o.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, p * this.renderSession.resolution, m * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, b), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = i._previous_stencil_mgr, i._previous_stencil_mgr = null, this.renderSession.stencilManager.count > 0 ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(u, o, p, m), this.texturePool.push(n), i._glFilterTexture = null }, e.WebGLFilterManager.prototype.applyFilterPass = function(t, i, o, n) { var s = this.gl,
            r = t.shaders[s.id];
        r || ((r = new e.PixiShader(s)).fragmentSrc = t.fragmentSrc, r.uniforms = t.uniforms, r.init(), t.shaders[s.id] = r), this.renderSession.shaderManager.setShader(r), s.uniform2f(r.projectionVector, o / 2, -n / 2), s.uniform2f(r.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), r.syncUniforms(), s.bindBuffer(s.ARRAY_BUFFER, this.vertexBuffer), s.vertexAttribPointer(r.aVertexPosition, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, this.uvBuffer), s.vertexAttribPointer(r.aTextureCoord, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ARRAY_BUFFER, this.colorBuffer), s.vertexAttribPointer(r.colorAttribute, 2, s.FLOAT, !1, 0, 0), s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, this.indexBuffer), s.drawElements(s.TRIANGLES, 6, s.UNSIGNED_SHORT, 0), this.renderSession.drawCount++ }, e.WebGLFilterManager.prototype.initShaderBuffers = function() { var t = this.gl;
        this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new e.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new e.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new e.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW) }, e.WebGLFilterManager.prototype.destroy = function() { var t = this.gl;
        this.filterStack = null, this.offsetX = 0, this.offsetY = 0; for (var e = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
        this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer) }, e.FilterTexture = function(t, i, o, n) { this.gl = t, this.frameBuffer = t.createFramebuffer(), this.texture = t.createTexture(), n = n || e.scaleModes.DEFAULT, t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, n === e.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, n === e.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0), this.renderBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this.renderBuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer), this.resize(i, o) }, e.FilterTexture.prototype.constructor = e.FilterTexture, e.FilterTexture.prototype.clear = function() { var t = this.gl;
        t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT) }, e.FilterTexture.prototype.resize = function(t, e) { if (this.width !== t || this.height !== e) { this.width = t, this.height = e; var i = this.gl;
            i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e) } }, e.FilterTexture.prototype.destroy = function() { var t = this.gl;
        t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null }, e.CanvasBuffer = function(t, i) { this.width = t, this.height = i, this.canvas = e.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = i }, e.CanvasBuffer.prototype.constructor = e.CanvasBuffer, e.CanvasBuffer.prototype.clear = function() { this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height) }, e.CanvasBuffer.prototype.resize = function(t, e) { this.width = this.canvas.width = t, this.height = this.canvas.height = e }, e.CanvasBuffer.prototype.destroy = function() { e.CanvasPool.remove(this) }, e.CanvasMaskManager = function() {}, e.CanvasMaskManager.prototype.constructor = e.CanvasMaskManager, e.CanvasMaskManager.prototype.pushMask = function(t, i) { var o = i.context;
        o.save(); var n = t.alpha,
            s = t.worldTransform,
            r = i.resolution;
        o.setTransform(s.a * r, s.b * r, s.c * r, s.d * r, s.tx * r, s.ty * r), e.CanvasGraphics.renderGraphicsMask(t, o), o.clip(), t.worldAlpha = n }, e.CanvasMaskManager.prototype.popMask = function(t) { t.context.restore() }, e.CanvasTinter = function() {}, e.CanvasTinter.getTintedTexture = function(t, i) { var o = t.tintedTexture || e.CanvasPool.create(this); return e.CanvasTinter.tintMethod(t.texture, i, o), o }, e.CanvasTinter.tintWithMultiply = function(t, e, i) { var o = i.getContext("2d"),
            n = t.crop;
        i.width === n.width && i.height === n.height || (i.width = n.width, i.height = n.height), o.clearRect(0, 0, n.width, n.height), o.fillStyle = "#" + ("00000" + (0 | e).toString(16)).substr(-6), o.fillRect(0, 0, n.width, n.height), o.globalCompositeOperation = "multiply", o.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), o.globalCompositeOperation = "destination-atop", o.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height) }, e.CanvasTinter.tintWithPerPixel = function(t, i, o) { var n = o.getContext("2d"),
            s = t.crop;
        o.width = s.width, o.height = s.height, n.globalCompositeOperation = "copy", n.drawImage(t.baseTexture.source, s.x, s.y, s.width, s.height, 0, 0, s.width, s.height); for (var r = e.hex2rgb(i), a = r[0], h = r[1], l = r[2], c = n.getImageData(0, 0, s.width, s.height), d = c.data, u = 0; u < d.length; u += 4)
            if (d[u + 0] *= a, d[u + 1] *= h, d[u + 2] *= l, !e.CanvasTinter.canHandleAlpha) { var p = d[u + 3];
                d[u + 0] /= 255 / p, d[u + 1] /= 255 / p, d[u + 2] /= 255 / p } n.putImageData(c, 0, 0) }, e.CanvasTinter.checkInverseAlpha = function() { var t = new e.CanvasBuffer(2, 1);
        t.context.fillStyle = "rgba(10, 20, 30, 0.5)", t.context.fillRect(0, 0, 1, 1); var i = t.context.getImageData(0, 0, 1, 1); if (null === i) return !1;
        t.context.putImageData(i, 1, 0); var o = t.context.getImageData(1, 0, 1, 1); return o.data[0] === i.data[0] && o.data[1] === i.data[1] && o.data[2] === i.data[2] && o.data[3] === i.data[3] }, e.CanvasTinter.canHandleAlpha = e.CanvasTinter.checkInverseAlpha(), e.CanvasTinter.canUseMultiply = e.canUseNewCanvasBlendModes(), e.CanvasTinter.tintMethod = e.CanvasTinter.canUseMultiply ? e.CanvasTinter.tintWithMultiply : e.CanvasTinter.tintWithPerPixel, e.CanvasRenderer = function(t) { this.game = t, e.defaultRenderer || (e.defaultRenderer = this), this.type = e.CANVAS_RENDERER, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", { alpha: this.transparent }), this.refresh = !0, this.count = 0, this.maskManager = new e.CanvasMaskManager, this.renderSession = { context: this.context, maskManager: this.maskManager, scaleMode: null, smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context), roundPixels: !1 }, this.mapBlendModes(), this.resize(this.width, this.height) }, e.CanvasRenderer.prototype.constructor = e.CanvasRenderer, e.CanvasRenderer.prototype.render = function(t) { this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t) }, e.CanvasRenderer.prototype.destroy = function(t) { void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null }, e.CanvasRenderer.prototype.resize = function(t, i) { this.width = t * this.resolution, this.height = i * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === e.scaleModes.LINEAR) }, e.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) { this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i) }, e.CanvasRenderer.prototype.mapBlendModes = function() { if (!e.blendModesCanvas) { var t = [],
                i = e.blendModes,
                o = e.canUseNewCanvasBlendModes();
            t[i.NORMAL] = "source-over", t[i.ADD] = "lighter", t[i.MULTIPLY] = o ? "multiply" : "source-over", t[i.SCREEN] = o ? "screen" : "source-over", t[i.OVERLAY] = o ? "overlay" : "source-over", t[i.DARKEN] = o ? "darken" : "source-over", t[i.LIGHTEN] = o ? "lighten" : "source-over", t[i.COLOR_DODGE] = o ? "color-dodge" : "source-over", t[i.COLOR_BURN] = o ? "color-burn" : "source-over", t[i.HARD_LIGHT] = o ? "hard-light" : "source-over", t[i.SOFT_LIGHT] = o ? "soft-light" : "source-over", t[i.DIFFERENCE] = o ? "difference" : "source-over", t[i.EXCLUSION] = o ? "exclusion" : "source-over", t[i.HUE] = o ? "hue" : "source-over", t[i.SATURATION] = o ? "saturation" : "source-over", t[i.COLOR] = o ? "color" : "source-over", t[i.LUMINOSITY] = o ? "luminosity" : "source-over", e.blendModesCanvas = t } }, e.BaseTexture = function(t, i) { this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = i || e.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1) }, e.BaseTexture.prototype.constructor = e.BaseTexture, e.BaseTexture.prototype.forceLoaded = function(t, e) { this.hasLoaded = !0, this.width = t, this.height = e, this.dirty() }, e.BaseTexture.prototype.destroy = function() { this.source && e.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU() }, e.BaseTexture.prototype.updateSourceImage = function(t) {}, e.BaseTexture.prototype.dirty = function() { for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0 }, e.BaseTexture.prototype.unloadFromGPU = function() { this.dirty(); for (var t = this._glTextures.length - 1; t >= 0; t--) { var i = this._glTextures[t],
                o = e.glContexts[t];
            o && i && o.deleteTexture(i) } this._glTextures.length = 0, this.dirty() }, e.BaseTexture.fromCanvas = function(t, i) { return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), new e.BaseTexture(t, i) }, e.TextureSilentFail = !1, e.Texture = function(t, i, o, n) { this.noFrame = !1, i || (this.noFrame = !0, i = new e.Rectangle(0, 0, 1, 1)), t instanceof e.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = i, this.trim = n, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = o || new e.Rectangle(0, 0, 1, 1), t.hasLoaded && (this.noFrame && (i = new e.Rectangle(0, 0, t.width, t.height)), this.setFrame(i)) }, e.Texture.prototype.constructor = e.Texture, e.Texture.prototype.onBaseTextureLoaded = function() { var t = this.baseTexture;
        this.noFrame && (this.frame = new e.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame) }, e.Texture.prototype.destroy = function(t) { t && this.baseTexture.destroy(), this.valid = !1 }, e.Texture.prototype.setFrame = function(t) { if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, this.trim || !(t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs();
        else { if (!e.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
            this.valid = !1 } }, e.Texture.prototype._updateUvs = function() { this._uvs || (this._uvs = new e.TextureUvs); var t = this.crop,
            i = this.baseTexture.width,
            o = this.baseTexture.height;
        this._uvs.x0 = t.x / i, this._uvs.y0 = t.y / o, this._uvs.x1 = (t.x + t.width) / i, this._uvs.y1 = t.y / o, this._uvs.x2 = (t.x + t.width) / i, this._uvs.y2 = (t.y + t.height) / o, this._uvs.x3 = t.x / i, this._uvs.y3 = (t.y + t.height) / o }, e.Texture.fromCanvas = function(t, i) { var o = e.BaseTexture.fromCanvas(t, i); return new e.Texture(o) }, e.TextureUvs = function() { this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0 }, e.RenderTexture = function(t, i, o, n, s) { if (this.width = t || 100, this.height = i || 100, this.resolution = s || 1, this.frame = new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.baseTexture = new e.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = n || e.scaleModes.DEFAULT, this.baseTexture.hasLoaded = !0, e.Texture.call(this, this.baseTexture, new e.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), this.renderer = o || e.defaultRenderer, this.renderer.type === e.WEBGL_RENDERER) { var r = this.renderer.gl;
            this.baseTexture._dirty[r.id] = !1, this.textureBuffer = new e.FilterTexture(r, this.width, this.height, this.baseTexture.scaleMode), this.baseTexture._glTextures[r.id] = this.textureBuffer.texture, this.render = this.renderWebGL, this.projection = new e.Point(.5 * this.width, .5 * -this.height) } else this.render = this.renderCanvas, this.textureBuffer = new e.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
        this.valid = !0, this.tempMatrix = new Phaser.Matrix, this._updateUvs() }, e.RenderTexture.prototype = Object.create(e.Texture.prototype), e.RenderTexture.prototype.constructor = e.RenderTexture, e.RenderTexture.prototype.resize = function(t, i, o) { t === this.width && i === this.height || (this.valid = t > 0 && i > 0, this.width = t, this.height = i, this.frame.width = this.crop.width = t * this.resolution, this.frame.height = this.crop.height = i * this.resolution, o && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === e.WEBGL_RENDERER && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height)) }, e.RenderTexture.prototype.clear = function() { this.valid && (this.renderer.type === e.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear()) }, e.RenderTexture.prototype.renderWebGL = function(t, e, i) { if (this.valid && 0 !== t.alpha) { var o = t.worldTransform;
            o.identity(), o.translate(0, 2 * this.projection.y), e && o.append(e), o.scale(1, -1); for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform(); var s = this.renderer.gl;
            s.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), s.bindFramebuffer(s.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e), this.renderer.spriteBatch.dirty = !0 } }, e.RenderTexture.prototype.renderCanvas = function(t, e, i) { if (this.valid && 0 !== t.alpha) { var o = t.worldTransform;
            o.identity(), e && o.append(e); for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
            i && this.textureBuffer.clear(); var s = this.renderer.resolution;
            this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = s } }, e.RenderTexture.prototype.getImage = function() { var t = new Image; return t.src = this.getBase64(), t }, e.RenderTexture.prototype.getBase64 = function() { return this.getCanvas().toDataURL() }, e.RenderTexture.prototype.getCanvas = function() { if (this.renderer.type === e.WEBGL_RENDERER) { var t = this.renderer.gl,
                i = this.textureBuffer.width,
                o = this.textureBuffer.height,
                n = new Uint8Array(4 * i * o);
            t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer), t.readPixels(0, 0, i, o, t.RGBA, t.UNSIGNED_BYTE, n), t.bindFramebuffer(t.FRAMEBUFFER, null); var s = new e.CanvasBuffer(i, o),
                r = s.context.getImageData(0, 0, i, o); return r.data.set(n), s.context.putImageData(r, 0, 0), s.canvas } return this.textureBuffer.canvas }, e.AbstractFilter = function(t, e) { this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = e || {}, this.fragmentSrc = t || [] }, e.AbstractFilter.prototype.constructor = e.AbstractFilter, e.AbstractFilter.prototype.syncUniforms = function() { for (var t = 0, e = this.shaders.length; t < e; t++) this.shaders[t].dirty = !0 }, e.Strip = function(t) { e.DisplayObjectContainer.call(this), this.texture = t, this.uvs = new e.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = new e.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new e.Float32Array([1, 1, 1, 1]), this.indices = new e.Uint16Array([0, 1, 2, 3]), this.dirty = !0, this.blendMode = e.blendModes.NORMAL, this.canvasPadding = 0, this.drawMode = e.Strip.DrawModes.TRIANGLE_STRIP }, e.Strip.prototype = Object.create(e.DisplayObjectContainer.prototype), e.Strip.prototype.constructor = e.Strip, e.Strip.prototype._renderWebGL = function(t) {!this.visible || this.alpha <= 0 || (t.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(t), t.shaderManager.setShader(t.shaderManager.stripShader), this._renderStrip(t), t.spriteBatch.start()) }, e.Strip.prototype._initWebGL = function(t) { var e = t.gl;
        this._vertexBuffer = e.createBuffer(), this._indexBuffer = e.createBuffer(), this._uvBuffer = e.createBuffer(), this._colorBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer), e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW) }, e.Strip.prototype._renderStrip = function(t) { var i = t.gl,
            o = t.projection,
            n = t.offset,
            s = t.shaderManager.stripShader,
            r = this.drawMode === e.Strip.DrawModes.TRIANGLE_STRIP ? i.TRIANGLE_STRIP : i.TRIANGLES;
        t.blendModeManager.setBlendMode(this.blendMode), i.uniformMatrix3fv(s.translationMatrix, !1, this.worldTransform.toArray(!0)), i.uniform2f(s.projectionVector, o.x, -o.y), i.uniform2f(s.offsetVector, -n.x, -n.y), i.uniform1f(s.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferData(i.ARRAY_BUFFER, this.vertices, i.STATIC_DRAW), i.vertexAttribPointer(s.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.bufferData(i.ARRAY_BUFFER, this.uvs, i.STATIC_DRAW), i.vertexAttribPointer(s.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? t.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer), i.bufferData(i.ELEMENT_ARRAY_BUFFER, this.indices, i.STATIC_DRAW)) : (i.bindBuffer(i.ARRAY_BUFFER, this._vertexBuffer), i.bufferSubData(i.ARRAY_BUFFER, 0, this.vertices), i.vertexAttribPointer(s.aVertexPosition, 2, i.FLOAT, !1, 0, 0), i.bindBuffer(i.ARRAY_BUFFER, this._uvBuffer), i.vertexAttribPointer(s.aTextureCoord, 2, i.FLOAT, !1, 0, 0), i.activeTexture(i.TEXTURE0), this.texture.baseTexture._dirty[i.id] ? t.renderer.updateTexture(this.texture.baseTexture) : i.bindTexture(i.TEXTURE_2D, this.texture.baseTexture._glTextures[i.id]), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), i.drawElements(r, this.indices.length, i.UNSIGNED_SHORT, 0) }, e.Strip.prototype._renderCanvas = function(t) { var i = t.context,
            o = this.worldTransform,
            n = o.tx * t.resolution + t.shakeX,
            s = o.ty * t.resolution + t.shakeY;
        t.roundPixels ? i.setTransform(o.a, o.b, o.c, o.d, 0 | n, 0 | s) : i.setTransform(o.a, o.b, o.c, o.d, n, s), this.drawMode === e.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(i) : this._renderCanvasTriangles(i) }, e.Strip.prototype._renderCanvasTriangleStrip = function(t) { var e = this.vertices,
            i = this.uvs,
            o = e.length / 2;
        this.count++; for (var n = 0; n < o - 2; n++) { var s = 2 * n;
            this._renderCanvasDrawTriangle(t, e, i, s, s + 2, s + 4) } }, e.Strip.prototype._renderCanvasTriangles = function(t) { var e = this.vertices,
            i = this.uvs,
            o = this.indices,
            n = o.length;
        this.count++; for (var s = 0; s < n; s += 3) { var r = 2 * o[s],
                a = 2 * o[s + 1],
                h = 2 * o[s + 2];
            this._renderCanvasDrawTriangle(t, e, i, r, a, h) } }, e.Strip.prototype._renderCanvasDrawTriangle = function(t, e, i, o, n, s) { var r = this.texture.baseTexture.source,
            a = this.texture.width,
            h = this.texture.height,
            l = e[o],
            c = e[n],
            d = e[s],
            u = e[o + 1],
            p = e[n + 1],
            m = e[s + 1],
            f = i[o] * a,
            y = i[n] * a,
            b = i[s] * a,
            g = i[o + 1] * h,
            _ = i[n + 1] * h,
            v = i[s + 1] * h; if (this.canvasPadding > 0) { var x = this.canvasPadding / this.worldTransform.a,
                S = this.canvasPadding / this.worldTransform.d,
                C = (l + c + d) / 3,
                w = (u + p + m) / 3,
                A = l - C,
                T = u - w,
                P = Math.sqrt(A * A + T * T);
            l = C + A / P * (P + x), u = w + T / P * (P + S), T = p - w, c = C + (A = c - C) / (P = Math.sqrt(A * A + T * T)) * (P + x), p = w + T / P * (P + S), T = m - w, d = C + (A = d - C) / (P = Math.sqrt(A * A + T * T)) * (P + x), m = w + T / P * (P + S) } t.save(), t.beginPath(), t.moveTo(l, u), t.lineTo(c, p), t.lineTo(d, m), t.closePath(), t.clip(); var k = f * _ + g * b + y * v - _ * b - g * y - f * v,
            M = l * _ + g * d + c * v - _ * d - g * c - l * v,
            E = f * c + l * b + y * d - c * b - l * y - f * d,
            B = f * _ * d + g * c * b + l * y * v - l * _ * b - g * y * d - f * c * v,
            I = u * _ + g * m + p * v - _ * m - g * p - u * v,
            D = f * p + u * b + y * m - p * b - u * y - f * m,
            L = f * _ * m + g * p * b + u * y * v - u * _ * b - g * y * m - f * p * v;
        t.transform(M / k, I / k, E / k, D / k, B / k, L / k), t.drawImage(r, 0, 0), t.restore() }, e.Strip.prototype.renderStripFlat = function(t) { var e = this.context,
            i = t.vertices,
            o = i.length / 2;
        this.count++, e.beginPath(); for (var n = 1; n < o - 2; n++) { var s = 2 * n,
                r = i[s],
                a = i[s + 2],
                h = i[s + 4],
                l = i[s + 1],
                c = i[s + 3],
                d = i[s + 5];
            e.moveTo(r, l), e.lineTo(a, c), e.lineTo(h, d) } e.fillStyle = "#FF0000", e.fill(), e.closePath() }, e.Strip.prototype.onTextureUpdate = function() { this.updateFrame = !0 }, e.Strip.prototype.getBounds = function(t) { for (var i = t || this.worldTransform, o = i.a, n = i.b, s = i.c, r = i.d, a = i.tx, h = i.ty, l = -1 / 0, c = -1 / 0, d = 1 / 0, u = 1 / 0, p = this.vertices, m = 0, f = p.length; m < f; m += 2) { var y = p[m],
                b = p[m + 1],
                g = o * y + s * b + a,
                _ = r * b + n * y + h;
            d = g < d ? g : d, u = _ < u ? _ : u, l = g > l ? g : l, c = _ > c ? _ : c } if (d === -1 / 0 || c === 1 / 0) return e.EmptyRectangle; var v = this._bounds; return v.x = d, v.width = l - d, v.y = u, v.height = c - u, this._currentBounds = v, v }, e.Strip.DrawModes = { TRIANGLE_STRIP: 0, TRIANGLES: 1 }, e.Rope = function(t, i) { e.Strip.call(this, t), this.points = i, this.vertices = new e.Float32Array(4 * i.length), this.uvs = new e.Float32Array(4 * i.length), this.colors = new e.Float32Array(2 * i.length), this.indices = new e.Uint16Array(2 * i.length), this.refresh() }, e.Rope.prototype = Object.create(e.Strip.prototype), e.Rope.prototype.constructor = e.Rope, e.Rope.prototype.refresh = function() { var t = this.points; if (!(t.length < 1)) { var e = this.uvs,
                i = (t[0], this.indices),
                o = this.colors;
            this.count -= .2, e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, o[0] = 1, o[1] = 1, i[0] = 0, i[1] = 1; for (var n, s, r, a = t.length, h = 1; h < a; h++) n = t[h], r = h / (a - 1), e[s = 4 * h] = r, e[s + 1] = 0, e[s + 2] = r, e[s + 3] = 1, o[s = 2 * h] = 1, o[s + 1] = 1, i[s = 2 * h] = s, i[s + 1] = s + 1, n } }, e.Rope.prototype.updateTransform = function() { var t = this.points; if (!(t.length < 1)) { var i, o = t[0],
                n = { x: 0, y: 0 };
            this.count -= .2; for (var s, r, a, h, l = this.vertices, c = t.length, d = 0; d < c; d++) s = t[d], r = 4 * d, i = d < t.length - 1 ? t[d + 1] : s, n.y = -(i.x - o.x), n.x = i.y - o.y, 10 * (1 - d / (c - 1)) > 1 && 1, a = Math.sqrt(n.x * n.x + n.y * n.y), h = this.texture.height / 2, n.x /= a, n.y /= a, n.x *= h, n.y *= h, l[r] = s.x + n.x, l[r + 1] = s.y + n.y, l[r + 2] = s.x - n.x, l[r + 3] = s.y - n.y, o = s;
            e.DisplayObjectContainer.prototype.updateTransform.call(this) } }, e.Rope.prototype.setTexture = function(t) { this.texture = t }, e.TilingSprite = function(t, i, o) { e.Sprite.call(this, t), this._width = i || 128, this._height = o || 128, this.tileScale = new e.Point(1, 1), this.tileScaleOffset = new e.Point(1, 1), this.tilePosition = new e.Point, this.renderable = !0, this.tint = 16777215, this.textureDebug = !1, this.blendMode = e.blendModes.NORMAL, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0 }, e.TilingSprite.prototype = Object.create(e.Sprite.prototype), e.TilingSprite.prototype.constructor = e.TilingSprite, e.TilingSprite.prototype.setTexture = function(t) { this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215) }, e.TilingSprite.prototype._renderWebGL = function(t) { if (this.visible && this.renderable && 0 !== this.alpha) { if (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) { if (this.generateTilingTexture(!0, t), !this.tilingTexture) return;
                this.tilingTexture.needsUpdate && (t.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1) } t.spriteBatch.renderTilingSprite(this); for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
            t.spriteBatch.stop(), this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this._mask, t), t.spriteBatch.start() } }, e.TilingSprite.prototype._renderCanvas = function(t) { if (this.visible && this.renderable && 0 !== this.alpha) { var i = t.context;
            this._mask && t.maskManager.pushMask(this._mask, t), i.globalAlpha = this.worldAlpha; var o = this.worldTransform,
                n = t.resolution,
                s = o.tx * n + t.shakeX,
                r = o.ty * n + t.shakeY; if (i.setTransform(o.a * n, o.b * n, o.c * n, o.d * n, s, r), this.refreshTexture) { if (this.generateTilingTexture(!1, t), !this.tilingTexture) return;
                this.tilePattern = i.createPattern(this.tilingTexture.baseTexture.source, "repeat") } var a = t.currentBlendMode;
            this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, i.globalCompositeOperation = e.blendModesCanvas[t.currentBlendMode]); var h = this.tilePosition,
                l = this.tileScale;
            h.x %= this.tilingTexture.baseTexture.width, h.y %= this.tilingTexture.baseTexture.height, i.scale(l.x, l.y), i.translate(h.x + this.anchor.x * -this._width, h.y + this.anchor.y * -this._height), i.fillStyle = this.tilePattern; var s = -h.x,
                r = -h.y,
                c = this._width / l.x,
                d = this._height / l.y;
            t.roundPixels && (s |= 0, r |= 0, c |= 0, d |= 0), i.fillRect(s, r, c, d), i.scale(1 / l.x, 1 / l.y), i.translate(-h.x + this.anchor.x * this._width, -h.y + this.anchor.y * this._height), this._mask && t.maskManager.popMask(t); for (var u = 0; u < this.children.length; u++) this.children[u]._renderCanvas(t);
            a !== this.blendMode && (t.currentBlendMode = a, i.globalCompositeOperation = e.blendModesCanvas[a]) } }, e.TilingSprite.prototype.onTextureUpdate = function() {}, e.TilingSprite.prototype.generateTilingTexture = function(t, i) { if (this.texture.baseTexture.hasLoaded) { var o = this.texture,
                n = o.frame,
                s = this._frame.sourceSizeW || this._frame.width,
                r = this._frame.sourceSizeH || this._frame.height,
                a = 0,
                h = 0;
            this._frame.trimmed && (a = this._frame.spriteSourceSizeX, h = this._frame.spriteSourceSizeY), t && (s = e.getNextPowerOfTwo(s), r = e.getNextPowerOfTwo(r)), this.canvasBuffer ? (this.canvasBuffer.resize(s, r), this.tilingTexture.baseTexture.width = s, this.tilingTexture.baseTexture.height = r, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new e.CanvasBuffer(s, r), this.tilingTexture = e.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, s, r)); var l = o.crop.width,
                c = o.crop.height;
            l === s && c === r || (l = s, c = r), this.canvasBuffer.context.drawImage(o.baseTexture.source, o.crop.x, o.crop.y, o.crop.width, o.crop.height, a, h, l, c), this.tileScaleOffset.x = n.width / s, this.tileScaleOffset.y = n.height / r, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0 } }, e.TilingSprite.prototype.getBounds = function() { var t = this._width,
            e = this._height,
            i = t * (1 - this.anchor.x),
            o = t * -this.anchor.x,
            n = e * (1 - this.anchor.y),
            s = e * -this.anchor.y,
            r = this.worldTransform,
            a = r.a,
            h = r.b,
            l = r.c,
            c = r.d,
            d = r.tx,
            u = r.ty,
            p = a * o + l * s + d,
            m = c * s + h * o + u,
            f = a * i + l * s + d,
            y = c * s + h * i + u,
            b = a * i + l * n + d,
            g = c * n + h * i + u,
            _ = a * o + l * n + d,
            v = c * n + h * o + u,
            x = -1 / 0,
            S = -1 / 0,
            C = 1 / 0,
            w = 1 / 0;
        C = _ < (C = b < (C = f < (C = p < C ? p : C) ? f : C) ? b : C) ? _ : C, w = v < (w = g < (w = y < (w = m < w ? m : w) ? y : w) ? g : w) ? v : w, x = _ > (x = b > (x = f > (x = p > x ? p : x) ? f : x) ? b : x) ? _ : x, S = v > (S = g > (S = y > (S = m > S ? m : S) ? y : S) ? g : S) ? v : S; var A = this._bounds; return A.x = C, A.width = x - C, A.y = w, A.height = S - w, this._currentBounds = A, A }, e.TilingSprite.prototype.destroy = function() { e.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null) }, Object.defineProperty(e.TilingSprite.prototype, "width", { get: function() { return this._width }, set: function(t) { this._width = t } }), Object.defineProperty(e.TilingSprite.prototype, "height", { get: function() { return this._height }, set: function(t) { this._height = t } }), "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = e), exports.PIXI = e) : "undefined" != typeof define && define.amd ? define("PIXI", t.PIXI = e) : t.PIXI = e, e }.call(this),
    function() {
        function t(t, e) { this._scaleFactor = t, this._deltaMode = e, this.originalEvent = null } var e = this,
            i = i || { VERSION: "2.6.2", GAMES: [], AUTO: 0, CANVAS: 1, WEBGL: 2, HEADLESS: 3, NONE: 0, LEFT: 1, RIGHT: 2, UP: 3, DOWN: 4, SPRITE: 0, BUTTON: 1, IMAGE: 2, GRAPHICS: 3, TEXT: 4, TILESPRITE: 5, BITMAPTEXT: 6, GROUP: 7, RENDERTEXTURE: 8, TILEMAP: 9, TILEMAPLAYER: 10, EMITTER: 11, POLYGON: 12, BITMAPDATA: 13, CANVAS_FILTER: 14, WEBGL_FILTER: 15, ELLIPSE: 16, SPRITEBATCH: 17, RETROFONT: 18, POINTER: 19, ROPE: 20, CIRCLE: 21, RECTANGLE: 22, LINE: 23, MATRIX: 24, POINT: 25, ROUNDEDRECTANGLE: 26, CREATURE: 27, VIDEO: 28, PENDING_ATLAS: -1, HORIZONTAL: 0, VERTICAL: 1, LANDSCAPE: 0, PORTRAIT: 1, ANGLE_UP: 270, ANGLE_DOWN: 90, ANGLE_LEFT: 180, ANGLE_RIGHT: 0, ANGLE_NORTH_EAST: 315, ANGLE_NORTH_WEST: 225, ANGLE_SOUTH_EAST: 45, ANGLE_SOUTH_WEST: 135, TOP_LEFT: 0, TOP_CENTER: 1, TOP_RIGHT: 2, LEFT_TOP: 3, LEFT_CENTER: 4, LEFT_BOTTOM: 5, CENTER: 6, RIGHT_TOP: 7, RIGHT_CENTER: 8, RIGHT_BOTTOM: 9, BOTTOM_LEFT: 10, BOTTOM_CENTER: 11, BOTTOM_RIGHT: 12, blendModes: { NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5, LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12, HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16 }, scaleModes: { DEFAULT: 0, LINEAR: 0, NEAREST: 1 }, PIXI: PIXI || {} }; if (Math.trunc || (Math.trunc = function(t) { return t < 0 ? Math.ceil(t) : Math.floor(t) }), Function.prototype.bind || (Function.prototype.bind = function() { var t = Array.prototype.slice; return function(e) {
                    function i() { var s = n.concat(t.call(arguments));
                        o.apply(this instanceof i ? this : e, s) } var o = this,
                        n = t.call(arguments, 1); if ("function" != typeof o) throw new TypeError; return i.prototype = function t(e) { if (e && (t.prototype = e), !(this instanceof t)) return new t }(o.prototype), i } }()), Array.isArray || (Array.isArray = function(t) { return "[object Array]" === Object.prototype.toString.call(t) }), Array.prototype.forEach || (Array.prototype.forEach = function(t) { "use strict"; if (void 0 === this || null === this) throw new TypeError; var e = Object(this),
                    i = e.length >>> 0; if ("function" != typeof t) throw new TypeError; for (var o = arguments.length >= 2 ? arguments[1] : void 0, n = 0; n < i; n++) n in e && t.call(o, e[n], n, e) }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) { var o = function(t) { var e = new Array;
                window[t] = function(t) { if ("number" == typeof t) { Array.call(this, t), this.length = t; for (e = 0; e < this.length; e++) this[e] = 0 } else { Array.call(this, t.length), this.length = t.length; for (var e = 0; e < this.length; e++) this[e] = t[e] } }, window[t].prototype = e, window[t].constructor = window[t] };
            o("Uint32Array"), o("Int16Array") } window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), i.Utils = { reverseString: function(t) { return t.split("").reverse().join("") }, getProperty: function(t, e) { for (var i = e.split("."), o = i.pop(), n = i.length, s = 1, r = i[0]; s < n && (t = t[r]);) r = i[s], s++; return t ? t[o] : null }, setProperty: function(t, e, i) { for (var o = e.split("."), n = o.pop(), s = o.length, r = 1, a = o[0]; r < s && (t = t[a]);) a = o[r], r++; return t && (t[n] = i), t }, chanceRoll: function(t) { return void 0 === t && (t = 50), t > 0 && 100 * Math.random() <= t }, randomChoice: function(t, e) { return Math.random() < .5 ? t : e }, parseDimension: function(t, e) { var i = 0,
                    o = 0; return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, o = 0 === e ? window.innerWidth * i : window.innerHeight * i) : o = parseInt(t, 10) : o = t, o }, pad: function(t, e, i, o) { if (void 0 === e) var e = 0; if (void 0 === i) var i = " "; if (void 0 === o) var o = 3; var n = 0; if (e + 1 >= (t = t.toString()).length) switch (o) {
                    case 1:
                        t = new Array(e + 1 - t.length).join(i) + t; break;
                    case 3:
                        var s = Math.ceil((n = e - t.length) / 2),
                            r = n - s;
                        t = new Array(r + 1).join(i) + t + new Array(s + 1).join(i); break;
                    default:
                        t += new Array(e + 1 - t.length).join(i) }
                return t }, isPlainObject: function(t) { if ("object" != typeof t || t.nodeType || t === t.window) return !1; try { if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1 } catch (t) { return !1 } return !0 }, extend: function() { var t, e, o, n, s, r, a = arguments[0] || {},
                    h = 1,
                    l = arguments.length,
                    c = !1; for ("boolean" == typeof a && (c = a, a = arguments[1] || {}, h = 2), l === h && (a = this, --h); h < l; h++)
                    if (null != (t = arguments[h]))
                        for (e in t) o = a[e], a !== (n = t[e]) && (c && n && (i.Utils.isPlainObject(n) || (s = Array.isArray(n))) ? (s ? (s = !1, r = o && Array.isArray(o) ? o : []) : r = o && i.Utils.isPlainObject(o) ? o : {}, a[e] = i.Utils.extend(c, r, n)) : void 0 !== n && (a[e] = n)); return a }, mixinPrototype: function(t, e, i) { void 0 === i && (i = !1); for (var o = Object.keys(e), n = 0; n < o.length; n++) { var s = o[n],
                        r = e[s];!i && s in t || (!r || "function" != typeof r.get && "function" != typeof r.set ? t[s] = r : "function" == typeof r.clone ? t[s] = r.clone() : Object.defineProperty(t, s, r)) } }, mixin: function(t, e) { if (!t || "object" != typeof t) return e; for (var o in t) { var n = t[o]; if (!n.childNodes && !n.cloneNode) { var s = typeof t[o];
                        t[o] && "object" === s ? typeof e[o] === s ? e[o] = i.Utils.mixin(t[o], e[o]) : e[o] = i.Utils.mixin(t[o], new n.constructor) : e[o] = t[o] } } return e } }, i.Circle = function(t, e, o) { t = t || 0, e = e || 0, o = o || 0, this.x = t, this.y = e, this._diameter = o, this._radius = 0, o > 0 && (this._radius = .5 * o), this.type = i.CIRCLE }, i.Circle.prototype = { circumference: function() { return Math.PI * this._radius * 2 }, random: function(t) { void 0 === t && (t = new i.Point); var e = 2 * Math.PI * Math.random(),
                    o = Math.random() + Math.random(),
                    n = o > 1 ? 2 - o : o,
                    s = n * Math.cos(e),
                    r = n * Math.sin(e); return t.x = this.x + s * this.radius, t.y = this.y + r * this.radius, t }, getBounds: function() { return new i.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter) }, setTo: function(t, e, i) { return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this }, copyFrom: function(t) { return this.setTo(t.x, t.y, t.diameter) }, copyTo: function(t) { return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t }, distance: function(t, e) { var o = i.Math.distance(this.x, this.y, t.x, t.y); return e ? Math.round(o) : o }, clone: function(t) { return void 0 === t || null === t ? t = new i.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t }, contains: function(t, e) { return i.Circle.contains(this, t, e) }, circumferencePoint: function(t, e, o) { return i.Circle.circumferencePoint(this, t, e, o) }, offset: function(t, e) { return this.x += t, this.y += e, this }, offsetPoint: function(t) { return this.offset(t.x, t.y) }, toString: function() { return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]" } }, i.Circle.prototype.constructor = i.Circle, Object.defineProperty(i.Circle.prototype, "diameter", { get: function() { return this._diameter }, set: function(t) { t > 0 && (this._diameter = t, this._radius = .5 * t) } }), Object.defineProperty(i.Circle.prototype, "radius", { get: function() { return this._radius }, set: function(t) { t > 0 && (this._radius = t, this._diameter = 2 * t) } }), Object.defineProperty(i.Circle.prototype, "left", { get: function() { return this.x - this._radius }, set: function(t) { t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t } }), Object.defineProperty(i.Circle.prototype, "right", { get: function() { return this.x + this._radius }, set: function(t) { t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x } }), Object.defineProperty(i.Circle.prototype, "top", { get: function() { return this.y - this._radius }, set: function(t) { t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t } }), Object.defineProperty(i.Circle.prototype, "bottom", { get: function() { return this.y + this._radius }, set: function(t) { t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y } }), Object.defineProperty(i.Circle.prototype, "area", { get: function() { return this._radius > 0 ? Math.PI * this._radius * this._radius : 0 } }), Object.defineProperty(i.Circle.prototype, "empty", { get: function() { return 0 === this._diameter }, set: function(t) {!0 === t && this.setTo(0, 0, 0) } }), i.Circle.contains = function(t, e, i) { return t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius }, i.Circle.equals = function(t, e) { return t.x === e.x && t.y === e.y && t.diameter === e.diameter }, i.Circle.intersects = function(t, e) { return i.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius }, i.Circle.circumferencePoint = function(t, e, o, n) { return void 0 === o && (o = !1), void 0 === n && (n = new i.Point), !0 === o && (e = i.Math.degToRad(e)), n.x = t.x + t.radius * Math.cos(e), n.y = t.y + t.radius * Math.sin(e), n }, i.Circle.intersectsRectangle = function(t, e) { var i = Math.abs(t.x - e.x - e.halfWidth); if (i > e.halfWidth + t.radius) return !1; var o = Math.abs(t.y - e.y - e.halfHeight); if (o > e.halfHeight + t.radius) return !1; if (i <= e.halfWidth || o <= e.halfHeight) return !0; var n = i - e.halfWidth,
                s = o - e.halfHeight; return n * n + s * s <= t.radius * t.radius }, PIXI.Circle = i.Circle, i.Ellipse = function(t, e, o, n) { t = t || 0, e = e || 0, o = o || 0, n = n || 0, this.x = t, this.y = e, this.width = o, this.height = n, this.type = i.ELLIPSE }, i.Ellipse.prototype = { setTo: function(t, e, i, o) { return this.x = t, this.y = e, this.width = i, this.height = o, this }, getBounds: function() { return new i.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height) }, copyFrom: function(t) { return this.setTo(t.x, t.y, t.width, t.height) }, copyTo: function(t) { return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t }, clone: function(t) { return void 0 === t || null === t ? t = new i.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t }, contains: function(t, e) { return i.Ellipse.contains(this, t, e) }, random: function(t) { void 0 === t && (t = new i.Point); var e = Math.random() * Math.PI * 2,
                    o = Math.random(); return t.x = Math.sqrt(o) * Math.cos(e), t.y = Math.sqrt(o) * Math.sin(e), t.x = this.x + t.x * this.width / 2, t.y = this.y + t.y * this.height / 2, t }, toString: function() { return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]" } }, i.Ellipse.prototype.constructor = i.Ellipse, Object.defineProperty(i.Ellipse.prototype, "left", { get: function() { return this.x }, set: function(t) { this.x = t } }), Object.defineProperty(i.Ellipse.prototype, "right", { get: function() { return this.x + this.width }, set: function(t) { t < this.x ? this.width = 0 : this.width = t - this.x } }), Object.defineProperty(i.Ellipse.prototype, "top", { get: function() { return this.y }, set: function(t) { this.y = t } }), Object.defineProperty(i.Ellipse.prototype, "bottom", { get: function() { return this.y + this.height }, set: function(t) { t < this.y ? this.height = 0 : this.height = t - this.y } }), Object.defineProperty(i.Ellipse.prototype, "empty", { get: function() { return 0 === this.width || 0 === this.height }, set: function(t) {!0 === t && this.setTo(0, 0, 0, 0) } }), i.Ellipse.contains = function(t, e, i) { if (t.width <= 0 || t.height <= 0) return !1; var o = (e - t.x) / t.width - .5,
                n = (i - t.y) / t.height - .5; return o *= o, n *= n, o + n < .25 }, PIXI.Ellipse = i.Ellipse, i.Line = function(t, e, o, n) { t = t || 0, e = e || 0, o = o || 0, n = n || 0, this.start = new i.Point(t, e), this.end = new i.Point(o, n), this.type = i.LINE }, i.Line.prototype = { setTo: function(t, e, i, o) { return this.start.setTo(t, e), this.end.setTo(i, o), this }, fromSprite: function(t, e, i) { return void 0 === i && (i = !1), i ? this.setTo(t.center.x, t.center.y, e.center.x, e.center.y) : this.setTo(t.x, t.y, e.x, e.y) }, fromAngle: function(t, e, i, o) { return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * o, e + Math.sin(i) * o), this }, rotate: function(t, e) { var i = (this.start.x + this.end.x) / 2,
                    o = (this.start.y + this.end.y) / 2; return this.start.rotate(i, o, t, e), this.end.rotate(i, o, t, e), this }, rotateAround: function(t, e, i, o) { return this.start.rotate(t, e, i, o), this.end.rotate(t, e, i, o), this }, intersects: function(t, e, o) { return i.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, o) }, reflect: function(t) { return i.Line.reflect(this, t) }, midPoint: function(t) { return void 0 === t && (t = new i.Point), t.x = (this.start.x + this.end.x) / 2, t.y = (this.start.y + this.end.y) / 2, t }, centerOn: function(t, e) { var i = t - (this.start.x + this.end.x) / 2,
                    o = e - (this.start.y + this.end.y) / 2;
                this.start.add(i, o), this.end.add(i, o) }, pointOnLine: function(t, e) { return (t - this.start.x) * (this.end.y - this.start.y) == (this.end.x - this.start.x) * (e - this.start.y) }, pointOnSegment: function(t, e) { var i = Math.min(this.start.x, this.end.x),
                    o = Math.max(this.start.x, this.end.x),
                    n = Math.min(this.start.y, this.end.y),
                    s = Math.max(this.start.y, this.end.y); return this.pointOnLine(t, e) && t >= i && t <= o && e >= n && e <= s }, random: function(t) { void 0 === t && (t = new i.Point); var e = Math.random(); return t.x = this.start.x + e * (this.end.x - this.start.x), t.y = this.start.y + e * (this.end.y - this.start.y), t }, coordinatesOnLine: function(t, e) { void 0 === t && (t = 1), void 0 === e && (e = []); var i = Math.round(this.start.x),
                    o = Math.round(this.start.y),
                    n = Math.round(this.end.x),
                    s = Math.round(this.end.y),
                    r = Math.abs(n - i),
                    a = Math.abs(s - o),
                    h = i < n ? 1 : -1,
                    l = o < s ? 1 : -1,
                    c = r - a;
                e.push([i, o]); for (var d = 1; i !== n || o !== s;) { var u = c << 1;
                    u > -a && (c -= a, i += h), u < r && (c += r, o += l), d % t == 0 && e.push([i, o]), d++ } return e }, clone: function(t) { return void 0 === t || null === t ? t = new i.Line(this.start.x, this.start.y, this.end.x, this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y), t } }, Object.defineProperty(i.Line.prototype, "length", { get: function() { return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y)) } }), Object.defineProperty(i.Line.prototype, "angle", { get: function() { return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x) } }), Object.defineProperty(i.Line.prototype, "slope", { get: function() { return (this.end.y - this.start.y) / (this.end.x - this.start.x) } }), Object.defineProperty(i.Line.prototype, "perpSlope", { get: function() { return -(this.end.x - this.start.x) / (this.end.y - this.start.y) } }), Object.defineProperty(i.Line.prototype, "x", { get: function() { return Math.min(this.start.x, this.end.x) } }), Object.defineProperty(i.Line.prototype, "y", { get: function() { return Math.min(this.start.y, this.end.y) } }), Object.defineProperty(i.Line.prototype, "left", { get: function() { return Math.min(this.start.x, this.end.x) } }), Object.defineProperty(i.Line.prototype, "right", { get: function() { return Math.max(this.start.x, this.end.x) } }), Object.defineProperty(i.Line.prototype, "top", { get: function() { return Math.min(this.start.y, this.end.y) } }), Object.defineProperty(i.Line.prototype, "bottom", { get: function() { return Math.max(this.start.y, this.end.y) } }), Object.defineProperty(i.Line.prototype, "width", { get: function() { return Math.abs(this.start.x - this.end.x) } }), Object.defineProperty(i.Line.prototype, "height", { get: function() { return Math.abs(this.start.y - this.end.y) } }), Object.defineProperty(i.Line.prototype, "normalX", { get: function() { return Math.cos(this.angle - 1.5707963267948966) } }), Object.defineProperty(i.Line.prototype, "normalY", { get: function() { return Math.sin(this.angle - 1.5707963267948966) } }), Object.defineProperty(i.Line.prototype, "normalAngle", { get: function() { return i.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI) } }), i.Line.intersectsPoints = function(t, e, o, n, s, r) { void 0 === s && (s = !0), void 0 === r && (r = new i.Point); var a = e.y - t.y,
                h = n.y - o.y,
                l = t.x - e.x,
                c = o.x - n.x,
                d = e.x * t.y - t.x * e.y,
                u = n.x * o.y - o.x * n.y,
                p = a * c - h * l; if (0 === p) return null; if (r.x = (l * u - c * d) / p, r.y = (h * d - a * u) / p, s) { var m = (n.y - o.y) * (e.x - t.x) - (n.x - o.x) * (e.y - t.y),
                    f = ((n.x - o.x) * (t.y - o.y) - (n.y - o.y) * (t.x - o.x)) / m,
                    y = ((e.x - t.x) * (t.y - o.y) - (e.y - t.y) * (t.x - o.x)) / m; return f >= 0 && f <= 1 && y >= 0 && y <= 1 ? r : null } return r }, i.Line.intersects = function(t, e, o, n) { return i.Line.intersectsPoints(t.start, t.end, e.start, e.end, o, n) }, i.Line.intersectsRectangle = function(t, e) { if (!i.Rectangle.intersects(t, e)) return !1; var o = t.start.x,
                n = t.start.y,
                s = t.end.x,
                r = t.end.y,
                a = e.x,
                h = e.y,
                l = e.right,
                c = e.bottom,
                d = 0; if (o >= a && o <= l && n >= h && n <= c || s >= a && s <= l && r >= h && r <= c) return !0; if (o < a && s >= a) { if ((d = n + (r - n) * (a - o) / (s - o)) > h && d <= c) return !0 } else if (o > l && s <= l && (d = n + (r - n) * (l - o) / (s - o)) >= h && d <= c) return !0; if (n < h && r >= h) { if ((d = o + (s - o) * (h - n) / (r - n)) >= a && d <= l) return !0 } else if (n > c && r <= c && (d = o + (s - o) * (c - n) / (r - n)) >= a && d <= l) return !0; return !1 }, i.Line.reflect = function(t, e) { return 2 * e.normalAngle - 3.141592653589793 - t.angle }, i.Matrix = function(t, e, o, n, s, r) { void 0 !== t && null !== t || (t = 1), void 0 !== e && null !== e || (e = 0), void 0 !== o && null !== o || (o = 0), void 0 !== n && null !== n || (n = 1), void 0 !== s && null !== s || (s = 0), void 0 !== r && null !== r || (r = 0), this.a = t, this.b = e, this.c = o, this.d = n, this.tx = s, this.ty = r, this.type = i.MATRIX }, i.Matrix.prototype = { fromArray: function(t) { return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5]) }, setTo: function(t, e, i, o, n, s) { return this.a = t, this.b = e, this.c = i, this.d = o, this.tx = n, this.ty = s, this }, clone: function(t) { return void 0 === t || null === t ? t = new i.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty), t }, copyTo: function(t) { return t.copyFrom(this), t }, copyFrom: function(t) { return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this }, toArray: function(t, e) { return void 0 === e && (e = new PIXI.Float32Array(9)), t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1), e }, apply: function(t, e) { return void 0 === e && (e = new i.Point), e.x = this.a * t.x + this.c * t.y + this.tx, e.y = this.b * t.x + this.d * t.y + this.ty, e }, applyInverse: function(t, e) { void 0 === e && (e = new i.Point); var o = 1 / (this.a * this.d + this.c * -this.b),
                    n = t.x,
                    s = t.y; return e.x = this.d * o * n + -this.c * o * s + (this.ty * this.c - this.tx * this.d) * o, e.y = this.a * o * s + -this.b * o * n + (-this.ty * this.a + this.tx * this.b) * o, e }, translate: function(t, e) { return this.tx += t, this.ty += e, this }, scale: function(t, e) { return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this }, rotate: function(t) { var e = Math.cos(t),
                    i = Math.sin(t),
                    o = this.a,
                    n = this.c,
                    s = this.tx; return this.a = o * e - this.b * i, this.b = o * i + this.b * e, this.c = n * e - this.d * i, this.d = n * i + this.d * e, this.tx = s * e - this.ty * i, this.ty = s * i + this.ty * e, this }, append: function(t) { var e = this.a,
                    i = this.b,
                    o = this.c,
                    n = this.d; return this.a = t.a * e + t.b * o, this.b = t.a * i + t.b * n, this.c = t.c * e + t.d * o, this.d = t.c * i + t.d * n, this.tx = t.tx * e + t.ty * o + this.tx, this.ty = t.tx * i + t.ty * n + this.ty, this }, identity: function() { return this.setTo(1, 0, 0, 1, 0, 0) } }, i.identityMatrix = new i.Matrix, PIXI.Matrix = i.Matrix, PIXI.identityMatrix = i.identityMatrix, i.Point = function(t, e) { t = t || 0, e = e || 0, this.x = t, this.y = e, this.type = i.POINT }, i.Point.prototype = { copyFrom: function(t) { return this.setTo(t.x, t.y) }, invert: function() { return this.setTo(this.y, this.x) }, setTo: function(t, e) { return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this }, set: function(t, e) { return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this }, add: function(t, e) { return this.x += t, this.y += e, this }, subtract: function(t, e) { return this.x -= t, this.y -= e, this }, multiply: function(t, e) { return this.x *= t, this.y *= e, this }, divide: function(t, e) { return this.x /= t, this.y /= e, this }, clampX: function(t, e) { return this.x = i.Math.clamp(this.x, t, e), this }, clampY: function(t, e) { return this.y = i.Math.clamp(this.y, t, e), this }, clamp: function(t, e) { return this.x = i.Math.clamp(this.x, t, e), this.y = i.Math.clamp(this.y, t, e), this }, clone: function(t) { return void 0 === t || null === t ? t = new i.Point(this.x, this.y) : t.setTo(this.x, this.y), t }, copyTo: function(t) { return t.x = this.x, t.y = this.y, t }, distance: function(t, e) { return i.Point.distance(this, t, e) }, equals: function(t) { return t.x === this.x && t.y === this.y }, angle: function(t, e) { return void 0 === e && (e = !1), e ? i.Math.radToDeg(Math.atan2(t.y - this.y, t.x - this.x)) : Math.atan2(t.y - this.y, t.x - this.x) }, rotate: function(t, e, o, n, s) { return i.Point.rotate(this, t, e, o, n, s) }, getMagnitude: function() { return Math.sqrt(this.x * this.x + this.y * this.y) }, getMagnitudeSq: function() { return this.x * this.x + this.y * this.y }, setMagnitude: function(t) { return this.normalize().multiply(t, t) }, normalize: function() { if (!this.isZero()) { var t = this.getMagnitude();
                    this.x /= t, this.y /= t } return this }, isZero: function() { return 0 === this.x && 0 === this.y }, dot: function(t) { return this.x * t.x + this.y * t.y }, cross: function(t) { return this.x * t.y - this.y * t.x }, perp: function() { return this.setTo(-this.y, this.x) }, rperp: function() { return this.setTo(this.y, -this.x) }, normalRightHand: function() { return this.setTo(-1 * this.y, this.x) }, floor: function() { return this.setTo(Math.floor(this.x), Math.floor(this.y)) }, ceil: function() { return this.setTo(Math.ceil(this.x), Math.ceil(this.y)) }, toString: function() { return "[{Point (x=" + this.x + " y=" + this.y + ")}]" } }, i.Point.prototype.constructor = i.Point, i.Point.add = function(t, e, o) { return void 0 === o && (o = new i.Point), o.x = t.x + e.x, o.y = t.y + e.y, o }, i.Point.subtract = function(t, e, o) { return void 0 === o && (o = new i.Point), o.x = t.x - e.x, o.y = t.y - e.y, o }, i.Point.multiply = function(t, e, o) { return void 0 === o && (o = new i.Point), o.x = t.x * e.x, o.y = t.y * e.y, o }, i.Point.divide = function(t, e, o) { return void 0 === o && (o = new i.Point), o.x = t.x / e.x, o.y = t.y / e.y, o }, i.Point.equals = function(t, e) { return t.x === e.x && t.y === e.y }, i.Point.angle = function(t, e) { return Math.atan2(t.y - e.y, t.x - e.x) }, i.Point.negative = function(t, e) { return void 0 === e && (e = new i.Point), e.setTo(-t.x, -t.y) }, i.Point.multiplyAdd = function(t, e, o, n) { return void 0 === n && (n = new i.Point), n.setTo(t.x + e.x * o, t.y + e.y * o) }, i.Point.interpolate = function(t, e, o, n) { return void 0 === n && (n = new i.Point), n.setTo(t.x + (e.x - t.x) * o, t.y + (e.y - t.y) * o) }, i.Point.perp = function(t, e) { return void 0 === e && (e = new i.Point), e.setTo(-t.y, t.x) }, i.Point.rperp = function(t, e) { return void 0 === e && (e = new i.Point), e.setTo(t.y, -t.x) }, i.Point.distance = function(t, e, o) { var n = i.Math.distance(t.x, t.y, e.x, e.y); return o ? Math.round(n) : n }, i.Point.project = function(t, e, o) { void 0 === o && (o = new i.Point); var n = t.dot(e) / e.getMagnitudeSq(); return 0 !== n && o.setTo(n * e.x, n * e.y), o }, i.Point.projectUnit = function(t, e, o) { void 0 === o && (o = new i.Point); var n = t.dot(e); return 0 !== n && o.setTo(n * e.x, n * e.y), o }, i.Point.normalRightHand = function(t, e) { return void 0 === e && (e = new i.Point), e.setTo(-1 * t.y, t.x) }, i.Point.normalize = function(t, e) { void 0 === e && (e = new i.Point); var o = t.getMagnitude(); return 0 !== o && e.setTo(t.x / o, t.y / o), e }, i.Point.rotate = function(t, e, o, n, s, r) { if (s && (n = i.Math.degToRad(n)), void 0 === r) { t.subtract(e, o); var a = Math.sin(n),
                    h = Math.cos(n),
                    l = h * t.x - a * t.y,
                    c = a * t.x + h * t.y;
                t.x = l + e, t.y = c + o } else { var d = n + Math.atan2(t.y - o, t.x - e);
                t.x = e + r * Math.cos(d), t.y = o + r * Math.sin(d) } return t }, i.Point.centroid = function(t, e) { if (void 0 === e && (e = new i.Point), "[object Array]" !== Object.prototype.toString.call(t)) throw new Error("Phaser.Point. Parameter 'points' must be an array"); var o = t.length; if (o < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty"); if (1 === o) return e.copyFrom(t[0]), e; for (var n = 0; n < o; n++) i.Point.add(e, t[n], e); return e.divide(o, o), e }, i.Point.parse = function(t, e, o) { e = e || "x", o = o || "y"; var n = new i.Point; return t[e] && (n.x = parseInt(t[e], 10)), t[o] && (n.y = parseInt(t[o], 10)), n }, PIXI.Point = i.Point, i.Polygon = function() { this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = i.POLYGON }, i.Polygon.prototype = { toNumberArray: function(t) { void 0 === t && (t = []); for (var e = 0; e < this._points.length; e++) "number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y)); return t }, flatten: function() { return this._points = this.toNumberArray(), this.flattened = !0, this }, clone: function(t) { var e = this._points.slice(); return void 0 === t || null === t ? t = new i.Polygon(e) : t.setTo(e), t }, contains: function(t, e) { var i = !1; if (this.flattened)
                    for (var o = -2, n = this._points.length - 2;
                        (o += 2) < this._points.length; n = o) { var s = this._points[o],
                            r = this._points[o + 1],
                            a = this._points[n],
                            h = this._points[n + 1];
                        (r <= e && e < h || h <= e && e < r) && t < (a - s) * (e - r) / (h - r) + s && (i = !i) } else
                        for (var o = -1, n = this._points.length - 1; ++o < this._points.length; n = o) { var s = this._points[o].x,
                                r = this._points[o].y,
                                a = this._points[n].x,
                                h = this._points[n].y;
                            (r <= e && e < h || h <= e && e < r) && t < (a - s) * (e - r) / (h - r) + s && (i = !i) }
                return i }, setTo: function(t) { if (this.area = 0, this._points = [], arguments.length > 0) { Array.isArray(t) || (t = Array.prototype.slice.call(arguments)); for (var e = Number.MAX_VALUE, i = 0, o = t.length; i < o; i++) { if ("number" == typeof t[i]) { n = new PIXI.Point(t[i], t[i + 1]);
                            i++ } else if (Array.isArray(t[i])) n = new PIXI.Point(t[i][0], t[i][1]);
                        else var n = new PIXI.Point(t[i].x, t[i].y);
                        this._points.push(n), n.y < e && (e = n.y) } this.calculateArea(e) } return this }, calculateArea: function(t) { for (var e, i, o, n, s = 0, r = this._points.length; s < r; s++) e = this._points[s], i = s === r - 1 ? this._points[0] : this._points[s + 1], o = (e.y - t + (i.y - t)) / 2, n = e.x - i.x, this.area += o * n; return this.area } }, i.Polygon.prototype.constructor = i.Polygon, Object.defineProperty(i.Polygon.prototype, "points", { get: function() { return this._points }, set: function(t) { null != t ? this.setTo(t) : this.setTo() } }), PIXI.Polygon = i.Polygon, i.Rectangle = function(t, e, o, n) { t = t || 0, e = e || 0, o = o || 0, n = n || 0, this.x = t, this.y = e, this.width = o, this.height = n, this.type = i.RECTANGLE }, i.Rectangle.prototype = { offset: function(t, e) { return this.x += t, this.y += e, this }, offsetPoint: function(t) { return this.offset(t.x, t.y) }, setTo: function(t, e, i, o) { return this.x = t, this.y = e, this.width = i, this.height = o, this }, scale: function(t, e) { return void 0 === e && (e = t), this.width *= t, this.height *= e, this }, centerOn: function(t, e) { return this.centerX = t, this.centerY = e, this }, floor: function() { this.x = Math.floor(this.x), this.y = Math.floor(this.y) }, floorAll: function() { this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height) }, ceil: function() { this.x = Math.ceil(this.x), this.y = Math.ceil(this.y) }, ceilAll: function() { this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height) }, copyFrom: function(t) { return this.setTo(t.x, t.y, t.width, t.height) }, copyTo: function(t) { return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t }, inflate: function(t, e) { return i.Rectangle.inflate(this, t, e) }, size: function(t) { return i.Rectangle.size(this, t) }, resize: function(t, e) { return this.width = t, this.height = e, this }, clone: function(t) { return i.Rectangle.clone(this, t) }, contains: function(t, e) { return i.Rectangle.contains(this, t, e) }, containsRect: function(t) { return i.Rectangle.containsRect(t, this) }, equals: function(t) { return i.Rectangle.equals(this, t) }, intersection: function(t, e) { return i.Rectangle.intersection(this, t, e) }, intersects: function(t) { return i.Rectangle.intersects(this, t) }, intersectsRaw: function(t, e, o, n, s) { return i.Rectangle.intersectsRaw(this, t, e, o, n, s) }, union: function(t, e) { return i.Rectangle.union(this, t, e) }, random: function(t) { return void 0 === t && (t = new i.Point), t.x = this.randomX, t.y = this.randomY, t }, getPoint: function(t, e) { switch (void 0 === e && (e = new i.Point), t) {
                    default:
                    case i.TOP_LEFT:
                        return e.set(this.x, this.y);
                    case i.TOP_CENTER:
                        return e.set(this.centerX, this.y);
                    case i.TOP_RIGHT:
                        return e.set(this.right, this.y);
                    case i.LEFT_CENTER:
                        return e.set(this.x, this.centerY);
                    case i.CENTER:
                        return e.set(this.centerX, this.centerY);
                    case i.RIGHT_CENTER:
                        return e.set(this.right, this.centerY);
                    case i.BOTTOM_LEFT:
                        return e.set(this.x, this.bottom);
                    case i.BOTTOM_CENTER:
                        return e.set(this.centerX, this.bottom);
                    case i.BOTTOM_RIGHT:
                        return e.set(this.right, this.bottom) } }, toString: function() { return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]" } }, Object.defineProperty(i.Rectangle.prototype, "halfWidth", { get: function() { return Math.round(this.width / 2) } }), Object.defineProperty(i.Rectangle.prototype, "halfHeight", { get: function() { return Math.round(this.height / 2) } }), Object.defineProperty(i.Rectangle.prototype, "bottom", { get: function() { return this.y + this.height }, set: function(t) { t <= this.y ? this.height = 0 : this.height = t - this.y } }), Object.defineProperty(i.Rectangle.prototype, "bottomLeft", { get: function() { return new i.Point(this.x, this.bottom) }, set: function(t) { this.x = t.x, this.bottom = t.y } }), Object.defineProperty(i.Rectangle.prototype, "bottomRight", { get: function() { return new i.Point(this.right, this.bottom) }, set: function(t) { this.right = t.x, this.bottom = t.y } }), Object.defineProperty(i.Rectangle.prototype, "left", { get: function() { return this.x }, set: function(t) { t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t } }), Object.defineProperty(i.Rectangle.prototype, "right", { get: function() { return this.x + this.width }, set: function(t) { t <= this.x ? this.width = 0 : this.width = t - this.x } }), Object.defineProperty(i.Rectangle.prototype, "volume", { get: function() { return this.width * this.height } }), Object.defineProperty(i.Rectangle.prototype, "perimeter", { get: function() { return 2 * this.width + 2 * this.height } }), Object.defineProperty(i.Rectangle.prototype, "centerX", { get: function() { return this.x + this.halfWidth }, set: function(t) { this.x = t - this.halfWidth } }), Object.defineProperty(i.Rectangle.prototype, "centerY", { get: function() { return this.y + this.halfHeight }, set: function(t) { this.y = t - this.halfHeight } }), Object.defineProperty(i.Rectangle.prototype, "randomX", { get: function() { return this.x + Math.random() * this.width } }), Object.defineProperty(i.Rectangle.prototype, "randomY", { get: function() { return this.y + Math.random() * this.height } }), Object.defineProperty(i.Rectangle.prototype, "top", { get: function() { return this.y }, set: function(t) { t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t } }), Object.defineProperty(i.Rectangle.prototype, "topLeft", { get: function() { return new i.Point(this.x, this.y) }, set: function(t) { this.x = t.x, this.y = t.y } }), Object.defineProperty(i.Rectangle.prototype, "topRight", { get: function() { return new i.Point(this.x + this.width, this.y) }, set: function(t) { this.right = t.x, this.y = t.y } }), Object.defineProperty(i.Rectangle.prototype, "empty", { get: function() { return !this.width || !this.height }, set: function(t) {!0 === t && this.setTo(0, 0, 0, 0) } }), i.Rectangle.prototype.constructor = i.Rectangle, i.Rectangle.inflate = function(t, e, i) { return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t }, i.Rectangle.inflatePoint = function(t, e) { return i.Rectangle.inflate(t, e.x, e.y) }, i.Rectangle.size = function(t, e) { return void 0 === e || null === e ? e = new i.Point(t.width, t.height) : e.setTo(t.width, t.height), e }, i.Rectangle.clone = function(t, e) { return void 0 === e || null === e ? e = new i.Rectangle(t.x, t.y, t.width, t.height) : e.setTo(t.x, t.y, t.width, t.height), e }, i.Rectangle.contains = function(t, e, i) { return !(t.width <= 0 || t.height <= 0) && (e >= t.x && e < t.right && i >= t.y && i < t.bottom) }, i.Rectangle.containsRaw = function(t, e, i, o, n, s) { return n >= t && n < t + i && s >= e && s < e + o }, i.Rectangle.containsPoint = function(t, e) { return i.Rectangle.contains(t, e.x, e.y) }, i.Rectangle.containsRect = function(t, e) { return !(t.volume > e.volume) && (t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom) }, i.Rectangle.equals = function(t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height }, i.Rectangle.sameDimensions = function(t, e) { return t.width === e.width && t.height === e.height }, i.Rectangle.intersection = function(t, e, o) { return void 0 === o && (o = new i.Rectangle), i.Rectangle.intersects(t, e) && (o.x = Math.max(t.x, e.x), o.y = Math.max(t.y, e.y), o.width = Math.min(t.right, e.right) - o.x, o.height = Math.min(t.bottom, e.bottom) - o.y), o }, i.Rectangle.intersects = function(t, e) { return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom) }, i.Rectangle.intersectsRaw = function(t, e, i, o, n, s) { return void 0 === s && (s = 0), !(e > t.right + s || i < t.left - s || o > t.bottom + s || n < t.top - s) }, i.Rectangle.union = function(t, e, o) { return void 0 === o && (o = new i.Rectangle), o.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top)) }, i.Rectangle.aabb = function(t, e) { void 0 === e && (e = new i.Rectangle); var o = Number.NEGATIVE_INFINITY,
                n = Number.POSITIVE_INFINITY,
                s = Number.NEGATIVE_INFINITY,
                r = Number.POSITIVE_INFINITY; return t.forEach(function(t) { t.x > o && (o = t.x), t.x < n && (n = t.x), t.y > s && (s = t.y), t.y < r && (r = t.y) }), e.setTo(n, r, o - n, s - r), e }, PIXI.Rectangle = i.Rectangle, PIXI.EmptyRectangle = new i.Rectangle(0, 0, 0, 0), i.RoundedRectangle = function(t, e, o, n, s) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === o && (o = 0), void 0 === n && (n = 0), void 0 === s && (s = 20), this.x = t, this.y = e, this.width = o, this.height = n, this.radius = s || 20, this.type = i.ROUNDEDRECTANGLE }, i.RoundedRectangle.prototype = { clone: function() { return new i.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius) }, contains: function(t, e) { if (this.width <= 0 || this.height <= 0) return !1; var i = this.x; if (t >= i && t <= i + this.width) { var o = this.y; if (e >= o && e <= o + this.height) return !0 } return !1 } }, i.RoundedRectangle.prototype.constructor = i.RoundedRectangle, PIXI.RoundedRectangle = i.RoundedRectangle, i.Camera = function(t, e, o, n, s, r) { this.game = t, this.world = t.world, this.id = 0, this.view = new i.Rectangle(o, n, s, r), this.bounds = new i.Rectangle(o, n, s, r), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = { x: !1, y: !1 }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new i.Point(1, 1), this.onShakeComplete = new i.Signal, this.onFlashComplete = new i.Signal, this.onFadeComplete = new i.Signal, this.fx = null, this._targetPosition = new i.Point, this._edge = 0, this._position = new i.Point, this._shake = { intensity: 0, duration: 0, horizontal: !1, vertical: !1, shakeBounds: !0, x: 0, y: 0 }, this._fxDuration = 0, this._fxType = 0 }, i.Camera.FOLLOW_LOCKON = 0, i.Camera.FOLLOW_PLATFORMER = 1, i.Camera.FOLLOW_TOPDOWN = 2, i.Camera.FOLLOW_TOPDOWN_TIGHT = 3, i.Camera.SHAKE_BOTH = 4, i.Camera.SHAKE_HORIZONTAL = 5, i.Camera.SHAKE_VERTICAL = 6, i.Camera.ENABLE_FX = !0, i.Camera.prototype = { boot: function() { this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, i.Graphics && i.Camera.ENABLE_FX && (this.fx = new i.Graphics(this.game), this.game.stage.addChild(this.fx)) }, preUpdate: function() { this.totalInView = 0 }, follow: function(t, e, o, n) { void 0 === e && (e = i.Camera.FOLLOW_LOCKON), void 0 === o && (o = 1), void 0 === n && (n = 1), this.target = t, this.lerp.set(o, n); var s; switch (e) {
                    case i.Camera.FOLLOW_PLATFORMER:
                        var r = this.width / 8,
                            a = this.height / 3;
                        this.deadzone = new i.Rectangle((this.width - r) / 2, (this.height - a) / 2 - .25 * a, r, a); break;
                    case i.Camera.FOLLOW_TOPDOWN:
                        s = Math.max(this.width, this.height) / 4, this.deadzone = new i.Rectangle((this.width - s) / 2, (this.height - s) / 2, s, s); break;
                    case i.Camera.FOLLOW_TOPDOWN_TIGHT:
                        s = Math.max(this.width, this.height) / 8, this.deadzone = new i.Rectangle((this.width - s) / 2, (this.height - s) / 2, s, s); break;
                    case i.Camera.FOLLOW_LOCKON:
                    default:
                        this.deadzone = null } }, unfollow: function() { this.target = null }, focusOn: function(t) { this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight)) }, focusOnXY: function(t, e) { this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight)) }, shake: function(t, e, o, n, s) { return void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === o && (o = !0), void 0 === n && (n = i.Camera.SHAKE_BOTH), void 0 === s && (s = !0), !(!o && this._shake.duration > 0) && (this._shake.intensity = t, this._shake.duration = e, this._shake.shakeBounds = s, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = n === i.Camera.SHAKE_BOTH || n === i.Camera.SHAKE_HORIZONTAL, this._shake.vertical = n === i.Camera.SHAKE_BOTH || n === i.Camera.SHAKE_VERTICAL, !0) }, flash: function(t, e, i) { return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, this._fxType = 0, !0) }, fade: function(t, e, i) { return void 0 === t && (t = 0), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, !0) }, update: function() { this._fxDuration > 0 && this.updateFX(), this._shake.duration > 0 && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y }, updateFX: function() { 0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch())) }, updateShake: function() { this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height)) }, updateTarget: function() { this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y }, setBoundsToWorld: function() { this.bounds && this.bounds.copyFrom(this.game.world.bounds) }, checkBounds: function() { this.atLimit.x = !1, this.atLimit.y = !1; var t = this.view.x + this._shake.x,
                    e = this.view.right + this._shake.x,
                    i = this.view.y + this._shake.y,
                    o = this.view.bottom + this._shake.y;
                t <= this.bounds.x * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)), e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)), o >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0)) }, setPosition: function(t, e) { this.view.x = t, this.view.y = e, this.bounds && this.checkBounds() }, setSize: function(t, e) { this.view.width = t, this.view.height = e }, reset: function() { this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this.resetFX() }, resetFX: function() { this.fx.clear(), this.fx.alpha = 0, this._fxDuration = 0 } }, i.Camera.prototype.constructor = i.Camera, Object.defineProperty(i.Camera.prototype, "x", { get: function() { return this.view.x }, set: function(t) { this.view.x = t, this.bounds && this.checkBounds() } }), Object.defineProperty(i.Camera.prototype, "y", { get: function() { return this.view.y }, set: function(t) { this.view.y = t, this.bounds && this.checkBounds() } }), Object.defineProperty(i.Camera.prototype, "position", { get: function() { return this._position.set(this.view.x, this.view.y), this._position }, set: function(t) { void 0 !== t.x && (this.view.x = t.x), void 0 !== t.y && (this.view.y = t.y), this.bounds && this.checkBounds() } }), Object.defineProperty(i.Camera.prototype, "width", { get: function() { return this.view.width }, set: function(t) { this.view.width = t } }), Object.defineProperty(i.Camera.prototype, "height", { get: function() { return this.view.height }, set: function(t) { this.view.height = t } }), Object.defineProperty(i.Camera.prototype, "shakeIntensity", { get: function() { return this._shake.intensity }, set: function(t) { this._shake.intensity = t } }), i.State = function() { this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null }, i.State.prototype = { init: function() {}, preload: function() {}, loadUpdate: function() {}, loadRender: function() {}, create: function() {}, update: function() {}, preRender: function() {}, render: function() {}, resize: function() {}, paused: function() {}, resumed: function() {}, pauseUpdate: function() {}, shutdown: function() {} }, i.State.prototype.constructor = i.State, i.StateManager = function(t, e) { this.game = t, this.states = {}, this._pendingState = null, void 0 !== e && null !== e && (this._pendingState = e), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new i.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null }, i.StateManager.prototype = { boot: function() { this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0) }, add: function(t, e, o) { void 0 === o && (o = !1); var n; return e instanceof i.State ? n = e : "object" == typeof e ? (n = e).game = this.game : "function" == typeof e && (n = new e(this.game)), this.states[t] = n, o && (this.game.isBooted ? this.start(t) : this._pendingState = t), n }, remove: function(t) { this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t] }, start: function(t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3))) }, restart: function(t, e) { void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2)) }, dummy: function() {}, preUpdate: function() { if (this._pendingState && this.game.isBooted) { var t = this.current; if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current !== this._pendingState) return;
                    this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete() } }, clearCurrentState: function() { this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy())) }, checkState: function(t) { return !!this.states[t] && !!(this.states[t].preload || this.states[t].create || this.states[t].update || this.states[t].render) }, link: function(t) { this.states[t].game = this.game, this.states[t].add = this.game.add, this.states[t].make = this.game.make, this.states[t].camera = this.game.camera, this.states[t].cache = this.game.cache, this.states[t].input = this.game.input, this.states[t].load = this.game.load, this.states[t].math = this.game.math, this.states[t].sound = this.game.sound, this.states[t].scale = this.game.scale, this.states[t].state = this, this.states[t].stage = this.game.stage, this.states[t].time = this.game.time, this.states[t].tweens = this.game.tweens, this.states[t].world = this.game.world, this.states[t].particles = this.game.particles, this.states[t].rnd = this.game.rnd, this.states[t].physics = this.game.physics, this.states[t].key = t }, unlink: function(t) { this.states[t] && (this.states[t].game = null, this.states[t].add = null, this.states[t].make = null, this.states[t].camera = null, this.states[t].cache = null, this.states[t].input = null, this.states[t].load = null, this.states[t].math = null, this.states[t].sound = null, this.states[t].scale = null, this.states[t].state = null, this.states[t].stage = null, this.states[t].time = null, this.states[t].tweens = null, this.states[t].world = null, this.states[t].particles = null, this.states[t].rnd = null, this.states[t].physics = null) }, setCurrentState: function(t) { this.callbackContext = this.states[t], this.link(t), this.onInitCallback = this.states[t].init || this.dummy, this.onPreloadCallback = this.states[t].preload || null, this.onLoadRenderCallback = this.states[t].loadRender || null, this.onLoadUpdateCallback = this.states[t].loadUpdate || null, this.onCreateCallback = this.states[t].create || null, this.onUpdateCallback = this.states[t].update || null, this.onPreRenderCallback = this.states[t].preRender || null, this.onRenderCallback = this.states[t].render || null, this.onResizeCallback = this.states[t].resize || null, this.onPausedCallback = this.states[t].paused || null, this.onResumedCallback = this.states[t].resumed || null, this.onPauseUpdateCallback = this.states[t].pauseUpdate || null, this.onShutDownCallback = this.states[t].shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0 }, getCurrentState: function() { return this.states[this.current] }, loadComplete: function() {!1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0 }, pause: function() { this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game) }, resume: function() { this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game) }, update: function() { this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game) }, pauseUpdate: function() { this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game) }, preRender: function(t) { this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t) }, resize: function(t, e) { this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e) }, render: function() { this._created ? this.onRenderCallback && (this.game.renderType === i.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game) }, destroy: function() { this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = "" } }, i.StateManager.prototype.constructor = i.StateManager, Object.defineProperty(i.StateManager.prototype, "created", { get: function() { return this._created } }), i.Signal = function() {}, i.Signal.prototype = { _bindings: null, _prevParams: null, memorize: !1, _shouldPropagate: !0, active: !0, _boundDispatch: !1, validateListener: function(t, e) { if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e)) }, _registerListener: function(t, e, o, n, s) { var r, a = this._indexOfListener(t, o); if (-1 !== a) { if ((r = this._bindings[a]).isOnce() !== e) throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.") } else r = new i.SignalBinding(this, t, e, o, n, s), this._addBinding(r); return this.memorize && this._prevParams && r.execute(this._prevParams), r }, _addBinding: function(t) { this._bindings || (this._bindings = []); var e = this._bindings.length;
                do { e-- } while (this._bindings[e] && t._priority <= this._bindings[e]._priority);
                this._bindings.splice(e + 1, 0, t) }, _indexOfListener: function(t, e) { if (!this._bindings) return -1;
                void 0 === e && (e = null); for (var i, o = this._bindings.length; o--;)
                    if ((i = this._bindings[o])._listener === t && i.context === e) return o; return -1 }, has: function(t, e) { return -1 !== this._indexOfListener(t, e) }, add: function(t, e, i) { this.validateListener(t, "add"); var o = []; if (arguments.length > 3)
                    for (var n = 3; n < arguments.length; n++) o.push(arguments[n]); return this._registerListener(t, !1, e, i, o) }, addOnce: function(t, e, i) { this.validateListener(t, "addOnce"); var o = []; if (arguments.length > 3)
                    for (var n = 3; n < arguments.length; n++) o.push(arguments[n]); return this._registerListener(t, !0, e, i, o) }, remove: function(t, e) { this.validateListener(t, "remove"); var i = this._indexOfListener(t, e); return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t }, removeAll: function(t) { if (void 0 === t && (t = null), this._bindings) { for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                    t || (this._bindings.length = 0) } }, getNumListeners: function() { return this._bindings ? this._bindings.length : 0 }, halt: function() { this._shouldPropagate = !1 }, dispatch: function() { if (this.active && this._bindings) { var t, e = Array.prototype.slice.call(arguments),
                        i = this._bindings.length; if (this.memorize && (this._prevParams = e), i) { t = this._bindings.slice(), this._shouldPropagate = !0;
                        do { i-- } while (t[i] && this._shouldPropagate && !1 !== t[i].execute(e)) } } }, forget: function() { this._prevParams && (this._prevParams = null) }, dispose: function() { this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null) }, toString: function() { return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]" } }, Object.defineProperty(i.Signal.prototype, "boundDispatch", { get: function() { var t = this; return this._boundDispatch || (this._boundDispatch = function() { return t.dispatch.apply(t, arguments) }) } }), i.Signal.prototype.constructor = i.Signal, i.SignalBinding = function(t, e, i, o, n, s) { this._listener = e, i && (this._isOnce = !0), null != o && (this.context = o), this._signal = t, n && (this._priority = n), s && s.length && (this._args = s) }, i.SignalBinding.prototype = { context: null, _isOnce: !1, _priority: 0, _args: null, callCount: 0, active: !0, params: null, execute: function(t) { var e, i; return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()), e }, detach: function() { return this.isBound() ? this._signal.remove(this._listener, this.context) : null }, isBound: function() { return !!this._signal && !!this._listener }, isOnce: function() { return this._isOnce }, getListener: function() { return this._listener }, getSignal: function() { return this._signal }, _destroy: function() { delete this._signal, delete this._listener, delete this.context }, toString: function() { return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]" } }, i.SignalBinding.prototype.constructor = i.SignalBinding, i.Filter = function(t, e, o) { this.game = t, this.type = i.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new i.Point; var n = new Date; if (this.uniforms = { resolution: { type: "2f", value: { x: 256, y: 256 } }, time: { type: "1f", value: 0 }, mouse: { type: "2f", value: { x: 0, y: 0 } }, date: { type: "4fv", value: [n.getFullYear(), n.getMonth(), n.getDate(), 60 * n.getHours() * 60 + 60 * n.getMinutes() + n.getSeconds()] }, sampleRate: { type: "1f", value: 44100 }, iChannel0: { type: "sampler2D", value: null, textureData: { repeat: !0 } }, iChannel1: { type: "sampler2D", value: null, textureData: { repeat: !0 } }, iChannel2: { type: "sampler2D", value: null, textureData: { repeat: !0 } }, iChannel3: { type: "sampler2D", value: null, textureData: { repeat: !0 } } }, e)
                for (var s in e) this.uniforms[s] = e[s];
            this.fragmentSrc = o || "" }, i.Filter.prototype = { init: function() {}, setResolution: function(t, e) { this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e }, update: function(t) { if (void 0 !== t) { var e = t.x / this.game.width,
                        i = 1 - t.y / this.game.height;
                    e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = i.toFixed(2), this.prevPoint.set(e, i)) } this.uniforms.time.value = this.game.time.totalElapsedSeconds() }, addToWorld: function(t, e, i, o, n, s) { void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 !== i && null !== i ? this.width = i : i = this.width, void 0 !== o && null !== o ? this.height = o : o = this.height; var r = this.game.add.image(t, e, "__default"); return r.width = i, r.height = o, r.anchor.set(n, s), r.filters = [this], r }, destroy: function() { this.game = null } }, i.Filter.prototype.constructor = i.Filter, Object.defineProperty(i.Filter.prototype, "width", { get: function() { return this.uniforms.resolution.value.x }, set: function(t) { this.uniforms.resolution.value.x = t } }), Object.defineProperty(i.Filter.prototype, "height", { get: function() { return this.uniforms.resolution.value.y }, set: function(t) { this.uniforms.resolution.value.y = t } }), i.Plugin = function(t, e) { void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1 }, i.Plugin.prototype = { preUpdate: function() {}, update: function() {}, render: function() {}, postRender: function() {}, destroy: function() { this.game = null, this.parent = null, this.active = !1, this.visible = !1 } }, i.Plugin.prototype.constructor = i.Plugin, i.PluginManager = function(t) { this.game = t, this.plugins = [], this._len = 0, this._i = 0 }, i.PluginManager.prototype = { add: function(t) { var e = Array.prototype.slice.call(arguments, 1),
                    i = !1; return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (t.hasPreUpdate = !0, i = !0), "function" == typeof t.update && (t.hasUpdate = !0, i = !0), "function" == typeof t.postUpdate && (t.hasPostUpdate = !0, i = !0), "function" == typeof t.render && (t.hasRender = !0, i = !0), "function" == typeof t.postRender && (t.hasPostRender = !0, i = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null }, remove: function(t, e) { for (void 0 === e && (e = !0), this._i = this._len; this._i--;)
                    if (this.plugins[this._i] === t) return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len-- }, removeAll: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                this.plugins.length = 0, this._len = 0 }, preUpdate: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate() }, update: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update() }, postUpdate: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate() }, render: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render() }, postRender: function() { for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender() }, destroy: function() { this.removeAll(), this.game = null } }, i.PluginManager.prototype.constructor = i.PluginManager, i.Stage = function(t) { this.game = t, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new PIXI.Matrix, this.stage = this, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = { r: 0, g: 0, b: 0, a: 0, color: 0, rgba: "#000000" }, this.game.transparent || (this._bgColor.a = 1), t.config && this.parseConfig(t.config) }, i.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.Stage.prototype.constructor = i.Stage, i.Stage.prototype.parseConfig = function(t) { t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor) }, i.Stage.prototype.boot = function() { i.DOM.getOffset(this.game.canvas, this.offset), i.Canvas.setUserSelect(this.game.canvas, "none"), i.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility() }, i.Stage.prototype.preUpdate = function() { this.currentRenderOrderID = 0; for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate() }, i.Stage.prototype.update = function() { for (var t = this.children.length; t--;) this.children[t].update() }, i.Stage.prototype.postUpdate = function() { this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget()); for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
            this.updateTransform() }, i.Stage.prototype.updateTransform = function() { this.worldAlpha = 1; for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform() }, i.Stage.prototype.checkVisibility = function() { void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null; var t = this;
            this._onChange = function(e) { return t.visibilityChange(e) }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() { i.Stage.prototype.visibilityChange.call(t, { type: "pause" }) }), CocoonJS.App.onActivated.addEventListener(function() { i.Stage.prototype.visibilityChange.call(t, { type: "resume" }) })) }, i.Stage.prototype.visibilityChange = function(t) { "pagehide" !== t.type && "blur" !== t.type && "pageshow" !== t.type && "focus" !== t.type ? this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t)) : "pagehide" === t.type || "blur" === t.type ? this.game.focusLoss(t) : "pageshow" !== t.type && "focus" !== t.type || this.game.focusGain(t) }, i.Stage.prototype.setBackgroundColor = function(t) { this.game.transparent || (i.Color.valueToColor(t, this._bgColor), i.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1) }, i.Stage.prototype.destroy = function() { this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null }, Object.defineProperty(i.Stage.prototype, "backgroundColor", { get: function() { return this._bgColor.color }, set: function(t) { this.setBackgroundColor(t) } }), Object.defineProperty(i.Stage.prototype, "smoothed", { get: function() { return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR }, set: function(t) { PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST } }), i.Group = function(t, e, o, n, s, r) { void 0 === n && (n = !1), void 0 === s && (s = !1), void 0 === r && (r = i.Physics.ARCADE), this.game = t, void 0 === e && (e = t.world), this.name = o || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), n ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : e && (e.addChild(this), this.z = e.children.length), this.type = i.GROUP, this.physicsType = i.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = i.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.onChildInputDown = new i.Signal, this.onChildInputUp = new i.Signal, this.onChildInputOver = new i.Signal, this.onChildInputOut = new i.Signal, this.enableBody = s, this.enableBodyDebug = !1, this.physicsBodyType = r, this.physicsSortDirection = null, this.onDestroy = new i.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new i.Point, this.hash = [], this._sortProperty = "z" }, i.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.Group.prototype.constructor = i.Group, i.Group.RETURN_NONE = 0, i.Group.RETURN_TOTAL = 1, i.Group.RETURN_CHILD = 2, i.Group.RETURN_ALL = 3, i.Group.SORT_ASCENDING = -1, i.Group.SORT_DESCENDING = 1, i.Group.prototype.add = function(t, e, i) { return void 0 === e && (e = !1), t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t), t) }, i.Group.prototype.addAt = function(t, e, i) { this.add(t, i, e) }, i.Group.prototype.addToHash = function(t) { return t.parent === this && -1 === this.hash.indexOf(t) && (this.hash.push(t), !0) }, i.Group.prototype.removeFromHash = function(t) { if (t) { var e = this.hash.indexOf(t); if (-1 !== e) return this.hash.splice(e, 1), !0 } return !1 }, i.Group.prototype.addMultiple = function(t, e) { if (t instanceof i.Group) t.moveAll(this, e);
            else if (Array.isArray(t))
                for (var o = 0; o < t.length; o++) this.add(t[o], e); return t }, i.Group.prototype.getAt = function(t) { return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t) }, i.Group.prototype.create = function(t, e, i, o, n, s) { void 0 === n && (n = !0); var r = new this.classType(this.game, t, e, i, o); return r.exists = n, r.visible = n, r.alive = n, this.add(r, !1, s) }, i.Group.prototype.createMultiple = function(t, e, i, o) { void 0 === i && (i = 0), void 0 === o && (o = !1), Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]); var n = this,
                s = []; return e.forEach(function(e) { i.forEach(function(i) { for (var r = 0; r < t; r++) s.push(n.create(0, 0, e, i, o)) }) }), s }, i.Group.prototype.updateZ = function() { for (var t = this.children.length; t--;) this.children[t].z = t }, i.Group.prototype.align = function(t, e, o, n, s, r) { if (void 0 === s && (s = i.TOP_LEFT), void 0 === r && (r = 0), 0 === this.children.length || r > this.children.length || -1 === t && -1 === e) return !1; for (var a = new i.Rectangle(0, 0, o, n), h = t * o, l = e * n, c = r; c < this.children.length; c++) { var d = this.children[c]; if (d.alignIn)
                    if (d.alignIn(a, s), -1 === t) a.y += n, a.y === l && (a.x += o, a.y = 0);
                    else if (-1 === e) a.x += o, a.x === h && (a.x = 0, a.y += n);
                else if (a.x += o, a.x === h && (a.x = 0, a.y += n, a.y === l)) return !0 } return !0 }, i.Group.prototype.resetCursor = function(t) { if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor }, i.Group.prototype.next = function() { if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor }, i.Group.prototype.previous = function() { if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor }, i.Group.prototype.swap = function(t, e) { this.swapChildren(t, e), this.updateZ() }, i.Group.prototype.bringToTop = function(t) { return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t }, i.Group.prototype.sendToBack = function(t) { return t.parent === this && this.getIndex(t) > 0 && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t }, i.Group.prototype.moveUp = function(t) { if (t.parent === this && this.getIndex(t) < this.children.length - 1) { var e = this.getIndex(t),
                    i = this.getAt(e + 1);
                i && this.swap(t, i) } return t }, i.Group.prototype.moveDown = function(t) { if (t.parent === this && this.getIndex(t) > 0) { var e = this.getIndex(t),
                    i = this.getAt(e - 1);
                i && this.swap(t, i) } return t }, i.Group.prototype.xy = function(t, e, i) { if (t < 0 || t > this.children.length) return -1;
            this.getChildAt(t).x = e, this.getChildAt(t).y = i }, i.Group.prototype.reverse = function() { this.children.reverse(), this.updateZ() }, i.Group.prototype.getIndex = function(t) { return this.children.indexOf(t) }, i.Group.prototype.getByName = function(t) { for (var e = 0; e < this.children.length; e++)
                if (this.children[e].name === t) return this.children[e]; return null }, i.Group.prototype.replace = function(t, e) { var o = this.getIndex(t); if (-1 !== o) return e.parent && (e.parent instanceof i.Group ? e.parent.remove(e) : e.parent.removeChild(e)), this.remove(t), this.addAt(e, o), t }, i.Group.prototype.hasProperty = function(t, e) { var i = e.length; return 1 === i && e[0] in t || (2 === i && e[0] in t && e[1] in t[e[0]] || (3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]])) }, i.Group.prototype.setProperty = function(t, e, i, o, n) { if (void 0 === n && (n = !1), o = o || 0, !this.hasProperty(t, e) && (!n || o > 0)) return !1; var s = e.length; return 1 === s ? 0 === o ? t[e[0]] = i : 1 === o ? t[e[0]] += i : 2 === o ? t[e[0]] -= i : 3 === o ? t[e[0]] *= i : 4 === o && (t[e[0]] /= i) : 2 === s ? 0 === o ? t[e[0]][e[1]] = i : 1 === o ? t[e[0]][e[1]] += i : 2 === o ? t[e[0]][e[1]] -= i : 3 === o ? t[e[0]][e[1]] *= i : 4 === o && (t[e[0]][e[1]] /= i) : 3 === s ? 0 === o ? t[e[0]][e[1]][e[2]] = i : 1 === o ? t[e[0]][e[1]][e[2]] += i : 2 === o ? t[e[0]][e[1]][e[2]] -= i : 3 === o ? t[e[0]][e[1]][e[2]] *= i : 4 === o && (t[e[0]][e[1]][e[2]] /= i) : 4 === s && (0 === o ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === o ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === o ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === o ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === o && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0 }, i.Group.prototype.checkProperty = function(t, e, o, n) { return void 0 === n && (n = !1), !(!i.Utils.getProperty(t, e) && n) && i.Utils.getProperty(t, e) === o }, i.Group.prototype.set = function(t, e, i, o, n, s, r) { if (void 0 === r && (r = !1), e = e.split("."), void 0 === o && (o = !1), void 0 === n && (n = !1), (!1 === o || o && t.alive) && (!1 === n || n && t.visible)) return this.setProperty(t, e, i, s, r) }, i.Group.prototype.setAll = function(t, e, i, o, n, s) { void 0 === i && (i = !1), void 0 === o && (o = !1), void 0 === s && (s = !1), t = t.split("."), n = n || 0; for (var r = 0; r < this.children.length; r++)(!i || i && this.children[r].alive) && (!o || o && this.children[r].visible) && this.setProperty(this.children[r], t, e, n, s) }, i.Group.prototype.setAllChildren = function(t, e, o, n, s, r) { void 0 === o && (o = !1), void 0 === n && (n = !1), void 0 === r && (r = !1), s = s || 0; for (var a = 0; a < this.children.length; a++)(!o || o && this.children[a].alive) && (!n || n && this.children[a].visible) && (this.children[a] instanceof i.Group ? this.children[a].setAllChildren(t, e, o, n, s, r) : this.setProperty(this.children[a], t.split("."), e, s, r)) }, i.Group.prototype.checkAll = function(t, e, i, o, n) { void 0 === i && (i = !1), void 0 === o && (o = !1), void 0 === n && (n = !1); for (var s = 0; s < this.children.length; s++)
                if ((!i || i && this.children[s].alive) && (!o || o && this.children[s].visible) && !this.checkProperty(this.children[s], t, e, n)) return !1; return !0 }, i.Group.prototype.addAll = function(t, e, i, o) { this.setAll(t, e, i, o, 1) }, i.Group.prototype.subAll = function(t, e, i, o) { this.setAll(t, e, i, o, 2) }, i.Group.prototype.multiplyAll = function(t, e, i, o) { this.setAll(t, e, i, o, 3) }, i.Group.prototype.divideAll = function(t, e, i, o) { this.setAll(t, e, i, o, 4) }, i.Group.prototype.callAllExists = function(t, e) { var i; if (arguments.length > 2) { i = []; for (o = 2; o < arguments.length; o++) i.push(arguments[o]) } for (var o = 0; o < this.children.length; o++) this.children[o].exists === e && this.children[o][t] && this.children[o][t].apply(this.children[o], i) }, i.Group.prototype.callbackFromArray = function(t, e, i) { if (1 === i) { if (t[e[0]]) return t[e[0]] } else if (2 === i) { if (t[e[0]][e[1]]) return t[e[0]][e[1]] } else if (3 === i) { if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]] } else if (4 === i) { if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]] } else if (t[e]) return t[e]; return !1 }, i.Group.prototype.callAll = function(t, e) { if (void 0 !== t) { var i = (t = t.split(".")).length; if (void 0 === e || null === e || "" === e) e = null;
                else if ("string" == typeof e) var o = (e = e.split(".")).length; var n; if (arguments.length > 2) { n = []; for (a = 2; a < arguments.length; a++) n.push(arguments[a]) } for (var s = null, r = null, a = 0; a < this.children.length; a++) s = this.callbackFromArray(this.children[a], t, i), e && s ? (r = this.callbackFromArray(this.children[a], e, o), s && s.apply(r, n)) : s && s.apply(this.children[a], n) } }, i.Group.prototype.preUpdate = function() { if (this.pendingDestroy) return this.destroy(), !1; if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1; for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate(); return !0 }, i.Group.prototype.update = function() { for (var t = this.children.length; t--;) this.children[t].update() }, i.Group.prototype.postUpdate = function() { this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y); for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate() }, i.Group.prototype.filter = function(t, e) { for (var o = -1, n = this.children.length, s = []; ++o < n;) { var r = this.children[o];
                (!e || e && r.exists) && t(r, o, this.children) && s.push(r) } return new i.ArraySet(s) }, i.Group.prototype.forEach = function(t, e, i) { if (void 0 === i && (i = !1), arguments.length <= 3)
                for (n = 0; n < this.children.length; n++)(!i || i && this.children[n].exists) && t.call(e, this.children[n]);
            else { for (var o = [null], n = 3; n < arguments.length; n++) o.push(arguments[n]); for (n = 0; n < this.children.length; n++)(!i || i && this.children[n].exists) && (o[0] = this.children[n], t.apply(e, o)) } }, i.Group.prototype.forEachExists = function(t, e) { var o; if (arguments.length > 2) { o = [null]; for (var n = 2; n < arguments.length; n++) o.push(arguments[n]) } this.iterate("exists", !0, i.Group.RETURN_TOTAL, t, e, o) }, i.Group.prototype.forEachAlive = function(t, e) { var o; if (arguments.length > 2) { o = [null]; for (var n = 2; n < arguments.length; n++) o.push(arguments[n]) } this.iterate("alive", !0, i.Group.RETURN_TOTAL, t, e, o) }, i.Group.prototype.forEachDead = function(t, e) { var o; if (arguments.length > 2) { o = [null]; for (var n = 2; n < arguments.length; n++) o.push(arguments[n]) } this.iterate("alive", !1, i.Group.RETURN_TOTAL, t, e, o) }, i.Group.prototype.sort = function(t, e) { this.children.length < 2 || (void 0 === t && (t = "z"), void 0 === e && (e = i.Group.SORT_ASCENDING), this._sortProperty = t, e === i.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ()) }, i.Group.prototype.customSort = function(t, e) { this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ()) }, i.Group.prototype.ascendingSortHandler = function(t, e) { return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1 }, i.Group.prototype.descendingSortHandler = function(t, e) { return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0 }, i.Group.prototype.iterate = function(t, e, o, n, s, r) { if (0 === this.children.length) { if (o === i.Group.RETURN_TOTAL) return 0; if (o === i.Group.RETURN_ALL) return [] } var a = 0; if (o === i.Group.RETURN_ALL) var h = []; for (var l = 0; l < this.children.length; l++)
                if (this.children[l][t] === e) { if (a++, n && (r ? (r[0] = this.children[l], n.apply(s, r)) : n.call(s, this.children[l])), o === i.Group.RETURN_CHILD) return this.children[l];
                    o === i.Group.RETURN_ALL && h.push(this.children[l]) } return o === i.Group.RETURN_TOTAL ? a : o === i.Group.RETURN_ALL ? h : null }, i.Group.prototype.getFirstExists = function(t, e, o, n, s, r) { void 0 === e && (e = !1), "boolean" != typeof t && (t = !0); var a = this.iterate("exists", t, i.Group.RETURN_CHILD); return null === a && e ? this.create(o, n, s, r) : this.resetChild(a, o, n, s, r) }, i.Group.prototype.getFirstAlive = function(t, e, o, n, s) { void 0 === t && (t = !1); var r = this.iterate("alive", !0, i.Group.RETURN_CHILD); return null === r && t ? this.create(e, o, n, s) : this.resetChild(r, e, o, n, s) }, i.Group.prototype.getFirstDead = function(t, e, o, n, s) { void 0 === t && (t = !1); var r = this.iterate("alive", !1, i.Group.RETURN_CHILD); return null === r && t ? this.create(e, o, n, s) : this.resetChild(r, e, o, n, s) }, i.Group.prototype.resetChild = function(t, e, i, o, n) { return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== o && t.loadTexture(o, n), t) }, i.Group.prototype.getTop = function() { if (this.children.length > 0) return this.children[this.children.length - 1] }, i.Group.prototype.getBottom = function() { if (this.children.length > 0) return this.children[0] }, i.Group.prototype.getClosestTo = function(t, e, o) { for (var n = Number.MAX_VALUE, s = 0, r = null, a = 0; a < this.children.length; a++) { var h = this.children[a];
                h.exists && (s = Math.abs(i.Point.distance(t, h))) < n && (!e || e.call(o, h, s)) && (n = s, r = h) } return r }, i.Group.prototype.getFurthestFrom = function(t, e, o) { for (var n = 0, s = 0, r = null, a = 0; a < this.children.length; a++) { var h = this.children[a];
                h.exists && (s = Math.abs(i.Point.distance(t, h))) > n && (!e || e.call(o, h, s)) && (n = s, r = h) } return r }, i.Group.prototype.countLiving = function() { return this.iterate("alive", !0, i.Group.RETURN_TOTAL) }, i.Group.prototype.countDead = function() { return this.iterate("alive", !1, i.Group.RETURN_TOTAL) }, i.Group.prototype.getRandom = function(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = this.children.length), 0 === e ? null : i.ArrayUtils.getRandomItem(this.children, t, e) }, i.Group.prototype.getRandomExists = function(t, e) { var i = this.getAll("exists", !0, t, e); return this.game.rnd.pick(i) }, i.Group.prototype.getAll = function(t, e, i, o) { void 0 === i && (i = 0), void 0 === o && (o = this.children.length); for (var n = [], s = i; s < o; s++) { var r = this.children[s];
                t && r[t] === e && n.push(r) } return n }, i.Group.prototype.remove = function(t, e, i) { if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
            i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this); var o = this.removeChild(t); return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && o && o.destroy(!0), !0 }, i.Group.prototype.moveAll = function(t, e) { if (void 0 === e && (e = !1), this.children.length > 0 && t instanceof i.Group) { do { t.add(this.children[0], e) } while (this.children.length > 0);
                this.hash = [], this.cursor = null } return t }, i.Group.prototype.removeAll = function(t, e, i) { if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) { do {!e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this); var o = this.removeChild(this.children[0]);
                    this.removeFromHash(o), t && o && o.destroy(!0, i) } while (this.children.length > 0);
                this.hash = [], this.cursor = null } }, i.Group.prototype.removeBetween = function(t, e, i, o) { if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === o && (o = !1), 0 !== this.children.length) { if (t > e || t < 0 || e > this.children.length) return !1; for (var n = e; n >= t;) {!o && this.children[n].events && this.children[n].events.onRemovedFromGroup$dispatch(this.children[n], this); var s = this.removeChild(this.children[n]);
                    this.removeFromHash(s), i && s && s.destroy(!0), this.cursor === this.children[n] && (this.cursor = null), n-- } this.updateZ() } }, i.Group.prototype.destroy = function(t, e) { null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1)) }, Object.defineProperty(i.Group.prototype, "total", { get: function() { return this.iterate("exists", !0, i.Group.RETURN_TOTAL) } }), Object.defineProperty(i.Group.prototype, "length", { get: function() { return this.children.length } }), Object.defineProperty(i.Group.prototype, "angle", { get: function() { return i.Math.radToDeg(this.rotation) }, set: function(t) { this.rotation = i.Math.degToRad(t) } }), Object.defineProperty(i.Group.prototype, "centerX", { get: function() { return this.getBounds(this.parent).centerX }, set: function(t) { var e = this.getBounds(this.parent),
                    i = this.x - e.x;
                this.x = t + i - e.halfWidth } }), Object.defineProperty(i.Group.prototype, "centerY", { get: function() { return this.getBounds(this.parent).centerY }, set: function(t) { var e = this.getBounds(this.parent),
                    i = this.y - e.y;
                this.y = t + i - e.halfHeight } }), Object.defineProperty(i.Group.prototype, "left", { get: function() { return this.getBounds(this.parent).left }, set: function(t) { var e = this.getBounds(this.parent),
                    i = this.x - e.x;
                this.x = t + i } }), Object.defineProperty(i.Group.prototype, "right", { get: function() { return this.getBounds(this.parent).right }, set: function(t) { var e = this.getBounds(this.parent),
                    i = this.x - e.x;
                this.x = t + i - e.width } }), Object.defineProperty(i.Group.prototype, "top", { get: function() { return this.getBounds(this.parent).top }, set: function(t) { var e = this.getBounds(this.parent),
                    i = this.y - e.y;
                this.y = t + i } }), Object.defineProperty(i.Group.prototype, "bottom", { get: function() { return this.getBounds(this.parent).bottom }, set: function(t) { var e = this.getBounds(this.parent),
                    i = this.y - e.y;
                this.y = t + i - e.height } }), i.World = function(t) { i.Group.call(this, t, null, "__world", !1), this.bounds = new i.Rectangle(0, 0, t.width, t.height), this.camera = null, this._definedSize = !1, this._width = t.width, this._height = t.height, this.game.state.onStateChange.add(this.stateChange, this) }, i.World.prototype = Object.create(i.Group.prototype), i.World.prototype.constructor = i.World, i.World.prototype.boot = function() { this.camera = new i.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot() }, i.World.prototype.stateChange = function() { this.x = 0, this.y = 0, this.camera.reset() }, i.World.prototype.setBounds = function(t, e, i, o) { this._definedSize = !0, this._width = i, this._height = o, this.bounds.setTo(t, e, i, o), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(o, this.game.height)), this.game.physics.setBoundsToWorld() }, i.World.prototype.resize = function(t, e) { this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld() }, i.World.prototype.shutdown = function() { this.destroy(!0, !0) }, i.World.prototype.wrap = function(t, e, i, o, n) { void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === o && (o = !0), void 0 === n && (n = !0), i ? (t.getBounds(), o && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), n && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (o && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : o && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), n && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : n && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e)) }, Object.defineProperty(i.World.prototype, "width", { get: function() { return this.bounds.width }, set: function(t) { t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0 } }), Object.defineProperty(i.World.prototype, "height", { get: function() { return this.bounds.height }, set: function(t) { t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0 } }), Object.defineProperty(i.World.prototype, "centerX", { get: function() { return this.bounds.halfWidth + this.bounds.x } }), Object.defineProperty(i.World.prototype, "centerY", { get: function() { return this.bounds.halfHeight + this.bounds.y } }), Object.defineProperty(i.World.prototype, "randomX", { get: function() { return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width) } }), Object.defineProperty(i.World.prototype, "randomY", { get: function() { return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height) } }), i.Game = function(t, e, o, n, s, r, a, h) { return this.id = i.GAMES.push(this) - 1, this.config = null, this.physicsConfig = h, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = i.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = i.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new i.Signal, this.forceSingleUpdate = !0, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = { enableDebug: !0 }, void 0 !== t && (this._width = t), void 0 !== e && (this._height = e), void 0 !== o && (this.renderType = o), void 0 !== n && (this.parent = n), void 0 !== r && (this.transparent = r), void 0 !== a && (this.antialias = a), this.rnd = new i.RandomDataGenerator([(Date.now() * Math.random()).toString()]), this.state = new i.StateManager(this, s)), this.device.whenReady(this.boot, this), this }, i.Game.prototype = { parseConfig: function(t) { this.config = t, void 0 === t.enableDebug && (this.config.enableDebug = !0), t.width && (this._width = t.width), t.height && (this._height = t.height), t.renderer && (this.renderType = t.renderer), t.parent && (this.parent = t.parent), void 0 !== t.transparent && (this.transparent = t.transparent), void 0 !== t.antialias && (this.antialias = t.antialias), t.resolution && (this.resolution = t.resolution), void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), t.physicsConfig && (this.physicsConfig = t.physicsConfig); var e = [(Date.now() * Math.random()).toString()];
                t.seed && (e = t.seed), this.rnd = new i.RandomDataGenerator(e); var o = null;
                t.state && (o = t.state), this.state = new i.StateManager(this, o) }, boot: function() { this.isBooted || (this.onPause = new i.Signal, this.onResume = new i.Signal, this.onBlur = new i.Signal, this.onFocus = new i.Signal, this.isBooted = !0, PIXI.game = this, this.math = i.Math, this.scale = new i.ScaleManager(this, this._width, this._height), this.stage = new i.Stage(this), this.setUpRenderer(), this.world = new i.World(this), this.add = new i.GameObjectFactory(this), this.make = new i.GameObjectCreator(this), this.cache = new i.Cache(this), this.load = new i.Loader(this), this.time = new i.Time(this), this.tweens = new i.TweenManager(this), this.input = new i.Input(this), this.sound = new i.SoundManager(this), this.physics = new i.Physics(this, this.physicsConfig), this.particles = new i.Particles(this), this.create = new i.Create(this), this.plugins = new i.PluginManager(this), this.net = new i.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new i.Utils.Debug(this), this.debug.boot()) : this.debug = { preUpdate: function() {}, update: function() {}, reset: function() {} }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new i.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new i.RequestAnimationFrame(this, !1), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.raf.start()) }, showDebugHeader: function() { if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) { var t = i.VERSION,
                        e = "Canvas",
                        o = "HTML Audio",
                        n = 1; if (this.renderType === i.WEBGL ? (e = "WebGL", n++) : this.renderType === i.HEADLESS && (e = "Headless"), this.device.webAudio && (o = "WebAudio", n++), this.device.chrome)
                        for (var s = ["%c %c %c Phaser v" + t + " | Pixi.js | " + e + " | " + o + "  %c %c %c http://phaser.io %c♥%c♥%c♥", "background: #fb8cb3", "background: #d44a52", "color: #ffffff; background: #871905;", "background: #d44a52", "background: #fb8cb3", "background: #ffffff"], r = 0; r < 3; r++) r < n ? s.push("color: #ff2424; background: #fff") : s.push("color: #959595; background: #fff");
                    else window.console } }, setUpRenderer: function() { if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = i.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.renderType === i.HEADLESS || this.renderType === i.CANVAS || this.renderType === i.AUTO && !this.device.webGL) { if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                    this.renderType = i.CANVAS, this.renderer = new PIXI.CanvasRenderer(this), this.context = this.renderer.context } else this.renderType = i.WEBGL, this.renderer = new PIXI.WebGLRenderer(this), this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
                this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === i.CANVAS), this.renderType !== i.HEADLESS && (this.stage.smoothed = this.antialias, i.Canvas.addToDOM(this.canvas, this.parent, !1), i.Canvas.setTouchAction(this.canvas)) }, contextLost: function(t) { t.preventDefault(), this.renderer.contextLost = !0 }, contextRestored: function() { this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1 }, update: function(t) { if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1); if (this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps);
                else { var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                    this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0); var i = 0; for (this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);) this.time.refresh();
                    i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.updateRender(this._deltaTime / e) } }, updateLogic: function(t) { this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform() }, updateRender: function(t) { this.lockRender || (this.state.preRender(t), this.renderType !== i.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(t), this.state.render(t)), this.plugins.postRender(t)) }, enableStep: function() { this.stepping = !0, this.pendingStep = !1, this.stepCount = 0 }, disableStep: function() { this.stepping = !1, this.pendingStep = !1 }, step: function() { this.pendingStep = !1, this.stepCount++ }, destroy: function() { this.raf.stop(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), i.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, i.GAMES[this.id] = null }, gamePaused: function(t) { this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0)) }, gameResumed: function(t) { this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1)) }, focusLoss: function(t) { this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t) }, focusGain: function(t) { this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t) } }, i.Game.prototype.constructor = i.Game, Object.defineProperty(i.Game.prototype, "paused", { get: function() { return this._paused }, set: function(t) {!0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1) } }), i.Input = function(t) { this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = i.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new i.ArraySet, this._localPoint = new i.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0 }, i.Input.MOUSE_OVERRIDES_TOUCH = 0, i.Input.TOUCH_OVERRIDES_MOUSE = 1, i.Input.MOUSE_TOUCH_COMBINE = 2, i.Input.MAX_POINTERS = 10, i.Input.prototype = { boot: function() { this.mousePointer = new i.Pointer(this.game, 0, i.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new i.Mouse(this.game), this.touch = new i.Touch(this.game), this.mspointer = new i.MSPointer(this.game), i.Keyboard && (this.keyboard = new i.Keyboard(this.game)), i.Gamepad && (this.gamepad = new i.Gamepad(this.game)), this.onDown = new i.Signal, this.onUp = new i.Signal, this.onTap = new i.Signal, this.onHold = new i.Signal, this.scale = new i.Point(1, 1), this.speed = new i.Point, this.position = new i.Point, this._oldPosition = new i.Point, this.circle = new i.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.mouse.start(), this.touch.start(), this.mspointer.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start(); var t = this;
                this._onClickTrampoline = function(e) { t.onClickTrampoline(e) }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1) }, destroy: function() { this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], PIXI.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline) }, setInteractiveCandidateHandler: function(t, e) { this.customCandidateHandler = t, this.customCandidateHandlerContext = e }, addMoveCallback: function(t, e) { this.moveCallbacks.push({ callback: t, context: e }) }, deleteMoveCallback: function(t, e) { for (var i = this.moveCallbacks.length; i--;)
                    if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1) }, addPointer: function() { if (this.pointers.length >= i.Input.MAX_POINTERS) return null; var t = this.pointers.length + 1,
                    e = new i.Pointer(this.game, t, i.PointerMode.TOUCH); return this.pointers.push(e), this["pointer" + t] = e, e }, update: function() { if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) this._pollCounter++;
                else { this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update(); for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                    this._pollCounter = 0 } }, reset: function(t) { if (this.game.isBooted && !this.resetLocked) { void 0 === t && (t = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(t), this.gamepad && this.gamepad.reset(); for (var e = 0; e < this.pointers.length; e++) this.pointers[e].reset(); "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new i.Signal, this.onUp = new i.Signal, this.onTap = new i.Signal, this.onHold = new i.Signal, this.moveCallbacks = []), this._pollCounter = 0 } }, resetSpeed: function(t, e) { this._oldPosition.setTo(t, e), this.speed.setTo(0, 0) }, startPointer: function(t) { if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null; if (!this.pointer1.active) return this.pointer1.start(t); if (!this.pointer2.active) return this.pointer2.start(t); for (var e = 2; e < this.pointers.length; e++) { var i = this.pointers[e]; if (!i.active) return i.start(t) } return null }, updatePointer: function(t) { if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t); if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t); for (var e = 2; e < this.pointers.length; e++) { var i = this.pointers[e]; if (i.active && i.identifier === t.identifier) return i.move(t) } return null }, stopPointer: function(t) { if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t); if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t); for (var e = 2; e < this.pointers.length; e++) { var i = this.pointers[e]; if (i.active && i.identifier === t.identifier) return i.stop(t) } return null }, countActivePointers: function(t) { void 0 === t && (t = this.pointers.length); for (var e = t, i = 0; i < this.pointers.length && e > 0; i++) this.pointers[i].active && e--; return t - e }, getPointer: function(t) { void 0 === t && (t = !1); for (var e = 0; e < this.pointers.length; e++) { var i = this.pointers[e]; if (i.active === t) return i } return null }, getPointerFromIdentifier: function(t) { for (var e = 0; e < this.pointers.length; e++) { var i = this.pointers[e]; if (i.identifier === t) return i } return null }, getPointerFromId: function(t) { for (var e = 0; e < this.pointers.length; e++) { var i = this.pointers[e]; if (i.pointerId === t) return i } return null }, getLocalPosition: function(t, e, o) { void 0 === o && (o = new i.Point); var n = t.worldTransform,
                    s = 1 / (n.a * n.d + n.c * -n.b); return o.setTo(n.d * s * e.x + -n.c * s * e.y + (n.ty * n.c - n.tx * n.d) * s, n.a * s * e.y + -n.b * s * e.x + (-n.ty * n.a + n.tx * n.b) * s) }, hitTest: function(t, e, o) { if (!t.worldVisible) return !1; if (this.getLocalPosition(t, e, this._localPoint), o.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains) return t.hitArea.contains(this._localPoint.x, this._localPoint.y); if (t instanceof i.TileSprite) { var n = t.width,
                        s = t.height,
                        r = -n * t.anchor.x; if (this._localPoint.x >= r && this._localPoint.x < r + n) { a = -s * t.anchor.y; if (this._localPoint.y >= a && this._localPoint.y < a + s) return !0 } } else if (t instanceof PIXI.Sprite) { var n = t.texture.frame.width,
                        s = t.texture.frame.height,
                        r = -n * t.anchor.x; if (this._localPoint.x >= r && this._localPoint.x < r + n) { var a = -s * t.anchor.y; if (this._localPoint.y >= a && this._localPoint.y < a + s) return !0 } } else if (t instanceof i.Graphics)
                    for (l = 0; l < t.graphicsData.length; l++) { var h = t.graphicsData[l]; if (h.fill && (h.shape && h.shape.contains(this._localPoint.x, this._localPoint.y))) return !0 }
                for (var l = 0; l < t.children.length; l++)
                    if (this.hitTest(t.children[l], e, o)) return !0; return !1 }, onClickTrampoline: function() { this.activePointer.processClickTrampolines() } }, i.Input.prototype.constructor = i.Input, Object.defineProperty(i.Input.prototype, "x", { get: function() { return this._x }, set: function(t) { this._x = Math.floor(t) } }), Object.defineProperty(i.Input.prototype, "y", { get: function() { return this._y }, set: function(t) { this._y = Math.floor(t) } }), Object.defineProperty(i.Input.prototype, "pollLocked", { get: function() { return this.pollRate > 0 && this._pollCounter < this.pollRate } }), Object.defineProperty(i.Input.prototype, "totalInactivePointers", { get: function() { return this.pointers.length - this.countActivePointers() } }), Object.defineProperty(i.Input.prototype, "totalActivePointers", { get: function() { return this.countActivePointers() } }), Object.defineProperty(i.Input.prototype, "worldX", { get: function() { return this.game.camera.view.x + this.x } }), Object.defineProperty(i.Input.prototype, "worldY", { get: function() { return this.game.camera.view.y + this.y } }), i.Mouse = function(t) { this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new i.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null }, i.Mouse.NO_BUTTON = -1, i.Mouse.LEFT_BUTTON = 0, i.Mouse.MIDDLE_BUTTON = 1, i.Mouse.RIGHT_BUTTON = 2, i.Mouse.BACK_BUTTON = 3, i.Mouse.FORWARD_BUTTON = 4, i.Mouse.WHEEL_UP = 1, i.Mouse.WHEEL_DOWN = -1, i.Mouse.prototype = { start: function() { if ((!this.game.device.android || !1 !== this.game.device.chrome) && null === this._onMouseDown) { var e = this;
                    this._onMouseDown = function(t) { return e.onMouseDown(t) }, this._onMouseMove = function(t) { return e.onMouseMove(t) }, this._onMouseUp = function(t) { return e.onMouseUp(t) }, this._onMouseUpGlobal = function(t) { return e.onMouseUpGlobal(t) }, this._onMouseOutGlobal = function(t) { return e.onMouseOutGlobal(t) }, this._onMouseOut = function(t) { return e.onMouseOut(t) }, this._onMouseOver = function(t) { return e.onMouseOver(t) }, this._onMouseWheel = function(t) { return e.onMouseWheel(t) }; var i = this.game.canvas;
                    i.addEventListener("mousedown", this._onMouseDown, !0), i.addEventListener("mousemove", this._onMouseMove, !0), i.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), i.addEventListener("mouseover", this._onMouseOver, !0), i.addEventListener("mouseout", this._onMouseOut, !0)); var o = this.game.device.wheelEvent;
                    o && (i.addEventListener(o, this._onMouseWheel, !0), "mousewheel" === o ? this._wheelEvent = new t(-.025, 1) : "DOMMouseScroll" === o && (this._wheelEvent = new t(1, 1))) } }, onMouseDown: function(t) { this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t)) }, onMouseMove: function(t) { this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t)) }, onMouseUp: function(t) { this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t)) }, onMouseUpGlobal: function(t) { this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t)) }, onMouseOutGlobal: function(t) { this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.leftButton.stop(t), this.input.mousePointer.rightButton.stop(t)) }, onMouseOut: function(t) { this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t)) }, onMouseOver: function(t) { this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t) }, onMouseWheel: function(t) { this._wheelEvent && (t = this._wheelEvent.bindEvent(t)), this.event = t, this.capture && t.preventDefault(), this.wheelDelta = i.Math.clamp(-t.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, t) }, requestPointerLock: function() { if (this.game.device.pointerLock) { var t = this.game.canvas;
                    t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock(); var e = this;
                    this._pointerLockChange = function(t) { return e.pointerLockChange(t) }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0) } }, pointerLockChange: function(t) { var e = this.game.canvas;
                document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e ? (this.locked = !0, this.pointerLock.dispatch(!0, t)) : (this.locked = !1, this.pointerLock.dispatch(!1, t)) }, releasePointerLock: function() { document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0) }, stop: function() { var t = this.game.canvas;
                t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0); var e = this.game.device.wheelEvent;
                e && t.removeEventListener(e, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0) } }, i.Mouse.prototype.constructor = i.Mouse, (t.prototype = {}).constructor = t, t.prototype.bindEvent = function(e) { if (!t._stubsGenerated && e) { for (var i in e) i in t.prototype || Object.defineProperty(t.prototype, i, { get: function(t) { return function() { var e = this.originalEvent[t]; return "function" != typeof e ? e : e.bind(this.originalEvent) } }(i) });
                t._stubsGenerated = !0 } return this.originalEvent = e, this }, Object.defineProperties(t.prototype, { type: { value: "wheel" }, deltaMode: { get: function() { return this._deltaMode } }, deltaY: { get: function() { return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0 } }, deltaX: { get: function() { return this._scaleFactor * this.originalEvent.wheelDeltaX || 0 } }, deltaZ: { value: 0 } }), i.MSPointer = function(t) { this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null }, i.MSPointer.prototype = { start: function() { if (null === this._onMSPointerDown) { var t = this; if (this.game.device.mspointer) { this._onMSPointerDown = function(e) { return t.onPointerDown(e) }, this._onMSPointerMove = function(e) { return t.onPointerMove(e) }, this._onMSPointerUp = function(e) { return t.onPointerUp(e) }, this._onMSPointerUpGlobal = function(e) { return t.onPointerUpGlobal(e) }, this._onMSPointerOut = function(e) { return t.onPointerOut(e) }, this._onMSPointerOver = function(e) { return t.onPointerOver(e) }; var e = this.game.canvas;
                        e.addEventListener("MSPointerDown", this._onMSPointerDown, !1), e.addEventListener("MSPointerMove", this._onMSPointerMove, !1), e.addEventListener("MSPointerUp", this._onMSPointerUp, !1), e.addEventListener("pointerdown", this._onMSPointerDown, !1), e.addEventListener("pointermove", this._onMSPointerMove, !1), e.addEventListener("pointerup", this._onMSPointerUp, !1), e.style["-ms-content-zooming"] = "none", e.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), e.addEventListener("MSPointerOver", this._onMSPointerOver, !0), e.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), e.addEventListener("pointerover", this._onMSPointerOver, !0), e.addEventListener("pointerout", this._onMSPointerOut, !0)) } } }, onPointerDown: function(t) { this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t)) }, onPointerMove: function(t) { this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t)) }, onPointerUp: function(t) { this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t)) }, onPointerUpGlobal: function(t) { if ("mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) { var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && e.withinGame && this.onPointerUp(t) } else this.onPointerUp(t) }, onPointerOut: function(t) { if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !1;
                else { var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && (e.withinGame = !1) } this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, t), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (t.identifier = 0, e ? e.stop(t) : this.input.mousePointer.stop(t)) }, onPointerOver: function(t) { if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !0;
                else { var e = this.input.getPointerFromIdentifier(t.identifier);
                    e && (e.withinGame = !0) } this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, t) }, stop: function() { var t = this.game.canvas;
                t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0) } }, i.MSPointer.prototype.constructor = i.MSPointer, i.DeviceButton = function(t, e) { this.parent = t, this.game = t.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = e, this.onDown = new i.Signal, this.onUp = new i.Signal, this.onFloat = new i.Signal }, i.DeviceButton.prototype = { start: function(t, e) { this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e)) }, stop: function(t, e) { this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e)) }, padFloat: function(t) { this.value = t, this.onFloat.dispatch(this, t) }, justPressed: function(t) { return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time }, justReleased: function(t) { return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time }, reset: function() { this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1 }, destroy: function() { this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null } }, i.DeviceButton.prototype.constructor = i.DeviceButton, Object.defineProperty(i.DeviceButton.prototype, "duration", { get: function() { return this.isUp ? -1 : this.game.time.time - this.timeDown } }), i.Pointer = function(t, e, o) { this.game = t, this.id = e, this.type = i.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = o || i.PointerMode.CURSOR | i.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new i.DeviceButton(this, i.Pointer.LEFT_BUTTON), this.middleButton = new i.DeviceButton(this, i.Pointer.MIDDLE_BUTTON), this.rightButton = new i.DeviceButton(this, i.Pointer.RIGHT_BUTTON), this.backButton = new i.DeviceButton(this, i.Pointer.BACK_BUTTON), this.forwardButton = new i.DeviceButton(this, i.Pointer.FORWARD_BUTTON), this.eraserButton = new i.DeviceButton(this, i.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === e, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new i.Point, this.positionDown = new i.Point, this.positionUp = new i.Point, this.circle = new i.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null }, i.Pointer.NO_BUTTON = 0, i.Pointer.LEFT_BUTTON = 1, i.Pointer.RIGHT_BUTTON = 2, i.Pointer.MIDDLE_BUTTON = 4, i.Pointer.BACK_BUTTON = 8, i.Pointer.FORWARD_BUTTON = 16, i.Pointer.ERASER_BUTTON = 32, i.Pointer.prototype = { resetButtons: function() { this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset()) }, processButtonsDown: function(t, e) { i.Pointer.LEFT_BUTTON & t && this.leftButton.start(e), i.Pointer.RIGHT_BUTTON & t && this.rightButton.start(e), i.Pointer.MIDDLE_BUTTON & t && this.middleButton.start(e), i.Pointer.BACK_BUTTON & t && this.backButton.start(e), i.Pointer.FORWARD_BUTTON & t && this.forwardButton.start(e), i.Pointer.ERASER_BUTTON & t && this.eraserButton.start(e) }, processButtonsUp: function(t, e) { t === i.Mouse.LEFT_BUTTON && this.leftButton.stop(e), t === i.Mouse.RIGHT_BUTTON && this.rightButton.stop(e), t === i.Mouse.MIDDLE_BUTTON && this.middleButton.stop(e), t === i.Mouse.BACK_BUTTON && this.backButton.stop(e), t === i.Mouse.FORWARD_BUTTON && this.forwardButton.stop(e), 5 === t && this.eraserButton.stop(e) }, updateButtons: function(t) { this.button = t.button; var e = "down" === t.type.toLowerCase().substr(-4);
                void 0 !== t.buttons ? e ? this.processButtonsDown(t.buttons, t) : this.processButtonsUp(t.button, t) : e ? this.leftButton.start(t) : (this.leftButton.stop(t), this.rightButton.stop(t)), 1 === t.buttons && t.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(t), this.rightButton.start(t)), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0) }, start: function(t) { var e = this.game.input; return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.isMouse ? this.updateButtons(t) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (e.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.x = this.x, e.y = this.y, e.position.setTo(this.x, this.y), e.onDown.dispatch(this, t), e.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this }, update: function() { var t = this.game.input;
                this.active && (this.dirty && (t.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= t.holdRate && ((t.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this), this._holdSent = !0), t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate, this._history.push({ x: this.position.x, y: this.position.y }), this._history.length > t.recordLimit && this._history.shift())) }, move: function(t, e) { var o = this.game.input; if (!o.pollLocked) { if (void 0 === e && (e = !1), void 0 !== t.button && (this.button = t.button), e && this.isMouse && this.updateButtons(t), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && o.mouse.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * o.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * o.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (o.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || o.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || o.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === o.totalActivePointers) && (o.activePointer = this, o.x = this.x, o.y = this.y, o.position.setTo(o.x, o.y), o.circle.x = o.x, o.circle.y = o.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY), this.game.paused) return this; for (var n = o.moveCallbacks.length; n--;) o.moveCallbacks[n].callback.call(o.moveCallbacks[n].context, this, this.x, this.y, e); return null !== this.targetObject && !0 === this.targetObject.isDragged ? !1 === this.targetObject.update(this) && (this.targetObject = null) : o.interactiveItems.total > 0 && this.processInteractiveObjects(e), this } }, processInteractiveObjects: function(t) { var e = 0,
                    i = -1,
                    o = null,
                    n = this.game.input.interactiveItems.first; for (this.interactiveCandidates = []; n;) n.checked = !1, n.validForInput(i, e, !1) && (n.checked = !0, (t && n.checkPointerDown(this, !0) || !t && n.checkPointerOver(this, !0)) && (e = n.sprite.renderOrderID, i = n.priorityID, o = n, this.interactiveCandidates.push(n))), n = this.game.input.interactiveItems.next; for (n = this.game.input.interactiveItems.first; n;) !n.checked && n.validForInput(i, e, !0) && (t && n.checkPointerDown(this, !1) || !t && n.checkPointerOver(this, !1)) && (e = n.sprite.renderOrderID, i = n.priorityID, o = n, this.interactiveCandidates.push(n)), n = this.game.input.interactiveItems.next; return this.game.input.customCandidateHandler && (o = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, o)), this.swapTarget(o, !1), null !== this.targetObject }, swapTarget: function(t, e) { void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t, t._pointerOverHandler(this, e)) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e)) }, leave: function(t) { this.withinGame = !1, this.move(t, !1) }, stop: function(t) { var e = this.game.input; { if (!this._stateReset || !this.withinGame) return this.timeUp = this.game.time.time, (e.multiInputOverride === i.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === i.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === i.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.onUp.dispatch(this, t), this.duration >= 0 && this.duration <= e.tapRate && (this.timeUp - this.previousTapTime < e.doubleTapRate ? e.onTap.dispatch(this, !0) : e.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(t) : (this.isDown = !1, this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && e.currentPointers--, e.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this;
                    t.preventDefault() } }, justPressed: function(t) { return t = t || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + t > this.game.time.time }, justReleased: function(t) { return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time }, addClickTrampoline: function(t, e, i, o) { if (this.isDown) { for (var n = this._clickTrampolines = this._clickTrampolines || [], s = 0; s < n.length; s++)
                        if (n[s].name === t) { n.splice(s, 1); break } n.push({ name: t, targetObject: this.targetObject, callback: e, callbackContext: i, callbackArgs: o }) } }, processClickTrampolines: function() { var t = this._clickTrampolines; if (t) { for (var e = 0; e < t.length; e++) { var i = t[e];
                        i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs) } this._clickTrampolines = null, this._trampolineTargetObject = null } }, reset: function() {!1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null }, resetMovement: function() { this.movementX = 0, this.movementY = 0 } }, i.Pointer.prototype.constructor = i.Pointer, Object.defineProperty(i.Pointer.prototype, "duration", { get: function() { return this.isUp ? -1 : this.game.time.time - this.timeDown } }), Object.defineProperty(i.Pointer.prototype, "worldX", { get: function() { return this.game.world.camera.x + this.x } }), Object.defineProperty(i.Pointer.prototype, "worldY", { get: function() { return this.game.world.camera.y + this.y } }), i.PointerMode = { CURSOR: 1, CONTACT: 2 }, i.Touch = function(t) { this.game = t, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null }, i.Touch.prototype = { start: function() { if (null === this._onTouchStart) { var t = this;
                    this.game.device.touch && (this._onTouchStart = function(e) { return t.onTouchStart(e) }, this._onTouchMove = function(e) { return t.onTouchMove(e) }, this._onTouchEnd = function(e) { return t.onTouchEnd(e) }, this._onTouchEnter = function(e) { return t.onTouchEnter(e) }, this._onTouchLeave = function(e) { return t.onTouchLeave(e) }, this._onTouchCancel = function(e) { return t.onTouchCancel(e) }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1))) } }, consumeDocumentTouches: function() { this._documentTouchMove = function(t) { t.preventDefault() }, document.addEventListener("touchmove", this._documentTouchMove, !1) }, addTouchLockCallback: function(t, e, i) { void 0 === i && (i = !1), this.touchLockCallbacks.push({ callback: t, context: e, onEnd: i }) }, removeTouchLockCallback: function(t, e) { for (var i = this.touchLockCallbacks.length; i--;)
                    if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1), !0; return !1 }, onTouchStart: function(t) { for (i = this.touchLockCallbacks.length; i--;) { var e = this.touchLockCallbacks[i];!e.onEnd && e.callback.call(e.context, this, t) && this.touchLockCallbacks.splice(i, 1) } if (this.event = t, this.game.input.enabled && this.enabled) { this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault(); for (var i = 0; i < t.changedTouches.length; i++) this.game.input.startPointer(t.changedTouches[i]) } }, onTouchCancel: function(t) { if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) { this.preventDefault && t.preventDefault(); for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e]) } }, onTouchEnter: function(t) { this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault() }, onTouchLeave: function(t) { this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault() }, onTouchMove: function(t) { this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault(); for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e]) }, onTouchEnd: function(t) { for (i = this.touchLockCallbacks.length; i--;) { var e = this.touchLockCallbacks[i];
                    e.onEnd && e.callback.call(e.context, this, t) && this.touchLockCallbacks.splice(i, 1) } this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault(); for (var i = 0; i < t.changedTouches.length; i++) this.game.input.stopPointer(t.changedTouches[i]) }, stop: function() { this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel)) } }, i.Touch.prototype.constructor = i.Touch, i.InputHandler = function(t) { this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new i.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new i.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new i.Point, this.snapPoint = new i.Point, this._dragPoint = new i.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new i.Point, this._pointerData = [], this._pointerData.push({ id: 0, x: 0, y: 0, camX: 0, camY: 0, isDown: !1, isUp: !1, isOver: !1, isOut: !1, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: !1 }) }, i.InputHandler.prototype = { start: function(t, e) { if (t = t || 0, void 0 === e && (e = !1), !1 === this.enabled) { this.game.input.interactiveItems.add(this), this.useHandCursor = e, this.priorityID = t; for (var o = 0; o < 10; o++) this._pointerData[o] = { id: o, x: 0, y: 0, isDown: !1, isUp: !1, isOver: !1, isOut: !1, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: !1 };
                    this.snapOffset = new i.Point, this.enabled = !0, this._wasEnabled = !0 } return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite }, addedToGroup: function() { this._dragPhase || this._wasEnabled && !this.enabled && this.start() }, removedFromGroup: function() { this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1) }, reset: function() { this.enabled = !1; for (var t = 0; t < 10; t++) this._pointerData[t] = { id: t, x: 0, y: 0, isDown: !1, isUp: !1, isOver: !1, isOut: !1, timeOver: 0, timeOut: 0, timeDown: 0, timeUp: 0, downDuration: 0, isDragged: !1 } }, stop: function() {!1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this)) }, destroy: function() { this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null) }, validForInput: function(t, e, i) { return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!i && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e)) }, isPixelPerfect: function() { return this.pixelPerfectClick || this.pixelPerfectOver }, pointerX: function(t) { return t = t || 0, this._pointerData[t].x }, pointerY: function(t) { return t = t || 0, this._pointerData[t].y }, pointerDown: function(t) { return t = t || 0, this._pointerData[t].isDown }, pointerUp: function(t) { return t = t || 0, this._pointerData[t].isUp }, pointerTimeDown: function(t) { return t = t || 0, this._pointerData[t].timeDown }, pointerTimeUp: function(t) { return t = t || 0, this._pointerData[t].timeUp }, pointerOver: function(t) { if (!this.enabled) return !1; if (void 0 === t) { for (var e = 0; e < 10; e++)
                        if (this._pointerData[e].isOver) return !0; return !1 } return this._pointerData[t].isOver }, pointerOut: function(t) { if (!this.enabled) return !1; if (void 0 !== t) return this._pointerData[t].isOut; for (var e = 0; e < 10; e++)
                    if (this._pointerData[e].isOut) return !0 }, pointerTimeOver: function(t) { return t = t || 0, this._pointerData[t].timeOver }, pointerTimeOut: function(t) { return t = t || 0, this._pointerData[t].timeOut }, pointerDragged: function(t) { return t = t || 0, this._pointerData[t].isDragged }, checkPointerDown: function(t, e) { return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))) }, checkPointerOver: function(t, e) { return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y))) }, checkPixel: function(t, e, i) { if (this.sprite.texture.baseTexture.source) { if (null === t && null === e) { this.game.input.getLocalPosition(this.sprite, i, this._tempPoint); var t = this._tempPoint.x,
                            e = this._tempPoint.y } if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t, this._dy = e, !1; if (this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1), this.game.input.hitContext.getImageData(0, 0, 1, 1).data[3] >= this.pixelPerfectAlpha) return !0 } return !1 }, update: function(t) { if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = i.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(t), !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1) }, _pointerOverHandler: function(t, e) { if (null !== this.sprite) { var o = this._pointerData[t.id]; if (!1 === o.isOver || t.dirty) { var n = !1 === o.isOver;
                        o.isOver = !0, o.isOut = !1, o.timeOver = this.game.time.time, o.x = t.x - this.sprite.x, o.y = t.y - this.sprite.y, this.useHandCursor && !1 === o.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && n && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t) } } }, _pointerOutHandler: function(t, e) { if (null !== this.sprite) { var o = this._pointerData[t.id];
                    o.isOver = !1, o.isOut = !0, o.timeOut = this.game.time.time, this.useHandCursor && !1 === o.isDragged && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t)) } }, _touchedHandler: function(t) { if (null !== this.sprite) { var e = this._pointerData[t.id]; if (!e.isDown && e.isOver) { if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return; if (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite)) return;
                        this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop() } } }, dragTimeElapsed: function(t) { this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t) }, _releasedHandler: function(t) { if (null !== this.sprite) { var e = this._pointerData[t.id]; if (e.isDown && t.isUp) { e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown; var o = this.checkPointerOver(t);
                        this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, o), this.sprite && this.sprite.parent && this.sprite.parent.type === i.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, o), o && (o = this.checkPointerOver(t))), e.isOver = o, !o && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t) } } }, updateDrag: function(t, e) { if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t), !1; var i = this.globalToLocalX(t.x) + this._dragPoint.x + this.dragOffset.x,
                    o = this.globalToLocalY(t.y) + this._dragPoint.y + this.dragOffset.y; if (this.sprite.fixedToCamera) this.allowHorizontalDrag && (this.sprite.cameraOffset.x = i), this.allowVerticalDrag && (this.sprite.cameraOffset.y = o), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y));
                else { var n = this.game.camera.x - this._pointerData[t.id].camX,
                        s = this.game.camera.y - this._pointerData[t.id].camY;
                    this.allowHorizontalDrag && (this.sprite.x = i + n), this.allowVerticalDrag && (this.sprite.y = o + s), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y)) } return this.sprite.events.onDragUpdate.dispatch(this.sprite, t, i, o, this.snapPoint, e), !0 }, justOver: function(t, e) { return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e }, justOut: function(t, e) { return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e }, justPressed: function(t, e) { return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e }, justReleased: function(t, e) { return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e }, overDuration: function(t) { return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1 }, downDuration: function(t) { return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1 }, enableDrag: function(t, e, o, n, s, r) { void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === o && (o = !1), void 0 === n && (n = 255), void 0 === s && (s = null), void 0 === r && (r = null), this._dragPoint = new i.Point, this.draggable = !0, this.bringToTop = e, this.dragOffset = new i.Point, this.dragFromCenter = t, this.pixelPerfectClick = o, this.pixelPerfectAlpha = n, s && (this.boundsRect = s), r && (this.boundsSprite = r) }, disableDrag: function() { if (this._pointerData)
                    for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
                this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1 }, startDrag: function(t) { var e = this.sprite.x,
                    i = this.sprite.y; if (this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].camX = this.game.camera.x, this._pointerData[t.id].camY = this.game.camera.y, this._pointerData[t.id].isDragged = !0, this.sprite.fixedToCamera) { if (this.dragFromCenter) { o = this.sprite.getBounds();
                        this.sprite.cameraOffset.x = this.globalToLocalX(t.x) + (this.sprite.cameraOffset.x - o.centerX), this.sprite.cameraOffset.y = this.globalToLocalY(t.y) + (this.sprite.cameraOffset.y - o.centerY) } this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y) } else { if (this.dragFromCenter) { var o = this.sprite.getBounds();
                        this.sprite.x = this.globalToLocalX(t.x) + (this.sprite.x - o.centerX), this.sprite.y = this.globalToLocalY(t.y) + (this.sprite.y - o.centerY) } this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(t.x), this.sprite.y - this.globalToLocalY(t.y)) } this.updateDrag(t, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(e, i), this.sprite.events.onDragStart$dispatch(this.sprite, t, e, i), this._pendingDrag = !1 }, globalToLocalX: function(t) { return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t }, globalToLocalY: function(t) { return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t }, stopDrag: function(t) { this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, t), !1 === this.checkPointerOver(t) && this._pointerOutHandler(t) }, setDragLock: function(t, e) { void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e }, enableSnap: function(t, e, i, o, n, s) { void 0 === i && (i = !0), void 0 === o && (o = !1), void 0 === n && (n = 0), void 0 === s && (s = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = n, this.snapOffsetY = s, this.snapOnDrag = i, this.snapOnRelease = o }, disableSnap: function() { this.snapOnDrag = !1, this.snapOnRelease = !1 }, checkBoundsRect: function() { this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY))) }, checkBoundsSprite: function() { this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY))) } }, i.InputHandler.prototype.constructor = i.InputHandler, i.Gamepad = function(t) { this.game = t, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [new i.SinglePad(t, this), new i.SinglePad(t, this), new i.SinglePad(t, this), new i.SinglePad(t, this)] }, i.Gamepad.prototype = { addCallbacks: function(t, e) { void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t) }, start: function() { if (!this._active) { this._active = !0; var t = this;
                    this._onGamepadConnected = function(e) { return t.onGamepadConnected(e) }, this._onGamepadDisconnected = function(e) { return t.onGamepadDisconnected(e) }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1) } }, onGamepadConnected: function(t) { var e = t.gamepad;
                this._rawPads.push(e), this._gamepads[e.index].connect(e) }, onGamepadDisconnected: function(t) { var e = t.gamepad; for (var i in this._rawPads) this._rawPads[i].index === e.index && this._rawPads.splice(i, 1);
                this._gamepads[e.index].disconnect() }, update: function() { this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus() }, _pollGamepads: function() { if (this._active) { if (navigator.getGamepads) t = navigator.getGamepads();
                    else if (navigator.webkitGetGamepads) t = navigator.webkitGetGamepads();
                    else if (navigator.webkitGamepads) var t = navigator.webkitGamepads(); if (t) { this._rawPads = []; for (var e = !1, i = 0; i < t.length && (typeof t[i] !== this._prevRawGamepadTypes[i] && (e = !0, this._prevRawGamepadTypes[i] = typeof t[i]), t[i] && this._rawPads.push(t[i]), 3 !== i); i++); for (var o = 0; o < this._gamepads.length; o++) this._gamepads[o]._rawPad = this._rawPads[o]; if (e) { for (var n, s = { rawIndices: {}, padIndices: {} }, r = 0; r < this._gamepads.length; r++)
                                if ((n = this._gamepads[r]).connected)
                                    for (var a = 0; a < this._rawPads.length; a++) this._rawPads[a].index === n.index && (s.rawIndices[n.index] = !0, s.padIndices[r] = !0); for (var h = 0; h < this._gamepads.length; h++)
                                if (n = this._gamepads[h], !s.padIndices[h]) { this._rawPads.length < 1 && n.disconnect(); for (var l = 0; l < this._rawPads.length && !s.padIndices[h]; l++) { var c = this._rawPads[l]; if (c) { if (s.rawIndices[c.index]) { n.disconnect(); continue } n.connect(c), s.rawIndices[c.index] = !0, s.padIndices[h] = !0 } else n.disconnect() } } } } } }, setDeadZones: function(t) { for (var e = 0; e < this._gamepads.length; e++) this._gamepads[e].deadZone = t }, stop: function() { this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected) }, reset: function() { this.update(); for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].reset() }, justPressed: function(t, e) { for (var i = 0; i < this._gamepads.length; i++)
                    if (!0 === this._gamepads[i].justPressed(t, e)) return !0; return !1 }, justReleased: function(t, e) { for (var i = 0; i < this._gamepads.length; i++)
                    if (!0 === this._gamepads[i].justReleased(t, e)) return !0; return !1 }, isDown: function(t) { for (var e = 0; e < this._gamepads.length; e++)
                    if (!0 === this._gamepads[e].isDown(t)) return !0; return !1 }, destroy: function() { this.stop(); for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].destroy() } }, i.Gamepad.prototype.constructor = i.Gamepad, Object.defineProperty(i.Gamepad.prototype, "active", { get: function() { return this._active } }), Object.defineProperty(i.Gamepad.prototype, "supported", { get: function() { return this._gamepadSupportAvailable } }), Object.defineProperty(i.Gamepad.prototype, "padsConnected", { get: function() { return this._rawPads.length } }), Object.defineProperty(i.Gamepad.prototype, "pad1", { get: function() { return this._gamepads[0] } }), Object.defineProperty(i.Gamepad.prototype, "pad2", { get: function() { return this._gamepads[1] } }), Object.defineProperty(i.Gamepad.prototype, "pad3", { get: function() { return this._gamepads[2] } }), Object.defineProperty(i.Gamepad.prototype, "pad4", { get: function() { return this._gamepads[3] } }), i.Gamepad.BUTTON_0 = 0, i.Gamepad.BUTTON_1 = 1, i.Gamepad.BUTTON_2 = 2, i.Gamepad.BUTTON_3 = 3, i.Gamepad.BUTTON_4 = 4, i.Gamepad.BUTTON_5 = 5, i.Gamepad.BUTTON_6 = 6, i.Gamepad.BUTTON_7 = 7, i.Gamepad.BUTTON_8 = 8, i.Gamepad.BUTTON_9 = 9, i.Gamepad.BUTTON_10 = 10, i.Gamepad.BUTTON_11 = 11, i.Gamepad.BUTTON_12 = 12, i.Gamepad.BUTTON_13 = 13, i.Gamepad.BUTTON_14 = 14, i.Gamepad.BUTTON_15 = 15, i.Gamepad.AXIS_0 = 0, i.Gamepad.AXIS_1 = 1, i.Gamepad.AXIS_2 = 2, i.Gamepad.AXIS_3 = 3, i.Gamepad.AXIS_4 = 4, i.Gamepad.AXIS_5 = 5, i.Gamepad.AXIS_6 = 6, i.Gamepad.AXIS_7 = 7, i.Gamepad.AXIS_8 = 8, i.Gamepad.AXIS_9 = 9, i.Gamepad.XBOX360_A = 0, i.Gamepad.XBOX360_B = 1, i.Gamepad.XBOX360_X = 2, i.Gamepad.XBOX360_Y = 3, i.Gamepad.XBOX360_LEFT_BUMPER = 4, i.Gamepad.XBOX360_RIGHT_BUMPER = 5, i.Gamepad.XBOX360_LEFT_TRIGGER = 6, i.Gamepad.XBOX360_RIGHT_TRIGGER = 7, i.Gamepad.XBOX360_BACK = 8, i.Gamepad.XBOX360_START = 9, i.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, i.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, i.Gamepad.XBOX360_DPAD_LEFT = 14, i.Gamepad.XBOX360_DPAD_RIGHT = 15, i.Gamepad.XBOX360_DPAD_UP = 12, i.Gamepad.XBOX360_DPAD_DOWN = 13, i.Gamepad.XBOX360_STICK_LEFT_X = 0, i.Gamepad.XBOX360_STICK_LEFT_Y = 1, i.Gamepad.XBOX360_STICK_RIGHT_X = 2, i.Gamepad.XBOX360_STICK_RIGHT_Y = 3, i.Gamepad.PS3XC_X = 0, i.Gamepad.PS3XC_CIRCLE = 1, i.Gamepad.PS3XC_SQUARE = 2, i.Gamepad.PS3XC_TRIANGLE = 3, i.Gamepad.PS3XC_L1 = 4, i.Gamepad.PS3XC_R1 = 5, i.Gamepad.PS3XC_L2 = 6, i.Gamepad.PS3XC_R2 = 7, i.Gamepad.PS3XC_SELECT = 8, i.Gamepad.PS3XC_START = 9, i.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, i.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, i.Gamepad.PS3XC_DPAD_UP = 12, i.Gamepad.PS3XC_DPAD_DOWN = 13, i.Gamepad.PS3XC_DPAD_LEFT = 14, i.Gamepad.PS3XC_DPAD_RIGHT = 15, i.Gamepad.PS3XC_STICK_LEFT_X = 0, i.Gamepad.PS3XC_STICK_LEFT_Y = 1, i.Gamepad.PS3XC_STICK_RIGHT_X = 2, i.Gamepad.PS3XC_STICK_RIGHT_Y = 3, i.SinglePad = function(t, e) { this.game = t, this.index = null, this.connected = !1, this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = .26, this._padParent = e, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0 }, i.SinglePad.prototype = { addCallbacks: function(t, e) { void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t) }, getButton: function(t) { return this._buttons[t] ? this._buttons[t] : null }, pollStatus: function() { if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) { for (var t = 0; t < this._buttonsLen; t++) { var e = isNaN(this._rawPad.buttons[t]) ? this._rawPad.buttons[t].value : this._rawPad.buttons[t];
                        e !== this._buttons[t].value && (1 === e ? this.processButtonDown(t, e) : 0 === e ? this.processButtonUp(t, e) : this.processButtonFloat(t, e)) } for (var i = 0; i < this._axesLen; i++) { var o = this._rawPad.axes[i];
                        o > 0 && o > this.deadZone || o < 0 && o < -this.deadZone ? this.processAxisChange(i, o) : this.processAxisChange(i, 0) } this._prevTimestamp = this._rawPad.timestamp } }, connect: function(t) { var e = !this.connected;
                this.connected = !0, this.index = t.index, this._rawPad = t, this._buttons = [], this._buttonsLen = t.buttons.length, this._axes = [], this._axesLen = t.axes.length; for (var o = 0; o < this._axesLen; o++) this._axes[o] = t.axes[o]; for (var n in t.buttons) n = parseInt(n, 10), this._buttons[n] = new i.DeviceButton(this, n);
                e && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), e && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext) }, disconnect: function() { var t = this.connected,
                    e = this.index;
                this.connected = !1, this.index = null, this._rawPad = void 0; for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
                this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, t && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, e), t && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext) }, destroy: function() { this._rawPad = void 0; for (var t = 0; t < this._buttonsLen; t++) this._buttons[t].destroy();
                this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null }, processAxisChange: function(t, e) { this._axes[t] !== e && (this._axes[t] = e, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, t, e), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, t, e)) }, processButtonDown: function(t, e) { this._buttons[t] && this._buttons[t].start(null, e), this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, t, e, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, t, e) }, processButtonUp: function(t, e) { this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, t, e, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].stop(null, e) }, processButtonFloat: function(t, e) { this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, t, e, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].padFloat(e) }, axis: function(t) { return !!this._axes[t] && this._axes[t] }, isDown: function(t) { return !!this._buttons[t] && this._buttons[t].isDown }, isUp: function(t) { return !!this._buttons[t] && this._buttons[t].isUp }, justReleased: function(t, e) { if (this._buttons[t]) return this._buttons[t].justReleased(e) }, justPressed: function(t, e) { if (this._buttons[t]) return this._buttons[t].justPressed(e) }, buttonValue: function(t) { return this._buttons[t] ? this._buttons[t].value : null }, reset: function() { for (var t = 0; t < this._axes.length; t++) this._axes[t] = 0 } }, i.SinglePad.prototype.constructor = i.SinglePad, i.Key = function(t, e) { this.game = t, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.repeats = 0, this.keyCode = e, this.onDown = new i.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new i.Signal, this._justDown = !1, this._justUp = !1 }, i.Key.prototype = { update: function() { this._enabled && this.isDown && (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this)) }, processKeyDown: function(t) { this._enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this))) }, processKeyUp: function(t) { this._enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this._justUp = !0, this.onUp.dispatch(this))) }, reset: function(t) { void 0 === t && (t = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this._enabled = !0, this._justDown = !1, this._justUp = !1, t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null) }, downDuration: function(t) { return void 0 === t && (t = 50), this.isDown && this.duration < t }, upDuration: function(t) { return void 0 === t && (t = 50), !this.isDown && this.game.time.time - this.timeUp < t } }, Object.defineProperty(i.Key.prototype, "justDown", { get: function() { var t = this._justDown; return this._justDown = !1, t } }), Object.defineProperty(i.Key.prototype, "justUp", { get: function() { var t = this._justUp; return this._justUp = !1, t } }), Object.defineProperty(i.Key.prototype, "enabled", { get: function() { return this._enabled }, set: function(t) {
                (t = !!t) !== this._enabled && (t || this.reset(!1), this._enabled = t) } }), i.Key.prototype.constructor = i.Key, i.Keyboard = function(t) { this.game = t, this.enabled = !0, this.event = null, this.pressEvent = null, this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0 }, i.Keyboard.prototype = { addCallbacks: function(t, e, i, o) { this.callbackContext = t, void 0 !== e && null !== e && (this.onDownCallback = e), void 0 !== i && null !== i && (this.onUpCallback = i), void 0 !== o && null !== o && (this.onPressCallback = o) }, addKey: function(t) { return this._keys[t] || (this._keys[t] = new i.Key(this.game, t), this.addKeyCapture(t)), this._keys[t] }, addKeys: function(t) { var e = {}; for (var i in t) e[i] = this.addKey(t[i]); return e }, removeKey: function(t) { this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t)) }, createCursorKeys: function() { return this.addKeys({ up: i.KeyCode.UP, down: i.KeyCode.DOWN, left: i.KeyCode.LEFT, right: i.KeyCode.RIGHT }) }, start: function() { if (!this.game.device.cocoonJS && null === this._onKeyDown) { var t = this;
                    this._onKeyDown = function(e) { return t.processKeyDown(e) }, this._onKeyUp = function(e) { return t.processKeyUp(e) }, this._onKeyPress = function(e) { return t.processKeyPress(e) }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1) } }, stop: function() { window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null }, destroy: function() { this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0 }, addKeyCapture: function(t) { if ("object" == typeof t)
                    for (var e in t) this._capture[t[e]] = !0;
                else this._capture[t] = !0 }, removeKeyCapture: function(t) { delete this._capture[t] }, clearCaptures: function() { this._capture = {} }, update: function() { for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update() }, processKeyDown: function(t) { if (this.event = t, this.game.input.enabled && this.enabled) { var e = t.keyCode;
                    this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new i.Key(this.game, e)), this._keys[e].processKeyDown(t), this._k = e, this.onDownCallback && this.onDownCallback.call(this.callbackContext, t) } }, processKeyPress: function(t) { this.pressEvent = t, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t) }, processKeyUp: function(t) { if (this.event = t, this.game.input.enabled && this.enabled) { var e = t.keyCode;
                    this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new i.Key(this.game, e)), this._keys[e].processKeyUp(t), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t) } }, reset: function(t) { void 0 === t && (t = !0), this.event = null; for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t) }, downDuration: function(t, e) { return this._keys[t] ? this._keys[t].downDuration(e) : null }, upDuration: function(t, e) { return this._keys[t] ? this._keys[t].upDuration(e) : null }, isDown: function(t) { return this._keys[t] ? this._keys[t].isDown : null } }, Object.defineProperty(i.Keyboard.prototype, "lastChar", { get: function() { return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode) } }), Object.defineProperty(i.Keyboard.prototype, "lastKey", { get: function() { return this._keys[this._k] } }), i.Keyboard.prototype.constructor = i.Keyboard, i.KeyCode = { A: "A".charCodeAt(0), B: "B".charCodeAt(0), C: "C".charCodeAt(0), D: "D".charCodeAt(0), E: "E".charCodeAt(0), F: "F".charCodeAt(0), G: "G".charCodeAt(0), H: "H".charCodeAt(0), I: "I".charCodeAt(0), J: "J".charCodeAt(0), K: "K".charCodeAt(0), L: "L".charCodeAt(0), M: "M".charCodeAt(0), N: "N".charCodeAt(0), O: "O".charCodeAt(0), P: "P".charCodeAt(0), Q: "Q".charCodeAt(0), R: "R".charCodeAt(0), S: "S".charCodeAt(0), T: "T".charCodeAt(0), U: "U".charCodeAt(0), V: "V".charCodeAt(0), W: "W".charCodeAt(0), X: "X".charCodeAt(0), Y: "Y".charCodeAt(0), Z: "Z".charCodeAt(0), ZERO: "0".charCodeAt(0), ONE: "1".charCodeAt(0), TWO: "2".charCodeAt(0), THREE: "3".charCodeAt(0), FOUR: "4".charCodeAt(0), FIVE: "5".charCodeAt(0), SIX: "6".charCodeAt(0), SEVEN: "7".charCodeAt(0), EIGHT: "8".charCodeAt(0), NINE: "9".charCodeAt(0), NUMPAD_0: 96, NUMPAD_1: 97, NUMPAD_2: 98, NUMPAD_3: 99, NUMPAD_4: 100, NUMPAD_5: 101, NUMPAD_6: 102, NUMPAD_7: 103, NUMPAD_8: 104, NUMPAD_9: 105, NUMPAD_MULTIPLY: 106, NUMPAD_ADD: 107, NUMPAD_ENTER: 108, NUMPAD_SUBTRACT: 109, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, F13: 124, F14: 125, F15: 126, COLON: 186, EQUALS: 187, COMMA: 188, UNDERSCORE: 189, PERIOD: 190, QUESTION_MARK: 191, TILDE: 192, OPEN_BRACKET: 219, BACKWARD_SLASH: 220, CLOSED_BRACKET: 221, QUOTES: 222, BACKSPACE: 8, TAB: 9, CLEAR: 12, ENTER: 13, SHIFT: 16, CONTROL: 17, ALT: 18, CAPS_LOCK: 20, ESC: 27, SPACEBAR: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PLUS: 43, MINUS: 44, INSERT: 45, DELETE: 46, HELP: 47, NUM_LOCK: 144 }; for (var n in i.KeyCode) i.KeyCode.hasOwnProperty(n) && !n.match(/[a-z]/) && (i.Keyboard[n] = i.KeyCode[n]);
        i.Component = function() {}, i.Component.Angle = function() {}, i.Component.Angle.prototype = { angle: { get: function() { return i.Math.wrapAngle(i.Math.radToDeg(this.rotation)) }, set: function(t) { this.rotation = i.Math.degToRad(i.Math.wrapAngle(t)) } } }, i.Component.Animation = function() {}, i.Component.Animation.prototype = { play: function(t, e, i, o) { if (this.animations) return this.animations.play(t, e, i, o) } }, i.Component.AutoCull = function() {}, i.Component.AutoCull.prototype = { autoCull: !1, inCamera: { get: function() { return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds) } } }, i.Component.Bounds = function() {}, i.Component.Bounds.prototype = { offsetX: { get: function() { return this.anchor.x * this.width } }, offsetY: { get: function() { return this.anchor.y * this.height } }, centerX: { get: function() { return this.x - this.offsetX + .5 * this.width }, set: function(t) { this.x = t + this.offsetX - .5 * this.width } }, centerY: { get: function() { return this.y - this.offsetY + .5 * this.height }, set: function(t) { this.y = t + this.offsetY - .5 * this.height } }, left: { get: function() { return this.x - this.offsetX }, set: function(t) { this.x = t + this.offsetX } }, right: { get: function() { return this.x + this.width - this.offsetX }, set: function(t) { this.x = t - this.width + this.offsetX } }, top: { get: function() { return this.y - this.offsetY }, set: function(t) { this.y = t + this.offsetY } }, bottom: { get: function() { return this.y + this.height - this.offsetY }, set: function(t) { this.y = t - this.height + this.offsetY } }, alignIn: function(t, e, o, n) { switch (void 0 === o && (o = 0), void 0 === n && (n = 0), e) {
                    default:
                    case i.TOP_LEFT:
                        this.left = t.left - o, this.top = t.top - n; break;
                    case i.TOP_CENTER:
                        this.centerX = t.centerX + o, this.top = t.top - n; break;
                    case i.TOP_RIGHT:
                        this.right = t.right + o, this.top = t.top - n; break;
                    case i.LEFT_CENTER:
                        this.left = t.left - o, this.centerY = t.centerY + n; break;
                    case i.CENTER:
                        this.centerX = t.centerX + o, this.centerY = t.centerY + n; break;
                    case i.RIGHT_CENTER:
                        this.right = t.right + o, this.centerY = t.centerY + n; break;
                    case i.BOTTOM_LEFT:
                        this.left = t.left - o, this.bottom = t.bottom + n; break;
                    case i.BOTTOM_CENTER:
                        this.centerX = t.centerX + o, this.bottom = t.bottom + n; break;
                    case i.BOTTOM_RIGHT:
                        this.right = t.right + o, this.bottom = t.bottom + n } return this }, alignTo: function(t, e, o, n) { switch (void 0 === o && (o = 0), void 0 === n && (n = 0), e) {
                    default:
                    case i.TOP_LEFT:
                        this.left = t.left - o, this.bottom = t.top - n; break;
                    case i.TOP_CENTER:
                        this.centerX = t.centerX + o, this.bottom = t.top - n; break;
                    case i.TOP_RIGHT:
                        this.right = t.right + o, this.bottom = t.top - n; break;
                    case i.LEFT_TOP:
                        this.right = t.left - o, this.top = t.top - n; break;
                    case i.LEFT_CENTER:
                        this.right = t.left - o, this.centerY = t.centerY + n; break;
                    case i.LEFT_BOTTOM:
                        this.right = t.left - o, this.bottom = t.bottom + n; break;
                    case i.RIGHT_TOP:
                        this.left = t.right + o, this.top = t.top - n; break;
                    case i.RIGHT_CENTER:
                        this.left = t.right + o, this.centerY = t.centerY + n; break;
                    case i.RIGHT_BOTTOM:
                        this.left = t.right + o, this.bottom = t.bottom + n; break;
                    case i.BOTTOM_LEFT:
                        this.left = t.left - o, this.top = t.bottom + n; break;
                    case i.BOTTOM_CENTER:
                        this.centerX = t.centerX + o, this.top = t.bottom + n; break;
                    case i.BOTTOM_RIGHT:
                        this.right = t.right + o, this.top = t.bottom + n } return this } }, i.Group.prototype.alignIn = i.Component.Bounds.prototype.alignIn, i.Group.prototype.alignTo = i.Component.Bounds.prototype.alignTo, i.Component.BringToTop = function() {}, i.Component.BringToTop.prototype.bringToTop = function() { return this.parent && this.parent.bringToTop(this), this }, i.Component.BringToTop.prototype.sendToBack = function() { return this.parent && this.parent.sendToBack(this), this }, i.Component.BringToTop.prototype.moveUp = function() { return this.parent && this.parent.moveUp(this), this }, i.Component.BringToTop.prototype.moveDown = function() { return this.parent && this.parent.moveDown(this), this }, i.Component.Core = function() {}, i.Component.Core.install = function(t) { i.Utils.mixinPrototype(this, i.Component.Core.prototype), this.components = {}; for (var e = 0; e < t.length; e++) { var o = t[e],
                    n = !1; "Destroy" === o && (n = !0), i.Utils.mixinPrototype(this, i.Component[o].prototype, n), this.components[o] = !0 } }, i.Component.Core.init = function(t, e, o, n, s) { this.game = t, this.key = n, this.data = {}, this.position.set(e, o), this.world = new i.Point(e, o), this.previousPosition = new i.Point(e, o), this.events = new i.Events(this), this._bounds = new i.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new i.AnimationManager(this)), this.components.LoadTexture && null !== n && this.loadTexture(n, s), this.components.FixedToCamera && (this.cameraOffset = new i.Point(e, o)) }, i.Component.Core.preUpdate = function() { if (!this.pendingDestroy) { if (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate(); for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate(); return !0 } this.destroy() }, i.Component.Core.prototype = { game: null, name: "", data: {}, components: {}, z: 0, events: void 0, animations: void 0, key: "", world: null, debug: !1, previousPosition: null, previousRotation: 0, renderOrderID: 0, fresh: !0, pendingDestroy: !1, _bounds: null, _exists: !0, exists: { get: function() { return this._exists }, set: function(t) { t ? (this._exists = !0, this.body && this.body.type === i.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === i.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1) } }, update: function() {}, postUpdate: function() { this.customRender && this.key.render(), this.components.PhysicsBody && i.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && i.Component.FixedToCamera.postUpdate.call(this); for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate() } }, i.Component.Crop = function() {}, i.Component.Crop.prototype = { cropRect: null, _crop: null, crop: function(t, e) { void 0 === e && (e = !1), t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : e && null === this.cropRect ? this.cropRect = new i.Rectangle(t.x, t.y, t.width, t.height) : this.cropRect = t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame()) }, updateCrop: function() { if (this.cropRect) { var t = this.texture.crop.x,
                        e = this.texture.crop.y,
                        o = this.texture.crop.width,
                        n = this.texture.crop.height;
                    this._crop = i.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y; var s = Math.max(this._frame.x, this._crop.x),
                        r = Math.max(this._frame.y, this._crop.y),
                        a = Math.min(this._frame.right, this._crop.right) - s,
                        h = Math.min(this._frame.bottom, this._crop.bottom) - r;
                    this.texture.crop.x = s, this.texture.crop.y = r, this.texture.crop.width = a, this.texture.crop.height = h, this.texture.frame.width = Math.min(a, this.cropRect.width), this.texture.frame.height = Math.min(h, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || t === s && e === r && o === a && n === h || (this.texture.requiresReTint = !0) } } }, i.Component.Delta = function() {}, i.Component.Delta.prototype = { deltaX: { get: function() { return this.world.x - this.previousPosition.x } }, deltaY: { get: function() { return this.world.y - this.previousPosition.y } }, deltaZ: { get: function() { return this.rotation - this.previousRotation } } }, i.Component.Destroy = function() {}, i.Component.Destroy.prototype = { destroyPhase: !1, destroy: function(t, e) { if (null !== this.game && !this.destroyPhase) { void 0 === t && (t = !0), void 0 === e && (e = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof i.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this); var o = this.children.length; if (t)
                        for (; o--;) this.children[o].destroy(t);
                    else
                        for (; o--;) this.removeChild(this.children[o]);
                    this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), i.Video && this.key instanceof i.Video && this.key.onChangeSource.remove(this.resizeFrame, this), i.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), e && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1 } } }, i.Events = function(t) { this.parent = t }, i.Events.prototype = { destroy: function() { this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose() }, onAddedToGroup: null, onRemovedFromGroup: null, onRemovedFromWorld: null, onDestroy: null, onKilled: null, onRevived: null, onOutOfBounds: null, onEnterBounds: null, onInputOver: null, onInputOut: null, onInputDown: null, onInputUp: null, onDragStart: null, onDragUpdate: null, onDragStop: null, onAnimationStart: null, onAnimationComplete: null, onAnimationLoop: null }, i.Events.prototype.constructor = i.Events; for (var s in i.Events.prototype) i.Events.prototype.hasOwnProperty(s) && 0 === s.indexOf("on") && null === i.Events.prototype[s] && function(t, e) { "use strict";
            Object.defineProperty(i.Events.prototype, t, { get: function() { return this[e] || (this[e] = new i.Signal) } }), i.Events.prototype[t + "$dispatch"] = function() { return this[e] ? this[e].dispatch.apply(this[e], arguments) : null } }(s, "_" + s);
        i.Component.FixedToCamera = function() {}, i.Component.FixedToCamera.postUpdate = function() { this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y) }, i.Component.FixedToCamera.prototype = { _fixedToCamera: !1, fixedToCamera: { get: function() { return this._fixedToCamera }, set: function(t) { t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1 } }, cameraOffset: new i.Point }, i.Component.Health = function() {}, i.Component.Health.prototype = { health: 1, maxHealth: 100, damage: function(t) { return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this }, setHealth: function(t) { return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this }, heal: function(t) { return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this } }, i.Component.InCamera = function() {}, i.Component.InCamera.prototype = { inCamera: { get: function() { return this.game.world.camera.view.intersects(this._bounds) } } }, i.Component.InputEnabled = function() {}, i.Component.InputEnabled.prototype = { input: null, inputEnabled: { get: function() { return this.input && this.input.enabled }, set: function(t) { t ? null === this.input ? (this.input = new i.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop() } } }, i.Component.InWorld = function() {}, i.Component.InWorld.preUpdate = function() { if (this.autoCull || this.checkWorldBounds) { if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                    if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                    else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1; if (this.checkWorldBounds)
                    if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                    else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1 } return !0 }, i.Component.InWorld.prototype = { checkWorldBounds: !1, outOfBoundsKill: !1, outOfCameraBoundsKill: !1, _outOfBoundsFired: !1, inWorld: { get: function() { return this.game.world.bounds.intersects(this.getBounds()) } } }, i.Component.LifeSpan = function() {}, i.Component.LifeSpan.preUpdate = function() { return !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) || (this.kill(), !1) }, i.Component.LifeSpan.prototype = { alive: !0, lifespan: 0, revive: function(t) { return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this }, kill: function() { return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this } }, i.Component.LoadTexture = function() {}, i.Component.LoadTexture.prototype = { customRender: !1, _frame: null, loadTexture: function(t, e, o) { t === i.PENDING_ATLAS ? (t = e, e = 0) : e = e || 0, (o || void 0 === o) && this.animations && this.animations.stop(), this.key = t, this.customRender = !1; var n = this.game.cache,
                    s = !0,
                    r = !this.texture.baseTexture.scaleMode; if (i.RenderTexture && t instanceof i.RenderTexture) this.key = t.key, this.setTexture(t);
                else if (i.BitmapData && t instanceof i.BitmapData) this.customRender = !0, this.setTexture(t.texture), s = n.hasFrameData(t.key, i.Cache.BITMAPDATA) ? !this.animations.loadFrameData(n.getFrameData(t.key, i.Cache.BITMAPDATA), e) : !this.animations.loadFrameData(t.frameData, 0);
                else if (i.Video && t instanceof i.Video) { this.customRender = !0; var a = t.texture.valid;
                    this.setTexture(t.texture), this.setFrame(t.texture.frame.clone()), t.onChangeSource.add(this.resizeFrame, this), this.texture.valid = a } else if (i.Tilemap && t instanceof i.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(t.canvas));
                else if (t instanceof PIXI.Texture) this.setTexture(t);
                else { var h = n.getImage(t, !0);
                    this.key = h.key, this.setTexture(new PIXI.Texture(h.base)), this.texture.baseTexture.skipRender = "__default" === t, s = !this.animations.loadFrameData(h.frameData, e) } s && (this._frame = i.Rectangle.clone(this.texture.frame)), r || (this.texture.baseTexture.scaleMode = 1) }, setFrame: function(t) { this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = { x: t.spriteSourceSizeX, y: t.spriteSourceSizeY, width: t.sourceSizeW, height: t.sourceSizeH }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0) }, resizeFrame: function(t, e, i) { this.texture.frame.resize(e, i), this.texture.setFrame(this.texture.frame) }, resetFrame: function() { this._frame && this.setFrame(this._frame) }, frame: { get: function() { return this.animations.frame }, set: function(t) { this.animations.frame = t } }, frameName: { get: function() { return this.animations.frameName }, set: function(t) { this.animations.frameName = t } } }, i.Component.Overlap = function() {}, i.Component.Overlap.prototype = { overlap: function(t) { return i.Rectangle.intersects(this.getBounds(), t.getBounds()) } }, i.Component.PhysicsBody = function() {}, i.Component.PhysicsBody.preUpdate = function() { return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1)) }, i.Component.PhysicsBody.postUpdate = function() { this.exists && this.body && this.body.postUpdate() }, i.Component.PhysicsBody.prototype = { body: null, x: { get: function() { return this.position.x }, set: function(t) { this.position.x = t, this.body && !this.body.dirty && (this.body._reset = !0) } }, y: { get: function() { return this.position.y }, set: function(t) { this.position.y = t, this.body && !this.body.dirty && (this.body._reset = !0) } } }, i.Component.Reset = function() {}, i.Component.Reset.prototype.reset = function(t, e, i) { return void 0 === i && (i = 1), this.world.set(t, e), this.position.set(t, e), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = i), this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1), this }, i.Component.ScaleMinMax = function() {}, i.Component.ScaleMinMax.prototype = { transformCallback: null, transformCallbackContext: this, scaleMin: null, scaleMax: null, checkTransform: function(t) { this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)), this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y)) }, setScaleMinMax: function(t, e, o, n) { void 0 === e ? e = o = n = t : void 0 === o && (o = n = e, e = t), null === t ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(t, e) : this.scaleMin = new i.Point(t, e), null === o ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(o, n) : this.scaleMax = new i.Point(o, n), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this) } }, i.Component.Smoothed = function() {}, i.Component.Smoothed.prototype = { smoothed: { get: function() { return !this.texture.baseTexture.scaleMode }, set: function(t) { t ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1) } } }, i.GameObjectFactory = function(t) { this.game = t, this.world = this.game.world }, i.GameObjectFactory.prototype = { existing: function(t) { return this.world.add(t) }, weapon: function(t, e, o, n) { var s = this.game.plugins.add(i.Weapon); return s.createBullets(t, e, o, n), s }, image: function(t, e, o, n, s) { return void 0 === s && (s = this.world), s.add(new i.Image(this.game, t, e, o, n)) }, sprite: function(t, e, i, o, n) { return void 0 === n && (n = this.world), n.create(t, e, i, o) }, creature: function(t, e, o, n, s) { void 0 === s && (s = this.world); var r = new i.Creature(this.game, t, e, o, n); return s.add(r), r }, tween: function(t) { return this.game.tweens.create(t) }, group: function(t, e, o, n, s) { return new i.Group(this.game, t, e, o, n, s) }, physicsGroup: function(t, e, o, n) { return new i.Group(this.game, e, o, n, !0, t) }, spriteBatch: function(t, e, o) { return void 0 === t && (t = null), void 0 === e && (e = "group"), void 0 === o && (o = !1), new i.SpriteBatch(this.game, t, e, o) }, audio: function(t, e, i, o) { return this.game.sound.add(t, e, i, o) }, sound: function(t, e, i, o) { return this.game.sound.add(t, e, i, o) }, audioSprite: function(t) { return this.game.sound.addSprite(t) }, tileSprite: function(t, e, o, n, s, r, a) { return void 0 === a && (a = this.world), a.add(new i.TileSprite(this.game, t, e, o, n, s, r)) }, rope: function(t, e, o, n, s, r) { return void 0 === r && (r = this.world), r.add(new i.Rope(this.game, t, e, o, n, s)) }, text: function(t, e, o, n, s) { return void 0 === s && (s = this.world), s.add(new i.Text(this.game, t, e, o, n)) }, button: function(t, e, o, n, s, r, a, h, l, c) { return void 0 === c && (c = this.world), c.add(new i.Button(this.game, t, e, o, n, s, r, a, h, l)) }, graphics: function(t, e, o) { return void 0 === o && (o = this.world), o.add(new i.Graphics(this.game, t, e)) }, emitter: function(t, e, o) { return this.game.particles.add(new i.Particles.Arcade.Emitter(this.game, t, e, o)) }, retroFont: function(t, e, o, n, s, r, a, h, l) { return new i.RetroFont(this.game, t, e, o, n, s, r, a, h, l) }, bitmapText: function(t, e, o, n, s, r) { return void 0 === r && (r = this.world), r.add(new i.BitmapText(this.game, t, e, o, n, s)) }, tilemap: function(t, e, o, n, s) { return new i.Tilemap(this.game, t, e, o, n, s) }, renderTexture: function(t, e, o, n) { void 0 !== o && "" !== o || (o = this.game.rnd.uuid()), void 0 === n && (n = !1); var s = new i.RenderTexture(this.game, t, e, o); return n && this.game.cache.addRenderTexture(o, s), s }, video: function(t, e) { return new i.Video(this.game, t, e) }, bitmapData: function(t, e, o, n) { void 0 === n && (n = !1), void 0 !== o && "" !== o || (o = this.game.rnd.uuid()); var s = new i.BitmapData(this.game, o, t, e); return n && this.game.cache.addBitmapData(o, s), s }, filter: function(t) { var e = Array.prototype.slice.call(arguments, 1); return (t = new i.Filter[t](this.game)).init.apply(t, e), t }, plugin: function(t) { return this.game.plugins.add(t) } }, i.GameObjectFactory.prototype.constructor = i.GameObjectFactory, i.GameObjectCreator = function(t) { this.game = t, this.world = this.game.world }, i.GameObjectCreator.prototype = { image: function(t, e, o, n) { return new i.Image(this.game, t, e, o, n) }, sprite: function(t, e, o, n) { return new i.Sprite(this.game, t, e, o, n) }, tween: function(t) { return new i.Tween(t, this.game, this.game.tweens) }, group: function(t, e, o, n, s) { return new i.Group(this.game, t, e, o, n, s) }, spriteBatch: function(t, e, o) { return void 0 === e && (e = "group"), void 0 === o && (o = !1), new i.SpriteBatch(this.game, t, e, o) }, audio: function(t, e, i, o) { return this.game.sound.add(t, e, i, o) }, audioSprite: function(t) { return this.game.sound.addSprite(t) }, sound: function(t, e, i, o) { return this.game.sound.add(t, e, i, o) }, tileSprite: function(t, e, o, n, s, r) { return new i.TileSprite(this.game, t, e, o, n, s, r) }, rope: function(t, e, o, n, s) { return new i.Rope(this.game, t, e, o, n, s) }, text: function(t, e, o, n) { return new i.Text(this.game, t, e, o, n) }, button: function(t, e, o, n, s, r, a, h, l) { return new i.Button(this.game, t, e, o, n, s, r, a, h, l) }, graphics: function(t, e) { return new i.Graphics(this.game, t, e) }, emitter: function(t, e, o) { return new i.Particles.Arcade.Emitter(this.game, t, e, o) }, retroFont: function(t, e, o, n, s, r, a, h, l) { return new i.RetroFont(this.game, t, e, o, n, s, r, a, h, l) }, bitmapText: function(t, e, o, n, s, r) { return new i.BitmapText(this.game, t, e, o, n, s, r) }, tilemap: function(t, e, o, n, s) { return new i.Tilemap(this.game, t, e, o, n, s) }, renderTexture: function(t, e, o, n) { void 0 !== o && "" !== o || (o = this.game.rnd.uuid()), void 0 === n && (n = !1); var s = new i.RenderTexture(this.game, t, e, o); return n && this.game.cache.addRenderTexture(o, s), s }, bitmapData: function(t, e, o, n) { void 0 === n && (n = !1), void 0 !== o && "" !== o || (o = this.game.rnd.uuid()); var s = new i.BitmapData(this.game, o, t, e); return n && this.game.cache.addBitmapData(o, s), s }, filter: function(t) { var e = Array.prototype.slice.call(arguments, 1); return (t = new i.Filter[t](this.game)).init.apply(t, e), t } }, i.GameObjectCreator.prototype.constructor = i.GameObjectCreator, i.Sprite = function(t, e, o, n, s) { e = e || 0, o = o || 0, n = n || null, s = s || null, this.type = i.SPRITE, this.physicsType = i.SPRITE, PIXI.Sprite.call(this, i.Cache.DEFAULT), i.Component.Core.init.call(this, t, e, o, n, s) }, i.Sprite.prototype = Object.create(PIXI.Sprite.prototype), i.Sprite.prototype.constructor = i.Sprite, i.Component.Core.install.call(i.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), i.Sprite.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Sprite.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Sprite.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Sprite.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Sprite.prototype.preUpdate = function() { return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore() }, i.Image = function(t, e, o, n, s) { e = e || 0, o = o || 0, n = n || null, s = s || null, this.type = i.IMAGE, PIXI.Sprite.call(this, i.Cache.DEFAULT), i.Component.Core.init.call(this, t, e, o, n, s) }, i.Image.prototype = Object.create(PIXI.Sprite.prototype), i.Image.prototype.constructor = i.Image, i.Component.Core.install.call(i.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), i.Image.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Image.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Image.prototype.preUpdate = function() { return !!this.preUpdateInWorld() && this.preUpdateCore() }, i.Button = function(t, e, o, n, s, r, a, h, l, c) { e = e || 0, o = o || 0, n = n || null, s = s || null, r = r || this, i.Image.call(this, t, e, o, n, h), this.type = i.BUTTON, this.physicsType = i.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new i.Signal, this.onInputOut = new i.Signal, this.onInputDown = new i.Signal, this.onInputUp = new i.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = i.PointerMode.TOUCH, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(a, h, l, c), null !== s && this.onInputUp.add(s, r), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this) }, i.Button.prototype = Object.create(i.Image.prototype), i.Button.prototype.constructor = i.Button;
        i.Button.prototype.clearFrames = function() { this.setFrames(null, null, null, null) }, i.Button.prototype.removedFromWorld = function() { this.inputEnabled = !1 }, i.Button.prototype.setStateFrame = function(t, e, i) { var o = "_on" + t + "Frame";
            null !== e ? (this[o] = e, i && this.changeStateFrame(t)) : this[o] = null }, i.Button.prototype.changeStateFrame = function(t) { if (this.freezeFrames) return !1; var e = this["_on" + t + "Frame"]; return "string" == typeof e ? (this.frameName = e, !0) : "number" == typeof e && (this.frame = e, !0) }, i.Button.prototype.setFrames = function(t, e, i, o) { this.setStateFrame("Over", t, this.input.pointerOver()), this.setStateFrame("Out", e, !this.input.pointerOver()), this.setStateFrame("Down", i, this.input.pointerDown()), this.setStateFrame("Up", o, this.input.pointerUp()) }, i.Button.prototype.setStateSound = function(t, e, o) { var n = "on" + t + "Sound",
                s = "on" + t + "SoundMarker";
            e instanceof i.Sound || e instanceof i.AudioSprite ? (this[n] = e, this[s] = "string" == typeof o ? o : "") : (this[n] = null, this[s] = "") }, i.Button.prototype.playStateSound = function(t) { var e = this["on" + t + "Sound"]; if (e) { var i = this["on" + t + "SoundMarker"]; return e.play(i), !0 } return !1 }, i.Button.prototype.setSounds = function(t, e, i, o, n, s, r, a) { this.setStateSound("Over", t, e), this.setStateSound("Out", n, s), this.setStateSound("Down", i, o), this.setStateSound("Up", r, a) }, i.Button.prototype.setOverSound = function(t, e) { this.setStateSound("Over", t, e) }, i.Button.prototype.setOutSound = function(t, e) { this.setStateSound("Out", t, e) }, i.Button.prototype.setDownSound = function(t, e) { this.setStateSound("Down", t, e) }, i.Button.prototype.setUpSound = function(t, e) { this.setStateSound("Up", t, e) }, i.Button.prototype.onInputOverHandler = function(t, e) { e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame("Over"), this.onOverMouseOnly && !e.isMouse || (this.playStateSound("Over"), this.onInputOver && this.onInputOver.dispatch(this, e))) }, i.Button.prototype.onInputOutHandler = function(t, e) { this.changeStateFrame("Out"), this.playStateSound("Out"), this.onInputOut && this.onInputOut.dispatch(this, e) }, i.Button.prototype.onInputDownHandler = function(t, e) { this.changeStateFrame("Down"), this.playStateSound("Down"), this.onInputDown && this.onInputDown.dispatch(this, e) }, i.Button.prototype.onInputUpHandler = function(t, e, i) { this.playStateSound("Up"), this.onInputUp && this.onInputUp.dispatch(this, e, i), this.freezeFrames || (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode ? this.changeStateFrame("Out") : this.changeStateFrame("Up") || (i ? this.changeStateFrame("Over") : this.changeStateFrame("Out"))) }, i.SpriteBatch = function(t, e, o, n) { void 0 !== e && null !== e || (e = t.world), PIXI.SpriteBatch.call(this), i.Group.call(this, t, e, o, n), this.type = i.SPRITEBATCH }, i.SpriteBatch.prototype = i.Utils.extend(!0, i.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, i.Group.prototype), i.SpriteBatch.prototype.constructor = i.SpriteBatch, i.BitmapData = function(t, e, o, n, s) { void 0 !== o && 0 !== o || (o = 256), void 0 !== n && 0 !== n || (n = 256), void 0 === s && (s = !1), this.game = t, this.key = e, this.width = o, this.height = n, this.canvas = i.Canvas.create(this, o, n, null, s), this.context = this.canvas.getContext("2d", { alpha: !0 }), this.ctx = this.context, this.smoothProperty = t.renderType === i.CANVAS ? t.renderer.renderSession.smoothProperty : i.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, o, n), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new i.FrameData, this.textureFrame = this.frameData.addFrame(new i.Frame(0, 0, 0, o, n, "bitmapData")), this.texture.frame = this.textureFrame, this.type = i.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new i.Point, this._size = new i.Point, this._scale = new i.Point, this._rotate = 0, this._alpha = { prev: 1, current: 1 }, this._anchor = new i.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new i.Circle, this._swapCanvas = void 0 }, i.BitmapData.prototype = { move: function(t, e, i) { return 0 !== t && this.moveH(t, i), 0 !== e && this.moveV(e, i), this }, moveH: function(t, e) { void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height)); var i = this._swapCanvas.getContext("2d"),
                    o = this.height,
                    n = this.canvas; if (i.clearRect(0, 0, this.width, this.height), t < 0) { t = Math.abs(t);
                    s = this.width - t;
                    e && i.drawImage(n, 0, 0, t, o, s, 0, t, o), i.drawImage(n, t, 0, s, o, 0, 0, s, o) } else { var s = this.width - t;
                    e && i.drawImage(n, s, 0, t, o, 0, 0, t, o), i.drawImage(n, 0, 0, s, o, t, 0, s, o) } return this.clear(), this.copy(this._swapCanvas) }, moveV: function(t, e) { void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height)); var i = this._swapCanvas.getContext("2d"),
                    o = this.width,
                    n = this.canvas; if (i.clearRect(0, 0, this.width, this.height), t < 0) { t = Math.abs(t);
                    s = this.height - t;
                    e && i.drawImage(n, 0, 0, o, t, 0, s, o, t), i.drawImage(n, 0, t, o, s, 0, 0, o, s) } else { var s = this.height - t;
                    e && i.drawImage(n, 0, s, o, t, 0, 0, o, t), i.drawImage(n, 0, 0, o, s, 0, t, o, s) } return this.clear(), this.copy(this._swapCanvas) }, add: function(t) { if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                else t.loadTexture(this); return this }, load: function(t) { if ("string" == typeof t && (t = this.game.cache.getImage(t)), t) return this.resize(t.width, t.height), this.cls(), this.draw(t), this.update(), this }, clear: function(t, e, i, o) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === o && (o = this.height), this.context.clearRect(t, e, i, o), this.dirty = !0, this }, fill: function(t, e, i, o) { return void 0 === o && (o = 1), this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + o + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this }, generateTexture: function(t) { var e = new Image;
                e.src = this.canvas.toDataURL("image/png"); var i = this.game.cache.addImage(t, "", e); return new PIXI.Texture(i.base) }, resize: function(t, e) { return t === this.width && e === this.height || (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, void 0 !== this._swapCanvas && (this._swapCanvas.width = t, this._swapCanvas.height = e), this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.update(), this.dirty = !0), this }, update: function(t, e, i, o) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = Math.max(1, this.width)), void 0 === o && (o = Math.max(1, this.height)), this.imageData = this.context.getImageData(t, e, i, o), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this }, processPixelRGB: function(t, e, o, n, s, r) { void 0 === o && (o = 0), void 0 === n && (n = 0), void 0 === s && (s = this.width), void 0 === r && (r = this.height); for (var a = o + s, h = n + r, l = i.Color.createColor(), c = { r: 0, g: 0, b: 0, a: 0 }, d = !1, u = n; u < h; u++)
                    for (var p = o; p < a; p++) i.Color.unpackPixel(this.getPixel32(p, u), l), !1 !== (c = t.call(e, l, p, u)) && null !== c && void 0 !== c && (this.setPixel32(p, u, c.r, c.g, c.b, c.a, !1), d = !0); return d && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this }, processPixel: function(t, e, i, o, n, s) { void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === n && (n = this.width), void 0 === s && (s = this.height); for (var r = i + n, a = o + s, h = 0, l = 0, c = !1, d = o; d < a; d++)
                    for (var u = i; u < r; u++) h = this.getPixel32(u, d), (l = t.call(e, h, u, d)) !== h && (this.pixels[d * this.width + u] = l, c = !0); return c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this }, replaceRGB: function(t, e, o, n, s, r, a, h, l) { var c = 0,
                    d = 0,
                    u = this.width,
                    p = this.height,
                    m = i.Color.packPixel(t, e, o, n);
                void 0 !== l && l instanceof i.Rectangle && (c = l.x, d = l.y, u = l.width, p = l.height); for (var f = 0; f < p; f++)
                    for (var y = 0; y < u; y++) this.getPixel32(c + y, d + f) === m && this.setPixel32(c + y, d + f, s, r, a, h, !1); return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this }, setHSL: function(t, e, o, n) { var s = t || 0 === t,
                    r = e || 0 === e,
                    a = o || 0 === o; if (s || r || a) { void 0 === n && (n = new i.Rectangle(0, 0, this.width, this.height)); for (var h = i.Color.createColor(), l = n.y; l < n.bottom; l++)
                        for (var c = n.x; c < n.right; c++) i.Color.unpackPixel(this.getPixel32(c, l), h, !0), s && (h.h = t), r && (h.s = e), a && (h.l = o), i.Color.HSLtoRGB(h.h, h.s, h.l, h), this.setPixel32(c, l, h.r, h.g, h.b, h.a, !1); return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this } }, shiftHSL: function(t, e, o, n) { if (void 0 !== t && null !== t || (t = !1), void 0 !== e && null !== e || (e = !1), void 0 !== o && null !== o || (o = !1), t || e || o) { void 0 === n && (n = new i.Rectangle(0, 0, this.width, this.height)); for (var s = i.Color.createColor(), r = n.y; r < n.bottom; r++)
                        for (var a = n.x; a < n.right; a++) i.Color.unpackPixel(this.getPixel32(a, r), s, !0), t && (s.h = this.game.math.wrap(s.h + t, 0, 1)), e && (s.s = this.game.math.clamp(s.s + e, 0, 1)), o && (s.l = this.game.math.clamp(s.l + o, 0, 1)), i.Color.HSLtoRGB(s.h, s.s, s.l, s), this.setPixel32(a, r, s.r, s.g, s.b, s.a, !1); return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this } }, setPixel32: function(t, e, o, n, s, r, a) { return void 0 === a && (a = !0), t >= 0 && t <= this.width && e >= 0 && e <= this.height && (i.Device.LITTLE_ENDIAN ? this.pixels[e * this.width + t] = r << 24 | s << 16 | n << 8 | o : this.pixels[e * this.width + t] = o << 24 | n << 16 | s << 8 | r, a && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this }, setPixel: function(t, e, i, o, n, s) { return this.setPixel32(t, e, i, o, n, 255, s) }, getPixel: function(t, e, o) { o || (o = i.Color.createColor()); var n = ~~(t + e * this.width); return n *= 4, o.r = this.data[n], o.g = this.data[++n], o.b = this.data[++n], o.a = this.data[++n], o }, getPixel32: function(t, e) { if (t >= 0 && t <= this.width && e >= 0 && e <= this.height) return this.pixels[e * this.width + t] }, getPixelRGB: function(t, e, o, n, s) { return i.Color.unpackPixel(this.getPixel32(t, e), o, n, s) }, getPixels: function(t) { return this.context.getImageData(t.x, t.y, t.width, t.height) }, getFirstPixel: function(t) { void 0 === t && (t = 0); var e = i.Color.createColor(),
                    o = 0,
                    n = 0,
                    s = 1,
                    r = !1;
                1 === t ? (s = -1, n = this.height) : 3 === t && (s = -1, o = this.width);
                do { i.Color.unpackPixel(this.getPixel32(o, n), e), 0 === t || 1 === t ? ++o === this.width && (o = 0, ((n += s) >= this.height || n <= 0) && (r = !0)) : 2 !== t && 3 !== t || ++n === this.height && (n = 0, ((o += s) >= this.width || o <= 0) && (r = !0)) } while (0 === e.a && !r); return e.x = o, e.y = n, e }, getBounds: function(t) { return void 0 === t && (t = new i.Rectangle), t.x = this.getFirstPixel(2).x, t.x === this.width ? t.setTo(0, 0, 0, 0) : (t.y = this.getFirstPixel(0).y, t.width = this.getFirstPixel(3).x - t.x + 1, t.height = this.getFirstPixel(1).y - t.y + 1, t) }, addToWorld: function(t, e, i, o, n, s) { n = n || 1, s = s || 1; var r = this.game.add.image(t, e, this); return r.anchor.set(i, o), r.scale.set(n, s), r }, copy: function(t, e, o, n, s, r, a, h, l, c, d, u, p, m, f, y, b) { if (void 0 !== t && null !== t || (t = this), (t instanceof i.RenderTexture || t instanceof PIXI.RenderTexture) && (t = t.getCanvas()), this._image = t, t instanceof i.Sprite || t instanceof i.Image || t instanceof i.Text || t instanceof PIXI.Sprite) this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), this._scale.set(t.scale.x, t.scale.y), this._anchor.set(t.anchor.x, t.anchor.y), this._rotate = t.rotation, this._alpha.current = t.alpha, t.texture instanceof i.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source, void 0 !== r && null !== r || (r = t.x), void 0 !== a && null !== a || (a = t.y), t.texture.trim && (r += t.texture.trim.x - t.anchor.x * t.texture.trim.width, a += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0));
                else { if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, t instanceof i.BitmapData) this._image = t.canvas;
                    else if ("string" == typeof t) { if (null === (t = this.game.cache.getImage(t))) return;
                        this._image = t } this._size.set(this._image.width, this._image.height) } if (void 0 !== e && null !== e || (e = 0), void 0 !== o && null !== o || (o = 0), n && (this._size.x = n), s && (this._size.y = s), void 0 !== r && null !== r || (r = e), void 0 !== a && null !== a || (a = o), void 0 !== h && null !== h || (h = this._size.x), void 0 !== l && null !== l || (l = this._size.y), "number" == typeof c && (this._rotate = c), "number" == typeof d && (this._anchor.x = d), "number" == typeof u && (this._anchor.y = u), "number" == typeof p && (this._scale.x = p), "number" == typeof m && (this._scale.y = m), "number" == typeof f && (this._alpha.current = f), void 0 === y && (y = null), void 0 === b && (b = !1), !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) { var g = this.context; return this._alpha.prev = g.globalAlpha, g.save(), g.globalAlpha = this._alpha.current, y && (this.op = y), b && (r |= 0, a |= 0), g.translate(r, a), g.scale(this._scale.x, this._scale.y), g.rotate(this._rotate), g.drawImage(this._image, this._pos.x + e, this._pos.y + o, this._size.x, this._size.y, -h * this._anchor.x, -l * this._anchor.y, h, l), g.restore(), g.globalAlpha = this._alpha.prev, this.dirty = !0, this } }, copyTransform: function(t, e, o) { if (void 0 === e && (e = null), void 0 === o && (o = !1), !t.hasOwnProperty("worldTransform") || !t.worldVisible || 0 === t.worldAlpha) return this; var n = t.worldTransform; if (this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), 0 === n.a || 0 === n.d || 0 === this._size.x || 0 === this._size.y) return this;
                t.texture instanceof i.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source; var s = n.tx,
                    r = n.ty;
                t.texture.trim && (s += t.texture.trim.x - t.anchor.x * t.texture.trim.width, r += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0)), o && (s |= 0, r |= 0); var a = this.context; return this._alpha.prev = a.globalAlpha, a.save(), a.globalAlpha = this._alpha.current, e && (this.op = e), a[this.smoothProperty] = t.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, a.setTransform(n.a, n.b, n.c, n.d, s, r), a.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * t.anchor.x, -this._size.y * t.anchor.y, this._size.x, this._size.y), a.restore(), a.globalAlpha = this._alpha.prev, this.dirty = !0, this }, copyRect: function(t, e, i, o, n, s, r) { return this.copy(t, e.x, e.y, e.width, e.height, i, o, e.width, e.height, 0, 0, 0, 1, 1, n, s, r) }, draw: function(t, e, i, o, n, s, r) { return this.copy(t, null, null, null, null, e, i, o, n, null, null, null, null, null, null, s, r) }, drawGroup: function(t, e, i) { return t.total > 0 && t.forEachExists(this.drawGroupProxy, this, e, i), this }, drawGroupProxy: function(t, e, o) { if (t.hasOwnProperty("texture") && this.copyTransform(t, e, o), t.type === i.GROUP && t.exists) this.drawGroup(t, e, o);
                else if (t.hasOwnProperty("children") && t.children.length > 0)
                    for (var n = 0; n < t.children.length; n++) t.children[n].exists && this.copyTransform(t.children[n], e, o) }, drawFull: function(t, e, o) { if (!1 === t.worldVisible || 0 === t.worldAlpha || t.hasOwnProperty("exists") && !1 === t.exists) return this; if (t.type !== i.GROUP && t.type !== i.EMITTER && t.type !== i.BITMAPTEXT)
                    if (t.type === i.GRAPHICS) { var n = t.getBounds();
                        this.ctx.save(), this.ctx.translate(n.x, n.y), PIXI.CanvasGraphics.renderGraphics(t, this.ctx), this.ctx.restore() } else this.copy(t, null, null, null, null, t.worldPosition.x, t.worldPosition.y, null, null, t.worldRotation, null, null, t.worldScale.x, t.worldScale.y, t.worldAlpha, e, o); if (t.children)
                    for (var s = 0; s < t.children.length; s++) this.drawFull(t.children[s], e, o); return this }, shadow: function(t, e, i, o) { var n = this.context; return void 0 === t || null === t ? n.shadowColor = "rgba(0,0,0,0)" : (n.shadowColor = t, n.shadowBlur = e || 5, n.shadowOffsetX = i || 10, n.shadowOffsetY = o || 10), this }, alphaMask: function(t, e, i, o) { return void 0 === o || null === o ? this.draw(e).blendSourceAtop() : this.draw(e, o.x, o.y, o.width, o.height).blendSourceAtop(), void 0 === i || null === i ? this.draw(t).blendReset() : this.draw(t, i.x, i.y, i.width, i.height).blendReset(), this }, extract: function(t, e, i, o, n, s, r, a, h) { return void 0 === n && (n = 255), void 0 === s && (s = !1), void 0 === r && (r = e), void 0 === a && (a = i), void 0 === h && (h = o), s && t.resize(this.width, this.height), this.processPixelRGB(function(s, l, c) { return s.r === e && s.g === i && s.b === o && t.setPixel32(l, c, r, a, h, n, !1), !1 }, this), t.context.putImageData(t.imageData, 0, 0), t.dirty = !0, t }, rect: function(t, e, i, o, n) { return void 0 !== n && (this.context.fillStyle = n), this.context.fillRect(t, e, i, o), this }, text: function(t, e, i, o, n, s) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = "14px Courier"), void 0 === n && (n = "rgb(255,255,255)"), void 0 === s && (s = !0); var r = this.context,
                    a = r.font; return r.font = o, s && (r.fillStyle = "rgb(0,0,0)", r.fillText(t, e + 1, i + 1)), r.fillStyle = n, r.fillText(t, e, i), r.font = a, this }, circle: function(t, e, i, o) { var n = this.context; return void 0 !== o && (n.fillStyle = o), n.beginPath(), n.arc(t, e, i, 0, 2 * Math.PI, !1), n.closePath(), n.fill(), this }, line: function(t, e, i, o, n, s) { void 0 === n && (n = "#fff"), void 0 === s && (s = 1); var r = this.context; return r.beginPath(), r.moveTo(t, e), r.lineTo(i, o), r.lineWidth = s, r.strokeStyle = n, r.stroke(), r.closePath(), this }, textureLine: function(t, e, o) { if (void 0 === o && (o = "repeat-x"), "string" != typeof e || (e = this.game.cache.getImage(e))) { var n = t.length; "no-repeat" === o && n > e.width && (n = e.width); var s = this.context; return s.fillStyle = s.createPattern(e, o), this._circle = new i.Circle(t.start.x, t.start.y, e.height), this._circle.circumferencePoint(t.angle - 1.5707963267948966, !1, this._pos), s.save(), s.translate(this._pos.x, this._pos.y), s.rotate(t.angle), s.fillRect(0, 0, n, e.height), s.restore(), this.dirty = !0, this } }, render: function() { return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this }, destroy: function() { this.frameData.destroy(), this.texture.destroy(!0), PIXI.CanvasPool.remove(this) }, blendReset: function() { return this.op = "source-over", this }, blendSourceOver: function() { return this.op = "source-over", this }, blendSourceIn: function() { return this.op = "source-in", this }, blendSourceOut: function() { return this.op = "source-out", this }, blendSourceAtop: function() { return this.op = "source-atop", this }, blendDestinationOver: function() { return this.op = "destination-over", this }, blendDestinationIn: function() { return this.op = "destination-in", this }, blendDestinationOut: function() { return this.op = "destination-out", this }, blendDestinationAtop: function() { return this.op = "destination-atop", this }, blendXor: function() { return this.op = "xor", this }, blendAdd: function() { return this.op = "lighter", this }, blendMultiply: function() { return this.op = "multiply", this }, blendScreen: function() { return this.op = "screen", this }, blendOverlay: function() { return this.op = "overlay", this }, blendDarken: function() { return this.op = "darken", this }, blendLighten: function() { return this.op = "lighten", this }, blendColorDodge: function() { return this.op = "color-dodge", this }, blendColorBurn: function() { return this.op = "color-burn", this }, blendHardLight: function() { return this.op = "hard-light", this }, blendSoftLight: function() { return this.op = "soft-light", this }, blendDifference: function() { return this.op = "difference", this }, blendExclusion: function() { return this.op = "exclusion", this }, blendHue: function() { return this.op = "hue", this }, blendSaturation: function() { return this.op = "saturation", this }, blendColor: function() { return this.op = "color", this }, blendLuminosity: function() { return this.op = "luminosity", this } }, Object.defineProperty(i.BitmapData.prototype, "smoothed", { get: function() { i.Canvas.getSmoothingEnabled(this.context) }, set: function(t) { i.Canvas.setSmoothingEnabled(this.context, t) } }), Object.defineProperty(i.BitmapData.prototype, "op", { get: function() { return this.context.globalCompositeOperation }, set: function(t) { this.context.globalCompositeOperation = t } }), i.BitmapData.getTransform = function(t, e, i, o, n, s) { return "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), "number" != typeof i && (i = 1), "number" != typeof o && (o = 1), "number" != typeof n && (n = 0), "number" != typeof s && (s = 0), { sx: i, sy: o, scaleX: i, scaleY: o, skewX: n, skewY: s, translateX: t, translateY: e, tx: t, ty: e } }, i.BitmapData.prototype.constructor = i.BitmapData, PIXI.Graphics = function() { PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new PIXI.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1 }, PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), PIXI.Graphics.prototype.constructor = PIXI.Graphics, PIXI.Graphics.prototype.lineStyle = function(t, e, i) { return this.lineWidth = t || 0, this.lineColor = e || 0, this.lineAlpha = void 0 === i ? 1 : i, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this }, PIXI.Graphics.prototype.moveTo = function(t, e) { return this.drawShape(new PIXI.Polygon([t, e])), this }, PIXI.Graphics.prototype.lineTo = function(t, e) { return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(t, e), this.dirty = !0, this._boundsDirty = !0, this }, PIXI.Graphics.prototype.quadraticCurveTo = function(t, e, i, o) { this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0); var n, s, r = this.currentPath.shape.points;
            0 === r.length && this.moveTo(0, 0); for (var a = r[r.length - 2], h = r[r.length - 1], l = 0, c = 1; c <= 20; ++c) n = a + (t - a) * (l = c / 20), s = h + (e - h) * l, r.push(n + (t + (i - t) * l - n) * l, s + (e + (o - e) * l - s) * l); return this.dirty = !0, this._boundsDirty = !0, this }, PIXI.Graphics.prototype.bezierCurveTo = function(t, e, i, o, n, s) { this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0); for (var r, a, h, l, c, d = this.currentPath.shape.points, u = d[d.length - 2], p = d[d.length - 1], m = 0, f = 1; f <= 20; ++f) h = (a = (r = 1 - (m = f / 20)) * r) * r, c = (l = m * m) * m, d.push(h * u + 3 * a * m * t + 3 * r * l * i + c * n, h * p + 3 * a * m * e + 3 * r * l * o + c * s); return this.dirty = !0, this._boundsDirty = !0, this }, PIXI.Graphics.prototype.arcTo = function(t, e, i, o, n) { this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e); var s = this.currentPath.shape.points,
                r = s[s.length - 2],
                a = s[s.length - 1] - e,
                h = r - t,
                l = o - e,
                c = i - t,
                d = Math.abs(a * c - h * l); if (d < 1e-8 || 0 === n) s[s.length - 2] === t && s[s.length - 1] === e || s.push(t, e);
            else { var u = a * a + h * h,
                    p = l * l + c * c,
                    m = a * l + h * c,
                    f = n * Math.sqrt(u) / d,
                    y = n * Math.sqrt(p) / d,
                    b = f * m / u,
                    g = y * m / p,
                    _ = f * c + y * h,
                    v = f * l + y * a,
                    x = h * (y + b),
                    S = a * (y + b),
                    C = c * (f + g),
                    w = l * (f + g),
                    A = Math.atan2(S - v, x - _),
                    T = Math.atan2(w - v, C - _);
                this.arc(_ + t, v + e, n, A, T, h * l > c * a) } return this.dirty = !0, this._boundsDirty = !0, this }, PIXI.Graphics.prototype.arc = function(t, e, i, o, n, s, r) { if (o === n) return this;
            void 0 === s && (s = !1), void 0 === r && (r = 40), !s && n <= o ? n += 2 * Math.PI : s && o <= n && (o += 2 * Math.PI); var a = s ? -1 * (o - n) : n - o,
                h = Math.ceil(Math.abs(a) / (2 * Math.PI)) * r; if (0 === a) return this; var l = t + Math.cos(o) * i,
                c = e + Math.sin(o) * i;
            s && this.filling ? this.moveTo(t, e) : this.moveTo(l, c); for (var d = this.currentPath.shape.points, u = a / (2 * h), p = 2 * u, m = Math.cos(u), f = Math.sin(u), y = h - 1, b = y % 1 / y, g = 0; g <= y; g++) { var _ = u + o + p * (g + b * g),
                    v = Math.cos(_),
                    x = -Math.sin(_);
                d.push((m * v + f * x) * i + t, (m * -x + f * v) * i + e) } return this.dirty = !0, this._boundsDirty = !0, this }, PIXI.Graphics.prototype.beginFill = function(t, e) { return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this }, PIXI.Graphics.prototype.endFill = function() { return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this }, PIXI.Graphics.prototype.drawRect = function(t, e, i, o) { return this.drawShape(new PIXI.Rectangle(t, e, i, o)), this }, PIXI.Graphics.prototype.drawRoundedRect = function(t, e, i, o, n) { return this.drawShape(new PIXI.RoundedRectangle(t, e, i, o, n)), this }, PIXI.Graphics.prototype.drawCircle = function(t, e, i) { return this.drawShape(new PIXI.Circle(t, e, i)), this }, PIXI.Graphics.prototype.drawEllipse = function(t, e, i, o) { return this.drawShape(new PIXI.Ellipse(t, e, i, o)), this }, PIXI.Graphics.prototype.drawPolygon = function(t) {
            (t instanceof i.Polygon || t instanceof PIXI.Polygon) && (t = t.points); var e = t; if (!Array.isArray(e)) { e = new Array(arguments.length); for (var o = 0; o < e.length; ++o) e[o] = arguments[o] } return this.drawShape(new i.Polygon(e)), this }, PIXI.Graphics.prototype.clear = function() { return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this }, PIXI.Graphics.prototype.generateTexture = function(t, e, i) { void 0 === t && (t = 1), void 0 === e && (e = PIXI.scaleModes.DEFAULT), void 0 === i && (i = 0); var o = this.getBounds();
            o.width += i, o.height += i; var n = new PIXI.CanvasBuffer(o.width * t, o.height * t),
                s = PIXI.Texture.fromCanvas(n.canvas, e); return s.baseTexture.resolution = t, n.context.scale(t, t), n.context.translate(-o.x, -o.y), PIXI.CanvasGraphics.renderGraphics(this, n.context), s }, PIXI.Graphics.prototype._renderWebGL = function(t) { if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) { if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t); if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode) { t.spriteBatch.currentBlendMode = this.blendMode; var e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode];
                    t.spriteBatch.gl.blendFunc(e[0], e[1]) } if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, t), this.children.length) { t.spriteBatch.start(); for (var i = 0; i < this.children.length; i++) this.children[i]._renderWebGL(t);
                    t.spriteBatch.stop() } this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this.mask, t), t.drawCount++, t.spriteBatch.start() } }, PIXI.Graphics.prototype._renderCanvas = function(t) { if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) { if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t); var e = t.context,
                    i = this.worldTransform;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t); var o = t.resolution,
                    n = i.tx * t.resolution + t.shakeX,
                    s = i.ty * t.resolution + t.shakeY;
                e.setTransform(i.a * o, i.b * o, i.c * o, i.d * o, n, s), PIXI.CanvasGraphics.renderGraphics(this, e); for (var r = 0; r < this.children.length; r++) this.children[r]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t) } }, PIXI.Graphics.prototype.getBounds = function(t) { if (!this._currentBounds) { if (!this.renderable) return PIXI.EmptyRectangle;
                this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1); var e = this._localBounds,
                    i = e.x,
                    o = e.width + e.x,
                    n = e.y,
                    s = e.height + e.y,
                    r = t || this.worldTransform,
                    a = r.a,
                    h = r.b,
                    l = r.c,
                    c = r.d,
                    d = r.tx,
                    u = r.ty,
                    p = a * o + l * s + d,
                    m = c * s + h * o + u,
                    f = a * i + l * s + d,
                    y = c * s + h * i + u,
                    b = a * i + l * n + d,
                    g = c * n + h * i + u,
                    _ = a * o + l * n + d,
                    v = c * n + h * o + u,
                    x = p,
                    S = m,
                    C = p,
                    w = m;
                C = _ < (C = b < (C = f < C ? f : C) ? b : C) ? _ : C, w = v < (w = g < (w = y < w ? y : w) ? g : w) ? v : w, x = _ > (x = b > (x = f > x ? f : x) ? b : x) ? _ : x, S = v > (S = g > (S = y > S ? y : S) ? g : S) ? v : S, this._bounds.x = C, this._bounds.width = x - C, this._bounds.y = w, this._bounds.height = S - w, this._currentBounds = this._bounds } return this._currentBounds }, PIXI.Graphics.prototype.getLocalBounds = function() { var t = this.worldTransform;
            this.worldTransform = PIXI.identityMatrix; for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform(); var i = this.getBounds(); for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform(); return i }, PIXI.Graphics.prototype.containsPoint = function(t) { this.worldTransform.applyInverse(t, tempPoint); for (var e = this.graphicsData, i = 0; i < e.length; i++) { var o = e[i]; if (o.fill && (o.shape && o.shape.contains(tempPoint.x, tempPoint.y))) return !0 } return !1 }, PIXI.Graphics.prototype.updateLocalBounds = function() { var t = 1 / 0,
                e = -1 / 0,
                o = 1 / 0,
                n = -1 / 0; if (this.graphicsData.length)
                for (var s, r, a, h, l, c, d = 0; d < this.graphicsData.length; d++) { var u = this.graphicsData[d],
                        p = u.type,
                        m = u.lineWidth; if (s = u.shape, p === PIXI.Graphics.RECT || p === PIXI.Graphics.RREC) a = s.x - m / 2, h = s.y - m / 2, l = s.width + m, c = s.height + m, t = a < t ? a : t, e = a + l > e ? a + l : e, o = h < o ? h : o, n = h + c > n ? h + c : n;
                    else if (p === PIXI.Graphics.CIRC) a = s.x, h = s.y, l = s.radius + m / 2, c = s.radius + m / 2, t = a - l < t ? a - l : t, e = a + l > e ? a + l : e, o = h - c < o ? h - c : o, n = h + c > n ? h + c : n;
                    else if (p === PIXI.Graphics.ELIP) a = s.x, h = s.y, l = s.width + m / 2, c = s.height + m / 2, t = a - l < t ? a - l : t, e = a + l > e ? a + l : e, o = h - c < o ? h - c : o, n = h + c > n ? h + c : n;
                    else { r = s.points; for (var f = 0; f < r.length; f++) r[f] instanceof i.Point ? (a = r[f].x, h = r[f].y) : (a = r[f], h = r[f + 1], f < r.length - 1 && f++), t = a - m < t ? a - m : t, e = a + m > e ? a + m : e, o = h - m < o ? h - m : o, n = h + m > n ? h + m : n } } else t = 0, e = 0, o = 0, n = 0; var y = this.boundsPadding;
            this._localBounds.x = t - y, this._localBounds.width = e - t + 2 * y, this._localBounds.y = o - y, this._localBounds.height = n - o + 2 * y }, PIXI.Graphics.prototype._generateCachedSprite = function() { var t = this.getLocalBounds(); if (this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height);
            else { var e = new PIXI.CanvasBuffer(t.width, t.height),
                    i = PIXI.Texture.fromCanvas(e.canvas);
                this._cachedSprite = new PIXI.Sprite(i), this._cachedSprite.buffer = e, this._cachedSprite.worldTransform = this.worldTransform } this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._cachedSprite.buffer.context.translate(-t.x, -t.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha }, PIXI.Graphics.prototype.updateCachedSpriteTexture = function() { var t = this._cachedSprite,
                e = t.texture,
                i = t.buffer.canvas;
            e.baseTexture.width = i.width, e.baseTexture.height = i.height, e.crop.width = e.frame.width = i.width, e.crop.height = e.frame.height = i.height, t._width = i.width, t._height = i.height, e.baseTexture.dirty() }, PIXI.Graphics.prototype.destroyCachedSprite = function() { this._cachedSprite.texture.destroy(!0), this._cachedSprite = null }, PIXI.Graphics.prototype.drawShape = function(t) { this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, t instanceof i.Polygon && (t = t.clone()).flatten(); var e = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, t); return this.graphicsData.push(e), e.type === PIXI.Graphics.POLY && (e.shape.closed = this.filling, this.currentPath = e), this.dirty = !0, this._boundsDirty = !0, e }, Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", { get: function() { return this._cacheAsBitmap }, set: function(t) { this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0 } }), PIXI.GraphicsData = function(t, e, i, o, n, s, r) { this.lineWidth = t, this.lineColor = e, this.lineAlpha = i, this._lineTint = e, this.fillColor = o, this.fillAlpha = n, this._fillTint = o, this.fill = s, this.shape = r, this.type = r.type }, PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData, PIXI.GraphicsData.prototype.clone = function() { return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape) }, PIXI.EarCut = {}, PIXI.EarCut.Triangulate = function(t, e, i) { i = i || 2; var o = e && e.length,
                n = o ? e[0] * i : t.length,
                s = PIXI.EarCut.linkedList(t, 0, n, i, !0),
                r = []; if (!s) return r; var a, h, l, c, d, u, p; if (o && (s = PIXI.EarCut.eliminateHoles(t, e, s, i)), t.length > 80 * i) { a = l = t[0], h = c = t[1]; for (var m = i; m < n; m += i) d = t[m], u = t[m + 1], d < a && (a = d), u < h && (h = u), d > l && (l = d), u > c && (c = u);
                p = Math.max(l - a, c - h) } return PIXI.EarCut.earcutLinked(s, r, i, a, h, p), r }, PIXI.EarCut.linkedList = function(t, e, i, o, n) { var s, r, a, h = 0; for (s = e, r = i - o; s < i; s += o) h += (t[r] - t[s]) * (t[s + 1] + t[r + 1]), r = s; if (n === h > 0)
                for (s = e; s < i; s += o) a = PIXI.EarCut.insertNode(s, t[s], t[s + 1], a);
            else
                for (s = i - o; s >= e; s -= o) a = PIXI.EarCut.insertNode(s, t[s], t[s + 1], a); return a }, PIXI.EarCut.filterPoints = function(t, e) { if (!t) return t;
            e || (e = t); var i, o = t;
            do { if (i = !1, o.steiner || !PIXI.EarCut.equals(o, o.next) && 0 !== PIXI.EarCut.area(o.prev, o, o.next)) o = o.next;
                else { if (PIXI.EarCut.removeNode(o), (o = e = o.prev) === o.next) return null;
                    i = !0 } } while (i || o !== e); return e }, PIXI.EarCut.earcutLinked = function(t, e, i, o, n, s, r) { if (t) {!r && s && PIXI.EarCut.indexCurve(t, o, n, s); for (var a, h, l = t; t.prev !== t.next;)
                    if (a = t.prev, h = t.next, s ? PIXI.EarCut.isEarHashed(t, o, n, s) : PIXI.EarCut.isEar(t)) e.push(a.i / i), e.push(t.i / i), e.push(h.i / i), PIXI.EarCut.removeNode(t), t = h.next, l = h.next;
                    else if ((t = h) === l) { r ? 1 === r ? (t = PIXI.EarCut.cureLocalIntersections(t, e, i), PIXI.EarCut.earcutLinked(t, e, i, o, n, s, 2)) : 2 === r && PIXI.EarCut.splitEarcut(t, e, i, o, n, s) : PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(t), e, i, o, n, s, 1); break } } }, PIXI.EarCut.isEar = function(t) { var e = t.prev,
                i = t,
                o = t.next; if (PIXI.EarCut.area(e, i, o) >= 0) return !1; for (var n = t.next.next; n !== t.prev;) { if (PIXI.EarCut.pointInTriangle(e.x, e.y, i.x, i.y, o.x, o.y, n.x, n.y) && PIXI.EarCut.area(n.prev, n, n.next) >= 0) return !1;
                n = n.next } return !0 }, PIXI.EarCut.isEarHashed = function(t, e, i, o) { var n = t.prev,
                s = t,
                r = t.next; if (PIXI.EarCut.area(n, s, r) >= 0) return !1; for (var a = n.x < s.x ? n.x < r.x ? n.x : r.x : s.x < r.x ? s.x : r.x, h = n.y < s.y ? n.y < r.y ? n.y : r.y : s.y < r.y ? s.y : r.y, l = n.x > s.x ? n.x > r.x ? n.x : r.x : s.x > r.x ? s.x : r.x, c = n.y > s.y ? n.y > r.y ? n.y : r.y : s.y > r.y ? s.y : r.y, d = PIXI.EarCut.zOrder(a, h, e, i, o), u = PIXI.EarCut.zOrder(l, c, e, i, o), p = t.nextZ; p && p.z <= u;) { if (p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(n.x, n.y, s.x, s.y, r.x, r.y, p.x, p.y) && PIXI.EarCut.area(p.prev, p, p.next) >= 0) return !1;
                p = p.nextZ } for (p = t.prevZ; p && p.z >= d;) { if (p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(n.x, n.y, s.x, s.y, r.x, r.y, p.x, p.y) && PIXI.EarCut.area(p.prev, p, p.next) >= 0) return !1;
                p = p.prevZ } return !0 }, PIXI.EarCut.cureLocalIntersections = function(t, e, i) { var o = t;
            do { var n = o.prev,
                    s = o.next.next;
                PIXI.EarCut.intersects(n, o, o.next, s) && PIXI.EarCut.locallyInside(n, s) && PIXI.EarCut.locallyInside(s, n) && (e.push(n.i / i), e.push(o.i / i), e.push(s.i / i), PIXI.EarCut.removeNode(o), PIXI.EarCut.removeNode(o.next), o = t = s), o = o.next } while (o !== t); return o }, PIXI.EarCut.splitEarcut = function(t, e, i, o, n, s) { var r = t;
            do { for (var a = r.next.next; a !== r.prev;) { if (r.i !== a.i && PIXI.EarCut.isValidDiagonal(r, a)) { var h = PIXI.EarCut.splitPolygon(r, a); return r = PIXI.EarCut.filterPoints(r, r.next), h = PIXI.EarCut.filterPoints(h, h.next), PIXI.EarCut.earcutLinked(r, e, i, o, n, s), void PIXI.EarCut.earcutLinked(h, e, i, o, n, s) } a = a.next } r = r.next } while (r !== t) }, PIXI.EarCut.eliminateHoles = function(t, e, i, o) { var n, s, r, a, h, l = []; for (n = 0, s = e.length; n < s; n++) r = e[n] * o, a = n < s - 1 ? e[n + 1] * o : t.length, (h = PIXI.EarCut.linkedList(t, r, a, o, !1)) === h.next && (h.steiner = !0), l.push(PIXI.EarCut.getLeftmost(h)); for (l.sort(compareX), n = 0; n < l.length; n++) PIXI.EarCut.eliminateHole(l[n], i), i = PIXI.EarCut.filterPoints(i, i.next); return i }, PIXI.EarCut.compareX = function(t, e) { return t.x - e.x }, PIXI.EarCut.eliminateHole = function(t, e) { if (e = PIXI.EarCut.findHoleBridge(t, e)) { var i = PIXI.EarCut.splitPolygon(e, t);
                PIXI.EarCut.filterPoints(i, i.next) } }, PIXI.EarCut.findHoleBridge = function(t, e) { var i, o = e,
                n = t.x,
                s = t.y,
                r = -1 / 0;
            do { if (s <= o.y && s >= o.next.y) { var a = o.x + (s - o.y) * (o.next.x - o.x) / (o.next.y - o.y);
                    a <= n && a > r && (r = a, i = o.x < o.next.x ? o : o.next) } o = o.next } while (o !== e); if (!i) return null; if (t.x === i.x) return i.prev; var h, l = i,
                c = 1 / 0; for (o = i.next; o !== l;) n >= o.x && o.x >= i.x && PIXI.EarCut.pointInTriangle(s < i.y ? n : r, s, i.x, i.y, s < i.y ? r : n, s, o.x, o.y) && ((h = Math.abs(s - o.y) / (n - o.x)) < c || h === c && o.x > i.x) && PIXI.EarCut.locallyInside(o, t) && (i = o, c = h), o = o.next; return i }, PIXI.EarCut.indexCurve = function(t, e, i, o) { var n = t;
            do { null === n.z && (n.z = PIXI.EarCut.zOrder(n.x, n.y, e, i, o)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next } while (n !== t);
            n.prevZ.nextZ = null, n.prevZ = null, PIXI.EarCut.sortLinked(n) }, PIXI.EarCut.sortLinked = function(t) { var e, i, o, n, s, r, a, h, l = 1;
            do { for (i = t, t = null, s = null, r = 0; i;) { for (r++, o = i, a = 0, e = 0; e < l && (a++, o = o.nextZ); e++); for (h = l; a > 0 || h > 0 && o;) 0 === a ? (n = o, o = o.nextZ, h--) : 0 !== h && o ? i.z <= o.z ? (n = i, i = i.nextZ, a--) : (n = o, o = o.nextZ, h--) : (n = i, i = i.nextZ, a--), s ? s.nextZ = n : t = n, n.prevZ = s, s = n;
                    i = o } s.nextZ = null, l *= 2 } while (r > 1); return t }, PIXI.EarCut.zOrder = function(t, e, i, o, n) { return t = 32767 * (t - i) / n, e = 32767 * (e - o) / n, t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t | e << 1 }, PIXI.EarCut.getLeftmost = function(t) { var e = t,
                i = t;
            do { e.x < i.x && (i = e), e = e.next } while (e !== t); return i }, PIXI.EarCut.pointInTriangle = function(t, e, i, o, n, s, r, a) { return (n - r) * (e - a) - (t - r) * (s - a) >= 0 && (t - r) * (o - a) - (i - r) * (e - a) >= 0 && (i - r) * (s - a) - (n - r) * (o - a) >= 0 }, PIXI.EarCut.isValidDiagonal = function(t, e) { return PIXI.EarCut.equals(t, e) || t.next.i !== e.i && t.prev.i !== e.i && !PIXI.EarCut.intersectsPolygon(t, e) && PIXI.EarCut.locallyInside(t, e) && PIXI.EarCut.locallyInside(e, t) && PIXI.EarCut.middleInside(t, e) }, PIXI.EarCut.area = function(t, e, i) { return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y) }, PIXI.EarCut.equals = function(t, e) { return t.x === e.x && t.y === e.y }, PIXI.EarCut.intersects = function(t, e, i, o) { return PIXI.EarCut.area(t, e, i) > 0 != PIXI.EarCut.area(t, e, o) > 0 && PIXI.EarCut.area(i, o, t) > 0 != PIXI.EarCut.area(i, o, e) > 0 }, PIXI.EarCut.intersectsPolygon = function(t, e) { var i = t;
            do { if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && PIXI.EarCut.intersects(i, i.next, t, e)) return !0;
                i = i.next } while (i !== t); return !1 }, PIXI.EarCut.locallyInside = function(t, e) { return PIXI.EarCut.area(t.prev, t, t.next) < 0 ? PIXI.EarCut.area(t, e, t.next) >= 0 && PIXI.EarCut.area(t, t.prev, e) >= 0 : PIXI.EarCut.area(t, e, t.prev) < 0 || PIXI.EarCut.area(t, t.next, e) < 0 }, PIXI.EarCut.middleInside = function(t, e) { var i = t,
                o = !1,
                n = (t.x + e.x) / 2,
                s = (t.y + e.y) / 2;
            do { i.y > s != i.next.y > s && n < (i.next.x - i.x) * (s - i.y) / (i.next.y - i.y) + i.x && (o = !o), i = i.next } while (i !== t); return o }, PIXI.EarCut.splitPolygon = function(t, e) { var i = new PIXI.EarCut.Node(t.i, t.x, t.y),
                o = new PIXI.EarCut.Node(e.i, e.x, e.y),
                n = t.next,
                s = e.prev; return t.next = e, e.prev = t, i.next = n, n.prev = i, o.next = i, i.prev = o, s.next = o, o.prev = s, o }, PIXI.EarCut.insertNode = function(t, e, i, o) { var n = new PIXI.EarCut.Node(t, e, i); return o ? (n.next = o.next, n.prev = o, o.next.prev = n, o.next = n) : (n.prev = n, n.next = n), n }, PIXI.EarCut.removeNode = function(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) }, PIXI.EarCut.Node = function(t, e, i) { this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1 }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(t, e) { var i, o = e.gl,
                n = e.projection,
                s = e.offset,
                r = e.shaderManager.primitiveShader;
            t.dirty && PIXI.WebGLGraphics.updateGraphics(t, o); for (var a = t._webGL[o.id], h = 0; h < a.data.length; h++) 1 === a.data[h].mode ? (i = a.data[h], e.stencilManager.pushStencil(t, i, e), o.drawElements(o.TRIANGLE_FAN, 4, o.UNSIGNED_SHORT, 2 * (i.indices.length - 4)), e.stencilManager.popStencil(t, i, e)) : (i = a.data[h], e.shaderManager.setShader(r), r = e.shaderManager.primitiveShader, o.uniformMatrix3fv(r.translationMatrix, !1, t.worldTransform.toArray(!0)), o.uniform1f(r.flipY, 1), o.uniform2f(r.projectionVector, n.x, -n.y), o.uniform2f(r.offsetVector, -s.x, -s.y), o.uniform3fv(r.tintColor, PIXI.hex2rgb(t.tint)), o.uniform1f(r.alpha, t.worldAlpha), o.bindBuffer(o.ARRAY_BUFFER, i.buffer), o.vertexAttribPointer(r.aVertexPosition, 2, o.FLOAT, !1, 24, 0), o.vertexAttribPointer(r.colorAttribute, 4, o.FLOAT, !1, 24, 8), o.bindBuffer(o.ELEMENT_ARRAY_BUFFER, i.indexBuffer), o.drawElements(o.TRIANGLE_STRIP, i.indices.length, o.UNSIGNED_SHORT, 0)) }, PIXI.WebGLGraphics.updateGraphics = function(t, e) { var i = t._webGL[e.id];
            i || (i = t._webGL[e.id] = { lastIndex: 0, data: [], gl: e }), t.dirty = !1; var o; if (t.clearDirty) { for (t.clearDirty = !1, o = 0; o < i.data.length; o++) { var n = i.data[o];
                    n.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(n) } i.data = [], i.lastIndex = 0 } var s; for (o = i.lastIndex; o < t.graphicsData.length; o++) { var r = t.graphicsData[o];
                r.type === PIXI.Graphics.POLY ? (r.points = r.shape.points.slice(), r.shape.closed && (r.points[0] === r.points[r.points.length - 2] && r.points[1] === r.points[r.points.length - 1] || r.points.push(r.points[0], r.points[1])), r.fill && r.points.length >= PIXI.WebGLGraphics.stencilBufferLimit && (r.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit ? (s = PIXI.WebGLGraphics.switchMode(i, 0), PIXI.WebGLGraphics.buildPoly(r, s) || (s = PIXI.WebGLGraphics.switchMode(i, 1), PIXI.WebGLGraphics.buildComplexPoly(r, s))) : (s = PIXI.WebGLGraphics.switchMode(i, 1), PIXI.WebGLGraphics.buildComplexPoly(r, s))), r.lineWidth > 0 && (s = PIXI.WebGLGraphics.switchMode(i, 0), PIXI.WebGLGraphics.buildLine(r, s))) : (s = PIXI.WebGLGraphics.switchMode(i, 0), r.type === PIXI.Graphics.RECT ? PIXI.WebGLGraphics.buildRectangle(r, s) : r.type === PIXI.Graphics.CIRC || r.type === PIXI.Graphics.ELIP ? PIXI.WebGLGraphics.buildCircle(r, s) : r.type === PIXI.Graphics.RREC && PIXI.WebGLGraphics.buildRoundedRectangle(r, s)), i.lastIndex++ } for (o = 0; o < i.data.length; o++)(s = i.data[o]).dirty && s.upload() }, PIXI.WebGLGraphics.switchMode = function(t, e) { var i; return t.data.length ? (i = t.data[t.data.length - 1]).mode === e && 1 !== e || ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)) : ((i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl)).mode = e, t.data.push(i)), i.dirty = !0, i }, PIXI.WebGLGraphics.buildRectangle = function(t, e) { var i = t.shape,
                o = i.x,
                n = i.y,
                s = i.width,
                r = i.height; if (t.fill) { var a = PIXI.hex2rgb(t.fillColor),
                    h = t.fillAlpha,
                    l = a[0] * h,
                    c = a[1] * h,
                    d = a[2] * h,
                    u = e.points,
                    p = e.indices,
                    m = u.length / 6;
                u.push(o, n), u.push(l, c, d, h), u.push(o + s, n), u.push(l, c, d, h), u.push(o, n + r), u.push(l, c, d, h), u.push(o + s, n + r), u.push(l, c, d, h), p.push(m, m, m + 1, m + 2, m + 3, m + 3) } if (t.lineWidth) { var f = t.points;
                t.points = [o, n, o + s, n, o + s, n + r, o, n + r, o, n], PIXI.WebGLGraphics.buildLine(t, e), t.points = f } }, PIXI.WebGLGraphics.buildRoundedRectangle = function(t, e) { var i = t.shape,
                o = i.x,
                n = i.y,
                s = i.width,
                r = i.height,
                a = i.radius,
                h = []; if (h.push(o, n + a), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(o, n + r - a, o, n + r, o + a, n + r)), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(o + s - a, n + r, o + s, n + r, o + s, n + r - a)), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(o + s, n + a, o + s, n, o + s - a, n)), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(o + a, n, o, n, o, n + a)), t.fill) { var l = PIXI.hex2rgb(t.fillColor),
                    c = t.fillAlpha,
                    d = l[0] * c,
                    u = l[1] * c,
                    p = l[2] * c,
                    m = e.points,
                    f = e.indices,
                    y = m.length / 6,
                    b = PIXI.EarCut.Triangulate(h, null, 2),
                    g = 0; for (g = 0; g < b.length; g += 3) f.push(b[g] + y), f.push(b[g] + y), f.push(b[g + 1] + y), f.push(b[g + 2] + y), f.push(b[g + 2] + y); for (g = 0; g < h.length; g++) m.push(h[g], h[++g], d, u, p, c) } if (t.lineWidth) { var _ = t.points;
                t.points = h, PIXI.WebGLGraphics.buildLine(t, e), t.points = _ } }, PIXI.WebGLGraphics.quadraticBezierCurve = function(t, e, i, o, n, s) {
            function r(t, e, i) { return t + (e - t) * i } for (var a, h, l, c, d, u, p = [], m = 0, f = 0; f <= 20; f++) a = r(t, i, m = f / 20), h = r(e, o, m), l = r(i, n, m), c = r(o, s, m), d = r(a, l, m), u = r(h, c, m), p.push(d, u); return p }, PIXI.WebGLGraphics.buildCircle = function(t, e) { var i, o, n = t.shape,
                s = n.x,
                r = n.y;
            t.type === PIXI.Graphics.CIRC ? (i = n.radius, o = n.radius) : (i = n.width, o = n.height); var a = 2 * Math.PI / 40,
                h = 0; if (t.fill) { var l = PIXI.hex2rgb(t.fillColor),
                    c = t.fillAlpha,
                    d = l[0] * c,
                    u = l[1] * c,
                    p = l[2] * c,
                    m = e.points,
                    f = e.indices,
                    y = m.length / 6; for (f.push(y), h = 0; h < 41; h++) m.push(s, r, d, u, p, c), m.push(s + Math.sin(a * h) * i, r + Math.cos(a * h) * o, d, u, p, c), f.push(y++, y++);
                f.push(y - 1) } if (t.lineWidth) { var b = t.points; for (t.points = [], h = 0; h < 41; h++) t.points.push(s + Math.sin(a * h) * i, r + Math.cos(a * h) * o);
                PIXI.WebGLGraphics.buildLine(t, e), t.points = b } }, PIXI.WebGLGraphics.buildLine = function(t, e) { var i = 0,
                o = t.points; if (0 !== o.length) { if (t.lineWidth % 2)
                    for (i = 0; i < o.length; i++) o[i] += .5; var n = new PIXI.Point(o[0], o[1]),
                    s = new PIXI.Point(o[o.length - 2], o[o.length - 1]); if (n.x === s.x && n.y === s.y) {
                    (o = o.slice()).pop(), o.pop(); var r = (s = new PIXI.Point(o[o.length - 2], o[o.length - 1])).x + .5 * (n.x - s.x),
                        a = s.y + .5 * (n.y - s.y);
                    o.unshift(r, a), o.push(r, a) } var h, l, c, d, u, p, m, f, y, b, g, _, v, x, S, C, w, A, T, P, k, M, E = e.points,
                    B = e.indices,
                    I = o.length / 2,
                    D = o.length,
                    L = E.length / 6,
                    O = t.lineWidth / 2,
                    R = PIXI.hex2rgb(t.lineColor),
                    F = t.lineAlpha,
                    V = R[0] * F,
                    G = R[1] * F,
                    U = R[2] * F; for (c = o[0], d = o[1], u = o[2], y = -(d - (p = o[3])), b = c - u, y /= M = Math.sqrt(y * y + b * b), b /= M, y *= O, b *= O, E.push(c - y, d - b, V, G, U, F), E.push(c + y, d + b, V, G, U, F), i = 1; i < I - 1; i++) c = o[2 * (i - 1)], d = o[2 * (i - 1) + 1], u = o[2 * i], p = o[2 * i + 1], m = o[2 * (i + 1)], f = o[2 * (i + 1) + 1], y = -(d - p), b = c - u, y /= M = Math.sqrt(y * y + b * b), b /= M, y *= O, b *= O, g = -(p - f), _ = u - m, g /= M = Math.sqrt(g * g + _ * _), _ /= M, w = (-y + c) * (-b + p) - (-y + u) * (-b + d), P = (-(g *= O) + m) * (-(_ *= O) + p) - (-g + u) * (-_ + f), k = (S = -b + d - (-b + p)) * (T = -g + u - (-g + m)) - (A = -_ + f - (-_ + p)) * (C = -y + u - (-y + c)), Math.abs(k) < .1 ? (k += 10.1, E.push(u - y, p - b, V, G, U, F), E.push(u + y, p + b, V, G, U, F)) : ((h = (C * P - T * w) / k) - u) * (h - u) + ((l = (A * w - S * P) / k) - p) + (l - p) > 19600 ? (v = y - g, x = b - _, v /= M = Math.sqrt(v * v + x * x), x /= M, v *= O, x *= O, E.push(u - v, p - x), E.push(V, G, U, F), E.push(u + v, p + x), E.push(V, G, U, F), E.push(u - v, p - x), E.push(V, G, U, F), D++) : (E.push(h, l), E.push(V, G, U, F), E.push(u - (h - u), p - (l - p)), E.push(V, G, U, F)); for (c = o[2 * (I - 2)], d = o[2 * (I - 2) + 1], u = o[2 * (I - 1)], y = -(d - (p = o[2 * (I - 1) + 1])), b = c - u, y /= M = Math.sqrt(y * y + b * b), b /= M, y *= O, b *= O, E.push(u - y, p - b), E.push(V, G, U, F), E.push(u + y, p + b), E.push(V, G, U, F), B.push(L), i = 0; i < D; i++) B.push(L++);
                B.push(L - 1) } }, PIXI.WebGLGraphics.buildComplexPoly = function(t, e) { var i = t.points.slice(); if (!(i.length < 6)) { var o = e.indices;
                e.points = i, e.alpha = t.fillAlpha, e.color = PIXI.hex2rgb(t.fillColor); for (var n, s, r = 1 / 0, a = -1 / 0, h = 1 / 0, l = -1 / 0, c = 0; c < i.length; c += 2) n = i[c], s = i[c + 1], r = n < r ? n : r, a = n > a ? n : a, h = s < h ? s : h, l = s > l ? s : l;
                i.push(r, h, a, h, a, l, r, l); var d = i.length / 2; for (c = 0; c < d; c++) o.push(c) } }, PIXI.WebGLGraphics.buildPoly = function(t, e) { var i = t.points; if (!(i.length < 6)) { var o = e.points,
                    n = e.indices,
                    s = i.length / 2,
                    r = PIXI.hex2rgb(t.fillColor),
                    a = t.fillAlpha,
                    h = r[0] * a,
                    l = r[1] * a,
                    c = r[2] * a,
                    d = PIXI.EarCut.Triangulate(i, null, 2); if (!d) return !1; var u = o.length / 6,
                    p = 0; for (p = 0; p < d.length; p += 3) n.push(d[p] + u), n.push(d[p] + u), n.push(d[p + 1] + u), n.push(d[p + 2] + u), n.push(d[p + 2] + u); for (p = 0; p < s; p++) o.push(i[2 * p], i[2 * p + 1], h, l, c, a); return !0 } }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(t) { this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0 }, PIXI.WebGLGraphicsData.prototype.reset = function() { this.points = [], this.indices = [] }, PIXI.WebGLGraphicsData.prototype.upload = function() { var t = this.gl;
            this.glPoints = new PIXI.Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndicies = new PIXI.Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW), this.dirty = !1 }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(t, e) { var i = t.worldAlpha;
            t.dirty && (this.updateGraphicsTint(t), t.dirty = !1); for (var o = 0; o < t.graphicsData.length; o++) { var n = t.graphicsData[o],
                    s = n.shape,
                    r = n._fillTint,
                    a = n._lineTint; if (e.lineWidth = n.lineWidth, n.type === PIXI.Graphics.POLY) { e.beginPath(); var h = s.points;
                    e.moveTo(h[0], h[1]); for (var l = 1; l < h.length / 2; l++) e.lineTo(h[2 * l], h[2 * l + 1]);
                    s.closed && e.lineTo(h[0], h[1]), h[0] === h[h.length - 2] && h[1] === h[h.length - 1] && e.closePath(), n.fill && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fill()), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke()) } else if (n.type === PIXI.Graphics.RECT)(n.fillColor || 0 === n.fillColor) && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fillRect(s.x, s.y, s.width, s.height)), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.strokeRect(s.x, s.y, s.width, s.height));
                else if (n.type === PIXI.Graphics.CIRC) e.beginPath(), e.arc(s.x, s.y, s.radius, 0, 2 * Math.PI), e.closePath(), n.fill && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fill()), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke());
                else if (n.type === PIXI.Graphics.ELIP) { var c = 2 * s.width,
                        d = 2 * s.height,
                        u = s.x - c / 2,
                        p = s.y - d / 2;
                    e.beginPath(); var m = c / 2 * .5522848,
                        f = d / 2 * .5522848,
                        y = u + c,
                        b = p + d,
                        g = u + c / 2,
                        _ = p + d / 2;
                    e.moveTo(u, _), e.bezierCurveTo(u, _ - f, g - m, p, g, p), e.bezierCurveTo(g + m, p, y, _ - f, y, _), e.bezierCurveTo(y, _ + f, g + m, b, g, b), e.bezierCurveTo(g - m, b, u, _ + f, u, _), e.closePath(), n.fill && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fill()), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke()) } else if (n.type === PIXI.Graphics.RREC) { var v = s.x,
                        x = s.y,
                        S = s.width,
                        C = s.height,
                        w = s.radius,
                        A = Math.min(S, C) / 2 | 0;
                    w = w > A ? A : w, e.beginPath(), e.moveTo(v, x + w), e.lineTo(v, x + C - w), e.quadraticCurveTo(v, x + C, v + w, x + C), e.lineTo(v + S - w, x + C), e.quadraticCurveTo(v + S, x + C, v + S, x + C - w), e.lineTo(v + S, x + w), e.quadraticCurveTo(v + S, x, v + S - w, x), e.lineTo(v + w, x), e.quadraticCurveTo(v, x, v, x + w), e.closePath(), (n.fillColor || 0 === n.fillColor) && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | r).toString(16)).substr(-6), e.fill()), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | a).toString(16)).substr(-6), e.stroke()) } } }, PIXI.CanvasGraphics.renderGraphicsMask = function(t, e) { var i = t.graphicsData.length; if (0 !== i) { e.beginPath(); for (var o = 0; o < i; o++) { var n = t.graphicsData[o],
                        s = n.shape; if (n.type === PIXI.Graphics.POLY) { var r = s.points;
                        e.moveTo(r[0], r[1]); for (var a = 1; a < r.length / 2; a++) e.lineTo(r[2 * a], r[2 * a + 1]);
                        r[0] === r[r.length - 2] && r[1] === r[r.length - 1] && e.closePath() } else if (n.type === PIXI.Graphics.RECT) e.rect(s.x, s.y, s.width, s.height), e.closePath();
                    else if (n.type === PIXI.Graphics.CIRC) e.arc(s.x, s.y, s.radius, 0, 2 * Math.PI), e.closePath();
                    else if (n.type === PIXI.Graphics.ELIP) { var h = 2 * s.width,
                            l = 2 * s.height,
                            c = s.x - h / 2,
                            d = s.y - l / 2,
                            u = h / 2 * .5522848,
                            p = l / 2 * .5522848,
                            m = c + h,
                            f = d + l,
                            y = c + h / 2,
                            b = d + l / 2;
                        e.moveTo(c, b), e.bezierCurveTo(c, b - p, y - u, d, y, d), e.bezierCurveTo(y + u, d, m, b - p, m, b), e.bezierCurveTo(m, b + p, y + u, f, y, f), e.bezierCurveTo(y - u, f, c, b + p, c, b), e.closePath() } else if (n.type === PIXI.Graphics.RREC) { var g = s.x,
                            _ = s.y,
                            v = s.width,
                            x = s.height,
                            S = s.radius,
                            C = Math.min(v, x) / 2 | 0;
                        S = S > C ? C : S, e.moveTo(g, _ + S), e.lineTo(g, _ + x - S), e.quadraticCurveTo(g, _ + x, g + S, _ + x), e.lineTo(g + v - S, _ + x), e.quadraticCurveTo(g + v, _ + x, g + v, _ + x - S), e.lineTo(g + v, _ + S), e.quadraticCurveTo(g + v, _, g + v - S, _), e.lineTo(g + S, _), e.quadraticCurveTo(g, _, g, _ + S), e.closePath() } } } }, PIXI.CanvasGraphics.updateGraphicsTint = function(t) { if (16777215 !== t.tint)
                for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, o = (255 & t.tint) / 255, n = 0; n < t.graphicsData.length; n++) { var s = t.graphicsData[n],
                        r = 0 | s.fillColor,
                        a = 0 | s.lineColor;
                    s._fillTint = ((r >> 16 & 255) / 255 * e * 255 << 16) + ((r >> 8 & 255) / 255 * i * 255 << 8) + (255 & r) / 255 * o * 255, s._lineTint = ((a >> 16 & 255) / 255 * e * 255 << 16) + ((a >> 8 & 255) / 255 * i * 255 << 8) + (255 & a) / 255 * o * 255 } }, i.Graphics = function(t, e, o) { void 0 === e && (e = 0), void 0 === o && (o = 0), this.type = i.GRAPHICS, this.physicsType = i.SPRITE, this.anchor = new i.Point, PIXI.Graphics.call(this), i.Component.Core.init.call(this, t, e, o, "", null) }, i.Graphics.prototype = Object.create(PIXI.Graphics.prototype), i.Graphics.prototype.constructor = i.Graphics, i.Component.Core.install.call(i.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), i.Graphics.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Graphics.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Graphics.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Graphics.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Graphics.prototype.preUpdate = function() { return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore() }, i.Graphics.prototype.postUpdate = function() { i.Component.PhysicsBody.postUpdate.call(this), i.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1); for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate() }, i.Graphics.prototype.destroy = function(t) { this.clear(), i.Component.Destroy.prototype.destroy.call(this, t) }, i.Graphics.prototype.drawTriangle = function(t, e) { void 0 === e && (e = !1); var o = new i.Polygon(t); if (e) { var n = new i.Point(this.game.camera.x - t[0].x, this.game.camera.y - t[0].y),
                    s = new i.Point(t[1].x - t[0].x, t[1].y - t[0].y),
                    r = new i.Point(t[1].x - t[2].x, t[1].y - t[2].y).cross(s);
                n.dot(r) > 0 && this.drawPolygon(o) } else this.drawPolygon(o) }, i.Graphics.prototype.drawTriangles = function(t, e, o) { void 0 === o && (o = !1); var n, s = new i.Point,
                r = new i.Point,
                a = new i.Point,
                h = []; if (e)
                if (t[0] instanceof i.Point)
                    for (n = 0; n < e.length / 3; n++) h.push(t[e[3 * n]]), h.push(t[e[3 * n + 1]]), h.push(t[e[3 * n + 2]]), 3 === h.length && (this.drawTriangle(h, o), h = []);
                else
                    for (n = 0; n < e.length; n++) s.x = t[2 * e[n]], s.y = t[2 * e[n] + 1], h.push(s.copyTo({})), 3 === h.length && (this.drawTriangle(h, o), h = []);
            else if (t[0] instanceof i.Point)
                for (n = 0; n < t.length / 3; n++) this.drawTriangle([t[3 * n], t[3 * n + 1], t[3 * n + 2]], o);
            else
                for (n = 0; n < t.length / 6; n++) s.x = t[6 * n + 0], s.y = t[6 * n + 1], r.x = t[6 * n + 2], r.y = t[6 * n + 3], a.x = t[6 * n + 4], a.y = t[6 * n + 5], this.drawTriangle([s, r, a], o) }, i.RenderTexture = function(t, e, o, n, s, r) { void 0 === n && (n = ""), void 0 === s && (s = i.scaleModes.DEFAULT), void 0 === r && (r = 1), this.game = t, this.key = n, this.type = i.RENDERTEXTURE, this._tempMatrix = new PIXI.Matrix, PIXI.RenderTexture.call(this, e, o, this.game.renderer, s, r), this.render = i.RenderTexture.prototype.render }, i.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype), i.RenderTexture.prototype.constructor = i.RenderTexture, i.RenderTexture.prototype.renderXY = function(t, e, i, o) { t.updateTransform(), this._tempMatrix.copyFrom(t.worldTransform), this._tempMatrix.tx = e, this._tempMatrix.ty = i, this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, o) : this.renderCanvas(t, this._tempMatrix, o) }, i.RenderTexture.prototype.renderRawXY = function(t, e, i, o) { this._tempMatrix.identity().translate(e, i), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, o) : this.renderCanvas(t, this._tempMatrix, o) }, i.RenderTexture.prototype.render = function(t, e, i) { void 0 === e || null === e ? this._tempMatrix.copyFrom(t.worldTransform) : this._tempMatrix.copyFrom(e), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, i) : this.renderCanvas(t, this._tempMatrix, i) }, i.Text = function(t, e, o, n, s) { e = e || 0, o = o || 0, n = void 0 === n || null === n ? "" : n.toString(), s = i.Utils.extend({}, s), this.type = i.TEXT, this.physicsType = i.SPRITE, this.padding = new i.Point, this.textBounds = null, this.canvas = PIXI.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this._res = t.renderer.resolution, this._text = n, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, i.Sprite.call(this, t, e, o, PIXI.Texture.fromCanvas(this.canvas)), this.setStyle(s), "" !== n && this.updateText() }, i.Text.prototype = Object.create(i.Sprite.prototype), i.Text.prototype.constructor = i.Text, i.Text.prototype.preUpdate = function() { return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore() }, i.Text.prototype.update = function() {}, i.Text.prototype.destroy = function(t) { this.texture.destroy(!0), i.Component.Destroy.prototype.destroy.call(this, t) }, i.Text.prototype.setShadow = function(t, e, i, o, n, s) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "rgba(0, 0, 0, 1)"), void 0 === o && (o = 0), void 0 === n && (n = !0), void 0 === s && (s = !0), this.style.shadowOffsetX = t, this.style.shadowOffsetY = e, this.style.shadowColor = i, this.style.shadowBlur = o, this.style.shadowStroke = n, this.style.shadowFill = s, this.dirty = !0, this }, i.Text.prototype.setStyle = function(t, e) { void 0 === e && (e = !1), (t = t || {}).font = t.font || "bold 20pt Arial", t.backgroundColor = t.backgroundColor || null, t.fill = t.fill || "black", t.align = t.align || "left", t.boundsAlignH = t.boundsAlignH || "left", t.boundsAlignV = t.boundsAlignV || "top", t.stroke = t.stroke || "black", t.strokeThickness = t.strokeThickness || 0, t.wordWrap = t.wordWrap || !1, t.wordWrapWidth = t.wordWrapWidth || 100, t.maxLines = t.maxLines || 0, t.shadowOffsetX = t.shadowOffsetX || 0, t.shadowOffsetY = t.shadowOffsetY || 0, t.shadowColor = t.shadowColor || "rgba(0,0,0,0)", t.shadowBlur = t.shadowBlur || 0, t.tabs = t.tabs || 0; var i = this.fontToComponents(t.font); return t.fontStyle && (i.fontStyle = t.fontStyle), t.fontVariant && (i.fontVariant = t.fontVariant), t.fontWeight && (i.fontWeight = t.fontWeight), t.fontSize && ("number" == typeof t.fontSize && (t.fontSize = t.fontSize + "px"), i.fontSize = t.fontSize), this._fontComponents = i, t.font = this.componentsToFont(this._fontComponents), this.style = t, this.dirty = !0, e && this.updateText(), this }, i.Text.prototype.updateText = function() { this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font; var t = this.text;
            this.style.wordWrap && (t = this.runWordWrap(this.text)); var e = t.split(/(?:\r\n|\r|\n)/),
                i = this.style.tabs,
                o = [],
                n = 0,
                s = this.determineFontProperties(this.style.font),
                r = e.length;
            this.style.maxLines > 0 && this.style.maxLines < e.length && (r = this.style.maxLines), this._charCount = 0; for (var a = 0; a < r; a++) { if (0 === i) { l = this.style.strokeThickness + this.padding.x;
                    this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? l += this.measureLine(e[a]) : l += this.context.measureText(e[a]).width, this.style.wordWrap && (l -= this.context.measureText(" ").width) } else { var h = e[a].split(/(?:\t)/),
                        l = this.padding.x + this.style.strokeThickness; if (Array.isArray(i))
                        for (var c = 0, d = 0; d < h.length; d++) { var u = 0;
                            u = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(h[d]) : Math.ceil(this.context.measureText(h[d]).width), d > 0 && (c += i[d - 1]), l = c + u } else
                            for (d = 0; d < h.length; d++) this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? l += this.measureLine(h[d]) : l += Math.ceil(this.context.measureText(h[d]).width), l += this.game.math.snapToCeil(l, i) - l } o[a] = Math.ceil(l), n = Math.max(n, o[a]) } this.canvas.width = n * this._res; var p = s.fontSize + this.style.strokeThickness + this.padding.y,
                m = p * r,
                f = this._lineSpacing;
            f < 0 && Math.abs(f) > p && (f = -p), 0 !== f && (m += f > 0 ? f * e.length : f * (e.length - 1)), this.canvas.height = m * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round"; var y, b; for (this._charCount = 0, a = 0; a < r; a++) y = this.style.strokeThickness / 2, b = this.style.strokeThickness / 2 + a * p + s.ascent, a > 0 && (b += f * a), "right" === this.style.align ? y += n - o[a] : "center" === this.style.align && (y += (n - o[a]) / 2), this.autoRound && (y = Math.round(y), b = Math.round(b)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(e[a], y, b) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[a], y, b) : this.renderTabLine(e[a], y, b, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[a], y, b) : this.renderTabLine(e[a], y, b, !0)));
            this.updateTexture(), this.dirty = !1 }, i.Text.prototype.renderTabLine = function(t, e, i, o) { var n = t.split(/(?:\t)/),
                s = this.style.tabs,
                r = 0; if (Array.isArray(s))
                for (var a = 0, h = 0; h < n.length; h++) h > 0 && (a += s[h - 1]), r = e + a, o ? this.context.fillText(n[h], r, i) : this.context.strokeText(n[h], r, i);
            else
                for (h = 0; h < n.length; h++) { var l = Math.ceil(this.context.measureText(n[h]).width);
                    r = this.game.math.snapToCeil(e, s), o ? this.context.fillText(n[h], r, i) : this.context.strokeText(n[h], r, i), e = r + l } }, i.Text.prototype.updateShadow = function(t) { t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0) }, i.Text.prototype.measureLine = function(t) { for (var e = 0, i = 0; i < t.length; i++) { var o = t[i]; if (this.fontWeights.length > 0 || this.fontStyles.length > 0) { var n = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (n.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (n.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(n) } this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), e += this.context.measureText(o).width, this._charCount++ } return Math.ceil(e) }, i.Text.prototype.updateLine = function(t, e, i) { for (var o = 0; o < t.length; o++) { var n = t[o]; if (this.fontWeights.length > 0 || this.fontStyles.length > 0) { var s = this.fontToComponents(this.context.font);
                    this.fontStyles[this._charCount] && (s.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (s.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(s) } this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(n, e, i)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(n, e, i)), e += this.context.measureText(n).width, this._charCount++ } }, i.Text.prototype.clearColors = function() { return this.colors = [], this.strokeColors = [], this.dirty = !0, this }, i.Text.prototype.clearFontValues = function() { return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this }, i.Text.prototype.addColor = function(t, e) { return this.colors[e] = t, this.dirty = !0, this }, i.Text.prototype.addStrokeColor = function(t, e) { return this.strokeColors[e] = t, this.dirty = !0, this }, i.Text.prototype.addFontStyle = function(t, e) { return this.fontStyles[e] = t, this.dirty = !0, this }, i.Text.prototype.addFontWeight = function(t, e) { return this.fontWeights[e] = t, this.dirty = !0, this }, i.Text.prototype.precalculateWordWrap = function(t) { return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(t).split(/(?:\r\n|\r|\n)/) }, i.Text.prototype.runWordWrap = function(t) { return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t) }, i.Text.prototype.advancedWordWrap = function(t) { for (var e = this.context, i = this.style.wordWrapWidth, o = "", n = t.replace(/ +/gi, " ").split(/\r?\n/gi), s = n.length, r = 0; r < s; r++) { var a = n[r],
                    h = ""; if (a = a.replace(/^ *|\s*$/gi, ""), e.measureText(a).width < i) o += a + "\n";
                else { for (var l = i, c = a.split(" "), d = 0; d < c.length; d++) { var u = c[d],
                            p = u + " ",
                            m = e.measureText(p).width; if (m > l) { if (0 === d) { for (var f = p; f.length && (f = f.slice(0, -1), !((m = e.measureText(f).width) <= l));); if (!f.length) throw new Error("This text's wordWrapWidth setting is less than a single character!"); var y = u.substr(f.length);
                                c[d] = y, h += f } var b = c[d].length ? d : d + 1,
                                g = c.slice(b).join(" ").replace(/[ \n]*$/gi, "");
                            n[r + 1] = g + " " + (n[r + 1] || ""), s = n.length; break } h += p, l -= m } o += h.replace(/[ \n]*$/gi, "") + "\n" } } return o = o.replace(/[\s|\n]*$/gi, "") }, i.Text.prototype.basicWordWrap = function(t) { for (var e = "", i = t.split("\n"), o = 0; o < i.length; o++) { for (var n = this.style.wordWrapWidth, s = i[o].split(" "), r = 0; r < s.length; r++) { var a = this.context.measureText(s[r]).width,
                        h = a + this.context.measureText(" ").width;
                    h > n ? (r > 0 && (e += "\n"), e += s[r] + " ", n = this.style.wordWrapWidth - a) : (n -= h, e += s[r] + " ") } o < i.length - 1 && (e += "\n") } return e }, i.Text.prototype.updateFont = function(t) { var e = this.componentsToFont(t);
            this.style.font !== e && (this.style.font = e, this.dirty = !0, this.parent && this.updateTransform()) }, i.Text.prototype.fontToComponents = function(t) { var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/); if (e) { var i = e[5].trim(); return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"), { font: t, fontStyle: e[1] || "normal", fontVariant: e[2] || "normal", fontWeight: e[3] || "normal", fontSize: e[4] || "medium", fontFamily: i } } return { font: t } }, i.Text.prototype.componentsToFont = function(t) { var e, i = []; return (e = t.fontStyle) && "normal" !== e && i.push(e), (e = t.fontVariant) && "normal" !== e && i.push(e), (e = t.fontWeight) && "normal" !== e && i.push(e), (e = t.fontSize) && "medium" !== e && i.push(e), (e = t.fontFamily) && i.push(e), i.length || i.push(t.font), i.join(" ") }, i.Text.prototype.setText = function(t, e) { return void 0 === e && (e = !1), this.text = t.toString() || "", e ? this.updateText() : this.dirty = !0, this }, i.Text.prototype.parseList = function(t) { if (!Array.isArray(t)) return this; for (var e = "", i = 0; i < t.length; i++) Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t")); return this.text = e, this.dirty = !0, this }, i.Text.prototype.setTextBounds = function(t, e, o, n) { return void 0 === t ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(t, e, o, n) : this.textBounds = new i.Rectangle(t, e, o, n), this.style.wordWrapWidth > o && (this.style.wordWrapWidth = o)), this.updateTexture(), this }, i.Text.prototype.updateTexture = function() { var t = this.texture.baseTexture,
                e = this.texture.crop,
                i = this.texture.frame,
                o = this.canvas.width,
                n = this.canvas.height; if (t.width = o, t.height = n, e.width = o, e.height = n, i.width = o, i.height = n, this.texture.width = o, this.texture.height = n, this._width = o, this._height = n, this.textBounds) { var s = this.textBounds.x,
                    r = this.textBounds.y; "right" === this.style.boundsAlignH ? s += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (s += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? r += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (r += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -s, this.pivot.y = -r } this.renderable = 0 !== o && 0 !== n, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty() }, i.Text.prototype._renderWebGL = function(t) { this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, t) }, i.Text.prototype._renderCanvas = function(t) { this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, t) }, i.Text.prototype.determineFontProperties = function(t) { var e = i.Text.fontPropertiesCache[t]; if (!e) { e = {}; var o = i.Text.fontPropertiesCanvas,
                    n = i.Text.fontPropertiesContext;
                n.font = t; var s = Math.ceil(n.measureText("|MÉq").width),
                    r = Math.ceil(n.measureText("|MÉq").width),
                    a = 2 * r; if (r = 1.4 * r | 0, o.width = s, o.height = a, n.fillStyle = "#f00", n.fillRect(0, 0, s, a), n.font = t, n.textBaseline = "alphabetic", n.fillStyle = "#000", n.fillText("|MÉq", 0, r), !n.getImageData(0, 0, s, a)) return e.ascent = r, e.descent = r + 6, e.fontSize = e.ascent + e.descent, i.Text.fontPropertiesCache[t] = e, e; var h, l, c = n.getImageData(0, 0, s, a).data,
                    d = c.length,
                    u = 4 * s,
                    p = 0,
                    m = !1; for (h = 0; h < r; h++) { for (l = 0; l < u; l += 4)
                        if (255 !== c[p + l]) { m = !0; break } if (m) break;
                    p += u } for (e.ascent = r - h, p = d - u, m = !1, h = a; h > r; h--) { for (l = 0; l < u; l += 4)
                        if (255 !== c[p + l]) { m = !0; break } if (m) break;
                    p -= u } e.descent = h - r, e.descent += 6, e.fontSize = e.ascent + e.descent, i.Text.fontPropertiesCache[t] = e } return e }, i.Text.prototype.getBounds = function(t) { return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, t) }, Object.defineProperty(i.Text.prototype, "text", { get: function() { return this._text }, set: function(t) { t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform()) } }), Object.defineProperty(i.Text.prototype, "cssFont", { get: function() { return this.componentsToFont(this._fontComponents) }, set: function(t) { t = t || "bold 20pt Arial", this._fontComponents = this.fontToComponents(t), this.updateFont(this._fontComponents) } }), Object.defineProperty(i.Text.prototype, "font", { get: function() { return this._fontComponents.fontFamily }, set: function(t) { t = (t = t || "Arial").trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"), this._fontComponents.fontFamily = t, this.updateFont(this._fontComponents) } }), Object.defineProperty(i.Text.prototype, "fontSize", { get: function() { var t = this._fontComponents.fontSize; return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t }, set: function(t) { "number" == typeof(t = t || "0") && (t += "px"), this._fontComponents.fontSize = t, this.updateFont(this._fontComponents) } }), Object.defineProperty(i.Text.prototype, "fontWeight", { get: function() { return this._fontComponents.fontWeight || "normal" }, set: function(t) { t = t || "normal", this._fontComponents.fontWeight = t, this.updateFont(this._fontComponents) } }), Object.defineProperty(i.Text.prototype, "fontStyle", { get: function() { return this._fontComponents.fontStyle || "normal" }, set: function(t) { t = t || "normal", this._fontComponents.fontStyle = t, this.updateFont(this._fontComponents) } }), Object.defineProperty(i.Text.prototype, "fontVariant", { get: function() { return this._fontComponents.fontVariant || "normal" }, set: function(t) { t = t || "normal", this._fontComponents.fontVariant = t, this.updateFont(this._fontComponents) } }), Object.defineProperty(i.Text.prototype, "fill", { get: function() { return this.style.fill }, set: function(t) { t !== this.style.fill && (this.style.fill = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "align", { get: function() { return this.style.align }, set: function(t) { t !== this.style.align && (this.style.align = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "resolution", { get: function() { return this._res }, set: function(t) { t !== this._res && (this._res = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "tabs", { get: function() { return this.style.tabs }, set: function(t) { t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "boundsAlignH", { get: function() { return this.style.boundsAlignH }, set: function(t) { t !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "boundsAlignV", { get: function() { return this.style.boundsAlignV }, set: function(t) { t !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "stroke", { get: function() { return this.style.stroke }, set: function(t) { t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "strokeThickness", { get: function() { return this.style.strokeThickness }, set: function(t) { t !== this.style.strokeThickness && (this.style.strokeThickness = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "wordWrap", { get: function() { return this.style.wordWrap }, set: function(t) { t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "wordWrapWidth", { get: function() { return this.style.wordWrapWidth }, set: function(t) { t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "lineSpacing", { get: function() { return this._lineSpacing }, set: function(t) { t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform()) } }), Object.defineProperty(i.Text.prototype, "shadowOffsetX", { get: function() { return this.style.shadowOffsetX }, set: function(t) { t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "shadowOffsetY", { get: function() { return this.style.shadowOffsetY }, set: function(t) { t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "shadowColor", { get: function() { return this.style.shadowColor }, set: function(t) { t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "shadowBlur", { get: function() { return this.style.shadowBlur }, set: function(t) { t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "shadowStroke", { get: function() { return this.style.shadowStroke }, set: function(t) { t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "shadowFill", { get: function() { return this.style.shadowFill }, set: function(t) { t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0) } }), Object.defineProperty(i.Text.prototype, "width", { get: function() { return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width }, set: function(t) { this.scale.x = t / this.texture.frame.width, this._width = t } }), Object.defineProperty(i.Text.prototype, "height", { get: function() { return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height }, set: function(t) { this.scale.y = t / this.texture.frame.height, this._height = t } }), i.Text.fontPropertiesCache = {}, i.Text.fontPropertiesCanvas = document.createElement("canvas"), i.Text.fontPropertiesContext = i.Text.fontPropertiesCanvas.getContext("2d"), i.BitmapText = function(t, e, o, n, s, r, a) { e = e || 0, o = o || 0, n = n || "", s = s || "", r = r || 32, a = a || "left", PIXI.DisplayObjectContainer.call(this), this.type = i.BITMAPTEXT, this.physicsType = i.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new i.Point, this._prevAnchor = new i.Point, this._glyphs = [], this._maxWidth = 0, this._text = s.toString() || "", this._data = t.cache.getBitmapFont(n), this._font = n, this._fontSize = r, this._align = a, this._tint = 16777215, this.updateText(), this.dirty = !1, i.Component.Core.init.call(this, t, e, o, "", null) }, i.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), i.BitmapText.prototype.constructor = i.BitmapText, i.Component.Core.install.call(i.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), i.BitmapText.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.BitmapText.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.BitmapText.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.BitmapText.prototype.preUpdateCore = i.Component.Core.preUpdate, i.BitmapText.prototype.preUpdate = function() { return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore() }, i.BitmapText.prototype.postUpdate = function() { i.Component.PhysicsBody.postUpdate.call(this), i.Component.FixedToCamera.postUpdate.call(this), this.body && this.body.type === i.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight)) }, i.BitmapText.prototype.setText = function(t) { this.text = t }, i.BitmapText.prototype.scanLine = function(t, e, i) { for (var o = 0, n = 0, s = -1, r = 0, a = null, h = this._maxWidth > 0 ? this._maxWidth : null, l = [], c = 0; c < i.length; c++) { var d = c === i.length - 1; if (/(?:\r\n|\r|\n)/.test(i.charAt(c))) return { width: n, text: i.substr(0, c), end: d, chars: l }; var u = i.charCodeAt(c),
                    p = t.chars[u],
                    m = 0;
                void 0 === p && (u = 32, p = t.chars[u]); var f = a && p.kerning[a] ? p.kerning[a] : 0; if (/(\s)/.test(i.charAt(c)) && (s = c, r = n), m = (f + p.texture.width + p.xOffset) * e, h && n + m >= h && s > -1) return { width: r || n, text: i.substr(0, c - (c - s)), end: d, chars: l };
                n += (p.xAdvance + f) * e, l.push(o + (p.xOffset + f) * e), o += (p.xAdvance + f) * e, a = u } return { width: n, text: i, end: d, chars: l } }, i.BitmapText.prototype.cleanText = function(t, e) { void 0 === e && (e = ""); var i = this._data.font; if (!i) return ""; for (var o = /\r\n|\n\r|\n|\r/g, n = t.replace(o, "\n").split("\n"), s = 0; s < n.length; s++) { for (var r = "", a = n[s], h = 0; h < a.length; h++) r = i.chars[a.charCodeAt(h)] ? r.concat(a[h]) : r.concat(e);
                n[s] = r } return n.join("\n") }, i.BitmapText.prototype.updateText = function() { var t = this._data.font; if (t) { var e = this.text,
                    i = this._fontSize / t.size,
                    o = [],
                    n = 0;
                this.textWidth = 0;
                do {
                    (c = this.scanLine(t, i, e)).y = n, o.push(c), c.width > this.textWidth && (this.textWidth = c.width), n += t.lineHeight * i, e = e.substr(c.text.length + 1) } while (!1 === c.end);
                this.textHeight = n; for (var s = 0, r = 0, a = this.textWidth * this.anchor.x, h = this.textHeight * this.anchor.y, l = 0; l < o.length; l++) { var c = o[l]; "right" === this._align ? r = this.textWidth - c.width : "center" === this._align && (r = (this.textWidth - c.width) / 2); for (var d = 0; d < c.text.length; d++) { var u = c.text.charCodeAt(d),
                            p = t.chars[u];
                        void 0 === p && (u = 32, p = t.chars[u]); var m = this._glyphs[s];
                        m ? m.texture = p.texture : ((m = new PIXI.Sprite(p.texture)).name = c.text[d], this._glyphs.push(m)), m.position.x = c.chars[d] + r - a, m.position.y = c.y + p.yOffset * i - h, m.scale.set(i), m.tint = this.tint, m.texture.requiresReTint = !0, m.parent || this.addChild(m), s++ } } for (l = s; l < this._glyphs.length; l++) this.removeChild(this._glyphs[l]) } }, i.BitmapText.prototype.purgeGlyphs = function() { for (var t = this._glyphs.length, e = [], i = 0; i < this._glyphs.length; i++) this._glyphs[i].parent !== this ? this._glyphs[i].destroy() : e.push(this._glyphs[i]); return this._glyphs = [], this._glyphs = e, this.updateText(), t - e.length }, i.BitmapText.prototype.updateTransform = function() {!this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this) }, Object.defineProperty(i.BitmapText.prototype, "align", { get: function() { return this._align }, set: function(t) { t === this._align || "left" !== t && "center" !== t && "right" !== t || (this._align = t, this.updateText()) } }), Object.defineProperty(i.BitmapText.prototype, "tint", { get: function() { return this._tint }, set: function(t) { t !== this._tint && (this._tint = t, this.updateText()) } }), Object.defineProperty(i.BitmapText.prototype, "font", { get: function() { return this._font }, set: function(t) { t !== this._font && (this._font = t.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText()) } }), Object.defineProperty(i.BitmapText.prototype, "fontSize", { get: function() { return this._fontSize }, set: function(t) {
                (t = parseInt(t, 10)) !== this._fontSize && t > 0 && (this._fontSize = t, this.updateText()) } }), Object.defineProperty(i.BitmapText.prototype, "text", { get: function() { return this._text }, set: function(t) { t !== this._text && (this._text = t.toString() || "", this.updateText()) } }), Object.defineProperty(i.BitmapText.prototype, "maxWidth", { get: function() { return this._maxWidth }, set: function(t) { t !== this._maxWidth && (this._maxWidth = t, this.updateText()) } }), Object.defineProperty(i.BitmapText.prototype, "smoothed", { get: function() { return !this._data.base.scaleMode }, set: function(t) { this._data.base.scaleMode = t ? 0 : 1 } }), i.RetroFont = function(t, e, o, n, s, r, a, h, l, c) { if (!t.cache.checkImageKey(e)) return !1;
            void 0 !== r && null !== r || (r = t.cache.getImage(e).width / o), this.characterWidth = o, this.characterHeight = n, this.characterSpacingX = a || 0, this.characterSpacingY = h || 0, this.characterPerRow = r, this.offsetX = l || 0, this.offsetY = c || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = t.cache.getImage(e), this._text = "", this.grabData = [], this.frameData = new i.FrameData; for (var d = this.offsetX, u = this.offsetY, p = 0, m = 0; m < s.length; m++) { var f = this.frameData.addFrame(new i.Frame(m, d, u, this.characterWidth, this.characterHeight));
                this.grabData[s.charCodeAt(m)] = f.index, ++p === this.characterPerRow ? (p = 0, d = this.offsetX, u += this.characterHeight + this.characterSpacingY) : d += this.characterWidth + this.characterSpacingX } t.cache.updateFrameData(e, this.frameData), this.stamp = new i.Image(t, 0, 0, e, 0), i.RenderTexture.call(this, t, 100, 100, "", i.scaleModes.NEAREST), this.type = i.RETROFONT }, i.RetroFont.prototype = Object.create(i.RenderTexture.prototype), i.RetroFont.prototype.constructor = i.RetroFont, i.RetroFont.ALIGN_LEFT = "left", i.RetroFont.ALIGN_RIGHT = "right", i.RetroFont.ALIGN_CENTER = "center", i.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", i.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", i.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", i.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", i.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", i.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", i.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", i.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", i.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", i.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", i.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", i.RetroFont.prototype.setFixedWidth = function(t, e) { void 0 === e && (e = "left"), this.fixedWidth = t, this.align = e }, i.RetroFont.prototype.setText = function(t, e, i, o, n, s) { this.multiLine = e || !1, this.customSpacingX = i || 0, this.customSpacingY = o || 0, this.align = n || "left", this.autoUpperCase = !s, t.length > 0 && (this.text = t) }, i.RetroFont.prototype.buildRetroFontText = function() { var t = 0,
                e = 0; if (this.clear(), this.multiLine) { var o = this._text.split("\n");
                this.fixedWidth > 0 ? this.resize(this.fixedWidth, o.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), o.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0); for (var n = 0; n < o.length; n++) t = 0, this.align === i.RetroFont.ALIGN_RIGHT ? t = this.width - o[n].length * (this.characterWidth + this.customSpacingX) : this.align === i.RetroFont.ALIGN_CENTER && (t = this.width / 2 - o[n].length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(o[n], t, e, this.customSpacingX), e += this.characterHeight + this.customSpacingY } else this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), t = 0, this.align === i.RetroFont.ALIGN_RIGHT ? t = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === i.RetroFont.ALIGN_CENTER && (t = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(this._text, t, 0, this.customSpacingX);
            this.requiresReTint = !0 }, i.RetroFont.prototype.pasteLine = function(t, e, i, o) { for (var n = 0; n < t.length; n++)
                if (" " === t.charAt(n)) e += this.characterWidth + o;
                else if (this.grabData[t.charCodeAt(n)] >= 0 && (this.stamp.frame = this.grabData[t.charCodeAt(n)], this.renderXY(this.stamp, e, i, !1), (e += this.characterWidth + o) > this.width)) break }, i.RetroFont.prototype.getLongestLine = function() { var t = 0; if (this._text.length > 0)
                for (var e = this._text.split("\n"), i = 0; i < e.length; i++) e[i].length > t && (t = e[i].length); return t }, i.RetroFont.prototype.removeUnsupportedCharacters = function(t) { for (var e = "", i = 0; i < this._text.length; i++) { var o = this._text[i],
                    n = o.charCodeAt(0);
                (this.grabData[n] >= 0 || !t && "\n" === o) && (e = e.concat(o)) } return e }, i.RetroFont.prototype.updateOffset = function(t, e) { if (this.offsetX !== t || this.offsetY !== e) { for (var i = t - this.offsetX, o = e - this.offsetY, n = this.game.cache.getFrameData(this.stamp.key).getFrames(), s = n.length; s--;) n[s].x += i, n[s].y += o;
                this.buildRetroFontText() } }, Object.defineProperty(i.RetroFont.prototype, "text", { get: function() { return this._text }, set: function(t) { var e;
                (e = this.autoUpperCase ? t.toUpperCase() : t) !== this._text && (this._text = e, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText()) } }), Object.defineProperty(i.RetroFont.prototype, "smoothed", { get: function() { return this.stamp.smoothed }, set: function(t) { this.stamp.smoothed = t, this.buildRetroFontText() } }), i.Rope = function(t, e, o, n, s, r) { this.points = [], this.points = r, this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, e = e || 0, o = o || 0, n = n || null, s = s || null, this.type = i.ROPE, PIXI.Rope.call(this, i.Cache.DEFAULT, this.points), i.Component.Core.init.call(this, t, e, o, n, s) }, i.Rope.prototype = Object.create(PIXI.Rope.prototype), i.Rope.prototype.constructor = i.Rope, i.Component.Core.install.call(i.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), i.Rope.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.Rope.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.Rope.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.Rope.prototype.preUpdateCore = i.Component.Core.preUpdate, i.Rope.prototype.preUpdate = function() { return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore() }, i.Rope.prototype.update = function() { this._hasUpdateAnimation && this.updateAnimation.call(this) }, i.Rope.prototype.reset = function(t, e) { return i.Component.Reset.prototype.reset.call(this, t, e), this }, Object.defineProperty(i.Rope.prototype, "updateAnimation", { get: function() { return this._updateAnimation }, set: function(t) { t && "function" == typeof t ? (this._hasUpdateAnimation = !0, this._updateAnimation = t) : (this._hasUpdateAnimation = !1, this._updateAnimation = null) } }), Object.defineProperty(i.Rope.prototype, "segments", { get: function() { for (var t, e, o, n, s, r, a, h, l = [], c = 0; c < this.points.length; c++) t = 4 * c, e = this.vertices[t] * this.scale.x, o = this.vertices[t + 1] * this.scale.y, n = this.vertices[t + 4] * this.scale.x, s = this.vertices[t + 3] * this.scale.y, r = i.Math.difference(e, n), a = i.Math.difference(o, s), e += this.world.x, o += this.world.y, h = new i.Rectangle(e, o, r, a), l.push(h); return l } }), i.TileSprite = function(t, e, o, n, s, r, a) { e = e || 0, o = o || 0, n = n || 256, s = s || 256, r = r || null, a = a || null, this.type = i.TILESPRITE, this.physicsType = i.SPRITE, this._scroll = new i.Point; var h = t.cache.getImage("__default", !0);
            PIXI.TilingSprite.call(this, new PIXI.Texture(h.base), n, s), i.Component.Core.init.call(this, t, e, o, r, a) }, i.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype), i.TileSprite.prototype.constructor = i.TileSprite, i.Component.Core.install.call(i.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]), i.TileSprite.prototype.preUpdatePhysics = i.Component.PhysicsBody.preUpdate, i.TileSprite.prototype.preUpdateLifeSpan = i.Component.LifeSpan.preUpdate, i.TileSprite.prototype.preUpdateInWorld = i.Component.InWorld.preUpdate, i.TileSprite.prototype.preUpdateCore = i.Component.Core.preUpdate, i.TileSprite.prototype.preUpdate = function() { return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore() }, i.TileSprite.prototype.autoScroll = function(t, e) { this._scroll.set(t, e) }, i.TileSprite.prototype.stopScroll = function() { this._scroll.set(0, 0) }, i.TileSprite.prototype.destroy = function(t) { i.Component.Destroy.prototype.destroy.call(this, t), PIXI.TilingSprite.prototype.destroy.call(this) }, i.TileSprite.prototype.reset = function(t, e) { return i.Component.Reset.prototype.reset.call(this, t, e), this.tilePosition.x = 0, this.tilePosition.y = 0, this }, i.Device = function() { this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1 }, i.Device = new i.Device, i.Device.onInitialized = new i.Signal, i.Device.whenReady = function(t, e, i) { var o = this._readyCheck; if (this.deviceReadyAt || !o) t.call(e, this);
            else if (o._monitor || i) o._queue = o._queue || [], o._queue.push([t, e]);
            else { o._monitor = o.bind(this), o._queue = o._queue || [], o._queue.push([t, e]); var n = void 0 !== window.cordova,
                    s = navigator.isCocoonJS; "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(o._monitor, 0) : n && !s ? document.addEventListener("deviceready", o._monitor, !1) : (document.addEventListener("DOMContentLoaded", o._monitor, !1), window.addEventListener("load", o._monitor, !1)) } }, i.Device._readyCheck = function() { var t = this._readyCheck; if (document.body) { if (!this.deviceReadyAt) { this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", t._monitor), document.removeEventListener("DOMContentLoaded", t._monitor), window.removeEventListener("load", t._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this); for (var e; e = t._queue.shift();) { var i = e[0],
                            o = e[1];
                        i.call(o, this) } this._readyCheck = null, this._initialize = null, this.onInitialized = null } } else window.setTimeout(t._monitor, 20) }, i.Device._initialize = function() {
            function t() { var t = new ArrayBuffer(4),
                    e = new Uint8Array(t),
                    i = new Uint32Array(t); return e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === i[0] || 2712847316 !== i[0] && null }

            function e() { if (void 0 === Uint8ClampedArray) return !1; var t = PIXI.CanvasPool.create(this, 1, 1).getContext("2d"); if (!t) return !1; var e = t.createImageData(1, 1); return PIXI.CanvasPool.remove(this), e.data instanceof Uint8ClampedArray } var i = this;! function() { var t = navigator.userAgent; /Playstation Vita/.test(t) ? i.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? i.kindle = !0 : /Android/.test(t) ? i.android = !0 : /CrOS/.test(t) ? i.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (i.iOS = !0, navigator.appVersion.match(/OS (\d+)/), i.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? i.linux = !0 : /Mac OS/.test(t) ? i.macOS = !0 : /Windows/.test(t) && (i.windows = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (i.android = !1, i.iOS = !1, i.macOS = !1, i.windows = !0, i.windowsPhone = !0); var e = /Silk/.test(t);
                (i.windows || i.macOS || i.linux && !e || i.chromeOS) && (i.desktop = !0), (i.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (i.desktop = !1) }(),
            function() { var t = navigator.userAgent; if (/Arora/.test(t) ? i.arora = !0 : /Edge\/\d+/.test(t) ? i.edge = !0 : /Chrome\/(\d+)/.test(t) && !i.windowsPhone ? (i.chrome = !0, i.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? i.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (i.firefox = !0, i.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && i.iOS ? i.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (i.ie = !0, i.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? i.midori = !0 : /Opera/.test(t) ? i.opera = !0 : /Safari\/(\d+)/.test(t) && !i.windowsPhone ? (i.safari = !0, /Version\/(\d+)\./.test(t) && (i.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (i.ie = !0, i.trident = !0, i.tridentVersion = parseInt(RegExp.$1, 10), i.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (i.silk = !0), navigator.standalone && (i.webApp = !0), void 0 !== window.cordova && (i.cordova = !0), "undefined" != typeof process && "undefined" != typeof require && (i.node = !0), i.node && "object" == typeof process.versions && (i.nodeWebkit = !!process.versions["node-webkit"], i.electron = !!process.versions.electron), navigator.isCocoonJS && (i.cocoonJS = !0), i.cocoonJS) try { i.cocoonJSApp = "undefined" != typeof CocoonJS } catch (t) { i.cocoonJSApp = !1 } void 0 !== window.ejecta && (i.ejecta = !0), /Crosswalk/.test(t) && (i.crosswalk = !0) }(),
            function() { i.audioData = !!window.Audio, i.webAudio = !(!window.AudioContext && !window.webkitAudioContext); var t = document.createElement("audio"); try { if (t.canPlayType && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") && (i.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, "") || t.canPlayType("audio/opus;").replace(/^no$/, "")) && (i.opus = !0), t.canPlayType("audio/mpeg;").replace(/^no$/, "") && (i.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, "") && (i.wav = !0), (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;").replace(/^no$/, "")) && (i.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "") && (i.webm = !0), "" !== t.canPlayType('audio/mp4;codecs="ec-3"')))
                        if (i.edge) i.dolby = !0;
                        else if (i.safari && i.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) { var e = parseInt(RegExp.$1, 10),
                            o = parseInt(RegExp.$2, 10);
                        (10 === e && o >= 11 || e > 10) && (i.dolby = !0) } } catch (t) {} }(),
            function() { var t = document.createElement("video"); try {!!t.canPlayType && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, "") && (i.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, "") && (i.h264Video = !0, i.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, "") && (i.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, "") && (i.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, "") && (i.hlsVideo = !0)) } catch (t) {} }(),
            function() { var t, e = document.createElement("p"),
                    o = { webkitTransform: "-webkit-transform", OTransform: "-o-transform", msTransform: "-ms-transform", MozTransform: "-moz-transform", transform: "transform" };
                document.body.insertBefore(e, null); for (var n in o) void 0 !== e.style[n] && (e.style[n] = "translate3d(1px,1px,1px)", t = window.getComputedStyle(e).getPropertyValue(o[n]));
                document.body.removeChild(e), i.css3D = void 0 !== t && t.length > 0 && "none" !== t }(), i.pixelRatio = window.devicePixelRatio || 1, i.iPhone = -1 !== navigator.userAgent.toLowerCase().indexOf("iphone"), i.iPhone4 = 2 === i.pixelRatio && i.iPhone, i.iPad = -1 !== navigator.userAgent.toLowerCase().indexOf("ipad"), "undefined" != typeof Int8Array ? i.typedArray = !0 : i.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (i.littleEndian = t(), i.LITTLE_ENDIAN = i.littleEndian), i.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== i.littleEndian && e(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (i.vibration = !0),
                function() { i.canvas = !!window.CanvasRenderingContext2D || i.cocoonJS; try { i.localStorage = !!localStorage.getItem } catch (t) { i.localStorage = !1 } i.file = !!(window.File && window.FileReader && window.FileList && window.Blob), i.fileSystem = !!window.requestFileSystem, i.webGL = function() { try { var t = document.createElement("canvas"); return t.screencanvas = !1, !!window.WebGLRenderingContext && (t.getContext("webgl") || t.getContext("experimental-webgl")) } catch (t) { return !1 } }(), i.webGL = !!i.webGL, i.worker = !!window.Worker, i.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, i.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, i.getUserMedia = i.getUserMedia && !!navigator.getUserMedia && !!window.URL, i.firefox && i.firefoxVersion < 21 && (i.getUserMedia = !1), !i.iOS && (i.ie || i.firefox || i.chrome) && (i.canvasBitBltShift = !0), (i.safari || i.mobileSafari) && (i.canvasBitBltShift = !1) }(),
                function() { for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], e = document.createElement("div"), o = 0; o < t.length; o++)
                        if (e[t[o]]) { i.fullscreen = !0, i.requestFullscreen = t[o]; break } var n = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"]; if (i.fullscreen)
                        for (o = 0; o < n.length; o++)
                            if (document[n[o]]) { i.cancelFullscreen = n[o]; break } window.Element && Element.ALLOW_KEYBOARD_INPUT && (i.fullscreenKeyboard = !0) }(), ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (i.touch = !0), (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (i.mspointer = !0), i.cocoonJS || ("onwheel" in window || i.ie && "WheelEvent" in window ? i.wheelEvent = "wheel" : "onmousewheel" in window ? i.wheelEvent = "mousewheel" : i.firefox && "MouseScrollEvent" in window && (i.wheelEvent = "DOMMouseScroll")) }, i.Device.canPlayAudio = function(t) { return !("mp3" !== t || !this.mp3) || (!("ogg" !== t || !this.ogg && !this.opus) || (!("m4a" !== t || !this.m4a) || (!("opus" !== t || !this.opus) || (!("wav" !== t || !this.wav) || (!("webm" !== t || !this.webm) || !("mp4" !== t || !this.dolby)))))) }, i.Device.canPlayVideo = function(t) { return !("webm" !== t || !this.webmVideo && !this.vp9Video) || (!("mp4" !== t || !this.mp4Video && !this.h264Video) || (!("ogg" !== t && "ogv" !== t || !this.oggVideo) || !("mpeg" !== t || !this.hlsVideo))) }, i.Device.isConsoleOpen = function() { return !(!window.console || !window.console.firebug) || !(!window.console || (console.clear, !console.profiles)) && console.profiles.length > 0 }, i.Device.isAndroidStockBrowser = function() { var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/); return t && t[1] < 537 }, i.Canvas = { create: function(t, e, i, o, n) { e = e || 256, i = i || 256; var s = n ? document.createElement("canvas") : PIXI.CanvasPool.create(t, e, i); return "string" == typeof o && "" !== o && (s.id = o), s.width = e, s.height = i, s.style.display = "block", s }, setBackgroundColor: function(t, e) { return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t }, setTouchAction: function(t, e) { return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t }, setUserSelect: function(t, e) { return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t }, addToDOM: function(t, e, i) { var o; return void 0 === i && (i = !0), e && ("string" == typeof e ? o = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (o = e)), o || (o = document.body), i && o.style && (o.style.overflow = "hidden"), o.appendChild(t), t }, removeFromDOM: function(t) { t.parentNode && t.parentNode.removeChild(t) }, setTransform: function(t, e, i, o, n, s, r) { return t.setTransform(o, s, r, n, e, i), t }, setSmoothingEnabled: function(t, e) { var o = i.Canvas.getSmoothingPrefix(t); return o && (t[o] = e), t }, getSmoothingPrefix: function(t) { var e = ["i", "webkitI", "msI", "mozI", "oI"]; for (var i in e) { var o = e[i] + "mageSmoothingEnabled"; if (o in t) return o } return null }, getSmoothingEnabled: function(t) { var e = i.Canvas.getSmoothingPrefix(t); if (e) return t[e] }, setImageRenderingCrisp: function(t) { for (var e = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"], i = 0; i < e.length; i++) t.style["image-rendering"] = e[i]; return t.style.msInterpolationMode = "nearest-neighbor", t }, setImageRenderingBicubic: function(t) { return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t } }, i.RequestAnimationFrame = function(t, e) { void 0 === e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e; for (var i = ["ms", "moz", "webkit", "o"], o = 0; o < i.length && !window.requestAnimationFrame; o++) window.requestAnimationFrame = window[i[o] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[o] + "CancelAnimationFrame"];
            this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null }, i.RequestAnimationFrame.prototype = { start: function() { this.isRunning = !0; var t = this;!window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() { return t.updateSetTimeout() }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(e) { return t.updateRAF(e) }, this._timeOutID = window.requestAnimationFrame(this._onLoop)) }, updateRAF: function(t) { this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop)) }, updateSetTimeout: function() { this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall)) }, stop: function() { this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1 }, isSetTimeOut: function() { return this._isSetTimeOut }, isRAF: function() { return !1 === this._isSetTimeOut } }, i.RequestAnimationFrame.prototype.constructor = i.RequestAnimationFrame, i.Math = { PI2: 2 * Math.PI, between: function(t, e) { return Math.floor(Math.random() * (e - t + 1) + t) }, fuzzyEqual: function(t, e, i) { return void 0 === i && (i = 1e-4), Math.abs(t - e) < i }, fuzzyLessThan: function(t, e, i) { return void 0 === i && (i = 1e-4), t < e + i }, fuzzyGreaterThan: function(t, e, i) { return void 0 === i && (i = 1e-4), t > e - i }, fuzzyCeil: function(t, e) { return void 0 === e && (e = 1e-4), Math.ceil(t - e) }, fuzzyFloor: function(t, e) { return void 0 === e && (e = 1e-4), Math.floor(t + e) }, average: function() { for (var t = 0, e = arguments.length, i = 0; i < e; i++) t += +arguments[i]; return t / e }, shear: function(t) { return t % 1 }, snapTo: function(t, e, i) { return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.round(t / e), i + t) }, snapToFloor: function(t, e, i) { return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.floor(t / e), i + t) }, snapToCeil: function(t, e, i) { return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.ceil(t / e), i + t) }, roundTo: function(t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); var o = Math.pow(i, -e); return Math.round(t * o) / o }, floorTo: function(t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); var o = Math.pow(i, -e); return Math.floor(t * o) / o }, ceilTo: function(t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); var o = Math.pow(i, -e); return Math.ceil(t * o) / o }, rotateToAngle: function(t, e, o) { return void 0 === o && (o = .05), t === e ? t : (Math.abs(e - t) <= o || Math.abs(e - t) >= i.Math.PI2 - o ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += i.Math.PI2 : e -= i.Math.PI2), e > t ? t += o : e < t && (t -= o)), t) }, getShortestAngle: function(t, e) { var i = e - t; return 0 === i ? 0 : i - 360 * Math.floor((i - -180) / 360) }, angleBetween: function(t, e, i, o) { return Math.atan2(o - e, i - t) }, angleBetweenY: function(t, e, i, o) { return Math.atan2(i - t, o - e) }, angleBetweenPoints: function(t, e) { return Math.atan2(e.y - t.y, e.x - t.x) }, angleBetweenPointsY: function(t, e) { return Math.atan2(e.x - t.x, e.y - t.y) }, reverseAngle: function(t) { return this.normalizeAngle(t + Math.PI, !0) }, normalizeAngle: function(t) { return (t %= 2 * Math.PI) >= 0 ? t : t + 2 * Math.PI }, maxAdd: function(t, e, i) { return Math.min(t + e, i) }, minSub: function(t, e, i) { return Math.max(t - e, i) }, wrap: function(t, e, i) { var o = i - e; if (o <= 0) return 0; var n = (t - e) % o; return n < 0 && (n += o), n + e }, wrapValue: function(t, e, i) { return t = Math.abs(t), e = Math.abs(e), i = Math.abs(i), (t + e) % i }, isOdd: function(t) { return !!(1 & t) }, isEven: function(t) { return !(1 & t) }, min: function() { if (1 === arguments.length && "object" == typeof arguments[0]) t = arguments[0];
                else var t = arguments; for (var e = 1, i = 0, o = t.length; e < o; e++) t[e] < t[i] && (i = e); return t[i] }, max: function() { if (1 === arguments.length && "object" == typeof arguments[0]) t = arguments[0];
                else var t = arguments; for (var e = 1, i = 0, o = t.length; e < o; e++) t[e] > t[i] && (i = e); return t[i] }, minProperty: function(t) { if (2 === arguments.length && "object" == typeof arguments[1]) e = arguments[1];
                else var e = arguments.slice(1); for (var i = 1, o = 0, n = e.length; i < n; i++) e[i][t] < e[o][t] && (o = i); return e[o][t] }, maxProperty: function(t) { if (2 === arguments.length && "object" == typeof arguments[1]) e = arguments[1];
                else var e = arguments.slice(1); for (var i = 1, o = 0, n = e.length; i < n; i++) e[i][t] > e[o][t] && (o = i); return e[o][t] }, wrapAngle: function(t, e) { return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180) }, linearInterpolation: function(t, e) { var i = t.length - 1,
                    o = i * e,
                    n = Math.floor(o); return e < 0 ? this.linear(t[0], t[1], o) : e > 1 ? this.linear(t[i], t[i - 1], i - o) : this.linear(t[n], t[n + 1 > i ? i : n + 1], o - n) }, bezierInterpolation: function(t, e) { for (var i = 0, o = t.length - 1, n = 0; n <= o; n++) i += Math.pow(1 - e, o - n) * Math.pow(e, n) * t[n] * this.bernstein(o, n); return i }, catmullRomInterpolation: function(t, e) { var i = t.length - 1,
                    o = i * e,
                    n = Math.floor(o); return t[0] === t[i] ? (e < 0 && (n = Math.floor(o = i * (1 + e))), this.catmullRom(t[(n - 1 + i) % i], t[n], t[(n + 1) % i], t[(n + 2) % i], o - n)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -o) - t[0]) : e > 1 ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], o - i) - t[i]) : this.catmullRom(t[n ? n - 1 : 0], t[n], t[i < n + 1 ? i : n + 1], t[i < n + 2 ? i : n + 2], o - n) }, linear: function(t, e, i) { return (e - t) * i + t }, bernstein: function(t, e) { return this.factorial(t) / this.factorial(e) / this.factorial(t - e) }, factorial: function(t) { if (0 === t) return 1; for (var e = t; --t;) e *= t; return e }, catmullRom: function(t, e, i, o, n) { var s = .5 * (i - t),
                    r = .5 * (o - e),
                    a = n * n; return (2 * e - 2 * i + s + r) * (n * a) + (-3 * e + 3 * i - 2 * s - r) * a + s * n + e }, difference: function(t, e) { return Math.abs(t - e) }, roundAwayFromZero: function(t) { return t > 0 ? Math.ceil(t) : Math.floor(t) }, sinCosGenerator: function(t, e, i, o) { void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === o && (o = 1); for (var n = e, s = i, r = o * Math.PI / t, a = [], h = [], l = 0; l < t; l++) n += (s -= n * r) * r, a[l] = s, h[l] = n; return { sin: h, cos: a, length: t } }, distance: function(t, e, i, o) { var n = t - i,
                    s = e - o; return Math.sqrt(n * n + s * s) }, distanceSq: function(t, e, i, o) { var n = t - i,
                    s = e - o; return n * n + s * s }, distancePow: function(t, e, i, o, n) { return void 0 === n && (n = 2), Math.sqrt(Math.pow(i - t, n) + Math.pow(o - e, n)) }, clamp: function(t, e, i) { return t < e ? e : i < t ? i : t }, clampBottom: function(t, e) { return t < e ? e : t }, within: function(t, e, i) { return Math.abs(t - e) <= i }, mapLinear: function(t, e, i, o, n) { return o + (t - e) * (n - o) / (i - e) }, smoothstep: function(t, e, i) { return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t) }, smootherstep: function(t, e, i) { return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10) }, sign: function(t) { return t < 0 ? -1 : t > 0 ? 1 : 0 }, percent: function(t, e, i) { return void 0 === i && (i = 0), t > e || i > e ? 1 : t < i || i > t ? 0 : (t - i) / e } }; var r = Math.PI / 180,
            a = 180 / Math.PI; return i.Math.degToRad = function(t) { return t * r }, i.Math.radToDeg = function(t) { return t * a }, i.RandomDataGenerator = function(t) { void 0 === t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof t ? this.state(t) : this.sow(t) }, i.RandomDataGenerator.prototype = { rnd: function() { var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c; return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2 }, sow: function(t) { if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t)
                    for (var e = 0; e < t.length && null != t[e]; e++) { var i = t[e];
                        this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0) } }, hash: function(t) { var e, i, o; for (o = 4022871197, t = t.toString(), i = 0; i < t.length; i++) e = .02519603282416938 * (o += t.charCodeAt(i)), e -= o = e >>> 0, o = (e *= o) >>> 0, o += 4294967296 * (e -= o); return 2.3283064365386963e-10 * (o >>> 0) }, integer: function() { return 4294967296 * this.rnd.apply(this) }, frac: function() { return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0) }, real: function() { return this.integer() + this.frac() }, integerInRange: function(t, e) { return Math.floor(this.realInRange(0, e - t + 1) + t) }, between: function(t, e) { return this.integerInRange(t, e) }, realInRange: function(t, e) { return this.frac() * (e - t) + t }, normal: function() { return 1 - 2 * this.frac() }, uuid: function() { var t = "",
                    e = ""; for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : "-"); return e }, pick: function(t) { return t[this.integerInRange(0, t.length - 1)] }, sign: function() { return this.pick([-1, 1]) }, weightedPick: function(t) { return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)] }, timestamp: function(t, e) { return this.realInRange(t || 9466848e5, e || 1577862e6) }, angle: function() { return this.integerInRange(-180, 180) }, state: function(t) { return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",") } }, i.RandomDataGenerator.prototype.constructor = i.RandomDataGenerator, i.QuadTree = function(t, e, i, o, n, s, r) { this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, o, n, s, r) }, i.QuadTree.prototype = { reset: function(t, e, i, o, n, s, r) { this.maxObjects = n || 10, this.maxLevels = s || 4, this.level = r || 0, this.bounds = { x: Math.round(t), y: Math.round(e), width: i, height: o, subWidth: Math.floor(i / 2), subHeight: Math.floor(o / 2), right: Math.round(t) + Math.floor(i / 2), bottom: Math.round(e) + Math.floor(o / 2) }, this.objects.length = 0, this.nodes.length = 0 }, populate: function(t) { t.forEach(this.populateHandler, this, !0) }, populateHandler: function(t) { t.body && t.exists && this.insert(t.body) }, split: function() { this.nodes[0] = new i.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new i.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new i.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new i.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1) }, insert: function(t) { var e, i = 0; if (null == this.nodes[0] || -1 === (e = this.getIndex(t))) { if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                        for (null == this.nodes[0] && this.split(); i < this.objects.length;) - 1 !== (e = this.getIndex(this.objects[i])) ? this.nodes[e].insert(this.objects.splice(i, 1)[0]) : i++ } else this.nodes[e].insert(t) }, getIndex: function(t) { var e = -1; return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e }, retrieve: function(t) { if (t instanceof i.Rectangle) var e = this.objects,
                    o = this.getIndex(t);
                else { if (!t.body) return this._empty; var e = this.objects,
                        o = this.getIndex(t.body) } return this.nodes[0] && (e = -1 !== o ? e.concat(this.nodes[o].retrieve(t)) : (e = (e = (e = e.concat(this.nodes[0].retrieve(t))).concat(this.nodes[1].retrieve(t))).concat(this.nodes[2].retrieve(t))).concat(this.nodes[3].retrieve(t))), e }, clear: function() { this.objects.length = 0; for (var t = this.nodes.length; t--;) this.nodes[t].clear(), this.nodes.splice(t, 1);
                this.nodes.length = 0 } }, i.QuadTree.prototype.constructor = i.QuadTree, i.Net = function(t) { this.game = t }, i.Net.prototype = { getHostName: function() { return window.location && window.location.hostname ? window.location.hostname : null }, checkDomainName: function(t) { return -1 !== window.location.hostname.indexOf(t) }, updateQueryString: function(t, e, i, o) { void 0 === i && (i = !1), void 0 !== o && "" !== o || (o = window.location.href); var n = "",
                    s = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi"); if (s.test(o)) n = void 0 !== e && null !== e ? o.replace(s, "$1" + t + "=" + e + "$2$3") : o.replace(s, "$1$3").replace(/(&|\?)$/, "");
                else if (void 0 !== e && null !== e) { var r = -1 !== o.indexOf("?") ? "&" : "?",
                        a = o.split("#");
                    o = a[0] + r + t + "=" + e, a[1] && (o += "#" + a[1]), n = o } else n = o; if (!i) return n;
                window.location.href = n }, getQueryString: function(t) { void 0 === t && (t = ""); var e = {},
                    i = location.search.substring(1).split("&"); for (var o in i) { var n = i[o].split("="); if (n.length > 1) { if (t && t === this.decodeURI(n[0])) return this.decodeURI(n[1]);
                        e[this.decodeURI(n[0])] = this.decodeURI(n[1]) } } return e }, decodeURI: function(t) { return decodeURIComponent(t.replace(/\+/g, " ")) } }, i.Net.prototype.constructor = i.Net, i.TweenManager = function(t) { this.game = t, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = { Power0: i.Easing.Power0, Power1: i.Easing.Power1, Power2: i.Easing.Power2, Power3: i.Easing.Power3, Power4: i.Easing.Power4, Linear: i.Easing.Linear.None, Quad: i.Easing.Quadratic.Out, Cubic: i.Easing.Cubic.Out, Quart: i.Easing.Quartic.Out, Quint: i.Easing.Quintic.Out, Sine: i.Easing.Sinusoidal.Out, Expo: i.Easing.Exponential.Out, Circ: i.Easing.Circular.Out, Elastic: i.Easing.Elastic.Out, Back: i.Easing.Back.Out, Bounce: i.Easing.Bounce.Out, "Quad.easeIn": i.Easing.Quadratic.In, "Cubic.easeIn": i.Easing.Cubic.In, "Quart.easeIn": i.Easing.Quartic.In, "Quint.easeIn": i.Easing.Quintic.In, "Sine.easeIn": i.Easing.Sinusoidal.In, "Expo.easeIn": i.Easing.Exponential.In, "Circ.easeIn": i.Easing.Circular.In, "Elastic.easeIn": i.Easing.Elastic.In, "Back.easeIn": i.Easing.Back.In, "Bounce.easeIn": i.Easing.Bounce.In, "Quad.easeOut": i.Easing.Quadratic.Out, "Cubic.easeOut": i.Easing.Cubic.Out, "Quart.easeOut": i.Easing.Quartic.Out, "Quint.easeOut": i.Easing.Quintic.Out, "Sine.easeOut": i.Easing.Sinusoidal.Out, "Expo.easeOut": i.Easing.Exponential.Out, "Circ.easeOut": i.Easing.Circular.Out, "Elastic.easeOut": i.Easing.Elastic.Out, "Back.easeOut": i.Easing.Back.Out, "Bounce.easeOut": i.Easing.Bounce.Out, "Quad.easeInOut": i.Easing.Quadratic.InOut, "Cubic.easeInOut": i.Easing.Cubic.InOut, "Quart.easeInOut": i.Easing.Quartic.InOut, "Quint.easeInOut": i.Easing.Quintic.InOut, "Sine.easeInOut": i.Easing.Sinusoidal.InOut, "Expo.easeInOut": i.Easing.Exponential.InOut, "Circ.easeInOut": i.Easing.Circular.InOut, "Elastic.easeInOut": i.Easing.Elastic.InOut, "Back.easeInOut": i.Easing.Back.InOut, "Bounce.easeInOut": i.Easing.Bounce.InOut }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this) }, i.TweenManager.prototype = { getAll: function() { return this._tweens }, removeAll: function() { for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
                this._add = [] }, removeFrom: function(t, e) { void 0 === e && (e = !0); if (Array.isArray(t))
                    for (o = 0, n = t.length; o < n; o++) this.removeFrom(t[o]);
                else if (t.type === i.GROUP && e)
                    for (var o = 0, n = t.children.length; o < n; o++) this.removeFrom(t.children[o]);
                else { for (o = 0, n = this._tweens.length; o < n; o++) t === this._tweens[o].target && this.remove(this._tweens[o]); for (o = 0, n = this._add.length; o < n; o++) t === this._add[o].target && this.remove(this._add[o]) } }, add: function(t) { t._manager = this, this._add.push(t) }, create: function(t) { return new i.Tween(t, this.game, this) }, remove: function(t) { var e = this._tweens.indexOf(t); - 1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0) }, update: function() { var t = this._add.length,
                    e = this._tweens.length; if (0 === e && 0 === t) return !1; for (var i = 0; i < e;) this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1), e--); return t > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0 }, isTweening: function(t) { return this._tweens.some(function(e) { return e.target === t }) }, _pauseAll: function() { for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._pause() }, _resumeAll: function() { for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._resume() }, pauseAll: function() { for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].pause() }, resumeAll: function() { for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].resume(!0) } }, i.TweenManager.prototype.constructor = i.TweenManager, i.Tween = function(t, e, o) { this.game = e, this.target = t, this.manager = o, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new i.Signal, this.onLoop = new i.Signal, this.onRepeat = new i.Signal, this.onChildComplete = new i.Signal, this.onComplete = new i.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = o.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1 }, i.Tween.prototype = { to: function(t, e, o, n, s, r, a) { return (void 0 === e || e <= 0) && (e = 1e3), void 0 !== o && null !== o || (o = i.Easing.Default), void 0 === n && (n = !1), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === a && (a = !1), "string" == typeof o && this.manager.easeMap[o] && (o = this.manager.easeMap[o]), this.isRunning ? this : (this.timeline.push(new i.TweenData(this).to(t, e, o, s, r, a)), n && this.start(), this) }, from: function(t, e, o, n, s, r, a) { return void 0 === e && (e = 1e3), void 0 !== o && null !== o || (o = i.Easing.Default), void 0 === n && (n = !1), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === a && (a = !1), "string" == typeof o && this.manager.easeMap[o] && (o = this.manager.easeMap[o]), this.isRunning ? this : (this.timeline.push(new i.TweenData(this).from(t, e, o, s, r, a)), n && this.start(), this) }, start: function(t) { if (void 0 === t && (t = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this; for (i = 0; i < this.timeline.length; i++)
                    for (var e in this.timeline[i].vEnd) this.properties[e] = this.target[e] || 0, Array.isArray(this.properties[e]) || (this.properties[e] *= 1); for (var i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues(); return this.manager.add(this), this.isRunning = !0, (t < 0 || t > this.timeline.length - 1) && (t = 0), this.current = t, this.timeline[this.current].start(), this }, stop: function(t) { return void 0 === t && (t = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this }, updateTweenData: function(t, e, i) { if (0 === this.timeline.length) return this; if (void 0 === i && (i = 0), -1 === i)
                    for (var o = 0; o < this.timeline.length; o++) this.timeline[o][t] = e;
                else this.timeline[i][t] = e; return this }, delay: function(t, e) { return this.updateTweenData("delay", t, e) }, repeat: function(t, e, i) { return void 0 === e && (e = 0), this.updateTweenData("repeatCounter", t, i), this.updateTweenData("repeatDelay", e, i) }, repeatDelay: function(t, e) { return this.updateTweenData("repeatDelay", t, e) }, yoyo: function(t, e, i) { return void 0 === e && (e = 0), this.updateTweenData("yoyo", t, i), this.updateTweenData("yoyoDelay", e, i) }, yoyoDelay: function(t, e) { return this.updateTweenData("yoyoDelay", t, e) }, easing: function(t, e) { return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]), this.updateTweenData("easingFunction", t, e) }, interpolation: function(t, e, o) { return void 0 === e && (e = i.Math), this.updateTweenData("interpolationFunction", t, o), this.updateTweenData("interpolationContext", e, o) }, repeatAll: function(t) { return void 0 === t && (t = 0), this.repeatCounter = t, this }, chain: function() { for (var t = arguments.length; t--;) t > 0 ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t]; return this }, loop: function(t) { return void 0 === t && (t = !0), this.repeatCounter = t ? -1 : 0, this }, onUpdateCallback: function(t, e) { return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this }, pause: function() { this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time }, _pause: function() { this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time) }, resume: function() { if (this.isPaused) { this.isPaused = !1, this._codePaused = !1; for (var t = 0; t < this.timeline.length; t++) this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime) } }, _resume: function() { this._codePaused || this.resume() }, update: function(t) { if (this.pendingDelete || !this.target) return !1; if (this.isPaused) return !0; var e = this.timeline[this.current].update(t); if (e === i.TweenData.PENDING) return !0; if (e === i.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning; if (e === i.TweenData.LOOPED) return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0; if (e === i.TweenData.COMPLETE) { var o = !1; return this.reverse ? --this.current < 0 && (this.current = this.timeline.length - 1, o = !0) : ++this.current === this.timeline.length && (this.current = 0, o = !0), o ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0) } }, generateData: function(t, e) { if (null === this.game || null === this.target) return null;
                void 0 === t && (t = 60), void 0 === e && (e = []); for (o = 0; o < this.timeline.length; o++)
                    for (var i in this.timeline[o].vEnd) this.properties[i] = this.target[i] || 0, Array.isArray(this.properties[i]) || (this.properties[i] *= 1); for (o = 0; o < this.timeline.length; o++) this.timeline[o].loadValues(); for (var o = 0; o < this.timeline.length; o++) e = e.concat(this.timeline[o].generateData(t)); return e } }, Object.defineProperty(i.Tween.prototype, "totalDuration", { get: function() { for (var t = 0, e = 0; e < this.timeline.length; e++) t += this.timeline[e].duration; return t } }), i.Tween.prototype.constructor = i.Tween, i.TweenData = function(t) { this.parent = t, this.game = t.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = i.Easing.Default, this.interpolationFunction = i.Math.linearInterpolation, this.interpolationContext = i.Math, this.isRunning = !1, this.isFrom = !1 }, i.TweenData.PENDING = 0, i.TweenData.RUNNING = 1, i.TweenData.LOOPED = 2, i.TweenData.COMPLETE = 3, i.TweenData.prototype = { to: function(t, e, i, o, n, s) { return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = o, this.repeatTotal = n, this.yoyo = s, this.isFrom = !1, this }, from: function(t, e, i, o, n, s) { return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = o, this.repeatTotal = n, this.yoyo = s, this.isFrom = !0, this }, start: function() { if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)
                    for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t], this.parent.target[t] = this.vStart[t]; return this.value = 0, this.yoyoCounter = 0, this.repeatCounter = this.repeatTotal, this }, loadValues: function() { for (var t in this.parent.properties) { if (this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) { if (0 === this.vEnd[t].length) continue;
                        0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t])) } void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t], 10)), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t], this.vStartCache[t] = this.vStart[t], this.vEndCache[t] = this.vEnd[t] } return this }, update: function(t) { if (this.isRunning) { if (t < this.startTime) return i.TweenData.RUNNING } else { if (!(t >= this.startTime)) return i.TweenData.PENDING;
                    this.isRunning = !0 } var e = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                this.parent.reverse ? (this.dt -= e * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += e * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent); for (var o in this.vEnd) { var n = this.vStart[o],
                        s = this.vEnd[o];
                    Array.isArray(s) ? this.parent.target[o] = this.interpolationFunction.call(this.interpolationContext, s, this.value) : this.parent.target[o] = n + (s - n) * this.value } return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : i.TweenData.RUNNING }, generateData: function(t) { this.parent.reverse ? this.dt = this.duration : this.dt = 0; var e = [],
                    i = !1,
                    o = 1 / t * 1e3;
                do { this.parent.reverse ? (this.dt -= o, this.dt = Math.max(this.dt, 0)) : (this.dt += o, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent); var n = {}; for (var s in this.vEnd) { var r = this.vStart[s],
                            a = this.vEnd[s];
                        Array.isArray(a) ? n[s] = this.interpolationFunction(a, this.value) : n[s] = r + (a - r) * this.value } e.push(n), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0) } while (!i); if (this.yoyo) { var h = e.slice();
                    h.reverse(), e = e.concat(h) } return e }, repeat: function() { if (this.yoyo) { if (this.inReverse && 0 === this.repeatCounter) { for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t]; return this.inReverse = !1, i.TweenData.COMPLETE } this.inReverse = !this.inReverse } else if (0 === this.repeatCounter) return i.TweenData.COMPLETE; if (this.inReverse)
                    for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t];
                else { for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                    this.repeatCounter > 0 && this.repeatCounter-- } return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, i.TweenData.LOOPED } }, i.TweenData.prototype.constructor = i.TweenData, i.Easing = { Linear: { None: function(t) { return t } }, Quadratic: { In: function(t) { return t * t }, Out: function(t) { return t * (2 - t) }, InOut: function(t) { return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1) } }, Cubic: { In: function(t) { return t * t * t }, Out: function(t) { return --t * t * t + 1 }, InOut: function(t) { return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2) } }, Quartic: { In: function(t) { return t * t * t * t }, Out: function(t) { return 1 - --t * t * t * t }, InOut: function(t) { return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2) } }, Quintic: { In: function(t) { return t * t * t * t * t }, Out: function(t) { return --t * t * t * t * t + 1 }, InOut: function(t) { return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2) } }, Sinusoidal: { In: function(t) { return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2) }, Out: function(t) { return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2) }, InOut: function(t) { return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t)) } }, Exponential: { In: function(t) { return 0 === t ? 0 : Math.pow(1024, t - 1) }, Out: function(t) { return 1 === t ? 1 : 1 - Math.pow(2, -10 * t) }, InOut: function(t) { return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1))) } }, Circular: { In: function(t) { return 1 - Math.sqrt(1 - t * t) }, Out: function(t) { return Math.sqrt(1 - --t * t) }, InOut: function(t) { return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) } }, Elastic: { In: function(t) { var e, i = .1; return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4)) }, Out: function(t) { var e, i = .1; return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1) }, InOut: function(t) { var e, i = .1; return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = .4 * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1) } }, Back: { In: function(t) { var e = 1.70158; return t * t * ((e + 1) * t - e) }, Out: function(t) { var e = 1.70158; return --t * t * ((e + 1) * t + e) + 1 }, InOut: function(t) { var e = 2.5949095; return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2) } }, Bounce: { In: function(t) { return 1 - i.Easing.Bounce.Out(1 - t) }, Out: function(t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, InOut: function(t) { return t < .5 ? .5 * i.Easing.Bounce.In(2 * t) : .5 * i.Easing.Bounce.Out(2 * t - 1) + .5 } } }, i.Easing.Default = i.Easing.Linear.None, i.Easing.Power0 = i.Easing.Linear.None, i.Easing.Power1 = i.Easing.Quadratic.Out, i.Easing.Power2 = i.Easing.Cubic.Out, i.Easing.Power3 = i.Easing.Quartic.Out, i.Easing.Power4 = i.Easing.Quintic.Out, i.Time = function(t) { this.game = t, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new i.Timer(this.game, !1), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = [] }, i.Time.prototype = { boot: function() { this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time }, add: function(t) { return this._timers.push(t), t }, create: function(t) { void 0 === t && (t = !0); var e = new i.Timer(this.game, t); return this._timers.push(e), e }, removeAll: function() { for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
                this._timers = [], this.events.removeAll() }, refresh: function() { var t = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - t }, update: function(t) { var e = this.time;
                this.time = Date.now(), this.elapsedMS = this.time - e, this.prevTime = this.now, this.now = t, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))), this.timeExpected = t + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers()) }, updateTimers: function() { for (var t = 0, e = this._timers.length; t < e;) this._timers[t].update(this.time) ? t++ : (this._timers.splice(t, 1), e--) }, updateAdvancedTiming: function() { this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0) }, gamePaused: function() { this._pauseStarted = Date.now(), this.events.pause(); for (var t = this._timers.length; t--;) this._timers[t]._pause() }, gameResumed: function() { this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume(); for (var t = this._timers.length; t--;) this._timers[t]._resume() }, totalElapsedSeconds: function() { return .001 * (this.time - this._started) }, elapsedSince: function(t) { return this.time - t }, elapsedSecondsSince: function(t) { return .001 * (this.time - t) }, reset: function() { this._started = this.time, this.removeAll() } }, Object.defineProperty(i.Time.prototype, "desiredFps", { get: function() { return this._desiredFps }, set: function(t) { this._desiredFps = t, this.physicsElapsed = 1 / t, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / t } }), i.Time.prototype.constructor = i.Time, i.Timer = function(t, e) { void 0 === e && (e = !0), this.game = t, this.running = !1, this.autoDestroy = e, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new i.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0 }, i.Timer.MINUTE = 6e4, i.Timer.SECOND = 1e3, i.Timer.HALF = 500, i.Timer.QUARTER = 250, i.Timer.prototype = { create: function(t, e, o, n, s, r) { var a = t = Math.round(t);
                0 === this._now ? a += this.game.time.time : a += this._now; var h = new i.TimerEvent(this, t, a, o, e, n, s, r); return this.events.push(h), this.order(), this.expired = !1, h }, add: function(t, e, i) { return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3)) }, repeat: function(t, e, i, o) { return this.create(t, !1, e, i, o, Array.prototype.slice.call(arguments, 4)) }, loop: function(t, e, i) { return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3)) }, start: function(t) { if (!this.running) { this._started = this.game.time.time + (t || 0), this.running = !0; for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started } }, stop: function(t) { this.running = !1, void 0 === t && (t = !0), t && (this.events.length = 0) }, remove: function(t) { for (var e = 0; e < this.events.length; e++)
                    if (this.events[e] === t) return this.events[e].pendingDelete = !0, !0; return !1 }, order: function() { this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick) }, sortHandler: function(t, e) { return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0 }, clearPendingEvents: function() { for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                this._len = this.events.length, this._i = 0 }, update: function(t) { if (this.paused) return !0; if (this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) { for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete;) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), !0 === this.events[this._i].loop ? (this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : this.events[this._i].repeatCount > 0 ? (this.events[this._i].repeatCount--, this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : (this._marked++, this.events[this._i].pendingDelete = !0, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)), this._i++;
                    this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this)) } return !this.expired || !this.autoDestroy }, pause: function() { this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0)) }, _pause: function() {!this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0) }, adjustEvents: function(t) { for (var e = 0; e < this.events.length; e++)
                    if (!this.events[e].pendingDelete) { var i = this.events[e].tick - t;
                        i < 0 && (i = 0), this.events[e].tick = this._now + i } var o = this.nextTick - t;
                this.nextTick = o < 0 ? this._now : this._now + o }, resume: function() { if (this.paused) { var t = this.game.time.time;
                    this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1 } }, _resume: function() { this._codePaused || this.resume() }, removeAll: function() { this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0 }, destroy: function() { this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, this._i = 0 } }, Object.defineProperty(i.Timer.prototype, "next", { get: function() { return this.nextTick } }), Object.defineProperty(i.Timer.prototype, "duration", { get: function() { return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0 } }), Object.defineProperty(i.Timer.prototype, "length", { get: function() { return this.events.length } }), Object.defineProperty(i.Timer.prototype, "ms", { get: function() { return this.running ? this._now - this._started - this._pauseTotal : 0 } }), Object.defineProperty(i.Timer.prototype, "seconds", { get: function() { return this.running ? .001 * this.ms : 0 } }), i.Timer.prototype.constructor = i.Timer, i.TimerEvent = function(t, e, i, o, n, s, r, a) { this.timer = t, this.delay = e, this.tick = i, this.repeatCount = o - 1, this.loop = n, this.callback = s, this.callbackContext = r, this.args = a, this.pendingDelete = !1 }, i.TimerEvent.prototype.constructor = i.TimerEvent, i.AnimationManager = function(t) { this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = [] }, i.AnimationManager.prototype = { loadFrameData: function(t, e) { if (void 0 === t) return !1; if (this.isLoaded)
                    for (var i in this._anims) this._anims[i].updateFrameData(t); return this._frameData = t, void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0 }, copyFrameData: function(t, e) { if (this._frameData = t.clone(), this.isLoaded)
                    for (var i in this._anims) this._anims[i].updateFrameData(this._frameData); return void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0 }, add: function(t, e, o, n, s) { return e = e || [], o = o || 60, void 0 === n && (n = !1), void 0 === s && (s = !(!e || "number" != typeof e[0])), this._outputFrames = [], this._frameData.getFrameIndexes(e, s, this._outputFrames), this._anims[t] = new i.Animation(this.game, this.sprite, t, this._frameData, this._outputFrames, o, n), this.currentAnim = this._anims[t], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[t] }, validateFrames: function(t, e) { void 0 === e && (e = !0); for (var i = 0; i < t.length; i++)
                    if (!0 === e) { if (t[i] > this._frameData.total) return !1 } else if (!1 === this._frameData.checkFrameName(t[i])) return !1; return !0 }, play: function(t, e, i, o) { if (this._anims[t]) return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, o)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, o)) }, stop: function(t, e) { void 0 === e && (e = !1), !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e) }, update: function() { return !(this.updateIfVisible && !this.sprite.visible) && (!(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame, !0)) }, next: function(t) { this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame) }, previous: function(t) { this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame) }, getAnimation: function(t) { return "string" == typeof t && this._anims[t] ? this._anims[t] : null }, refreshFrame: function() {}, destroy: function() { t = null; for (var t in this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null } }, i.AnimationManager.prototype.constructor = i.AnimationManager, Object.defineProperty(i.AnimationManager.prototype, "frameData", { get: function() { return this._frameData } }), Object.defineProperty(i.AnimationManager.prototype, "frameTotal", { get: function() { return this._frameData.total } }), Object.defineProperty(i.AnimationManager.prototype, "paused", { get: function() { return this.currentAnim.isPaused }, set: function(t) { this.currentAnim.paused = t } }), Object.defineProperty(i.AnimationManager.prototype, "name", { get: function() { if (this.currentAnim) return this.currentAnim.name } }), Object.defineProperty(i.AnimationManager.prototype, "frame", { get: function() { if (this.currentFrame) return this.currentFrame.index }, set: function(t) { "number" == typeof t && this._frameData && null !== this._frameData.getFrame(t) && (this.currentFrame = this._frameData.getFrame(t), this.currentFrame && this.sprite.setFrame(this.currentFrame)) } }), Object.defineProperty(i.AnimationManager.prototype, "frameName", { get: function() { if (this.currentFrame) return this.currentFrame.name }, set: function(t) { "string" == typeof t && this._frameData && null !== this._frameData.getFrameByName(t) && (this.currentFrame = this._frameData.getFrameByName(t), this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame))) } }), i.Animation = function(t, e, o, n, s, r, a) { void 0 === a && (a = !1), this.game = t, this._parent = e, this._frameData = n, this.name = o, this._frames = [], this._frames = this._frames.concat(s), this.delay = 1e3 / r, this.loop = a, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new i.Signal, this.onUpdate = null, this.onComplete = new i.Signal, this.onLoop = new i.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this) }, i.Animation.prototype = { play: function(t, e, i) { return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), void 0 !== i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this }, restart: function() { this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this) }, reverse: function() { return this.reversed = !this.reversed, this }, reverseOnce: function() { return this.onComplete.addOnce(this.reverse, this), this.reverse() }, setFrame: function(t, e) { var i; if (void 0 === e && (e = !1), "string" == typeof t)
                    for (o = 0; o < this._frames.length; o++) this._frameData.getFrame(this._frames[o]).name === t && (i = o);
                else if ("number" == typeof t)
                    if (e) i = t;
                    else
                        for (var o = 0; o < this._frames.length; o++) this._frames[o] === t && (i = o);
                i && (this._frameIndex = i - 1, this._timeNextFrame = this.game.time.time, this.update()) }, stop: function(t, e) { void 0 === t && (t = !1), void 0 === e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this)) }, onPause: function() { this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time) }, onResume: function() { this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff) }, update: function() { return !this.isPaused && (!!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0))) }, updateCurrentFrame: function(t, e) { if (void 0 === e && (e = !1), !this._frameData) return !1; var i = this.currentFrame.index; return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (e || !e && i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData) }, next: function(t) { void 0 === t && (t = 1); var e = this._frameIndex + t;
                e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0)) }, previous: function(t) { void 0 === t && (t = 1); var e = this._frameIndex - t;
                e < 0 && (this.loop ? e = this._frames.length + e : e++), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0)) }, updateFrameData: function(t) { this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null }, destroy: function() { this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose()) }, complete: function() { this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill() } }, i.Animation.prototype.constructor = i.Animation, Object.defineProperty(i.Animation.prototype, "paused", { get: function() { return this.isPaused }, set: function(t) { this.isPaused = t, t ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay) } }), Object.defineProperty(i.Animation.prototype, "reversed", { get: function() { return this.isReversed }, set: function(t) { this.isReversed = t } }), Object.defineProperty(i.Animation.prototype, "frameTotal", { get: function() { return this._frames.length } }), Object.defineProperty(i.Animation.prototype, "frame", { get: function() { return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex }, set: function(t) { this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame)) } }), Object.defineProperty(i.Animation.prototype, "speed", { get: function() { return 1e3 / this.delay }, set: function(t) { t > 0 && (this.delay = 1e3 / t) } }), Object.defineProperty(i.Animation.prototype, "enableUpdate", { get: function() { return null !== this.onUpdate }, set: function(t) { t && null === this.onUpdate ? this.onUpdate = new i.Signal : t || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null) } }), i.Animation.generateFrameNames = function(t, e, o, n, s) { void 0 === n && (n = ""); var r = [],
                a = ""; if (e < o)
                for (h = e; h <= o; h++) a = t + (a = "number" == typeof s ? i.Utils.pad(h.toString(), s, "0", 1) : h.toString()) + n, r.push(a);
            else
                for (var h = e; h >= o; h--) a = t + (a = "number" == typeof s ? i.Utils.pad(h.toString(), s, "0", 1) : h.toString()) + n, r.push(a); return r }, i.Frame = function(t, e, o, n, s, r) { this.index = t, this.x = e, this.y = o, this.width = n, this.height = s, this.name = r, this.centerX = Math.floor(n / 2), this.centerY = Math.floor(s / 2), this.distance = i.Math.distance(0, 0, n, s), this.rotated = !1, this.rotationDirection = "cw", this.trimmed = !1, this.sourceSizeW = n, this.sourceSizeH = s, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height }, i.Frame.prototype = { resize: function(t, e) { this.width = t, this.height = e, this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2), this.distance = i.Math.distance(0, 0, t, e), this.sourceSizeW = t, this.sourceSizeH = e, this.right = this.x + t, this.bottom = this.y + e }, setTrim: function(t, e, i, o, n, s, r) { this.trimmed = t, t && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = o, this.spriteSourceSizeY = n, this.spriteSourceSizeW = s, this.spriteSourceSizeH = r) }, clone: function() { var t = new i.Frame(this.index, this.x, this.y, this.width, this.height, this.name); for (var e in this) this.hasOwnProperty(e) && (t[e] = this[e]); return t }, getRect: function(t) { return void 0 === t ? t = new i.Rectangle(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t } }, i.Frame.prototype.constructor = i.Frame, i.FrameData = function() { this._frames = [], this._frameNames = [] }, i.FrameData.prototype = { addFrame: function(t) { return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t }, getFrame: function(t) { return t >= this._frames.length && (t = 0), this._frames[t] }, getFrameByName: function(t) { return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null }, checkFrameName: function(t) { return null != this._frameNames[t] }, clone: function() { for (var t = new i.FrameData, e = 0; e < this._frames.length; e++) t._frames.push(this._frames[e].clone()); for (var o in this._frameNames) this._frameNames.hasOwnProperty(o) && t._frameNames.push(this._frameNames[o]); return t }, getFrameRange: function(t, e, i) { void 0 === i && (i = []); for (var o = t; o <= e; o++) i.push(this._frames[o]); return i }, getFrames: function(t, e, i) { if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                    for (o = 0; o < this._frames.length; o++) i.push(this._frames[o]);
                else
                    for (var o = 0; o < t.length; o++) e ? i.push(this.getFrame(t[o])) : i.push(this.getFrameByName(t[o])); return i }, getFrameIndexes: function(t, e, i) { if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                    for (o = 0; o < this._frames.length; o++) i.push(this._frames[o].index);
                else
                    for (var o = 0; o < t.length; o++) e && this._frames[t[o]] ? i.push(this._frames[t[o]].index) : this.getFrameByName(t[o]) && i.push(this.getFrameByName(t[o]).index); return i }, destroy: function() { this._frames = null, this._frameNames = null } }, i.FrameData.prototype.constructor = i.FrameData, Object.defineProperty(i.FrameData.prototype, "total", { get: function() { return this._frames.length } }), i.AnimationParser = { spriteSheet: function(t, e, o, n, s, r, a) { var h = e; if ("string" == typeof e && (h = t.cache.getImage(e)), null === h) return null; var l = h.width,
                    c = h.height;
                o <= 0 && (o = Math.floor(-l / Math.min(-1, o))), n <= 0 && (n = Math.floor(-c / Math.min(-1, n))); var d = Math.floor((l - r) / (o + a)) * Math.floor((c - r) / (n + a)); if (-1 !== s && (d = s), 0 === l || 0 === c || l < o || c < n || 0 === d) return null; for (var u = new i.FrameData, p = r, m = r, f = 0; f < d; f++) u.addFrame(new i.Frame(f, p, m, o, n, "")), (p += o + a) + o > l && (p = r, m += n + a); return u }, JSONData: function(t, e) { if (e.frames) { for (var o, n = new i.FrameData, s = e.frames, r = 0; r < s.length; r++) o = n.addFrame(new i.Frame(r, s[r].frame.x, s[r].frame.y, s[r].frame.w, s[r].frame.h, s[r].filename)), s[r].trimmed && o.setTrim(s[r].trimmed, s[r].sourceSize.w, s[r].sourceSize.h, s[r].spriteSourceSize.x, s[r].spriteSourceSize.y, s[r].spriteSourceSize.w, s[r].spriteSourceSize.h); return n } }, JSONDataPyxel: function(t, e) { if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(t) { e[t] }), 1 === e.layers.length) { for (var o = new i.FrameData, n = e.tileheight, s = e.tilewidth, r = e.layers[0].tiles, a = 0; a < r.length; a++) o.addFrame(new i.Frame(a, r[a].x, r[a].y, s, n, "frame_" + a)).setTrim(!1); return o } }, JSONDataHash: function(t, e) { if (e.frames) { var o, n = new i.FrameData,
                        s = e.frames,
                        r = 0; for (var a in s) o = n.addFrame(new i.Frame(r, s[a].frame.x, s[a].frame.y, s[a].frame.w, s[a].frame.h, a)), s[a].trimmed && o.setTrim(s[a].trimmed, s[a].sourceSize.w, s[a].sourceSize.h, s[a].spriteSourceSize.x, s[a].spriteSourceSize.y, s[a].spriteSourceSize.w, s[a].spriteSourceSize.h), r++; return n } }, XMLData: function(t, e) { if (e.getElementsByTagName("TextureAtlas")) { for (var o, n, s, r, a, h, l, c, d, u, p, m = new i.FrameData, f = e.getElementsByTagName("SubTexture"), y = 0; y < f.length; y++) n = (s = f[y].attributes).name.value, r = parseInt(s.x.value, 10), a = parseInt(s.y.value, 10), h = parseInt(s.width.value, 10), l = parseInt(s.height.value, 10), c = null, d = null, s.frameX && (c = Math.abs(parseInt(s.frameX.value, 10)), d = Math.abs(parseInt(s.frameY.value, 10)), u = parseInt(s.frameWidth.value, 10), p = parseInt(s.frameHeight.value, 10)), o = m.addFrame(new i.Frame(y, r, a, h, l, n)), null === c && null === d || o.setTrim(!0, h, l, c, d, u, p); return m } } }, i.Cache = function(t) { this.game = t, this.autoResolveURL = !1, this._cache = { canvas: {}, image: {}, texture: {}, sound: {}, video: {}, text: {}, json: {}, xml: {}, physics: {}, tilemap: {}, binary: {}, bitmapData: {}, bitmapFont: {}, shader: {}, renderTexture: {} }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new i.Signal, this._cacheMap = [], this._cacheMap[i.Cache.CANVAS] = this._cache.canvas, this._cacheMap[i.Cache.IMAGE] = this._cache.image, this._cacheMap[i.Cache.TEXTURE] = this._cache.texture, this._cacheMap[i.Cache.SOUND] = this._cache.sound, this._cacheMap[i.Cache.TEXT] = this._cache.text, this._cacheMap[i.Cache.PHYSICS] = this._cache.physics, this._cacheMap[i.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[i.Cache.BINARY] = this._cache.binary, this._cacheMap[i.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[i.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[i.Cache.JSON] = this._cache.json, this._cacheMap[i.Cache.XML] = this._cache.xml, this._cacheMap[i.Cache.VIDEO] = this._cache.video, this._cacheMap[i.Cache.SHADER] = this._cache.shader, this._cacheMap[i.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this.addDefaultImage(), this.addMissingImage() }, i.Cache.CANVAS = 1, i.Cache.IMAGE = 2, i.Cache.TEXTURE = 3, i.Cache.SOUND = 4, i.Cache.TEXT = 5, i.Cache.PHYSICS = 6, i.Cache.TILEMAP = 7, i.Cache.BINARY = 8, i.Cache.BITMAPDATA = 9, i.Cache.BITMAPFONT = 10, i.Cache.JSON = 11, i.Cache.XML = 12, i.Cache.VIDEO = 13, i.Cache.SHADER = 14, i.Cache.RENDER_TEXTURE = 15, i.Cache.DEFAULT = null, i.Cache.MISSING = null, i.Cache.prototype = { addCanvas: function(t, e, i) { void 0 === i && (i = e.getContext("2d")), this._cache.canvas[t] = { canvas: e, context: i } }, addImage: function(t, e, o) { this.checkImageKey(t) && this.removeImage(t); var n = { key: t, url: e, data: o, base: new PIXI.BaseTexture(o), frame: new i.Frame(0, 0, 0, o.width, o.height, t), frameData: new i.FrameData }; return n.frameData.addFrame(new i.Frame(0, 0, 0, o.width, o.height, e)), this._cache.image[t] = n, this._resolveURL(e, n), "__default" === t ? i.Cache.DEFAULT = new PIXI.Texture(n.base) : "__missing" === t && (i.Cache.MISSING = new PIXI.Texture(n.base)), n }, addDefaultImage: function() { var t = new Image;
                t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg=="; var e = this.addImage("__default", null, t);
                e.base.skipRender = !0, i.Cache.DEFAULT = new PIXI.Texture(e.base) }, addMissingImage: function() { var t = new Image;
                t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg=="; var e = this.addImage("__missing", null, t);
                i.Cache.MISSING = new PIXI.Texture(e.base) }, addSound: function(t, e, i, o, n) { void 0 === o && (o = !0, n = !1), void 0 === n && (o = !1, n = !0); var s = !1;
                n && (s = !0), this._cache.sound[t] = { url: e, data: i, isDecoding: !1, decoded: s, webAudio: o, audioTag: n, locked: this.game.sound.touchLocked }, this._resolveURL(e, this._cache.sound[t]) }, addText: function(t, e, i) { this._cache.text[t] = { url: e, data: i }, this._resolveURL(e, this._cache.text[t]) }, addPhysicsData: function(t, e, i, o) { this._cache.physics[t] = { url: e, data: i, format: o }, this._resolveURL(e, this._cache.physics[t]) }, addTilemap: function(t, e, i, o) { this._cache.tilemap[t] = { url: e, data: i, format: o }, this._resolveURL(e, this._cache.tilemap[t]) }, addBinary: function(t, e) { this._cache.binary[t] = e }, addBitmapData: function(t, e, o) { return e.key = t, void 0 === o && (o = new i.FrameData).addFrame(e.textureFrame), this._cache.bitmapData[t] = { data: e, frameData: o }, e }, addBitmapFont: function(t, e, o, n, s, r, a) { var h = { url: e, data: o, font: null, base: new PIXI.BaseTexture(o) };
                void 0 === r && (r = 0), void 0 === a && (a = 0), h.font = "json" === s ? i.LoaderParser.jsonBitmapFont(n, h.base, r, a) : i.LoaderParser.xmlBitmapFont(n, h.base, r, a), this._cache.bitmapFont[t] = h, this._resolveURL(e, h) }, addJSON: function(t, e, i) { this._cache.json[t] = { url: e, data: i }, this._resolveURL(e, this._cache.json[t]) }, addXML: function(t, e, i) { this._cache.xml[t] = { url: e, data: i }, this._resolveURL(e, this._cache.xml[t]) }, addVideo: function(t, e, i, o) { this._cache.video[t] = { url: e, data: i, isBlob: o, locked: !0 }, this._resolveURL(e, this._cache.video[t]) }, addShader: function(t, e, i) { this._cache.shader[t] = { url: e, data: i }, this._resolveURL(e, this._cache.shader[t]) }, addRenderTexture: function(t, e) { this._cache.renderTexture[t] = { texture: e, frame: new i.Frame(0, 0, 0, e.width, e.height, "", "") } }, addSpriteSheet: function(t, e, o, n, s, r, a, h) { void 0 === r && (r = -1), void 0 === a && (a = 0), void 0 === h && (h = 0); var l = { key: t, url: e, data: o, frameWidth: n, frameHeight: s, margin: a, spacing: h, base: new PIXI.BaseTexture(o), frameData: i.AnimationParser.spriteSheet(this.game, o, n, s, r, a, h) };
                this._cache.image[t] = l, this._resolveURL(e, l) }, addTextureAtlas: function(t, e, o, n, s) { var r = { key: t, url: e, data: o, base: new PIXI.BaseTexture(o) };
                s === i.Loader.TEXTURE_ATLAS_XML_STARLING ? r.frameData = i.AnimationParser.XMLData(this.game, n, t) : s === i.Loader.TEXTURE_ATLAS_JSON_PYXEL ? r.frameData = i.AnimationParser.JSONDataPyxel(this.game, n, t) : Array.isArray(n.frames) ? r.frameData = i.AnimationParser.JSONData(this.game, n, t) : r.frameData = i.AnimationParser.JSONDataHash(this.game, n, t), this._cache.image[t] = r, this._resolveURL(e, r) }, reloadSound: function(t) { var e = this,
                    i = this.getSound(t);
                i && (i.data.src = i.url, i.data.addEventListener("canplaythrough", function() { return e.reloadSoundComplete(t) }, !1), i.data.load()) }, reloadSoundComplete: function(t) { var e = this.getSound(t);
                e && (e.locked = !1, this.onSoundUnlock.dispatch(t)) }, updateSound: function(t, e, i) { var o = this.getSound(t);
                o && (o[e] = i) }, decodedSound: function(t, e) { var i = this.getSound(t);
                i.data = e, i.decoded = !0, i.isDecoding = !1 }, isSoundDecoded: function(t) { var e = this.getItem(t, i.Cache.SOUND, "isSoundDecoded"); if (e) return e.decoded }, isSoundReady: function(t) { var e = this.getItem(t, i.Cache.SOUND, "isSoundDecoded"); if (e) return e.decoded && !this.game.sound.touchLocked }, checkKey: function(t, e) { return !!this._cacheMap[t][e] }, checkURL: function(t) { return !!this._urlMap[this._resolveURL(t)] }, checkCanvasKey: function(t) { return this.checkKey(i.Cache.CANVAS, t) }, checkImageKey: function(t) { return this.checkKey(i.Cache.IMAGE, t) }, checkTextureKey: function(t) { return this.checkKey(i.Cache.TEXTURE, t) }, checkSoundKey: function(t) { return this.checkKey(i.Cache.SOUND, t) }, checkTextKey: function(t) { return this.checkKey(i.Cache.TEXT, t) }, checkPhysicsKey: function(t) { return this.checkKey(i.Cache.PHYSICS, t) }, checkTilemapKey: function(t) { return this.checkKey(i.Cache.TILEMAP, t) }, checkBinaryKey: function(t) { return this.checkKey(i.Cache.BINARY, t) }, checkBitmapDataKey: function(t) { return this.checkKey(i.Cache.BITMAPDATA, t) }, checkBitmapFontKey: function(t) { return this.checkKey(i.Cache.BITMAPFONT, t) }, checkJSONKey: function(t) { return this.checkKey(i.Cache.JSON, t) }, checkXMLKey: function(t) { return this.checkKey(i.Cache.XML, t) }, checkVideoKey: function(t) { return this.checkKey(i.Cache.VIDEO, t) }, checkShaderKey: function(t) { return this.checkKey(i.Cache.SHADER, t) }, checkRenderTextureKey: function(t) { return this.checkKey(i.Cache.RENDER_TEXTURE, t) }, getItem: function(t, e, i, o) { return this.checkKey(e, t) ? void 0 === o ? this._cacheMap[e][t] : this._cacheMap[e][t][o] : null }, getCanvas: function(t) { return this.getItem(t, i.Cache.CANVAS, "getCanvas", "canvas") }, getImage: function(t, e) { void 0 !== t && null !== t || (t = "__default"), void 0 === e && (e = !1); var o = this.getItem(t, i.Cache.IMAGE, "getImage"); return null === o && (o = this.getItem("__missing", i.Cache.IMAGE, "getImage")), e ? o : o.data }, getTextureFrame: function(t) { return this.getItem(t, i.Cache.TEXTURE, "getTextureFrame", "frame") }, getSound: function(t) { return this.getItem(t, i.Cache.SOUND, "getSound") }, getSoundData: function(t) { return this.getItem(t, i.Cache.SOUND, "getSoundData", "data") }, getText: function(t) { return this.getItem(t, i.Cache.TEXT, "getText", "data") }, getPhysicsData: function(t, e, o) { var n = this.getItem(t, i.Cache.PHYSICS, "getPhysicsData", "data"); if (null === n || void 0 === e || null === e) return n; if (n[e]) { var s = n[e]; if (!s || !o) return s; for (var r in s)
                        if ((r = s[r]).fixtureKey === o) return r } return null }, getTilemapData: function(t) { return this.getItem(t, i.Cache.TILEMAP, "getTilemapData") }, getBinary: function(t) { return this.getItem(t, i.Cache.BINARY, "getBinary") }, getBitmapData: function(t) { return this.getItem(t, i.Cache.BITMAPDATA, "getBitmapData", "data") }, getBitmapFont: function(t) { return this.getItem(t, i.Cache.BITMAPFONT, "getBitmapFont") }, getJSON: function(t, e) { var o = this.getItem(t, i.Cache.JSON, "getJSON", "data"); return o ? e ? i.Utils.extend(!0, Array.isArray(o) ? [] : {}, o) : o : null }, getXML: function(t) { return this.getItem(t, i.Cache.XML, "getXML", "data") }, getVideo: function(t) { return this.getItem(t, i.Cache.VIDEO, "getVideo") }, getShader: function(t) { return this.getItem(t, i.Cache.SHADER, "getShader", "data") }, getRenderTexture: function(t) { return this.getItem(t, i.Cache.RENDER_TEXTURE, "getRenderTexture") }, getBaseTexture: function(t, e) { return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getBaseTexture", "base") }, getFrame: function(t, e) { return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getFrame", "frame") }, getFrameCount: function(t, e) { var i = this.getFrameData(t, e); return i ? i.total : 0 }, getFrameData: function(t, e) { return void 0 === e && (e = i.Cache.IMAGE), this.getItem(t, e, "getFrameData", "frameData") }, hasFrameData: function(t, e) { return void 0 === e && (e = i.Cache.IMAGE), null !== this.getItem(t, e, "", "frameData") }, updateFrameData: function(t, e, o) { void 0 === o && (o = i.Cache.IMAGE), this._cacheMap[o][t] && (this._cacheMap[o][t].frameData = e) }, getFrameByIndex: function(t, e, i) { var o = this.getFrameData(t, i); return o ? o.getFrame(e) : null }, getFrameByName: function(t, e, i) { var o = this.getFrameData(t, i); return o ? o.getFrameByName(e) : null }, getURL: function(t) { return (t = this._resolveURL(t)) ? this._urlMap[t] : null }, getKeys: function(t) { void 0 === t && (t = i.Cache.IMAGE); var e = []; if (this._cacheMap[t])
                    for (var o in this._cacheMap[t]) "__default" !== o && "__missing" !== o && e.push(o); return e }, removeCanvas: function(t) { delete this._cache.canvas[t] }, removeImage: function(t, e) { void 0 === e && (e = !0); var i = this.getImage(t, !0);
                e && i.base && i.base.destroy(), delete this._cache.image[t] }, removeSound: function(t) { delete this._cache.sound[t] }, removeText: function(t) { delete this._cache.text[t] }, removePhysics: function(t) { delete this._cache.physics[t] }, removeTilemap: function(t) { delete this._cache.tilemap[t] }, removeBinary: function(t) { delete this._cache.binary[t] }, removeBitmapData: function(t) { delete this._cache.bitmapData[t] }, removeBitmapFont: function(t) { delete this._cache.bitmapFont[t] }, removeJSON: function(t) { delete this._cache.json[t] }, removeXML: function(t) { delete this._cache.xml[t] }, removeVideo: function(t) { delete this._cache.video[t] }, removeShader: function(t) { delete this._cache.shader[t] }, removeRenderTexture: function(t) { delete this._cache.renderTexture[t] }, removeSpriteSheet: function(t) { delete this._cache.spriteSheet[t] }, removeTextureAtlas: function(t) { delete this._cache.atlas[t] }, clearGLTextures: function() { for (var t in this._cache.image) this._cache.image[t].base._glTextures = [] }, _resolveURL: function(t, e) { return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null }, destroy: function() { for (var t = 0; t < this._cacheMap.length; t++) { var e = this._cacheMap[t]; for (var i in e) "__default" !== i && "__missing" !== i && (e[i].destroy && e[i].destroy(), delete e[i]) } this._urlMap = null, this._urlResolver = null, this._urlTemp = null } }, i.Cache.prototype.constructor = i.Cache, i.Loader = function(t) { this.game = t, this.cache = t.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = { requestedWith: !1, json: "application/json", xml: "application/xml" }, this.onLoadStart = new i.Signal, this.onLoadComplete = new i.Signal, this.onPackComplete = new i.Signal, this.onFileStart = new i.Signal, this.onFileComplete = new i.Signal, this.onFileError = new i.Signal, this.useXDomainRequest = !1, this._warnedAboutXDomainRequest = !1, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0 }, i.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, i.Loader.TEXTURE_ATLAS_JSON_HASH = 1, i.Loader.TEXTURE_ATLAS_XML_STARLING = 2, i.Loader.PHYSICS_LIME_CORONA_JSON = 3, i.Loader.PHYSICS_PHASER_JSON = 4, i.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, i.Loader.prototype = { setPreloadSprite: function(t, e) { e = e || 0, this.preloadSprite = { sprite: t, direction: e, width: t.width, height: t.height, rect: null }, this.preloadSprite.rect = 0 === e ? new i.Rectangle(0, 0, 1, t.height) : new i.Rectangle(0, 0, t.width, 1), t.crop(this.preloadSprite.rect), t.visible = !0 }, resize: function() { this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height) }, checkKeyExists: function(t, e) { return this.getAssetIndex(t, e) > -1 }, getAssetIndex: function(t, e) { for (var i = -1, o = 0; o < this._fileList.length; o++) { var n = this._fileList[o]; if (n.type === t && n.key === e && (i = o, !n.loaded && !n.loading)) break } return i }, getAsset: function(t, e) { var i = this.getAssetIndex(t, e); return i > -1 && { index: i, file: this._fileList[i] } }, reset: function(t, e) { void 0 === e && (e = !1), this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll())) }, addToFileList: function(t, e, i, o, n, s) { if (void 0 === n && (n = !1), void 0 === e || "" === e) return this; if (void 0 === i || null === i) { if (!s) return this;
                    i = e + s } var r = { type: t, key: e, path: this.path, url: i, syncPoint: this._withSyncPointDepth > 0, data: null, loading: !1, loaded: !1, error: !1 }; if (o)
                    for (var a in o) r[a] = o[a]; var h = this.getAssetIndex(t, e); if (n && h > -1) { var l = this._fileList[h];
                    l.loading || l.loaded ? (this._fileList.push(r), this._totalFileCount++) : this._fileList[h] = r } else -1 === h && (this._fileList.push(r), this._totalFileCount++); return this }, replaceInFileList: function(t, e, i, o) { return this.addToFileList(t, e, i, o, !0) }, pack: function(t, e, i, o) { if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === o && (o = null), !e && !i) return this; var n = { type: "packfile", key: t, url: e, path: this.path, syncPoint: !0, data: null, loading: !1, loaded: !1, error: !1, callbackContext: o };
                i && ("string" == typeof i && (i = JSON.parse(i)), n.data = i || {}, n.loaded = !0); for (var s = 0; s < this._fileList.length + 1; s++) { var r = this._fileList[s]; if (!r || !r.loaded && !r.loading && "packfile" !== r.type) { this._fileList.splice(s, 0, n), this._totalPackCount++; break } } return this }, image: function(t, e, i) { return this.addToFileList("image", t, e, void 0, i, ".png") }, images: function(t, e) { if (Array.isArray(e))
                    for (i = 0; i < t.length; i++) this.image(t[i], e[i]);
                else
                    for (var i = 0; i < t.length; i++) this.image(t[i]); return this }, text: function(t, e, i) { return this.addToFileList("text", t, e, void 0, i, ".txt") }, json: function(t, e, i) { return this.addToFileList("json", t, e, void 0, i, ".json") }, shader: function(t, e, i) { return this.addToFileList("shader", t, e, void 0, i, ".frag") }, xml: function(t, e, i) { return this.addToFileList("xml", t, e, void 0, i, ".xml") }, script: function(t, e, i, o) { return void 0 === i && (i = !1), !1 !== i && void 0 === o && (o = this), this.addToFileList("script", t, e, { syncPoint: !0, callback: i, callbackContext: o }, !1, ".js") }, binary: function(t, e, i, o) { return void 0 === i && (i = !1), !1 !== i && void 0 === o && (o = i), this.addToFileList("binary", t, e, { callback: i, callbackContext: o }, !1, ".bin") }, spritesheet: function(t, e, i, o, n, s, r) { return void 0 === n && (n = -1), void 0 === s && (s = 0), void 0 === r && (r = 0), this.addToFileList("spritesheet", t, e, { frameWidth: i, frameHeight: o, frameMax: n, margin: s, spacing: r }, !1, ".png") }, audio: function(t, e, i) { return this.game.sound.noAudio ? this : (void 0 === i && (i = !0), "string" == typeof e && (e = [e]), this.addToFileList("audio", t, e, { buffer: null, autoDecode: i })) }, audioSprite: function(t, e, i, o, n) { return this.game.sound.noAudio ? this : (void 0 === i && (i = null), void 0 === o && (o = null), void 0 === n && (n = !0), this.audio(t, e, n), i ? this.json(t + "-audioatlas", i) : o && ("string" == typeof o && (o = JSON.parse(o)), this.cache.addJSON(t + "-audioatlas", "", o)), this) }, audiosprite: function(t, e, i, o, n) { return this.audioSprite(t, e, i, o, n) }, video: function(t, e, i, o) { return void 0 === i && (i = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === o && (o = !1), "string" == typeof e && (e = [e]), this.addToFileList("video", t, e, { buffer: null, asBlob: o, loadEvent: i }) }, tilemap: function(t, e, o, n) { if (void 0 === e && (e = null), void 0 === o && (o = null), void 0 === n && (n = i.Tilemap.CSV), e || o || (e = n === i.Tilemap.CSV ? t + ".csv" : t + ".json"), o) { switch (n) {
                        case i.Tilemap.CSV:
                            break;
                        case i.Tilemap.TILED_JSON:
                            "string" == typeof o && (o = JSON.parse(o)) } this.cache.addTilemap(t, null, o, n) } else this.addToFileList("tilemap", t, e, { format: n }); return this }, physics: function(t, e, o, n) { return void 0 === e && (e = null), void 0 === o && (o = null), void 0 === n && (n = i.Physics.LIME_CORONA_JSON), e || o || (e = t + ".json"), o ? ("string" == typeof o && (o = JSON.parse(o)), this.cache.addPhysicsData(t, null, o, n)) : this.addToFileList("physics", t, e, { format: n }), this }, bitmapFont: function(t, e, i, o, n, s) { if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === i && (i = null), void 0 === o && (o = null), null === i && null === o && (i = t + ".xml"), void 0 === n && (n = 0), void 0 === s && (s = 0), i) this.addToFileList("bitmapfont", t, e, { atlasURL: i, xSpacing: n, ySpacing: s });
                else if ("string" == typeof o) { var r, a; try { r = JSON.parse(o) } catch (t) { a = this.parseXml(o) } if (!a && !r) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                    this.addToFileList("bitmapfont", t, e, { atlasURL: null, atlasData: r || a, atlasType: r ? "json" : "xml", xSpacing: n, ySpacing: s }) } return this }, atlasJSONArray: function(t, e, o, n) { return this.atlas(t, e, o, n, i.Loader.TEXTURE_ATLAS_JSON_ARRAY) }, atlasJSONHash: function(t, e, o, n) { return this.atlas(t, e, o, n, i.Loader.TEXTURE_ATLAS_JSON_HASH) }, atlasXML: function(t, e, o, n) { return void 0 === o && (o = null), void 0 === n && (n = null), o || n || (o = t + ".xml"), this.atlas(t, e, o, n, i.Loader.TEXTURE_ATLAS_XML_STARLING) }, atlas: function(t, e, o, n, s) { if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === o && (o = null), void 0 === n && (n = null), void 0 === s && (s = i.Loader.TEXTURE_ATLAS_JSON_ARRAY), o || n || (o = s === i.Loader.TEXTURE_ATLAS_XML_STARLING ? t + ".xml" : t + ".json"), o) this.addToFileList("textureatlas", t, e, { atlasURL: o, format: s });
                else { switch (s) {
                        case i.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                            "string" == typeof n && (n = JSON.parse(n)); break;
                        case i.Loader.TEXTURE_ATLAS_XML_STARLING:
                            if ("string" == typeof n) { var r = this.parseXml(n); if (!r) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                n = r } } this.addToFileList("textureatlas", t, e, { atlasURL: null, atlasData: n, format: s }) } return this }, withSyncPoint: function(t, e) { this._withSyncPointDepth++; try { t.call(e || this, this) } finally { this._withSyncPointDepth-- } return this }, addSyncPoint: function(t, e) { var i = this.getAsset(t, e); return i && (i.file.syncPoint = !0), this }, removeFile: function(t, e) { var i = this.getAsset(t, e);
                i && (i.loaded || i.loading || this._fileList.splice(i.index, 1)) }, removeAll: function() { this._fileList.length = 0, this._flightQueue.length = 0 }, start: function() { this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue()) }, processLoadQueue: function() { if (this.isLoading) { for (o = 0; o < this._flightQueue.length; o++)((n = this._flightQueue[o]).loaded || n.error) && (this._flightQueue.splice(o, 1), o--, n.loading = !1, n.requestUrl = null, n.requestObject = null, n.error && this.onFileError.dispatch(n.key, n), "packfile" !== n.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, n.key, !n.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === n.type && n.error && (this._loadedPackCount++, this.onPackComplete.dispatch(n.key, !n.error, this._loadedPackCount, this._totalPackCount))); for (var t = !1, e = this.enableParallel ? i.Math.clamp(this.maxParallelDownloads, 1, 12) : 1, o = this._processingHead; o < this._fileList.length; o++) { var n = this._fileList[o]; if ("packfile" === n.type && !n.error && n.loaded && o === this._processingHead && (this.processPack(n), this._loadedPackCount++, this.onPackComplete.dispatch(n.key, !n.error, this._loadedPackCount, this._totalPackCount)), n.loaded || n.error ? o === this._processingHead && (this._processingHead = o + 1) : !n.loading && this._flightQueue.length < e && ("packfile" !== n.type || n.data ? t || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(n), n.loading = !0, this.onFileStart.dispatch(this.progress, n.key, n.url), this.loadFile(n)) : (this._flightQueue.push(n), n.loading = !0, this.loadFile(n))), !n.loaded && n.syncPoint && (t = !0), this._flightQueue.length >= e || t && this._loadedPackCount === this._totalPackCount) break } if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
                    else if (!this._flightQueue.length) { var s = this;
                        setTimeout(function() { s.finishedLoading(!0) }, 2e3) } } else this.finishedLoading(!0) }, finishedLoading: function(t) { this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.onLoadComplete.dispatch(), this.game.state.loadComplete(), this.reset()) }, asyncComplete: function(t, e) { void 0 === e && (e = ""), t.loaded = !0, t.error = !!e, e && (t.errorMessage = e), this.processLoadQueue() }, processPack: function(t) { var e = t.data[t.key]; if (e)
                    for (var o = 0; o < e.length; o++) { var n = e[o]; switch (n.type) {
                            case "image":
                                this.image(n.key, n.url, n.overwrite); break;
                            case "text":
                                this.text(n.key, n.url, n.overwrite); break;
                            case "json":
                                this.json(n.key, n.url, n.overwrite); break;
                            case "xml":
                                this.xml(n.key, n.url, n.overwrite); break;
                            case "script":
                                this.script(n.key, n.url, n.callback, t.callbackContext || this); break;
                            case "binary":
                                this.binary(n.key, n.url, n.callback, t.callbackContext || this); break;
                            case "spritesheet":
                                this.spritesheet(n.key, n.url, n.frameWidth, n.frameHeight, n.frameMax, n.margin, n.spacing); break;
                            case "video":
                                this.video(n.key, n.urls); break;
                            case "audio":
                                this.audio(n.key, n.urls, n.autoDecode); break;
                            case "audiosprite":
                                this.audiosprite(n.key, n.urls, n.jsonURL, n.jsonData, n.autoDecode); break;
                            case "tilemap":
                                this.tilemap(n.key, n.url, n.data, i.Tilemap[n.format]); break;
                            case "physics":
                                this.physics(n.key, n.url, n.data, i.Loader[n.format]); break;
                            case "bitmapFont":
                                this.bitmapFont(n.key, n.textureURL, n.atlasURL, n.atlasData, n.xSpacing, n.ySpacing); break;
                            case "atlasJSONArray":
                                this.atlasJSONArray(n.key, n.textureURL, n.atlasURL, n.atlasData); break;
                            case "atlasJSONHash":
                                this.atlasJSONHash(n.key, n.textureURL, n.atlasURL, n.atlasData); break;
                            case "atlasXML":
                                this.atlasXML(n.key, n.textureURL, n.atlasURL, n.atlasData); break;
                            case "atlas":
                                this.atlas(n.key, n.textureURL, n.atlasURL, n.atlasData, i.Loader[n.format]); break;
                            case "shader":
                                this.shader(n.key, n.url, n.overwrite) } } }, transformUrl: function(t, e) { return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t) }, loadFile: function(t) { switch (t.type) {
                    case "packfile":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete); break;
                    case "image":
                    case "spritesheet":
                    case "textureatlas":
                    case "bitmapfont":
                        this.loadImageTag(t); break;
                    case "audio":
                        t.url = this.getAudioURL(t.url), t.url ? this.game.sound.usingWebAudio ? this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(t) : this.fileError(t, null, "No supported audio URL specified or device does not have audio playback support"); break;
                    case "video":
                        t.url = this.getVideoURL(t.url), t.url ? t.asBlob ? this.xhrLoad(t, this.transformUrl(t.url, t), "blob", this.fileComplete) : this.loadVideoTag(t) : this.fileError(t, null, "No supported video URL specified or device does not have video playback support"); break;
                    case "json":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete); break;
                    case "xml":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.xmlLoadComplete); break;
                    case "tilemap":
                        t.format === i.Tilemap.TILED_JSON ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete) : t.format === i.Tilemap.CSV ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.csvLoadComplete) : this.asyncComplete(t, "invalid Tilemap format: " + t.format); break;
                    case "text":
                    case "script":
                    case "shader":
                    case "physics":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete); break;
                    case "binary":
                        this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete) } }, loadImageTag: function(t) { var e = this;
                t.data = new Image, t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function() { t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t)) }, t.data.onerror = function() { t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t)) }, t.data.src = this.transformUrl(t.url, t), t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t)) }, loadVideoTag: function(t) { var e = this;
                t.data = document.createElement("video"), t.data.name = t.key, t.data.controls = !1, t.data.autoplay = !1; var o = function() { t.data.removeEventListener(t.loadEvent, o, !1), t.data.onerror = null, t.data.canplay = !0, i.GAMES[e.game.id].load.fileComplete(t) };
                t.data.onerror = function() { t.data.removeEventListener(t.loadEvent, o, !1), t.data.onerror = null, t.data.canplay = !1, e.fileError(t) }, t.data.addEventListener(t.loadEvent, o, !1), t.data.src = this.transformUrl(t.url, t), t.data.load() }, loadAudioTag: function(t) { var e = this; if (this.game.sound.touchLocked) t.data = new Audio, t.data.name = t.key, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), this.fileComplete(t);
                else { t.data = new Audio, t.data.name = t.key; var i = function() { t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileComplete(t) };
                    t.data.onerror = function() { t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileError(t) }, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), t.data.addEventListener("canplaythrough", i, !1), t.data.load() } }, xhrLoad: function(t, e, i, o, n) { if (this.useXDomainRequest && window.XDomainRequest) this.xhrLoadWithXDR(t, e, i, o, n);
                else { var s = new XMLHttpRequest;
                    s.open("GET", e, !0), s.responseType = i, !1 !== this.headers.requestedWith && s.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[t.type] && s.setRequestHeader("Accept", this.headers[t.type]), n = n || this.fileError; var r = this;
                    s.onload = function() { try { return 4 === s.readyState && s.status >= 400 && s.status <= 599 ? n.call(r, t, s) : o.call(r, t, s) } catch (e) { r.hasLoaded ? window.console : r.asyncComplete(t, e.message || "Exception") } }, s.onerror = function() { try { return n.call(r, t, s) } catch (e) { r.hasLoaded ? window.console : r.asyncComplete(t, e.message || "Exception") } }, t.requestObject = s, t.requestUrl = e, s.send() } }, xhrLoadWithXDR: function(t, e, i, o, n) { this._warnedAboutXDomainRequest || this.game.device.ie && !(this.game.device.ieVersion >= 10) || (this._warnedAboutXDomainRequest = !0); var s = new window.XDomainRequest;
                s.open("GET", e, !0), s.responseType = i, s.timeout = 3e3, n = n || this.fileError; var r = this;
                s.onerror = function() { try { return n.call(r, t, s) } catch (e) { r.asyncComplete(t, e.message || "Exception") } }, s.ontimeout = function() { try { return n.call(r, t, s) } catch (e) { r.asyncComplete(t, e.message || "Exception") } }, s.onprogress = function() {}, s.onload = function() { try { return 4 === s.readyState && s.status >= 400 && s.status <= 599 ? n.call(r, t, s) : o.call(r, t, s) } catch (e) { r.asyncComplete(t, e.message || "Exception") } }, t.requestObject = s, t.requestUrl = e, setTimeout(function() { s.send() }, 0) }, getVideoURL: function(t) { for (var e = 0; e < t.length; e++) { var i, o = t[e]; if (o.uri) { if (i = o.type, o = o.uri, this.game.device.canPlayVideo(i)) return o } else { if (0 === o.indexOf("blob:") || 0 === o.indexOf("data:")) return o; if (o.indexOf("?") >= 0 && (o = o.substr(0, o.indexOf("?"))), i = o.substr((Math.max(0, o.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayVideo(i)) return t[e] } } return null }, getAudioURL: function(t) { if (this.game.sound.noAudio) return null; for (var e = 0; e < t.length; e++) { var i, o = t[e]; if (o.uri) { if (i = o.type, o = o.uri, this.game.device.canPlayAudio(i)) return o } else { if (0 === o.indexOf("blob:") || 0 === o.indexOf("data:")) return o; if (o.indexOf("?") >= 0 && (o = o.substr(0, o.indexOf("?"))), i = o.substr((Math.max(0, o.lastIndexOf(".")) || 1 / 0) + 1).toLowerCase(), this.game.device.canPlayAudio(i)) return t[e] } } return null }, fileError: function(t, e, i) { var o = "error loading asset from URL " + (t.requestUrl || this.transformUrl(t.url, t));!i && e && (i = e.status), i && (o = o + " (" + i + ")"), this.asyncComplete(t, o) }, fileComplete: function(t, e) { var o = !0; switch (t.type) {
                    case "packfile":
                        n = JSON.parse(e.responseText);
                        t.data = n || {}; break;
                    case "image":
                        this.cache.addImage(t.key, t.url, t.data); break;
                    case "spritesheet":
                        this.cache.addSpriteSheet(t.key, t.url, t.data, t.frameWidth, t.frameHeight, t.frameMax, t.margin, t.spacing); break;
                    case "textureatlas":
                        if (null == t.atlasURL) this.cache.addTextureAtlas(t.key, t.url, t.data, t.atlasData, t.format);
                        else if (o = !1, t.format === i.Loader.TEXTURE_ATLAS_JSON_ARRAY || t.format === i.Loader.TEXTURE_ATLAS_JSON_HASH || t.format === i.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.jsonLoadComplete);
                        else { if (t.format !== i.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + t.format);
                            this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.xmlLoadComplete) } break;
                    case "bitmapfont":
                        t.atlasURL ? (o = !1, this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", function(t, e) { var i; try { i = JSON.parse(e.responseText) } catch (t) {} i ? (t.atlasType = "json", this.jsonLoadComplete(t, e)) : (t.atlasType = "xml", this.xmlLoadComplete(t, e)) })) : this.cache.addBitmapFont(t.key, t.url, t.data, t.atlasData, t.atlasType, t.xSpacing, t.ySpacing); break;
                    case "video":
                        if (t.asBlob) try { t.data = e.response } catch (e) { throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + t.key) } this.cache.addVideo(t.key, t.url, t.data, t.asBlob); break;
                    case "audio":
                        this.game.sound.usingWebAudio ? (t.data = e.response, this.cache.addSound(t.key, t.url, t.data, !0, !1), t.autoDecode && this.game.sound.decode(t.key)) : this.cache.addSound(t.key, t.url, t.data, !1, !0); break;
                    case "text":
                        t.data = e.responseText, this.cache.addText(t.key, t.url, t.data); break;
                    case "shader":
                        t.data = e.responseText, this.cache.addShader(t.key, t.url, t.data); break;
                    case "physics":
                        var n = JSON.parse(e.responseText);
                        this.cache.addPhysicsData(t.key, t.url, n, t.format); break;
                    case "script":
                        t.data = document.createElement("script"), t.data.language = "javascript", t.data.type = "text/javascript", t.data.defer = !1, t.data.text = e.responseText, document.head.appendChild(t.data), t.callback && (t.data = t.callback.call(t.callbackContext, t.key, e.responseText)); break;
                    case "binary":
                        t.callback ? t.data = t.callback.call(t.callbackContext, t.key, e.response) : t.data = e.response, this.cache.addBinary(t.key, t.data) } o && this.asyncComplete(t) }, jsonLoadComplete: function(t, e) { var i = JSON.parse(e.responseText); "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format), this.asyncComplete(t) }, csvLoadComplete: function(t, e) { var i = e.responseText;
                this.cache.addTilemap(t.key, t.url, i, t.format), this.asyncComplete(t) }, xmlLoadComplete: function(t, e) { var i = e.responseText,
                    o = this.parseXml(i); if (o) "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, o, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, o, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, o), this.asyncComplete(t);
                else { e.responseType || e.contentType;
                    this.asyncComplete(t, "invalid XML") } }, parseXml: function(t) { var e; try { if (window.DOMParser) { var i = new DOMParser;
                        e = i.parseFromString(t, "text/xml") } else(e = new ActiveXObject("Microsoft.XMLDOM")).async = "false", e.loadXML(t) } catch (t) { e = null } return e && e.documentElement && !e.getElementsByTagName("parsererror").length ? e : null }, updateProgress: function() { this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null) }, totalLoadedFiles: function() { return this._loadedFileCount }, totalQueuedFiles: function() { return this._totalFileCount - this._loadedFileCount }, totalLoadedPacks: function() { return this._totalPackCount }, totalQueuedPacks: function() { return this._totalPackCount - this._loadedPackCount } }, Object.defineProperty(i.Loader.prototype, "progressFloat", { get: function() { var t = this._loadedFileCount / this._totalFileCount * 100; return i.Math.clamp(t || 0, 0, 100) } }), Object.defineProperty(i.Loader.prototype, "progress", { get: function() { return Math.round(this.progressFloat) } }), i.Loader.prototype.constructor = i.Loader, i.LoaderParser = { bitmapFont: function(t, e, i, o) { return this.xmlBitmapFont(t, e, i, o) }, xmlBitmapFont: function(t, e, i, o) { var n = {},
                    s = t.getElementsByTagName("info")[0],
                    r = t.getElementsByTagName("common")[0];
                n.font = s.getAttribute("face"), n.size = parseInt(s.getAttribute("size"), 10), n.lineHeight = parseInt(r.getAttribute("lineHeight"), 10) + o, n.chars = {}; for (var a = t.getElementsByTagName("char"), h = 0; h < a.length; h++) { var l = parseInt(a[h].getAttribute("id"), 10);
                    n.chars[l] = { x: parseInt(a[h].getAttribute("x"), 10), y: parseInt(a[h].getAttribute("y"), 10), width: parseInt(a[h].getAttribute("width"), 10), height: parseInt(a[h].getAttribute("height"), 10), xOffset: parseInt(a[h].getAttribute("xoffset"), 10), yOffset: parseInt(a[h].getAttribute("yoffset"), 10), xAdvance: parseInt(a[h].getAttribute("xadvance"), 10) + i, kerning: {} } } var c = t.getElementsByTagName("kerning"); for (h = 0; h < c.length; h++) { var d = parseInt(c[h].getAttribute("first"), 10),
                        u = parseInt(c[h].getAttribute("second"), 10),
                        p = parseInt(c[h].getAttribute("amount"), 10);
                    n.chars[u].kerning[d] = p } return this.finalizeBitmapFont(e, n) }, jsonBitmapFont: function(t, e, i, o) { var n = { font: t.font.info._face, size: parseInt(t.font.info._size, 10), lineHeight: parseInt(t.font.common._lineHeight, 10) + o, chars: {} }; return t.font.chars.char.forEach(function(t) { var e = parseInt(t._id, 10);
                    n.chars[e] = { x: parseInt(t._x, 10), y: parseInt(t._y, 10), width: parseInt(t._width, 10), height: parseInt(t._height, 10), xOffset: parseInt(t._xoffset, 10), yOffset: parseInt(t._yoffset, 10), xAdvance: parseInt(t._xadvance, 10) + i, kerning: {} } }), t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function(t) { n.chars[t._second].kerning[t._first] = parseInt(t._amount, 10) }), this.finalizeBitmapFont(e, n) }, finalizeBitmapFont: function(t, e) { return Object.keys(e.chars).forEach(function(o) { var n = e.chars[o];
                    n.texture = new PIXI.Texture(t, new i.Rectangle(n.x, n.y, n.width, n.height)) }), e } }, i.AudioSprite = function(t, e) { this.game = t, this.key = e, this.config = this.game.cache.getJSON(e + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {}; for (var i in this.config.spritemap) { var o = this.config.spritemap[i],
                    n = this.game.add.sound(this.key);
                n.addMarker(i, o.start, o.end - o.start, null, o.loop), this.sounds[i] = n } this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey]) }, i.AudioSprite.prototype = { play: function(t, e) { return void 0 === e && (e = 1), this.sounds[t].play(t, null, e) }, stop: function(t) { if (t) this.sounds[t].stop();
                else
                    for (var e in this.sounds) this.sounds[e].stop() }, get: function(t) { return this.sounds[t] } }, i.AudioSprite.prototype.constructor = i.AudioSprite, i.Sound = function(t, e, o, n, s) { void 0 === o && (o = 1), void 0 === n && (n = !1), void 0 === s && (s = t.sound.connectToMaster), this.game = t, this.name = e, this.key = e, this.loop = n, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = o * this.game.sound.volume, s && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(e) && this.game.cache.isSoundReady(e) ? (this._sound = this.game.cache.getSoundData(e), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new i.Signal, this.onPlay = new i.Signal, this.onPause = new i.Signal, this.onResume = new i.Signal, this.onLoop = new i.Signal, this.onStop = new i.Signal, this.onMute = new i.Signal, this.onMarkerComplete = new i.Signal, this.onFadeComplete = new i.Signal, this._volume = o, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1 }, i.Sound.prototype = { soundHasUnlocked: function(t) { t === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration) }, addMarker: function(t, e, i, o, n) { void 0 !== i && null !== i || (i = 1), void 0 !== o && null !== o || (o = 1), void 0 === n && (n = !1), this.markers[t] = { name: t, start: e, stop: e + i, volume: o, duration: i, durationMS: 1e3 * i, loop: n } }, removeMarker: function(t) { delete this.markers[t] }, onEndedHandler: function() { this._sound.onended = null, this.isPlaying = !1, this.currentTime = this.durationMS, this.stop() }, update: function() { this.game.cache.checkSoundKey(this.key) ? (this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = this.game.time.time), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))) : this.destroy() }, loopFull: function(t) { return this.play(null, 0, t, !0) }, play: function(t, e, i, o, n) { if (void 0 !== t && !1 !== t && null !== t || (t = ""), void 0 === n && (n = !0), this.isPlaying && !this.allowMultiple && !n && !this.override) return this; if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || n)) { if (this.usingWebAudio) { if (void 0 === this._sound.stop) this._sound.noteOff(0);
                        else try { this._sound.stop(0) } catch (t) {} this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode) } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                    this.isPlaying = !1 } if ("" === t && Object.keys(this.markers).length > 0) return this; if ("" !== t) { if (!this.markers[t]) return this;
                    this.currentMarker = t, this.position = this.markers[t].start, this.volume = this.markers[t].volume, this.loop = this.markers[t].loop, this.duration = this.markers[t].duration, this.durationMS = this.markers[t].durationMS, void 0 !== i && (this.volume = i), void 0 !== o && (this.loop = o), this._tempMarker = t, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop } else e = e || 0, void 0 === i && (i = this._volume), void 0 === o && (o = this.loop), this.position = Math.max(0, e), this.volume = i, this.loop = o, this.duration = 0, this.durationMS = 0, this._tempMarker = t, this._tempPosition = e, this._tempVolume = i, this._tempLoop = o; return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this.loop && "" === t && (this._sound.loop = !0), this.loop || "" !== t || (this._sound.onended = this.onEndedHandler.bind(this)), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === t ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key).isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key).locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume, this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this }, restart: function(t, e, i, o) { t = t || "", e = e || 0, i = i || 1, void 0 === o && (o = !1), this.play(t, e, i, o, !0) }, pause: function() { this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop()) }, resume: function() { if (this.paused && this._sound) { if (this.usingWebAudio) { var t = Math.max(0, this.position + this.pausedPosition / 1e3);
                        this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this.loop && (this._sound.loop = !0), this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this)); var e = this.duration - this.pausedPosition / 1e3;
                        void 0 === this._sound.start ? this._sound.noteGrainOn(0, t, e) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, t) : this._sound.start(0, t, e) } else this._sound.currentTime = this._tempPause, this._sound.play();
                    this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this) } }, stop: function() { if (this.isPlaying && this._sound)
                    if (this.usingWebAudio) { if (void 0 === this._sound.stop) this._sound.noteOff(0);
                        else try { this._sound.stop(0) } catch (t) {} this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode) } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0); if (this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) { var t = this.currentMarker; "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, t) } }, fadeIn: function(t, e, i) { void 0 === e && (e = !1), void 0 === i && (i = this.currentMarker), this.paused || (this.play(i, 0, 0, e), this.fadeTo(t, 1)) }, fadeOut: function(t) { this.fadeTo(t, 0) }, fadeTo: function(t, e) { this.isPlaying && !this.paused && e !== this.volume && (void 0 === t && (t = 1e3), void 0 !== e && (this.fadeTween = this.game.add.tween(this).to({ volume: e }, t, i.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this))) }, fadeComplete: function() { this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop() }, updateGlobalVolume: function(t) { this.usingAudioTag && this._sound && (this._sound.volume = t * this._volume) }, destroy: function(t) { void 0 === t && (t = !0), this.stop(), t ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose()) } }, i.Sound.prototype.constructor = i.Sound, Object.defineProperty(i.Sound.prototype, "isDecoding", { get: function() { return this.game.cache.getSound(this.key).isDecoding } }), Object.defineProperty(i.Sound.prototype, "isDecoded", { get: function() { return this.game.cache.isSoundDecoded(this.key) } }), Object.defineProperty(i.Sound.prototype, "mute", { get: function() { return this._muted || this.game.sound.mute }, set: function(t) {
                (t = t || !1) !== this._muted && (t ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this)) } }), Object.defineProperty(i.Sound.prototype, "volume", { get: function() { return this._volume }, set: function(t) { this.game.device.firefox && this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)), this._muted ? this._muteVolume = t : (this._tempVolume = t, this._volume = t, this.usingWebAudio ? this.gainNode.gain.value = t : this.usingAudioTag && this._sound && (this._sound.volume = t)) } }), i.SoundManager = function(t) { this.game = t, this.onSoundDecode = new i.Signal, this.onVolumeChange = new i.Signal, this.onMute = new i.Signal, this.onUnMute = new i.Signal, this.context = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new i.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null }, i.SoundManager.prototype = { boot: function() { if (this.game.device.iOS && !1 === this.game.device.webAudio && (this.channels = 1), window.PhaserGlobal) { if (!0 === window.PhaserGlobal.disableAudio) return this.noAudio = !0, void(this.touchLocked = !1); if (!0 === window.PhaserGlobal.disableWebAudio) return this.usingAudioTag = !0, void(this.touchLocked = !1) } if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext;
                else if (window.AudioContext) try { this.context = new window.AudioContext } catch (t) { this.context = null, this.usingWebAudio = !1, this.touchLocked = !1 } else if (window.webkitAudioContext) try { this.context = new window.webkitAudioContext } catch (t) { this.context = null, this.usingWebAudio = !1, this.touchLocked = !1 }
                if (null === this.context) { if (void 0 === window.Audio) return void(this.noAudio = !0);
                    this.usingAudioTag = !0 } else this.usingWebAudio = !0, void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination);
                this.noAudio || (!this.game.device.cocoonJS && this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock() }, setTouchLock: function() { this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (this.game.device.iOSVersion > 8 ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0) }, unlock: function() { if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0; if (this.usingAudioTag) this.touchLocked = !1, this._unlockSource = null;
                else if (this.usingWebAudio) { var t = this.context.createBuffer(1, 1, 22050);
                    this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = t, this._unlockSource.connect(this.context.destination), void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0) } return !0 }, stopAll: function() { if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop() }, pauseAll: function() { if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause() }, resumeAll: function() { if (!this.noAudio)
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume() }, decode: function(t, e) { e = e || null; var i = this.game.cache.getSoundData(t); if (i && !1 === this.game.cache.isSoundDecoded(t)) { this.game.cache.updateSound(t, "isDecoding", !0); var o = this; try { this.context.decodeAudioData(i, function(i) { i && (o.game.cache.decodedSound(t, i), o.onSoundDecode.dispatch(t, e)) }) } catch (t) {} } }, setDecodedCallback: function(t, e, o) { "string" == typeof t && (t = [t]), this._watchList.reset(); for (var n = 0; n < t.length; n++) t[n] instanceof i.Sound ? this.game.cache.isSoundDecoded(t[n].key) || this._watchList.add(t[n].key) : this.game.cache.isSoundDecoded(t[n]) || this._watchList.add(t[n]);
                0 === this._watchList.total ? (this._watching = !1, e.call(o)) : (this._watching = !0, this._watchCallback = e, this._watchContext = o) }, update: function() { if (!this.noAudio) {!this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1, this._unlockSource = null); for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update(); if (this._watching) { for (var e = this._watchList.first; e;) this.game.cache.isSoundDecoded(e) && this._watchList.remove(e), e = this._watchList.next;
                        0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext)) } } }, add: function(t, e, o, n) { void 0 === e && (e = 1), void 0 === o && (o = !1), void 0 === n && (n = this.connectToMaster); var s = new i.Sound(this.game, t, e, o, n); return this._sounds.push(s), s }, addSprite: function(t) { return new i.AudioSprite(this.game, t) }, remove: function(t) { for (var e = this._sounds.length; e--;)
                    if (this._sounds[e] === t) return this._sounds[e].destroy(!1), this._sounds.splice(e, 1), !0; return !1 }, removeByKey: function(t) { for (var e = this._sounds.length, i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++); return i }, play: function(t, e, i) { if (!this.noAudio) { var o = this.add(t, e, i); return o.play(), o } }, setMute: function() { if (!this._muted) { this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0); for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                    this.onMute.dispatch() } }, unsetMute: function() { if (this._muted && !this._codeMuted) { this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume); for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                    this.onUnMute.dispatch() } }, destroy: function() { this.stopAll(); for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].destroy();
                this._sounds = [], this.onSoundDecode.dispose(), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close()) } }, i.SoundManager.prototype.constructor = i.SoundManager, Object.defineProperty(i.SoundManager.prototype, "mute", { get: function() { return this._muted }, set: function(t) { if (t = t || !1) { if (this._muted) return;
                    this._codeMuted = !0, this.setMute() } else { if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute() } } }), Object.defineProperty(i.SoundManager.prototype, "volume", { get: function() { return this._volume }, set: function(t) { if (t < 0 ? t = 0 : t > 1 && (t = 1), this._volume !== t) { if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t;
                    else
                        for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                    this.onVolumeChange.dispatch(t) } } }), i.ScaleManager = function(t, e, o) { this.game = t, this.dom = i.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new i.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new i.Signal, this.enterIncorrectOrientation = new i.Signal, this.leaveIncorrectOrientation = new i.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new i.Signal, this.onFullScreenChange = new i.Signal, this.onFullScreenError = new i.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new i.Point(1, 1), this.scaleFactorInversed = new i.Point(1, 1), this.margin = { left: 0, top: 0, right: 0, bottom: 0, x: 0, y: 0 }, this.bounds = new i.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = { right: "layout", bottom: "" }, this.compatibility = { supportsFullScreen: !1, orientationFallback: null, noMargins: !1, scrollTo: null, forceMinimumDocumentHeight: !1, canExpandParent: !0, clickTrampoline: "" }, this._scaleMode = i.ScaleManager.NO_SCALE, this._fullScreenScaleMode = i.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new i.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new i.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new i.Rectangle, this._userScaleFactor = new i.Point(1, 1), this._userScaleTrim = new i.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new i.Rectangle, this._tempBounds = new i.Rectangle, this._lastReportedCanvasSize = new i.Rectangle, this._lastReportedGameSize = new i.Rectangle, this._booted = !1, t.config && this.parseConfig(t.config), this.setupScale(e, o) }, i.ScaleManager.EXACT_FIT = 0, i.ScaleManager.NO_SCALE = 1, i.ScaleManager.SHOW_ALL = 2, i.ScaleManager.RESIZE = 3, i.ScaleManager.USER_SCALE = 4, i.ScaleManager.prototype = { boot: function() { var t = this.compatibility;
                t.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? t.scrollTo = new i.Point(0, 1) : t.scrollTo = new i.Point(0, 0)), this.game.device.desktop ? (t.orientationFallback = "screen", t.clickTrampoline = "when-not-mouse") : (t.orientationFallback = "", t.clickTrampoline = ""); var e = this;
                this._orientationChange = function(t) { return e.orientationChange(t) }, this._windowResize = function(t) { return e.windowResize(t) }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) { return e.fullScreenChange(t) }, this._fullScreenError = function(t) { return e.fullScreenError(t) }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), i.FlexGrid && (this.grid = new i.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null) }, parseConfig: function(t) { void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode), void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget) }, setupScale: function(t, e) { var o, n = new i.Rectangle; "" !== this.game.parent && ("string" == typeof this.game.parent ? o = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (o = this.game.parent)), o ? (this.parentNode = o, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), n.width = this._parentBounds.width, n.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, n.width = this.dom.visualBounds.width, n.height = this.dom.visualBounds.height, this.offset.set(0, 0)); var s = 0,
                    r = 0; "number" == typeof t ? s = t : (this.parentScaleFactor.x = parseInt(t, 10) / 100, s = n.width * this.parentScaleFactor.x), "number" == typeof e ? r = e : (this.parentScaleFactor.y = parseInt(e, 10) / 100, r = n.height * this.parentScaleFactor.y), s = Math.floor(s), r = Math.floor(r), this._gameSize.setTo(0, 0, s, r), this.updateDimensions(s, r, !1) }, _gameResumed: function() { this.queueUpdate(!0) }, setGameSize: function(t, e) { this._gameSize.setTo(0, 0, t, e), this.currentScaleMode !== i.ScaleManager.RESIZE && this.updateDimensions(t, e, !0), this.queueUpdate(!0) }, setUserScale: function(t, e, i, o) { this._userScaleFactor.setTo(t, e), this._userScaleTrim.setTo(0 | i, 0 | o), this.queueUpdate(!0) }, setResizeCallback: function(t, e) { this.onResize = t, this.onResizeContext = e }, signalSizeChange: function() { if (!i.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !i.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) { var t = this.width,
                        e = this.height;
                    this._lastReportedCanvasSize.setTo(0, 0, t, e), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(t, e), this.onSizeChange.dispatch(this, t, e), this.currentScaleMode === i.ScaleManager.RESIZE && (this.game.state.resize(t, e), this.game.load.resize(t, e)) } }, setMinMax: function(t, e, i, o) { this.minWidth = t, this.minHeight = e, void 0 !== i && (this.maxWidth = i), void 0 !== o && (this.maxHeight = o) }, preUpdate: function() { if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) { var t = this._updateThrottle;
                    this._updateThrottleReset = t >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset); var e = this._parentBounds.width,
                        o = this._parentBounds.height,
                        n = this.getParentBounds(this._parentBounds),
                        s = n.width !== e || n.height !== o,
                        r = this.updateOrientationState();
                    (s || r) && (this.onResize && this.onResize.call(this.onResizeContext, this, n), this.updateLayout(), this.signalSizeChange()); var a = 2 * this._updateThrottle;
                    this._updateThrottle < t && (a = Math.min(t, this._updateThrottleReset)), this._updateThrottle = i.Math.clamp(a, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time } }, pauseUpdate: function() { this.preUpdate(), this._updateThrottle = this.trackParentInterval }, updateDimensions: function(t, e, i) { this.width = t * this.parentScaleFactor.x, this.height = e * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height)) }, updateScalingAndBounds: function() { this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y) }, forceOrientation: function(t, e) { void 0 === e && (e = !1), this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0) }, classifyOrientation: function(t) { return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null }, updateOrientationState: function() { var t = this.screenOrientation,
                    e = this.incorrectOrientation;
                this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait; var i = t !== this.screenOrientation,
                    o = e !== this.incorrectOrientation; return o && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (i || o) && this.onOrientationChange.dispatch(this, t, e), i || o }, orientationChange: function(t) { this.event = t, this.queueUpdate(!0) }, windowResize: function(t) { this.event = t, this.queueUpdate(!0) }, scrollTop: function() { var t = this.compatibility.scrollTo;
                t && window.scrollTo(t.x, t.y) }, refresh: function() { this.scrollTop(), this.queueUpdate(!0) }, updateLayout: function() { var t = this.currentScaleMode; if (t !== i.ScaleManager.RESIZE) { if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : t === i.ScaleManager.EXACT_FIT ? this.setExactFit() : t === i.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : t === i.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : t === i.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (t === i.ScaleManager.SHOW_ALL || t === i.ScaleManager.USER_SCALE)) { var e = this.getParentBounds(this._tempBounds);
                        this.width = Math.min(this.width, e.width), this.height = Math.min(this.height, e.height) } this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas() } else this.reflowGame() }, getParentBounds: function(t) { var e = t || new i.Rectangle,
                    o = this.boundingParent,
                    n = this.dom.visualBounds,
                    s = this.dom.layoutBounds; if (o) { var r = o.getBoundingClientRect(),
                        a = o.offsetParent ? o.offsetParent.getBoundingClientRect() : o.getBoundingClientRect();
                    e.setTo(r.left - a.left, r.top - a.top, r.width, r.height); var h = this.windowConstraints; if (h.right) { l = "layout" === h.right ? s : n;
                        e.right = Math.min(e.right, l.width) } if (h.bottom) { var l = "layout" === h.bottom ? s : n;
                        e.bottom = Math.min(e.bottom, l.height) } } else e.setTo(0, 0, n.width, n.height); return e.setTo(Math.round(e.x), Math.round(e.y), Math.round(e.width), Math.round(e.height)), e }, alignCanvas: function(t, e) { var i = this.getParentBounds(this._tempBounds),
                    o = this.game.canvas,
                    n = this.margin; if (t) { n.left = n.right = 0;
                    h = o.getBoundingClientRect(); if (this.width < i.width && !this.incorrectOrientation) { var s = h.left - i.x,
                            r = i.width / 2 - this.width / 2,
                            a = (r = Math.max(r, 0)) - s;
                        n.left = Math.round(a) } o.style.marginLeft = n.left + "px", 0 !== n.left && (n.right = -(i.width - h.width - n.left), o.style.marginRight = n.right + "px") } if (e) { n.top = n.bottom = 0; var h = o.getBoundingClientRect(); if (this.height < i.height && !this.incorrectOrientation) { var s = h.top - i.y,
                            r = i.height / 2 - this.height / 2,
                            a = (r = Math.max(r, 0)) - s;
                        n.top = Math.round(a) } o.style.marginTop = n.top + "px", 0 !== n.top && (n.bottom = -(i.height - h.height - n.top), o.style.marginBottom = n.bottom + "px") } n.x = n.left, n.y = n.top }, reflowGame: function() { this.resetCanvas("", ""); var t = this.getParentBounds(this._tempBounds);
                this.updateDimensions(t.width, t.height, !0) }, reflowCanvas: function() { this.incorrectOrientation || (this.width = i.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = i.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds() }, resetCanvas: function(t, e) { void 0 === t && (t = this.width + "px"), void 0 === e && (e = this.height + "px"); var i = this.game.canvas;
                this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""), i.style.width = t, i.style.height = e }, queueUpdate: function(t) { t && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset }, reset: function(t) { t && this.grid && this.grid.reset() }, setMaximum: function() { this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height }, setShowAll: function(t) { var e, i = this.getParentBounds(this._tempBounds),
                    o = i.width,
                    n = i.height;
                e = t ? Math.max(n / this.game.height, o / this.game.width) : Math.min(n / this.game.height, o / this.game.width), this.width = Math.round(this.game.width * e), this.height = Math.round(this.game.height * e) }, setExactFit: function() { var t = this.getParentBounds(this._tempBounds);
                this.width = t.width, this.height = t.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight))) }, createFullScreenTarget: function() { var t = document.createElement("div"); return t.style.margin = "0", t.style.padding = "0", t.style.background = "#000", t }, startFullScreen: function(t, e) { if (this.isFullScreen) return !1; { if (this.compatibility.supportsFullScreen) { if ("when-not-mouse" === this.compatibility.clickTrampoline) { var o = this.game.input; if (o.activePointer && o.activePointer !== o.mousePointer && (e || !1 !== e)) return void o.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [t, !1]) } void 0 !== t && this.game.renderType === i.CANVAS && (this.game.stage.smoothed = t); var n = this.fullScreenTarget;
                        n || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), n = this._createdFullScreenTarget); var s = { targetElement: n }; if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, s), this._createdFullScreenTarget) { var r = this.game.canvas;
                            r.parentNode.insertBefore(n, r), n.appendChild(r) } return this.game.device.fullscreenKeyboard ? n[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : n[this.game.device.requestFullscreen](), !0 } var a = this;
                    setTimeout(function() { a.fullScreenError() }, 10) } }, stopFullScreen: function() { return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), !0) }, cleanupCreatedTarget: function() { var t = this._createdFullScreenTarget; if (t && t.parentNode) { var e = t.parentNode;
                    e.insertBefore(this.game.canvas, t), e.removeChild(t) } this._createdFullScreenTarget = null }, prepScreenMode: function(t) { var e = !!this._createdFullScreenTarget,
                    o = this._createdFullScreenTarget || this.fullScreenTarget;
                t ? (e || this.fullScreenScaleMode === i.ScaleManager.EXACT_FIT) && o !== this.game.canvas && (this._fullScreenRestore = { targetWidth: o.style.width, targetHeight: o.style.height }, o.style.width = "100%", o.style.height = "100%") : (this._fullScreenRestore && (o.style.width = this._fullScreenRestore.targetWidth, o.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas()) }, fullScreenChange: function(t) { this.event = t, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height) }, fullScreenError: function(t) { this.event = t, this.cleanupCreatedTarget(), this.onFullScreenError.dispatch(this) }, scaleSprite: function(t, e, i, o) { if (void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === o && (o = !1), !t || !t.scale) return t; if (t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0) return t; var n = e,
                    s = t.height * e / t.width,
                    r = t.width * i / t.height,
                    a = i,
                    h = r > e; return (h = h ? o : !o) ? (t.width = Math.floor(n), t.height = Math.floor(s)) : (t.width = Math.floor(r), t.height = Math.floor(a)), t }, destroy: function() { this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1)) } }, i.ScaleManager.prototype.constructor = i.ScaleManager, Object.defineProperty(i.ScaleManager.prototype, "boundingParent", { get: function() { return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null } }), Object.defineProperty(i.ScaleManager.prototype, "scaleMode", { get: function() { return this._scaleMode }, set: function(t) { return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t), this._scaleMode } }), Object.defineProperty(i.ScaleManager.prototype, "fullScreenScaleMode", { get: function() { return this._fullScreenScaleMode }, set: function(t) { return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t), this._fullScreenScaleMode } }), Object.defineProperty(i.ScaleManager.prototype, "currentScaleMode", { get: function() { return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode } }), Object.defineProperty(i.ScaleManager.prototype, "pageAlignHorizontally", { get: function() { return this._pageAlignHorizontally }, set: function(t) { t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0)) } }), Object.defineProperty(i.ScaleManager.prototype, "pageAlignVertically", { get: function() { return this._pageAlignVertically }, set: function(t) { t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0)) } }), Object.defineProperty(i.ScaleManager.prototype, "isFullScreen", { get: function() { return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) } }), Object.defineProperty(i.ScaleManager.prototype, "isPortrait", { get: function() { return "portrait" === this.classifyOrientation(this.screenOrientation) } }), Object.defineProperty(i.ScaleManager.prototype, "isLandscape", { get: function() { return "landscape" === this.classifyOrientation(this.screenOrientation) } }), Object.defineProperty(i.ScaleManager.prototype, "isGamePortrait", { get: function() { return this.height > this.width } }), Object.defineProperty(i.ScaleManager.prototype, "isGameLandscape", { get: function() { return this.width > this.height } }), i.Utils.Debug = function(t) { this.game = t, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.renderShadow = !0, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1 }, i.Utils.Debug.prototype = { boot: function() { this.game.renderType === i.CANVAS ? this.context = this.game.context : (this.bmd = new i.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d")) }, resize: function(t, e, i) { this.bmd.resize(e, i), this.canvas.width = e, this.canvas.height = i }, preUpdate: function() { this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1) }, reset: function() { this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear() }, start: function(t, e, i, o) { "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), i = i || "rgb(255,255,255)", void 0 === o && (o = 0), this.currentX = t, this.currentY = e, this.currentColor = i, this.columnWidth = o, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = i, this.context.fillStyle = i, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha }, stop: function() { this.context.restore() }, line: function() { for (var t = this.currentX, e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[e], t, this.currentY), t += this.columnWidth;
                this.currentY += this.lineHeight }, soundInfo: function(t, e, i, o) { this.start(e, i, o), this.line("Sound: " + t.key + " Locked: " + t.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + " Pending Playback: " + t.pendingPlayback), this.line("Decoded: " + t.isDecoded + " Decoding: " + t.isDecoding), this.line("Total Duration: " + t.totalDuration + " Playing: " + t.isPlaying), this.line("Time: " + t.currentTime), this.line("Volume: " + t.volume + " Muted: " + t.mute), this.line("WebAudio: " + t.usingWebAudio + " Audio: " + t.usingAudioTag), "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + " Duration: " + t.duration + " (ms: " + t.durationMS + ")"), this.line("Start: " + t.markers[t.currentMarker].start + " Stop: " + t.markers[t.currentMarker].stop), this.line("Position: " + t.position)), this.stop() }, cameraInfo: function(t, e, i, o) { this.start(e, i, o), this.line("Camera (" + t.width + " x " + t.height + ")"), this.line("X: " + t.x + " Y: " + t.y), t.bounds && this.line("Bounds x: " + t.bounds.x + " Y: " + t.bounds.y + " w: " + t.bounds.width + " h: " + t.bounds.height), this.line("View x: " + t.view.x + " Y: " + t.view.y + " w: " + t.view.width + " h: " + t.view.height), this.line("Total in view: " + t.totalInView), this.stop() }, timer: function(t, e, i, o) { this.start(e, i, o), this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"), this.line("Next Tick: " + t.next + " Duration: " + t.duration), this.line("Paused: " + t.paused + " Length: " + t.length), this.stop() }, pointer: function(t, e, i, o, n) { null != t && (void 0 === e && (e = !1), i = i || "rgba(0,255,0,0.5)", o = o || "rgba(255,0,0,0.5)", !0 === e && !0 === t.isUp || (this.start(t.x, t.y - 100, n), this.context.beginPath(), this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI), t.active ? this.context.fillStyle = i : this.context.fillStyle = o, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(t.positionDown.x, t.positionDown.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + t.id + " Active: " + t.active), this.line("World X: " + t.worldX + " World Y: " + t.worldY), this.line("Screen X: " + t.x + " Screen Y: " + t.y + " In: " + t.withinGame), this.line("Duration: " + t.duration + " ms"), this.line("is Down: " + t.isDown + " is Up: " + t.isUp), this.stop())) }, spriteInputInfo: function(t, e, i, o) { this.start(e, i, o), this.line("Sprite Input: (" + t.width + " x " + t.height + ")"), this.line("x: " + t.input.pointerX().toFixed(1) + " y: " + t.input.pointerY().toFixed(1)), this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration().toFixed(0)), this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration().toFixed(0)), this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()), this.stop() }, key: function(t, e, i, o) { this.start(e, i, o, 150), this.line("Key:", t.keyCode, "isDown:", t.isDown), this.line("justDown:", t.justDown, "justUp:", t.justUp), this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)), this.stop() }, inputInfo: function(t, e, i) { this.start(t, e, i), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop() }, spriteBounds: function(t, e, i) { var o = t.getBounds();
                o.x += this.game.camera.x, o.y += this.game.camera.y, this.rectangle(o, e, i) }, ropeSegments: function(t, e, i) { var o = this;
                t.segments.forEach(function(t) { o.rectangle(t, e, i) }, this) }, spriteInfo: function(t, e, i, o) { this.start(e, i, o), this.line("Sprite:  (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y), this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)), this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)), this.line("visible: " + t.visible + " in camera: " + t.inCamera), this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)), this.stop() }, spriteCoords: function(t, e, i, o) { this.start(e, i, o, 100), t.name && this.line(t.name), this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)), this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)), this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)), this.stop() }, lineInfo: function(t, e, i, o) { this.start(e, i, o, 80), this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)), this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)), this.line("length:", t.length.toFixed(2), "angle:", t.angle), this.stop() }, pixel: function(t, e, i, o) { o = o || 2, this.start(), this.context.fillStyle = i, this.context.fillRect(t, e, o, o), this.stop() }, geom: function(t, e, o, n) { void 0 === o && (o = !0), void 0 === n && (n = 0), e = e || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = e, this.context.strokeStyle = e, t instanceof i.Rectangle || 1 === n ? o ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : t instanceof i.Circle || 2 === n ? (this.context.beginPath(), this.context.arc(t.x - this.game.camera.x, t.y - this.game.camera.y, t.radius, 0, 2 * Math.PI, !1), this.context.closePath(), o ? this.context.fill() : this.context.stroke()) : t instanceof i.Point || 3 === n ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, 4, 4) : (t instanceof i.Line || 4 === n) && (this.context.lineWidth = 1, this.context.beginPath(), this.context.moveTo(t.start.x + .5 - this.game.camera.x, t.start.y + .5 - this.game.camera.y), this.context.lineTo(t.end.x + .5 - this.game.camera.x, t.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()), this.stop() }, rectangle: function(t, e, i) { void 0 === i && (i = !0), e = e || "rgba(0, 255, 0, 0.4)", this.start(), i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)), this.stop() }, text: function(t, e, i, o, n) { o = o || "rgb(255,255,255)", n = n || "16px Courier", this.start(), this.context.font = n, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)), this.context.fillStyle = o, this.context.fillText(t, e, i), this.stop() }, quadTree: function(t, e) { e = e || "rgba(255,0,0,0.3)", this.start(); var i = t.bounds; if (0 === t.nodes.length) { this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)"; for (o = 0; o < t.objects.length; o++) this.context.strokeRect(t.objects[o].x, t.objects[o].y, t.objects[o].width, t.objects[o].height) } else
                    for (var o = 0; o < t.nodes.length; o++) this.quadTree(t.nodes[o]);
                this.stop() }, body: function(t, e, o) { t.body && (this.start(), t.body.type === i.Physics.ARCADE ? i.Physics.Arcade.Body.render(this.context, t.body, e, o) : t.body.type === i.Physics.NINJA ? i.Physics.Ninja.Body.render(this.context, t.body, e, o) : t.body.type === i.Physics.BOX2D && i.Physics.Box2D.renderBody(this.context, t.body, e), this.stop()) }, bodyInfo: function(t, e, o, n) { t.body && (this.start(e, o, n, 210), t.body.type === i.Physics.ARCADE ? i.Physics.Arcade.Body.renderBodyInfo(this, t.body) : t.body.type === i.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, t.body), this.stop()) }, box2dWorld: function() { this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop() }, box2dBody: function(t, e) { this.start(), i.Physics.Box2D.renderBody(this.context, t, e), this.stop() }, displayList: function(t) { if (void 0 === t && (t = this.game.world), t.hasOwnProperty("renderOrderID"), t.children && t.children.length > 0)
                    for (var e = 0; e < t.children.length; e++) this.game.debug.displayList(t.children[e]) }, destroy: function() { PIXI.CanvasPool.remove(this) } }, i.Utils.Debug.prototype.constructor = i.Utils.Debug, i.DOM = { getOffset: function(t, e) { e = e || new i.Point; var o = t.getBoundingClientRect(),
                    n = i.DOM.scrollY,
                    s = i.DOM.scrollX,
                    r = document.documentElement.clientTop,
                    a = document.documentElement.clientLeft; return e.x = o.left + s - a, e.y = o.top + n - r, e }, getBounds: function(t, e) { return void 0 === e && (e = 0), !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e) }, calibrate: function(t, e) { e = +e || 0; var i = { width: 0, height: 0, left: 0, right: 0, top: 0, bottom: 0 }; return i.width = (i.right = t.right + e) - (i.left = t.left - e), i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e), i }, getAspectRatio: function(t) { var e = (t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t).width,
                    i = t.height; return "function" == typeof e && (e = e.call(t)), "function" == typeof i && (i = i.call(t)), e / i }, inLayoutViewport: function(t, e) { var i = this.getBounds(t, e); return !!i && i.bottom >= 0 && i.right >= 0 && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height }, getScreenOrientation: function(t) { var e = window.screen,
                    i = e.orientation || e.mozOrientation || e.msOrientation; if (i && "string" == typeof i.type) return i.type; if ("string" == typeof i) return i; var o = "portrait-primary",
                    n = "landscape-primary"; if ("screen" === t) return e.height > e.width ? o : n; if ("viewport" === t) return this.visualBounds.height > this.visualBounds.width ? o : n; if ("window.orientation" === t && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? o : n; if (window.matchMedia) { if (window.matchMedia("(orientation: portrait)").matches) return o; if (window.matchMedia("(orientation: landscape)").matches) return n } return this.visualBounds.height > this.visualBounds.width ? o : n }, visualBounds: new i.Rectangle, layoutBounds: new i.Rectangle, documentBounds: new i.Rectangle }, i.Device.whenReady(function(t) { var e = window && "pageXOffset" in window ? function() { return window.pageXOffset } : function() { return document.documentElement.scrollLeft },
                o = window && "pageYOffset" in window ? function() { return window.pageYOffset } : function() { return document.documentElement.scrollTop }; if (Object.defineProperty(i.DOM, "scrollX", { get: e }), Object.defineProperty(i.DOM, "scrollY", { get: o }), Object.defineProperty(i.DOM.visualBounds, "x", { get: e }), Object.defineProperty(i.DOM.visualBounds, "y", { get: o }), Object.defineProperty(i.DOM.layoutBounds, "x", { value: 0 }), Object.defineProperty(i.DOM.layoutBounds, "y", { value: 0 }), t.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) { var n = function() { return Math.max(window.innerWidth, document.documentElement.clientWidth) },
                    s = function() { return Math.max(window.innerHeight, document.documentElement.clientHeight) };
                Object.defineProperty(i.DOM.visualBounds, "width", { get: n }), Object.defineProperty(i.DOM.visualBounds, "height", { get: s }), Object.defineProperty(i.DOM.layoutBounds, "width", { get: n }), Object.defineProperty(i.DOM.layoutBounds, "height", { get: s }) } else Object.defineProperty(i.DOM.visualBounds, "width", { get: function() { return window.innerWidth } }), Object.defineProperty(i.DOM.visualBounds, "height", { get: function() { return window.innerHeight } }), Object.defineProperty(i.DOM.layoutBounds, "width", { get: function() { var t = document.documentElement.clientWidth,
                        e = window.innerWidth; return t < e ? e : t } }), Object.defineProperty(i.DOM.layoutBounds, "height", { get: function() { var t = document.documentElement.clientHeight,
                        e = window.innerHeight; return t < e ? e : t } });
            Object.defineProperty(i.DOM.documentBounds, "x", { value: 0 }), Object.defineProperty(i.DOM.documentBounds, "y", { value: 0 }), Object.defineProperty(i.DOM.documentBounds, "width", { get: function() { var t = document.documentElement; return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth) } }), Object.defineProperty(i.DOM.documentBounds, "height", { get: function() { var t = document.documentElement; return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight) } }) }, null, !0), i.ArraySet = function(t) { this.position = 0, this.list = t || [] }, i.ArraySet.prototype = { add: function(t) { return this.exists(t) || this.list.push(t), t }, getIndex: function(t) { return this.list.indexOf(t) }, getByKey: function(t, e) { for (var i = this.list.length; i--;)
                    if (this.list[i][t] === e) return this.list[i]; return null }, exists: function(t) { return this.list.indexOf(t) > -1 }, reset: function() { this.list.length = 0 }, remove: function(t) { var e = this.list.indexOf(t); if (e > -1) return this.list.splice(e, 1), t }, setAll: function(t, e) { for (var i = this.list.length; i--;) this.list[i] && (this.list[i][t] = e) }, callAll: function(t) { for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e) }, removeAll: function(t) { void 0 === t && (t = !1); for (var e = this.list.length; e--;)
                    if (this.list[e]) { var i = this.remove(this.list[e]);
                        t && i.destroy() } this.position = 0, this.list = [] } }, Object.defineProperty(i.ArraySet.prototype, "total", { get: function() { return this.list.length } }), Object.defineProperty(i.ArraySet.prototype, "first", { get: function() { return this.position = 0, this.list.length > 0 ? this.list[0] : null } }), Object.defineProperty(i.ArraySet.prototype, "next", { get: function() { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null } }), i.ArraySet.prototype.constructor = i.ArraySet, i.ArrayUtils = { getRandomItem: function(t, e, i) { if (null === t) return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length); var o = e + Math.floor(Math.random() * i); return void 0 === t[o] ? null : t[o] }, removeRandomItem: function(t, e, i) { if (null == t) return null;
                void 0 === e && (e = 0), void 0 === i && (i = t.length); var o = e + Math.floor(Math.random() * i); if (o < t.length) { var n = t.splice(o, 1); return void 0 === n[0] ? null : n[0] } return null }, shuffle: function(t) { for (var e = t.length - 1; e > 0; e--) { var i = Math.floor(Math.random() * (e + 1)),
                        o = t[e];
                    t[e] = t[i], t[i] = o } return t }, transposeMatrix: function(t) { for (var e = t.length, i = t[0].length, o = new Array(i), n = 0; n < i; n++) { o[n] = new Array(e); for (var s = e - 1; s > -1; s--) o[n][s] = t[s][n] } return o }, rotateMatrix: function(t, e) { if ("string" != typeof e && (e = (e % 360 + 360) % 360), 90 === e || -270 === e || "rotateLeft" === e) t = (t = i.ArrayUtils.transposeMatrix(t)).reverse();
                else if (-90 === e || 270 === e || "rotateRight" === e) t = t.reverse(), t = i.ArrayUtils.transposeMatrix(t);
                else if (180 === Math.abs(e) || "rotate180" === e) { for (var o = 0; o < t.length; o++) t[o].reverse();
                    t = t.reverse() } return t }, findClosest: function(t, e) { if (!e.length) return NaN; if (1 === e.length || t < e[0]) return e[0]; for (var i = 1; e[i] < t;) i++; var o = e[i - 1],
                    n = i < e.length ? e[i] : Number.POSITIVE_INFINITY; return n - t <= t - o ? n : o }, rotateRight: function(t) { var e = t.pop(); return t.unshift(e), e }, rotateLeft: function(t) { var e = t.shift(); return t.push(e), e }, rotate: function(t) { var e = t.shift(); return t.push(e), e }, numberArray: function(t, e) { for (var i = [], o = t; o <= e; o++) i.push(o); return i }, numberArrayStep: function(t, e, o) { void 0 !== t && null !== t || (t = 0), void 0 !== e && null !== e || (e = t, t = 0), void 0 === o && (o = 1); for (var n = [], s = Math.max(i.Math.roundAwayFromZero((e - t) / (o || 1)), 0), r = 0; r < s; r++) n.push(t), t += o; return n } }, i.LinkedList = function() { this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0 }, i.LinkedList.prototype = { add: function(t) { return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, this.next = t, t.prev = this, this.total++, t) : (this.last.next = t, t.prev = this.last, this.last = t, this.total++, t) }, reset: function() { this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0 }, remove: function(t) { if (1 === this.total) return this.reset(), void(t.next = t.prev = null);
                t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.next = t.prev = null, null === this.first && (this.last = null), this.total-- }, callAll: function(t) { if (this.first && this.last) { var e = this.first;
                    do { e && e[t] && e[t].call(e), e = e.next } while (e !== this.last.next) } } }, i.LinkedList.prototype.constructor = i.LinkedList, i.Create = function(t) { this.game = t, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{ 0: "#000", 1: "#9D9D9D", 2: "#FFF", 3: "#BE2633", 4: "#E06F8B", 5: "#493C2B", 6: "#A46422", 7: "#EB8931", 8: "#F7E26B", 9: "#2F484E", A: "#44891A", B: "#A3CE27", C: "#1B2632", D: "#005784", E: "#31A2F2", F: "#B2DCEF" }, { 0: "#000", 1: "#191028", 2: "#46af45", 3: "#a1d685", 4: "#453e78", 5: "#7664fe", 6: "#833129", 7: "#9ec2e8", 8: "#dc534b", 9: "#e18d79", A: "#d6b97b", B: "#e9d8a1", C: "#216c4b", D: "#d365c8", E: "#afaab9", F: "#f5f4eb" }, { 0: "#000", 1: "#2234d1", 2: "#0c7e45", 3: "#44aacc", 4: "#8a3622", 5: "#5c2e78", 6: "#aa5c3d", 7: "#b5b5b5", 8: "#5e606e", 9: "#4c81fb", A: "#6cd947", B: "#7be2f9", C: "#eb8a60", D: "#e23d69", E: "#ffd93f", F: "#fff" }, { 0: "#000", 1: "#fff", 2: "#8b4131", 3: "#7bbdc5", 4: "#8b41ac", 5: "#6aac41", 6: "#3931a4", 7: "#d5de73", 8: "#945a20", 9: "#5a4100", A: "#bd736a", B: "#525252", C: "#838383", D: "#acee8b", E: "#7b73de", F: "#acacac" }, { 0: "#000", 1: "#191028", 2: "#46af45", 3: "#a1d685", 4: "#453e78", 5: "#7664fe", 6: "#833129", 7: "#9ec2e8", 8: "#dc534b", 9: "#e18d79", A: "#d6b97b", B: "#e9d8a1", C: "#216c4b", D: "#d365c8", E: "#afaab9", F: "#fff" }] }, i.Create.PALETTE_ARNE = 0, i.Create.PALETTE_JMP = 1, i.Create.PALETTE_CGA = 2, i.Create.PALETTE_C64 = 3, i.Create.PALETTE_JAPANESE_MACHINE = 4, i.Create.prototype = { texture: function(t, e, i, o, n) { void 0 === i && (i = 8), void 0 === o && (o = i), void 0 === n && (n = 0); var s = e[0].length * i,
                    r = e.length * o;
                null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(s, r), this.bmd.clear(); for (var a = 0; a < e.length; a++)
                    for (var h = e[a], l = 0; l < h.length; l++) { var c = h[l]; "." !== c && " " !== c && (this.ctx.fillStyle = this.palettes[n][c], this.ctx.fillRect(l * i, a * o, i, o)) }
                return this.bmd.generateTexture(t) }, grid: function(t, e, i, o, n, s) { null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(e, i), this.ctx.fillStyle = s; for (var r = 0; r < i; r += n) this.ctx.fillRect(0, r, e, 1); for (var a = 0; a < e; a += o) this.ctx.fillRect(a, 0, 1, i); return this.bmd.generateTexture(t) } }, i.Create.prototype.constructor = i.Create, i.FlexGrid = function(t, e, o) { this.game = t.game, this.manager = t, this.width = e, this.height = o, this.boundsCustom = new i.Rectangle(0, 0, e, o), this.boundsFluid = new i.Rectangle(0, 0, e, o), this.boundsFull = new i.Rectangle(0, 0, e, o), this.boundsNone = new i.Rectangle(0, 0, e, o), this.positionCustom = new i.Point(0, 0), this.positionFluid = new i.Point(0, 0), this.positionFull = new i.Point(0, 0), this.positionNone = new i.Point(0, 0), this.scaleCustom = new i.Point(1, 1), this.scaleFluid = new i.Point(1, 1), this.scaleFluidInversed = new i.Point(1, 1), this.scaleFull = new i.Point(1, 1), this.scaleNone = new i.Point(1, 1), this.customWidth = 0, this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = e / o, this.ratioV = o / e, this.multiplier = 0, this.layers = [] }, i.FlexGrid.prototype = { setSize: function(t, e) { this.width = t, this.height = e, this.ratioH = t / e, this.ratioV = e / t, this.scaleNone = new i.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh() }, createCustomLayer: function(t, e, o, n) { void 0 === n && (n = !0), this.customWidth = t, this.customHeight = e, this.boundsCustom.width = t, this.boundsCustom.height = e; var s = new i.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom); return n && this.game.world.add(s), this.layers.push(s), void 0 !== o && null !== typeof o && s.addMultiple(o), s }, createFluidLayer: function(t, e) { void 0 === e && (e = !0); var o = new i.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid); return e && this.game.world.add(o), this.layers.push(o), void 0 !== t && null !== typeof t && o.addMultiple(t), o }, createFullLayer: function(t) { var e = new i.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid); return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e }, createFixedLayer: function(t) { var e = new i.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone); return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e }, reset: function() { for (var t = this.layers.length; t--;) this.layers[t].persist || (this.layers[t].position = null, this.layers[t].scale = null, this.layers.slice(t, 1)) }, onResize: function(t, e) { this.ratioH = t / e, this.ratioV = e / t, this.refresh(t, e) }, refresh: function() { this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y) }, fitSprite: function(t) { this.manager.scaleSprite(t), t.x = this.manager.bounds.centerX, t.y = this.manager.bounds.centerY }, debug: function() { this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1) } }, i.FlexGrid.prototype.constructor = i.FlexGrid, i.FlexLayer = function(t, e, o, n) { i.Group.call(this, t.game, null, "__flexLayer" + t.game.rnd.uuid(), !1), this.manager = t.manager, this.grid = t, this.persist = !1, this.position = e, this.bounds = o, this.scale = n, this.topLeft = o.topLeft, this.topMiddle = new i.Point(o.halfWidth, 0), this.topRight = o.topRight, this.bottomLeft = o.bottomLeft, this.bottomMiddle = new i.Point(o.halfWidth, o.bottom), this.bottomRight = o.bottomRight }, i.FlexLayer.prototype = Object.create(i.Group.prototype), i.FlexLayer.prototype.constructor = i.FlexLayer, i.FlexLayer.prototype.resize = function() {}, i.FlexLayer.prototype.debug = function() { this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9") }, i.Color = { packPixel: function(t, e, o, n) { return i.Device.LITTLE_ENDIAN ? (n << 24 | o << 16 | e << 8 | t) >>> 0 : (t << 24 | e << 16 | o << 8 | n) >>> 0 }, unpackPixel: function(t, e, o, n) { return void 0 !== e && null !== e || (e = i.Color.createColor()), void 0 !== o && null !== o || (o = !1), void 0 !== n && null !== n || (n = !1), i.Device.LITTLE_ENDIAN ? (e.a = (4278190080 & t) >>> 24, e.b = (16711680 & t) >>> 16, e.g = (65280 & t) >>> 8, e.r = 255 & t) : (e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t), e.color = t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a / 255 + ")", o && i.Color.RGBtoHSL(e.r, e.g, e.b, e), n && i.Color.RGBtoHSV(e.r, e.g, e.b, e), e }, fromRGBA: function(t, e) { return e || (e = i.Color.createColor()), e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")", e }, toRGBA: function(t, e, i, o) { return t << 24 | e << 16 | i << 8 | o }, toABGR: function(t, e, i, o) { return (o << 24 | i << 16 | e << 8 | t) >>> 0 }, RGBtoHSL: function(t, e, o, n) { n || (n = i.Color.createColor(t, e, o, 1)), t /= 255, e /= 255, o /= 255; var s = Math.min(t, e, o),
                    r = Math.max(t, e, o); if (n.h = 0, n.s = 0, n.l = (r + s) / 2, r !== s) { var a = r - s;
                    n.s = n.l > .5 ? a / (2 - r - s) : a / (r + s), r === t ? n.h = (e - o) / a + (e < o ? 6 : 0) : r === e ? n.h = (o - t) / a + 2 : r === o && (n.h = (t - e) / a + 4), n.h /= 6 } return n }, HSLtoRGB: function(t, e, o, n) { if (n ? (n.r = o, n.g = o, n.b = o) : n = i.Color.createColor(o, o, o), 0 !== e) { var s = o < .5 ? o * (1 + e) : o + e - o * e,
                        r = 2 * o - s;
                    n.r = i.Color.hueToColor(r, s, t + 1 / 3), n.g = i.Color.hueToColor(r, s, t), n.b = i.Color.hueToColor(r, s, t - 1 / 3) } return n.r = Math.floor(255 * n.r | 0), n.g = Math.floor(255 * n.g | 0), n.b = Math.floor(255 * n.b | 0), i.Color.updateColor(n), n }, RGBtoHSV: function(t, e, o, n) { n || (n = i.Color.createColor(t, e, o, 255)), t /= 255, e /= 255, o /= 255; var s = Math.min(t, e, o),
                    r = Math.max(t, e, o),
                    a = r - s; return n.h = 0, n.s = 0 === r ? 0 : a / r, n.v = r, r !== s && (r === t ? n.h = (e - o) / a + (e < o ? 6 : 0) : r === e ? n.h = (o - t) / a + 2 : r === o && (n.h = (t - e) / a + 4), n.h /= 6), n }, HSVtoRGB: function(t, e, o, n) { void 0 === n && (n = i.Color.createColor(0, 0, 0, 1, t, e, 0, o)); var s, r, a, h = Math.floor(6 * t),
                    l = 6 * t - h,
                    c = o * (1 - e),
                    d = o * (1 - l * e),
                    u = o * (1 - (1 - l) * e); switch (h % 6) {
                    case 0:
                        s = o, r = u, a = c; break;
                    case 1:
                        s = d, r = o, a = c; break;
                    case 2:
                        s = c, r = o, a = u; break;
                    case 3:
                        s = c, r = d, a = o; break;
                    case 4:
                        s = u, r = c, a = o; break;
                    case 5:
                        s = o, r = c, a = d } return n.r = Math.floor(255 * s), n.g = Math.floor(255 * r), n.b = Math.floor(255 * a), i.Color.updateColor(n), n }, hueToColor: function(t, e, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t }, createColor: function(t, e, o, n, s, r, a, h) { var l = { r: t || 0, g: e || 0, b: o || 0, a: n || 1, h: s || 0, s: r || 0, l: a || 0, v: h || 0, color: 0, color32: 0, rgba: "" }; return i.Color.updateColor(l) }, updateColor: function(t) { return t.rgba = "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + t.a.toString() + ")", t.color = i.Color.getColor(t.r, t.g, t.b), t.color32 = i.Color.getColor32(255 * t.a, t.r, t.g, t.b), t }, getColor32: function(t, e, i, o) { return t << 24 | e << 16 | i << 8 | o }, getColor: function(t, e, i) { return t << 16 | e << 8 | i }, RGBtoString: function(t, e, o, n, s) { return void 0 === n && (n = 255), void 0 === s && (s = "#"), "#" === s ? "#" + ((1 << 24) + (t << 16) + (e << 8) + o).toString(16).slice(1) : "0x" + i.Color.componentToHex(n) + i.Color.componentToHex(t) + i.Color.componentToHex(e) + i.Color.componentToHex(o) }, hexToRGB: function(t) { var e = i.Color.hexToColor(t); if (e) return i.Color.getColor32(e.a, e.r, e.g, e.b) }, hexToColor: function(t, e) { t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, o) { return e + e + i + i + o + o }); var o = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t); if (o) { var n = parseInt(o[1], 16),
                        s = parseInt(o[2], 16),
                        r = parseInt(o[3], 16);
                    e ? (e.r = n, e.g = s, e.b = r) : e = i.Color.createColor(n, s, r) } return e }, webToColor: function(t, e) { e || (e = i.Color.createColor()); var o = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t); return o && (e.r = parseInt(o[1], 10), e.g = parseInt(o[2], 10), e.b = parseInt(o[3], 10), e.a = void 0 !== o[4] ? parseFloat(o[4]) : 1, i.Color.updateColor(e)), e }, valueToColor: function(t, e) { if (e || (e = i.Color.createColor()), "string" == typeof t) return 0 === t.indexOf("rgb") ? i.Color.webToColor(t, e) : (e.a = 1, i.Color.hexToColor(t, e)); if ("number" == typeof t) { var o = i.Color.getRGB(t); return e.r = o.r, e.g = o.g, e.b = o.b, e.a = o.a / 255, e } return e }, componentToHex: function(t) { var e = t.toString(16); return 1 === e.length ? "0" + e : e }, HSVColorWheel: function(t, e) { void 0 === t && (t = 1), void 0 === e && (e = 1); for (var o = [], n = 0; n <= 359; n++) o.push(i.Color.HSVtoRGB(n / 359, t, e)); return o }, HSLColorWheel: function(t, e) { void 0 === t && (t = .5), void 0 === e && (e = .5); for (var o = [], n = 0; n <= 359; n++) o.push(i.Color.HSLtoRGB(n / 359, t, e)); return o }, interpolateColor: function(t, e, o, n, s) { void 0 === s && (s = 255); var r = i.Color.getRGB(t),
                    a = i.Color.getRGB(e),
                    h = (a.red - r.red) * n / o + r.red,
                    l = (a.green - r.green) * n / o + r.green,
                    c = (a.blue - r.blue) * n / o + r.blue; return i.Color.getColor32(s, h, l, c) }, interpolateColorWithRGB: function(t, e, o, n, s, r) { var a = i.Color.getRGB(t),
                    h = (e - a.red) * r / s + a.red,
                    l = (o - a.green) * r / s + a.green,
                    c = (n - a.blue) * r / s + a.blue; return i.Color.getColor(h, l, c) }, interpolateRGB: function(t, e, o, n, s, r, a, h) { var l = (n - t) * h / a + t,
                    c = (s - e) * h / a + e,
                    d = (r - o) * h / a + o; return i.Color.getColor(l, c, d) }, getRandomColor: function(t, e, o) { if (void 0 === t && (t = 0), void 0 === e && (e = 255), void 0 === o && (o = 255), e > 255 || t > e) return i.Color.getColor(255, 255, 255); var n = t + Math.round(Math.random() * (e - t)),
                    s = t + Math.round(Math.random() * (e - t)),
                    r = t + Math.round(Math.random() * (e - t)); return i.Color.getColor32(o, n, s, r) }, getRGB: function(t) { return t > 16777215 ? { alpha: t >>> 24, red: t >> 16 & 255, green: t >> 8 & 255, blue: 255 & t, a: t >>> 24, r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t } : { alpha: 255, red: t >> 16 & 255, green: t >> 8 & 255, blue: 255 & t, a: 255, r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t } }, getWebRGB: function(t) { if ("object" == typeof t) return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255).toString() + ")"; var e = i.Color.getRGB(t); return "rgba(" + e.r.toString() + "," + e.g.toString() + "," + e.b.toString() + "," + (e.a / 255).toString() + ")" }, getAlpha: function(t) { return t >>> 24 }, getAlphaFloat: function(t) { return (t >>> 24) / 255 }, getRed: function(t) { return t >> 16 & 255 }, getGreen: function(t) { return t >> 8 & 255 }, getBlue: function(t) { return 255 & t }, blendNormal: function(t) { return t }, blendLighten: function(t, e) { return e > t ? e : t }, blendDarken: function(t, e) { return e > t ? t : e }, blendMultiply: function(t, e) { return t * e / 255 }, blendAverage: function(t, e) { return (t + e) / 2 }, blendAdd: function(t, e) { return Math.min(255, t + e) }, blendSubtract: function(t, e) { return Math.max(0, t + e - 255) }, blendDifference: function(t, e) { return Math.abs(t - e) }, blendNegation: function(t, e) { return 255 - Math.abs(255 - t - e) }, blendScreen: function(t, e) { return 255 - ((255 - t) * (255 - e) >> 8) }, blendExclusion: function(t, e) { return t + e - 2 * t * e / 255 }, blendOverlay: function(t, e) { return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255 }, blendSoftLight: function(t, e) { return e < 128 ? 2 * (64 + (t >> 1)) * (e / 255) : 255 - 2 * (255 - (64 + (t >> 1))) * (255 - e) / 255 }, blendHardLight: function(t, e) { return i.Color.blendOverlay(e, t) }, blendColorDodge: function(t, e) { return 255 === e ? e : Math.min(255, (t << 8) / (255 - e)) }, blendColorBurn: function(t, e) { return 0 === e ? e : Math.max(0, 255 - (255 - t << 8) / e) }, blendLinearDodge: function(t, e) { return i.Color.blendAdd(t, e) }, blendLinearBurn: function(t, e) { return i.Color.blendSubtract(t, e) }, blendLinearLight: function(t, e) { return e < 128 ? i.Color.blendLinearBurn(t, 2 * e) : i.Color.blendLinearDodge(t, 2 * (e - 128)) }, blendVividLight: function(t, e) { return e < 128 ? i.Color.blendColorBurn(t, 2 * e) : i.Color.blendColorDodge(t, 2 * (e - 128)) }, blendPinLight: function(t, e) { return e < 128 ? i.Color.blendDarken(t, 2 * e) : i.Color.blendLighten(t, 2 * (e - 128)) }, blendHardMix: function(t, e) { return i.Color.blendVividLight(t, e) < 128 ? 0 : 255 }, blendReflect: function(t, e) { return 255 === e ? e : Math.min(255, t * t / (255 - e)) }, blendGlow: function(t, e) { return i.Color.blendReflect(e, t) }, blendPhoenix: function(t, e) { return Math.min(t, e) - Math.max(t, e) + 255 } }, i.Physics = function(t, e) { e = e || {}, this.game = t, this.config = e, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig() }, i.Physics.ARCADE = 0, i.Physics.P2JS = 1, i.Physics.NINJA = 2, i.Physics.BOX2D = 3, i.Physics.CHIPMUNK = 4, i.Physics.MATTERJS = 5, i.Physics.prototype = { parseConfig: function() { this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !i.Physics.hasOwnProperty("Arcade") || (this.arcade = new i.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && i.Physics.hasOwnProperty("Ninja") && (this.ninja = new i.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && !0 === this.config.p2 && i.Physics.hasOwnProperty("P2") && (this.p2 = new i.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && i.Physics.hasOwnProperty("BOX2D") && (this.box2d = new i.Physics.BOX2D(this.game, this.config)), this.config.hasOwnProperty("matter") && !0 === this.config.matter && i.Physics.hasOwnProperty("Matter") && (this.matter = new i.Physics.Matter(this.game, this.config)) }, startSystem: function(t) { t === i.Physics.ARCADE ? this.arcade = new i.Physics.Arcade(this.game) : t === i.Physics.P2JS ? null === this.p2 ? this.p2 = new i.Physics.P2(this.game, this.config) : this.p2.reset() : t === i.Physics.NINJA ? this.ninja = new i.Physics.Ninja(this.game) : t === i.Physics.BOX2D ? null === this.box2d ? this.box2d = new i.Physics.Box2D(this.game, this.config) : this.box2d.reset() : t === i.Physics.MATTERJS && (null === this.matter ? this.matter = new i.Physics.Matter(this.game, this.config) : this.matter.reset()) }, enable: function(t, e, o) { void 0 === e && (e = i.Physics.ARCADE), void 0 === o && (o = !1), e === i.Physics.ARCADE ? this.arcade.enable(t) : e === i.Physics.P2JS && this.p2 ? this.p2.enable(t, o) : e === i.Physics.NINJA && this.ninja ? this.ninja.enableAABB(t) : e === i.Physics.BOX2D && this.box2d ? this.box2d.enable(t) : e === i.Physics.MATTERJS && this.matter && this.matter.enable(t) }, preUpdate: function() { this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate() }, update: function() { this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update() }, setBoundsToWorld: function() { this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld() }, clear: function() { this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear() }, reset: function() { this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset() }, destroy: function() { this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null } }, i.Physics.prototype.constructor = i.Physics, i.Physics.Arcade = function(t) { this.game = t, this.gravity = new i.Point, this.bounds = new i.Rectangle(0, 0, t.world.width, t.world.height), this.checkCollision = { up: !0, down: !0, left: !0, right: !0 }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, this.sortDirection = i.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, this.quadTree = new i.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._total = 0, this.setBoundsToWorld() }, i.Physics.Arcade.prototype.constructor = i.Physics.Arcade, i.Physics.Arcade.SORT_NONE = 0, i.Physics.Arcade.LEFT_RIGHT = 1, i.Physics.Arcade.RIGHT_LEFT = 2, i.Physics.Arcade.TOP_BOTTOM = 3, i.Physics.Arcade.BOTTOM_TOP = 4, i.Physics.Arcade.prototype = { setBounds: function(t, e, i, o) { this.bounds.setTo(t, e, i, o) }, setBoundsToWorld: function() { this.bounds.copyFrom(this.game.world.bounds) }, enable: function(t, e) { void 0 === e && (e = !0); var o = 1; if (Array.isArray(t))
                    for (o = t.length; o--;) t[o] instanceof i.Group ? this.enable(t[o].children, e) : (this.enableBody(t[o]), e && t[o].hasOwnProperty("children") && t[o].children.length > 0 && this.enable(t[o], !0));
                else t instanceof i.Group ? this.enable(t.children, e) : (this.enableBody(t), e && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, !0)) }, enableBody: function(t) { t.hasOwnProperty("body") && null === t.body && (t.body = new i.Physics.Arcade.Body(t), t.parent && t.parent instanceof i.Group && t.parent.addToHash(t)) }, updateMotion: function(t) { var e = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity;
                t.angularVelocity += e, t.rotation += t.angularVelocity * this.game.time.physicsElapsed, t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x), t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y) }, computeVelocity: function(t, e, i, o, n, s) { return void 0 === s && (s = 1e4), 1 === t && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.game.time.physicsElapsed : 2 === t && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.game.time.physicsElapsed), o ? i += o * this.game.time.physicsElapsed : n && (i - (n *= this.game.time.physicsElapsed) > 0 ? i -= n : i + n < 0 ? i += n : i = 0), i > s ? i = s : i < -s && (i = -s), i }, overlap: function(t, e, i, o, n) { if (i = i || null, o = o || null, n = n || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                    for (s = 0; s < e.length; s++) this.collideHandler(t, e[s], i, o, n, !0);
                else if (Array.isArray(t) && !Array.isArray(e))
                    for (s = 0; s < t.length; s++) this.collideHandler(t[s], e, i, o, n, !0);
                else if (Array.isArray(t) && Array.isArray(e))
                    for (var s = 0; s < t.length; s++)
                        for (var r = 0; r < e.length; r++) this.collideHandler(t[s], e[r], i, o, n, !0);
                else this.collideHandler(t, e, i, o, n, !0); return this._total > 0 }, collide: function(t, e, i, o, n) { if (i = i || null, o = o || null, n = n || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                    for (s = 0; s < e.length; s++) this.collideHandler(t, e[s], i, o, n, !1);
                else if (Array.isArray(t) && !Array.isArray(e))
                    for (s = 0; s < t.length; s++) this.collideHandler(t[s], e, i, o, n, !1);
                else if (Array.isArray(t) && Array.isArray(e))
                    for (var s = 0; s < t.length; s++)
                        for (var r = 0; r < e.length; r++) this.collideHandler(t[s], e[r], i, o, n, !1);
                else this.collideHandler(t, e, i, o, n, !1); return this._total > 0 }, sortLeftRight: function(t, e) { return t.body && e.body ? t.body.x - e.body.x : 0 }, sortRightLeft: function(t, e) { return t.body && e.body ? e.body.x - t.body.x : 0 }, sortTopBottom: function(t, e) { return t.body && e.body ? t.body.y - e.body.y : 0 }, sortBottomTop: function(t, e) { return t.body && e.body ? e.body.y - t.body.y : 0 }, sort: function(t, e) { null !== t.physicsSortDirection ? e = t.physicsSortDirection : void 0 === e && (e = this.sortDirection), e === i.Physics.Arcade.LEFT_RIGHT ? t.hash.sort(this.sortLeftRight) : e === i.Physics.Arcade.RIGHT_LEFT ? t.hash.sort(this.sortRightLeft) : e === i.Physics.Arcade.TOP_BOTTOM ? t.hash.sort(this.sortTopBottom) : e === i.Physics.Arcade.BOTTOM_TOP && t.hash.sort(this.sortBottomTop) }, collideHandler: function(t, e, o, n, s, r) { if (void 0 === e && t.physicsType === i.GROUP) return this.sort(t), void this.collideGroupVsSelf(t, o, n, s, r);
                t && e && t.exists && e.exists && (this.sortDirection !== i.Physics.Arcade.SORT_NONE && (t.physicsType === i.GROUP && this.sort(t), e.physicsType === i.GROUP && this.sort(e)), t.physicsType === i.SPRITE ? e.physicsType === i.SPRITE ? this.collideSpriteVsSprite(t, e, o, n, s, r) : e.physicsType === i.GROUP ? this.collideSpriteVsGroup(t, e, o, n, s, r) : e.physicsType === i.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(t, e, o, n, s, r) : t.physicsType === i.GROUP ? e.physicsType === i.SPRITE ? this.collideSpriteVsGroup(e, t, o, n, s, r) : e.physicsType === i.GROUP ? this.collideGroupVsGroup(t, e, o, n, s, r) : e.physicsType === i.TILEMAPLAYER && this.collideGroupVsTilemapLayer(t, e, o, n, s, r) : t.physicsType === i.TILEMAPLAYER && (e.physicsType === i.SPRITE ? this.collideSpriteVsTilemapLayer(e, t, o, n, s, r) : e.physicsType === i.GROUP && this.collideGroupVsTilemapLayer(e, t, o, n, s, r))) }, collideSpriteVsSprite: function(t, e, i, o, n, s) { return !(!t.body || !e.body) && (this.separate(t.body, e.body, o, n, s) && (i && i.call(n, t, e), this._total++), !0) }, collideSpriteVsGroup: function(t, e, o, n, s, r) { if (0 !== e.length && t.body)
                    if (this.skipQuadTree || t.body.skipQuadTree)
                        for (var a = {}, h = 0; h < e.hash.length; h++) { var l = e.hash[h]; if (l && l.exists && l.body) { if (a = l.body.getBounds(a), this.sortDirection === i.Physics.Arcade.LEFT_RIGHT) { if (t.body.right < a.x) break; if (a.right < t.body.x) continue } else if (this.sortDirection === i.Physics.Arcade.RIGHT_LEFT) { if (t.body.x > a.right) break; if (a.x > t.body.right) continue } else if (this.sortDirection === i.Physics.Arcade.TOP_BOTTOM) { if (t.body.bottom < a.y) break; if (a.bottom < t.body.y) continue } else if (this.sortDirection === i.Physics.Arcade.BOTTOM_TOP) { if (t.body.y > a.bottom) break; if (a.y > t.body.bottom) continue } this.collideSpriteVsSprite(t, l, o, n, s, r) } } else { this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(e); for (var c = this.quadTree.retrieve(t), h = 0; h < c.length; h++) this.separate(t.body, c[h], n, s, r) && (o && o.call(s, t, c[h].sprite), this._total++) } }, collideGroupVsSelf: function(t, e, o, n, s) { if (0 !== t.length)
                    for (var r = 0; r < t.hash.length; r++) { var a = {},
                            h = t.hash[r]; if (h && h.exists && h.body) { a = h.body.getBounds(a); for (var l = r + 1; l < t.hash.length; l++) { var c = {},
                                    d = t.hash[l]; if (d && d.exists && d.body) { if (c = d.body.getBounds(c), this.sortDirection === i.Physics.Arcade.LEFT_RIGHT) { if (a.right < c.x) break; if (c.right < a.x) continue } else if (this.sortDirection === i.Physics.Arcade.RIGHT_LEFT) { if (a.x > c.right) continue; if (c.x > a.right) break } else if (this.sortDirection === i.Physics.Arcade.TOP_BOTTOM) { if (a.bottom < c.y) continue; if (c.bottom < a.y) break } else if (this.sortDirection === i.Physics.Arcade.BOTTOM_TOP) { if (a.y > c.bottom) continue; if (c.y > h.body.bottom) break } this.collideSpriteVsSprite(h, d, e, o, n, s) } } } } }, collideGroupVsGroup: function(t, e, o, n, s, r) { if (0 !== t.length && 0 !== e.length)
                    for (var a = 0; a < t.children.length; a++) t.children[a].exists && (t.children[a].physicsType === i.GROUP ? this.collideGroupVsGroup(t.children[a], e, o, n, s, r) : this.collideSpriteVsGroup(t.children[a], e, o, n, s, r)) }, separate: function(t, e, i, o, n) { if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1; if (i && !1 === i.call(o, t.sprite, e.sprite)) return !1; if (t.isCircle && e.isCircle) return this.separateCircle(t, e, n); if (t.isCircle !== e.isCircle) { var s = t.isCircle ? e : t,
                        r = t.isCircle ? t : e,
                        a = { x: s.x, y: s.y, right: s.right, bottom: s.bottom },
                        h = { x: r.x + r.radius, y: r.y + r.radius }; if ((h.y < a.y || h.y > a.bottom) && (h.x < a.x || h.x > a.right)) return this.separateCircle(t, e, n) } var l = !1,
                    c = !1;
                this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (l = this.separateX(t, e, n), this.intersects(t, e) && (c = this.separateY(t, e, n))) : (c = this.separateY(t, e, n), this.intersects(t, e) && (l = this.separateX(t, e, n))); var d = l || c; return d && (n ? (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)) : (t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite))), d }, intersects: function(t, e) { return t !== e && (t.isCircle ? e.isCircle ? i.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y) <= t.radius + e.radius : this.circleBodyIntersects(t, e) : e.isCircle ? this.circleBodyIntersects(e, t) : !(t.right <= e.position.x) && (!(t.bottom <= e.position.y) && (!(t.position.x >= e.right) && !(t.position.y >= e.bottom)))) }, circleBodyIntersects: function(t, e) { var o = i.Math.clamp(t.center.x, e.left, e.right),
                    n = i.Math.clamp(t.center.y, e.top, e.bottom); return (t.center.x - o) * (t.center.x - o) + (t.center.y - n) * (t.center.y - n) <= t.radius * t.radius }, separateCircle: function(t, e, o) { this.getOverlapX(t, e), this.getOverlapY(t, e); var n = e.center.x - t.center.x,
                    s = e.center.y - t.center.y,
                    r = Math.atan2(s, n),
                    a = 0; if (t.isCircle !== e.isCircle) { var h = { x: e.isCircle ? t.position.x : e.position.x, y: e.isCircle ? t.position.y : e.position.y, right: e.isCircle ? t.right : e.right, bottom: e.isCircle ? t.bottom : e.bottom },
                        l = { x: t.isCircle ? t.position.x + t.radius : e.position.x + e.radius, y: t.isCircle ? t.position.y + t.radius : e.position.y + e.radius, radius: t.isCircle ? t.radius : e.radius };
                    l.y < h.y ? l.x < h.x ? a = i.Math.distance(l.x, l.y, h.x, h.y) - l.radius : l.x > h.right && (a = i.Math.distance(l.x, l.y, h.right, h.y) - l.radius) : l.y > h.bottom && (l.x < h.x ? a = i.Math.distance(l.x, l.y, h.x, h.bottom) - l.radius : l.x > h.right && (a = i.Math.distance(l.x, l.y, h.right, h.bottom) - l.radius)), a *= -1 } else a = t.radius + e.radius - i.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y); if (o || 0 === a || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== a && (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)), 0 !== a; var c = { x: t.velocity.x * Math.cos(r) + t.velocity.y * Math.sin(r), y: t.velocity.x * Math.sin(r) - t.velocity.y * Math.cos(r) },
                    d = { x: e.velocity.x * Math.cos(r) + e.velocity.y * Math.sin(r), y: e.velocity.x * Math.sin(r) - e.velocity.y * Math.cos(r) },
                    u = ((t.mass - e.mass) * c.x + 2 * e.mass * d.x) / (t.mass + e.mass),
                    p = (2 * t.mass * c.x + (e.mass - t.mass) * d.x) / (t.mass + e.mass); return t.immovable || (t.velocity.x = (u * Math.cos(r) - c.y * Math.sin(r)) * t.bounce.x, t.velocity.y = (c.y * Math.cos(r) + u * Math.sin(r)) * t.bounce.y), e.immovable || (e.velocity.x = (p * Math.cos(r) - d.y * Math.sin(r)) * e.bounce.x, e.velocity.y = (d.y * Math.cos(r) + p * Math.sin(r)) * e.bounce.y), Math.abs(r) < Math.PI / 2 ? t.velocity.x > 0 && !t.immovable && e.velocity.x > t.velocity.x ? t.velocity.x *= -1 : e.velocity.x < 0 && !e.immovable && t.velocity.x < e.velocity.x ? e.velocity.x *= -1 : t.velocity.y > 0 && !t.immovable && e.velocity.y > t.velocity.y ? t.velocity.y *= -1 : e.velocity.y < 0 && !e.immovable && t.velocity.y < e.velocity.y && (e.velocity.y *= -1) : Math.abs(r) > Math.PI / 2 && (t.velocity.x < 0 && !t.immovable && e.velocity.x < t.velocity.x ? t.velocity.x *= -1 : e.velocity.x > 0 && !e.immovable && t.velocity.x > e.velocity.x ? e.velocity.x *= -1 : t.velocity.y < 0 && !t.immovable && e.velocity.y < t.velocity.y ? t.velocity.y *= -1 : e.velocity.y > 0 && !e.immovable && t.velocity.x > e.velocity.y && (e.velocity.y *= -1)), t.immovable || (t.x += t.velocity.x * this.game.time.physicsElapsed - a * Math.cos(r), t.y += t.velocity.y * this.game.time.physicsElapsed - a * Math.sin(r)), e.immovable || (e.x += e.velocity.x * this.game.time.physicsElapsed + a * Math.cos(r), e.y += e.velocity.y * this.game.time.physicsElapsed + a * Math.sin(r)), t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite), !0 }, getOverlapX: function(t, e, i) { var o = 0,
                    n = t.deltaAbsX() + e.deltaAbsX() + this.OVERLAP_BIAS; return 0 === t.deltaX() && 0 === e.deltaX() ? (t.embedded = !0, e.embedded = !0) : t.deltaX() > e.deltaX() ? (o = t.right - e.x) > n && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? o = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0) : t.deltaX() < e.deltaX() && (-(o = t.x - e.width - e.x) > n && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? o = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0)), t.overlapX = o, e.overlapX = o, o }, getOverlapY: function(t, e, i) { var o = 0,
                    n = t.deltaAbsY() + e.deltaAbsY() + this.OVERLAP_BIAS; return 0 === t.deltaY() && 0 === e.deltaY() ? (t.embedded = !0, e.embedded = !0) : t.deltaY() > e.deltaY() ? (o = t.bottom - e.y) > n && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? o = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0) : t.deltaY() < e.deltaY() && (-(o = t.y - e.bottom) > n && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? o = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0)), t.overlapY = o, e.overlapY = o, o }, separateX: function(t, e, i) { var o = this.getOverlapX(t, e, i); if (i || 0 === o || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== o || t.embedded && e.embedded; var n = t.velocity.x,
                    s = e.velocity.x; if (t.immovable || e.immovable) t.immovable ? (e.x += o, e.velocity.x = n - s * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= o, t.velocity.x = s - n * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y));
                else { o *= .5, t.x -= o, e.x += o; var r = Math.sqrt(s * s * e.mass / t.mass) * (s > 0 ? 1 : -1),
                        a = Math.sqrt(n * n * t.mass / e.mass) * (n > 0 ? 1 : -1),
                        h = .5 * (r + a);
                    r -= h, a -= h, t.velocity.x = h + r * t.bounce.x, e.velocity.x = h + a * e.bounce.x } return !0 }, separateY: function(t, e, i) { var o = this.getOverlapY(t, e, i); if (i || 0 === o || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return 0 !== o || t.embedded && e.embedded; var n = t.velocity.y,
                    s = e.velocity.y; if (t.immovable || e.immovable) t.immovable ? (e.y += o, e.velocity.y = n - s * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= o, t.velocity.y = s - n * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x));
                else { o *= .5, t.y -= o, e.y += o; var r = Math.sqrt(s * s * e.mass / t.mass) * (s > 0 ? 1 : -1),
                        a = Math.sqrt(n * n * t.mass / e.mass) * (n > 0 ? 1 : -1),
                        h = .5 * (r + a);
                    r -= h, a -= h, t.velocity.y = h + r * t.bounce.y, e.velocity.y = h + a * e.bounce.y } return !0 }, getObjectsUnderPointer: function(t, e, i, o) { if (0 !== e.length && t.exists) return this.getObjectsAtLocation(t.x, t.y, e, i, o, t) }, getObjectsAtLocation: function(t, e, o, n, s, r) { this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(o); for (var a = new i.Rectangle(t, e, 1, 1), h = [], l = this.quadTree.retrieve(a), c = 0; c < l.length; c++) l[c].hitTest(t, e) && (n && n.call(s, r, l[c].sprite), h.push(l[c].sprite)); return h }, moveToObject: function(t, e, i, o) { void 0 === i && (i = 60), void 0 === o && (o = 0); var n = Math.atan2(e.y - t.y, e.x - t.x); return o > 0 && (i = this.distanceBetween(t, e) / (o / 1e3)), t.body.velocity.x = Math.cos(n) * i, t.body.velocity.y = Math.sin(n) * i, n }, moveToPointer: function(t, e, i, o) { void 0 === e && (e = 60), i = i || this.game.input.activePointer, void 0 === o && (o = 0); var n = this.angleToPointer(t, i); return o > 0 && (e = this.distanceToPointer(t, i) / (o / 1e3)), t.body.velocity.x = Math.cos(n) * e, t.body.velocity.y = Math.sin(n) * e, n }, moveToXY: function(t, e, i, o, n) { void 0 === o && (o = 60), void 0 === n && (n = 0); var s = Math.atan2(i - t.y, e - t.x); return n > 0 && (o = this.distanceToXY(t, e, i) / (n / 1e3)), t.body.velocity.x = Math.cos(s) * o, t.body.velocity.y = Math.sin(s) * o, s }, velocityFromAngle: function(t, e, o) { return void 0 === e && (e = 60), (o = o || new i.Point).setTo(Math.cos(this.game.math.degToRad(t)) * e, Math.sin(this.game.math.degToRad(t)) * e) }, velocityFromRotation: function(t, e, o) { return void 0 === e && (e = 60), (o = o || new i.Point).setTo(Math.cos(t) * e, Math.sin(t) * e) }, accelerationFromRotation: function(t, e, o) { return void 0 === e && (e = 60), (o = o || new i.Point).setTo(Math.cos(t) * e, Math.sin(t) * e) }, accelerateToObject: function(t, e, i, o, n) { void 0 === i && (i = 60), void 0 === o && (o = 1e3), void 0 === n && (n = 1e3); var s = this.angleBetween(t, e); return t.body.acceleration.setTo(Math.cos(s) * i, Math.sin(s) * i), t.body.maxVelocity.setTo(o, n), s }, accelerateToPointer: function(t, e, i, o, n) { void 0 === i && (i = 60), void 0 === e && (e = this.game.input.activePointer), void 0 === o && (o = 1e3), void 0 === n && (n = 1e3); var s = this.angleToPointer(t, e); return t.body.acceleration.setTo(Math.cos(s) * i, Math.sin(s) * i), t.body.maxVelocity.setTo(o, n), s }, accelerateToXY: function(t, e, i, o, n, s) { void 0 === o && (o = 60), void 0 === n && (n = 1e3), void 0 === s && (s = 1e3); var r = this.angleToXY(t, e, i); return t.body.acceleration.setTo(Math.cos(r) * o, Math.sin(r) * o), t.body.maxVelocity.setTo(n, s), r }, distanceBetween: function(t, e, i) { void 0 === i && (i = !1); var o = i ? t.world.x - e.world.x : t.x - e.x,
                    n = i ? t.world.y - e.world.y : t.y - e.y; return Math.sqrt(o * o + n * n) }, distanceToXY: function(t, e, i, o) { void 0 === o && (o = !1); var n = o ? t.world.x - e : t.x - e,
                    s = o ? t.world.y - i : t.y - i; return Math.sqrt(n * n + s * s) }, distanceToPointer: function(t, e, i) { void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1); var o = i ? t.world.x - e.worldX : t.x - e.worldX,
                    n = i ? t.world.y - e.worldY : t.y - e.worldY; return Math.sqrt(o * o + n * n) }, angleBetween: function(t, e, i) { return void 0 === i && (i = !1), i ? Math.atan2(e.world.y - t.world.y, e.world.x - t.world.x) : Math.atan2(e.y - t.y, e.x - t.x) }, angleBetweenCenters: function(t, e) { var i = e.centerX - t.centerX,
                    o = e.centerY - t.centerY; return Math.atan2(o, i) }, angleToXY: function(t, e, i, o) { return void 0 === o && (o = !1), o ? Math.atan2(i - t.world.y, e - t.world.x) : Math.atan2(i - t.y, e - t.x) }, angleToPointer: function(t, e, i) { return void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1), i ? Math.atan2(e.worldY - t.world.y, e.worldX - t.world.x) : Math.atan2(e.worldY - t.y, e.worldX - t.x) }, worldAngleToPointer: function(t, e) { return this.angleToPointer(t, e, !0) } }, i.Physics.Arcade.Body = function(t) { this.sprite = t, this.game = t.game, this.type = i.Physics.ARCADE, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new i.Point, this.position = new i.Point(t.x, t.y), this.prev = new i.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = t.angle, this.preRotation = t.angle, this.width = t.width, this.height = t.height, this.sourceWidth = t.width, this.sourceHeight = t.height, t.texture && (this.sourceWidth = t.texture.frame.width, this.sourceHeight = t.texture.frame.height), this.halfWidth = Math.abs(t.width / 2), this.halfHeight = Math.abs(t.height / 2), this.center = new i.Point(t.x + this.halfWidth, t.y + this.halfHeight), this.velocity = new i.Point, this.newVelocity = new i.Point, this.deltaMax = new i.Point, this.acceleration = new i.Point, this.drag = new i.Point, this.allowGravity = !0, this.gravity = new i.Point, this.bounce = new i.Point, this.worldBounce = null, this.onWorldBounds = null, this.onCollide = null, this.onOverlap = null, this.maxVelocity = new i.Point(1e4, 1e4), this.friction = new i.Point(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = i.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = { none: !1, any: !0, up: !0, down: !0, left: !0, right: !0 }, this.touching = { none: !0, up: !1, down: !1, left: !1, right: !1 }, this.wasTouching = { none: !0, up: !1, down: !1, left: !1, right: !1 }, this.blocked = { up: !1, down: !1, left: !1, right: !1 }, this.tilePadding = new i.Point, this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.moveTimer = 0, this.moveDistance = 0, this.moveDuration = 0, this.moveTarget = null, this.moveEnd = null, this.onMoveComplete = new i.Signal, this.movementCallback = null, this.movementCallbackContext = null, this._reset = !0, this._sx = t.scale.x, this._sy = t.scale.y, this._dx = 0, this._dy = 0 }, i.Physics.Arcade.Body.prototype = { updateBounds: function() { if (this.syncBounds) { var t = this.sprite.getBounds();
                    t.ceilAll(), t.width === this.width && t.height === this.height || (this.width = t.width, this.height = t.height, this._reset = !0) } else { var e = Math.abs(this.sprite.scale.x),
                        i = Math.abs(this.sprite.scale.y);
                    e === this._sx && i === this._sy || (this.width = this.sourceWidth * e, this.height = this.sourceHeight * i, this._sx = e, this._sy = i, this._reset = !0) } this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)) }, preUpdate: function() { this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1) }, updateMovement: function() { var t = 0,
                    e = 0 !== this.overlapX || 0 !== this.overlapY; if (this.moveDuration > 0 ? (this.moveTimer += this.game.time.elapsedMS, t = this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), t = this.moveTarget.length / this.moveDistance), this.movementCallback) var i = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, t); return !(e || t >= 1 || void 0 !== i && !0 !== i) || (this.stopMovement(t >= 1 || this.stopVelocityOnCollide && e), !1) }, stopMovement: function(t) { this.isMoving && (this.isMoving = !1, t && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY)) }, postUpdate: function() { this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = i.LEFT : this.deltaX() > 0 && (this.facing = i.RIGHT), this.deltaY() < 0 ? this.facing = i.UP : this.deltaY() > 0 && (this.facing = i.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y) }, checkWorldBounds: function() { var t = this.position,
                    e = this.game.physics.arcade.bounds,
                    i = this.game.physics.arcade.checkCollision,
                    o = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
                    n = this.worldBounce ? -this.worldBounce.y : -this.bounce.y; if (this.isCircle) { var s = { x: this.center.x - this.radius, y: this.center.y - this.radius, right: this.center.x + this.radius, bottom: this.center.y + this.radius };
                    s.x < e.x && i.left ? (t.x = e.x - this.halfWidth + this.radius, this.velocity.x *= o, this.blocked.left = !0) : s.right > e.right && i.right && (t.x = e.right - this.halfWidth - this.radius, this.velocity.x *= o, this.blocked.right = !0), s.y < e.y && i.up ? (t.y = e.y - this.halfHeight + this.radius, this.velocity.y *= n, this.blocked.up = !0) : s.bottom > e.bottom && i.down && (t.y = e.bottom - this.halfHeight - this.radius, this.velocity.y *= n, this.blocked.down = !0) } else t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= o, this.blocked.left = !0) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= o, this.blocked.right = !0), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= n, this.blocked.up = !0) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= n, this.blocked.down = !0); return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right }, moveFrom: function(t, e, i) { if (void 0 === e && (e = this.speed), 0 === e) return !1; var o; return void 0 === i ? (o = this.angle, i = this.game.math.radToDeg(o)) : o = this.game.math.degToRad(i), this.moveTimer = 0, this.moveDuration = t, 0 === i || 180 === i ? this.velocity.set(Math.cos(o) * e, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(o) * e) : this.velocity.set(Math.cos(o) * e, Math.sin(o) * e), this.isMoving = !0, !0 }, moveTo: function(t, e, o) { var n = e / (t / 1e3); if (0 === n) return !1; var s; return void 0 === o ? (s = this.angle, o = this.game.math.radToDeg(s)) : s = this.game.math.degToRad(o), e = Math.abs(e), this.moveDuration = 0, this.moveDistance = e, null === this.moveTarget && (this.moveTarget = new i.Line, this.moveEnd = new i.Point), this.moveTarget.fromAngle(this.x, this.y, s, e), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === o || 180 === o ? this.velocity.set(Math.cos(s) * n, 0) : 90 === o || 270 === o ? this.velocity.set(0, Math.sin(s) * n) : this.velocity.set(Math.cos(s) * n, Math.sin(s) * n), this.isMoving = !0, !0 }, setSize: function(t, e, i, o) { void 0 === i && (i = this.offset.x), void 0 === o && (o = this.offset.y), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(i, o), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.isCircle = !1, this.radius = 0 }, setCircle: function(t, e, i) { void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(e, i), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)) : this.isCircle = !1 }, reset: function(t, e) { this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this.position.x = t - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = e - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight) }, getBounds: function(t) { return this.isCircle ? (t.x = this.center.x - this.radius, t.y = this.center.y - this.radius, t.right = this.center.x + this.radius, t.bottom = this.center.y + this.radius) : (t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom), t }, hitTest: function(t, e) { return this.isCircle ? i.Circle.contains(this, t, e) : i.Rectangle.contains(this, t, e) }, onFloor: function() { return this.blocked.down }, onCeiling: function() { return this.blocked.up }, onWall: function() { return this.blocked.left || this.blocked.right }, deltaAbsX: function() { return this.deltaX() > 0 ? this.deltaX() : -this.deltaX() }, deltaAbsY: function() { return this.deltaY() > 0 ? this.deltaY() : -this.deltaY() }, deltaX: function() { return this.position.x - this.prev.x }, deltaY: function() { return this.position.y - this.prev.y }, deltaZ: function() { return this.rotation - this.preRotation }, destroy: function() { this.sprite.parent && this.sprite.parent instanceof i.Group && this.sprite.parent.removeFromHash(this.sprite), this.sprite.body = null, this.sprite = null } }, Object.defineProperty(i.Physics.Arcade.Body.prototype, "left", { get: function() { return this.position.x } }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "right", { get: function() { return this.position.x + this.width } }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "top", { get: function() { return this.position.y } }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "bottom", { get: function() { return this.position.y + this.height } }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "x", { get: function() { return this.position.x }, set: function(t) { this.position.x = t } }), Object.defineProperty(i.Physics.Arcade.Body.prototype, "y", { get: function() { return this.position.y }, set: function(t) { this.position.y = t } }), i.Physics.Arcade.Body.render = function(t, e, i, o) { void 0 === o && (o = !0), i = i || "rgba(0,255,0,0.4)", t.fillStyle = i, t.strokeStyle = i, e.isCircle ? (t.beginPath(), t.arc(e.center.x - e.game.camera.x, e.center.y - e.game.camera.y, e.radius, 0, 2 * Math.PI), o ? t.fill() : t.stroke()) : o ? t.fillRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height) : t.strokeRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height) }, i.Physics.Arcade.Body.renderBodyInfo = function(t, e) { t.line("x: " + e.x.toFixed(2), "y: " + e.y.toFixed(2), "width: " + e.width, "height: " + e.height), t.line("velocity x: " + e.velocity.x.toFixed(2), "y: " + e.velocity.y.toFixed(2), "deltaX: " + e._dx.toFixed(2), "deltaY: " + e._dy.toFixed(2)), t.line("acceleration x: " + e.acceleration.x.toFixed(2), "y: " + e.acceleration.y.toFixed(2), "speed: " + e.speed.toFixed(2), "angle: " + e.angle.toFixed(2)), t.line("gravity x: " + e.gravity.x, "y: " + e.gravity.y, "bounce x: " + e.bounce.x.toFixed(2), "y: " + e.bounce.y.toFixed(2)), t.line("touching left: " + e.touching.left, "right: " + e.touching.right, "up: " + e.touching.up, "down: " + e.touching.down), t.line("blocked left: " + e.blocked.left, "right: " + e.blocked.right, "up: " + e.blocked.up, "down: " + e.blocked.down) }, i.Physics.Arcade.Body.prototype.constructor = i.Physics.Arcade.Body, i.Physics.Arcade.TilemapCollision = function() {}, i.Physics.Arcade.TilemapCollision.prototype = { TILE_BIAS: 16, collideSpriteVsTilemapLayer: function(t, e, i, o, n, s) { if (t.body) { var r = e.getTiles(t.body.position.x - t.body.tilePadding.x, t.body.position.y - t.body.tilePadding.y, t.body.width + t.body.tilePadding.x, t.body.height + t.body.tilePadding.y, !1, !1); if (0 !== r.length)
                        for (var a = 0; a < r.length; a++) o ? o.call(n, t, r[a]) && this.separateTile(a, t.body, r[a], e, s) && (this._total++, i && i.call(n, t, r[a])) : this.separateTile(a, t.body, r[a], e, s) && (this._total++, i && i.call(n, t, r[a])) } }, collideGroupVsTilemapLayer: function(t, e, i, o, n, s) { if (0 !== t.length)
                    for (var r = 0; r < t.children.length; r++) t.children[r].exists && this.collideSpriteVsTilemapLayer(t.children[r], e, i, o, n, s) }, separateTile: function(t, e, i, o, n) { if (!e.enable) return !1; var s = o.fixedToCamera ? 0 : o.position.x,
                    r = o.fixedToCamera ? 0 : o.position.y; if (!i.intersects(e.position.x - s, e.position.y - r, e.right - s, e.bottom - r)) return !1; if (n) return !0; if (i.collisionCallback && !i.collisionCallback.call(i.collisionCallbackContext, e.sprite, i)) return !1; if (void 0 !== i.layer.callbacks && i.layer.callbacks[i.index] && !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, e.sprite, i)) return !1; if (!(i.faceLeft || i.faceRight || i.faceTop || i.faceBottom)) return !1; var a = 0,
                    h = 0,
                    l = 0,
                    c = 1; if (e.deltaAbsX() > e.deltaAbsY() ? l = -1 : e.deltaAbsX() < e.deltaAbsY() && (c = -1), 0 !== e.deltaX() && 0 !== e.deltaY() && (i.faceLeft || i.faceRight) && (i.faceTop || i.faceBottom) && (l = Math.min(Math.abs(e.position.x - s - i.right), Math.abs(e.right - s - i.left)), c = Math.min(Math.abs(e.position.y - r - i.bottom), Math.abs(e.bottom - r - i.top))), l < c) { if ((i.faceLeft || i.faceRight) && 0 !== (a = this.tileCheckX(e, i, o)) && !i.intersects(e.position.x - s, e.position.y - r, e.right - s, e.bottom - r)) return !0;
                    (i.faceTop || i.faceBottom) && (h = this.tileCheckY(e, i, o)) } else { if ((i.faceTop || i.faceBottom) && 0 !== (h = this.tileCheckY(e, i, o)) && !i.intersects(e.position.x - s, e.position.y - r, e.right - s, e.bottom - r)) return !0;
                    (i.faceLeft || i.faceRight) && (a = this.tileCheckX(e, i, o)) } return 0 !== a || 0 !== h }, tileCheckX: function(t, e, i) { var o = 0,
                    n = i.fixedToCamera ? 0 : i.position.x; return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x - n < e.right && (o = t.x - n - e.right) < -this.TILE_BIAS && (o = 0) : t.deltaX() > 0 && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right - n > e.left && (o = t.right - n - e.left) > this.TILE_BIAS && (o = 0), 0 !== o && (t.customSeparateX ? t.overlapX = o : this.processTileSeparationX(t, o)), o }, tileCheckY: function(t, e, i) { var o = 0,
                    n = i.fixedToCamera ? 0 : i.position.y; return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y - n < e.bottom && (o = t.y - n - e.bottom) < -this.TILE_BIAS && (o = 0) : t.deltaY() > 0 && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom - n > e.top && (o = t.bottom - n - e.top) > this.TILE_BIAS && (o = 0), 0 !== o && (t.customSeparateY ? t.overlapY = o : this.processTileSeparationY(t, o)), o }, processTileSeparationX: function(t, e) { e < 0 ? t.blocked.left = !0 : e > 0 && (t.blocked.right = !0), t.position.x -= e, 0 === t.bounce.x ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x }, processTileSeparationY: function(t, e) { e < 0 ? t.blocked.up = !0 : e > 0 && (t.blocked.down = !0), t.position.y -= e, 0 === t.bounce.y ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y } }, i.Utils.mixinPrototype(i.Physics.Arcade.prototype, i.Physics.Arcade.TilemapCollision.prototype), p2.Body.prototype.parent = null, p2.Spring.prototype.parent = null, i.Physics.P2 = function(t, e) { this.game = t, void 0 === e ? e = { gravity: [0, 0], broadphase: new p2.SAPBroadphase } : (e.hasOwnProperty("gravity") || (e.gravity = [0, 0]), e.hasOwnProperty("broadphase") || (e.broadphase = new p2.SAPBroadphase)), this.config = e, this.world = new p2.World(this.config), this.frameRate = 1 / 60, this.useElapsedTime = !1, this.paused = !1, this.materials = [], this.gravity = new i.Physics.P2.InversePointProxy(this, this.world.gravity), this.walls = { left: null, right: null, top: null, bottom: null }, this.onBodyAdded = new i.Signal, this.onBodyRemoved = new i.Signal, this.onSpringAdded = new i.Signal, this.onSpringRemoved = new i.Signal, this.onConstraintAdded = new i.Signal, this.onConstraintRemoved = new i.Signal, this.onContactMaterialAdded = new i.Signal, this.onContactMaterialRemoved = new i.Signal, this.postBroadphaseCallback = null, this.callbackContext = null, this.onBeginContact = new i.Signal, this.onEndContact = new i.Signal, e.hasOwnProperty("mpx") && e.hasOwnProperty("pxm") && e.hasOwnProperty("mpxi") && e.hasOwnProperty("pxmi") && (this.mpx = e.mpx, this.mpxi = e.mpxi, this.pxm = e.pxm, this.pxmi = e.pxmi), this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.collisionGroups = [], this.nothingCollisionGroup = new i.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new i.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new i.Physics.P2.CollisionGroup(2147483648), this.boundsCollidesWith = [], this._toRemove = [], this._collisionGroupID = 2, this._boundsLeft = !0, this._boundsRight = !0, this._boundsTop = !0, this._boundsBottom = !0, this._boundsOwnGroup = !1, this.setBoundsToWorld(!0, !0, !0, !0, !1) }, i.Physics.P2.prototype = { removeBodyNextStep: function(t) { this._toRemove.push(t) }, preUpdate: function() { for (var t = this._toRemove.length; t--;) this.removeBody(this._toRemove[t]);
                this._toRemove.length = 0 }, enable: function(t, e, o) { void 0 === e && (e = !1), void 0 === o && (o = !0); var n = 1; if (Array.isArray(t))
                    for (n = t.length; n--;) t[n] instanceof i.Group ? this.enable(t[n].children, e, o) : (this.enableBody(t[n], e), o && t[n].hasOwnProperty("children") && t[n].children.length > 0 && this.enable(t[n], e, !0));
                else t instanceof i.Group ? this.enable(t.children, e, o) : (this.enableBody(t, e), o && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, e, !0)) }, enableBody: function(t, e) { t.hasOwnProperty("body") && null === t.body && (t.body = new i.Physics.P2.Body(this.game, t, t.x, t.y, 1), t.body.debug = e, void 0 !== t.anchor && t.anchor.set(.5)) }, setImpactEvents: function(t) { t ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this) }, setPostBroadphaseCallback: function(t, e) { this.postBroadphaseCallback = t, this.callbackContext = e, null !== t ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this) }, postBroadphaseHandler: function(t) { if (this.postBroadphaseCallback && 0 !== t.pairs.length)
                    for (var e = t.pairs.length - 2; e >= 0; e -= 2) t.pairs[e].parent && t.pairs[e + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, t.pairs[e].parent, t.pairs[e + 1].parent) && t.pairs.splice(e, 2) }, impactHandler: function(t) { if (t.bodyA.parent && t.bodyB.parent) { var e = t.bodyA.parent,
                        i = t.bodyB.parent;
                    e._bodyCallbacks[t.bodyB.id] && e._bodyCallbacks[t.bodyB.id].call(e._bodyCallbackContext[t.bodyB.id], e, i, t.shapeA, t.shapeB), i._bodyCallbacks[t.bodyA.id] && i._bodyCallbacks[t.bodyA.id].call(i._bodyCallbackContext[t.bodyA.id], i, e, t.shapeB, t.shapeA), e._groupCallbacks[t.shapeB.collisionGroup] && e._groupCallbacks[t.shapeB.collisionGroup].call(e._groupCallbackContext[t.shapeB.collisionGroup], e, i, t.shapeA, t.shapeB), i._groupCallbacks[t.shapeA.collisionGroup] && i._groupCallbacks[t.shapeA.collisionGroup].call(i._groupCallbackContext[t.shapeA.collisionGroup], i, e, t.shapeB, t.shapeA) } }, beginContactHandler: function(t) { t.bodyA && t.bodyB && (this.onBeginContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyA.parent && t.bodyA.parent.onBeginContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyB.parent && t.bodyB.parent.onBeginContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA, t.contactEquations)) }, endContactHandler: function(t) { t.bodyA && t.bodyB && (this.onEndContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB), t.bodyA.parent && t.bodyA.parent.onEndContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB), t.bodyB.parent && t.bodyB.parent.onEndContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA)) }, setBoundsToWorld: function(t, e, i, o, n) { this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, t, e, i, o, n) }, setWorldMaterial: function(t, e, i, o, n) { void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === o && (o = !0), void 0 === n && (n = !0), e && this.walls.left && (this.walls.left.shapes[0].material = t), i && this.walls.right && (this.walls.right.shapes[0].material = t), o && this.walls.top && (this.walls.top.shapes[0].material = t), n && this.walls.bottom && (this.walls.bottom.shapes[0].material = t) }, updateBoundsCollisionGroup: function(t) { void 0 === t && (t = !0); var e = t ? this.boundsCollisionGroup.mask : this.everythingCollisionGroup.mask;
                this.walls.left && (this.walls.left.shapes[0].collisionGroup = e), this.walls.right && (this.walls.right.shapes[0].collisionGroup = e), this.walls.top && (this.walls.top.shapes[0].collisionGroup = e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = e), this._boundsOwnGroup = t }, setBounds: function(t, e, i, o, n, s, r, a, h) { void 0 === n && (n = this._boundsLeft), void 0 === s && (s = this._boundsRight), void 0 === r && (r = this._boundsTop), void 0 === a && (a = this._boundsBottom), void 0 === h && (h = this._boundsOwnGroup), this.setupWall(n, "left", t, e, 1.5707963267948966, h), this.setupWall(s, "right", t + i, e, -1.5707963267948966, h), this.setupWall(r, "top", t, e, -3.141592653589793, h), this.setupWall(a, "bottom", t, e + o, 0, h), this._boundsLeft = n, this._boundsRight = s, this._boundsTop = r, this._boundsBottom = a, this._boundsOwnGroup = h }, setupWall: function(t, e, i, o, n, s) { t ? (this.walls[e] ? this.walls[e].position = [this.pxmi(i), this.pxmi(o)] : (this.walls[e] = new p2.Body({ mass: 0, position: [this.pxmi(i), this.pxmi(o)], angle: n }), this.walls[e].addShape(new p2.Plane), this.world.addBody(this.walls[e])), s && (this.walls[e].shapes[0].collisionGroup = this.boundsCollisionGroup.mask)) : this.walls[e] && (this.world.removeBody(this.walls[e]), this.walls[e] = null) }, pause: function() { this.paused = !0 }, resume: function() { this.paused = !1 }, update: function() { this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate)) }, reset: function() { this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.nothingCollisionGroup = new i.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new i.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new i.Physics.P2.CollisionGroup(2147483648), this._collisionGroupID = 2, this.setBoundsToWorld(!0, !0, !0, !0, !1) }, clear: function() { this.world.time = 0, this.world.fixedStepTime = 0, this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations(); for (var t = this.world.constraints, e = t.length - 1; e >= 0; e--) this.world.removeConstraint(t[e]); for (var i = this.world.bodies, e = i.length - 1; e >= 0; e--) this.world.removeBody(i[e]); for (var o = this.world.springs, e = o.length - 1; e >= 0; e--) this.world.removeSpring(o[e]); for (var n = this.world.contactMaterials, e = n.length - 1; e >= 0; e--) this.world.removeContactMaterial(n[e]);
                this.world.off("beginContact", this.beginContactHandler, this), this.world.off("endContact", this.endContactHandler, this), this.postBroadphaseCallback = null, this.callbackContext = null, this.impactCallback = null, this.collisionGroups = [], this._toRemove = [], this.boundsCollidesWith = [], this.walls = { left: null, right: null, top: null, bottom: null } }, destroy: function() { this.clear(), this.game = null }, addBody: function(t) { return !t.data.world && (this.world.addBody(t.data), this.onBodyAdded.dispatch(t), !0) }, removeBody: function(t) { return t.data.world === this.world && (this.world.removeBody(t.data), this.onBodyRemoved.dispatch(t)), t }, addSpring: function(t) { return t instanceof i.Physics.P2.Spring || t instanceof i.Physics.P2.RotationalSpring ? this.world.addSpring(t.data) : this.world.addSpring(t), this.onSpringAdded.dispatch(t), t }, removeSpring: function(t) { return t instanceof i.Physics.P2.Spring || t instanceof i.Physics.P2.RotationalSpring ? this.world.removeSpring(t.data) : this.world.removeSpring(t), this.onSpringRemoved.dispatch(t), t }, createDistanceConstraint: function(t, e, o, n, s, r) { if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new i.Physics.P2.DistanceConstraint(this, t, e, o, n, s, r)) }, createGearConstraint: function(t, e, o, n) { if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new i.Physics.P2.GearConstraint(this, t, e, o, n)) }, createRevoluteConstraint: function(t, e, o, n, s, r) { if (t = this.getBody(t), o = this.getBody(o), t && o) return this.addConstraint(new i.Physics.P2.RevoluteConstraint(this, t, e, o, n, s, r)) }, createLockConstraint: function(t, e, o, n, s) { if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new i.Physics.P2.LockConstraint(this, t, e, o, n, s)) }, createPrismaticConstraint: function(t, e, o, n, s, r, a) { if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new i.Physics.P2.PrismaticConstraint(this, t, e, o, n, s, r, a)) }, addConstraint: function(t) { return this.world.addConstraint(t), this.onConstraintAdded.dispatch(t), t }, removeConstraint: function(t) { return this.world.removeConstraint(t), this.onConstraintRemoved.dispatch(t), t }, addContactMaterial: function(t) { return this.world.addContactMaterial(t), this.onContactMaterialAdded.dispatch(t), t }, removeContactMaterial: function(t) { return this.world.removeContactMaterial(t), this.onContactMaterialRemoved.dispatch(t), t }, getContactMaterial: function(t, e) { return this.world.getContactMaterial(t, e) }, setMaterial: function(t, e) { for (var i = e.length; i--;) e[i].setMaterial(t) }, createMaterial: function(t, e) { t = t || ""; var o = new i.Physics.P2.Material(t); return this.materials.push(o), void 0 !== e && e.setMaterial(o), o }, createContactMaterial: function(t, e, o) { void 0 === t && (t = this.createMaterial()), void 0 === e && (e = this.createMaterial()); var n = new i.Physics.P2.ContactMaterial(t, e, o); return this.addContactMaterial(n) }, getBodies: function() { for (var t = [], e = this.world.bodies.length; e--;) t.push(this.world.bodies[e].parent); return t }, getBody: function(t) { return t instanceof p2.Body ? t : t instanceof i.Physics.P2.Body ? t.data : t.body && t.body.type === i.Physics.P2JS ? t.body.data : null }, getSprings: function() { for (var t = [], e = this.world.springs.length; e--;) t.push(this.world.springs[e].parent); return t }, getConstraints: function() { for (var t = [], e = this.world.constraints.length; e--;) t.push(this.world.constraints[e]); return t }, hitTest: function(t, e, o, n) { void 0 === e && (e = this.world.bodies), void 0 === o && (o = 5), void 0 === n && (n = !1); for (var s = [this.pxmi(t.x), this.pxmi(t.y)], r = [], a = e.length; a--;) e[a] instanceof i.Physics.P2.Body && (!n || e[a].data.type !== p2.Body.STATIC) ? r.push(e[a].data) : e[a] instanceof p2.Body && e[a].parent && (!n || e[a].type !== p2.Body.STATIC) ? r.push(e[a]) : e[a] instanceof i.Sprite && e[a].hasOwnProperty("body") && (!n || e[a].body.data.type !== p2.Body.STATIC) && r.push(e[a].body.data); return this.world.hitTest(s, r, o) }, toJSON: function() { return this.world.toJSON() }, createCollisionGroup: function(t) { var e = Math.pow(2, this._collisionGroupID);
                this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | e), this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | e), this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | e), this._collisionGroupID++; var o = new i.Physics.P2.CollisionGroup(e); return this.collisionGroups.push(o), t && this.setCollisionGroup(t, o), o }, setCollisionGroup: function(t, e) { if (t instanceof i.Group)
                    for (var o = 0; o < t.total; o++) t.children[o].body && t.children[o].body.type === i.Physics.P2JS && t.children[o].body.setCollisionGroup(e);
                else t.body.setCollisionGroup(e) }, createSpring: function(t, e, o, n, s, r, a, h, l) { if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addSpring(new i.Physics.P2.Spring(this, t, e, o, n, s, r, a, h, l)) }, createRotationalSpring: function(t, e, o, n, s) { if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addSpring(new i.Physics.P2.RotationalSpring(this, t, e, o, n, s)) }, createBody: function(t, e, o, n, s, r) { void 0 === n && (n = !1); var a = new i.Physics.P2.Body(this.game, null, t, e, o); return !(r && !a.addPolygon(s, r)) && (n && this.world.addBody(a.data), a) }, createParticle: function(t, e, o, n, s, r) { void 0 === n && (n = !1); var a = new i.Physics.P2.Body(this.game, null, t, e, o); return !(r && !a.addPolygon(s, r)) && (n && this.world.addBody(a.data), a) }, convertCollisionObjects: function(t, e, i) { void 0 === i && (i = !0); for (var o = [], n = 0, s = t.collision[e].length; n < s; n++) { var r = t.collision[e][n],
                        a = this.createBody(r.x, r.y, 0, i, {}, r.polyline);
                    a && o.push(a) } return o }, clearTilemapLayerBodies: function(t, e) { e = t.getLayer(e); for (var i = t.layers[e].bodies.length; i--;) t.layers[e].bodies[i].destroy();
                t.layers[e].bodies.length = 0 }, convertTilemap: function(t, e, i, o) { e = t.getLayer(e), void 0 === i && (i = !0), void 0 === o && (o = !0), this.clearTilemapLayerBodies(t, e); for (var n = 0, s = 0, r = 0, a = 0, h = t.layers[e].height; a < h; a++) { n = 0; for (var l = 0, c = t.layers[e].width; l < c; l++) { var d = t.layers[e].data[a][l]; if (d && d.index > -1 && d.collides)
                            if (o) { var u = t.getTileRight(e, l, a);
                                0 === n && (s = d.x * d.width, r = d.y * d.height, n = d.width), u && u.collides ? n += d.width : ((p = this.createBody(s, r, 0, !1)).addRectangle(n, d.height, n / 2, d.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p), n = 0) } else { var p = this.createBody(d.x * d.width, d.y * d.height, 0, !1);
                                p.addRectangle(d.width, d.height, d.width / 2, d.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p) } } } return t.layers[e].bodies }, mpx: function(t) { return t *= 20 }, pxm: function(t) { return .05 * t }, mpxi: function(t) { return t *= -20 }, pxmi: function(t) { return -.05 * t } }, Object.defineProperty(i.Physics.P2.prototype, "friction", { get: function() { return this.world.defaultContactMaterial.friction }, set: function(t) { this.world.defaultContactMaterial.friction = t } }), Object.defineProperty(i.Physics.P2.prototype, "restitution", { get: function() { return this.world.defaultContactMaterial.restitution }, set: function(t) { this.world.defaultContactMaterial.restitution = t } }), Object.defineProperty(i.Physics.P2.prototype, "contactMaterial", { get: function() { return this.world.defaultContactMaterial }, set: function(t) { this.world.defaultContactMaterial = t } }), Object.defineProperty(i.Physics.P2.prototype, "applySpringForces", { get: function() { return this.world.applySpringForces }, set: function(t) { this.world.applySpringForces = t } }), Object.defineProperty(i.Physics.P2.prototype, "applyDamping", { get: function() { return this.world.applyDamping }, set: function(t) { this.world.applyDamping = t } }), Object.defineProperty(i.Physics.P2.prototype, "applyGravity", { get: function() { return this.world.applyGravity }, set: function(t) { this.world.applyGravity = t } }), Object.defineProperty(i.Physics.P2.prototype, "solveConstraints", { get: function() { return this.world.solveConstraints }, set: function(t) { this.world.solveConstraints = t } }), Object.defineProperty(i.Physics.P2.prototype, "time", { get: function() { return this.world.time } }), Object.defineProperty(i.Physics.P2.prototype, "emitImpactEvent", { get: function() { return this.world.emitImpactEvent }, set: function(t) { this.world.emitImpactEvent = t } }), Object.defineProperty(i.Physics.P2.prototype, "sleepMode", { get: function() { return this.world.sleepMode }, set: function(t) { this.world.sleepMode = t } }), Object.defineProperty(i.Physics.P2.prototype, "total", { get: function() { return this.world.bodies.length } }), i.Physics.P2.FixtureList = function(t) { Array.isArray(t) || (t = [t]), this.rawList = t, this.init(), this.parse(this.rawList) }, i.Physics.P2.FixtureList.prototype = { init: function() { this.namedFixtures = {}, this.groupedFixtures = [], this.allFixtures = [] }, setCategory: function(t, e) { this.getFixtures(e).forEach(function(e) { e.collisionGroup = t }) }, setMask: function(t, e) { this.getFixtures(e).forEach(function(e) { e.collisionMask = t }) }, setSensor: function(t, e) { this.getFixtures(e).forEach(function(e) { e.sensor = t }) }, setMaterial: function(t, e) { this.getFixtures(e).forEach(function(e) { e.material = t }) }, getFixtures: function(t) { var e = []; if (t) { t instanceof Array || (t = [t]); var i = this; return t.forEach(function(t) { i.namedFixtures[t] && e.push(i.namedFixtures[t]) }), this.flatten(e) } return this.allFixtures }, getFixtureByKey: function(t) { return this.namedFixtures[t] }, getGroup: function(t) { return this.groupedFixtures[t] }, parse: function() { var t, e, i, o;
                i = this.rawList, o = []; for (t in i) e = i[t], isNaN(t - 0) ? this.namedFixtures[t] = this.flatten(e) : (this.groupedFixtures[t] = this.groupedFixtures[t] || [], this.groupedFixtures[t] = this.groupedFixtures[t].concat(e)), o.push(this.allFixtures = this.flatten(this.groupedFixtures)) }, flatten: function(t) { var e, i; return e = [], i = arguments.callee, t.forEach(function(t) { return Array.prototype.push.apply(e, Array.isArray(t) ? i(t) : [t]) }), e } }, i.Physics.P2.PointProxy = function(t, e) { this.world = t, this.destination = e }, i.Physics.P2.PointProxy.prototype.constructor = i.Physics.P2.PointProxy, Object.defineProperty(i.Physics.P2.PointProxy.prototype, "x", { get: function() { return this.world.mpx(this.destination[0]) }, set: function(t) { this.destination[0] = this.world.pxm(t) } }), Object.defineProperty(i.Physics.P2.PointProxy.prototype, "y", { get: function() { return this.world.mpx(this.destination[1]) }, set: function(t) { this.destination[1] = this.world.pxm(t) } }), Object.defineProperty(i.Physics.P2.PointProxy.prototype, "mx", { get: function() { return this.destination[0] }, set: function(t) { this.destination[0] = t } }), Object.defineProperty(i.Physics.P2.PointProxy.prototype, "my", { get: function() { return this.destination[1] }, set: function(t) { this.destination[1] = t } }), i.Physics.P2.InversePointProxy = function(t, e) { this.world = t, this.destination = e }, i.Physics.P2.InversePointProxy.prototype.constructor = i.Physics.P2.InversePointProxy, Object.defineProperty(i.Physics.P2.InversePointProxy.prototype, "x", { get: function() { return this.world.mpxi(this.destination[0]) }, set: function(t) { this.destination[0] = this.world.pxmi(t) } }), Object.defineProperty(i.Physics.P2.InversePointProxy.prototype, "y", { get: function() { return this.world.mpxi(this.destination[1]) }, set: function(t) { this.destination[1] = this.world.pxmi(t) } }), Object.defineProperty(i.Physics.P2.InversePointProxy.prototype, "mx", { get: function() { return this.destination[0] }, set: function(t) { this.destination[0] = -t } }), Object.defineProperty(i.Physics.P2.InversePointProxy.prototype, "my", { get: function() { return this.destination[1] }, set: function(t) { this.destination[1] = -t } }), i.Physics.P2.Body = function(t, e, o, n, s) { e = e || null, o = o || 0, n = n || 0, void 0 === s && (s = 1), this.game = t, this.world = t.physics.p2, this.sprite = e, this.type = i.Physics.P2JS, this.offset = new i.Point, this.data = new p2.Body({ position: [this.world.pxmi(o), this.world.pxmi(n)], mass: s }), this.data.parent = this, this.velocity = new i.Physics.P2.InversePointProxy(this.world, this.data.velocity), this.force = new i.Physics.P2.InversePointProxy(this.world, this.data.force), this.gravity = new i.Point, this.onBeginContact = new i.Signal, this.onEndContact = new i.Signal, this.collidesWith = [], this.removeNextStep = !1, this.debugBody = null, this.dirty = !1, this._collideWorldBounds = !0, this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this._reset = !1, e && (this.setRectangleFromSprite(e), e.exists && this.game.physics.p2.addBody(this)) }, i.Physics.P2.Body.prototype = { createBodyCallback: function(t, e, i) { var o = -1;
                t.id ? o = t.id : t.body && (o = t.body.id), o > -1 && (null === e ? (delete this._bodyCallbacks[o], delete this._bodyCallbackContext[o]) : (this._bodyCallbacks[o] = e, this._bodyCallbackContext[o] = i)) }, createGroupCallback: function(t, e, i) { null === e ? (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]) : (this._groupCallbacks[t.mask] = e, this._groupCallbackContext[t.mask] = i) }, getCollisionMask: function() { var t = 0;
                this._collideWorldBounds && (t = this.game.physics.p2.boundsCollisionGroup.mask); for (var e = 0; e < this.collidesWith.length; e++) t |= this.collidesWith[e].mask; return t }, updateCollisionMask: function(t) { var e = this.getCollisionMask(); if (void 0 === t)
                    for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].collisionMask = e;
                else t.collisionMask = e }, setCollisionGroup: function(t, e) { var i = this.getCollisionMask(); if (void 0 === e)
                    for (var o = this.data.shapes.length - 1; o >= 0; o--) this.data.shapes[o].collisionGroup = t.mask, this.data.shapes[o].collisionMask = i;
                else e.collisionGroup = t.mask, e.collisionMask = i }, clearCollision: function(t, e, i) { if (void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i)
                    for (var o = this.data.shapes.length - 1; o >= 0; o--) t && (this.data.shapes[o].collisionGroup = null), e && (this.data.shapes[o].collisionMask = null);
                else t && (i.collisionGroup = null), e && (i.collisionMask = null);
                t && (this.collidesWith.length = 0) }, removeCollisionGroup: function(t, e, i) { void 0 === e && (e = !0); var o; if (Array.isArray(t))
                    for (s = 0; s < t.length; s++)(o = this.collidesWith.indexOf(t[s])) > -1 && (this.collidesWith.splice(o, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
                else(o = this.collidesWith.indexOf(t)) > -1 && (this.collidesWith.splice(o, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask])); var n = this.getCollisionMask(); if (void 0 === i)
                    for (var s = this.data.shapes.length - 1; s >= 0; s--) this.data.shapes[s].collisionMask = n;
                else i.collisionMask = n }, collides: function(t, e, i, o) { if (Array.isArray(t))
                    for (s = 0; s < t.length; s++) - 1 === this.collidesWith.indexOf(t[s]) && (this.collidesWith.push(t[s]), e && this.createGroupCallback(t[s], e, i));
                else -1 === this.collidesWith.indexOf(t) && (this.collidesWith.push(t), e && this.createGroupCallback(t, e, i)); var n = this.getCollisionMask(); if (void 0 === o)
                    for (var s = this.data.shapes.length - 1; s >= 0; s--) this.data.shapes[s].collisionMask = n;
                else o.collisionMask = n }, adjustCenterOfMass: function() { this.data.adjustCenterOfMass(), this.shapeChanged() }, getVelocityAtPoint: function(t, e) { return this.data.getVelocityAtPoint(t, e) }, applyDamping: function(t) { this.data.applyDamping(t) }, applyImpulse: function(t, e, i) { this.data.applyImpulse(t, [this.world.pxmi(e), this.world.pxmi(i)]) }, applyImpulseLocal: function(t, e, i) { this.data.applyImpulseLocal(t, [this.world.pxmi(e), this.world.pxmi(i)]) }, applyForce: function(t, e, i) { this.data.applyForce(t, [this.world.pxmi(e), this.world.pxmi(i)]) }, setZeroForce: function() { this.data.setZeroForce() }, setZeroRotation: function() { this.data.angularVelocity = 0 }, setZeroVelocity: function() { this.data.velocity[0] = 0, this.data.velocity[1] = 0 }, setZeroDamping: function() { this.data.damping = 0, this.data.angularDamping = 0 }, toLocalFrame: function(t, e) { return this.data.toLocalFrame(t, e) }, toWorldFrame: function(t, e) { return this.data.toWorldFrame(t, e) }, rotateLeft: function(t) { this.data.angularVelocity = this.world.pxm(-t) }, rotateRight: function(t) { this.data.angularVelocity = this.world.pxm(t) }, moveForward: function(t) { var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = e * Math.cos(i), this.data.velocity[1] = e * Math.sin(i) }, moveBackward: function(t) { var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.velocity[0] = -e * Math.cos(i), this.data.velocity[1] = -e * Math.sin(i) }, thrust: function(t) { var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.force[0] += e * Math.cos(i), this.data.force[1] += e * Math.sin(i) }, thrustLeft: function(t) { var e = this.world.pxmi(-t),
                    i = this.data.angle;
                this.data.force[0] += e * Math.cos(i), this.data.force[1] += e * Math.sin(i) }, thrustRight: function(t) { var e = this.world.pxmi(-t),
                    i = this.data.angle;
                this.data.force[0] -= e * Math.cos(i), this.data.force[1] -= e * Math.sin(i) }, reverse: function(t) { var e = this.world.pxmi(-t),
                    i = this.data.angle + Math.PI / 2;
                this.data.force[0] -= e * Math.cos(i), this.data.force[1] -= e * Math.sin(i) }, moveLeft: function(t) { this.data.velocity[0] = this.world.pxmi(-t) }, moveRight: function(t) { this.data.velocity[0] = this.world.pxmi(t) }, moveUp: function(t) { this.data.velocity[1] = this.world.pxmi(-t) }, moveDown: function(t) { this.data.velocity[1] = this.world.pxmi(t) }, preUpdate: function() { this.dirty = !0, this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1) }, postUpdate: function() { this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x, this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y, this.fixedRotation || (this.sprite.rotation = this.data.angle), this.debugBody && this.debugBody.updateSpriteTransform(), this.dirty = !1 }, reset: function(t, e, i, o) { void 0 === i && (i = !1), void 0 === o && (o = !1), this.setZeroForce(), this.setZeroVelocity(), this.setZeroRotation(), i && this.setZeroDamping(), o && (this.mass = 1), this.x = t, this.y = e }, addToWorld: function() { if (this.game.physics.p2._toRemove)
                    for (var t = 0; t < this.game.physics.p2._toRemove.length; t++) this.game.physics.p2._toRemove[t] === this && this.game.physics.p2._toRemove.splice(t, 1);
                this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this) }, removeFromWorld: function() { this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this) }, destroy: function() { this.removeFromWorld(), this.clearShapes(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this.debugBody && this.debugBody.destroy(!0, !0), this.debugBody = null, this.sprite && (this.sprite.body = null, this.sprite = null) }, clearShapes: function() { for (var t = this.data.shapes.length; t--;) this.data.removeShape(this.data.shapes[t]);
                this.shapeChanged() }, addShape: function(t, e, i, o) { return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), this.data.addShape(t, [this.world.pxmi(e), this.world.pxmi(i)], o), this.shapeChanged(), t }, addCircle: function(t, e, i, o) { var n = new p2.Circle({ radius: this.world.pxm(t) }); return this.addShape(n, e, i, o) }, addRectangle: function(t, e, i, o, n) { var s = new p2.Box({ width: this.world.pxm(t), height: this.world.pxm(e) }); return this.addShape(s, i, o, n) }, addPlane: function(t, e, i) { var o = new p2.Plane; return this.addShape(o, t, e, i) }, addParticle: function(t, e, i) { var o = new p2.Particle; return this.addShape(o, t, e, i) }, addLine: function(t, e, i, o) { var n = new p2.Line({ length: this.world.pxm(t) }); return this.addShape(n, e, i, o) }, addCapsule: function(t, e, i, o, n) { var s = new p2.Capsule({ length: this.world.pxm(t), radius: this.world.pxm(e) }); return this.addShape(s, i, o, n) }, addPolygon: function(t, e) { t = t || {}, Array.isArray(e) || (e = Array.prototype.slice.call(arguments, 1)); var i = []; if (1 === e.length && Array.isArray(e[0])) i = e[0].slice(0);
                else if (Array.isArray(e[0])) i = e.slice();
                else if ("number" == typeof e[0])
                    for (var o = 0, n = e.length; o < n; o += 2) i.push([e[o], e[o + 1]]); var s = i.length - 1;
                i[s][0] === i[0][0] && i[s][1] === i[0][1] && i.pop(); for (var r = 0; r < i.length; r++) i[r][0] = this.world.pxmi(i[r][0]), i[r][1] = this.world.pxmi(i[r][1]); var a = this.data.fromPolygon(i, t); return this.shapeChanged(), a }, removeShape: function(t) { var e = this.data.removeShape(t); return this.shapeChanged(), e }, setCircle: function(t, e, i, o) { return this.clearShapes(), this.addCircle(t, e, i, o) }, setRectangle: function(t, e, i, o, n) { return void 0 === t && (t = 16), void 0 === e && (e = 16), this.clearShapes(), this.addRectangle(t, e, i, o, n) }, setRectangleFromSprite: function(t) { return void 0 === t && (t = this.sprite), this.clearShapes(), this.addRectangle(t.width, t.height, 0, 0, t.rotation) }, setMaterial: function(t, e) { if (void 0 === e)
                    for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].material = t;
                else e.material = t }, shapeChanged: function() { this.debugBody && this.debugBody.draw() }, addPhaserPolygon: function(t, e) { for (var i = this.game.cache.getPhysicsData(t, e), o = [], n = 0; n < i.length; n++) { var s = i[n],
                        r = this.addFixture(s);
                    o[s.filter.group] = o[s.filter.group] || [], o[s.filter.group] = o[s.filter.group].concat(r), s.fixtureKey && (o[s.fixtureKey] = r) } return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), o }, addFixture: function(t) { var e = []; if (t.circle) {
                    (l = new p2.Circle({ radius: this.world.pxm(t.circle.radius) })).collisionGroup = t.filter.categoryBits, l.collisionMask = t.filter.maskBits, l.sensor = t.isSensor; var i = p2.vec2.create();
                    i[0] = this.world.pxmi(t.circle.position[0] - this.sprite.width / 2), i[1] = this.world.pxmi(t.circle.position[1] - this.sprite.height / 2), this.data.addShape(l, i), e.push(l) } else
                    for (var o = t.polygons, n = p2.vec2.create(), s = 0; s < o.length; s++) { for (var r = o[s], a = [], h = 0; h < r.length; h += 2) a.push([this.world.pxmi(r[h]), this.world.pxmi(r[h + 1])]); for (var l = new p2.Convex({ vertices: a }), c = 0; c !== l.vertices.length; c++) { var d = l.vertices[c];
                            p2.vec2.sub(d, d, l.centerOfMass) } p2.vec2.scale(n, l.centerOfMass, 1), n[0] -= this.world.pxmi(this.sprite.width / 2), n[1] -= this.world.pxmi(this.sprite.height / 2), l.updateTriangles(), l.updateCenterOfMass(), l.updateBoundingRadius(), l.collisionGroup = t.filter.categoryBits, l.collisionMask = t.filter.maskBits, l.sensor = t.isSensor, this.data.addShape(l, n), e.push(l) }
                return e }, loadPolygon: function(t, e) { if (null === t) i = e;
                else var i = this.game.cache.getPhysicsData(t, e); for (var o = p2.vec2.create(), n = 0; n < i.length; n++) { for (var s = [], r = 0; r < i[n].shape.length; r += 2) s.push([this.world.pxmi(i[n].shape[r]), this.world.pxmi(i[n].shape[r + 1])]); for (var a = new p2.Convex({ vertices: s }), h = 0; h !== a.vertices.length; h++) { var l = a.vertices[h];
                        p2.vec2.sub(l, l, a.centerOfMass) } p2.vec2.scale(o, a.centerOfMass, 1), o[0] -= this.world.pxmi(this.sprite.width / 2), o[1] -= this.world.pxmi(this.sprite.height / 2), a.updateTriangles(), a.updateCenterOfMass(), a.updateBoundingRadius(), this.data.addShape(a, o) } return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), !0 } }, i.Physics.P2.Body.prototype.constructor = i.Physics.P2.Body, i.Physics.P2.Body.DYNAMIC = 1, i.Physics.P2.Body.STATIC = 2, i.Physics.P2.Body.KINEMATIC = 4, Object.defineProperty(i.Physics.P2.Body.prototype, "static", { get: function() { return this.data.type === i.Physics.P2.Body.STATIC }, set: function(t) { t && this.data.type !== i.Physics.P2.Body.STATIC ? (this.data.type = i.Physics.P2.Body.STATIC, this.mass = 0) : t || this.data.type !== i.Physics.P2.Body.STATIC || (this.data.type = i.Physics.P2.Body.DYNAMIC, this.mass = 1) } }), Object.defineProperty(i.Physics.P2.Body.prototype, "dynamic", { get: function() { return this.data.type === i.Physics.P2.Body.DYNAMIC }, set: function(t) { t && this.data.type !== i.Physics.P2.Body.DYNAMIC ? (this.data.type = i.Physics.P2.Body.DYNAMIC, this.mass = 1) : t || this.data.type !== i.Physics.P2.Body.DYNAMIC || (this.data.type = i.Physics.P2.Body.STATIC, this.mass = 0) } }), Object.defineProperty(i.Physics.P2.Body.prototype, "kinematic", { get: function() { return this.data.type === i.Physics.P2.Body.KINEMATIC }, set: function(t) { t && this.data.type !== i.Physics.P2.Body.KINEMATIC ? (this.data.type = i.Physics.P2.Body.KINEMATIC, this.mass = 4) : t || this.data.type !== i.Physics.P2.Body.KINEMATIC || (this.data.type = i.Physics.P2.Body.STATIC, this.mass = 0) } }), Object.defineProperty(i.Physics.P2.Body.prototype, "allowSleep", { get: function() { return this.data.allowSleep }, set: function(t) { t !== this.data.allowSleep && (this.data.allowSleep = t) } }), Object.defineProperty(i.Physics.P2.Body.prototype, "angle", { get: function() { return i.Math.wrapAngle(i.Math.radToDeg(this.data.angle)) }, set: function(t) { this.data.angle = i.Math.degToRad(i.Math.wrapAngle(t)) } }), Object.defineProperty(i.Physics.P2.Body.prototype, "angularDamping", { get: function() { return this.data.angularDamping }, set: function(t) { this.data.angularDamping = t } }), Object.defineProperty(i.Physics.P2.Body.prototype, "angularForce", { get: function() { return this.data.angularForce }, set: function(t) { this.data.angularForce = t } }), Object.defineProperty(i.Physics.P2.Body.prototype, "angularVelocity", { get: function() { return this.data.angularVelocity }, set: function(t) { this.data.angularVelocity = t } }), Object.defineProperty(i.Physics.P2.Body.prototype, "damping", { get: function() { return this.data.damping }, set: function(t) { this.data.damping = t } }), Object.defineProperty(i.Physics.P2.Body.prototype, "fixedRotation", { get: function() { return this.data.fixedRotation }, set: function(t) { t !== this.data.fixedRotation && (this.data.fixedRotation = t) } }), Object.defineProperty(i.Physics.P2.Body.prototype, "inertia", { get: function() { return this.data.inertia }, set: function(t) { this.data.inertia = t } }), Object.defineProperty(i.Physics.P2.Body.prototype, "mass", { get: function() { return this.data.mass }, set: function(t) { t !== this.data.mass && (this.data.mass = t, this.data.updateMassProperties()) } }), Object.defineProperty(i.Physics.P2.Body.prototype, "motionState", { get: function() { return this.data.type }, set: function(t) { t !== this.data.type && (this.data.type = t) } }), Object.defineProperty(i.Physics.P2.Body.prototype, "rotation", { get: function() { return this.data.angle }, set: function(t) { this.data.angle = t } }), Object.defineProperty(i.Physics.P2.Body.prototype, "sleepSpeedLimit", { get: function() { return this.data.sleepSpeedLimit }, set: function(t) { this.data.sleepSpeedLimit = t } }), Object.defineProperty(i.Physics.P2.Body.prototype, "x", { get: function() { return this.world.mpxi(this.data.position[0]) }, set: function(t) { this.data.position[0] = this.world.pxmi(t) } }), Object.defineProperty(i.Physics.P2.Body.prototype, "y", { get: function() { return this.world.mpxi(this.data.position[1]) }, set: function(t) { this.data.position[1] = this.world.pxmi(t) } }), Object.defineProperty(i.Physics.P2.Body.prototype, "id", { get: function() { return this.data.id } }), Object.defineProperty(i.Physics.P2.Body.prototype, "debug", { get: function() { return null !== this.debugBody }, set: function(t) { t && !this.debugBody ? this.debugBody = new i.Physics.P2.BodyDebug(this.game, this.data) : !t && this.debugBody && (this.debugBody.destroy(), this.debugBody = null) } }), Object.defineProperty(i.Physics.P2.Body.prototype, "collideWorldBounds", { get: function() { return this._collideWorldBounds }, set: function(t) { t && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !t && this._collideWorldBounds && (this._collideWorldBounds = !1, this.updateCollisionMask()) } }), i.Physics.P2.BodyDebug = function(t, e, o) { i.Group.call(this, t); var n = { pixelsPerLengthUnit: t.physics.p2.mpx(1), debugPolygons: !1, lineWidth: 1, alpha: .5 };
            this.settings = i.Utils.extend(n, o), this.ppu = this.settings.pixelsPerLengthUnit, this.ppu = -1 * this.ppu, this.body = e, this.canvas = new i.Graphics(t), this.canvas.alpha = this.settings.alpha, this.add(this.canvas), this.draw(), this.updateSpriteTransform() }, i.Physics.P2.BodyDebug.prototype = Object.create(i.Group.prototype), i.Physics.P2.BodyDebug.prototype.constructor = i.Physics.P2.BodyDebug, i.Utils.extend(i.Physics.P2.BodyDebug.prototype, { updateSpriteTransform: function() { this.position.x = this.body.position[0] * this.ppu, this.position.y = this.body.position[1] * this.ppu, this.rotation = this.body.angle }, draw: function() { var t, e, i, o, n, s, r, a, h, l, c, d, u, p; if (r = this.body, (h = this.canvas).clear(), i = parseInt(this.randomPastelHex(), 16), 16711680, s = this.lineWidth, r instanceof p2.Body && r.shapes.length) { var m = r.shapes.length; for (o = 0; o !== m;) { if (e = r.shapes[o], a = e.position || 0, t = e.angle || 0, e instanceof p2.Circle) this.drawCircle(h, a[0] * this.ppu, a[1] * this.ppu, t, e.radius * this.ppu, i, s);
                        else if (e instanceof p2.Capsule) this.drawCapsule(h, a[0] * this.ppu, a[1] * this.ppu, t, e.length * this.ppu, e.radius * this.ppu, 16711680, i, s);
                        else if (e instanceof p2.Plane) this.drawPlane(h, a[0] * this.ppu, -a[1] * this.ppu, i, 16711680, 5 * s, 10 * s, 10 * s, 100 * this.ppu, t);
                        else if (e instanceof p2.Line) this.drawLine(h, e.length * this.ppu, 16711680, s);
                        else if (e instanceof p2.Box) this.drawRectangle(h, a[0] * this.ppu, a[1] * this.ppu, t, e.width * this.ppu, e.height * this.ppu, 16711680, i, s);
                        else if (e instanceof p2.Convex) { for (c = [], d = p2.vec2.create(), n = u = 0, p = e.vertices.length; 0 <= p ? u < p : u > p; n = 0 <= p ? ++u : --u) l = e.vertices[n], p2.vec2.rotate(d, l, t), c.push([(d[0] + a[0]) * this.ppu, -(d[1] + a[1]) * this.ppu]);
                            this.drawConvex(h, c, e.triangles, 16711680, i, s, this.settings.debugPolygons, [a[0] * this.ppu, -a[1] * this.ppu]) } o++ } } }, drawRectangle: function(t, e, i, o, n, s, r, a, h) { void 0 === h && (h = 1), void 0 === r && (r = 0), t.lineStyle(h, r, 1), t.beginFill(a), t.drawRect(e - n / 2, i - s / 2, n, s) }, drawCircle: function(t, e, i, o, n, s, r) { void 0 === r && (r = 1), void 0 === s && (s = 16777215), t.lineStyle(r, 0, 1), t.beginFill(s, 1), t.drawCircle(e, i, 2 * -n), t.endFill(), t.moveTo(e, i), t.lineTo(e + n * Math.cos(-o), i + n * Math.sin(-o)) }, drawLine: function(t, e, i, o) { void 0 === o && (o = 1), void 0 === i && (i = 0), t.lineStyle(5 * o, i, 1), t.moveTo(-e / 2, 0), t.lineTo(e / 2, 0) }, drawConvex: function(t, e, i, o, n, s, r, a) { var h, l, c, d, u, p, m, f, y, b, g; if (void 0 === s && (s = 1), void 0 === o && (o = 0), r) { for (h = [16711680, 65280, 255], l = 0; l !== e.length + 1;) d = e[l % e.length], u = e[(l + 1) % e.length], m = d[0], b = d[1], f = u[0], g = u[1], t.lineStyle(s, h[l % h.length], 1), t.moveTo(m, -b), t.lineTo(f, -g), t.drawCircle(m, -b, 2 * s), l++; return t.lineStyle(s, 0, 1), t.drawCircle(a[0], a[1], 2 * s) } for (t.lineStyle(s, o, 1), t.beginFill(n), l = 0; l !== e.length;) p = (c = e[l])[0], y = c[1], 0 === l ? t.moveTo(p, -y) : t.lineTo(p, -y), l++; if (t.endFill(), e.length > 2) return t.moveTo(e[e.length - 1][0], -e[e.length - 1][1]), t.lineTo(e[0][0], -e[0][1]) }, drawPath: function(t, e, i, o, n) { var s, r, a, h, l, c, d, u, p, m, f; for (void 0 === n && (n = 1), void 0 === i && (i = 0), t.lineStyle(n, i, 1), "number" == typeof o && t.beginFill(o), r = null, a = null, s = 0; s < e.length;) m = (p = e[s])[0], f = p[1], m === r && f === a || (0 === s ? t.moveTo(m, f) : (h = r, l = a, c = m, d = f, u = e[(s + 1) % e.length][0], 0 !== (c - h) * (e[(s + 1) % e.length][1] - l) - (u - h) * (d - l) && t.lineTo(m, f)), r = m, a = f), s++; "number" == typeof o && t.endFill(), e.length > 2 && "number" == typeof o && (t.moveTo(e[e.length - 1][0], e[e.length - 1][1]), t.lineTo(e[0][0], e[0][1])) }, drawPlane: function(t, e, i, o, n, s, r, a, h, l) { var c, d;
                void 0 === s && (s = 1), void 0 === o && (o = 16777215), t.lineStyle(s, n, 11), t.beginFill(o), t.moveTo(e, -i), c = e + Math.cos(l) * this.game.width, d = i + Math.sin(l) * this.game.height, t.lineTo(c, -d), t.moveTo(e, -i), c = e + Math.cos(l) * -this.game.width, d = i + Math.sin(l) * -this.game.height, t.lineTo(c, -d) }, drawCapsule: function(t, e, i, o, n, s, r, a, h) { void 0 === h && (h = 1), void 0 === r && (r = 0), t.lineStyle(h, r, 1); var l = Math.cos(o),
                    c = Math.sin(o);
                t.beginFill(a, 1), t.drawCircle(-n / 2 * l + e, -n / 2 * c + i, 2 * -s), t.drawCircle(n / 2 * l + e, n / 2 * c + i, 2 * -s), t.endFill(), t.lineStyle(h, r, 0), t.beginFill(a, 1), t.moveTo(-n / 2 * l + s * c + e, -n / 2 * c + s * l + i), t.lineTo(n / 2 * l + s * c + e, n / 2 * c + s * l + i), t.lineTo(n / 2 * l - s * c + e, n / 2 * c - s * l + i), t.lineTo(-n / 2 * l - s * c + e, -n / 2 * c - s * l + i), t.endFill(), t.lineStyle(h, r, 1), t.moveTo(-n / 2 * l + s * c + e, -n / 2 * c + s * l + i), t.lineTo(n / 2 * l + s * c + e, n / 2 * c + s * l + i), t.moveTo(-n / 2 * l - s * c + e, -n / 2 * c - s * l + i), t.lineTo(n / 2 * l - s * c + e, n / 2 * c - s * l + i) }, randomPastelHex: function() { var t, e, i, o; return i = [255, 255, 255], o = Math.floor(256 * Math.random()), e = Math.floor(256 * Math.random()), t = Math.floor(256 * Math.random()), o = Math.floor((o + 3 * i[0]) / 4), e = Math.floor((e + 3 * i[1]) / 4), t = Math.floor((t + 3 * i[2]) / 4), this.rgbToHex(o, e, t) }, rgbToHex: function(t, e, i) { return this.componentToHex(t) + this.componentToHex(e) + this.componentToHex(i) }, componentToHex: function(t) { var e; return 2 === (e = t.toString(16)).length ? e : e + "0" } }), i.Physics.P2.Spring = function(t, e, i, o, n, s, r, a, h, l) { this.game = t.game, this.world = t, void 0 === o && (o = 1), void 0 === n && (n = 100), void 0 === s && (s = 1); var c = { restLength: o = t.pxm(o), stiffness: n, damping: s };
            void 0 !== r && null !== r && (c.worldAnchorA = [t.pxm(r[0]), t.pxm(r[1])]), void 0 !== a && null !== a && (c.worldAnchorB = [t.pxm(a[0]), t.pxm(a[1])]), void 0 !== h && null !== h && (c.localAnchorA = [t.pxm(h[0]), t.pxm(h[1])]), void 0 !== l && null !== l && (c.localAnchorB = [t.pxm(l[0]), t.pxm(l[1])]), this.data = new p2.LinearSpring(e, i, c), this.data.parent = this }, i.Physics.P2.Spring.prototype.constructor = i.Physics.P2.Spring, i.Physics.P2.RotationalSpring = function(t, e, i, o, n, s) { this.game = t.game, this.world = t, void 0 === o && (o = null), void 0 === n && (n = 100), void 0 === s && (s = 1), o && (o = t.pxm(o)); var r = { restAngle: o, stiffness: n, damping: s };
            this.data = new p2.RotationalSpring(e, i, r), this.data.parent = this }, i.Physics.P2.Spring.prototype.constructor = i.Physics.P2.Spring, i.Physics.P2.Material = function(t) { this.name = t, p2.Material.call(this) }, i.Physics.P2.Material.prototype = Object.create(p2.Material.prototype), i.Physics.P2.Material.prototype.constructor = i.Physics.P2.Material, i.Physics.P2.ContactMaterial = function(t, e, i) { p2.ContactMaterial.call(this, t, e, i) }, i.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype), i.Physics.P2.ContactMaterial.prototype.constructor = i.Physics.P2.ContactMaterial, i.Physics.P2.CollisionGroup = function(t) { this.mask = t }, i.Physics.P2.DistanceConstraint = function(t, e, i, o, n, s, r) { void 0 === o && (o = 100), void 0 === n && (n = [0, 0]), void 0 === s && (s = [0, 0]), void 0 === r && (r = Number.MAX_VALUE), this.game = t.game, this.world = t; var a = { distance: o = t.pxm(o), localAnchorA: n = [t.pxmi(n[0]), t.pxmi(n[1])], localAnchorB: s = [t.pxmi(s[0]), t.pxmi(s[1])], maxForce: r };
            p2.DistanceConstraint.call(this, e, i, a) }, i.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype), i.Physics.P2.DistanceConstraint.prototype.constructor = i.Physics.P2.DistanceConstraint, i.Physics.P2.GearConstraint = function(t, e, i, o, n) { void 0 === o && (o = 0), void 0 === n && (n = 1), this.game = t.game, this.world = t; var s = { angle: o, ratio: n };
            p2.GearConstraint.call(this, e, i, s) }, i.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype), i.Physics.P2.GearConstraint.prototype.constructor = i.Physics.P2.GearConstraint, i.Physics.P2.LockConstraint = function(t, e, i, o, n, s) { void 0 === o && (o = [0, 0]), void 0 === n && (n = 0), void 0 === s && (s = Number.MAX_VALUE), this.game = t.game, this.world = t; var r = { localOffsetB: o = [t.pxm(o[0]), t.pxm(o[1])], localAngleB: n, maxForce: s };
            p2.LockConstraint.call(this, e, i, r) }, i.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype), i.Physics.P2.LockConstraint.prototype.constructor = i.Physics.P2.LockConstraint, i.Physics.P2.PrismaticConstraint = function(t, e, i, o, n, s, r, a) { void 0 === o && (o = !0), void 0 === n && (n = [0, 0]), void 0 === s && (s = [0, 0]), void 0 === r && (r = [0, 0]), void 0 === a && (a = Number.MAX_VALUE), this.game = t.game, this.world = t; var h = { localAnchorA: n = [t.pxmi(n[0]), t.pxmi(n[1])], localAnchorB: s = [t.pxmi(s[0]), t.pxmi(s[1])], localAxisA: r, maxForce: a, disableRotationalLock: !o };
            p2.PrismaticConstraint.call(this, e, i, h) }, i.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype), i.Physics.P2.PrismaticConstraint.prototype.constructor = i.Physics.P2.PrismaticConstraint, i.Physics.P2.RevoluteConstraint = function(t, e, i, o, n, s, r) { void 0 === s && (s = Number.MAX_VALUE), void 0 === r && (r = null), this.game = t.game, this.world = t, i = [t.pxmi(i[0]), t.pxmi(i[1])], n = [t.pxmi(n[0]), t.pxmi(n[1])], r && (r = [t.pxmi(r[0]), t.pxmi(r[1])]); var a = { worldPivot: r, localPivotA: i, localPivotB: n, maxForce: s };
            p2.RevoluteConstraint.call(this, e, o, a) }, i.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype), i.Physics.P2.RevoluteConstraint.prototype.constructor = i.Physics.P2.RevoluteConstraint, i.ImageCollection = function(t, e, i, o, n, s, r) {
            (void 0 === i || i <= 0) && (i = 32), (void 0 === o || o <= 0) && (o = 32), void 0 === n && (n = 0), void 0 === s && (s = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | o, this.imageMargin = 0 | n, this.imageSpacing = 0 | s, this.properties = r || {}, this.images = [], this.total = 0 }, i.ImageCollection.prototype = { containsImageIndex: function(t) { return t >= this.firstgid && t < this.firstgid + this.total }, addImage: function(t, e) { this.images.push({ gid: t, image: e }), this.total++ } }, i.ImageCollection.prototype.constructor = i.ImageCollection, i.Tile = function(t, e, i, o, n, s) { this.layer = t, this.index = e, this.x = i, this.y = o, this.rotation = 0, this.flipped = !1, this.worldX = i * n, this.worldY = o * s, this.width = n, this.height = s, this.centerX = Math.abs(n / 2), this.centerY = Math.abs(s / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.collisionCallback = null, this.collisionCallbackContext = this }, i.Tile.prototype = { containsPoint: function(t, e) { return !(t < this.worldX || e < this.worldY || t > this.right || e > this.bottom) }, intersects: function(t, e, i, o) { return !(i <= this.worldX) && (!(o <= this.worldY) && (!(t >= this.worldX + this.width) && !(e >= this.worldY + this.height))) }, setCollisionCallback: function(t, e) { this.collisionCallback = t, this.collisionCallbackContext = e }, destroy: function() { this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null }, setCollision: function(t, e, i, o) { this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = o, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = o }, resetCollision: function() { this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1 }, isInteresting: function(t, e) { return t && e ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : t ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!e && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight) }, copy: function(t) { this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext } }, i.Tile.prototype.constructor = i.Tile, Object.defineProperty(i.Tile.prototype, "collides", { get: function() { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown } }), Object.defineProperty(i.Tile.prototype, "canCollide", { get: function() { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback } }), Object.defineProperty(i.Tile.prototype, "left", { get: function() { return this.worldX } }), Object.defineProperty(i.Tile.prototype, "right", { get: function() { return this.worldX + this.width } }), Object.defineProperty(i.Tile.prototype, "top", { get: function() { return this.worldY } }), Object.defineProperty(i.Tile.prototype, "bottom", { get: function() { return this.worldY + this.height } }), i.Tilemap = function(t, e, o, n, s, r) { this.game = t, this.key = e; var a = i.TilemapParser.parse(this.game, e, o, n, s, r);
            null !== a && (this.width = a.width, this.height = a.height, this.tileWidth = a.tileWidth, this.tileHeight = a.tileHeight, this.orientation = a.orientation, this.format = a.format, this.version = a.version, this.properties = a.properties, this.widthInPixels = a.widthInPixels, this.heightInPixels = a.heightInPixels, this.layers = a.layers, this.tilesets = a.tilesets, this.imagecollections = a.imagecollections, this.tiles = a.tiles, this.objects = a.objects, this.collideIndexes = [], this.collision = a.collision, this.images = a.images, this.enableDebug = !1, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0) }, i.Tilemap.CSV = 0, i.Tilemap.TILED_JSON = 1, i.Tilemap.NORTH = 0, i.Tilemap.EAST = 1, i.Tilemap.SOUTH = 2, i.Tilemap.WEST = 3, i.Tilemap.prototype = { create: function(t, e, i, o, n, s) { return void 0 === s && (s = this.game.world), this.width = e, this.height = i, this.setTileSize(o, n), this.layers.length = 0, this.createBlankLayer(t, e, i, o, n, s) }, setTileSize: function(t, e) { this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e }, addTilesetImage: function(t, e, o, n, s, r, a) { if (void 0 === t) return null;
                void 0 === o && (o = this.tileWidth), void 0 === n && (n = this.tileHeight), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), 0 === o && (o = 32), 0 === n && (n = 32); var h = null; if (void 0 !== e && null !== e || (e = t), e instanceof i.BitmapData) h = e.canvas;
                else { if (!this.game.cache.checkImageKey(e)) return null;
                    h = this.game.cache.getImage(e) } var l = this.getTilesetIndex(t); if (null === l && this.format === i.Tilemap.TILED_JSON) return null; if (this.tilesets[l]) return this.tilesets[l].setImage(h), this.tilesets[l]; var c = new i.Tileset(t, a, o, n, s, r, {});
                c.setImage(h), this.tilesets.push(c); for (var d = this.tilesets.length - 1, u = s, p = s, m = 0, f = 0, y = 0, b = a; b < a + c.total && (this.tiles[b] = [u, p, d], u += o + r, ++m !== c.total) && (++f !== c.columns || (u = s, p += n + r, f = 0, ++y !== c.rows)); b++); return c }, createFromObjects: function(t, e, o, n, s, r, a, h, l) { if (void 0 === s && (s = !0), void 0 === r && (r = !1), void 0 === a && (a = this.game.world), void 0 === h && (h = i.Sprite), void 0 === l && (l = !0), this.objects[t])
                    for (var c = 0; c < this.objects[t].length; c++) { var d = !1,
                            u = this.objects[t][c]; if (void 0 !== u.gid && "number" == typeof e && u.gid === e ? d = !0 : void 0 !== u.id && "number" == typeof e && u.id === e ? d = !0 : void 0 !== u.name && "string" == typeof e && u.name === e && (d = !0), d) { var p = new h(this.game, parseFloat(u.x, 10), parseFloat(u.y, 10), o, n);
                            p.name = u.name, p.visible = u.visible, p.autoCull = r, p.exists = s, u.width && (p.width = u.width), u.height && (p.height = u.height), u.rotation && (p.angle = u.rotation), l && (p.y -= p.height), a.add(p); for (var m in u.properties) a.set(p, m, u.properties[m], !1, !1, 0, !0) } } }, createFromTiles: function(t, e, o, n, s, r) { "number" == typeof t && (t = [t]), void 0 === e || null === e ? e = [] : "number" == typeof e && (e = [e]), n = this.getLayer(n), void 0 === s && (s = this.game.world), void 0 === r && (r = {}), void 0 === r.customClass && (r.customClass = i.Sprite), void 0 === r.adjustY && (r.adjustY = !0); var a = this.layers[n].width,
                    h = this.layers[n].height; if (this.copy(0, 0, a, h, n), this._results.length < 2) return 0; for (var l, c = 0, d = 1, u = this._results.length; d < u; d++)
                    if (-1 !== t.indexOf(this._results[d].index)) { l = new r.customClass(this.game, this._results[d].worldX, this._results[d].worldY, o); for (var p in r) l[p] = r[p];
                        s.add(l), c++ } if (1 === e.length)
                    for (d = 0; d < t.length; d++) this.replace(t[d], e[0], 0, 0, a, h, n);
                else if (e.length > 1)
                    for (d = 0; d < t.length; d++) this.replace(t[d], e[d], 0, 0, a, h, n); return c }, createLayer: function(t, e, o, n) { void 0 === e && (e = this.game.width), void 0 === o && (o = this.game.height), void 0 === n && (n = this.game.world); var s = t; if ("string" == typeof t && (s = this.getLayerIndex(t)), !(null === s || s > this.layers.length)) { void 0 === e || e <= 0 ? e = Math.min(this.game.width, this.layers[s].widthInPixels) : e > this.game.width && (e = this.game.width), void 0 === o || o <= 0 ? o = Math.min(this.game.height, this.layers[s].heightInPixels) : o > this.game.height && (o = this.game.height), this.enableDebug; var r = n.add(new i.TilemapLayer(this.game, this, s, e, o)); return this.enableDebug, r } }, createBlankLayer: function(t, e, o, n, s, r) { if (void 0 === r && (r = this.game.world), null === this.getLayerIndex(t)) { for (var a, h = { name: t, x: 0, y: 0, width: e, height: o, widthInPixels: e * n, heightInPixels: o * s, alpha: 1, visible: !0, properties: {}, indexes: [], callbacks: [], bodies: [], data: null }, l = [], c = 0; c < o; c++) { a = []; for (var d = 0; d < e; d++) a.push(new i.Tile(h, -1, d, c, n, s));
                        l.push(a) } h.data = l, this.layers.push(h), this.currentLayer = this.layers.length - 1; var u = h.widthInPixels,
                        p = h.heightInPixels; return u > this.game.width && (u = this.game.width), p > this.game.height && (p = this.game.height), (l = new i.TilemapLayer(this.game, this, this.layers.length - 1, u, p)).name = t, r.add(l) } }, getIndex: function(t, e) { for (var i = 0; i < t.length; i++)
                    if (t[i].name === e) return i; return null }, getLayerIndex: function(t) { return this.getIndex(this.layers, t) }, getTilesetIndex: function(t) { return this.getIndex(this.tilesets, t) }, getImageIndex: function(t) { return this.getIndex(this.images, t) }, setTileIndexCallback: function(t, e, i, o) { if (o = this.getLayer(o), "number" == typeof t) this.layers[o].callbacks[t] = { callback: e, callbackContext: i };
                else
                    for (var n = 0, s = t.length; n < s; n++) this.layers[o].callbacks[t[n]] = { callback: e, callbackContext: i } }, setTileLocationCallback: function(t, e, i, o, n, s, r) { if (r = this.getLayer(r), this.copy(t, e, i, o, r), !(this._results.length < 2))
                    for (var a = 1; a < this._results.length; a++) this._results[a].setCollisionCallback(n, s) }, setCollision: function(t, e, i, o) { if (void 0 === e && (e = !0), void 0 === o && (o = !0), i = this.getLayer(i), "number" == typeof t) return this.setCollisionByIndex(t, e, i, !0); if (Array.isArray(t)) { for (var n = 0; n < t.length; n++) this.setCollisionByIndex(t[n], e, i, !1);
                    o && this.calculateFaces(i) } }, setCollisionBetween: function(t, e, i, o, n) { if (void 0 === i && (i = !0), void 0 === n && (n = !0), o = this.getLayer(o), !(t > e)) { for (var s = t; s <= e; s++) this.setCollisionByIndex(s, i, o, !1);
                    n && this.calculateFaces(o) } }, setCollisionByExclusion: function(t, e, i, o) { void 0 === e && (e = !0), void 0 === o && (o = !0), i = this.getLayer(i); for (var n = 0, s = this.tiles.length; n < s; n++) - 1 === t.indexOf(n) && this.setCollisionByIndex(n, e, i, !1);
                o && this.calculateFaces(i) }, setCollisionByIndex: function(t, e, i, o) { if (void 0 === e && (e = !0), void 0 === i && (i = this.currentLayer), void 0 === o && (o = !0), e) this.collideIndexes.push(t);
                else { var n = this.collideIndexes.indexOf(t);
                    n > -1 && this.collideIndexes.splice(n, 1) } for (var s = 0; s < this.layers[i].height; s++)
                    for (var r = 0; r < this.layers[i].width; r++) { var a = this.layers[i].data[s][r];
                        a && a.index === t && (e ? a.setCollision(!0, !0, !0, !0) : a.resetCollision(), a.faceTop = e, a.faceBottom = e, a.faceLeft = e, a.faceRight = e) }
                return o && this.calculateFaces(i), i }, getLayer: function(t) { return void 0 === t ? t = this.currentLayer : "string" == typeof t ? t = this.getLayerIndex(t) : t instanceof i.TilemapLayer && (t = t.index), t }, setPreventRecalculate: function(t) { if (!0 === t && !0 !== this.preventingRecalculate && (this.preventingRecalculate = !0, this.needToRecalculate = {}), !1 === t && !0 === this.preventingRecalculate) { this.preventingRecalculate = !1; for (var e in this.needToRecalculate) this.calculateFaces(e);
                    this.needToRecalculate = !1 } }, calculateFaces: function(t) { if (this.preventingRecalculate) this.needToRecalculate[t] = !0;
                else
                    for (var e = null, i = null, o = null, n = null, s = 0, r = this.layers[t].height; s < r; s++)
                        for (var a = 0, h = this.layers[t].width; a < h; a++) { var l = this.layers[t].data[s][a];
                            l && (e = this.getTileAbove(t, a, s), i = this.getTileBelow(t, a, s), o = this.getTileLeft(t, a, s), n = this.getTileRight(t, a, s), l.collides && (l.faceTop = !0, l.faceBottom = !0, l.faceLeft = !0, l.faceRight = !0), e && e.collides && (l.faceTop = !1), i && i.collides && (l.faceBottom = !1), o && o.collides && (l.faceLeft = !1), n && n.collides && (l.faceRight = !1)) } }, getTileAbove: function(t, e, i) { return i > 0 ? this.layers[t].data[i - 1][e] : null }, getTileBelow: function(t, e, i) { return i < this.layers[t].height - 1 ? this.layers[t].data[i + 1][e] : null }, getTileLeft: function(t, e, i) { return e > 0 ? this.layers[t].data[i][e - 1] : null }, getTileRight: function(t, e, i) { return e < this.layers[t].width - 1 ? this.layers[t].data[i][e + 1] : null }, setLayer: function(t) { t = this.getLayer(t), this.layers[t] && (this.currentLayer = t) }, hasTile: function(t, e, i) { return i = this.getLayer(i), void 0 !== this.layers[i].data[e] && void 0 !== this.layers[i].data[e][t] && this.layers[i].data[e][t].index > -1 }, removeTile: function(t, e, o) { if (o = this.getLayer(o), t >= 0 && t < this.layers[o].width && e >= 0 && e < this.layers[o].height && this.hasTile(t, e, o)) { var n = this.layers[o].data[e][t]; return this.layers[o].data[e][t] = new i.Tile(this.layers[o], -1, t, e, this.tileWidth, this.tileHeight), this.layers[o].dirty = !0, this.calculateFaces(o), n } }, removeTileWorldXY: function(t, e, i, o, n) { return n = this.getLayer(n), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, o) / o, this.removeTile(t, e, n) }, putTile: function(t, e, o, n) { if (null === t) return this.removeTile(e, o, n); if (n = this.getLayer(n), e >= 0 && e < this.layers[n].width && o >= 0 && o < this.layers[n].height) { var s; return t instanceof i.Tile ? (s = t.index, this.hasTile(e, o, n) ? this.layers[n].data[o][e].copy(t) : this.layers[n].data[o][e] = new i.Tile(n, s, e, o, t.width, t.height)) : (s = t, this.hasTile(e, o, n) ? this.layers[n].data[o][e].index = s : this.layers[n].data[o][e] = new i.Tile(this.layers[n], s, e, o, this.tileWidth, this.tileHeight)), this.collideIndexes.indexOf(s) > -1 ? this.layers[n].data[o][e].setCollision(!0, !0, !0, !0) : this.layers[n].data[o][e].resetCollision(), this.layers[n].dirty = !0, this.calculateFaces(n), this.layers[n].data[o][e] } return null }, putTileWorldXY: function(t, e, i, o, n, s) { return s = this.getLayer(s), e = this.game.math.snapToFloor(e, o) / o, i = this.game.math.snapToFloor(i, n) / n, this.putTile(t, e, i, s) }, searchTileIndex: function(t, e, i, o) { void 0 === e && (e = 0), void 0 === i && (i = !1), o = this.getLayer(o); var n = 0; if (i) { for (s = this.layers[o].height - 1; s >= 0; s--)
                        for (r = this.layers[o].width - 1; r >= 0; r--)
                            if (this.layers[o].data[s][r].index === t) { if (n === e) return this.layers[o].data[s][r];
                                n++ } } else
                    for (var s = 0; s < this.layers[o].height; s++)
                        for (var r = 0; r < this.layers[o].width; r++)
                            if (this.layers[o].data[s][r].index === t) { if (n === e) return this.layers[o].data[s][r];
                                n++ } return null }, getTile: function(t, e, i, o) { return void 0 === o && (o = !1), i = this.getLayer(i), t >= 0 && t < this.layers[i].width && e >= 0 && e < this.layers[i].height ? -1 === this.layers[i].data[e][t].index ? o ? this.layers[i].data[e][t] : null : this.layers[i].data[e][t] : null }, getTileWorldXY: function(t, e, i, o, n, s) { return void 0 === i && (i = this.tileWidth), void 0 === o && (o = this.tileHeight), n = this.getLayer(n), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, o) / o, this.getTile(t, e, n, s) }, copy: function(t, e, i, o, n) { n = this.getLayer(n); { if (this.layers[n]) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.layers[n].width), void 0 === o && (o = this.layers[n].height), t < 0 && (t = 0), e < 0 && (e = 0), i > this.layers[n].width && (i = this.layers[n].width), o > this.layers[n].height && (o = this.layers[n].height), this._results.length = 0, this._results.push({ x: t, y: e, width: i, height: o, layer: n }); for (var s = e; s < e + o; s++)
                            for (var r = t; r < t + i; r++) this._results.push(this.layers[n].data[s][r]); return this._results } this._results.length = 0 } }, paste: function(t, e, i, o) { if (void 0 === t && (t = 0), void 0 === e && (e = 0), o = this.getLayer(o), i && !(i.length < 2)) { for (var n = t - i[1].x, s = e - i[1].y, r = 1; r < i.length; r++) this.layers[o].data[s + i[r].y][n + i[r].x].copy(i[r]);
                    this.layers[o].dirty = !0, this.calculateFaces(o) } }, swap: function(t, e, i, o, n, s, r) { r = this.getLayer(r), this.copy(i, o, n, s, r), this._results.length < 2 || (this._tempA = t, this._tempB = e, this._results.forEach(this.swapHandler, this), this.paste(i, o, this._results, r)) }, swapHandler: function(t) { t.index === this._tempA ? t.index = this._tempB : t.index === this._tempB && (t.index = this._tempA) }, forEach: function(t, e, i, o, n, s, r) { r = this.getLayer(r), this.copy(i, o, n, s, r), this._results.length < 2 || (this._results.forEach(t, e), this.paste(i, o, this._results, r)) }, replace: function(t, e, i, o, n, s, r) { if (r = this.getLayer(r), this.copy(i, o, n, s, r), !(this._results.length < 2)) { for (var a = 1; a < this._results.length; a++) this._results[a].index === t && (this._results[a].index = e);
                    this.paste(i, o, this._results, r) } }, random: function(t, e, i, o, n) { if (n = this.getLayer(n), this.copy(t, e, i, o, n), !(this._results.length < 2)) { for (var s = [], r = 1; r < this._results.length; r++)
                        if (this._results[r].index) { var a = this._results[r].index; - 1 === s.indexOf(a) && s.push(a) } for (var h = 1; h < this._results.length; h++) this._results[h].index = this.game.rnd.pick(s);
                    this.paste(t, e, this._results, n) } }, shuffle: function(t, e, o, n, s) { if (s = this.getLayer(s), this.copy(t, e, o, n, s), !(this._results.length < 2)) { for (var r = [], a = 1; a < this._results.length; a++) this._results[a].index && r.push(this._results[a].index);
                    i.ArrayUtils.shuffle(r); for (var h = 1; h < this._results.length; h++) this._results[h].index = r[h - 1];
                    this.paste(t, e, this._results, s) } }, fill: function(t, e, i, o, n, s) { if (s = this.getLayer(s), this.copy(e, i, o, n, s), !(this._results.length < 2)) { for (var r = 1; r < this._results.length; r++) this._results[r].index = t;
                    this.paste(e, i, this._results, s) } }, removeAllLayers: function() { this.layers.length = 0, this.currentLayer = 0 }, dump: function() { for (var t = "", e = [""], i = 0; i < this.layers[this.currentLayer].height; i++) { for (var o = 0; o < this.layers[this.currentLayer].width; o++) t += "%c  ", this.layers[this.currentLayer].data[i][o] > 1 ? this.debugMap[this.layers[this.currentLayer].data[i][o]] ? e.push("background: " + this.debugMap[this.layers[this.currentLayer].data[i][o]]) : e.push("background: #ffffff") : e.push("background: rgb(0, 0, 0)");
                    t += "\n" } e[0] = t }, destroy: function() { this.removeAllLayers(), this.data = [], this.game = null } }, i.Tilemap.prototype.constructor = i.Tilemap, Object.defineProperty(i.Tilemap.prototype, "layer", { get: function() { return this.layers[this.currentLayer] }, set: function(t) { t !== this.currentLayer && this.setLayer(t) } }), i.TilemapLayer = function(t, e, o, n, s) { n |= 0, s |= 0, i.Sprite.call(this, t, 0, 0), this.map = e, this.index = o, this.layer = e.layers[o], this.canvas = PIXI.CanvasPool.create(this, n, s), this.context = this.canvas.getContext("2d"), this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))), this.type = i.TILEMAPLAYER, this.physicsType = i.TILEMAPLAYER, this.renderSettings = { enableScrollDelta: !1, overdrawRatio: .2, copyCanvas: null }, this.debug = !1, this.exists = !0, this.debugSettings = { missingImageFill: "rgb(255,255,255)", debuggedTileOverfill: "rgba(0,255,0,0.4)", forceFullRedraw: !0, debugAlpha: .5, facingEdgeStroke: "rgba(0,255,0,1)", collidingTileOverfill: "rgba(0,255,0,0.2)" }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, this._wrap = !1, this._mc = { scrollX: 0, scrollY: 0, renderWidth: 0, renderHeight: 0, tileWidth: e.tileWidth, tileHeight: e.tileHeight, cw: e.tileWidth, ch: e.tileHeight, tilesets: [] }, this._scrollX = 0, this._scrollY = 0, this._results = [], t.device.canvasBitBltShift || (this.renderSettings.copyCanvas = i.TilemapLayer.ensureSharedCopyCanvas()), this.fixedToCamera = !0 }, i.TilemapLayer.prototype = Object.create(i.Sprite.prototype), i.TilemapLayer.prototype.constructor = i.TilemapLayer, i.TilemapLayer.prototype.preUpdateCore = i.Component.Core.preUpdate, i.TilemapLayer.sharedCopyCanvas = null, i.TilemapLayer.ensureSharedCopyCanvas = function() { return this.sharedCopyCanvas || (this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2)), this.sharedCopyCanvas }, i.TilemapLayer.prototype.preUpdate = function() { return this.preUpdateCore() }, i.TilemapLayer.prototype.postUpdate = function() { this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y }, i.TilemapLayer.prototype._renderCanvas = function(t) { this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderCanvas.call(this, t) }, i.TilemapLayer.prototype._renderWebGL = function(t) { this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderWebGL.call(this, t) }, i.TilemapLayer.prototype.destroy = function() { PIXI.CanvasPool.remove(this), i.Component.Destroy.prototype.destroy.call(this) }, i.TilemapLayer.prototype.resize = function(t, e) { this.canvas.width = t, this.canvas.height = e, this.texture.frame.resize(t, e), this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.texture.baseTexture.width = t, this.texture.baseTexture.height = e, this.texture.baseTexture.dirty(), this.texture.requiresUpdate = !0, this.texture._updateUvs(), this.dirty = !0 }, i.TilemapLayer.prototype.resizeWorld = function() { this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y) }, i.TilemapLayer.prototype._fixX = function(t) { return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? t : 0 === this.scrollFactorX && 0 !== this.position.x ? t - this.position.x : this._scrollX + (t - this._scrollX / this.scrollFactorX) }, i.TilemapLayer.prototype._unfixX = function(t) { return 1 === this.scrollFactorX ? t : this._scrollX / this.scrollFactorX + (t - this._scrollX) }, i.TilemapLayer.prototype._fixY = function(t) { return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? t : 0 === this.scrollFactorY && 0 !== this.position.y ? t - this.position.y : this._scrollY + (t - this._scrollY / this.scrollFactorY) }, i.TilemapLayer.prototype._unfixY = function(t) { return 1 === this.scrollFactorY ? t : this._scrollY / this.scrollFactorY + (t - this._scrollY) }, i.TilemapLayer.prototype.getTileX = function(t) { return Math.floor(this._fixX(t) / this._mc.tileWidth) }, i.TilemapLayer.prototype.getTileY = function(t) { return Math.floor(this._fixY(t) / this._mc.tileHeight) }, i.TilemapLayer.prototype.getTileXY = function(t, e, i) { return i.x = this.getTileX(t), i.y = this.getTileY(e), i }, i.TilemapLayer.prototype.getRayCastTiles = function(t, e, i, o) { e || (e = this.rayStepRate), void 0 === i && (i = !1), void 0 === o && (o = !1); var n = this.getTiles(t.x, t.y, t.width, t.height, i, o); if (0 === n.length) return []; for (var s = t.coordinatesOnLine(e), r = [], a = 0; a < n.length; a++)
                for (var h = 0; h < s.length; h++) { var l = n[a],
                        c = s[h]; if (l.containsPoint(c[0], c[1])) { r.push(l); break } }
            return r }, i.TilemapLayer.prototype.getTiles = function(t, e, i, o, n, s) { void 0 === n && (n = !1), void 0 === s && (s = !1); var r = !(n || s);
            t = this._fixX(t), e = this._fixY(e); for (var a = Math.floor(t / (this._mc.cw * this.scale.x)), h = Math.floor(e / (this._mc.ch * this.scale.y)), l = Math.ceil((t + i) / (this._mc.cw * this.scale.x)) - a, c = Math.ceil((e + o) / (this._mc.ch * this.scale.y)) - h; this._results.length;) this._results.pop(); for (var d = h; d < h + c; d++)
                for (var u = a; u < a + l; u++) { var p = this.layer.data[d];
                    p && p[u] && (r || p[u].isInteresting(n, s)) && this._results.push(p[u]) }
            return this._results.slice() }, i.TilemapLayer.prototype.resolveTileset = function(t) { var e = this._mc.tilesets; if (t < 2e3)
                for (; e.length < t;) e.push(void 0); var i = this.map.tiles[t] && this.map.tiles[t][2]; if (null !== i) { var o = this.map.tilesets[i]; if (o && o.containsTileIndex(t)) return e[t] = o } return e[t] = null }, i.TilemapLayer.prototype.resetTilesetCache = function() { for (var t = this._mc.tilesets; t.length;) t.pop() }, i.TilemapLayer.prototype.setScale = function(t, e) { t = t || 1, e = e || t; for (var i = 0; i < this.layer.data.length; i++)
                for (var o = this.layer.data[i], n = 0; n < o.length; n++) { var s = o[n];
                    s.width = this.map.tileWidth * t, s.height = this.map.tileHeight * e, s.worldX = s.x * s.width, s.worldY = s.y * s.height } this.scale.setTo(t, e) }, i.TilemapLayer.prototype.shiftCanvas = function(t, e, i) { var o = t.canvas,
                n = o.width - Math.abs(e),
                s = o.height - Math.abs(i),
                r = 0,
                a = 0,
                h = e,
                l = i;
            e < 0 && (r = -e, h = 0), i < 0 && (a = -i, l = 0); var c = this.renderSettings.copyCanvas; if (c) {
                (c.width < n || c.height < s) && (c.width = n, c.height = s); var d = c.getContext("2d");
                d.clearRect(0, 0, n, s), d.drawImage(o, r, a, n, s, 0, 0, n, s), t.clearRect(h, l, n, s), t.drawImage(c, 0, 0, n, s, h, l, n, s) } else t.save(), t.globalCompositeOperation = "copy", t.drawImage(o, r, a, n, s, h, l, n, s), t.restore() }, i.TilemapLayer.prototype.renderRegion = function(t, e, i, o, n, s) { var r = this.context,
                a = this.layer.width,
                h = this.layer.height,
                l = this._mc.tileWidth,
                c = this._mc.tileHeight,
                d = this._mc.tilesets,
                u = NaN;
            this._wrap || (i <= n && (i = Math.max(0, i), n = Math.min(a - 1, n)), o <= s && (o = Math.max(0, o), s = Math.min(h - 1, s))); var p, m, f, y, b, g, _ = i * l - t,
                v = (i + (1 << 20) * a) % a; for (y = (o + (1 << 20) * h) % h, g = s - o, m = o * c - e; g >= 0; y++, g--, m += c) { y >= h && (y -= h); var x = this.layer.data[y]; for (f = v, b = n - i, p = _; b >= 0; f++, b--, p += l) { f >= a && (f -= a); var S = x[f]; if (S && !(S.index < 0)) { var C = S.index,
                            w = d[C];
                        void 0 === w && (w = this.resolveTileset(C)), S.alpha === u || this.debug || (r.globalAlpha = S.alpha, u = S.alpha), w ? S.rotation || S.flipped ? (r.save(), r.translate(p + S.centerX, m + S.centerY), r.rotate(S.rotation), S.flipped && r.scale(-1, 1), w.draw(r, -S.centerX, -S.centerY, C), r.restore()) : w.draw(r, p, m, C) : this.debugSettings.missingImageFill && (r.fillStyle = this.debugSettings.missingImageFill, r.fillRect(p, m, l, c)), S.debug && this.debugSettings.debuggedTileOverfill && (r.fillStyle = this.debugSettings.debuggedTileOverfill, r.fillRect(p, m, l, c)) } } } }, i.TilemapLayer.prototype.renderDeltaScroll = function(t, e) { var i = this._mc.scrollX,
                o = this._mc.scrollY,
                n = this.canvas.width,
                s = this.canvas.height,
                r = this._mc.tileWidth,
                a = this._mc.tileHeight,
                h = 0,
                l = -r,
                c = 0,
                d = -a; if (t < 0 ? (h = n + t, l = n - 1) : t > 0 && (l = t), e < 0 ? (c = s + e, d = s - 1) : e > 0 && (d = e), this.shiftCanvas(this.context, t, e), h = Math.floor((h + i) / r), l = Math.floor((l + i) / r), c = Math.floor((c + o) / a), d = Math.floor((d + o) / a), h <= l) { this.context.clearRect(h * r - i, 0, (l - h + 1) * r, s); var u = Math.floor((0 + o) / a),
                    p = Math.floor((s - 1 + o) / a);
                this.renderRegion(i, o, h, u, l, p) } if (c <= d) { this.context.clearRect(0, c * a - o, n, (d - c + 1) * a); var m = Math.floor((0 + i) / r),
                    f = Math.floor((n - 1 + i) / r);
                this.renderRegion(i, o, m, c, f, d) } }, i.TilemapLayer.prototype.renderFull = function() { var t = this._mc.scrollX,
                e = this._mc.scrollY,
                i = this.canvas.width,
                o = this.canvas.height,
                n = this._mc.tileWidth,
                s = this._mc.tileHeight,
                r = Math.floor(t / n),
                a = Math.floor((i - 1 + t) / n),
                h = Math.floor(e / s),
                l = Math.floor((o - 1 + e) / s);
            this.context.clearRect(0, 0, i, o), this.renderRegion(t, e, r, h, a, l) }, i.TilemapLayer.prototype.render = function() { var t = !1; if (this.visible) {
                (this.dirty || this.layer.dirty) && (this.layer.dirty = !1, t = !0); var e = this.canvas.width,
                    i = this.canvas.height,
                    o = 0 | this._scrollX,
                    n = 0 | this._scrollY,
                    s = this._mc,
                    r = s.scrollX - o,
                    a = s.scrollY - n; if (t || 0 !== r || 0 !== a || s.renderWidth !== e || s.renderHeight !== i) return this.context.save(), s.scrollX = o, s.scrollY = n, s.renderWidth === e && s.renderHeight === i || (s.renderWidth = e, s.renderHeight = i), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, this.debugSettings.forceFullRedraw && (t = !0)), !t && this.renderSettings.enableScrollDelta && Math.abs(r) + Math.abs(a) < Math.min(e, i) ? this.renderDeltaScroll(r, a) : this.renderFull(), this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.texture.baseTexture.dirty(), this.dirty = !1, this.context.restore(), !0 } }, i.TilemapLayer.prototype.renderDebug = function() { var t, e, i, o, n, s, r = this._mc.scrollX,
                a = this._mc.scrollY,
                h = this.context,
                l = this.canvas.width,
                c = this.canvas.height,
                d = this.layer.width,
                u = this.layer.height,
                p = this._mc.tileWidth,
                m = this._mc.tileHeight,
                f = Math.floor(r / p),
                y = Math.floor((l - 1 + r) / p),
                b = Math.floor(a / m),
                g = Math.floor((c - 1 + a) / m),
                _ = f * p - r,
                v = b * m - a,
                x = (f + (1 << 20) * d) % d,
                S = (b + (1 << 20) * u) % u; for (h.strokeStyle = this.debugSettings.facingEdgeStroke, o = S, s = g - b, e = v; s >= 0; o++, s--, e += m) { o >= u && (o -= u); var C = this.layer.data[o]; for (i = x, n = y - f, t = _; n >= 0; i++, n--, t += p) { i >= d && (i -= d); var w = C[i];!w || w.index < 0 || !w.collides || (this.debugSettings.collidingTileOverfill && (h.fillStyle = this.debugSettings.collidingTileOverfill, h.fillRect(t, e, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (h.beginPath(), w.faceTop && (h.moveTo(t, e), h.lineTo(t + this._mc.cw, e)), w.faceBottom && (h.moveTo(t, e + this._mc.ch), h.lineTo(t + this._mc.cw, e + this._mc.ch)), w.faceLeft && (h.moveTo(t, e), h.lineTo(t, e + this._mc.ch)), w.faceRight && (h.moveTo(t + this._mc.cw, e), h.lineTo(t + this._mc.cw, e + this._mc.ch)), h.closePath(), h.stroke())) } } }, Object.defineProperty(i.TilemapLayer.prototype, "wrap", { get: function() { return this._wrap }, set: function(t) { this._wrap = t, this.dirty = !0 } }), Object.defineProperty(i.TilemapLayer.prototype, "scrollX", { get: function() { return this._scrollX }, set: function(t) { this._scrollX = t } }), Object.defineProperty(i.TilemapLayer.prototype, "scrollY", { get: function() { return this._scrollY }, set: function(t) { this._scrollY = t } }), Object.defineProperty(i.TilemapLayer.prototype, "collisionWidth", { get: function() { return this._mc.cw }, set: function(t) { this._mc.cw = 0 | t, this.dirty = !0 } }), Object.defineProperty(i.TilemapLayer.prototype, "collisionHeight", { get: function() { return this._mc.ch }, set: function(t) { this._mc.ch = 0 | t, this.dirty = !0 } }), i.TilemapParser = { INSERT_NULL: !1, parse: function(t, e, o, n, s, r) { if (void 0 === o && (o = 32), void 0 === n && (n = 32), void 0 === s && (s = 10), void 0 === r && (r = 10), void 0 === e) return this.getEmptyData(); if (null === e) return this.getEmptyData(o, n, s, r); var a = t.cache.getTilemapData(e); if (a) { if (a.format === i.Tilemap.CSV) return this.parseCSV(e, a.data, o, n); if (!a.format || a.format === i.Tilemap.TILED_JSON) return this.parseTiledJSON(a.data) } }, parseCSV: function(t, e, o, n) { for (var s = this.getEmptyData(), r = [], a = (e = e.trim()).split("\n"), h = a.length, l = 0, c = 0; c < a.length; c++) { r[c] = []; for (var d = a[c].split(","), u = 0; u < d.length; u++) r[c][u] = new i.Tile(s.layers[0], parseInt(d[u], 10), u, c, o, n);
                    0 === l && (l = d.length) } return s.format = i.Tilemap.CSV, s.name = t, s.width = l, s.height = h, s.tileWidth = o, s.tileHeight = n, s.widthInPixels = l * o, s.heightInPixels = h * n, s.layers[0].width = l, s.layers[0].height = h, s.layers[0].widthInPixels = s.widthInPixels, s.layers[0].heightInPixels = s.heightInPixels, s.layers[0].data = r, s }, getEmptyData: function(t, e, i, o) { return { width: void 0 !== i && null !== i ? i : 0, height: void 0 !== o && null !== o ? o : 0, tileWidth: void 0 !== t && null !== t ? t : 0, tileHeight: void 0 !== e && null !== e ? e : 0, orientation: "orthogonal", version: "1", properties: {}, widthInPixels: 0, heightInPixels: 0, layers: [{ name: "layer", x: 0, y: 0, width: 0, height: 0, widthInPixels: 0, heightInPixels: 0, alpha: 1, visible: !0, properties: {}, indexes: [], callbacks: [], bodies: [], data: [] }], images: [], objects: {}, collision: {}, tilesets: [], tiles: [] } }, parseTiledJSON: function(t) {
                function e(t, e) { var i = {}; for (var o in e) { var n = e[o];
                        void 0 !== t[n] && (i[n] = t[n]) } return i } if ("orthogonal" !== t.orientation) return null; for (var o = { width: t.width, height: t.height, tileWidth: t.tilewidth, tileHeight: t.tileheight, orientation: t.orientation, format: i.Tilemap.TILED_JSON, version: t.version, properties: t.properties, widthInPixels: t.width * t.tilewidth, heightInPixels: t.height * t.tileheight }, n = [], s = 0; s < t.layers.length; s++)
                    if ("tilelayer" === t.layers[s].type) { var r = t.layers[s]; if (!r.compression && r.encoding && "base64" === r.encoding) { for (var a = window.atob(r.data), h = a.length, l = new Array(h), c = 0; c < h; c += 4) l[c / 4] = (a.charCodeAt(c) | a.charCodeAt(c + 1) << 8 | a.charCodeAt(c + 2) << 16 | a.charCodeAt(c + 3) << 24) >>> 0;
                            r.data = l, delete r.encoding } else if (r.compression) continue;
                        V = { name: r.name, x: r.x, y: r.y, width: r.width, height: r.height, widthInPixels: r.width * t.tilewidth, heightInPixels: r.height * t.tileheight, alpha: r.opacity, visible: r.visible, properties: {}, indexes: [], callbacks: [], bodies: [] };
                        r.properties && (V.properties = r.properties); for (var d, u, p, m = 0, f = [], y = [], b = 0, h = r.data.length; b < h; b++) { if (d = 0, u = !1, P = r.data[b], p = 0, P > 536870912) switch (P > 2147483648 && (P -= 2147483648, p += 4), P > 1073741824 && (P -= 1073741824, p += 2), P > 536870912 && (P -= 536870912, p += 1), p) {
                                case 5:
                                    d = Math.PI / 2; break;
                                case 6:
                                    d = Math.PI; break;
                                case 3:
                                    d = 3 * Math.PI / 2; break;
                                case 4:
                                    d = 0, u = !0; break;
                                case 7:
                                    d = Math.PI / 2, u = !0; break;
                                case 2:
                                    d = Math.PI, u = !0; break;
                                case 1:
                                    d = 3 * Math.PI / 2, u = !0 } P > 0 ? ((G = new i.Tile(V, P, m, y.length, t.tilewidth, t.tileheight)).rotation = d, G.flipped = u, 0 !== p && (G.flippedVal = p), f.push(G)) : i.TilemapParser.INSERT_NULL ? f.push(null) : f.push(new i.Tile(V, -1, m, y.length, t.tilewidth, t.tileheight)), ++m === r.width && (y.push(f), m = 0, f = []) } V.data = y, n.push(V) } o.layers = n; for (var g = [], s = 0; s < t.layers.length; s++)
                    if ("imagelayer" === t.layers[s].type) { var _ = t.layers[s],
                            v = { name: _.name, image: _.image, x: _.x, y: _.y, alpha: _.opacity, visible: _.visible, properties: {} };
                        _.properties && (v.properties = _.properties), g.push(v) } o.images = g; for (var x = [], S = [], C = null, s = 0; s < t.tilesets.length; s++) { if ((N = t.tilesets[s]).image) { var w = new i.Tileset(N.name, N.firstgid, N.tilewidth, N.tileheight, N.margin, N.spacing, N.properties);
                        N.tileproperties && (w.tileProperties = N.tileproperties), w.updateTileData(N.imagewidth, N.imageheight), x.push(w) } else { var A = new i.ImageCollection(N.name, N.firstgid, N.tilewidth, N.tileheight, N.margin, N.spacing, N.properties); for (var T in N.tiles) { var v = N.tiles[T].image,
                                P = N.firstgid + parseInt(T, 10);
                            A.addImage(P, v) } S.push(A) } C && (C.lastgid = N.firstgid - 1), C = N } o.tilesets = x, o.imagecollections = S; for (var k = {}, M = {}, s = 0; s < t.layers.length; s++)
                    if ("objectgroup" === t.layers[s].type) { var E = t.layers[s];
                        k[E.name] = [], M[E.name] = []; for (var B = 0, h = E.objects.length; B < h; B++)
                            if (E.objects[B].gid) { D = { gid: E.objects[B].gid, name: E.objects[B].name, type: E.objects[B].hasOwnProperty("type") ? E.objects[B].type : "", x: E.objects[B].x, y: E.objects[B].y, visible: E.objects[B].visible, properties: E.objects[B].properties };
                                E.objects[B].rotation && (D.rotation = E.objects[B].rotation), k[E.name].push(D) } else if (E.objects[B].polyline) { D = { name: E.objects[B].name, type: E.objects[B].type, x: E.objects[B].x, y: E.objects[B].y, width: E.objects[B].width, height: E.objects[B].height, visible: E.objects[B].visible, properties: E.objects[B].properties };
                            E.objects[B].rotation && (D.rotation = E.objects[B].rotation), D.polyline = []; for (I = 0; I < E.objects[B].polyline.length; I++) D.polyline.push([E.objects[B].polyline[I].x, E.objects[B].polyline[I].y]);
                            M[E.name].push(D), k[E.name].push(D) } else if (E.objects[B].polygon) {
                            (D = e(E.objects[B], ["name", "type", "x", "y", "visible", "rotation", "properties"])).polygon = []; for (var I = 0; I < E.objects[B].polygon.length; I++) D.polygon.push([E.objects[B].polygon[I].x, E.objects[B].polygon[I].y]);
                            k[E.name].push(D) } else if (E.objects[B].ellipse) { var D = e(E.objects[B], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                            k[E.name].push(D) } else(D = e(E.objects[B], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"])).rectangle = !0, k[E.name].push(D) } o.objects = k, o.collision = M, o.tiles = []; for (s = 0; s < o.tilesets.length; s++)
                    for (var m = (N = o.tilesets[s]).tileMargin, L = N.tileMargin, O = 0, R = 0, F = 0, b = N.firstgid; b < N.firstgid + N.total && (o.tiles[b] = [m, L, s], m += N.tileWidth + N.tileSpacing, ++O !== N.total) && (++R !== N.columns || (m = N.tileMargin, L += N.tileHeight + N.tileSpacing, R = 0, ++F !== N.rows)); b++); for (var V, G, U, N, s = 0; s < o.layers.length; s++) { V = o.layers[s], N = null; for (c = 0; c < V.data.length; c++) { f = V.data[c]; for (var j = 0; j < f.length; j++) null === (G = f[j]) || G.index < 0 || (U = o.tiles[G.index][2], (N = o.tilesets[U]).tileProperties && N.tileProperties[G.index - N.firstgid] && (G.properties = i.Utils.mixin(N.tileProperties[G.index - N.firstgid], G.properties))) } } return o } }, i.Tileset = function(t, e, i, o, n, s, r) {
            (void 0 === i || i <= 0) && (i = 32), (void 0 === o || o <= 0) && (o = 32), void 0 === n && (n = 0), void 0 === s && (s = 0), this.name = t, this.firstgid = 0 | e, this.tileWidth = 0 | i, this.tileHeight = 0 | o, this.tileMargin = 0 | n, this.tileSpacing = 0 | s, this.properties = r || {}, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = [] }, i.Tileset.prototype = { draw: function(t, e, i, o) { var n = o - this.firstgid << 1;
                n >= 0 && n + 1 < this.drawCoords.length && t.drawImage(this.image, this.drawCoords[n], this.drawCoords[n + 1], this.tileWidth, this.tileHeight, e, i, this.tileWidth, this.tileHeight) }, containsTileIndex: function(t) { return t >= this.firstgid && t < this.firstgid + this.total }, setImage: function(t) { this.image = t, this.updateTileData(t.width, t.height) }, setSpacing: function(t, e) { this.tileMargin = 0 | t, this.tileSpacing = 0 | e, this.image && this.updateTileData(this.image.width, this.image.height) }, updateTileData: function(t, e) { var i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing),
                    o = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
                i = Math.floor(i), o = Math.floor(o), this.rows && this.rows !== i || this.columns && this.columns, this.rows = i, this.columns = o, this.total = i * o, this.drawCoords.length = 0; for (var n = this.tileMargin, s = this.tileMargin, r = 0; r < this.rows; r++) { for (var a = 0; a < this.columns; a++) this.drawCoords.push(n), this.drawCoords.push(s), n += this.tileWidth + this.tileSpacing;
                    n = this.tileMargin, s += this.tileHeight + this.tileSpacing } } }, i.Tileset.prototype.constructor = i.Tileset, i.Particle = function(t, e, o, n, s) { i.Sprite.call(this, t, e, o, n, s), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0 }, i.Particle.prototype = Object.create(i.Sprite.prototype), i.Particle.prototype.constructor = i.Particle, i.Particle.prototype.update = function() { this.autoScale && (--this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (--this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1) }, i.Particle.prototype.onEmit = function() {}, i.Particle.prototype.setAlphaData = function(t) { this.alphaData = t, this._a = t.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0 }, i.Particle.prototype.setScaleData = function(t) { this.scaleData = t, this._s = t.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0 }, i.Particle.prototype.reset = function(t, e, o) { return i.Component.Reset.prototype.reset.call(this, t, e, o), this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this }, i.Particles = function(t) { this.game = t, this.emitters = {}, this.ID = 0 }, i.Particles.prototype = { add: function(t) { return this.emitters[t.name] = t, t }, remove: function(t) { delete this.emitters[t.name] }, update: function() { for (var t in this.emitters) this.emitters[t].exists && this.emitters[t].update() } }, i.Particles.prototype.constructor = i.Particles, i.Particles.Arcade = {}, i.Particles.Arcade.Emitter = function(t, e, o, n) { this.maxParticles = n || 50, i.Group.call(this, t), this.name = "emitter" + this.game.particles.ID++, this.type = i.EMITTER, this.physicsType = i.GROUP, this.area = new i.Rectangle(e, o, 1, 1), this.minParticleSpeed = new i.Point(-100, -100), this.maxParticleSpeed = new i.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.gravity = 100, this.particleClass = i.Particle, this.particleDrag = new i.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new i.Point, this.on = !1, this.particleAnchor = new i.Point(.5, .5), this.blendMode = i.blendModes.NORMAL, this.emitX = e, this.emitY = o, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this._minParticleScale = new i.Point(1, 1), this._maxParticleScale = new i.Point(1, 1), this._quantity = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, this._flowTotal = 0, this._explode = !0, this._frames = null }, i.Particles.Arcade.Emitter.prototype = Object.create(i.Group.prototype), i.Particles.Arcade.Emitter.prototype.constructor = i.Particles.Arcade.Emitter, i.Particles.Arcade.Emitter.prototype.update = function() { if (this.on && this.game.time.time >= this._timer)
                if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal)
                    if (this._flowQuantity > 0) { for (t = 0; t < this._flowQuantity; t++)
                            if (this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal)) { this.on = !1; break } } else this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1));
            else this.emitParticle() && (this._counter++, this._quantity > 0 && this._counter >= this._quantity && (this.on = !1)); for (var t = this.children.length; t--;) this.children[t].exists && this.children[t].update() }, i.Particles.Arcade.Emitter.prototype.makeParticles = function(t, e, i, o, n) { void 0 === e && (e = 0), void 0 === i && (i = this.maxParticles), void 0 === o && (o = !1), void 0 === n && (n = !1); var s, r = 0,
                a = t,
                h = e; for (this._frames = e, i > this.maxParticles && (this.maxParticles = i); r < i;) Array.isArray(t) && (a = this.game.rnd.pick(t)), Array.isArray(e) && (h = this.game.rnd.pick(e)), s = new this.particleClass(this.game, 0, 0, a, h), this.game.physics.arcade.enable(s, !1), o ? (s.body.checkCollision.any = !0, s.body.checkCollision.none = !1) : s.body.checkCollision.none = !0, s.body.collideWorldBounds = n, s.body.skipQuadTree = !0, s.exists = !1, s.visible = !1, s.anchor.copyFrom(this.particleAnchor), this.add(s), r++; return this }, i.Particles.Arcade.Emitter.prototype.kill = function() { return this.on = !1, this.alive = !1, this.exists = !1, this }, i.Particles.Arcade.Emitter.prototype.revive = function() { return this.alive = !0, this.exists = !0, this }, i.Particles.Arcade.Emitter.prototype.explode = function(t, e) { return this._flowTotal = 0, this.start(!0, t, 0, e, !1), this }, i.Particles.Arcade.Emitter.prototype.flow = function(t, e, i, o, n) { return void 0 !== i && 0 !== i || (i = 1), void 0 === o && (o = -1), void 0 === n && (n = !0), i > this.maxParticles && (i = this.maxParticles), this._counter = 0, this._flowQuantity = i, this._flowTotal = o, n ? (this.start(!0, t, e, i), this._counter += i, this.on = !0, this._timer = this.game.time.time + e * this.game.time.slowMotion) : this.start(!1, t, e, i), this }, i.Particles.Arcade.Emitter.prototype.start = function(t, e, i, o, n) { if (void 0 === t && (t = !0), void 0 === e && (e = 0), void 0 !== i && null !== i || (i = 250), void 0 === o && (o = 0), void 0 === n && (n = !1), o > this.maxParticles && (o = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = e, this.frequency = i, t || n)
                for (var s = 0; s < o; s++) this.emitParticle();
            else this.on = !0, this._quantity = o, this._counter = 0, this._timer = this.game.time.time + i * this.game.time.slowMotion; return this }, i.Particles.Arcade.Emitter.prototype.emitParticle = function(t, e, i, o) { void 0 === t && (t = null), void 0 === e && (e = null); var n = this.getFirstExists(!1); if (null === n) return !1; var s = this.game.rnd;
            void 0 !== i && void 0 !== o ? n.loadTexture(i, o) : void 0 !== i && n.loadTexture(i); var r = this.emitX,
                a = this.emitY;
            null !== t ? r = t : this.width > 1 && (r = s.between(this.left, this.right)), null !== e ? a = e : this.height > 1 && (a = s.between(this.top, this.bottom)), n.reset(r, a), n.angle = 0, n.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(n) : this.particleSendToBack && this.sendToBack(n), this.autoScale ? n.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? n.scale.set(s.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y || n.scale.set(s.realInRange(this._minParticleScale.x, this._maxParticleScale.x), s.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), void 0 === o && (Array.isArray(this._frames) ? n.frame = this.game.rnd.pick(this._frames) : n.frame = this._frames), this.autoAlpha ? n.setAlphaData(this.alphaData) : n.alpha = s.realInRange(this.minParticleAlpha, this.maxParticleAlpha), n.blendMode = this.blendMode; var h = n.body; return h.updateBounds(), h.bounce.copyFrom(this.bounce), h.drag.copyFrom(this.particleDrag), h.velocity.x = s.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), h.velocity.y = s.between(this.minParticleSpeed.y, this.maxParticleSpeed.y), h.angularVelocity = s.between(this.minRotation, this.maxRotation), h.gravity.y = this.gravity, h.angularDrag = this.angularDrag, n.onEmit(), !0 }, i.Particles.Arcade.Emitter.prototype.destroy = function() { this.game.particles.remove(this), i.Group.prototype.destroy.call(this, !0, !1) }, i.Particles.Arcade.Emitter.prototype.setSize = function(t, e) { return this.area.width = t, this.area.height = e, this }, i.Particles.Arcade.Emitter.prototype.setXSpeed = function(t, e) { return t = t || 0, e = e || 0, this.minParticleSpeed.x = t, this.maxParticleSpeed.x = e, this }, i.Particles.Arcade.Emitter.prototype.setYSpeed = function(t, e) { return t = t || 0, e = e || 0, this.minParticleSpeed.y = t, this.maxParticleSpeed.y = e, this }, i.Particles.Arcade.Emitter.prototype.setRotation = function(t, e) { return t = t || 0, e = e || 0, this.minRotation = t, this.maxRotation = e, this }, i.Particles.Arcade.Emitter.prototype.setAlpha = function(t, e, o, n, s) { if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === o && (o = 0), void 0 === n && (n = i.Easing.Linear.None), void 0 === s && (s = !1), this.minParticleAlpha = t, this.maxParticleAlpha = e, this.autoAlpha = !1, o > 0 && t !== e) { var r = { v: t },
                    a = this.game.make.tween(r).to({ v: e }, o, n);
                a.yoyo(s), this.alphaData = a.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0 } return this }, i.Particles.Arcade.Emitter.prototype.setScale = function(t, e, o, n, s, r, a) { if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === o && (o = 1), void 0 === n && (n = 1), void 0 === s && (s = 0), void 0 === r && (r = i.Easing.Linear.None), void 0 === a && (a = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(t, o), this._maxParticleScale.set(e, n), this.autoScale = !1, s > 0 && (t !== e || o !== n)) { var h = { x: t, y: o },
                    l = this.game.make.tween(h).to({ x: e, y: n }, s, r);
                l.yoyo(a), this.scaleData = l.generateData(60), this.scaleData.reverse(), this.autoScale = !0 } return this }, i.Particles.Arcade.Emitter.prototype.at = function(t) { return t.center ? (this.emitX = t.center.x, this.emitY = t.center.y) : (this.emitX = t.world.x + t.anchor.x * t.width, this.emitY = t.world.y + t.anchor.y * t.height), this }, Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "width", { get: function() { return this.area.width }, set: function(t) { this.area.width = t } }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "height", { get: function() { return this.area.height }, set: function(t) { this.area.height = t } }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "x", { get: function() { return this.emitX }, set: function(t) { this.emitX = t } }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "y", { get: function() { return this.emitY }, set: function(t) { this.emitY = t } }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "left", { get: function() { return Math.floor(this.x - this.area.width / 2) } }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "right", { get: function() { return Math.floor(this.x + this.area.width / 2) } }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "top", { get: function() { return Math.floor(this.y - this.area.height / 2) } }), Object.defineProperty(i.Particles.Arcade.Emitter.prototype, "bottom", { get: function() { return Math.floor(this.y + this.area.height / 2) } }), i.Weapon = function(t, e) { i.Plugin.call(this, t, e), this.bullets = null, this.autoExpandBulletsGroup = !1, this.autofire = !1, this.shots = 0, this.fireLimit = 0, this.fireRate = 100, this.fireRateVariance = 0, this.fireFrom = new i.Rectangle(0, 0, 1, 1), this.fireAngle = i.ANGLE_UP, this.bulletInheritSpriteSpeed = !1, this.bulletAnimation = "", this.bulletFrameRandom = !1, this.bulletFrameCycle = !1, this.bulletWorldWrap = !1, this.bulletWorldWrapPadding = 0, this.bulletAngleOffset = 0, this.bulletAngleVariance = 0, this.bulletSpeed = 200, this.bulletSpeedVariance = 0, this.bulletLifespan = 0, this.bulletKillDistance = 0, this.bulletGravity = new i.Point(0, 0), this.bulletRotateToVelocity = !1, this.bulletKey = "", this.bulletFrame = "", this._bulletClass = i.Bullet, this._bulletCollideWorldBounds = !1, this._bulletKillType = i.Weapon.KILL_WORLD_BOUNDS, this._data = { customBody: !1, width: 0, height: 0, offsetX: 0, offsetY: 0 }, this.bounds = new i.Rectangle, this.bulletBounds = t.world.bounds, this.bulletFrames = [], this.bulletFrameIndex = 0, this.anims = {}, this.onFire = new i.Signal, this.onKill = new i.Signal, this.onFireLimit = new i.Signal, this.trackedSprite = null, this.trackedPointer = null, this.trackRotation = !1, this.trackOffset = new i.Point, this._nextFire = 0, this._rotatedPoint = new i.Point }, i.Weapon.prototype = Object.create(i.Plugin.prototype), i.Weapon.prototype.constructor = i.Weapon, i.Weapon.KILL_NEVER = 0, i.Weapon.KILL_LIFESPAN = 1, i.Weapon.KILL_DISTANCE = 2, i.Weapon.KILL_WEAPON_BOUNDS = 3, i.Weapon.KILL_CAMERA_BOUNDS = 4, i.Weapon.KILL_WORLD_BOUNDS = 5, i.Weapon.KILL_STATIC_BOUNDS = 6, i.Weapon.prototype.createBullets = function(t, e, o, n) { return void 0 === t && (t = 1), void 0 === n && (n = this.game.world), this.bullets || (this.bullets = this.game.add.physicsGroup(i.Physics.ARCADE, n), this.bullets.classType = this._bulletClass), 0 !== t && (-1 === t && (this.autoExpandBulletsGroup = !0, t = 1), this.bullets.createMultiple(t, e, o), this.bullets.setAll("data.bulletManager", this), this.bulletKey = e, this.bulletFrame = o), this }, i.Weapon.prototype.forEach = function(t, e) { return this.bullets.forEachExists(t, e, arguments), this }, i.Weapon.prototype.pauseAll = function() { return this.bullets.setAll("body.enable", !1), this }, i.Weapon.prototype.resumeAll = function() { return this.bullets.setAll("body.enable", !0), this }, i.Weapon.prototype.killAll = function() { return this.bullets.callAllExists("kill", !0), this.bullets.setAll("body.enable", !0), this }, i.Weapon.prototype.resetShots = function(t) { return this.shots = 0, void 0 !== t && (this.fireLimit = t), this }, i.Weapon.prototype.destroy = function() { this.parent.remove(this, !1), this.bullets.destroy(), this.game = null, this.parent = null, this.active = !1, this.visible = !1 }, i.Weapon.prototype.update = function() { this._bulletKillType === i.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(), this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)), this.autofire && this.fire() }, i.Weapon.prototype.trackSprite = function(t, e, i, o) { return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = !1), this.trackedPointer = null, this.trackedSprite = t, this.trackRotation = o, this.trackOffset.set(e, i), this }, i.Weapon.prototype.trackPointer = function(t, e, i) { return void 0 === t && (t = this.game.input.activePointer), void 0 === e && (e = 0), void 0 === i && (i = 0), this.trackedPointer = t, this.trackedSprite = null, this.trackRotation = !1, this.trackOffset.set(e, i), this }, i.Weapon.prototype.fire = function(t, e, o) { if (this.game.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit) return !1; var n = this.bulletSpeed;
            0 !== this.bulletSpeedVariance && (n += i.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)), t ? this.fireFrom.width > 1 ? this.fireFrom.centerOn(t.x, t.y) : (this.fireFrom.x = t.x, this.fireFrom.y = t.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y), this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.rotation), this.fireFrom.width > 1 ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x, this.fireFrom.y = this._rotatedPoint.y)) : this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y), this.bulletInheritSpriteSpeed && (n += this.trackedSprite.body.speed)) : this.trackedPointer && (this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y)); var s = this.fireFrom.width > 1 ? this.fireFrom.randomX : this.fireFrom.x,
                r = this.fireFrom.height > 1 ? this.fireFrom.randomY : this.fireFrom.y,
                a = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
            void 0 !== e && void 0 !== o && (a = this.game.math.radToDeg(Math.atan2(o - r, e - s))), 0 !== this.bulletAngleVariance && (a += i.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance)); var h = 0,
                l = 0;
            0 === a || 180 === a ? h = Math.cos(this.game.math.degToRad(a)) * n : 90 === a || 270 === a ? l = Math.sin(this.game.math.degToRad(a)) * n : (h = Math.cos(this.game.math.degToRad(a)) * n, l = Math.sin(this.game.math.degToRad(a)) * n); var c = null; if (this.autoExpandBulletsGroup ? (c = this.bullets.getFirstExists(!1, !0, s, r, this.bulletKey, this.bulletFrame)).data.bulletManager = this : c = this.bullets.getFirstExists(!1), c) { if (c.reset(s, r), c.data.fromX = s, c.data.fromY = r, c.data.killType = this.bulletKillType, c.data.killDistance = this.bulletKillDistance, c.data.rotateToVelocity = this.bulletRotateToVelocity, this.bulletKillType === i.Weapon.KILL_LIFESPAN && (c.lifespan = this.bulletLifespan), c.angle = a + this.bulletAngleOffset, "" !== this.bulletAnimation) { if (null === c.animations.getAnimation(this.bulletAnimation)) { var d = this.anims[this.bulletAnimation];
                        c.animations.add(d.name, d.frames, d.frameRate, d.loop, d.useNumericIndex) } c.animations.play(this.bulletAnimation) } else this.bulletFrameCycle ? (c.frame = this.bulletFrames[this.bulletFrameIndex], ++this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (c.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]); if (c.data.bodyDirty && (this._data.customBody && c.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY), c.body.collideWorldBounds = this.bulletCollideWorldBounds, c.data.bodyDirty = !1), c.body.velocity.set(h, l), c.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y), 0 !== this.bulletSpeedVariance) { var u = this.fireRate;
                    (u += i.Math.between(-this.fireRateVariance, this.fireRateVariance)) < 0 && (u = 0), this._nextFire = this.game.time.now + u } else this._nextFire = this.game.time.now + this.fireRate;
                this.shots++, this.onFire.dispatch(c, this, n), this.fireLimit > 0 && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit) } return c }, i.Weapon.prototype.fireAtPointer = function(t) { return void 0 === t && (t = this.game.input.activePointer), this.fire(null, t.worldX, t.worldY) }, i.Weapon.prototype.fireAtSprite = function(t) { return this.fire(null, t.world.x, t.world.y) }, i.Weapon.prototype.fireAtXY = function(t, e) { return this.fire(null, t, e) }, i.Weapon.prototype.setBulletBodyOffset = function(t, e, i, o) { return void 0 === i && (i = 0), void 0 === o && (o = 0), this._data.customBody = !0, this._data.width = t, this._data.height = e, this._data.offsetX = i, this._data.offsetY = o, this.bullets.callAll("body.setSize", "body", t, e, i, o), this.bullets.setAll("data.bodyDirty", !1), this }, i.Weapon.prototype.setBulletFrames = function(t, e, o, n) { return void 0 === o && (o = !0), void 0 === n && (n = !1), this.bulletFrames = i.ArrayUtils.numberArray(t, e), this.bulletFrameIndex = 0, this.bulletFrameCycle = o, this.bulletFrameRandom = n, this }, i.Weapon.prototype.addBulletAnimation = function(t, e, i, o, n) { return this.anims[t] = { name: t, frames: e, frameRate: i, loop: o, useNumericIndex: n }, this.bullets.callAll("animations.add", "animations", t, e, i, o, n), this.bulletAnimation = t, this }, i.Weapon.prototype.debug = function(t, e, i) { void 0 === t && (t = 16), void 0 === e && (e = 32), void 0 === i && (i = !1), this.game.debug.text("Weapon Plugin", t, e), this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, t, e + 24), i && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)") }, Object.defineProperty(i.Weapon.prototype, "bulletClass", { get: function() { return this._bulletClass }, set: function(t) { this._bulletClass = t, this.bullets.classType = this._bulletClass } }), Object.defineProperty(i.Weapon.prototype, "bulletKillType", { get: function() { return this._bulletKillType }, set: function(t) { switch (t) {
                    case i.Weapon.KILL_STATIC_BOUNDS:
                    case i.Weapon.KILL_WEAPON_BOUNDS:
                        this.bulletBounds = this.bounds; break;
                    case i.Weapon.KILL_CAMERA_BOUNDS:
                        this.bulletBounds = this.game.camera.view; break;
                    case i.Weapon.KILL_WORLD_BOUNDS:
                        this.bulletBounds = this.game.world.bounds } this._bulletKillType = t } }), Object.defineProperty(i.Weapon.prototype, "bulletCollideWorldBounds", { get: function() { return this._bulletCollideWorldBounds }, set: function(t) { this._bulletCollideWorldBounds = t, this.bullets.setAll("body.collideWorldBounds", t), this.bullets.setAll("data.bodyDirty", !1) } }), Object.defineProperty(i.Weapon.prototype, "x", { get: function() { return this.fireFrom.x }, set: function(t) { this.fireFrom.x = t } }), Object.defineProperty(i.Weapon.prototype, "y", { get: function() { return this.fireFrom.y }, set: function(t) { this.fireFrom.y = t } }), i.Bullet = function(t, e, o, n, s) { i.Sprite.call(this, t, e, o, n, s), this.anchor.set(.5), this.data = { bulletManager: null, fromX: 0, fromY: 0, bodyDirty: !0, rotateToVelocity: !1, killType: 0, killDistance: 0 } }, i.Bullet.prototype = Object.create(i.Sprite.prototype), i.Bullet.prototype.constructor = i.Bullet, i.Bullet.prototype.kill = function() { return this.alive = !1, this.exists = !1, this.visible = !1, this.data.bulletManager.onKill.dispatch(this), this }, i.Bullet.prototype.update = function() { this.exists && (this.data.killType > i.Weapon.KILL_LIFESPAN && (this.data.killType === i.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()), this.data.rotateToVelocity && (this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x)), this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding)) }, i.Video = function(t, e, o) { if (void 0 === e && (e = null), void 0 === o && (o = null), this.game = t, this.key = e, this.width = 0, this.height = 0, this.type = i.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new i.Signal, this.onChangeSource = new i.Signal, this.onComplete = new i.Signal, this.onAccess = new i.Signal, this.onError = new i.Signal, this.onTimeout = new i.Signal, this.timeout = 15e3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, e && this.game.cache.checkVideoKey(e)) { var n = this.game.cache.getVideo(e);
                n.isBlob ? this.createVideoFromBlob(n.data) : this.video = n.data, this.width = this.video.videoWidth, this.height = this.video.videoHeight } else o && this.createVideoFromURL(o, !1);
            this.video && !o ? (this.baseTexture = new PIXI.BaseTexture(this.video), this.baseTexture.forceLoaded(this.width, this.height)) : (this.baseTexture = new PIXI.BaseTexture(i.Cache.DEFAULT.baseTexture.source), this.baseTexture.forceLoaded(this.width, this.height)), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new i.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), this.texture.valid = !1, null !== e && this.video && (this.texture.valid = this.video.canplay), this.snapshot = null, i.BitmapData && (this.snapshot = new i.BitmapData(this.game, "", this.width, this.height)), !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : n && (n.locked = !1) }, i.Video.prototype = { connectToMediaStream: function(t, e) { return t && e && (this.video = t, this.videoStream = e, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this }, startMediaStream: function(t, e, i) { if (void 0 === t && (t = !1), void 0 === e && (e = null), void 0 === i && (i = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), !1;
                null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), null !== e && (this.video.width = e), null !== i && (this.video.height = i), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout); try { navigator.getUserMedia({ audio: t, video: !0 }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this)) } catch (t) { this.getUserMediaError(t) } return this }, getUserMediaTimeout: function() { clearTimeout(this._timeOutID), this.onTimeout.dispatch(this) }, getUserMediaError: function(t) { clearTimeout(this._timeOutID), this.onError.dispatch(this, t) }, getUserMediaSuccess: function(t) { clearTimeout(this._timeOutID), this.videoStream = t, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = t : this.video.src = window.URL && window.URL.createObjectURL(t) || t; var e = this;
                this.video.onloadeddata = function() {
                    function t() { if (i > 0)
                            if (e.video.videoWidth > 0) { var o = e.video.videoWidth,
                                    n = e.video.videoHeight;
                                isNaN(e.video.videoHeight) && (n = o / (4 / 3)), e.video.play(), e.isStreaming = !0, e.baseTexture.source = e.video, e.updateTexture(null, o, n), e.onAccess.dispatch(e) } else window.setTimeout(t, 500);
                        i-- } var i = 10;
                    t() } }, createVideoFromBlob: function(t) { var e = this; return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), this.video.addEventListener("loadeddata", function(t) { e.updateTexture(t) }, !0), this.video.src = window.URL.createObjectURL(t), this.video.canplay = !0, this }, createVideoFromURL: function(t, e) { return void 0 === e && (e = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), this.video.controls = !1, e && this.video.setAttribute("autoplay", "autoplay"), this.video.src = t, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = t, this }, updateTexture: function(t, e, i) { var o = !1;
                void 0 !== e && null !== e || (e = this.video.videoWidth, o = !0), void 0 !== i && null !== i || (i = this.video.videoHeight), this.width = e, this.height = i, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), this.baseTexture.forceLoaded(e, i), this.texture.frame.resize(e, i), this.texture.width = e, this.texture.height = i, this.texture.valid = !0, this.snapshot && this.snapshot.resize(e, i), o && null !== this.key && (this.onChangeSource.dispatch(this, e, i), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate))) }, complete: function() { this.onComplete.dispatch(this) }, play: function(t, e) { return void 0 === t && (t = !1), void 0 === e && (e = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), this.video.loop = t ? "loop" : "", this.video.playbackRate = e, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, t, e)), this }, playHandler: function() { this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture() }, stop: function() { return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks().forEach(function(t) { t.stop() }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()), this }, add: function(t) { if (Array.isArray(t))
                    for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                else t.loadTexture(this); return this }, addToWorld: function(t, e, i, o, n, s) { n = n || 1, s = s || 1; var r = this.game.add.image(t, e, this); return r.anchor.set(i, o), r.scale.set(n, s), r }, render: function() {!this.disableTextureUpload && this.playing && this.baseTexture.dirty() }, setMute: function() { this._muted || (this._muted = !0, this.video.muted = !0) }, unsetMute: function() { this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1) }, setPause: function() { this._paused || this.touchLocked || (this._paused = !0, this.video.pause()) }, setResume: function() {!this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play()) }, changeSource: function(t, e) { return void 0 === e && (e = !0), this.texture.valid = !1, this.video.pause(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = t, this.video.load(), this._autoplay = e, e || (this.paused = !0), this }, checkVideoProgress: function() { 4 === this.video.readyState ? this.updateTexture() : --this.retry > 0 && (this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) }, setTouchLock: function() { this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0 }, unlock: function() { if (this.touchLocked = !1, this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate), this.key) { var t = this.game.cache.getVideo(this.key);
                    t && !t.isBlob && (t.locked = !1) } return !0 }, grab: function(t, e, i) { if (void 0 === t && (t = !1), void 0 === e && (e = 1), void 0 === i && (i = null), null !== this.snapshot) return t && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, e, i), this.snapshot }, removeVideoElement: function() { if (this.video) { for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) this.video.removeChild(this.video.firstChild);
                    this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null } }, destroy: function() { this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID) } }, Object.defineProperty(i.Video.prototype, "currentTime", { get: function() { return this.video ? this.video.currentTime : 0 }, set: function(t) { this.video.currentTime = t } }), Object.defineProperty(i.Video.prototype, "duration", { get: function() { return this.video ? this.video.duration : 0 } }), Object.defineProperty(i.Video.prototype, "progress", { get: function() { return this.video ? this.video.currentTime / this.video.duration : 0 } }), Object.defineProperty(i.Video.prototype, "mute", { get: function() { return this._muted }, set: function(t) { if (t = t || null) { if (this._muted) return;
                    this._codeMuted = !0, this.setMute() } else { if (!this._muted) return;
                    this._codeMuted = !1, this.unsetMute() } } }), Object.defineProperty(i.Video.prototype, "paused", { get: function() { return this._paused }, set: function(t) { if (t = t || null, !this.touchLocked)
                    if (t) { if (this._paused) return;
                        this._codePaused = !0, this.setPause() } else { if (!this._paused) return;
                        this._codePaused = !1, this.setResume() } } }), Object.defineProperty(i.Video.prototype, "volume", { get: function() { return this.video ? this.video.volume : 1 }, set: function(t) { t < 0 ? t = 0 : t > 1 && (t = 1), this.video && (this.video.volume = t) } }), Object.defineProperty(i.Video.prototype, "playbackRate", { get: function() { return this.video ? this.video.playbackRate : 1 }, set: function(t) { this.video && (this.video.playbackRate = t) } }), Object.defineProperty(i.Video.prototype, "loop", { get: function() { return !!this.video && this.video.loop }, set: function(t) { t && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "") } }), Object.defineProperty(i.Video.prototype, "playing", { get: function() { return !(this.video.paused && this.video.ended) } }), i.Video.prototype.constructor = i.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = i.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = i.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix), void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix), PIXI.Graphics && void 0 === PIXI.Graphics.POLY && (PIXI.Graphics.POLY = i.POLYGON, PIXI.Graphics.RECT = i.RECTANGLE, PIXI.Graphics.CIRC = i.CIRCLE, PIXI.Graphics.ELIP = i.ELLIPSE, PIXI.Graphics.RREC = i.ROUNDEDRECTANGLE), PIXI.TextureSilentFail = !0, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = i), exports.Phaser = i) : "undefined" != typeof define && define.amd ? define("Phaser", e.Phaser = i) : e.Phaser = i, i }.call(this);
var COMPILED = !1,
    goog = goog || {};
goog.global = this, goog.global.CLOSURE_UNCOMPILED_DEFINES, goog.global.CLOSURE_DEFINES, goog.isDef = function(t) { return void 0 !== t }, goog.exportPath_ = function(t, e, i) { var o = t.split("."),
        n = i || goog.global;
    o[0] in n || !n.execScript || n.execScript("var " + o[0]); for (var s; o.length && (s = o.shift());) !o.length && goog.isDef(e) ? n[s] = e : n = n[s] ? n[s] : n[s] = {} }, goog.define = function(t, e) { var i = e;
    COMPILED || (goog.global.CLOSURE_UNCOMPILED_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_UNCOMPILED_DEFINES, t) ? i = goog.global.CLOSURE_UNCOMPILED_DEFINES[t] : goog.global.CLOSURE_DEFINES && Object.prototype.hasOwnProperty.call(goog.global.CLOSURE_DEFINES, t) && (i = goog.global.CLOSURE_DEFINES[t])), goog.exportPath_(t, i) }, goog.DEBUG = !0, goog.define("goog.LOCALE", "en"), goog.define("goog.TRUSTED_SITE", !0), goog.define("goog.STRICT_MODE_COMPATIBLE", !1), goog.provide = function(t) { if (!COMPILED) { if (goog.isProvided_(t)) throw Error('Namespace "' + t + '" already declared.');
        delete goog.implicitNamespaces_[t]; for (var e = t;
            (e = e.substring(0, e.lastIndexOf("."))) && !goog.getObjectByName(e);) goog.implicitNamespaces_[e] = !0 } goog.exportPath_(t) }, goog.setTestOnly = function(t) { if (COMPILED && !goog.DEBUG) throw t = t || "", Error("Importing test-only code into non-debug environment" + (t ? ": " + t : ".")) }, goog.forwardDeclare = function() {}, COMPILED || (goog.isProvided_ = function(t) { return !goog.implicitNamespaces_[t] && goog.isDefAndNotNull(goog.getObjectByName(t)) }, goog.implicitNamespaces_ = {}), goog.getObjectByName = function(t, e) { for (var i, o = t.split("."), n = e || goog.global; i = o.shift();) { if (!goog.isDefAndNotNull(n[i])) return null;
        n = n[i] } return n }, goog.globalize = function(t, e) { var i = e || goog.global; for (var o in t) i[o] = t[o] }, goog.addDependency = function(t, e, i) { if (goog.DEPENDENCIES_ENABLED) { for (var o, n, s = t.replace(/\\/g, "/"), r = goog.dependencies_, a = 0; o = e[a]; a++) r.nameToPath[o] = s, s in r.pathToNames || (r.pathToNames[s] = {}), r.pathToNames[s][o] = !0; for (var h = 0; n = i[h]; h++) s in r.requires || (r.requires[s] = {}), r.requires[s][n] = !0 } }, goog.define("goog.ENABLE_DEBUG_LOADER", !0), goog.require = function(t) { if (!COMPILED) { if (goog.isProvided_(t)) return; if (goog.ENABLE_DEBUG_LOADER) { var e = goog.getPathFromDeps_(t); if (e) return goog.included_[e] = !0, void goog.writeScripts_() } var i = "goog.require could not find: " + t; throw goog.global.console && goog.global.console.error(i), Error(i) } }, goog.basePath = "", goog.global.CLOSURE_BASE_PATH, goog.global.CLOSURE_NO_DEPS, goog.global.CLOSURE_IMPORT_SCRIPT, goog.nullFunction = function() {}, goog.identityFunction = function(t) { return t }, goog.abstractMethod = function() { throw Error("unimplemented abstract method") }, goog.addSingletonGetter = function(t) { t.getInstance = function() { return t.instance_ ? t.instance_ : (goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = t), t.instance_ = new t) } }, goog.instantiatedSingletons_ = [], goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER, goog.DEPENDENCIES_ENABLED && (goog.included_ = {}, goog.dependencies_ = { pathToNames: {}, nameToPath: {}, requires: {}, visited: {}, written: {} }, goog.inHtmlDocument_ = function() { var t = goog.global.document; return void 0 !== t && "write" in t }, goog.findBasePath_ = function() { if (goog.global.CLOSURE_BASE_PATH) goog.basePath = goog.global.CLOSURE_BASE_PATH;
    else if (goog.inHtmlDocument_())
        for (var t = goog.global.document, e = t.getElementsByTagName("script"), i = e.length - 1; i >= 0; --i) { var o = e[i].src,
                n = o.lastIndexOf("?"),
                s = -1 == n ? o.length : n; if ("base.js" == o.substr(s - 7, 7)) return void(goog.basePath = o.substr(0, s - 7)) } }, goog.importScript_ = function(t) { var e = goog.global.CLOSURE_IMPORT_SCRIPT || goog.writeScriptTag_;!goog.dependencies_.written[t] && e(t) && (goog.dependencies_.written[t] = !0) }, goog.writeScriptTag_ = function(t) { if (goog.inHtmlDocument_()) { var e = goog.global.document; if ("complete" == e.readyState) { if (/\bdeps.js$/.test(t)) return !1; throw Error('Cannot write "' + t + '" after document load') } return e.write('<script type="text/javascript" src="' + t + '"><\/script>'), !0 } return !1 }, goog.writeScripts_ = function() {
    function t(n) { if (!(n in o.written)) { if (n in o.visited) return void(n in i || (i[n] = !0, e.push(n))); if (o.visited[n] = !0, n in o.requires)
                for (var s in o.requires[n])
                    if (!goog.isProvided_(s)) { if (!(s in o.nameToPath)) throw Error("Undefined nameToPath for " + s);
                        t(o.nameToPath[s]) } n in i || (i[n] = !0, e.push(n)) } } var e = [],
        i = {},
        o = goog.dependencies_; for (var n in goog.included_) o.written[n] || t(n); for (var s = 0; s < e.length; s++) { if (!e[s]) throw Error("Undefined script input");
        goog.importScript_(goog.basePath + e[s]) } }, goog.getPathFromDeps_ = function(t) { return t in goog.dependencies_.nameToPath ? goog.dependencies_.nameToPath[t] : null }, goog.findBasePath_()), goog.typeOf = function(t) { var e = typeof t; if ("object" == e) { if (!t) return "null"; if (t instanceof Array) return "array"; if (t instanceof Object) return e; var i = Object.prototype.toString.call(t); if ("[object Window]" == i) return "object"; if ("[object Array]" == i || "number" == typeof t.length && void 0 !== t.splice && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable("splice")) return "array"; if ("[object Function]" == i || void 0 !== t.call && void 0 !== t.propertyIsEnumerable && !t.propertyIsEnumerable("call")) return "function" } else if ("function" == e && void 0 === t.call) return "object"; return e }, goog.isNull = function(t) { return null === t }, goog.isDefAndNotNull = function(t) { return null != t }, goog.isArray = function(t) { return "array" == goog.typeOf(t) }, goog.isArrayLike = function(t) { var e = goog.typeOf(t); return "array" == e || "object" == e && "number" == typeof t.length }, goog.isDateLike = function(t) { return goog.isObject(t) && "function" == typeof t.getFullYear }, goog.isString = function(t) { return "string" == typeof t }, goog.isBoolean = function(t) { return "boolean" == typeof t }, goog.isNumber = function(t) { return "number" == typeof t }, goog.isFunction = function(t) { return "function" == goog.typeOf(t) }, goog.isObject = function(t) { var e = typeof t; return "object" == e && null != t || "function" == e }, goog.getUid = function(t) { return t[goog.UID_PROPERTY_] || (t[goog.UID_PROPERTY_] = ++goog.uidCounter_) }, goog.hasUid = function(t) { return !!t[goog.UID_PROPERTY_] }, goog.removeUid = function(t) { "removeAttribute" in t && t.removeAttribute(goog.UID_PROPERTY_); try { delete t[goog.UID_PROPERTY_] } catch (t) {} }, goog.UID_PROPERTY_ = "closure_uid_" + (1e9 * Math.random() >>> 0), goog.uidCounter_ = 0, goog.getHashCode = goog.getUid, goog.removeHashCode = goog.removeUid, goog.cloneObject = function(t) { var e = goog.typeOf(t); if ("object" == e || "array" == e) { if (t.clone) return t.clone(); var i = "array" == e ? [] : {}; for (var o in t) i[o] = goog.cloneObject(t[o]); return i } return t }, goog.bindNative_ = function(t) { return t.call.apply(t.bind, arguments) }, goog.bindJs_ = function(t, e) { if (!t) throw new Error; if (arguments.length > 2) { var i = Array.prototype.slice.call(arguments, 2); return function() { var o = Array.prototype.slice.call(arguments); return Array.prototype.unshift.apply(o, i), t.apply(e, o) } } return function() { return t.apply(e, arguments) } }, goog.bind = function() { return goog.bind = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bindNative_ : goog.bindJs_, goog.bind.apply(null, arguments) }, goog.partial = function(t) { var e = Array.prototype.slice.call(arguments, 1); return function() { var i = e.slice(); return i.push.apply(i, arguments), t.apply(this, i) } }, goog.mixin = function(t, e) { for (var i in e) t[i] = e[i] }, goog.now = goog.TRUSTED_SITE && Date.now || function() { return +new Date }, goog.globalEval = function(t) { if (goog.global.execScript) goog.global.execScript(t, "JavaScript");
    else { if (!goog.global.eval) throw Error("goog.globalEval not available"); if (null == goog.evalWorksForGlobals_ && (goog.global.eval("var _et_ = 1;"), void 0 !== goog.global._et_ ? (delete goog.global._et_, goog.evalWorksForGlobals_ = !0) : goog.evalWorksForGlobals_ = !1), goog.evalWorksForGlobals_) goog.global.eval(t);
        else { var e = goog.global.document,
                i = e.createElement("script");
            i.type = "text/javascript", i.defer = !1, i.appendChild(e.createTextNode(t)), e.body.appendChild(i), e.body.removeChild(i) } } }, goog.evalWorksForGlobals_ = null, goog.cssNameMapping_, goog.cssNameMappingStyle_, goog.getCssName = function(t, e) { var i, o = function(t) { return goog.cssNameMapping_[t] || t }; return i = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? o : function(t) { for (var e = t.split("-"), i = [], n = 0; n < e.length; n++) i.push(o(e[n])); return i.join("-") } : function(t) { return t }, e ? t + "-" + i(e) : i(t) }, goog.setCssNameMapping = function(t, e) { goog.cssNameMapping_ = t, goog.cssNameMappingStyle_ = e }, goog.global.CLOSURE_CSS_NAME_MAPPING, !COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING), goog.getMsg = function(t, e) { return e && (t = t.replace(/\{\$([^}]+)}/g, function(t, i) { return i in e ? e[i] : t })), t }, goog.getMsgWithFallback = function(t) { return t }, goog.exportSymbol = function(t, e, i) { goog.exportPath_(t, e, i) }, goog.exportProperty = function(t, e, i) { t[e] = i }, goog.inherits = function(t, e) {
    function i() {} i.prototype = e.prototype, t.superClass_ = e.prototype, t.prototype = new i, t.prototype.constructor = t, t.base = function(t, i) { var o = Array.prototype.slice.call(arguments, 2); return e.prototype[i].apply(t, o) } }, goog.base = function(t, e) { var i = arguments.callee.caller; if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !i) throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C"); if (i.superClass_) return i.superClass_.constructor.apply(t, Array.prototype.slice.call(arguments, 1)); for (var o = Array.prototype.slice.call(arguments, 2), n = !1, s = t.constructor; s; s = s.superClass_ && s.superClass_.constructor)
        if (s.prototype[e] === i) n = !0;
        else if (n) return s.prototype[e].apply(t, o); if (t[e] === i) return t.constructor.prototype[e].apply(t, o); throw Error("goog.base called from a method of one name to a method of a different name") }, goog.scope = function(t) { t.call(goog.global) }, COMPILED || (goog.global.COMPILED = COMPILED), goog.defineClass = function(t, e) { var i = e.constructor,
        o = e.statics;
    i && i != Object.prototype.constructor || (i = function() { throw Error("cannot instantiate an interface (no constructor defined).") }); var n = goog.defineClass.createSealingConstructor_(i, t); return t && goog.inherits(n, t), delete e.constructor, delete e.statics, goog.defineClass.applyProperties_(n.prototype, e), null != o && (o instanceof Function ? o(n) : goog.defineClass.applyProperties_(n, o)), n }, goog.defineClass.ClassDescriptor, goog.define("goog.defineClass.SEAL_CLASS_INSTANCES", goog.DEBUG), goog.defineClass.createSealingConstructor_ = function(t, e) { if (goog.defineClass.SEAL_CLASS_INSTANCES && Object.seal instanceof Function) { if (e && e.prototype && e.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]) return t; var i = function() { var e = t.apply(this, arguments) || this; return this.constructor === i && Object.seal(e), e }; return i } return t }, goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"], goog.defineClass.applyProperties_ = function(t, e) { var i; for (i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]); for (var o = 0; o < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; o++) i = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[o], Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]) }, goog.tagUnsealableClass = function(t) {!COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES && (t.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = !0) }, goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable", goog.provide("box2d.b2Settings"), Object.defineProperty || (Object.defineProperty = function(t, e, i) { Object.__defineGetter__ && ("get" in i ? t.__defineGetter__(e, i.get) : "value" in i && t.__defineGetter__(e, i.value)), Object.__defineSetter__ && ("set" in i ? t.__defineSetter__(e, i.set) : "value" in i && t.__defineSetter__(e, i.value)) }), box2d.DEBUG = !1, box2d.ENABLE_ASSERTS = box2d.DEBUG, box2d.b2Assert = function(t) { box2d.DEBUG }, box2d.b2_maxFloat = 1e37, box2d.b2_epsilon = 1e-5, box2d.b2_epsilon_sq = box2d.b2_epsilon * box2d.b2_epsilon, box2d.b2_pi = Math.PI, box2d.b2_maxManifoldPoints = 2, box2d.b2_maxPolygonVertices = 8, box2d.b2_aabbExtension = .1, box2d.b2_aabbMultiplier = 2, box2d.b2_linearSlop = .008, box2d.b2_angularSlop = 2 / 180 * box2d.b2_pi, box2d.b2_polygonRadius = 2 * box2d.b2_linearSlop, box2d.b2_maxSubSteps = 8, box2d.b2_maxTOIContacts = 32, box2d.b2_velocityThreshold = 1, box2d.b2_maxLinearCorrection = .2, box2d.b2_maxAngularCorrection = 8 / 180 * box2d.b2_pi, box2d.b2_maxTranslation = 2, box2d.b2_maxTranslationSquared = box2d.b2_maxTranslation * box2d.b2_maxTranslation, box2d.b2_maxRotation = .5 * box2d.b2_pi, box2d.b2_maxRotationSquared = box2d.b2_maxRotation * box2d.b2_maxRotation, box2d.b2_baumgarte = .2, box2d.b2_toiBaumgarte = .75, box2d.b2_timeToSleep = .5, box2d.b2_linearSleepTolerance = .01, box2d.b2_angularSleepTolerance = 2 / 180 * box2d.b2_pi, box2d.b2Alloc = function() { return null }, box2d.b2Free = function() {}, box2d.b2Log = function() { goog.global.console.log.apply(null, arguments) }, box2d.b2Version = function(t, e, i) { this.major = t || 0, this.minor = e || 0, this.revision = i || 0 }, box2d.b2Version.prototype.major = 0, box2d.b2Version.prototype.minor = 0, box2d.b2Version.prototype.revision = 0, box2d.b2Version.prototype.toString = function() { return this.major + "." + this.minor + "." + this.revision }, box2d.b2_version = new box2d.b2Version(2, 3, 0), box2d.b2_changelist = 278, box2d.b2ParseInt = function(t) { return parseInt(t, 10) }, box2d.b2ParseUInt = function(t) { return box2d.b2Abs(parseInt(t, 10)) }, box2d.b2MakeArray = function(t, e) { void 0 === t && (t = 0); var i = new Array(t); if (void 0 !== e)
        for (var o = 0; t > o; ++o) i[o] = e(o); return i }, box2d.b2MakeNumberArray = function(t) { return box2d.b2MakeArray(t, function() { return 0 }) }, goog.provide("box2d.b2Math"), goog.require("box2d.b2Settings"), box2d.b2_pi_over_180 = box2d.b2_pi / 180, box2d.b2_180_over_pi = 180 / box2d.b2_pi, box2d.b2_two_pi = 2 * box2d.b2_pi, box2d.b2Abs = function(t) { return 0 > t ? -t : t }, box2d.b2Min = function(t, e) { return e > t ? t : e }, box2d.b2Max = function(t, e) { return t > e ? t : e }, box2d.b2Clamp = function(t, e, i) { return e > t ? e : t > i ? i : t }, box2d.b2Swap = function(t, e) { box2d.ENABLE_ASSERTS && box2d.b2Assert(!1); var i = t[0];
    t[0] = e[0], e[0] = i }, box2d.b2IsValid = function(t) { return isFinite(t) }, box2d.b2Sq = function(t) { return t * t }, box2d.b2InvSqrt = function(t) { return 1 / Math.sqrt(t) }, box2d.b2Sqrt = function(t) { return Math.sqrt(t) }, box2d.b2Pow = function(t, e) { return Math.pow(t, e) }, box2d.b2DegToRad = function(t) { return t * box2d.b2_pi_over_180 }, box2d.b2RadToDeg = function(t) { return t * box2d.b2_180_over_pi }, box2d.b2Cos = function(t) { return Math.cos(t) }, box2d.b2Sin = function(t) { return Math.sin(t) }, box2d.b2Acos = function(t) { return Math.acos(t) }, box2d.b2Asin = function(t) { return Math.asin(t) }, box2d.b2Atan2 = function(t, e) { return Math.atan2(t, e) }, box2d.b2NextPowerOfTwo = function(t) { return t |= t >> 1 & 2147483647, t |= t >> 2 & 1073741823, t |= t >> 4 & 268435455, t |= t >> 8 & 16777215, (t |= t >> 16 & 65535) + 1 }, box2d.b2IsPowerOfTwo = function(t) { return t > 0 && 0 == (t & t - 1) }, box2d.b2Random = function() { return 2 * Math.random() - 1 }, box2d.b2RandomRange = function(t, e) { return (e - t) * Math.random() + t }, box2d.b2Vec2 = function(t, e) { this.x = t || 0, this.y = e || 0 }, box2d.b2Vec2.prototype.x = 0, box2d.b2Vec2.prototype.y = 0, box2d.b2Vec2_zero = new box2d.b2Vec2, box2d.b2Vec2.ZERO = new box2d.b2Vec2, box2d.b2Vec2.UNITX = new box2d.b2Vec2(1, 0), box2d.b2Vec2.UNITY = new box2d.b2Vec2(0, 1), box2d.b2Vec2.s_t0 = new box2d.b2Vec2, box2d.b2Vec2.s_t1 = new box2d.b2Vec2, box2d.b2Vec2.s_t2 = new box2d.b2Vec2, box2d.b2Vec2.s_t3 = new box2d.b2Vec2, box2d.b2Vec2.MakeArray = function(t) { return box2d.b2MakeArray(t, function() { return new box2d.b2Vec2 }) }, box2d.b2Vec2.prototype.Clone = function() { return new box2d.b2Vec2(this.x, this.y) }, box2d.b2Vec2.prototype.SetZero = function() { return this.x = 0, this.y = 0, this }, box2d.b2Vec2.prototype.SetXY = function(t, e) { return this.x = t, this.y = e, this }, box2d.b2Vec2.prototype.Copy = function(t) { return this.x = t.x, this.y = t.y, this }, box2d.b2Vec2.prototype.SelfAdd = function(t) { return this.x += t.x, this.y += t.y, this }, box2d.b2Vec2.prototype.SelfAddXY = function(t, e) { return this.x += t, this.y += e, this }, box2d.b2Vec2.prototype.SelfSub = function(t) { return this.x -= t.x, this.y -= t.y, this }, box2d.b2Vec2.prototype.SelfSubXY = function(t, e) { return this.x -= t, this.y -= e, this }, box2d.b2Vec2.prototype.SelfMul = function(t) { return this.x *= t, this.y *= t, this }, box2d.b2Vec2.prototype.SelfMulAdd = function(t, e) { return this.x += t * e.x, this.y += t * e.y, this }, box2d.b2Vec2.prototype.SelfMulSub = function(t, e) { return this.x -= t * e.x, this.y -= t * e.y, this }, box2d.b2Vec2.prototype.Dot = function(t) { return this.x * t.x + this.y * t.y }, box2d.b2Vec2.prototype.Cross = function(t) { return this.x * t.y - this.y * t.x }, box2d.b2Vec2.prototype.Length = function() { var t = this.x,
        e = this.y; return Math.sqrt(t * t + e * e) }, box2d.b2Vec2.prototype.GetLength = box2d.b2Vec2.prototype.Length, box2d.b2Vec2.prototype.LengthSquared = function() { var t = this.x,
        e = this.y; return t * t + e * e }, box2d.b2Vec2.prototype.GetLengthSquared = box2d.b2Vec2.prototype.LengthSquared, box2d.b2Vec2.prototype.Normalize = function() { var t = this.GetLength(); if (t >= box2d.b2_epsilon) { var e = 1 / t;
        this.x *= e, this.y *= e } return t }, box2d.b2Vec2.prototype.SelfNormalize = function() { var t = this.GetLength(); if (t >= box2d.b2_epsilon) { var e = 1 / t;
        this.x *= e, this.y *= e } return this }, box2d.b2Vec2.prototype.SelfRotate = function(t, e) { var i = this.x,
        o = this.y; return this.x = t * i - e * o, this.y = e * i + t * o, this }, box2d.b2Vec2.prototype.SelfRotateRadians = function(t) { return this.SelfRotate(Math.cos(t), Math.sin(t)) }, box2d.b2Vec2.prototype.SelfRotateDegrees = function(t) { return this.SelfRotateRadians(box2d.b2DegToRad(t)) }, box2d.b2Vec2.prototype.IsValid = function() { return isFinite(this.x) && isFinite(this.y) }, box2d.b2Vec2.prototype.SelfCrossVS = function(t) { var e = this.x; return this.x = t * this.y, this.y = -t * e, this }, box2d.b2Vec2.prototype.SelfCrossSV = function(t) { var e = this.x; return this.x = -t * this.y, this.y = t * e, this }, box2d.b2Vec2.prototype.SelfMinV = function(t) { return this.x = box2d.b2Min(this.x, t.x), this.y = box2d.b2Min(this.y, t.y), this }, box2d.b2Vec2.prototype.SelfMaxV = function(t) { return this.x = box2d.b2Max(this.x, t.x), this.y = box2d.b2Max(this.y, t.y), this }, box2d.b2Vec2.prototype.SelfAbs = function() { return this.x = box2d.b2Abs(this.x), this.y = box2d.b2Abs(this.y), this }, box2d.b2Vec2.prototype.SelfNeg = function() { return this.x = -this.x, this.y = -this.y, this }, box2d.b2Vec2.prototype.SelfSkew = function() { var t = this.x; return this.x = -this.y, this.y = t, this }, box2d.b2AbsV = function(t, e) { return e.x = box2d.b2Abs(t.x), e.y = box2d.b2Abs(t.y), e }, box2d.b2MinV = function(t, e, i) { return i.x = box2d.b2Min(t.x, e.x), i.y = box2d.b2Min(t.y, e.y), i }, box2d.b2MaxV = function(t, e, i) { return i.x = box2d.b2Max(t.x, e.x), i.y = box2d.b2Max(t.y, e.y), i }, box2d.b2ClampV = function(t, e, i, o) { return o.x = box2d.b2Clamp(t.x, e.x, i.x), o.y = box2d.b2Clamp(t.y, e.y, i.y), o }, box2d.b2RotateV = function(t, e, i, o) { var n = t.x,
        s = t.y; return o.x = e * n - i * s, o.y = i * n + e * s, o }, box2d.b2RotateRadiansV = function(t, e, i) { return box2d.b2RotateV(t, Math.cos(e), Math.sin(e), i) }, box2d.b2RotateDegreesV = function(t, e, i) { return box2d.b2RotateRadiansV(t, box2d.b2DegToRad(e), i) }, box2d.b2DotVV = function(t, e) { return t.x * e.x + t.y * e.y }, box2d.b2CrossVV = function(t, e) { return t.x * e.y - t.y * e.x }, box2d.b2CrossVS = function(t, e, i) { var o = t.x; return i.x = e * t.y, i.y = -e * o, i }, box2d.b2CrossVOne = function(t, e) { var i = t.x; return e.x = t.y, e.y = -i, e }, box2d.b2CrossSV = function(t, e, i) { var o = e.x; return i.x = -t * e.y, i.y = t * o, i }, box2d.b2CrossOneV = function(t, e) { var i = t.x; return e.x = -t.y, e.y = i, e }, box2d.b2AddVV = function(t, e, i) { return i.x = t.x + e.x, i.y = t.y + e.y, i }, box2d.b2SubVV = function(t, e, i) { return i.x = t.x - e.x, i.y = t.y - e.y, i }, box2d.b2MulSV = function(t, e, i) { return i.x = e.x * t, i.y = e.y * t, i }, box2d.b2AddVMulSV = function(t, e, i, o) { return o.x = t.x + e * i.x, o.y = t.y + e * i.y, o }, box2d.b2SubVMulSV = function(t, e, i, o) { return o.x = t.x - e * i.x, o.y = t.y - e * i.y, o }, box2d.b2AddVCrossSV = function(t, e, i, o) { var n = i.x; return o.x = t.x - e * i.y, o.y = t.y + e * n, o }, box2d.b2MidVV = function(t, e, i) { return i.x = .5 * (t.x + e.x), i.y = .5 * (t.y + e.y), i }, box2d.b2ExtVV = function(t, e, i) { return i.x = .5 * (e.x - t.x), i.y = .5 * (e.y - t.y), i }, box2d.b2IsEqualToV = function(t, e) { return t.x === e.x && t.y === e.y }, box2d.b2DistanceVV = function(t, e) { var i = t.x - e.x,
        o = t.y - e.y; return Math.sqrt(i * i + o * o) }, box2d.b2DistanceSquaredVV = function(t, e) { var i = t.x - e.x,
        o = t.y - e.y; return i * i + o * o }, box2d.b2NegV = function(t, e) { return e.x = -t.x, e.y = -t.y, e }, box2d.b2Vec3 = function(t, e, i) { this.x = t || 0, this.y = e || 0, this.z = i || 0 }, box2d.b2Vec3.prototype.x = 0, box2d.b2Vec3.prototype.y = 0, box2d.b2Vec3.prototype.z = 0, box2d.b2Vec3.ZERO = new box2d.b2Vec3, box2d.b2Vec3.s_t0 = new box2d.b2Vec3, box2d.b2Vec3.prototype.Clone = function() { return new box2d.b2Vec3(this.x, this.y, this.z) }, box2d.b2Vec3.prototype.SetZero = function() { return this.x = 0, this.y = 0, this.z = 0, this }, box2d.b2Vec3.prototype.SetXYZ = function(t, e, i) { return this.x = t, this.y = e, this.z = i, this }, box2d.b2Vec3.prototype.Copy = function(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }, box2d.b2Vec3.prototype.SelfNeg = function() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, box2d.b2Vec3.prototype.SelfAdd = function(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this }, box2d.b2Vec3.prototype.SelfAddXYZ = function(t, e, i) { return this.x += t, this.y += e, this.z += i, this }, box2d.b2Vec3.prototype.SelfSub = function(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this }, box2d.b2Vec3.prototype.SelfSubXYZ = function(t, e, i) { return this.x -= t, this.y -= e, this.z -= i, this }, box2d.b2Vec3.prototype.SelfMul = function(t) { return this.x *= t, this.y *= t, this.z *= t, this }, box2d.b2DotV3V3 = function(t, e) { return t.x * e.x + t.y * e.y + t.z * e.z }, box2d.b2CrossV3V3 = function(t, e, i) { var o = t.x,
        n = t.y,
        s = t.z,
        r = e.x,
        a = e.y,
        h = e.z; return i.x = n * h - s * a, i.y = s * r - o * h, i.z = o * a - n * r, i }, box2d.b2Mat22 = function() { this.ex = new box2d.b2Vec2(1, 0), this.ey = new box2d.b2Vec2(0, 1) }, box2d.b2Mat22.prototype.ex = null, box2d.b2Mat22.prototype.ey = null, box2d.b2Mat22.IDENTITY = new box2d.b2Mat22, box2d.b2Mat22.prototype.Clone = function() { return (new box2d.b2Mat22).Copy(this) }, box2d.b2Mat22.FromVV = function(t, e) { return (new box2d.b2Mat22).SetVV(t, e) }, box2d.b2Mat22.FromSSSS = function(t, e, i, o) { return (new box2d.b2Mat22).SetSSSS(t, e, i, o) }, box2d.b2Mat22.FromAngleRadians = function(t) { return (new box2d.b2Mat22).SetAngleRadians(t) }, box2d.b2Mat22.prototype.SetSSSS = function(t, e, i, o) { return this.ex.SetXY(t, i), this.ey.SetXY(e, o), this }, box2d.b2Mat22.prototype.SetVV = function(t, e) { return this.ex.Copy(t), this.ey.Copy(e), this }, box2d.b2Mat22.prototype.SetAngle = function(t) { var e = Math.cos(t),
        i = Math.sin(t); return this.ex.SetXY(e, i), this.ey.SetXY(-i, e), this }, box2d.b2Mat22.prototype.SetAngleRadians = box2d.b2Mat22.prototype.SetAngle, box2d.b2Mat22.prototype.SetAngleDegrees = function(t) { return this.SetAngle(box2d.b2DegToRad(t)) }, box2d.b2Mat22.prototype.Copy = function(t) { return this.ex.Copy(t.ex), this.ey.Copy(t.ey), this }, box2d.b2Mat22.prototype.SetIdentity = function() { return this.ex.SetXY(1, 0), this.ey.SetXY(0, 1), this }, box2d.b2Mat22.prototype.SetZero = function() { return this.ex.SetZero(), this.ey.SetZero(), this }, box2d.b2Mat22.prototype.GetAngle = function() { return Math.atan2(this.ex.y, this.ex.x) }, box2d.b2Mat22.prototype.GetAngleRadians = box2d.b2Mat22.prototype.GetAngle, box2d.b2Mat22.prototype.GetInverse = function(t) { var e = this.ex.x,
        i = this.ey.x,
        o = this.ex.y,
        n = this.ey.y,
        s = e * n - i * o; return 0 !== s && (s = 1 / s), t.ex.x = s * n, t.ey.x = -s * i, t.ex.y = -s * o, t.ey.y = s * e, t }, box2d.b2Mat22.prototype.Solve = function(t, e, i) { var o = this.ex.x,
        n = this.ey.x,
        s = this.ex.y,
        r = this.ey.y,
        a = o * r - n * s; return 0 !== a && (a = 1 / a), i.x = a * (r * t - n * e), i.y = a * (o * e - s * t), i }, box2d.b2Mat22.prototype.SelfAbs = function() { return this.ex.SelfAbs(), this.ey.SelfAbs(), this }, box2d.b2Mat22.prototype.SelfInv = function() { return this.GetInverse(this) }, box2d.b2Mat22.prototype.SelfAddM = function(t) { return this.ex.SelfAdd(t.ex), this.ey.SelfAdd(t.ey), this }, box2d.b2Mat22.prototype.SelfSubM = function(t) { return this.ex.SelfSub(t.ex), this.ey.SelfSub(t.ey), this }, box2d.b2AbsM = function(t, e) { var i = t.ex,
        o = t.ey; return e.ex.x = box2d.b2Abs(i.x), e.ex.y = box2d.b2Abs(i.y), e.ey.x = box2d.b2Abs(o.x), e.ey.y = box2d.b2Abs(o.y), e }, box2d.b2MulMV = function(t, e, i) { var o = t.ex,
        n = t.ey,
        s = e.x,
        r = e.y; return i.x = o.x * s + n.x * r, i.y = o.y * s + n.y * r, i }, box2d.b2MulTMV = function(t, e, i) { var o = t.ex,
        n = t.ey,
        s = e.x,
        r = e.y; return i.x = o.x * s + o.y * r, i.y = n.x * s + n.y * r, i }, box2d.b2AddMM = function(t, e, i) { var o = t.ex,
        n = t.ey,
        s = e.ex,
        r = e.ey; return i.ex.x = o.x + s.x, i.ex.y = o.y + s.y, i.ey.x = n.x + r.x, i.ey.y = n.y + r.y, i }, box2d.b2MulMM = function(t, e, i) { var o = t.ex.x,
        n = t.ex.y,
        s = t.ey.x,
        r = t.ey.y,
        a = e.ex.x,
        h = e.ex.y,
        l = e.ey.x,
        c = e.ey.y; return i.ex.x = o * a + s * h, i.ex.y = n * a + r * h, i.ey.x = o * l + s * c, i.ey.y = n * l + r * c, i }, box2d.b2MulTMM = function(t, e, i) { var o = t.ex.x,
        n = t.ex.y,
        s = t.ey.x,
        r = t.ey.y,
        a = e.ex.x,
        h = e.ex.y,
        l = e.ey.x,
        c = e.ey.y; return i.ex.x = o * a + n * h, i.ex.y = s * a + r * h, i.ey.x = o * l + n * c, i.ey.y = s * l + r * c, i }, box2d.b2Mat33 = function() { this.ex = new box2d.b2Vec3(1, 0, 0), this.ey = new box2d.b2Vec3(0, 1, 0), this.ez = new box2d.b2Vec3(0, 0, 1) }, box2d.b2Mat33.prototype.ex = null, box2d.b2Mat33.prototype.ey = null, box2d.b2Mat33.prototype.ez = null, box2d.b2Mat33.IDENTITY = new box2d.b2Mat33, box2d.b2Mat33.prototype.Clone = function() { return (new box2d.b2Mat33).Copy(this) }, box2d.b2Mat33.prototype.SetVVV = function(t, e, i) { return this.ex.Copy(t), this.ey.Copy(e), this.ez.Copy(i), this }, box2d.b2Mat33.prototype.Copy = function(t) { return this.ex.Copy(t.ex), this.ey.Copy(t.ey), this.ez.Copy(t.ez), this }, box2d.b2Mat33.prototype.SetIdentity = function() { return this.ex.SetXYZ(1, 0, 0), this.ey.SetXYZ(0, 1, 0), this.ez.SetXYZ(0, 0, 1), this }, box2d.b2Mat33.prototype.SetZero = function() { return this.ex.SetZero(), this.ey.SetZero(), this.ez.SetZero(), this }, box2d.b2Mat33.prototype.SelfAddM = function(t) { return this.ex.SelfAdd(t.ex), this.ey.SelfAdd(t.ey), this.ez.SelfAdd(t.ez), this }, box2d.b2Mat33.prototype.Solve33 = function(t, e, i, o) { var n = this.ex.x,
        s = this.ex.y,
        r = this.ex.z,
        a = this.ey.x,
        h = this.ey.y,
        l = this.ey.z,
        c = this.ez.x,
        d = this.ez.y,
        u = this.ez.z,
        p = n * (h * u - l * d) + s * (l * c - a * u) + r * (a * d - h * c); return 0 !== p && (p = 1 / p), o.x = p * (t * (h * u - l * d) + e * (l * c - a * u) + i * (a * d - h * c)), o.y = p * (n * (e * u - i * d) + s * (i * c - t * u) + r * (t * d - e * c)), o.z = p * (n * (h * i - l * e) + s * (l * t - a * i) + r * (a * e - h * t)), o }, box2d.b2Mat33.prototype.Solve22 = function(t, e, i) { var o = this.ex.x,
        n = this.ey.x,
        s = this.ex.y,
        r = this.ey.y,
        a = o * r - n * s; return 0 !== a && (a = 1 / a), i.x = a * (r * t - n * e), i.y = a * (o * e - s * t), i }, box2d.b2Mat33.prototype.GetInverse22 = function(t) { var e = this.ex.x,
        i = this.ey.x,
        o = this.ex.y,
        n = this.ey.y,
        s = e * n - i * o;
    0 !== s && (s = 1 / s), t.ex.x = s * n, t.ey.x = -s * i, t.ex.z = 0, t.ex.y = -s * o, t.ey.y = s * e, t.ey.z = 0, t.ez.x = 0, t.ez.y = 0, t.ez.z = 0 }, box2d.b2Mat33.prototype.GetSymInverse33 = function(t) { var e = box2d.b2DotV3V3(this.ex, box2d.b2CrossV3V3(this.ey, this.ez, box2d.b2Vec3.s_t0));
    0 !== e && (e = 1 / e); var i = this.ex.x,
        o = this.ey.x,
        n = this.ez.x,
        s = this.ey.y,
        r = this.ez.y,
        a = this.ez.z;
    t.ex.x = e * (s * a - r * r), t.ex.y = e * (n * r - o * a), t.ex.z = e * (o * r - n * s), t.ey.x = t.ex.y, t.ey.y = e * (i * a - n * n), t.ey.z = e * (n * o - i * r), t.ez.x = t.ex.z, t.ez.y = t.ey.z, t.ez.z = e * (i * s - o * o) }, box2d.b2MulM33V3 = function(t, e, i) { var o = e.x,
        n = e.y,
        s = e.z; return i.x = t.ex.x * o + t.ey.x * n + t.ez.x * s, i.y = t.ex.y * o + t.ey.y * n + t.ez.y * s, i.z = t.ex.z * o + t.ey.z * n + t.ez.z * s, i }, box2d.b2MulM33XYZ = function(t, e, i, o, n) { return n.x = t.ex.x * e + t.ey.x * i + t.ez.x * o, n.y = t.ex.y * e + t.ey.y * i + t.ez.y * o, n.z = t.ex.z * e + t.ey.z * i + t.ez.z * o, n }, box2d.b2MulM33V2 = function(t, e, i) { var o = e.x,
        n = e.y; return i.x = t.ex.x * o + t.ey.x * n, i.y = t.ex.y * o + t.ey.y * n, i }, box2d.b2MulM33XY = function(t, e, i, o) { return o.x = t.ex.x * e + t.ey.x * i, o.y = t.ex.y * e + t.ey.y * i, o }, box2d.b2Rot = function(t) { t && (this.angle = t, this.s = Math.sin(t), this.c = Math.cos(t)) }, box2d.b2Rot.prototype.angle = 0, box2d.b2Rot.prototype.s = 0, box2d.b2Rot.prototype.c = 1, box2d.b2Rot.IDENTITY = new box2d.b2Rot, box2d.b2Rot.prototype.Clone = function() { return (new box2d.b2Rot).Copy(this) }, box2d.b2Rot.prototype.Copy = function(t) { return this.angle = t.angle, this.s = t.s, this.c = t.c, this }, box2d.b2Rot.prototype.SetAngle = function(t) { return this.angle !== t && (this.angle = t, this.s = Math.sin(t), this.c = Math.cos(t)), this }, box2d.b2Rot.prototype.SetAngleRadians = box2d.b2Rot.prototype.SetAngle, box2d.b2Rot.prototype.SetAngleDegrees = function(t) { return this.SetAngle(box2d.b2DegToRad(t)) }, box2d.b2Rot.prototype.SetIdentity = function() { return this.angle = 0, this.s = 0, this.c = 1, this }, box2d.b2Rot.prototype.GetAngle = function() { return this.angle }, box2d.b2Rot.prototype.GetAngleRadians = box2d.b2Rot.prototype.GetAngle, box2d.b2Rot.prototype.GetAngleDegrees = function() { return box2d.b2RadToDeg(this.GetAngle()) }, box2d.b2Rot.prototype.GetXAxis = function(t) { return t.x = this.c, t.y = this.s, t }, box2d.b2Rot.prototype.GetYAxis = function(t) { return t.x = -this.s, t.y = this.c, t }, box2d.b2MulRR = function(t, e, i) { var o = t.c,
        n = t.s,
        s = e.c,
        r = e.s; for (i.s = n * s + o * r, i.c = o * s - n * r, i.angle = t.angle + e.angle; i.angle < -box2d.b2_pi;) i.angle += box2d.b2_two_pi; for (; i.angle >= box2d.b2_pi;) i.angle -= box2d.b2_two_pi; return i }, box2d.b2MulTRR = function(t, e, i) { var o = t.c,
        n = t.s,
        s = e.c,
        r = e.s; for (i.s = o * r - n * s, i.c = o * s + n * r, i.angle = t.angle - e.angle; i.angle < -box2d.b2_pi;) i.angle += box2d.b2_two_pi; for (; i.angle >= box2d.b2_pi;) i.angle -= box2d.b2_two_pi; return i }, box2d.b2MulRV = function(t, e, i) { var o = t.c,
        n = t.s,
        s = e.x,
        r = e.y; return i.x = o * s - n * r, i.y = n * s + o * r, i }, box2d.b2MulTRV = function(t, e, i) { var o = t.c,
        n = t.s,
        s = e.x,
        r = e.y; return i.x = o * s + n * r, i.y = -n * s + o * r, i }, box2d.b2Transform = function() { this.p = new box2d.b2Vec2, this.q = new box2d.b2Rot }, box2d.b2Transform.prototype.p = null, box2d.b2Transform.prototype.q = null, box2d.b2Transform.IDENTITY = new box2d.b2Transform, box2d.b2Transform.prototype.Clone = function() { return (new box2d.b2Transform).Copy(this) }, box2d.b2Transform.prototype.Copy = function(t) { return this.p.Copy(t.p), this.q.Copy(t.q), this }, box2d.b2Transform.prototype.SetIdentity = function() { return this.p.SetZero(), this.q.SetIdentity(), this }, box2d.b2Transform.prototype.SetPositionRotation = function(t, e) { return this.p.Copy(t), this.q.Copy(e), this }, box2d.b2Transform.prototype.SetPositionAngleRadians = function(t, e) { return this.p.Copy(t), this.q.SetAngleRadians(e), this }, box2d.b2Transform.prototype.SetPosition = function(t) { return this.p.Copy(t), this }, box2d.b2Transform.prototype.SetPositionXY = function(t, e) { return this.p.SetXY(t, e), this }, box2d.b2Transform.prototype.SetRotation = function(t) { return this.q.Copy(t), this }, box2d.b2Transform.prototype.SetRotationAngleRadians = function(t) { return this.q.SetAngleRadians(t), this }, box2d.b2Transform.prototype.GetPosition = function() { return this.p }, box2d.b2Transform.prototype.GetRotation = function() { return this.q }, box2d.b2Transform.prototype.GetRotationAngle = function() { return this.q.GetAngle() }, box2d.b2Transform.prototype.GetRotationAngleRadians = box2d.b2Transform.prototype.GetRotationAngle, box2d.b2Transform.prototype.GetAngle = function() { return this.q.GetAngle() }, box2d.b2Transform.prototype.GetAngleRadians = box2d.b2Transform.prototype.GetAngle, box2d.b2MulXV = function(t, e, i) { var o = t.q.c,
        n = t.q.s,
        s = e.x,
        r = e.y; return i.x = o * s - n * r + t.p.x, i.y = n * s + o * r + t.p.y, i }, box2d.b2MulTXV = function(t, e, i) { var o = t.q.c,
        n = t.q.s,
        s = e.x - t.p.x,
        r = e.y - t.p.y; return i.x = o * s + n * r, i.y = -n * s + o * r, i }, box2d.b2MulXX = function(t, e, i) { return box2d.b2MulRR(t.q, e.q, i.q), box2d.b2AddVV(box2d.b2MulRV(t.q, e.p, i.p), t.p, i.p), i }, box2d.b2MulTXX = function(t, e, i) { return box2d.b2MulTRR(t.q, e.q, i.q), box2d.b2MulTRV(t.q, box2d.b2SubVV(e.p, t.p, i.p), i.p), i }, box2d.b2Sweep = function() { this.localCenter = new box2d.b2Vec2, this.c0 = new box2d.b2Vec2, this.c = new box2d.b2Vec2 }, box2d.b2Sweep.prototype.localCenter = null, box2d.b2Sweep.prototype.c0 = null, box2d.b2Sweep.prototype.c = null, box2d.b2Sweep.prototype.a0 = 0, box2d.b2Sweep.prototype.a = 0, box2d.b2Sweep.prototype.alpha0 = 0, box2d.b2Sweep.prototype.Clone = function() { return (new box2d.b2Sweep).Copy(this) }, box2d.b2Sweep.prototype.Copy = function(t) { return this.localCenter.Copy(t.localCenter), this.c0.Copy(t.c0), this.c.Copy(t.c), this.a0 = t.a0, this.a = t.a, this.alpha0 = t.alpha0, this }, box2d.b2Sweep.prototype.GetTransform = function(t, e) { var i = 1 - e;
    t.p.x = i * this.c0.x + e * this.c.x, t.p.y = i * this.c0.y + e * this.c.y; var o = i * this.a0 + e * this.a; return t.q.SetAngleRadians(o), t.p.SelfSub(box2d.b2MulRV(t.q, this.localCenter, box2d.b2Vec2.s_t0)), t }, box2d.b2Sweep.prototype.Advance = function(t) { box2d.ENABLE_ASSERTS && box2d.b2Assert(this.alpha0 < 1); var e = (t - this.alpha0) / (1 - this.alpha0);
    this.c0.x += e * (this.c.x - this.c0.x), this.c0.y += e * (this.c.y - this.c0.y), this.a0 += e * (this.a - this.a0), this.alpha0 = t }, box2d.b2Sweep.prototype.Normalize = function() { var t = box2d.b2_two_pi * Math.floor(this.a0 / box2d.b2_two_pi);
    this.a0 -= t, this.a -= t }, goog.provide("box2d.b2Controller"), goog.require("box2d.b2Settings"), box2d.b2ControllerEdge = function() {}, box2d.b2ControllerEdge.prototype.controller = null, box2d.b2ControllerEdge.prototype.body = null, box2d.b2ControllerEdge.prototype.prevBody = null, box2d.b2ControllerEdge.prototype.nextBody = null, box2d.b2ControllerEdge.prototype.prevController = null, box2d.b2ControllerEdge.prototype.nextController = null, box2d.b2Controller = function() {}, box2d.b2Controller.prototype.m_world = null, box2d.b2Controller.prototype.m_bodyList = null, box2d.b2Controller.prototype.m_bodyCount = 0, box2d.b2Controller.prototype.m_prev = null, box2d.b2Controller.prototype.m_next = null, box2d.b2Controller.prototype.Step = function() {}, box2d.b2Controller.prototype.Draw = function() {}, box2d.b2Controller.prototype.GetNext = function() { return this.m_next }, box2d.b2Controller.prototype.GetPrev = function() { return this.m_prev }, box2d.b2Controller.prototype.GetWorld = function() { return this.m_world }, box2d.b2Controller.prototype.GetBodyList = function() { return this.m_bodyList }, box2d.b2Controller.prototype.AddBody = function(t) { var e = new box2d.b2ControllerEdge;
    e.body = t, e.controller = this, e.nextBody = this.m_bodyList, e.prevBody = null, this.m_bodyList && (this.m_bodyList.prevBody = e), this.m_bodyList = e, ++this.m_bodyCount, e.nextController = t.m_controllerList, e.prevController = null, t.m_controllerList && (t.m_controllerList.prevController = e), t.m_controllerList = e, ++t.m_controllerCount }, box2d.b2Controller.prototype.RemoveBody = function(t) { box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_bodyCount > 0); for (var e = this.m_bodyList; e && e.body !== t;) e = e.nextBody;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(null !== e), e.prevBody && (e.prevBody.nextBody = e.nextBody), e.nextBody && (e.nextBody.prevBody = e.prevBody), this.m_bodyList === e && (this.m_bodyList = e.nextBody), --this.m_bodyCount, e.nextController && (e.nextController.prevController = e.prevController), e.prevController && (e.prevController.nextController = e.nextController), t.m_controllerList === e && (t.m_controllerList = e.nextController), --t.m_controllerCount }, box2d.b2Controller.prototype.Clear = function() { for (; this.m_bodyList;) this.RemoveBody(this.m_bodyList.body);
    this.m_bodyCount = 0 }, goog.provide("box2d.b2ConstantAccelController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), box2d.b2ConstantAccelController = function() { goog.base(this), this.A = new box2d.b2Vec2(0, 0) }, goog.inherits(box2d.b2ConstantAccelController, box2d.b2Controller), box2d.b2ConstantAccelController.prototype.A = null, box2d.b2ConstantAccelController.prototype.Step = function(t) { for (var e = box2d.b2MulSV(t.dt, this.A, box2d.b2ConstantAccelController.prototype.Step.s_dtA), i = this.m_bodyList; i; i = i.nextBody) { var o = i.body;
        o.IsAwake() && o.SetLinearVelocity(box2d.b2AddVV(o.GetLinearVelocity(), e, box2d.b2Vec2.s_t0)) } }, box2d.b2ConstantAccelController.prototype.Step.s_dtA = new box2d.b2Vec2, goog.provide("box2d.b2Joint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), box2d.b2JointType = { e_unknownJoint: 0, e_revoluteJoint: 1, e_prismaticJoint: 2, e_distanceJoint: 3, e_pulleyJoint: 4, e_mouseJoint: 5, e_gearJoint: 6, e_wheelJoint: 7, e_weldJoint: 8, e_frictionJoint: 9, e_ropeJoint: 10, e_motorJoint: 11, e_areaJoint: 12 }, goog.exportProperty(box2d.b2JointType, "e_unknownJoint", box2d.b2JointType.e_unknownJoint), goog.exportProperty(box2d.b2JointType, "e_revoluteJoint", box2d.b2JointType.e_revoluteJoint), goog.exportProperty(box2d.b2JointType, "e_prismaticJoint", box2d.b2JointType.e_prismaticJoint), goog.exportProperty(box2d.b2JointType, "e_distanceJoint", box2d.b2JointType.e_distanceJoint), goog.exportProperty(box2d.b2JointType, "e_pulleyJoint", box2d.b2JointType.e_pulleyJoint), goog.exportProperty(box2d.b2JointType, "e_mouseJoint", box2d.b2JointType.e_mouseJoint), goog.exportProperty(box2d.b2JointType, "e_gearJoint", box2d.b2JointType.e_gearJoint), goog.exportProperty(box2d.b2JointType, "e_wheelJoint", box2d.b2JointType.e_wheelJoint), goog.exportProperty(box2d.b2JointType, "e_weldJoint", box2d.b2JointType.e_weldJoint), goog.exportProperty(box2d.b2JointType, "e_frictionJoint", box2d.b2JointType.e_frictionJoint), goog.exportProperty(box2d.b2JointType, "e_ropeJoint", box2d.b2JointType.e_ropeJoint), goog.exportProperty(box2d.b2JointType, "e_motorJoint", box2d.b2JointType.e_motorJoint), goog.exportProperty(box2d.b2JointType, "e_areaJoint", box2d.b2JointType.e_areaJoint), box2d.b2LimitState = { e_inactiveLimit: 0, e_atLowerLimit: 1, e_atUpperLimit: 2, e_equalLimits: 3 }, goog.exportProperty(box2d.b2LimitState, "e_inactiveLimit", box2d.b2LimitState.e_inactiveLimit), goog.exportProperty(box2d.b2LimitState, "e_atLowerLimit", box2d.b2LimitState.e_atLowerLimit), goog.exportProperty(box2d.b2LimitState, "e_atUpperLimit", box2d.b2LimitState.e_atUpperLimit), goog.exportProperty(box2d.b2LimitState, "e_equalLimits", box2d.b2LimitState.e_equalLimits), box2d.b2Jacobian = function() { this.linear = new box2d.b2Vec2 }, box2d.b2Jacobian.prototype.linear = null, box2d.b2Jacobian.prototype.angularA = 0, box2d.b2Jacobian.prototype.angularB = 0, box2d.b2Jacobian.prototype.SetZero = function() { return this.linear.SetZero(), this.angularA = 0, this.angularB = 0, this }, box2d.b2Jacobian.prototype.Set = function(t, e, i) { return this.linear.Copy(t), this.angularA = e, this.angularB = i, this }, box2d.b2JointEdge = function() {}, box2d.b2JointEdge.prototype.other = null, box2d.b2JointEdge.prototype.joint = null, box2d.b2JointEdge.prototype.prev = null, box2d.b2JointEdge.prototype.next = null, box2d.b2JointDef = function(t) { this.type = t }, box2d.b2JointDef.prototype.type = box2d.b2JointType.e_unknownJoint, box2d.b2JointDef.prototype.userData = null, box2d.b2JointDef.prototype.bodyA = null, box2d.b2JointDef.prototype.bodyB = null, box2d.b2JointDef.prototype.collideConnected = !1, box2d.b2Joint = function(t) { box2d.ENABLE_ASSERTS && box2d.b2Assert(t.bodyA !== t.bodyB), this.m_type = t.type, this.m_edgeA = new box2d.b2JointEdge, this.m_edgeB = new box2d.b2JointEdge, this.m_bodyA = t.bodyA, this.m_bodyB = t.bodyB, this.m_collideConnected = t.collideConnected, this.m_userData = t.userData }, box2d.b2Joint.prototype.m_type = box2d.b2JointType.e_unknownJoint, box2d.b2Joint.prototype.m_prev = null, box2d.b2Joint.prototype.m_next = null, box2d.b2Joint.prototype.m_edgeA = null, box2d.b2Joint.prototype.m_edgeB = null, box2d.b2Joint.prototype.m_bodyA = null, box2d.b2Joint.prototype.m_bodyB = null, box2d.b2Joint.prototype.m_index = 0, box2d.b2Joint.prototype.m_islandFlag = !1, box2d.b2Joint.prototype.m_collideConnected = !1, box2d.b2Joint.prototype.m_userData = null, box2d.b2Joint.prototype.GetAnchorA = function(t) { return t.SetZero() }, box2d.b2Joint.prototype.GetAnchorB = function(t) { return t.SetZero() }, box2d.b2Joint.prototype.GetReactionForce = function(t, e) { return e.SetZero() }, box2d.b2Joint.prototype.GetReactionTorque = function() { return 0 }, box2d.b2Joint.prototype.InitVelocityConstraints = function() {}, box2d.b2Joint.prototype.SolveVelocityConstraints = function() {}, box2d.b2Joint.prototype.SolvePositionConstraints = function() { return !1 }, box2d.b2Joint.prototype.GetType = function() { return this.m_type }, box2d.b2Joint.prototype.GetBodyA = function() { return this.m_bodyA }, box2d.b2Joint.prototype.GetBodyB = function() { return this.m_bodyB }, box2d.b2Joint.prototype.GetNext = function() { return this.m_next }, box2d.b2Joint.prototype.GetUserData = function() { return this.m_userData }, box2d.b2Joint.prototype.SetUserData = function(t) { this.m_userData = t }, box2d.b2Joint.prototype.GetCollideConnected = function() { return this.m_collideConnected }, box2d.b2Joint.prototype.Dump = function() { box2d.DEBUG && box2d.b2Log("// Dump is not supported for this joint type.\n") }, box2d.b2Joint.prototype.IsActive = function() { return this.m_bodyA.IsActive() && this.m_bodyB.IsActive() }, box2d.b2Joint.prototype.ShiftOrigin = function() {}, goog.provide("box2d.b2RevoluteJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2RevoluteJointDef = function() { goog.base(this, box2d.b2JointType.e_revoluteJoint), this.localAnchorA = new box2d.b2Vec2(0, 0), this.localAnchorB = new box2d.b2Vec2(0, 0) }, goog.inherits(box2d.b2RevoluteJointDef, box2d.b2JointDef), box2d.b2RevoluteJointDef.prototype.localAnchorA = null, box2d.b2RevoluteJointDef.prototype.localAnchorB = null, box2d.b2RevoluteJointDef.prototype.referenceAngle = 0, box2d.b2RevoluteJointDef.prototype.enableLimit = !1, box2d.b2RevoluteJointDef.prototype.lowerAngle = 0, box2d.b2RevoluteJointDef.prototype.upperAngle = 0, box2d.b2RevoluteJointDef.prototype.enableMotor = !1, box2d.b2RevoluteJointDef.prototype.motorSpeed = 0, box2d.b2RevoluteJointDef.prototype.maxMotorTorque = 0, box2d.b2RevoluteJointDef.prototype.Initialize = function(t, e, i) { this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB), this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians() }, box2d.b2RevoluteJoint = function(t) { goog.base(this, t), this.m_localAnchorA = new box2d.b2Vec2, this.m_localAnchorB = new box2d.b2Vec2, this.m_impulse = new box2d.b2Vec3, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_mass = new box2d.b2Mat33, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_K = new box2d.b2Mat22, this.m_localAnchorA.Copy(t.localAnchorA), this.m_localAnchorB.Copy(t.localAnchorB), this.m_referenceAngle = t.referenceAngle, this.m_impulse.SetZero(), this.m_motorImpulse = 0, this.m_lowerAngle = t.lowerAngle, this.m_upperAngle = t.upperAngle, this.m_maxMotorTorque = t.maxMotorTorque, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_limitState = box2d.b2LimitState.e_inactiveLimit }, goog.inherits(box2d.b2RevoluteJoint, box2d.b2Joint), box2d.b2RevoluteJoint.prototype.m_localAnchorA = null, box2d.b2RevoluteJoint.prototype.m_localAnchorB = null, box2d.b2RevoluteJoint.prototype.m_impulse = null, box2d.b2RevoluteJoint.prototype.m_motorImpulse = 0, box2d.b2RevoluteJoint.prototype.m_enableMotor = !1, box2d.b2RevoluteJoint.prototype.m_maxMotorTorque = 0, box2d.b2RevoluteJoint.prototype.m_motorSpeed = 0, box2d.b2RevoluteJoint.prototype.m_enableLimit = !1, box2d.b2RevoluteJoint.prototype.m_referenceAngle = 0, box2d.b2RevoluteJoint.prototype.m_lowerAngle = 0, box2d.b2RevoluteJoint.prototype.m_upperAngle = 0, box2d.b2RevoluteJoint.prototype.m_indexA = 0, box2d.b2RevoluteJoint.prototype.m_indexB = 0, box2d.b2RevoluteJoint.prototype.m_rA = null, box2d.b2RevoluteJoint.prototype.m_rB = null, box2d.b2RevoluteJoint.prototype.m_localCenterA = null, box2d.b2RevoluteJoint.prototype.m_localCenterB = null, box2d.b2RevoluteJoint.prototype.m_invMassA = 0, box2d.b2RevoluteJoint.prototype.m_invMassB = 0, box2d.b2RevoluteJoint.prototype.m_invIA = 0, box2d.b2RevoluteJoint.prototype.m_invIB = 0, box2d.b2RevoluteJoint.prototype.m_mass = null, box2d.b2RevoluteJoint.prototype.m_motorMass = 0, box2d.b2RevoluteJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit, box2d.b2RevoluteJoint.prototype.m_qA = null, box2d.b2RevoluteJoint.prototype.m_qB = null, box2d.b2RevoluteJoint.prototype.m_lalcA = null, box2d.b2RevoluteJoint.prototype.m_lalcB = null, box2d.b2RevoluteJoint.prototype.m_K = null, box2d.b2RevoluteJoint.prototype.InitVelocityConstraints = function(t) { this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI; var e = t.positions[this.m_indexA].a,
        i = t.velocities[this.m_indexA].v,
        o = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].a,
        s = t.velocities[this.m_indexB].v,
        r = t.velocities[this.m_indexB].w,
        a = this.m_qA.SetAngleRadians(e),
        h = this.m_qB.SetAngleRadians(n);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(a, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(h, this.m_lalcB, this.m_rB); var l = this.m_invMassA,
        c = this.m_invMassB,
        d = this.m_invIA,
        u = this.m_invIB,
        p = d + u === 0; if (this.m_mass.ex.x = l + c + this.m_rA.y * this.m_rA.y * d + this.m_rB.y * this.m_rB.y * u, this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * d - this.m_rB.y * this.m_rB.x * u, this.m_mass.ez.x = -this.m_rA.y * d - this.m_rB.y * u, this.m_mass.ex.y = this.m_mass.ey.x, this.m_mass.ey.y = l + c + this.m_rA.x * this.m_rA.x * d + this.m_rB.x * this.m_rB.x * u, this.m_mass.ez.y = this.m_rA.x * d + this.m_rB.x * u, this.m_mass.ex.z = this.m_mass.ez.x, this.m_mass.ey.z = this.m_mass.ez.y, this.m_mass.ez.z = d + u, this.m_motorMass = d + u, this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass), (!1 === this.m_enableMotor || p) && (this.m_motorImpulse = 0), this.m_enableLimit && !1 === p) { var m = n - e - this.m_referenceAngle;
        box2d.b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * box2d.b2_angularSlop ? this.m_limitState = box2d.b2LimitState.e_equalLimits : m <= this.m_lowerAngle ? (this.m_limitState !== box2d.b2LimitState.e_atLowerLimit && (this.m_impulse.z = 0), this.m_limitState = box2d.b2LimitState.e_atLowerLimit) : m >= this.m_upperAngle ? (this.m_limitState !== box2d.b2LimitState.e_atUpperLimit && (this.m_impulse.z = 0), this.m_limitState = box2d.b2LimitState.e_atUpperLimit) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z = 0) } else this.m_limitState = box2d.b2LimitState.e_inactiveLimit; if (t.step.warmStarting) { this.m_impulse.SelfMul(t.step.dtRatio), this.m_motorImpulse *= t.step.dtRatio; var f = box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y);
        i.SelfMulSub(l, f), o -= d * (box2d.b2CrossVV(this.m_rA, f) + this.m_motorImpulse + this.m_impulse.z), s.SelfMulAdd(c, f), r += u * (box2d.b2CrossVV(this.m_rB, f) + this.m_motorImpulse + this.m_impulse.z) } else this.m_impulse.SetZero(), this.m_motorImpulse = 0;
    t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = r }, box2d.b2RevoluteJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints = function(t) { var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        n = t.velocities[this.m_indexB].w,
        s = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB,
        l = a + h === 0; if (this.m_enableMotor && this.m_limitState !== box2d.b2LimitState.e_equalLimits && !1 === l) { var c = n - i - this.m_motorSpeed,
            d = -this.m_motorMass * c,
            u = this.m_motorImpulse,
            p = t.step.dt * this.m_maxMotorTorque;
        this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + d, -p, p), i -= a * (d = this.m_motorImpulse - u), n += h * d } if (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit && !1 === l) { var m = box2d.b2SubVV(box2d.b2AddVCrossSV(o, n, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1),
            f = n - i,
            d = this.m_mass.Solve33(m.x, m.y, f, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3).SelfNeg(); if (this.m_limitState === box2d.b2LimitState.e_equalLimits) this.m_impulse.SelfAdd(d);
        else if (this.m_limitState === box2d.b2LimitState.e_atLowerLimit)
            if (0 > (_ = this.m_impulse.z + d.z)) { var y = -m.x + this.m_impulse.z * this.m_mass.ez.x,
                    b = -m.y + this.m_impulse.z * this.m_mass.ez.y,
                    g = this.m_mass.Solve22(y, b, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced);
                d.x = g.x, d.y = g.y, d.z = -this.m_impulse.z, this.m_impulse.x += g.x, this.m_impulse.y += g.y, this.m_impulse.z = 0 } else this.m_impulse.SelfAdd(d);
        else if (this.m_limitState === box2d.b2LimitState.e_atUpperLimit) { var _ = this.m_impulse.z + d.z; if (_ > 0) { var y = -m.x + this.m_impulse.z * this.m_mass.ez.x,
                    b = -m.y + this.m_impulse.z * this.m_mass.ez.y,
                    g = this.m_mass.Solve22(y, b, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced);
                d.x = g.x, d.y = g.y, d.z = -this.m_impulse.z, this.m_impulse.x += g.x, this.m_impulse.y += g.y, this.m_impulse.z = 0 } else this.m_impulse.SelfAdd(d) } var v = box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P.SetXY(d.x, d.y);
        e.SelfMulSub(s, v), i -= a * (box2d.b2CrossVV(this.m_rA, v) + d.z), o.SelfMulAdd(r, v), n += h * (box2d.b2CrossVV(this.m_rB, v) + d.z) } else { var c = box2d.b2SubVV(box2d.b2AddVCrossSV(o, n, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot),
            d = this.m_mass.Solve22(-c.x, -c.y, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2);
        this.m_impulse.x += d.x, this.m_impulse.y += d.y, e.SelfMulSub(s, d), i -= a * box2d.b2CrossVV(this.m_rA, d), o.SelfMulAdd(r, d), n += h * box2d.b2CrossVV(this.m_rB, d) } t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = n }, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse3 = new box2d.b2Vec3, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_reduced = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolveVelocityConstraints.s_impulse2 = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints = function(t) { var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        n = t.positions[this.m_indexB].a,
        s = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(n),
        a = 0,
        h = 0,
        l = this.m_invIA + this.m_invIB === 0; if (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit && !1 === l) { var c = n - i - this.m_referenceAngle,
            d = 0; if (this.m_limitState === box2d.b2LimitState.e_equalLimits) { var u = box2d.b2Clamp(c - this.m_lowerAngle, -box2d.b2_maxAngularCorrection, box2d.b2_maxAngularCorrection);
            d = -this.m_motorMass * u, a = box2d.b2Abs(u) } else this.m_limitState === box2d.b2LimitState.e_atLowerLimit ? (a = -(u = c - this.m_lowerAngle), u = box2d.b2Clamp(u + box2d.b2_angularSlop, -box2d.b2_maxAngularCorrection, 0), d = -this.m_motorMass * u) : this.m_limitState === box2d.b2LimitState.e_atUpperLimit && (a = u = c - this.m_upperAngle, u = box2d.b2Clamp(u - box2d.b2_angularSlop, 0, box2d.b2_maxAngularCorrection), d = -this.m_motorMass * u);
        i -= this.m_invIA * d, n += this.m_invIB * d } s.SetAngleRadians(i), r.SetAngleRadians(n), box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA); var p = box2d.b2MulRV(s, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB); var m = box2d.b2MulRV(r, this.m_lalcB, this.m_rB);
    h = (u = box2d.b2SubVV(box2d.b2AddVV(o, m, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, p, box2d.b2Vec2.s_t1), box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C)).GetLength(); var f = this.m_invMassA,
        y = this.m_invMassB,
        b = this.m_invIA,
        g = this.m_invIB,
        _ = this.m_K;
    _.ex.x = f + y + b * p.y * p.y + g * m.y * m.y, _.ex.y = -b * p.x * p.y - g * m.x * m.y, _.ey.x = _.ex.y, _.ey.y = f + y + b * p.x * p.x + g * m.x * m.x; var v = _.Solve(u.x, u.y, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg(); return e.SelfMulSub(f, v), i -= b * box2d.b2CrossVV(p, v), o.SelfMulAdd(y, v), n += g * box2d.b2CrossVV(m, v), t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = n, h <= box2d.b2_linearSlop && a <= box2d.b2_angularSlop }, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_C = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec2, box2d.b2RevoluteJoint.prototype.GetAnchorA = function(t) { return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t) }, box2d.b2RevoluteJoint.prototype.GetAnchorB = function(t) { return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t) }, box2d.b2RevoluteJoint.prototype.GetReactionForce = function(t, e) { return e.SetXY(t * this.m_impulse.x, t * this.m_impulse.y) }, box2d.b2RevoluteJoint.prototype.GetReactionTorque = function(t) { return t * this.m_impulse.z }, box2d.b2RevoluteJoint.prototype.GetLocalAnchorA = function(t) { return t.Copy(this.m_localAnchorA) }, box2d.b2RevoluteJoint.prototype.GetLocalAnchorB = function(t) { return t.Copy(this.m_localAnchorB) }, box2d.b2RevoluteJoint.prototype.GetReferenceAngle = function() { return this.m_referenceAngle }, box2d.b2RevoluteJoint.prototype.GetJointAngleRadians = function() { return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle }, box2d.b2RevoluteJoint.prototype.GetJointSpeed = function() { return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity }, box2d.b2RevoluteJoint.prototype.IsMotorEnabled = function() { return this.m_enableMotor }, box2d.b2RevoluteJoint.prototype.EnableMotor = function(t) { this.m_enableMotor !== t && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t) }, box2d.b2RevoluteJoint.prototype.GetMotorTorque = function(t) { return t * this.m_motorImpulse }, box2d.b2RevoluteJoint.prototype.GetMotorSpeed = function() { return this.m_motorSpeed }, box2d.b2RevoluteJoint.prototype.SetMaxMotorTorque = function(t) { this.m_maxMotorTorque = t }, box2d.b2RevoluteJoint.prototype.GetMaxMotorTorque = function() { return this.m_maxMotorTorque }, box2d.b2RevoluteJoint.prototype.IsLimitEnabled = function() { return this.m_enableLimit }, box2d.b2RevoluteJoint.prototype.EnableLimit = function(t) { t !== this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = t, this.m_impulse.z = 0) }, box2d.b2RevoluteJoint.prototype.GetLowerLimit = function() { return this.m_lowerAngle }, box2d.b2RevoluteJoint.prototype.GetUpperLimit = function() { return this.m_upperAngle }, box2d.b2RevoluteJoint.prototype.SetLimits = function(t, e) {
    (t !== this.m_lowerAngle || e !== this.m_upperAngle) && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_impulse.z = 0, this.m_lowerAngle = t, this.m_upperAngle = e) }, box2d.b2RevoluteJoint.prototype.SetMotorSpeed = function(t) { this.m_motorSpeed !== t && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t) }, box2d.b2RevoluteJoint.prototype.Dump = function() { if (box2d.DEBUG) { var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2RevoluteJointDef*/ var jd = new box2d.b2RevoluteJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle), box2d.b2Log("  jd.enableLimit = %s;\n", this.m_enableLimit ? "true" : "false"), box2d.b2Log("  jd.lowerAngle = %.15f;\n", this.m_lowerAngle), box2d.b2Log("  jd.upperAngle = %.15f;\n", this.m_upperAngle), box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false"), box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed), box2d.b2Log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index) } }, goog.provide("box2d.b2PrismaticJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2PrismaticJointDef = function() { goog.base(this, box2d.b2JointType.e_prismaticJoint), this.localAnchorA = new box2d.b2Vec2, this.localAnchorB = new box2d.b2Vec2, this.localAxisA = new box2d.b2Vec2(1, 0) }, goog.inherits(box2d.b2PrismaticJointDef, box2d.b2JointDef), box2d.b2PrismaticJointDef.prototype.localAnchorA = null, box2d.b2PrismaticJointDef.prototype.localAnchorB = null, box2d.b2PrismaticJointDef.prototype.localAxisA = null, box2d.b2PrismaticJointDef.prototype.referenceAngle = 0, box2d.b2PrismaticJointDef.prototype.enableLimit = !1, box2d.b2PrismaticJointDef.prototype.lowerTranslation = 0, box2d.b2PrismaticJointDef.prototype.upperTranslation = 0, box2d.b2PrismaticJointDef.prototype.enableMotor = !1, box2d.b2PrismaticJointDef.prototype.maxMotorForce = 0, box2d.b2PrismaticJointDef.prototype.motorSpeed = 0, box2d.b2PrismaticJointDef.prototype.Initialize = function(t, e, i, o) { this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB), this.bodyA.GetLocalVector(o, this.localAxisA), this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians() }, box2d.b2PrismaticJoint = function(t) { goog.base(this, t), this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_localXAxisA = t.localAxisA.Clone().SelfNormalize(), this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2), this.m_referenceAngle = t.referenceAngle, this.m_impulse = new box2d.b2Vec3(0, 0, 0), this.m_lowerTranslation = t.lowerTranslation, this.m_upperTranslation = t.upperTranslation, this.m_maxMotorForce = t.maxMotorForce, this.m_motorSpeed = t.motorSpeed, this.m_enableLimit = t.enableLimit, this.m_enableMotor = t.enableMotor, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_axis = new box2d.b2Vec2(0, 0), this.m_perp = new box2d.b2Vec2(0, 0), this.m_K = new box2d.b2Mat33, this.m_K3 = new box2d.b2Mat33, this.m_K2 = new box2d.b2Mat22, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2 }, goog.inherits(box2d.b2PrismaticJoint, box2d.b2Joint), box2d.b2PrismaticJoint.prototype.m_localAnchorA = null, box2d.b2PrismaticJoint.prototype.m_localAnchorB = null, box2d.b2PrismaticJoint.prototype.m_localXAxisA = null, box2d.b2PrismaticJoint.prototype.m_localYAxisA = null, box2d.b2PrismaticJoint.prototype.m_referenceAngle = 0, box2d.b2PrismaticJoint.prototype.m_impulse = null, box2d.b2PrismaticJoint.prototype.m_motorImpulse = 0, box2d.b2PrismaticJoint.prototype.m_lowerTranslation = 0, box2d.b2PrismaticJoint.prototype.m_upperTranslation = 0, box2d.b2PrismaticJoint.prototype.m_maxMotorForce = 0, box2d.b2PrismaticJoint.prototype.m_motorSpeed = 0, box2d.b2PrismaticJoint.prototype.m_enableLimit = !1, box2d.b2PrismaticJoint.prototype.m_enableMotor = !1, box2d.b2PrismaticJoint.prototype.m_limitState = box2d.b2LimitState.e_inactiveLimit, box2d.b2PrismaticJoint.prototype.m_indexA = 0, box2d.b2PrismaticJoint.prototype.m_indexB = 0, box2d.b2PrismaticJoint.prototype.m_localCenterA = null, box2d.b2PrismaticJoint.prototype.m_localCenterB = null, box2d.b2PrismaticJoint.prototype.m_invMassA = 0, box2d.b2PrismaticJoint.prototype.m_invMassB = 0, box2d.b2PrismaticJoint.prototype.m_invIA = 0, box2d.b2PrismaticJoint.prototype.m_invIB = 0, box2d.b2PrismaticJoint.prototype.m_axis = null, box2d.b2PrismaticJoint.prototype.m_perp = null, box2d.b2PrismaticJoint.prototype.m_s1 = 0, box2d.b2PrismaticJoint.prototype.m_s2 = 0, box2d.b2PrismaticJoint.prototype.m_a1 = 0, box2d.b2PrismaticJoint.prototype.m_a2 = 0, box2d.b2PrismaticJoint.prototype.m_K = null, box2d.b2PrismaticJoint.prototype.m_K3 = null, box2d.b2PrismaticJoint.prototype.m_K2 = null, box2d.b2PrismaticJoint.prototype.m_motorMass = 0, box2d.b2PrismaticJoint.prototype.m_qA = null, box2d.b2PrismaticJoint.prototype.m_qB = null, box2d.b2PrismaticJoint.prototype.m_lalcA = null, box2d.b2PrismaticJoint.prototype.m_lalcB = null, box2d.b2PrismaticJoint.prototype.m_rA = null, box2d.b2PrismaticJoint.prototype.m_rB = null, box2d.b2PrismaticJoint.prototype.InitVelocityConstraints = function(t) { this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI; var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        n = t.velocities[this.m_indexA].w,
        s = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        c = this.m_qB.SetAngleRadians(r);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA); var d = box2d.b2MulRV(l, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB); var u = box2d.b2MulRV(c, this.m_lalcB, this.m_rB),
        p = box2d.b2AddVV(box2d.b2SubVV(s, e, box2d.b2Vec2.s_t0), box2d.b2SubVV(u, d, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d),
        m = this.m_invMassA,
        f = this.m_invMassB,
        y = this.m_invIA,
        b = this.m_invIB; if (box2d.b2MulRV(l, this.m_localXAxisA, this.m_axis), this.m_a1 = box2d.b2CrossVV(box2d.b2AddVV(p, d, box2d.b2Vec2.s_t0), this.m_axis), this.m_a2 = box2d.b2CrossVV(u, this.m_axis), this.m_motorMass = m + f + y * this.m_a1 * this.m_a1 + b * this.m_a2 * this.m_a2, this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass), box2d.b2MulRV(l, this.m_localYAxisA, this.m_perp), this.m_s1 = box2d.b2CrossVV(box2d.b2AddVV(p, d, box2d.b2Vec2.s_t0), this.m_perp), this.m_s2 = box2d.b2CrossVV(u, this.m_perp), this.m_K.ex.x = m + f + y * this.m_s1 * this.m_s1 + b * this.m_s2 * this.m_s2, this.m_K.ex.y = y * this.m_s1 + b * this.m_s2, this.m_K.ex.z = y * this.m_s1 * this.m_a1 + b * this.m_s2 * this.m_a2, this.m_K.ey.x = this.m_K.ex.y, this.m_K.ey.y = y + b, 0 === this.m_K.ey.y && (this.m_K.ey.y = 1), this.m_K.ey.z = y * this.m_a1 + b * this.m_a2, this.m_K.ez.x = this.m_K.ex.z, this.m_K.ez.y = this.m_K.ey.z, this.m_K.ez.z = m + f + y * this.m_a1 * this.m_a1 + b * this.m_a2 * this.m_a2, this.m_enableLimit) { var g = box2d.b2DotVV(this.m_axis, p);
        box2d.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * box2d.b2_linearSlop ? this.m_limitState = box2d.b2LimitState.e_equalLimits : g <= this.m_lowerTranslation ? this.m_limitState !== box2d.b2LimitState.e_atLowerLimit && (this.m_limitState = box2d.b2LimitState.e_atLowerLimit, this.m_impulse.z = 0) : g >= this.m_upperTranslation ? this.m_limitState !== box2d.b2LimitState.e_atUpperLimit && (this.m_limitState = box2d.b2LimitState.e_atUpperLimit, this.m_impulse.z = 0) : (this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z = 0) } else this.m_limitState = box2d.b2LimitState.e_inactiveLimit, this.m_impulse.z = 0; if (!1 === this.m_enableMotor && (this.m_motorImpulse = 0), t.step.warmStarting) { this.m_impulse.SelfMul(t.step.dtRatio), this.m_motorImpulse *= t.step.dtRatio; var _ = box2d.b2AddVV(box2d.b2MulSV(this.m_impulse.x, this.m_perp, box2d.b2Vec2.s_t0), box2d.b2MulSV(this.m_motorImpulse + this.m_impulse.z, this.m_axis, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P),
            v = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1,
            x = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;
        o.SelfMulSub(m, _), n -= y * v, a.SelfMulAdd(f, _), h += b * x } else this.m_impulse.SetZero(), this.m_motorImpulse = 0;
    t.velocities[this.m_indexA].w = n, t.velocities[this.m_indexB].w = h }, box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints = function(t) { var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        n = t.velocities[this.m_indexB].w,
        s = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB; if (this.m_enableMotor && this.m_limitState !== box2d.b2LimitState.e_equalLimits) { var l = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(o, e, box2d.b2Vec2.s_t0)) + this.m_a2 * n - this.m_a1 * i,
            c = this.m_motorMass * (this.m_motorSpeed - l),
            d = this.m_motorImpulse,
            u = t.step.dt * this.m_maxMotorForce;
        this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + c, -u, u), c = this.m_motorImpulse - d; var p = box2d.b2MulSV(c, this.m_axis, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P),
            m = c * this.m_a1,
            f = c * this.m_a2;
        e.SelfMulSub(s, p), i -= a * m, o.SelfMulAdd(r, p), n += h * f } var y = box2d.b2DotVV(this.m_perp, box2d.b2SubVV(o, e, box2d.b2Vec2.s_t0)) + this.m_s2 * n - this.m_s1 * i,
        b = n - i; if (this.m_enableLimit && this.m_limitState !== box2d.b2LimitState.e_inactiveLimit) { var g = box2d.b2DotVV(this.m_axis, box2d.b2SubVV(o, e, box2d.b2Vec2.s_t0)) + this.m_a2 * n - this.m_a1 * i,
            _ = box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1.Copy(this.m_impulse),
            v = this.m_K.Solve33(-y, -b, -g, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3);
        this.m_impulse.SelfAdd(v), this.m_limitState === box2d.b2LimitState.e_atLowerLimit ? this.m_impulse.z = box2d.b2Max(this.m_impulse.z, 0) : this.m_limitState === box2d.b2LimitState.e_atUpperLimit && (this.m_impulse.z = box2d.b2Min(this.m_impulse.z, 0)); var x = -y - (this.m_impulse.z - _.z) * this.m_K.ez.x,
            S = -b - (this.m_impulse.z - _.z) * this.m_K.ez.y,
            C = this.m_K.Solve22(x, S, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r);
        C.x += _.x, C.y += _.y, this.m_impulse.x = C.x, this.m_impulse.y = C.y, v.x = this.m_impulse.x - _.x, v.y = this.m_impulse.y - _.y, v.z = this.m_impulse.z - _.z; var p = box2d.b2AddVV(box2d.b2MulSV(v.x, this.m_perp, box2d.b2Vec2.s_t0), box2d.b2MulSV(v.z, this.m_axis, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P),
            m = v.x * this.m_s1 + v.y + v.z * this.m_a1,
            f = v.x * this.m_s2 + v.y + v.z * this.m_a2;
        e.SelfMulSub(s, p), i -= a * m, o.SelfMulAdd(r, p), n += h * f } else { v = this.m_K.Solve22(-y, -b, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2);
        this.m_impulse.x += v.x, this.m_impulse.y += v.y; var p = box2d.b2MulSV(v.x, this.m_perp, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P),
            m = v.x * this.m_s1 + v.y,
            f = v.x * this.m_s2 + v.y;
        e.SelfMulSub(s, p), i -= a * m, o.SelfMulAdd(r, p), n += h * f } t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = n }, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f2r = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_f1 = new box2d.b2Vec3, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df3 = new box2d.b2Vec3, box2d.b2PrismaticJoint.prototype.SolveVelocityConstraints.s_df2 = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints = function(t) { var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        n = t.positions[this.m_indexB].a,
        s = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(n),
        a = this.m_invMassA,
        h = this.m_invMassB,
        l = this.m_invIA,
        c = this.m_invIB,
        d = box2d.b2MulRV(s, this.m_lalcA, this.m_rA),
        u = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        p = box2d.b2SubVV(box2d.b2AddVV(o, u, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, d, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d),
        m = box2d.b2MulRV(s, this.m_localXAxisA, this.m_axis),
        f = box2d.b2CrossVV(box2d.b2AddVV(p, d, box2d.b2Vec2.s_t0), m),
        y = box2d.b2CrossVV(u, m),
        b = box2d.b2MulRV(s, this.m_localYAxisA, this.m_perp),
        g = box2d.b2CrossVV(box2d.b2AddVV(p, d, box2d.b2Vec2.s_t0), b),
        _ = box2d.b2CrossVV(u, b),
        v = box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse,
        x = box2d.b2DotVV(b, p),
        S = n - i - this.m_referenceAngle,
        C = box2d.b2Abs(x),
        w = box2d.b2Abs(S),
        A = !1,
        T = 0; if (this.m_enableLimit) { var P = box2d.b2DotVV(m, p);
        box2d.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * box2d.b2_linearSlop ? (T = box2d.b2Clamp(P, -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection), C = box2d.b2Max(C, box2d.b2Abs(P)), A = !0) : P <= this.m_lowerTranslation ? (T = box2d.b2Clamp(P - this.m_lowerTranslation + box2d.b2_linearSlop, -box2d.b2_maxLinearCorrection, 0), C = box2d.b2Max(C, this.m_lowerTranslation - P), A = !0) : P >= this.m_upperTranslation && (T = box2d.b2Clamp(P - this.m_upperTranslation - box2d.b2_linearSlop, 0, box2d.b2_maxLinearCorrection), C = box2d.b2Max(C, P - this.m_upperTranslation), A = !0) } if (A) { var k = a + h + l * g * g + c * _ * _,
            M = l * g + c * _,
            E = l * g * f + c * _ * y;
        0 === (L = l + c) && (L = 1); var B = l * f + c * y,
            I = a + h + l * f * f + c * y * y,
            D = this.m_K3;
        D.ex.SetXYZ(k, M, E), D.ey.SetXYZ(M, L, B), D.ez.SetXYZ(E, B, I), v = D.Solve33(-x, -S, -T, v) } else { var k = a + h + l * g * g + c * _ * _,
            M = l * g + c * _,
            L = l + c;
        0 === L && (L = 1); var O = this.m_K2;
        O.ex.SetXY(k, M), O.ey.SetXY(M, L); var R = O.Solve(-x, -S, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1);
        v.x = R.x, v.y = R.y, v.z = 0 } var F = box2d.b2AddVV(box2d.b2MulSV(v.x, b, box2d.b2Vec2.s_t0), box2d.b2MulSV(v.z, m, box2d.b2Vec2.s_t1), box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P),
        V = v.x * g + v.y + v.z * f,
        G = v.x * _ + v.y + v.z * y; return e.SelfMulSub(a, F), i -= l * V, o.SelfMulAdd(h, F), n += c * G, t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = n, C <= box2d.b2_linearSlop && w <= box2d.b2_angularSlop }, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_impulse1 = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetAnchorA = function(t) { return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t) }, box2d.b2PrismaticJoint.prototype.GetAnchorB = function(t) { return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t) }, box2d.b2PrismaticJoint.prototype.GetReactionForce = function(t, e) { return e.SetXY(t * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x), t * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y)) }, box2d.b2PrismaticJoint.prototype.GetReactionTorque = function(t) { return t * this.m_impulse.y }, box2d.b2PrismaticJoint.prototype.GetLocalAnchorA = function(t) { return t.Copy(this.m_localAnchorA) }, box2d.b2PrismaticJoint.prototype.GetLocalAnchorB = function(t) { return t.Copy(this.m_localAnchorB) }, box2d.b2PrismaticJoint.prototype.GetLocalAxisA = function(t) { return t.Copy(this.m_localXAxisA) }, box2d.b2PrismaticJoint.prototype.GetReferenceAngle = function() { return this.m_referenceAngle }, box2d.b2PrismaticJoint.prototype.GetJointTranslation = function() { var t = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA),
        e = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB),
        i = box2d.b2SubVV(e, t, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d),
        o = this.m_bodyA.GetWorldVector(this.m_localXAxisA, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis); return box2d.b2DotVV(i, o) }, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pA = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_pB = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_d = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetJointTranslation.s_axis = new box2d.b2Vec2, box2d.b2PrismaticJoint.prototype.GetJointSpeed = function() { var t = this.m_bodyA,
        e = this.m_bodyB;
    box2d.b2SubVV(this.m_localAnchorA, t.m_sweep.localCenter, this.m_lalcA); var i = box2d.b2MulRV(t.m_xf.q, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, e.m_sweep.localCenter, this.m_lalcB); var o = box2d.b2MulRV(e.m_xf.q, this.m_lalcB, this.m_rB),
        n = box2d.b2AddVV(t.m_sweep.c, i, box2d.b2Vec2.s_t0),
        s = box2d.b2AddVV(e.m_sweep.c, o, box2d.b2Vec2.s_t1),
        r = box2d.b2SubVV(s, n, box2d.b2Vec2.s_t2),
        a = t.GetWorldVector(this.m_localXAxisA, this.m_axis),
        h = t.m_linearVelocity,
        l = e.m_linearVelocity,
        c = t.m_angularVelocity,
        d = e.m_angularVelocity; return box2d.b2DotVV(r, box2d.b2CrossSV(c, a, box2d.b2Vec2.s_t0)) + box2d.b2DotVV(a, box2d.b2SubVV(box2d.b2AddVCrossSV(l, d, o, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(h, c, i, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0)) }, box2d.b2PrismaticJoint.prototype.IsLimitEnabled = function() { return this.m_enableLimit }, box2d.b2PrismaticJoint.prototype.EnableLimit = function(t) { t !== this.m_enableLimit && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableLimit = t, this.m_impulse.z = 0) }, box2d.b2PrismaticJoint.prototype.GetLowerLimit = function() { return this.m_lowerTranslation }, box2d.b2PrismaticJoint.prototype.GetUpperLimit = function() { return this.m_upperTranslation }, box2d.b2PrismaticJoint.prototype.SetLimits = function(t, e) {
    (t !== this.m_lowerTranslation || e !== this.m_upperTranslation) && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_lowerTranslation = t, this.m_upperTranslation = e, this.m_impulse.z = 0) }, box2d.b2PrismaticJoint.prototype.IsMotorEnabled = function() { return this.m_enableMotor }, box2d.b2PrismaticJoint.prototype.EnableMotor = function(t) { this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t }, box2d.b2PrismaticJoint.prototype.SetMotorSpeed = function(t) { this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t }, box2d.b2PrismaticJoint.prototype.GetMotorSpeed = function() { return this.m_motorSpeed }, box2d.b2PrismaticJoint.prototype.SetMaxMotorForce = function(t) { this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorForce = t }, box2d.b2PrismaticJoint.prototype.GetMaxMotorForce = function() { return this.m_maxMotorForce }, box2d.b2PrismaticJoint.prototype.GetMotorForce = function(t) { return t * this.m_motorImpulse }, box2d.b2PrismaticJoint.prototype.Dump = function() { if (box2d.DEBUG) { var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2PrismaticJointDef*/ var jd = new box2d.b2PrismaticJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.localAxisA.SetXY(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y), box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle), box2d.b2Log("  jd.enableLimit = %s;\n", this.m_enableLimit ? "true" : "false"), box2d.b2Log("  jd.lowerTranslation = %.15f;\n", this.m_lowerTranslation), box2d.b2Log("  jd.upperTranslation = %.15f;\n", this.m_upperTranslation), box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false"), box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed), box2d.b2Log("  jd.maxMotorForce = %.15f;\n", this.m_maxMotorForce), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index) } }, goog.provide("box2d.b2GearJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), goog.require("box2d.b2RevoluteJoint"), goog.require("box2d.b2PrismaticJoint"), box2d.b2GearJointDef = function() { goog.base(this, box2d.b2JointType.e_gearJoint) }, goog.inherits(box2d.b2GearJointDef, box2d.b2JointDef), box2d.b2GearJointDef.prototype.joint1 = null, box2d.b2GearJointDef.prototype.joint2 = null, box2d.b2GearJointDef.prototype.ratio = 1, box2d.b2GearJoint = function(t) { goog.base(this, t), this.m_joint1 = t.joint1, this.m_joint2 = t.joint2, this.m_localAnchorA = new box2d.b2Vec2, this.m_localAnchorB = new box2d.b2Vec2, this.m_localAnchorC = new box2d.b2Vec2, this.m_localAnchorD = new box2d.b2Vec2, this.m_localAxisC = new box2d.b2Vec2, this.m_localAxisD = new box2d.b2Vec2, this.m_lcA = new box2d.b2Vec2, this.m_lcB = new box2d.b2Vec2, this.m_lcC = new box2d.b2Vec2, this.m_lcD = new box2d.b2Vec2, this.m_JvAC = new box2d.b2Vec2, this.m_JvBD = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_qC = new box2d.b2Rot, this.m_qD = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_lalcC = new box2d.b2Vec2, this.m_lalcD = new box2d.b2Vec2, this.m_typeA = this.m_joint1.GetType(), this.m_typeB = this.m_joint2.GetType(), box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_typeA === box2d.b2JointType.e_revoluteJoint || this.m_typeA === box2d.b2JointType.e_prismaticJoint), box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_typeB === box2d.b2JointType.e_revoluteJoint || this.m_typeB === box2d.b2JointType.e_prismaticJoint); var e, i;
    this.m_bodyC = this.m_joint1.GetBodyA(), this.m_bodyA = this.m_joint1.GetBodyB(); var o = this.m_bodyA.m_xf,
        n = this.m_bodyA.m_sweep.a,
        s = this.m_bodyC.m_xf,
        r = this.m_bodyC.m_sweep.a; if (this.m_typeA === box2d.b2JointType.e_revoluteJoint) { p = t.joint1;
        this.m_localAnchorC.Copy(p.m_localAnchorA), this.m_localAnchorA.Copy(p.m_localAnchorB), this.m_referenceAngleA = p.m_referenceAngle, this.m_localAxisC.SetZero(), e = n - r - this.m_referenceAngleA } else { m = t.joint1;
        this.m_localAnchorC.Copy(m.m_localAnchorA), this.m_localAnchorA.Copy(m.m_localAnchorB), this.m_referenceAngleA = m.m_referenceAngle, this.m_localAxisC.Copy(m.m_localXAxisA); var a = this.m_localAnchorC,
            h = box2d.b2MulTRV(s.q, box2d.b2AddVV(box2d.b2MulRV(o.q, this.m_localAnchorA, box2d.b2Vec2.s_t0), box2d.b2SubVV(o.p, s.p, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        e = box2d.b2DotVV(box2d.b2SubVV(h, a, box2d.b2Vec2.s_t0), this.m_localAxisC) } this.m_bodyD = this.m_joint2.GetBodyA(), this.m_bodyB = this.m_joint2.GetBodyB(); var l = this.m_bodyB.m_xf,
        c = this.m_bodyB.m_sweep.a,
        d = this.m_bodyD.m_xf,
        u = this.m_bodyD.m_sweep.a; if (this.m_typeB === box2d.b2JointType.e_revoluteJoint) { var p = t.joint2;
        this.m_localAnchorD.Copy(p.m_localAnchorA), this.m_localAnchorB.Copy(p.m_localAnchorB), this.m_referenceAngleB = p.m_referenceAngle, this.m_localAxisD.SetZero(), i = c - u - this.m_referenceAngleB } else { var m = t.joint2;
        this.m_localAnchorD.Copy(m.m_localAnchorA), this.m_localAnchorB.Copy(m.m_localAnchorB), this.m_referenceAngleB = m.m_referenceAngle, this.m_localAxisD.Copy(m.m_localXAxisA); var f = this.m_localAnchorD,
            y = box2d.b2MulTRV(d.q, box2d.b2AddVV(box2d.b2MulRV(l.q, this.m_localAnchorB, box2d.b2Vec2.s_t0), box2d.b2SubVV(l.p, d.p, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        i = box2d.b2DotVV(box2d.b2SubVV(y, f, box2d.b2Vec2.s_t0), this.m_localAxisD) } this.m_ratio = t.ratio, this.m_constant = e + this.m_ratio * i, this.m_impulse = 0 }, goog.inherits(box2d.b2GearJoint, box2d.b2Joint), box2d.b2GearJoint.prototype.m_joint1 = null, box2d.b2GearJoint.prototype.m_joint2 = null, box2d.b2GearJoint.prototype.m_typeA = box2d.b2JointType.e_unknownJoint, box2d.b2GearJoint.prototype.m_typeB = box2d.b2JointType.e_unknownJoint, box2d.b2GearJoint.prototype.m_bodyC = null, box2d.b2GearJoint.prototype.m_bodyD = null, box2d.b2GearJoint.prototype.m_localAnchorA = null, box2d.b2GearJoint.prototype.m_localAnchorB = null, box2d.b2GearJoint.prototype.m_localAnchorC = null, box2d.b2GearJoint.prototype.m_localAnchorD = null, box2d.b2GearJoint.prototype.m_localAxisC = null, box2d.b2GearJoint.prototype.m_localAxisD = null, box2d.b2GearJoint.prototype.m_referenceAngleA = 0, box2d.b2GearJoint.prototype.m_referenceAngleB = 0, box2d.b2GearJoint.prototype.m_constant = 0, box2d.b2GearJoint.prototype.m_ratio = 0, box2d.b2GearJoint.prototype.m_impulse = 0, box2d.b2GearJoint.prototype.m_indexA = 0, box2d.b2GearJoint.prototype.m_indexB = 0, box2d.b2GearJoint.prototype.m_indexC = 0, box2d.b2GearJoint.prototype.m_indexD = 0, box2d.b2GearJoint.prototype.m_lcA = null, box2d.b2GearJoint.prototype.m_lcB = null, box2d.b2GearJoint.prototype.m_lcC = null, box2d.b2GearJoint.prototype.m_lcD = null, box2d.b2GearJoint.prototype.m_mA = 0, box2d.b2GearJoint.prototype.m_mB = 0, box2d.b2GearJoint.prototype.m_mC = 0, box2d.b2GearJoint.prototype.m_mD = 0, box2d.b2GearJoint.prototype.m_iA = 0, box2d.b2GearJoint.prototype.m_iB = 0, box2d.b2GearJoint.prototype.m_iC = 0, box2d.b2GearJoint.prototype.m_iD = 0, box2d.b2GearJoint.prototype.m_JvAC = null, box2d.b2GearJoint.prototype.m_JvBD = null, box2d.b2GearJoint.prototype.m_JwA = 0, box2d.b2GearJoint.prototype.m_JwB = 0, box2d.b2GearJoint.prototype.m_JwC = 0, box2d.b2GearJoint.prototype.m_JwD = 0, box2d.b2GearJoint.prototype.m_mass = 0, box2d.b2GearJoint.prototype.m_qA = null, box2d.b2GearJoint.prototype.m_qB = null, box2d.b2GearJoint.prototype.m_qC = null, box2d.b2GearJoint.prototype.m_qD = null, box2d.b2GearJoint.prototype.m_lalcA = null, box2d.b2GearJoint.prototype.m_lalcB = null, box2d.b2GearJoint.prototype.m_lalcC = null, box2d.b2GearJoint.prototype.m_lalcD = null, box2d.b2GearJoint.prototype.InitVelocityConstraints = function(t) { this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_indexC = this.m_bodyC.m_islandIndex, this.m_indexD = this.m_bodyD.m_islandIndex, this.m_lcA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_lcB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_lcC.Copy(this.m_bodyC.m_sweep.localCenter), this.m_lcD.Copy(this.m_bodyD.m_sweep.localCenter), this.m_mA = this.m_bodyA.m_invMass, this.m_mB = this.m_bodyB.m_invMass, this.m_mC = this.m_bodyC.m_invMass, this.m_mD = this.m_bodyD.m_invMass, this.m_iA = this.m_bodyA.m_invI, this.m_iB = this.m_bodyB.m_invI, this.m_iC = this.m_bodyC.m_invI, this.m_iD = this.m_bodyD.m_invI; var e = t.positions[this.m_indexA].a,
        i = t.velocities[this.m_indexA].v,
        o = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].a,
        s = t.velocities[this.m_indexB].v,
        r = t.velocities[this.m_indexB].w,
        a = t.positions[this.m_indexC].a,
        h = t.velocities[this.m_indexC].v,
        l = t.velocities[this.m_indexC].w,
        c = t.positions[this.m_indexD].a,
        d = t.velocities[this.m_indexD].v,
        u = t.velocities[this.m_indexD].w,
        p = this.m_qA.SetAngleRadians(e),
        m = this.m_qB.SetAngleRadians(n),
        f = this.m_qC.SetAngleRadians(a),
        y = this.m_qD.SetAngleRadians(c); if (this.m_mass = 0, this.m_typeA === box2d.b2JointType.e_revoluteJoint) this.m_JvAC.SetZero(), this.m_JwA = 1, this.m_JwC = 1, this.m_mass += this.m_iA + this.m_iC;
    else { _ = box2d.b2MulRV(f, this.m_localAxisC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u);
        box2d.b2SubVV(this.m_localAnchorC, this.m_lcC, this.m_lalcC); var b = box2d.b2MulRV(f, this.m_lalcC, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC);
        box2d.b2SubVV(this.m_localAnchorA, this.m_lcA, this.m_lalcA); var g = box2d.b2MulRV(p, this.m_lalcA, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA);
        this.m_JvAC.Copy(_), this.m_JwC = box2d.b2CrossVV(b, _), this.m_JwA = box2d.b2CrossVV(g, _), this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA } if (this.m_typeB === box2d.b2JointType.e_revoluteJoint) this.m_JvBD.SetZero(), this.m_JwB = this.m_ratio, this.m_JwD = this.m_ratio, this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
    else { var _ = box2d.b2MulRV(y, this.m_localAxisD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u);
        box2d.b2SubVV(this.m_localAnchorD, this.m_lcD, this.m_lalcD); var v = box2d.b2MulRV(y, this.m_lalcD, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD);
        box2d.b2SubVV(this.m_localAnchorB, this.m_lcB, this.m_lalcB); var x = box2d.b2MulRV(m, this.m_lalcB, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB);
        box2d.b2MulSV(this.m_ratio, _, this.m_JvBD), this.m_JwD = this.m_ratio * box2d.b2CrossVV(v, _), this.m_JwB = this.m_ratio * box2d.b2CrossVV(x, _), this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB } this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0, t.step.warmStarting ? (i.SelfMulAdd(this.m_mA * this.m_impulse, this.m_JvAC), o += this.m_iA * this.m_impulse * this.m_JwA, s.SelfMulAdd(this.m_mB * this.m_impulse, this.m_JvBD), r += this.m_iB * this.m_impulse * this.m_JwB, h.SelfMulSub(this.m_mC * this.m_impulse, this.m_JvAC), l -= this.m_iC * this.m_impulse * this.m_JwC, d.SelfMulSub(this.m_mD * this.m_impulse, this.m_JvBD), u -= this.m_iD * this.m_impulse * this.m_JwD) : this.m_impulse = 0, t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = r, t.velocities[this.m_indexC].w = l, t.velocities[this.m_indexD].w = u }, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_u = new box2d.b2Vec2, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rA = new box2d.b2Vec2, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rB = new box2d.b2Vec2, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rC = new box2d.b2Vec2, box2d.b2GearJoint.prototype.InitVelocityConstraints.s_rD = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolveVelocityConstraints = function(t) { var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        n = t.velocities[this.m_indexB].w,
        s = t.velocities[this.m_indexC].v,
        r = t.velocities[this.m_indexC].w,
        a = t.velocities[this.m_indexD].v,
        h = t.velocities[this.m_indexD].w,
        l = box2d.b2DotVV(this.m_JvAC, box2d.b2SubVV(e, s, box2d.b2Vec2.s_t0)) + box2d.b2DotVV(this.m_JvBD, box2d.b2SubVV(o, a, box2d.b2Vec2.s_t0));
    l += this.m_JwA * i - this.m_JwC * r + (this.m_JwB * n - this.m_JwD * h); var c = -this.m_mass * l;
    this.m_impulse += c, e.SelfMulAdd(this.m_mA * c, this.m_JvAC), i += this.m_iA * c * this.m_JwA, o.SelfMulAdd(this.m_mB * c, this.m_JvBD), n += this.m_iB * c * this.m_JwB, s.SelfMulSub(this.m_mC * c, this.m_JvAC), r -= this.m_iC * c * this.m_JwC, a.SelfMulSub(this.m_mD * c, this.m_JvBD), h -= this.m_iD * c * this.m_JwD, t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = n, t.velocities[this.m_indexC].w = r, t.velocities[this.m_indexD].w = h }, box2d.b2GearJoint.prototype.SolvePositionConstraints = function(t) { var e, i, o, n, s, r, a = t.positions[this.m_indexA].c,
        h = t.positions[this.m_indexA].a,
        l = t.positions[this.m_indexB].c,
        c = t.positions[this.m_indexB].a,
        d = t.positions[this.m_indexC].c,
        u = t.positions[this.m_indexC].a,
        p = t.positions[this.m_indexD].c,
        m = t.positions[this.m_indexD].a,
        f = this.m_qA.SetAngleRadians(h),
        y = this.m_qB.SetAngleRadians(c),
        b = this.m_qC.SetAngleRadians(u),
        g = this.m_qD.SetAngleRadians(m),
        _ = this.m_JvAC,
        v = this.m_JvBD,
        x = 0; if (this.m_typeA === box2d.b2JointType.e_revoluteJoint) _.SetZero(), o = 1, s = 1, x += this.m_iA + this.m_iC, e = h - u - this.m_referenceAngleA;
    else { var S = box2d.b2MulRV(b, this.m_localAxisC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u),
            C = box2d.b2MulRV(b, this.m_lalcC, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC),
            w = box2d.b2MulRV(f, this.m_lalcA, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA);
        _.Copy(S), s = box2d.b2CrossVV(C, S), o = box2d.b2CrossVV(w, S), x += this.m_mC + this.m_mA + this.m_iC * s * s + this.m_iA * o * o; var A = this.m_lalcC,
            T = box2d.b2MulTRV(b, box2d.b2AddVV(w, box2d.b2SubVV(a, d, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        e = box2d.b2DotVV(box2d.b2SubVV(T, A, box2d.b2Vec2.s_t0), this.m_localAxisC) } if (this.m_typeB === box2d.b2JointType.e_revoluteJoint) v.SetZero(), n = this.m_ratio, r = this.m_ratio, x += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD), i = c - m - this.m_referenceAngleB;
    else { var S = box2d.b2MulRV(g, this.m_localAxisD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u),
            P = box2d.b2MulRV(g, this.m_lalcD, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD),
            k = box2d.b2MulRV(y, this.m_lalcB, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB);
        box2d.b2MulSV(this.m_ratio, S, v), r = this.m_ratio * box2d.b2CrossVV(P, S), n = this.m_ratio * box2d.b2CrossVV(k, S), x += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * r * r + this.m_iB * n * n; var M = this.m_lalcD,
            E = box2d.b2MulTRV(g, box2d.b2AddVV(k, box2d.b2SubVV(l, p, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0);
        i = box2d.b2DotVV(box2d.b2SubVV(E, M, box2d.b2Vec2.s_t0), this.m_localAxisD) } var B = e + this.m_ratio * i - this.m_constant,
        I = 0; return x > 0 && (I = -B / x), a.SelfMulAdd(this.m_mA * I, _), h += this.m_iA * I * o, l.SelfMulAdd(this.m_mB * I, v), c += this.m_iB * I * n, d.SelfMulSub(this.m_mC * I, _), u -= this.m_iC * I * s, p.SelfMulSub(this.m_mD * I, v), m -= this.m_iD * I * r, t.positions[this.m_indexA].a = h, t.positions[this.m_indexB].a = c, t.positions[this.m_indexC].a = u, t.positions[this.m_indexD].a = m, 0 < box2d.b2_linearSlop }, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_u = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rC = new box2d.b2Vec2, box2d.b2GearJoint.prototype.SolvePositionConstraints.s_rD = new box2d.b2Vec2, box2d.b2GearJoint.prototype.GetAnchorA = function(t) { return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t) }, box2d.b2GearJoint.prototype.GetAnchorB = function(t) { return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t) }, box2d.b2GearJoint.prototype.GetReactionForce = function(t, e) { return box2d.b2MulSV(t * this.m_impulse, this.m_JvAC, e) }, box2d.b2GearJoint.prototype.GetReactionTorque = function(t) { return t * this.m_impulse * this.m_JwA }, box2d.b2GearJoint.prototype.GetJoint1 = function() { return this.m_joint1 }, box2d.b2GearJoint.prototype.GetJoint2 = function() { return this.m_joint2 }, box2d.b2GearJoint.prototype.GetRatio = function() { return this.m_ratio }, box2d.b2GearJoint.prototype.SetRatio = function(t) { box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t)), this.m_ratio = t }, box2d.b2GearJoint.prototype.Dump = function() { if (box2d.DEBUG) { var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex,
            i = this.m_joint1.m_index,
            o = this.m_joint2.m_index;
        box2d.b2Log("  /*box2d.b2GearJointDef*/ var jd = new box2d.b2GearJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.joint1 = joints[%d];\n", i), box2d.b2Log("  jd.joint2 = joints[%d];\n", o), box2d.b2Log("  jd.ratio = %.15f;\n", this.m_ratio), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index) } }, goog.provide("box2d.b2Distance"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), box2d.b2DistanceProxy = function() { this.m_buffer = box2d.b2Vec2.MakeArray(2) }, box2d.b2DistanceProxy.prototype.m_buffer = null, box2d.b2DistanceProxy.prototype.m_vertices = null, box2d.b2DistanceProxy.prototype.m_count = 0, box2d.b2DistanceProxy.prototype.m_radius = 0, box2d.b2DistanceProxy.prototype.Reset = function() { return this.m_vertices = null, this.m_count = 0, this.m_radius = 0, this }, box2d.b2DistanceProxy.prototype.SetShape = function(t, e) { t.SetupDistanceProxy(this, e) }, box2d.b2DistanceProxy.prototype.GetSupport = function(t) { for (var e = 0, i = box2d.b2DotVV(this.m_vertices[0], t), o = 1; o < this.m_count; ++o) { var n = box2d.b2DotVV(this.m_vertices[o], t);
        n > i && (e = o, i = n) } return e }, box2d.b2DistanceProxy.prototype.GetSupportVertex = function(t, e) { for (var i = 0, o = box2d.b2DotVV(this.m_vertices[0], t), n = 1; n < this.m_count; ++n) { var s = box2d.b2DotVV(this.m_vertices[n], t);
        s > o && (i = n, o = s) } return e.Copy(this.m_vertices[i]) }, box2d.b2DistanceProxy.prototype.GetVertexCount = function() { return this.m_count }, box2d.b2DistanceProxy.prototype.GetVertex = function(t) { return box2d.ENABLE_ASSERTS && box2d.b2Assert(t >= 0 && t < this.m_count), this.m_vertices[t] }, box2d.b2SimplexCache = function() { this.indexA = box2d.b2MakeNumberArray(3), this.indexB = box2d.b2MakeNumberArray(3) }, box2d.b2SimplexCache.prototype.metric = 0, box2d.b2SimplexCache.prototype.count = 0, box2d.b2SimplexCache.prototype.indexA = null, box2d.b2SimplexCache.prototype.indexB = null, box2d.b2SimplexCache.prototype.Reset = function() { return this.metric = 0, this.count = 0, this }, box2d.b2DistanceInput = function() { this.proxyA = new box2d.b2DistanceProxy, this.proxyB = new box2d.b2DistanceProxy, this.transformA = new box2d.b2Transform, this.transformB = new box2d.b2Transform }, box2d.b2DistanceInput.prototype.proxyA = null, box2d.b2DistanceInput.prototype.proxyB = null, box2d.b2DistanceInput.prototype.transformA = null, box2d.b2DistanceInput.prototype.transformB = null, box2d.b2DistanceInput.prototype.useRadii = !1, box2d.b2DistanceInput.prototype.Reset = function() { return this.proxyA.Reset(), this.proxyB.Reset(), this.transformA.SetIdentity(), this.transformB.SetIdentity(), this.useRadii = !1, this }, box2d.b2DistanceOutput = function() { this.pointA = new box2d.b2Vec2, this.pointB = new box2d.b2Vec2 }, box2d.b2DistanceOutput.prototype.pointA = null, box2d.b2DistanceOutput.prototype.pointB = null, box2d.b2DistanceOutput.prototype.distance = 0, box2d.b2DistanceOutput.prototype.iterations = 0, box2d.b2DistanceOutput.prototype.Reset = function() { return this.pointA.SetZero(), this.pointB.SetZero(), this.distance = 0, this.iterations = 0, this }, box2d.b2_gjkCalls = 0, box2d.b2_gjkIters = 0, box2d.b2_gjkMaxIters = 0, box2d.b2SimplexVertex = function() { this.wA = new box2d.b2Vec2, this.wB = new box2d.b2Vec2, this.w = new box2d.b2Vec2 }, box2d.b2SimplexVertex.prototype.wA = null, box2d.b2SimplexVertex.prototype.wB = null, box2d.b2SimplexVertex.prototype.w = null, box2d.b2SimplexVertex.prototype.a = 0, box2d.b2SimplexVertex.prototype.indexA = 0, box2d.b2SimplexVertex.prototype.indexB = 0, box2d.b2SimplexVertex.prototype.Copy = function(t) { return this.wA.Copy(t.wA), this.wB.Copy(t.wB), this.w.Copy(t.w), this.a = t.a, this.indexA = t.indexA, this.indexB = t.indexB, this }, box2d.b2Simplex = function() { this.m_v1 = new box2d.b2SimplexVertex, this.m_v2 = new box2d.b2SimplexVertex, this.m_v3 = new box2d.b2SimplexVertex, this.m_vertices = new Array(3), this.m_vertices[0] = this.m_v1, this.m_vertices[1] = this.m_v2, this.m_vertices[2] = this.m_v3 }, box2d.b2Simplex.prototype.m_v1 = null, box2d.b2Simplex.prototype.m_v2 = null, box2d.b2Simplex.prototype.m_v3 = null, box2d.b2Simplex.prototype.m_vertices = null, box2d.b2Simplex.prototype.m_count = 0, box2d.b2Simplex.prototype.ReadCache = function(t, e, i, o, n) { box2d.ENABLE_ASSERTS && box2d.b2Assert(0 <= t.count && t.count <= 3), this.m_count = t.count; for (var s = this.m_vertices, r = 0; r < this.m_count; ++r) {
        (d = s[r]).indexA = t.indexA[r], d.indexB = t.indexB[r]; var a = e.GetVertex(d.indexA),
            h = o.GetVertex(d.indexB);
        box2d.b2MulXV(i, a, d.wA), box2d.b2MulXV(n, h, d.wB), box2d.b2SubVV(d.wB, d.wA, d.w), d.a = 0 } if (this.m_count > 1) { var l = t.metric,
            c = this.GetMetric();
        (.5 * l > c || c > 2 * l || c < box2d.b2_epsilon) && (this.m_count = 0) } if (0 === this.m_count) { var d = s[0];
        d.indexA = 0, d.indexB = 0; var a = e.GetVertex(0),
            h = o.GetVertex(0);
        box2d.b2MulXV(i, a, d.wA), box2d.b2MulXV(n, h, d.wB), box2d.b2SubVV(d.wB, d.wA, d.w), d.a = 1, this.m_count = 1 } }, box2d.b2Simplex.prototype.WriteCache = function(t) { t.metric = this.GetMetric(), t.count = this.m_count; for (var e = this.m_vertices, i = 0; i < this.m_count; ++i) t.indexA[i] = e[i].indexA, t.indexB[i] = e[i].indexB }, box2d.b2Simplex.prototype.GetSearchDirection = function(t) { switch (this.m_count) {
        case 1:
            return box2d.b2NegV(this.m_v1.w, t);
        case 2:
            var e = box2d.b2SubVV(this.m_v2.w, this.m_v1.w, t); return box2d.b2CrossVV(e, box2d.b2NegV(this.m_v1.w, box2d.b2Vec2.s_t0)) > 0 ? box2d.b2CrossOneV(e, t) : box2d.b2CrossVOne(e, t);
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), t.SetZero() } }, box2d.b2Simplex.prototype.GetClosestPoint = function(t) { switch (this.m_count) {
        case 0:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), t.SetZero();
        case 1:
            return t.Copy(this.m_v1.w);
        case 2:
            return t.SetXY(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);
        case 3:
            return t.SetZero();
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), t.SetZero() } }, box2d.b2Simplex.prototype.GetWitnessPoints = function(t, e) { switch (this.m_count) {
        case 0:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1); break;
        case 1:
            t.Copy(this.m_v1.wA), e.Copy(this.m_v1.wB); break;
        case 2:
            t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x, t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y, e.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x, e.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y; break;
        case 3:
            e.x = t.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x, e.y = t.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y; break;
        default:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1) } }, box2d.b2Simplex.prototype.GetMetric = function() { switch (this.m_count) {
        case 0:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0;
        case 1:
            return 0;
        case 2:
            return box2d.b2DistanceVV(this.m_v1.w, this.m_v2.w);
        case 3:
            return box2d.b2CrossVV(box2d.b2SubVV(this.m_v2.w, this.m_v1.w, box2d.b2Vec2.s_t0), box2d.b2SubVV(this.m_v3.w, this.m_v1.w, box2d.b2Vec2.s_t1));
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0 } }, box2d.b2Simplex.prototype.Solve2 = function() { var t = this.m_v1.w,
        e = this.m_v2.w,
        i = box2d.b2SubVV(e, t, box2d.b2Simplex.s_e12),
        o = -box2d.b2DotVV(t, i); if (0 >= o) return this.m_v1.a = 1, void(this.m_count = 1); var n = box2d.b2DotVV(e, i); if (0 >= n) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Copy(this.m_v2); var s = 1 / (n + o);
    this.m_v1.a = n * s, this.m_v2.a = o * s, this.m_count = 2 }, box2d.b2Simplex.prototype.Solve3 = function() { var t = this.m_v1.w,
        e = this.m_v2.w,
        i = this.m_v3.w,
        o = box2d.b2SubVV(e, t, box2d.b2Simplex.s_e12),
        n = box2d.b2DotVV(t, o),
        s = box2d.b2DotVV(e, o),
        r = -n,
        a = box2d.b2SubVV(i, t, box2d.b2Simplex.s_e13),
        h = box2d.b2DotVV(t, a),
        l = box2d.b2DotVV(i, a),
        c = -h,
        d = box2d.b2SubVV(i, e, box2d.b2Simplex.s_e23),
        u = box2d.b2DotVV(e, d),
        p = box2d.b2DotVV(i, d),
        m = -u,
        f = box2d.b2CrossVV(o, a),
        y = f * box2d.b2CrossVV(e, i),
        b = f * box2d.b2CrossVV(i, t),
        g = f * box2d.b2CrossVV(t, e); if (0 >= r && 0 >= c) return this.m_v1.a = 1, void(this.m_count = 1); if (s > 0 && r > 0 && 0 >= g) { var _ = 1 / (s + r); return this.m_v1.a = s * _, this.m_v2.a = r * _, void(this.m_count = 2) } if (l > 0 && c > 0 && 0 >= b) { var v = 1 / (l + c); return this.m_v1.a = l * v, this.m_v3.a = c * v, this.m_count = 2, void this.m_v2.Copy(this.m_v3) } if (0 >= s && 0 >= m) return this.m_v2.a = 1, this.m_count = 1, void this.m_v1.Copy(this.m_v2); if (0 >= l && 0 >= p) return this.m_v3.a = 1, this.m_count = 1, void this.m_v1.Copy(this.m_v3); if (p > 0 && m > 0 && 0 >= y) { var x = 1 / (p + m); return this.m_v2.a = p * x, this.m_v3.a = m * x, this.m_count = 2, void this.m_v1.Copy(this.m_v3) } var S = 1 / (y + b + g);
    this.m_v1.a = y * S, this.m_v2.a = b * S, this.m_v3.a = g * S, this.m_count = 3 }, box2d.b2Simplex.s_e12 = new box2d.b2Vec2, box2d.b2Simplex.s_e13 = new box2d.b2Vec2, box2d.b2Simplex.s_e23 = new box2d.b2Vec2, box2d.b2Distance = function(t, e, i) {++box2d.b2_gjkCalls; var o = i.proxyA,
        n = i.proxyB,
        s = i.transformA,
        r = i.transformB,
        a = box2d.b2Distance.s_simplex;
    a.ReadCache(e, o, s, n, r); for (var h = a.m_vertices, l = box2d.b2Distance.s_saveA, c = box2d.b2Distance.s_saveB, d = 0, u = (box2d.b2_maxFloat, 0); 20 > u;) { d = a.m_count; for (y = 0; d > y; ++y) l[y] = h[y].indexA, c[y] = h[y].indexB; switch (a.m_count) {
            case 1:
                break;
            case 2:
                a.Solve2(); break;
            case 3:
                a.Solve3(); break;
            default:
                box2d.ENABLE_ASSERTS && box2d.b2Assert(!1) } if (3 === a.m_count) break;
        (v = a.GetClosestPoint(box2d.b2Distance.s_p)).GetLengthSquared(); var p = a.GetSearchDirection(box2d.b2Distance.s_d); if (p.GetLengthSquared() < box2d.b2_epsilon_sq) break; var m = h[a.m_count];
        m.indexA = o.GetSupport(box2d.b2MulTRV(s.q, box2d.b2NegV(p, box2d.b2Vec2.s_t0), box2d.b2Distance.s_supportA)), box2d.b2MulXV(s, o.GetVertex(m.indexA), m.wA), m.indexB = n.GetSupport(box2d.b2MulTRV(r.q, p, box2d.b2Distance.s_supportB)), box2d.b2MulXV(r, n.GetVertex(m.indexB), m.wB), box2d.b2SubVV(m.wB, m.wA, m.w), ++u, ++box2d.b2_gjkIters; for (var f = !1, y = 0; d > y; ++y)
            if (m.indexA === l[y] && m.indexB === c[y]) { f = !0; break } if (f) break;++a.m_count } if (box2d.b2_gjkMaxIters = box2d.b2Max(box2d.b2_gjkMaxIters, u), a.GetWitnessPoints(t.pointA, t.pointB), t.distance = box2d.b2DistanceVV(t.pointA, t.pointB), t.iterations = u, a.WriteCache(e), i.useRadii) { var b = o.m_radius,
            g = n.m_radius; if (t.distance > b + g && t.distance > box2d.b2_epsilon) { t.distance -= b + g; var _ = box2d.b2SubVV(t.pointB, t.pointA, box2d.b2Distance.s_normal);
            _.Normalize(), t.pointA.SelfMulAdd(b, _), t.pointB.SelfMulSub(g, _) } else { var v = box2d.b2MidVV(t.pointA, t.pointB, box2d.b2Distance.s_p);
            t.pointA.Copy(v), t.pointB.Copy(v), t.distance = 0 } } }, box2d.b2Distance.s_simplex = new box2d.b2Simplex, box2d.b2Distance.s_saveA = box2d.b2MakeNumberArray(3), box2d.b2Distance.s_saveB = box2d.b2MakeNumberArray(3), box2d.b2Distance.s_p = new box2d.b2Vec2, box2d.b2Distance.s_d = new box2d.b2Vec2, box2d.b2Distance.s_normal = new box2d.b2Vec2, box2d.b2Distance.s_supportA = new box2d.b2Vec2, box2d.b2Distance.s_supportB = new box2d.b2Vec2, goog.provide("box2d.b2WeldJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2WeldJointDef = function() { goog.base(this, box2d.b2JointType.e_weldJoint), this.localAnchorA = new box2d.b2Vec2, this.localAnchorB = new box2d.b2Vec2 }, goog.inherits(box2d.b2WeldJointDef, box2d.b2JointDef), box2d.b2WeldJointDef.prototype.localAnchorA = null, box2d.b2WeldJointDef.prototype.localAnchorB = null, box2d.b2WeldJointDef.prototype.referenceAngle = 0, box2d.b2WeldJointDef.prototype.frequencyHz = 0, box2d.b2WeldJointDef.prototype.dampingRatio = 0, box2d.b2WeldJointDef.prototype.Initialize = function(t, e, i) { this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB), this.referenceAngle = this.bodyB.GetAngleRadians() - this.bodyA.GetAngleRadians() }, box2d.b2WeldJoint = function(t) { goog.base(this, t), this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_referenceAngle = t.referenceAngle, this.m_impulse = new box2d.b2Vec3(0, 0, 0), this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_mass = new box2d.b2Mat33, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_K = new box2d.b2Mat33 }, goog.inherits(box2d.b2WeldJoint, box2d.b2Joint), box2d.b2WeldJoint.prototype.m_frequencyHz = 0, box2d.b2WeldJoint.prototype.m_dampingRatio = 0, box2d.b2WeldJoint.prototype.m_bias = 0, box2d.b2WeldJoint.prototype.m_localAnchorA = null, box2d.b2WeldJoint.prototype.m_localAnchorB = null, box2d.b2WeldJoint.prototype.m_referenceAngle = 0, box2d.b2WeldJoint.prototype.m_gamma = 0, box2d.b2WeldJoint.prototype.m_impulse = null, box2d.b2WeldJoint.prototype.m_indexA = 0, box2d.b2WeldJoint.prototype.m_indexB = 0, box2d.b2WeldJoint.prototype.m_rA = null, box2d.b2WeldJoint.prototype.m_rB = null, box2d.b2WeldJoint.prototype.m_localCenterA = null, box2d.b2WeldJoint.prototype.m_localCenterB = null, box2d.b2WeldJoint.prototype.m_invMassA = 0, box2d.b2WeldJoint.prototype.m_invMassB = 0, box2d.b2WeldJoint.prototype.m_invIA = 0, box2d.b2WeldJoint.prototype.m_invIB = 0, box2d.b2WeldJoint.prototype.m_mass = null, box2d.b2WeldJoint.prototype.m_qA = null, box2d.b2WeldJoint.prototype.m_qB = null, box2d.b2WeldJoint.prototype.m_lalcA = null, box2d.b2WeldJoint.prototype.m_lalcB = null, box2d.b2WeldJoint.prototype.m_K = null, box2d.b2WeldJoint.prototype.InitVelocityConstraints = function(t) { this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI; var e = t.positions[this.m_indexA].a,
        i = t.velocities[this.m_indexA].v,
        o = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].a,
        s = t.velocities[this.m_indexB].v,
        r = t.velocities[this.m_indexB].w,
        a = this.m_qA.SetAngleRadians(e),
        h = this.m_qB.SetAngleRadians(n);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(a, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(h, this.m_lalcB, this.m_rB); var l = this.m_invMassA,
        c = this.m_invMassB,
        d = this.m_invIA,
        u = this.m_invIB,
        p = this.m_K; if (p.ex.x = l + c + this.m_rA.y * this.m_rA.y * d + this.m_rB.y * this.m_rB.y * u, p.ey.x = -this.m_rA.y * this.m_rA.x * d - this.m_rB.y * this.m_rB.x * u, p.ez.x = -this.m_rA.y * d - this.m_rB.y * u, p.ex.y = p.ey.x, p.ey.y = l + c + this.m_rA.x * this.m_rA.x * d + this.m_rB.x * this.m_rB.x * u, p.ez.y = this.m_rA.x * d + this.m_rB.x * u, p.ex.z = p.ez.x, p.ey.z = p.ez.y, p.ez.z = d + u, this.m_frequencyHz > 0) { p.GetInverse22(this.m_mass); var m = d + u,
            f = m > 0 ? 1 / m : 0,
            y = n - e - this.m_referenceAngle,
            b = 2 * box2d.b2_pi * this.m_frequencyHz,
            g = 2 * f * this.m_dampingRatio * b,
            _ = f * b * b,
            v = t.step.dt;
        this.m_gamma = v * (g + v * _), this.m_gamma = 0 !== this.m_gamma ? 1 / this.m_gamma : 0, this.m_bias = y * v * _ * this.m_gamma, m += this.m_gamma, this.m_mass.ez.z = 0 !== m ? 1 / m : 0 } else p.GetSymInverse33(this.m_mass), this.m_gamma = 0, this.m_bias = 0; if (t.step.warmStarting) { this.m_impulse.SelfMul(t.step.dtRatio); var x = box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P.SetXY(this.m_impulse.x, this.m_impulse.y);
        i.SelfMulSub(l, x), o -= d * (box2d.b2CrossVV(this.m_rA, x) + this.m_impulse.z), s.SelfMulAdd(c, x), r += u * (box2d.b2CrossVV(this.m_rB, x) + this.m_impulse.z) } else this.m_impulse.SetZero();
    t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = r }, box2d.b2WeldJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolveVelocityConstraints = function(t) { var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        n = t.velocities[this.m_indexB].w,
        s = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB; if (this.m_frequencyHz > 0) { var l = n - i,
            c = -this.m_mass.ez.z * (l + this.m_bias + this.m_gamma * this.m_impulse.z);
        this.m_impulse.z += c, i -= a * c, n += h * c; var d = box2d.b2SubVV(box2d.b2AddVCrossSV(o, n, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1),
            u = box2d.b2MulM33XY(this.m_mass, d.x, d.y, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1).SelfNeg();
        this.m_impulse.x += u.x, this.m_impulse.y += u.y;
        m = u;
        e.SelfMulSub(s, m), i -= a * box2d.b2CrossVV(this.m_rA, m), o.SelfMulAdd(r, m), n += h * box2d.b2CrossVV(this.m_rB, m) } else { var d = box2d.b2SubVV(box2d.b2AddVCrossSV(o, n, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1),
            l = n - i,
            p = box2d.b2MulM33XYZ(this.m_mass, d.x, d.y, l, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg();
        this.m_impulse.SelfAdd(p); var m = box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P.SetXY(p.x, p.y);
        e.SelfMulSub(s, m), i -= a * (box2d.b2CrossVV(this.m_rA, m) + p.z), o.SelfMulAdd(r, m), n += h * (box2d.b2CrossVV(this.m_rB, m) + p.z) } t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = n }, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_Cdot1 = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse1 = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec3, box2d.b2WeldJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolvePositionConstraints = function(t) { var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        n = t.positions[this.m_indexB].a,
        s = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(n),
        a = this.m_invMassA,
        h = this.m_invMassB,
        l = this.m_invIA,
        c = this.m_invIB;
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA); var d = box2d.b2MulRV(s, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB); var u, p, m = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        f = this.m_K; if (f.ex.x = a + h + d.y * d.y * l + m.y * m.y * c, f.ey.x = -d.y * d.x * l - m.y * m.x * c, f.ez.x = -d.y * l - m.y * c, f.ex.y = f.ey.x, f.ey.y = a + h + d.x * d.x * l + m.x * m.x * c, f.ez.y = d.x * l + m.x * c, f.ex.z = f.ez.x, f.ey.z = f.ez.y, f.ez.z = l + c, this.m_frequencyHz > 0) { u = (y = box2d.b2SubVV(box2d.b2AddVV(o, m, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, d, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1)).GetLength(), p = 0;
        _ = f.Solve22(y.x, y.y, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P).SelfNeg();
        e.SelfMulSub(a, _), i -= l * box2d.b2CrossVV(d, _), o.SelfMulAdd(h, _), n += c * box2d.b2CrossVV(m, _) } else { var y = box2d.b2SubVV(box2d.b2AddVV(o, m, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, d, box2d.b2Vec2.s_t1), box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1),
            b = n - i - this.m_referenceAngle;
        u = y.GetLength(), p = box2d.b2Abs(b); var g = f.Solve33(y.x, y.y, b, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse).SelfNeg(),
            _ = box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P.SetXY(g.x, g.y);
        e.SelfMulSub(a, _), i -= l * (box2d.b2CrossVV(this.m_rA, _) + g.z), o.SelfMulAdd(h, _), n += c * (box2d.b2CrossVV(this.m_rB, _) + g.z) } return t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = n, u <= box2d.b2_linearSlop && p <= box2d.b2_angularSlop }, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_C1 = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2WeldJoint.prototype.SolvePositionConstraints.s_impulse = new box2d.b2Vec3, box2d.b2WeldJoint.prototype.GetAnchorA = function(t) { return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t) }, box2d.b2WeldJoint.prototype.GetAnchorB = function(t) { return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t) }, box2d.b2WeldJoint.prototype.GetReactionForce = function(t, e) { return e.SetXY(t * this.m_impulse.x, t * this.m_impulse.y) }, box2d.b2WeldJoint.prototype.GetReactionTorque = function(t) { return t * this.m_impulse.z }, box2d.b2WeldJoint.prototype.GetLocalAnchorA = function(t) { return t.Copy(this.m_localAnchorA) }, box2d.b2WeldJoint.prototype.GetLocalAnchorB = function(t) { return t.Copy(this.m_localAnchorB) }, box2d.b2WeldJoint.prototype.GetReferenceAngle = function() { return this.m_referenceAngle }, box2d.b2WeldJoint.prototype.SetFrequency = function(t) { this.m_frequencyHz = t }, box2d.b2WeldJoint.prototype.GetFrequency = function() { return this.m_frequencyHz }, box2d.b2WeldJoint.prototype.SetDampingRatio = function(t) { this.m_dampingRatio = t }, box2d.b2WeldJoint.prototype.GetDampingRatio = function() { return this.m_dampingRatio }, box2d.b2WeldJoint.prototype.Dump = function() { if (box2d.DEBUG) { var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2WeldJointDef*/ var jd = new box2d.b2WeldJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.referenceAngle = %.15f;\n", this.m_referenceAngle), box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz), box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index) } }, goog.provide("box2d.b2RopeJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2RopeJointDef = function() { goog.base(this, box2d.b2JointType.e_ropeJoint), this.localAnchorA = new box2d.b2Vec2(-1, 0), this.localAnchorB = new box2d.b2Vec2(1, 0) }, goog.inherits(box2d.b2RopeJointDef, box2d.b2JointDef), box2d.b2RopeJointDef.prototype.localAnchorA = null, box2d.b2RopeJointDef.prototype.localAnchorB = null, box2d.b2RopeJointDef.prototype.maxLength = 0, box2d.b2RopeJoint = function(t) { goog.base(this, t), this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_maxLength = t.maxLength, this.m_u = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2 }, goog.inherits(box2d.b2RopeJoint, box2d.b2Joint), box2d.b2RopeJoint.prototype.m_localAnchorA = null, box2d.b2RopeJoint.prototype.m_localAnchorB = null, box2d.b2RopeJoint.prototype.m_maxLength = 0, box2d.b2RopeJoint.prototype.m_length = 0, box2d.b2RopeJoint.prototype.m_impulse = 0, box2d.b2RopeJoint.prototype.m_indexA = 0, box2d.b2RopeJoint.prototype.m_indexB = 0, box2d.b2RopeJoint.prototype.m_u = null, box2d.b2RopeJoint.prototype.m_rA = null, box2d.b2RopeJoint.prototype.m_rB = null, box2d.b2RopeJoint.prototype.m_localCenterA = null, box2d.b2RopeJoint.prototype.m_localCenterB = null, box2d.b2RopeJoint.prototype.m_invMassA = 0, box2d.b2RopeJoint.prototype.m_invMassB = 0, box2d.b2RopeJoint.prototype.m_invIA = 0, box2d.b2RopeJoint.prototype.m_invIB = 0, box2d.b2RopeJoint.prototype.m_mass = 0, box2d.b2RopeJoint.prototype.m_state = box2d.b2LimitState.e_inactiveLimit, box2d.b2RopeJoint.prototype.m_qA = null, box2d.b2RopeJoint.prototype.m_qB = null, box2d.b2RopeJoint.prototype.m_lalcA = null, box2d.b2RopeJoint.prototype.m_lalcB = null, box2d.b2RopeJoint.prototype.InitVelocityConstraints = function(t) { this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI; var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        n = t.velocities[this.m_indexA].w,
        s = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        c = this.m_qB.SetAngleRadians(r);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(l, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(c, this.m_lalcB, this.m_rB), this.m_u.Copy(s).SelfAdd(this.m_rB).SelfSub(e).SelfSub(this.m_rA), this.m_length = this.m_u.GetLength(); var d = this.m_length - this.m_maxLength; if (this.m_state = d > 0 ? box2d.b2LimitState.e_atUpperLimit : box2d.b2LimitState.e_inactiveLimit, !(this.m_length > box2d.b2_linearSlop)) return this.m_u.SetZero(), this.m_mass = 0, void(this.m_impulse = 0);
    this.m_u.SelfMul(1 / this.m_length); var u = box2d.b2CrossVV(this.m_rA, this.m_u),
        p = box2d.b2CrossVV(this.m_rB, this.m_u),
        m = this.m_invMassA + this.m_invIA * u * u + this.m_invMassB + this.m_invIB * p * p; if (this.m_mass = 0 !== m ? 1 / m : 0, t.step.warmStarting) { this.m_impulse *= t.step.dtRatio; var f = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P);
        o.SelfMulSub(this.m_invMassA, f), n -= this.m_invIA * box2d.b2CrossVV(this.m_rA, f), a.SelfMulAdd(this.m_invMassB, f), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, f) } else this.m_impulse = 0;
    t.velocities[this.m_indexA].w = n, t.velocities[this.m_indexB].w = h }, box2d.b2RopeJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.SolveVelocityConstraints = function(t) { var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        n = t.velocities[this.m_indexB].w,
        s = box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA),
        r = box2d.b2AddVCrossSV(o, n, this.m_rB, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB),
        a = this.m_length - this.m_maxLength,
        h = box2d.b2DotVV(this.m_u, box2d.b2SubVV(r, s, box2d.b2Vec2.s_t0));
    0 > a && (h += t.step.inv_dt * a); var l = -this.m_mass * h,
        c = this.m_impulse;
    this.m_impulse = box2d.b2Min(0, this.m_impulse + l), l = this.m_impulse - c; var d = box2d.b2MulSV(l, this.m_u, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P);
    e.SelfMulSub(this.m_invMassA, d), i -= this.m_invIA * box2d.b2CrossVV(this.m_rA, d), o.SelfMulAdd(this.m_invMassB, d), n += this.m_invIB * box2d.b2CrossVV(this.m_rB, d), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = n }, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.SolvePositionConstraints = function(t) { var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        n = t.positions[this.m_indexB].a,
        s = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(n);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA); var a = box2d.b2MulRV(s, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB); var h = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        l = this.m_u.Copy(o).SelfAdd(h).SelfSub(e).SelfSub(a),
        c = l.Normalize(),
        d = c - this.m_maxLength;
    d = box2d.b2Clamp(d, 0, box2d.b2_maxLinearCorrection); var u = -this.m_mass * d,
        p = box2d.b2MulSV(u, l, box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P); return e.SelfMulSub(this.m_invMassA, p), i -= this.m_invIA * box2d.b2CrossVV(a, p), o.SelfMulAdd(this.m_invMassB, p), n += this.m_invIB * box2d.b2CrossVV(h, p), t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = n, c - this.m_maxLength < box2d.b2_linearSlop }, box2d.b2RopeJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2RopeJoint.prototype.GetAnchorA = function(t) { return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t) }, box2d.b2RopeJoint.prototype.GetAnchorB = function(t) { return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t) }, box2d.b2RopeJoint.prototype.GetReactionForce = function(t, e) { return box2d.b2MulSV(t * this.m_impulse, this.m_u, e) }, box2d.b2RopeJoint.prototype.GetReactionTorque = function() { return 0 }, box2d.b2RopeJoint.prototype.GetLocalAnchorA = function(t) { return t.Copy(this.m_localAnchorA) }, box2d.b2RopeJoint.prototype.GetLocalAnchorB = function(t) { return t.Copy(this.m_localAnchorB) }, box2d.b2RopeJoint.prototype.SetMaxLength = function(t) { this.m_maxLength = t }, box2d.b2RopeJoint.prototype.GetMaxLength = function() { return this.m_maxLength }, box2d.b2RopeJoint.prototype.GetLimitState = function() { return this.m_state }, box2d.b2RopeJoint.prototype.Dump = function() { if (box2d.DEBUG) { var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2RopeJointDef*/ var jd = new box2d.b2RopeJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.maxLength = %.15f;\n", this.m_maxLength), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index) } }, goog.provide("box2d.b2GravityController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), box2d.b2GravityController = function() { goog.base(this) }, goog.inherits(box2d.b2GravityController, box2d.b2Controller), box2d.b2GravityController.prototype.G = 1, box2d.b2GravityController.prototype.invSqr = !0, box2d.b2GravityController.prototype.Step = function() { if (this.invSqr)
        for (r = this.m_bodyList; r; r = r.nextBody)
            for (var t = r.body, e = t.GetWorldCenter(), i = t.GetMass(), o = this.m_bodyList; o !== r; o = o.nextBody) { var n = (a = o.body).GetWorldCenter(),
                    s = a.GetMass();
                (c = (h = n.x - e.x) * h + (l = n.y - e.y) * l) < box2d.b2_epsilon || ((d = box2d.b2GravityController.prototype.Step.s_f.SetXY(h, l)).SelfMul(this.G / c / box2d.b2Sqrt(c) * i * s), t.IsAwake() && t.ApplyForce(d, e), a.IsAwake() && a.ApplyForce(d.SelfMul(-1), n)) } else
                for (var r = this.m_bodyList; r; r = r.nextBody)
                    for (var t = r.body, e = t.GetWorldCenter(), i = t.GetMass(), o = this.m_bodyList; o !== r; o = o.nextBody) { var a = o.body,
                            n = a.GetWorldCenter(),
                            s = a.GetMass(),
                            h = n.x - e.x,
                            l = n.y - e.y,
                            c = h * h + l * l; if (!(c < box2d.b2_epsilon)) { var d = box2d.b2GravityController.prototype.Step.s_f.SetXY(h, l);
                            d.SelfMul(this.G / c * i * s), t.IsAwake() && t.ApplyForce(d, e), a.IsAwake() && a.ApplyForce(d.SelfMul(-1), n) } } }, box2d.b2GravityController.prototype.Step.s_f = new box2d.b2Vec2, goog.provide("box2d.b2TimeStep"), goog.require("box2d.b2Settings"), box2d.b2Profile = function() {}, box2d.b2Profile.prototype.step = 0, box2d.b2Profile.prototype.collide = 0, box2d.b2Profile.prototype.solve = 0, box2d.b2Profile.prototype.solveInit = 0, box2d.b2Profile.prototype.solveVelocity = 0, box2d.b2Profile.prototype.solvePosition = 0, box2d.b2Profile.prototype.broadphase = 0, box2d.b2Profile.prototype.solveTOI = 0, box2d.b2Profile.prototype.Reset = function() { return this.step = 0, this.collide = 0, this.solve = 0, this.solveInit = 0, this.solveVelocity = 0, this.solvePosition = 0, this.broadphase = 0, this.solveTOI = 0, this }, box2d.b2TimeStep = function() {}, box2d.b2TimeStep.prototype.dt = 0, box2d.b2TimeStep.prototype.inv_dt = 0, box2d.b2TimeStep.prototype.dtRatio = 0, box2d.b2TimeStep.prototype.velocityIterations = 0, box2d.b2TimeStep.prototype.positionIterations = 0, box2d.b2TimeStep.prototype.warmStarting = !1, box2d.b2TimeStep.prototype.Copy = function(t) { return this.dt = t.dt, this.inv_dt = t.inv_dt, this.dtRatio = t.dtRatio, this.positionIterations = t.positionIterations, this.velocityIterations = t.velocityIterations, this.warmStarting = t.warmStarting, this }, box2d.b2Position = function() { this.c = new box2d.b2Vec2 }, box2d.b2Position.prototype.c = null, box2d.b2Position.prototype.a = 0, box2d.b2Position.MakeArray = function(t) { return box2d.b2MakeArray(t, function() { return new box2d.b2Position }) }, box2d.b2Velocity = function() { this.v = new box2d.b2Vec2 }, box2d.b2Velocity.prototype.v = null, box2d.b2Velocity.prototype.w = 0, box2d.b2Velocity.MakeArray = function(t) { return box2d.b2MakeArray(t, function() { return new box2d.b2Velocity }) }, box2d.b2SolverData = function() { this.step = new box2d.b2TimeStep }, box2d.b2SolverData.prototype.step = null, box2d.b2SolverData.prototype.positions = null, box2d.b2SolverData.prototype.velocities = null, goog.provide("box2d.b2Collision"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Distance"), box2d.b2ContactFeatureType = { e_vertex: 0, e_face: 1 }, goog.exportProperty(box2d.b2ContactFeatureType, "e_vertex", box2d.b2ContactFeatureType.e_vertex), goog.exportProperty(box2d.b2ContactFeatureType, "e_face", box2d.b2ContactFeatureType.e_face), box2d.b2ContactFeature = function(t) { this._id = t }, box2d.b2ContactFeature.prototype._id = null, box2d.b2ContactFeature.prototype._indexA = 0, box2d.b2ContactFeature.prototype._indexB = 0, box2d.b2ContactFeature.prototype._typeA = 0, box2d.b2ContactFeature.prototype._typeB = 0, Object.defineProperty(box2d.b2ContactFeature.prototype, "indexA", { enumerable: !1, configurable: !0, get: function() { return this._indexA }, set: function(t) { this._indexA = t, this._id._key = 4294967040 & this._id._key | 255 & this._indexA } }), Object.defineProperty(box2d.b2ContactFeature.prototype, "indexB", { enumerable: !1, configurable: !0, get: function() { return this._indexB }, set: function(t) { this._indexB = t, this._id._key = 4294902015 & this._id._key | this._indexB << 8 & 65280 } }), Object.defineProperty(box2d.b2ContactFeature.prototype, "typeA", { enumerable: !1, configurable: !0, get: function() { return this._typeA }, set: function(t) { this._typeA = t, this._id._key = 4278255615 & this._id._key | this._typeA << 16 & 16711680 } }), Object.defineProperty(box2d.b2ContactFeature.prototype, "typeB", { enumerable: !1, configurable: !0, get: function() { return this._typeB }, set: function(t) { this._typeB = t, this._id._key = 16777215 & this._id._key | this._typeB << 24 & 4278190080 } }), box2d.b2ContactID = function() { this.cf = new box2d.b2ContactFeature(this) }, box2d.b2ContactID.prototype.cf = null, box2d.b2ContactID.prototype.key = 0, box2d.b2ContactID.prototype.Copy = function(t) { return this.key = t.key, this }, box2d.b2ContactID.prototype.Clone = function() { return (new box2d.b2ContactID).Copy(this) }, Object.defineProperty(box2d.b2ContactID.prototype, "key", { enumerable: !1, configurable: !0, get: function() { return this._key }, set: function(t) { this._key = t, this.cf._indexA = 255 & this._key, this.cf._indexB = this._key >> 8 & 255, this.cf._typeA = this._key >> 16 & 255, this.cf._typeB = this._key >> 24 & 255 } }), box2d.b2ManifoldPoint = function() { this.localPoint = new box2d.b2Vec2, this.id = new box2d.b2ContactID }, box2d.b2ManifoldPoint.prototype.localPoint = null, box2d.b2ManifoldPoint.prototype.normalImpulse = 0, box2d.b2ManifoldPoint.prototype.tangentImpulse = 0, box2d.b2ManifoldPoint.prototype.id = null, box2d.b2ManifoldPoint.MakeArray = function(t) { return box2d.b2MakeArray(t, function() { return new box2d.b2ManifoldPoint }) }, box2d.b2ManifoldPoint.prototype.Reset = function() { this.localPoint.SetZero(), this.normalImpulse = 0, this.tangentImpulse = 0, this.id.key = 0 }, box2d.b2ManifoldPoint.prototype.Copy = function(t) { return this.localPoint.Copy(t.localPoint), this.normalImpulse = t.normalImpulse, this.tangentImpulse = t.tangentImpulse, this.id.Copy(t.id), this }, box2d.b2ManifoldType = { e_unknown: -1, e_circles: 0, e_faceA: 1, e_faceB: 2 }, goog.exportProperty(box2d.b2ManifoldType, "e_unknown", box2d.b2ManifoldType.e_unknown), goog.exportProperty(box2d.b2ManifoldType, "e_circles", box2d.b2ManifoldType.e_circles), goog.exportProperty(box2d.b2ManifoldType, "e_faceA", box2d.b2ManifoldType.e_faceA), goog.exportProperty(box2d.b2ManifoldType, "e_faceB", box2d.b2ManifoldType.e_faceB), box2d.b2Manifold = function() { this.points = box2d.b2ManifoldPoint.MakeArray(box2d.b2_maxManifoldPoints), this.localNormal = new box2d.b2Vec2, this.localPoint = new box2d.b2Vec2, this.type = box2d.b2ManifoldType.e_unknown, this.pointCount = 0 }, box2d.b2Manifold.prototype.points = null, box2d.b2Manifold.prototype.localNormal = null, box2d.b2Manifold.prototype.localPoint = null, box2d.b2Manifold.prototype.type = box2d.b2ManifoldType.e_unknown, box2d.b2Manifold.prototype.pointCount = 0, box2d.b2Manifold.prototype.Reset = function() { for (var t = 0, e = box2d.b2_maxManifoldPoints; e > t; ++t) this.points[t].Reset();
    this.localNormal.SetZero(), this.localPoint.SetZero(), this.type = box2d.b2ManifoldType.e_unknown, this.pointCount = 0 }, box2d.b2Manifold.prototype.Copy = function(t) { this.pointCount = t.pointCount; for (var e = 0, i = box2d.b2_maxManifoldPoints; i > e; ++e) this.points[e].Copy(t.points[e]); return this.localNormal.Copy(t.localNormal), this.localPoint.Copy(t.localPoint), this.type = t.type, this }, box2d.b2Manifold.prototype.Clone = function() { return (new box2d.b2Manifold).Copy(this) }, box2d.b2WorldManifold = function() { this.normal = new box2d.b2Vec2, this.points = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints), this.separations = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints) }, box2d.b2WorldManifold.prototype.normal = null, box2d.b2WorldManifold.prototype.points = null, box2d.b2WorldManifold.prototype.separations = null, box2d.b2WorldManifold.prototype.Initialize = function(t, e, i, o, n) { if (0 !== t.pointCount) switch (t.type) {
        case box2d.b2ManifoldType.e_circles:
            this.normal.SetXY(1, 0); var s = box2d.b2MulXV(e, t.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointA),
                r = box2d.b2MulXV(o, t.points[0].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_pointB);
            box2d.b2DistanceSquaredVV(s, r) > box2d.b2_epsilon_sq && box2d.b2SubVV(r, s, this.normal).SelfNormalize(); var a = box2d.b2AddVMulSV(s, i, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA),
                h = box2d.b2SubVMulSV(r, n, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
            box2d.b2MidVV(a, h, this.points[0]), this.separations[0] = box2d.b2DotVV(box2d.b2SubVV(h, a, box2d.b2Vec2.s_t0), this.normal); break;
        case box2d.b2ManifoldType.e_faceA:
            box2d.b2MulRV(e.q, t.localNormal, this.normal); for (var l = box2d.b2MulXV(e, t.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint), c = 0, d = t.pointCount; d > c; ++c) { var u = box2d.b2MulXV(o, t.points[c].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint),
                    p = i - box2d.b2DotVV(box2d.b2SubVV(u, l, box2d.b2Vec2.s_t0), this.normal),
                    a = box2d.b2AddVMulSV(u, p, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA),
                    h = box2d.b2SubVMulSV(u, n, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB);
                box2d.b2MidVV(a, h, this.points[c]), this.separations[c] = box2d.b2DotVV(box2d.b2SubVV(h, a, box2d.b2Vec2.s_t0), this.normal) } break;
        case box2d.b2ManifoldType.e_faceB:
            box2d.b2MulRV(o.q, t.localNormal, this.normal); for (var l = box2d.b2MulXV(o, t.localPoint, box2d.b2WorldManifold.prototype.Initialize.s_planePoint), c = 0, d = t.pointCount; d > c; ++c) { var u = box2d.b2MulXV(e, t.points[c].localPoint, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint),
                    p = n - box2d.b2DotVV(box2d.b2SubVV(u, l, box2d.b2Vec2.s_t0), this.normal),
                    h = box2d.b2AddVMulSV(u, p, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cB),
                    a = box2d.b2SubVMulSV(u, i, this.normal, box2d.b2WorldManifold.prototype.Initialize.s_cA);
                box2d.b2MidVV(a, h, this.points[c]), this.separations[c] = box2d.b2DotVV(box2d.b2SubVV(a, h, box2d.b2Vec2.s_t0), this.normal) } this.normal.SelfNeg() } }, box2d.b2WorldManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_cA = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_cB = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2, box2d.b2WorldManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2, box2d.b2PointState = { b2_nullState: 0, b2_addState: 1, b2_persistState: 2, b2_removeState: 3 }, goog.exportProperty(box2d.b2PointState, "b2_nullState   ", box2d.b2PointState.b2_nullState), goog.exportProperty(box2d.b2PointState, "b2_addState    ", box2d.b2PointState.b2_addState), goog.exportProperty(box2d.b2PointState, "b2_persistState", box2d.b2PointState.b2_persistState), goog.exportProperty(box2d.b2PointState, "b2_removeState ", box2d.b2PointState.b2_removeState), box2d.b2GetPointStates = function(t, e, i, o) { for (var n = 0, s = i.pointCount; s > n; ++n) { l = (h = i.points[n].id).key;
        t[n] = box2d.b2PointState.b2_removeState; for (var r = 0, a = o.pointCount; a > r; ++r)
            if (o.points[r].id.key === l) { t[n] = box2d.b2PointState.b2_persistState; break } } for (s = box2d.b2_maxManifoldPoints; s > n; ++n) t[n] = box2d.b2PointState.b2_nullState; for (var n = 0, s = o.pointCount; s > n; ++n) { var h = o.points[n].id,
            l = h.key;
        e[n] = box2d.b2PointState.b2_addState; for (var r = 0, a = i.pointCount; a > r; ++r)
            if (i.points[r].id.key === l) { e[n] = box2d.b2PointState.b2_persistState; break } } for (s = box2d.b2_maxManifoldPoints; s > n; ++n) e[n] = box2d.b2PointState.b2_nullState }, box2d.b2ClipVertex = function() { this.v = new box2d.b2Vec2, this.id = new box2d.b2ContactID }, box2d.b2ClipVertex.prototype.v = null, box2d.b2ClipVertex.prototype.id = null, box2d.b2ClipVertex.MakeArray = function(t) { return box2d.b2MakeArray(t, function() { return new box2d.b2ClipVertex }) }, box2d.b2ClipVertex.prototype.Copy = function(t) { return this.v.Copy(t.v), this.id.Copy(t.id), this }, box2d.b2RayCastInput = function() { this.p1 = new box2d.b2Vec2, this.p2 = new box2d.b2Vec2, this.maxFraction = 1 }, box2d.b2RayCastInput.prototype.p1 = null, box2d.b2RayCastInput.prototype.p2 = null, box2d.b2RayCastInput.prototype.maxFraction = 1, box2d.b2RayCastInput.prototype.Copy = function(t) { return this.p1.Copy(t.p1), this.p2.Copy(t.p2), this.maxFraction = t.maxFraction, this }, box2d.b2RayCastOutput = function() { this.normal = new box2d.b2Vec2, this.fraction = 0 }, box2d.b2RayCastOutput.prototype.normal = null, box2d.b2RayCastOutput.prototype.fraction = 0, box2d.b2RayCastOutput.prototype.Copy = function(t) { return this.normal.Copy(t.normal), this.fraction = t.fraction, this }, box2d.b2AABB = function() { this.lowerBound = new box2d.b2Vec2, this.upperBound = new box2d.b2Vec2, this.m_out_center = new box2d.b2Vec2, this.m_out_extent = new box2d.b2Vec2 }, box2d.b2AABB.prototype.lowerBound = null, box2d.b2AABB.prototype.upperBound = null, box2d.b2AABB.prototype.m_out_center = null, box2d.b2AABB.prototype.m_out_extent = null, box2d.b2AABB.prototype.Copy = function(t) { return this.lowerBound.Copy(t.lowerBound), this.upperBound.Copy(t.upperBound), this }, box2d.b2AABB.prototype.IsValid = function() { var t = this.upperBound.x - this.lowerBound.x,
        e = this.upperBound.y - this.lowerBound.y,
        i = t >= 0 && e >= 0; return i = i && this.lowerBound.IsValid() && this.upperBound.IsValid() }, box2d.b2AABB.prototype.GetCenter = function() { return box2d.b2MidVV(this.lowerBound, this.upperBound, this.m_out_center) }, box2d.b2AABB.prototype.GetExtents = function() { return box2d.b2ExtVV(this.lowerBound, this.upperBound, this.m_out_extent) }, box2d.b2AABB.prototype.GetPerimeter = function() { return 2 * (this.upperBound.x - this.lowerBound.x + (this.upperBound.y - this.lowerBound.y)) }, box2d.b2AABB.prototype.Combine1 = function(t) { return this.lowerBound.x = box2d.b2Min(this.lowerBound.x, t.lowerBound.x), this.lowerBound.y = box2d.b2Min(this.lowerBound.y, t.lowerBound.y), this.upperBound.x = box2d.b2Max(this.upperBound.x, t.upperBound.x), this.upperBound.y = box2d.b2Max(this.upperBound.y, t.upperBound.y), this }, box2d.b2AABB.prototype.Combine2 = function(t, e) { return this.lowerBound.x = box2d.b2Min(t.lowerBound.x, e.lowerBound.x), this.lowerBound.y = box2d.b2Min(t.lowerBound.y, e.lowerBound.y), this.upperBound.x = box2d.b2Max(t.upperBound.x, e.upperBound.x), this.upperBound.y = box2d.b2Max(t.upperBound.y, e.upperBound.y), this }, box2d.b2AABB.Combine = function(t, e, i) { return i.Combine2(t, e), i }, box2d.b2AABB.prototype.Contains = function(t) { var e = !0; return e = e && this.lowerBound.x <= t.lowerBound.x, e = e && this.lowerBound.y <= t.lowerBound.y, e = e && t.upperBound.x <= this.upperBound.x, e = e && t.upperBound.y <= this.upperBound.y }, box2d.b2AABB.prototype.RayCast = function(t, e) { var i = -box2d.b2_maxFloat,
        o = box2d.b2_maxFloat,
        n = e.p1.x,
        s = e.p1.y,
        r = e.p2.x - e.p1.x,
        a = e.p2.y - e.p1.y,
        h = box2d.b2Abs(r),
        l = box2d.b2Abs(a),
        c = t.normal; if (h < box2d.b2_epsilon) { if (n < this.lowerBound.x || this.upperBound.x < n) return !1 } else { var d = 1 / r,
            u = -1; if ((p = (this.lowerBound.x - n) * d) > (m = (this.upperBound.x - n) * d)) { f = p;
            p = m, m = f, u = 1 } if (p > i && (c.x = u, c.y = 0, i = p), o = box2d.b2Min(o, m), i > o) return !1 } if (l < box2d.b2_epsilon) { if (s < this.lowerBound.y || this.upperBound.y < s) return !1 } else { var d = 1 / a,
            p = (this.lowerBound.y - s) * d,
            m = (this.upperBound.y - s) * d,
            u = -1; if (p > m) { var f = p;
            p = m, m = f, u = 1 } if (p > i && (c.x = 0, c.y = u, i = p), o = box2d.b2Min(o, m), i > o) return !1 } return !(0 > i || e.maxFraction < i) && (t.fraction = i, !0) }, box2d.b2AABB.prototype.TestOverlap = function(t) { var e = t.lowerBound.x - this.upperBound.x,
        i = t.lowerBound.y - this.upperBound.y,
        o = this.lowerBound.x - t.upperBound.x,
        n = this.lowerBound.y - t.upperBound.y; return !(e > 0 || i > 0) && !(o > 0 || n > 0) }, box2d.b2TestOverlapAABB = function(t, e) { var i = e.lowerBound.x - t.upperBound.x,
        o = e.lowerBound.y - t.upperBound.y,
        n = t.lowerBound.x - e.upperBound.x,
        s = t.lowerBound.y - e.upperBound.y; return !(i > 0 || o > 0) && !(n > 0 || s > 0) }, box2d.b2ClipSegmentToLine = function(t, e, i, o, n) { var s = 0,
        r = e[0],
        a = e[1],
        h = box2d.b2DotVV(i, r.v) - o,
        l = box2d.b2DotVV(i, a.v) - o; if (0 >= h && t[s++].Copy(r), 0 >= l && t[s++].Copy(a), 0 > h * l) { var c = h / (h - l),
            d = t[s].v;
        d.x = r.v.x + c * (a.v.x - r.v.x), d.y = r.v.y + c * (a.v.y - r.v.y); var u = t[s].id;
        u.cf.indexA = n, u.cf.indexB = r.id.cf.indexB, u.cf.typeA = box2d.b2ContactFeatureType.e_vertex, u.cf.typeB = box2d.b2ContactFeatureType.e_face, ++s } return s }, box2d.b2TestOverlapShape = function(t, e, i, o, n, s) { var r = box2d.b2TestOverlapShape.s_input.Reset();
    r.proxyA.SetShape(t, e), r.proxyB.SetShape(i, o), r.transformA.Copy(n), r.transformB.Copy(s), r.useRadii = !0; var a = box2d.b2TestOverlapShape.s_simplexCache.Reset();
    a.count = 0; var h = box2d.b2TestOverlapShape.s_output.Reset(); return box2d.b2Distance(h, a, r), h.distance < 10 * box2d.b2_epsilon }, box2d.b2TestOverlapShape.s_input = new box2d.b2DistanceInput, box2d.b2TestOverlapShape.s_simplexCache = new box2d.b2SimplexCache, box2d.b2TestOverlapShape.s_output = new box2d.b2DistanceOutput, goog.provide("box2d.b2Timer"), goog.require("box2d.b2Settings"), box2d.b2Timer = function() { this.m_start = (new Date).getTime() }, box2d.b2Timer.prototype.m_start = 0, box2d.b2Timer.prototype.Reset = function() { return this.m_start = (new Date).getTime(), this }, box2d.b2Timer.prototype.GetMilliseconds = function() { return (new Date).getTime() - this.m_start }, box2d.b2Counter = function() {}, box2d.b2Counter.prototype.m_count = 0, box2d.b2Counter.prototype.m_min_count = 0, box2d.b2Counter.prototype.m_max_count = 0, box2d.b2Counter.prototype.GetCount = function() { return this.m_count }, box2d.b2Counter.prototype.GetMinCount = function() { return this.m_min_count }, box2d.b2Counter.prototype.GetMaxCount = function() { return this.m_max_count }, box2d.b2Counter.prototype.ResetCount = function() { var t = this.m_count; return this.m_count = 0, t }, box2d.b2Counter.prototype.ResetMinCount = function() { this.m_min_count = 0 }, box2d.b2Counter.prototype.ResetMaxCount = function() { this.m_max_count = 0 }, box2d.b2Counter.prototype.Increment = function() { this.m_count++, this.m_max_count < this.m_count && (this.m_max_count = this.m_count) }, box2d.b2Counter.prototype.Decrement = function() { this.m_count--, this.m_min_count > this.m_count && (this.m_min_count = this.m_count) }, goog.provide("box2d.b2TimeOfImpact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Distance"), goog.require("box2d.b2Math"), goog.require("box2d.b2Timer"), box2d.b2_toiTime = 0, box2d.b2_toiMaxTime = 0, box2d.b2_toiCalls = 0, box2d.b2_toiIters = 0, box2d.b2_toiMaxIters = 0, box2d.b2_toiRootIters = 0, box2d.b2_toiMaxRootIters = 0, box2d.b2TOIInput = function() { this.proxyA = new box2d.b2DistanceProxy, this.proxyB = new box2d.b2DistanceProxy, this.sweepA = new box2d.b2Sweep, this.sweepB = new box2d.b2Sweep }, box2d.b2TOIInput.prototype.proxyA = null, box2d.b2TOIInput.prototype.proxyB = null, box2d.b2TOIInput.prototype.sweepA = null, box2d.b2TOIInput.prototype.sweepB = null, box2d.b2TOIInput.prototype.tMax = 0, box2d.b2TOIOutputState = { e_unknown: 0, e_failed: 1, e_overlapped: 2, e_touching: 3, e_separated: 4 }, goog.exportProperty(box2d.b2TOIOutputState, "e_unknown", box2d.b2TOIOutputState.e_unknown), goog.exportProperty(box2d.b2TOIOutputState, "e_failed", box2d.b2TOIOutputState.e_failed), goog.exportProperty(box2d.b2TOIOutputState, "e_overlapped", box2d.b2TOIOutputState.e_overlapped), goog.exportProperty(box2d.b2TOIOutputState, "e_touching", box2d.b2TOIOutputState.e_touching), goog.exportProperty(box2d.b2TOIOutputState, "e_separated", box2d.b2TOIOutputState.e_separated), box2d.b2TOIOutput = function() {}, box2d.b2TOIOutput.prototype.state = box2d.b2TOIOutputState.e_unknown, box2d.b2TOIOutput.prototype.t = 0, box2d.b2SeparationFunctionType = { e_unknown: -1, e_points: 0, e_faceA: 1, e_faceB: 2 }, goog.exportProperty(box2d.b2SeparationFunctionType, "e_unknown", box2d.b2SeparationFunctionType.e_unknown), goog.exportProperty(box2d.b2SeparationFunctionType, "e_points", box2d.b2SeparationFunctionType.e_points), goog.exportProperty(box2d.b2SeparationFunctionType, "e_faceA", box2d.b2SeparationFunctionType.e_faceA), goog.exportProperty(box2d.b2SeparationFunctionType, "e_faceB", box2d.b2SeparationFunctionType.e_faceB), box2d.b2SeparationFunction = function() { this.m_sweepA = new box2d.b2Sweep, this.m_sweepB = new box2d.b2Sweep, this.m_localPoint = new box2d.b2Vec2, this.m_axis = new box2d.b2Vec2 }, box2d.b2SeparationFunction.prototype.m_proxyA = null, box2d.b2SeparationFunction.prototype.m_proxyB = null, box2d.b2SeparationFunction.prototype.m_sweepA = null, box2d.b2SeparationFunction.prototype.m_sweepB = null, box2d.b2SeparationFunction.prototype.m_type = box2d.b2SeparationFunctionType.e_unknown, box2d.b2SeparationFunction.prototype.m_localPoint = null, box2d.b2SeparationFunction.prototype.m_axis = null, box2d.b2SeparationFunction.prototype.Initialize = function(t, e, i, o, n, s) { this.m_proxyA = e, this.m_proxyB = o; var r = t.count;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(r > 0 && 3 > r), this.m_sweepA.Copy(i), this.m_sweepB.Copy(n); var a = box2d.b2TimeOfImpact.s_xfA,
        h = box2d.b2TimeOfImpact.s_xfB; if (this.m_sweepA.GetTransform(a, s), this.m_sweepB.GetTransform(h, s), 1 === r) { this.m_type = box2d.b2SeparationFunctionType.e_points; var l = this.m_proxyA.GetVertex(t.indexA[0]),
            c = this.m_proxyB.GetVertex(t.indexB[0]),
            d = box2d.b2MulXV(a, l, box2d.b2TimeOfImpact.s_pointA),
            u = box2d.b2MulXV(h, c, box2d.b2TimeOfImpact.s_pointB); return box2d.b2SubVV(u, d, this.m_axis), g = this.m_axis.Normalize() } if (t.indexA[0] === t.indexA[1]) { this.m_type = box2d.b2SeparationFunctionType.e_faceB; var p = this.m_proxyB.GetVertex(t.indexB[0]),
            m = this.m_proxyB.GetVertex(t.indexB[1]);
        box2d.b2CrossVOne(box2d.b2SubVV(m, p, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize();
        b = box2d.b2MulRV(h.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);
        box2d.b2MidVV(p, m, this.m_localPoint); var u = box2d.b2MulXV(h, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB),
            l = this.m_proxyA.GetVertex(t.indexA[0]),
            d = box2d.b2MulXV(a, l, box2d.b2TimeOfImpact.s_pointA); return 0 > (g = box2d.b2DotVV(box2d.b2SubVV(d, u, box2d.b2Vec2.s_t0), b)) && (this.m_axis.SelfNeg(), g = -g), g } this.m_type = box2d.b2SeparationFunctionType.e_faceA; var f = this.m_proxyA.GetVertex(t.indexA[0]),
        y = this.m_proxyA.GetVertex(t.indexA[1]);
    box2d.b2CrossVOne(box2d.b2SubVV(y, f, box2d.b2Vec2.s_t0), this.m_axis).SelfNormalize(); var b = box2d.b2MulRV(a.q, this.m_axis, box2d.b2TimeOfImpact.s_normal);
    box2d.b2MidVV(f, y, this.m_localPoint); var d = box2d.b2MulXV(a, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA),
        c = this.m_proxyB.GetVertex(t.indexB[0]),
        u = box2d.b2MulXV(h, c, box2d.b2TimeOfImpact.s_pointB),
        g = box2d.b2DotVV(box2d.b2SubVV(u, d, box2d.b2Vec2.s_t0), b); return 0 > g && (this.m_axis.SelfNeg(), g = -g), g }, box2d.b2SeparationFunction.prototype.FindMinSeparation = function(t, e, i) { var o = box2d.b2TimeOfImpact.s_xfA,
        n = box2d.b2TimeOfImpact.s_xfB; switch (this.m_sweepA.GetTransform(o, i), this.m_sweepB.GetTransform(n, i), this.m_type) {
        case box2d.b2SeparationFunctionType.e_points:
            var s = box2d.b2MulTRV(o.q, this.m_axis, box2d.b2TimeOfImpact.s_axisA),
                r = box2d.b2MulTRV(n.q, box2d.b2NegV(this.m_axis, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB);
            t[0] = this.m_proxyA.GetSupport(s), e[0] = this.m_proxyB.GetSupport(r); var a = this.m_proxyA.GetVertex(t[0]),
                h = this.m_proxyB.GetVertex(e[0]),
                l = box2d.b2MulXV(o, a, box2d.b2TimeOfImpact.s_pointA),
                c = box2d.b2MulXV(n, h, box2d.b2TimeOfImpact.s_pointB); return u = box2d.b2DotVV(box2d.b2SubVV(c, l, box2d.b2Vec2.s_t0), this.m_axis);
        case box2d.b2SeparationFunctionType.e_faceA:
            var d = box2d.b2MulRV(o.q, this.m_axis, box2d.b2TimeOfImpact.s_normal),
                l = box2d.b2MulXV(o, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA),
                r = box2d.b2MulTRV(n.q, box2d.b2NegV(d, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisB);
            t[0] = -1, e[0] = this.m_proxyB.GetSupport(r); var h = this.m_proxyB.GetVertex(e[0]),
                c = box2d.b2MulXV(n, h, box2d.b2TimeOfImpact.s_pointB); return u = box2d.b2DotVV(box2d.b2SubVV(c, l, box2d.b2Vec2.s_t0), d);
        case box2d.b2SeparationFunctionType.e_faceB:
            var d = box2d.b2MulRV(n.q, this.m_axis, box2d.b2TimeOfImpact.s_normal),
                c = box2d.b2MulXV(n, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB),
                s = box2d.b2MulTRV(o.q, box2d.b2NegV(d, box2d.b2Vec2.s_t0), box2d.b2TimeOfImpact.s_axisA);
            e[0] = -1, t[0] = this.m_proxyA.GetSupport(s); var a = this.m_proxyA.GetVertex(t[0]),
                l = box2d.b2MulXV(o, a, box2d.b2TimeOfImpact.s_pointA),
                u = box2d.b2DotVV(box2d.b2SubVV(l, c, box2d.b2Vec2.s_t0), d); return u;
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), t[0] = -1, e[0] = -1, 0 } }, box2d.b2SeparationFunction.prototype.Evaluate = function(t, e, i) { var o = box2d.b2TimeOfImpact.s_xfA,
        n = box2d.b2TimeOfImpact.s_xfB; switch (this.m_sweepA.GetTransform(o, i), this.m_sweepB.GetTransform(n, i), this.m_type) {
        case box2d.b2SeparationFunctionType.e_points:
            var s = this.m_proxyA.GetVertex(t),
                r = this.m_proxyB.GetVertex(e),
                a = box2d.b2MulXV(o, s, box2d.b2TimeOfImpact.s_pointA),
                h = box2d.b2MulXV(n, r, box2d.b2TimeOfImpact.s_pointB); return c = box2d.b2DotVV(box2d.b2SubVV(h, a, box2d.b2Vec2.s_t0), this.m_axis);
        case box2d.b2SeparationFunctionType.e_faceA:
            var l = box2d.b2MulRV(o.q, this.m_axis, box2d.b2TimeOfImpact.s_normal),
                a = box2d.b2MulXV(o, this.m_localPoint, box2d.b2TimeOfImpact.s_pointA),
                r = this.m_proxyB.GetVertex(e),
                h = box2d.b2MulXV(n, r, box2d.b2TimeOfImpact.s_pointB); return c = box2d.b2DotVV(box2d.b2SubVV(h, a, box2d.b2Vec2.s_t0), l);
        case box2d.b2SeparationFunctionType.e_faceB:
            var l = box2d.b2MulRV(n.q, this.m_axis, box2d.b2TimeOfImpact.s_normal),
                h = box2d.b2MulXV(n, this.m_localPoint, box2d.b2TimeOfImpact.s_pointB),
                s = this.m_proxyA.GetVertex(t),
                a = box2d.b2MulXV(o, s, box2d.b2TimeOfImpact.s_pointA),
                c = box2d.b2DotVV(box2d.b2SubVV(a, h, box2d.b2Vec2.s_t0), l); return c;
        default:
            return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), 0 } }, box2d.b2TimeOfImpact = function(t, e) { var i = box2d.b2TimeOfImpact.s_timer.Reset();++box2d.b2_toiCalls, t.state = box2d.b2TOIOutputState.e_unknown, t.t = e.tMax; var o = e.proxyA,
        n = e.proxyB,
        s = box2d.b2TimeOfImpact.s_sweepA.Copy(e.sweepA),
        r = box2d.b2TimeOfImpact.s_sweepB.Copy(e.sweepB);
    s.Normalize(), r.Normalize(); var a = e.tMax,
        h = o.m_radius + n.m_radius,
        l = box2d.b2Max(box2d.b2_linearSlop, h - 3 * box2d.b2_linearSlop),
        c = .25 * box2d.b2_linearSlop;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(l > c); var d = 0,
        u = 0,
        p = box2d.b2TimeOfImpact.s_cache;
    p.count = 0; var m = box2d.b2TimeOfImpact.s_distanceInput; for (m.proxyA = e.proxyA, m.proxyB = e.proxyB, m.useRadii = !1;;) { var f = box2d.b2TimeOfImpact.s_xfA,
            y = box2d.b2TimeOfImpact.s_xfB;
        s.GetTransform(f, d), r.GetTransform(y, d), m.transformA.Copy(f), m.transformB.Copy(y); var b = box2d.b2TimeOfImpact.s_distanceOutput; if (box2d.b2Distance(b, p, m), b.distance <= 0) { t.state = box2d.b2TOIOutputState.e_overlapped, t.t = 0; break } if (b.distance < l + c) { t.state = box2d.b2TOIOutputState.e_touching, t.t = d; break } var g = box2d.b2TimeOfImpact.s_fcn;
        g.Initialize(p, o, s, n, r, d); for (var _ = !1, v = a, x = 0;;) { var S = box2d.b2TimeOfImpact.s_indexA,
                C = box2d.b2TimeOfImpact.s_indexB,
                w = g.FindMinSeparation(S, C, v); if (w > l + c) { t.state = box2d.b2TOIOutputState.e_separated, t.t = a, _ = !0; break } if (w > l - c) { d = v; break } var A = g.Evaluate(S[0], C[0], d); if (l - c > A) { t.state = box2d.b2TOIOutputState.e_failed, t.t = d, _ = !0; break } if (l + c >= A) { t.state = box2d.b2TOIOutputState.e_touching, t.t = d, _ = !0; break } for (var T = 0, P = d, k = v;;) { var M = 0;
                M = 1 & T ? P + (l - A) * (k - P) / (w - A) : .5 * (P + k), ++T, ++box2d.b2_toiRootIters; var E = g.Evaluate(S[0], C[0], M); if (box2d.b2Abs(E - l) < c) { v = M; break } if (E > l ? (P = M, A = E) : (k = M, w = E), 50 === T) break } if (box2d.b2_toiMaxRootIters = box2d.b2Max(box2d.b2_toiMaxRootIters, T), ++x === box2d.b2_maxPolygonVertices) break } if (++u, ++box2d.b2_toiIters, _) break; if (20 === u) { t.state = box2d.b2TOIOutputState.e_failed, t.t = d; break } } box2d.b2_toiMaxIters = box2d.b2Max(box2d.b2_toiMaxIters, u); var B = i.GetMilliseconds();
    box2d.b2_toiMaxTime = box2d.b2Max(box2d.b2_toiMaxTime, B), box2d.b2_toiTime += B }, box2d.b2TimeOfImpact.s_timer = new box2d.b2Timer, box2d.b2TimeOfImpact.s_cache = new box2d.b2SimplexCache, box2d.b2TimeOfImpact.s_distanceInput = new box2d.b2DistanceInput, box2d.b2TimeOfImpact.s_distanceOutput = new box2d.b2DistanceOutput, box2d.b2TimeOfImpact.s_xfA = new box2d.b2Transform, box2d.b2TimeOfImpact.s_xfB = new box2d.b2Transform, box2d.b2TimeOfImpact.s_indexA = box2d.b2MakeNumberArray(1), box2d.b2TimeOfImpact.s_indexB = box2d.b2MakeNumberArray(1), box2d.b2TimeOfImpact.s_fcn = new box2d.b2SeparationFunction, box2d.b2TimeOfImpact.s_sweepA = new box2d.b2Sweep, box2d.b2TimeOfImpact.s_sweepB = new box2d.b2Sweep, box2d.b2TimeOfImpact.s_pointA = new box2d.b2Vec2, box2d.b2TimeOfImpact.s_pointB = new box2d.b2Vec2, box2d.b2TimeOfImpact.s_normal = new box2d.b2Vec2, box2d.b2TimeOfImpact.s_axisA = new box2d.b2Vec2, box2d.b2TimeOfImpact.s_axisB = new box2d.b2Vec2, goog.provide("box2d.b2Contact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Collision"), goog.require("box2d.b2TimeOfImpact"), box2d.b2MixFriction = function(t, e) { return box2d.b2Sqrt(t * e) }, box2d.b2MixRestitution = function(t, e) { return t > e ? t : e }, box2d.b2ContactEdge = function() {}, box2d.b2ContactEdge.prototype.other = null, box2d.b2ContactEdge.prototype.contact = null, box2d.b2ContactEdge.prototype.prev = null, box2d.b2ContactEdge.prototype.next = null, box2d.b2ContactFlag = { e_none: 0, e_islandFlag: 1, e_touchingFlag: 2, e_enabledFlag: 4, e_filterFlag: 8, e_bulletHitFlag: 16, e_toiFlag: 32 }, goog.exportProperty(box2d.b2ContactFlag, "e_none", box2d.b2ContactFlag.e_none), goog.exportProperty(box2d.b2ContactFlag, "e_islandFlag", box2d.b2ContactFlag.e_islandFlag), goog.exportProperty(box2d.b2ContactFlag, "e_touchingFlag", box2d.b2ContactFlag.e_touchingFlag), goog.exportProperty(box2d.b2ContactFlag, "e_enabledFlag", box2d.b2ContactFlag.e_enabledFlag), goog.exportProperty(box2d.b2ContactFlag, "e_filterFlag", box2d.b2ContactFlag.e_filterFlag), goog.exportProperty(box2d.b2ContactFlag, "e_bulletHitFlag", box2d.b2ContactFlag.e_bulletHitFlag), goog.exportProperty(box2d.b2ContactFlag, "e_toiFlag", box2d.b2ContactFlag.e_toiFlag), box2d.b2Contact = function() { this.m_nodeA = new box2d.b2ContactEdge, this.m_nodeB = new box2d.b2ContactEdge, this.m_manifold = new box2d.b2Manifold, this.m_oldManifold = new box2d.b2Manifold }, box2d.b2Contact.prototype.m_flags = box2d.b2ContactFlag.e_none, box2d.b2Contact.prototype.m_prev = null, box2d.b2Contact.prototype.m_next = null, box2d.b2Contact.prototype.m_nodeA = null, box2d.b2Contact.prototype.m_nodeB = null, box2d.b2Contact.prototype.m_fixtureA = null, box2d.b2Contact.prototype.m_fixtureB = null, box2d.b2Contact.prototype.m_indexA = 0, box2d.b2Contact.prototype.m_indexB = 0, box2d.b2Contact.prototype.m_manifold = null, box2d.b2Contact.prototype.m_toiCount = 0, box2d.b2Contact.prototype.m_toi = 0, box2d.b2Contact.prototype.m_friction = 0, box2d.b2Contact.prototype.m_restitution = 0, box2d.b2Contact.prototype.m_tangentSpeed = 0, box2d.b2Contact.prototype.m_oldManifold = null, box2d.b2Contact.prototype.GetManifold = function() { return this.m_manifold }, box2d.b2Contact.prototype.GetWorldManifold = function(t) { var e = this.m_fixtureA.GetBody(),
        i = this.m_fixtureB.GetBody(),
        o = this.m_fixtureA.GetShape(),
        n = this.m_fixtureB.GetShape();
    t.Initialize(this.m_manifold, e.GetTransform(), o.m_radius, i.GetTransform(), n.m_radius) }, box2d.b2Contact.prototype.IsTouching = function() { return (this.m_flags & box2d.b2ContactFlag.e_touchingFlag) === box2d.b2ContactFlag.e_touchingFlag }, box2d.b2Contact.prototype.SetEnabled = function(t) { t ? this.m_flags |= box2d.b2ContactFlag.e_enabledFlag : this.m_flags &= ~box2d.b2ContactFlag.e_enabledFlag }, box2d.b2Contact.prototype.IsEnabled = function() { return (this.m_flags & box2d.b2ContactFlag.e_enabledFlag) === box2d.b2ContactFlag.e_enabledFlag }, box2d.b2Contact.prototype.GetNext = function() { return this.m_next }, box2d.b2Contact.prototype.GetFixtureA = function() { return this.m_fixtureA }, box2d.b2Contact.prototype.GetChildIndexA = function() { return this.m_indexA }, box2d.b2Contact.prototype.GetFixtureB = function() { return this.m_fixtureB }, box2d.b2Contact.prototype.GetChildIndexB = function() { return this.m_indexB }, box2d.b2Contact.prototype.Evaluate = function() {}, box2d.b2Contact.prototype.FlagForFiltering = function() { this.m_flags |= box2d.b2ContactFlag.e_filterFlag }, box2d.b2Contact.prototype.SetFriction = function(t) { this.m_friction = t }, box2d.b2Contact.prototype.GetFriction = function() { return this.m_friction }, box2d.b2Contact.prototype.ResetFriction = function() { this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction) }, box2d.b2Contact.prototype.SetRestitution = function(t) { this.m_restitution = t }, box2d.b2Contact.prototype.GetRestitution = function() { return this.m_restitution }, box2d.b2Contact.prototype.ResetRestitution = function() { this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution) }, box2d.b2Contact.prototype.SetTangentSpeed = function(t) { this.m_tangentSpeed = t }, box2d.b2Contact.prototype.GetTangentSpeed = function() { return this.m_tangentSpeed }, box2d.b2Contact.prototype.Reset = function(t, e, i, o) { this.m_flags = box2d.b2ContactFlag.e_enabledFlag, this.m_fixtureA = t, this.m_fixtureB = i, this.m_indexA = e, this.m_indexB = o, this.m_manifold.pointCount = 0, this.m_prev = null, this.m_next = null, this.m_nodeA.contact = null, this.m_nodeA.prev = null, this.m_nodeA.next = null, this.m_nodeA.other = null, this.m_nodeB.contact = null, this.m_nodeB.prev = null, this.m_nodeB.next = null, this.m_nodeB.other = null, this.m_toiCount = 0, this.m_friction = box2d.b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction), this.m_restitution = box2d.b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution) }, box2d.b2Contact.prototype.Update = function(t) { var e = this.m_oldManifold;
    this.m_oldManifold = this.m_manifold, this.m_manifold = e, this.m_flags |= box2d.b2ContactFlag.e_enabledFlag; var i = !1,
        o = (this.m_flags & box2d.b2ContactFlag.e_touchingFlag) === box2d.b2ContactFlag.e_touchingFlag,
        n = this.m_fixtureA.IsSensor(),
        s = this.m_fixtureB.IsSensor(),
        r = n || s,
        a = this.m_fixtureA.GetBody(),
        h = this.m_fixtureB.GetBody(),
        l = a.GetTransform(),
        c = h.GetTransform(); if (r) { var d = this.m_fixtureA.GetShape(),
            u = this.m_fixtureB.GetShape();
        i = box2d.b2TestOverlapShape(d, this.m_indexA, u, this.m_indexB, l, c), this.m_manifold.pointCount = 0 } else { this.Evaluate(this.m_manifold, l, c), i = this.m_manifold.pointCount > 0; for (var p = 0; p < this.m_manifold.pointCount; ++p) { var m = this.m_manifold.points[p];
            m.normalImpulse = 0, m.tangentImpulse = 0; for (var f = m.id, y = 0; y < this.m_oldManifold.pointCount; ++y) { var b = this.m_oldManifold.points[y]; if (b.id.key === f.key) { m.normalImpulse = b.normalImpulse, m.tangentImpulse = b.tangentImpulse; break } } } i !== o && (a.SetAwake(!0), h.SetAwake(!0)) } i ? this.m_flags |= box2d.b2ContactFlag.e_touchingFlag : this.m_flags &= ~box2d.b2ContactFlag.e_touchingFlag, !1 === o && !0 === i && t && t.BeginContact(this), !0 === o && !1 === i && t && t.EndContact(this), !1 === r && i && t && t.PreSolve(this, this.m_oldManifold) }, box2d.b2Contact.prototype.ComputeTOI = function(t, e) { var i = box2d.b2Contact.prototype.ComputeTOI.s_input;
    i.proxyA.SetShape(this.m_fixtureA.GetShape(), this.m_indexA), i.proxyB.SetShape(this.m_fixtureB.GetShape(), this.m_indexB), i.sweepA.Copy(t), i.sweepB.Copy(e), i.tMax = box2d.b2_linearSlop; var o = box2d.b2Contact.prototype.ComputeTOI.s_output; return box2d.b2TimeOfImpact(o, i), o.t }, box2d.b2Contact.prototype.ComputeTOI.s_input = new box2d.b2TOIInput, box2d.b2Contact.prototype.ComputeTOI.s_output = new box2d.b2TOIOutput, goog.provide("box2d.b2PolygonAndCircleContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), box2d.b2PolygonAndCircleContact = function() { goog.base(this) }, goog.inherits(box2d.b2PolygonAndCircleContact, box2d.b2Contact), box2d.b2PolygonAndCircleContact.Create = function() { return new box2d.b2PolygonAndCircleContact }, box2d.b2PolygonAndCircleContact.Destroy = function() {}, box2d.b2PolygonAndCircleContact.prototype.Reset = function(t, e, i, o) { goog.base(this, "Reset", t, e, i, o), box2d.ENABLE_ASSERTS && box2d.b2Assert(t.GetType() === box2d.b2ShapeType.e_polygonShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(i.GetType() === box2d.b2ShapeType.e_circleShape) }, box2d.b2PolygonAndCircleContact.prototype.Evaluate = function(t, e, i) { var o = this.m_fixtureA.GetShape(),
        n = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2PolygonShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(n instanceof box2d.b2CircleShape), box2d.b2CollidePolygonAndCircle(t, o instanceof box2d.b2PolygonShape ? o : null, e, n instanceof box2d.b2CircleShape ? n : null, i) }, goog.provide("box2d.b2EdgeAndPolygonContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), box2d.b2EdgeAndPolygonContact = function() { goog.base(this) }, goog.inherits(box2d.b2EdgeAndPolygonContact, box2d.b2Contact), box2d.b2EdgeAndPolygonContact.Create = function() { return new box2d.b2EdgeAndPolygonContact }, box2d.b2EdgeAndPolygonContact.Destroy = function() {}, box2d.b2EdgeAndPolygonContact.prototype.Reset = function(t, e, i, o) { goog.base(this, "Reset", t, e, i, o), box2d.ENABLE_ASSERTS && box2d.b2Assert(t.GetType() === box2d.b2ShapeType.e_edgeShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(i.GetType() === box2d.b2ShapeType.e_polygonShape) }, box2d.b2EdgeAndPolygonContact.prototype.Evaluate = function(t, e, i) { var o = this.m_fixtureA.GetShape(),
        n = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2EdgeShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(n instanceof box2d.b2PolygonShape), box2d.b2CollideEdgeAndPolygon(t, o instanceof box2d.b2EdgeShape ? o : null, e, n instanceof box2d.b2PolygonShape ? n : null, i) }, goog.provide("box2d.b2Shape"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Distance"), box2d.b2MassData = function() { this.center = new box2d.b2Vec2(0, 0) }, box2d.b2MassData.prototype.mass = 0, box2d.b2MassData.prototype.center = null, box2d.b2MassData.prototype.I = 0, box2d.b2ShapeType = { e_unknown: -1, e_circleShape: 0, e_edgeShape: 1, e_polygonShape: 2, e_chainShape: 3, e_shapeTypeCount: 4 }, goog.exportProperty(box2d.b2ShapeType, "e_unknown", box2d.b2ShapeType.e_unknown), goog.exportProperty(box2d.b2ShapeType, "e_circleShape", box2d.b2ShapeType.e_circleShape), goog.exportProperty(box2d.b2ShapeType, "e_edgeShape", box2d.b2ShapeType.e_edgeShape), goog.exportProperty(box2d.b2ShapeType, "e_polygonShape", box2d.b2ShapeType.e_polygonShape), goog.exportProperty(box2d.b2ShapeType, "e_chainShape", box2d.b2ShapeType.e_chainShape), goog.exportProperty(box2d.b2ShapeType, "e_shapeTypeCount", box2d.b2ShapeType.e_shapeTypeCount), box2d.b2Shape = function(t, e) { this.m_type = t, this.m_radius = e }, box2d.b2Shape.prototype.m_type = box2d.b2ShapeType.e_unknown, box2d.b2Shape.prototype.m_radius = 0, box2d.b2Shape.prototype.Clone = function() { return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), null }, box2d.b2Shape.prototype.Copy = function(t) { return box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_type === t.m_type), this.m_radius = t.m_radius, this }, box2d.b2Shape.prototype.GetType = function() { return this.m_type }, box2d.b2Shape.prototype.GetChildCount = function() { return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual"), 0 }, box2d.b2Shape.prototype.TestPoint = function() { return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual"), !1 }, box2d.b2Shape.prototype.RayCast = function() { return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual"), !1 }, box2d.b2Shape.prototype.ComputeAABB = function() { box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual") }, box2d.b2Shape.prototype.ComputeMass = function() { box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual") }, box2d.b2Shape.prototype.SetupDistanceProxy = function() { box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual") }, box2d.b2Shape.prototype.ComputeSubmergedArea = function() { return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual"), 0 }, box2d.b2Shape.prototype.Dump = function() { box2d.ENABLE_ASSERTS && box2d.b2Assert(!1, "pure virtual") }, goog.provide("box2d.b2PolygonShape"), goog.require("box2d.b2Shape"), box2d.b2PolygonShape = function() { goog.base(this, box2d.b2ShapeType.e_polygonShape, box2d.b2_polygonRadius), this.m_centroid = new box2d.b2Vec2(0, 0), this.m_vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices), this.m_normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices) }, goog.inherits(box2d.b2PolygonShape, box2d.b2Shape), box2d.b2PolygonShape.prototype.m_centroid = null, box2d.b2PolygonShape.prototype.m_vertices = null, box2d.b2PolygonShape.prototype.m_normals = null, box2d.b2PolygonShape.prototype.m_count = 0, box2d.b2PolygonShape.prototype.Clone = function() { return (new box2d.b2PolygonShape).Copy(this) }, box2d.b2PolygonShape.prototype.Copy = function(t) { goog.base(this, "Copy", t), box2d.ENABLE_ASSERTS && box2d.b2Assert(t instanceof box2d.b2PolygonShape), this.m_centroid.Copy(t.m_centroid), this.m_count = t.m_count; for (var e = 0, i = this.m_count; i > e; ++e) this.m_vertices[e].Copy(t.m_vertices[e]), this.m_normals[e].Copy(t.m_normals[e]); return this }, box2d.b2PolygonShape.prototype.SetAsBox = function(t, e) { return this.m_count = 4, this.m_vertices[0].SetXY(-t, -e), this.m_vertices[1].SetXY(t, -e), this.m_vertices[2].SetXY(t, e), this.m_vertices[3].SetXY(-t, e), this.m_normals[0].SetXY(0, -1), this.m_normals[1].SetXY(1, 0), this.m_normals[2].SetXY(0, 1), this.m_normals[3].SetXY(-1, 0), this.m_centroid.SetZero(), this }, box2d.b2PolygonShape.prototype.SetAsOrientedBox = function(t, e, i, o) { this.m_count = 4, this.m_vertices[0].SetXY(-t, -e), this.m_vertices[1].SetXY(t, -e), this.m_vertices[2].SetXY(t, e), this.m_vertices[3].SetXY(-t, e), this.m_normals[0].SetXY(0, -1), this.m_normals[1].SetXY(1, 0), this.m_normals[2].SetXY(0, 1), this.m_normals[3].SetXY(-1, 0), this.m_centroid.Copy(i); var n = new box2d.b2Transform;
    n.SetPosition(i), n.SetRotationAngleRadians(o); for (var s = 0, r = this.m_count; r > s; ++s) box2d.b2MulXV(n, this.m_vertices[s], this.m_vertices[s]), box2d.b2MulRV(n.q, this.m_normals[s], this.m_normals[s]); return this }, box2d.b2PolygonShape.prototype.Set = function(t, e) { if (void 0 === e && (e = t.length), box2d.ENABLE_ASSERTS && box2d.b2Assert(e >= 3 && e <= box2d.b2_maxPolygonVertices), 3 > e) return this.SetAsBox(1, 1); for (var i = box2d.b2Min(e, box2d.b2_maxPolygonVertices), o = box2d.b2PolygonShape.prototype.Set.s_ps, n = 0, s = 0; i > s; ++s) { for (var r = t[s], a = !0, h = 0; n > h; ++h)
            if (box2d.b2DistanceSquaredVV(r, o[h]) < .5 * box2d.b2_linearSlop) { a = !1; break } a && o[n++].Copy(r) } if (3 > (i = n)) return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), this.SetAsBox(1, 1); for (var l = 0, c = o[0].x, s = 1; i > s; ++s) { var d = o[s].x;
        (d > c || d === c && o[s].y < o[l].y) && (l = s, c = d) } for (var u = box2d.b2PolygonShape.prototype.Set.s_hull, p = 0, m = l;;) { u[p] = m; for (var f = 0, h = 1; i > h; ++h)
            if (f !== m) { var y = box2d.b2SubVV(o[f], o[u[p]], box2d.b2PolygonShape.prototype.Set.s_r),
                    r = box2d.b2SubVV(o[h], o[u[p]], box2d.b2PolygonShape.prototype.Set.s_v),
                    b = box2d.b2CrossVV(y, r);
                0 > b && (f = h), 0 === b && r.GetLengthSquared() > y.GetLengthSquared() && (f = h) } else f = h; if (++p, m = f, f === l) break } this.m_count = p; for (s = 0; p > s; ++s) this.m_vertices[s].Copy(o[u[s]]); for (var s = 0, g = p; g > s; ++s) { var _ = this.m_vertices[s],
            v = this.m_vertices[(s + 1) % g],
            x = box2d.b2SubVV(v, _, box2d.b2Vec2.s_t0);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(x.GetLengthSquared() > box2d.b2_epsilon_sq), box2d.b2CrossVOne(x, this.m_normals[s]).SelfNormalize() } return box2d.b2PolygonShape.ComputeCentroid(this.m_vertices, p, this.m_centroid), this }, box2d.b2PolygonShape.prototype.Set.s_ps = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices), box2d.b2PolygonShape.prototype.Set.s_hull = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices), box2d.b2PolygonShape.prototype.Set.s_r = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.Set.s_v = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.SetAsVector = function(t, e) { return this.Set(t, e), this }, box2d.b2PolygonShape.prototype.SetAsArray = function(t, e) { return this.Set(t, e), this }, box2d.b2PolygonShape.prototype.GetChildCount = function() { return 1 }, box2d.b2PolygonShape.prototype.TestPoint = function(t, e) { for (var i = box2d.b2MulTXV(t, e, box2d.b2PolygonShape.prototype.TestPoint.s_pLocal), o = 0, n = this.m_count; n > o; ++o)
        if (box2d.b2DotVV(this.m_normals[o], box2d.b2SubVV(i, this.m_vertices[o], box2d.b2Vec2.s_t0)) > 0) return !1; return !0 }, box2d.b2PolygonShape.prototype.TestPoint.s_pLocal = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.RayCast = function(t, e, i) { for (var o = box2d.b2MulTXV(i, e.p1, box2d.b2PolygonShape.prototype.RayCast.s_p1), n = box2d.b2MulTXV(i, e.p2, box2d.b2PolygonShape.prototype.RayCast.s_p2), s = box2d.b2SubVV(n, o, box2d.b2PolygonShape.prototype.RayCast.s_d), r = 0, a = e.maxFraction, h = -1, l = 0, c = this.m_count; c > l; ++l) { var d = box2d.b2DotVV(this.m_normals[l], box2d.b2SubVV(this.m_vertices[l], o, box2d.b2Vec2.s_t0)),
            u = box2d.b2DotVV(this.m_normals[l], s); if (0 === u) { if (0 > d) return !1 } else 0 > u && r * u > d ? (r = d / u, h = l) : u > 0 && a * u > d && (a = d / u); if (r > a) return !1 } return box2d.ENABLE_ASSERTS && box2d.b2Assert(r >= 0 && r <= e.maxFraction), h >= 0 && (t.fraction = r, box2d.b2MulRV(i.q, this.m_normals[h], t.normal), !0) }, box2d.b2PolygonShape.prototype.RayCast.s_p1 = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.RayCast.s_p2 = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.RayCast.s_d = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeAABB = function(t, e) { for (var i = box2d.b2MulXV(e, this.m_vertices[0], t.lowerBound), o = t.upperBound.Copy(i), n = 0, s = this.m_count; s > n; ++n) { var r = box2d.b2MulXV(e, this.m_vertices[n], box2d.b2PolygonShape.prototype.ComputeAABB.s_v);
        box2d.b2MinV(r, i, i), box2d.b2MaxV(r, o, o) } var a = this.m_radius;
    i.SelfSubXY(a, a), o.SelfAddXY(a, a) }, box2d.b2PolygonShape.prototype.ComputeAABB.s_v = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeMass = function(t, e) { box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_count >= 3); for (var i = box2d.b2PolygonShape.prototype.ComputeMass.s_center.SetZero(), o = 0, n = 0, s = box2d.b2PolygonShape.prototype.ComputeMass.s_s.SetZero(), r = 0, a = this.m_count; a > r; ++r) s.SelfAdd(this.m_vertices[r]);
    s.SelfMul(1 / this.m_count); for (var r = 0, a = this.m_count; a > r; ++r) { var h = box2d.b2SubVV(this.m_vertices[r], s, box2d.b2PolygonShape.prototype.ComputeMass.s_e1),
            l = box2d.b2SubVV(this.m_vertices[(r + 1) % a], s, box2d.b2PolygonShape.prototype.ComputeMass.s_e2),
            c = box2d.b2CrossVV(h, l),
            d = .5 * c;
        o += d, i.SelfAdd(box2d.b2MulSV(d * (1 / 3), box2d.b2AddVV(h, l, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1)); var u = h.x,
            p = h.y,
            m = l.x,
            f = l.y;
        n += 1 / 3 * .25 * c * (u * u + m * u + m * m + (p * p + f * p + f * f)) } t.mass = e * o, box2d.ENABLE_ASSERTS && box2d.b2Assert(o > box2d.b2_epsilon), i.SelfMul(1 / o), box2d.b2AddVV(i, s, t.center), t.I = e * n, t.I += t.mass * (box2d.b2DotVV(t.center, t.center) - box2d.b2DotVV(i, i)) }, box2d.b2PolygonShape.prototype.ComputeMass.s_center = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeMass.s_s = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeMass.s_e1 = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeMass.s_e2 = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.Validate = function() { for (var t = 0; t < this.m_count; ++t)
        for (var e = t, i = (t + 1) % this.m_count, o = this.m_vertices[e], n = box2d.b2SubVV(this.m_vertices[i], o, box2d.b2PolygonShape.prototype.Validate.s_e), s = 0; s < this.m_count; ++s)
            if (s !== e && s !== i) { var r = box2d.b2SubVV(this.m_vertices[s], o, box2d.b2PolygonShape.prototype.Validate.s_v); if (0 > box2d.b2CrossVV(n, r)) return !1 } return !0 }, box2d.b2PolygonShape.prototype.Validate.s_e = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.Validate.s_v = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.SetupDistanceProxy = function(t) { t.m_vertices = this.m_vertices, t.m_count = this.m_count, t.m_radius = this.m_radius }, box2d.b2PolygonShape.prototype.ComputeSubmergedArea = function(t, e, i, o) { for (var n = box2d.b2MulTRV(i.q, t, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL), s = e - box2d.b2DotVV(t, i.p), r = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths, a = 0, h = -1, l = -1, c = !1, d = 0, u = this.m_count; u > d; ++d) { r[d] = box2d.b2DotVV(n, this.m_vertices[d]) - s; var p = r[d] < -box2d.b2_epsilon;
        d > 0 && (p ? c || (h = d - 1, a++) : c && (l = d - 1, a++)), c = p } switch (a) {
        case 0:
            if (c) { var m = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md; return this.ComputeMass(m, 1), box2d.b2MulXV(i, m.center, o), m.mass } return 0;
        case 1:
            -1 === h ? h = this.m_count - 1 : l = this.m_count - 1 } for (var f = (h + 1) % this.m_count, y = (l + 1) % this.m_count, b = (0 - r[h]) / (r[f] - r[h]), g = (0 - r[l]) / (r[y] - r[l]), _ = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec.SetXY(this.m_vertices[h].x * (1 - b) + this.m_vertices[f].x * b, this.m_vertices[h].y * (1 - b) + this.m_vertices[f].y * b), v = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec.SetXY(this.m_vertices[l].x * (1 - g) + this.m_vertices[y].x * g, this.m_vertices[l].y * (1 - g) + this.m_vertices[y].y * g), x = 0, S = box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center.SetZero(), C = this.m_vertices[f], w = null, d = f; d !== y;) { w = (d = (d + 1) % this.m_count) === y ? v : this.m_vertices[d]; var A = .5 * ((C.x - _.x) * (w.y - _.y) - (C.y - _.y) * (w.x - _.x));
        x += A, S.x += A * (_.x + C.x + w.x) / 3, S.y += A * (_.y + C.y + w.y) / 3, C = w } return S.SelfMul(1 / x), box2d.b2MulXV(i, S, o), x }, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_normalL = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_depths = box2d.b2MakeNumberArray(box2d.b2_maxPolygonVertices), box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_md = new box2d.b2MassData, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_intoVec = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_outoVec = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.ComputeSubmergedArea.s_center = new box2d.b2Vec2, box2d.b2PolygonShape.prototype.Dump = function() { box2d.b2Log("    /*box2d.b2PolygonShape*/ var shape = new box2d.b2PolygonShape();\n"), box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices); for (var t = 0; t < this.m_count; ++t) box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", t, this.m_vertices[t].x, this.m_vertices[t].y);
    box2d.b2Log("    shape.Set(vs, %d);\n", this.m_count) }, box2d.b2PolygonShape.ComputeCentroid = function(t, e, i) { box2d.ENABLE_ASSERTS && box2d.b2Assert(e >= 3); var o = i;
    o.SetZero(); for (var n = 0, s = box2d.b2PolygonShape.ComputeCentroid.s_pRef.SetZero(), r = 0; e > r; ++r) { var a = s,
            h = t[r],
            l = t[(r + 1) % e],
            c = box2d.b2SubVV(h, a, box2d.b2PolygonShape.ComputeCentroid.s_e1),
            d = box2d.b2SubVV(l, a, box2d.b2PolygonShape.ComputeCentroid.s_e2),
            u = .5 * box2d.b2CrossVV(c, d);
        n += u, o.x += u * (1 / 3) * (a.x + h.x + l.x), o.y += u * (1 / 3) * (a.y + h.y + l.y) } return box2d.ENABLE_ASSERTS && box2d.b2Assert(n > box2d.b2_epsilon), o.SelfMul(1 / n), o }, box2d.b2PolygonShape.ComputeCentroid.s_pRef = new box2d.b2Vec2, box2d.b2PolygonShape.ComputeCentroid.s_e1 = new box2d.b2Vec2, box2d.b2PolygonShape.ComputeCentroid.s_e2 = new box2d.b2Vec2, goog.provide("box2d.b2CollideEdge"), goog.require("box2d.b2Collision"), box2d.b2CollideEdgeAndCircle = function(t, e, i, o, n) { t.pointCount = 0; var s = box2d.b2MulTXV(i, box2d.b2MulXV(n, o.m_p, box2d.b2Vec2.s_t0), box2d.b2CollideEdgeAndCircle.s_Q),
        r = e.m_vertex1,
        a = e.m_vertex2,
        h = box2d.b2SubVV(a, r, box2d.b2CollideEdgeAndCircle.s_e),
        l = box2d.b2DotVV(h, box2d.b2SubVV(a, s, box2d.b2Vec2.s_t0)),
        c = box2d.b2DotVV(h, box2d.b2SubVV(s, r, box2d.b2Vec2.s_t0)),
        d = e.m_radius + o.m_radius,
        u = box2d.b2CollideEdgeAndCircle.s_id; if (u.cf.indexB = 0, u.cf.typeB = box2d.b2ContactFeatureType.e_vertex, 0 >= c) { var p = r,
            m = box2d.b2SubVV(s, p, box2d.b2CollideEdgeAndCircle.s_d); if ((S = box2d.b2DotVV(m, m)) > d * d) return; if (e.m_hasVertex0) { var f = e.m_vertex0,
                y = r,
                b = box2d.b2SubVV(y, f, box2d.b2CollideEdgeAndCircle.s_e1); if (box2d.b2DotVV(b, box2d.b2SubVV(y, s, box2d.b2Vec2.s_t0)) > 0) return } return u.cf.indexA = 0, u.cf.typeA = box2d.b2ContactFeatureType.e_vertex, t.pointCount = 1, t.type = box2d.b2ManifoldType.e_circles, t.localNormal.SetZero(), t.localPoint.Copy(p), t.points[0].id.Copy(u), void t.points[0].localPoint.Copy(o.m_p) } if (0 >= l) { var p = a,
            m = box2d.b2SubVV(s, p, box2d.b2CollideEdgeAndCircle.s_d); if ((S = box2d.b2DotVV(m, m)) > d * d) return; if (e.m_hasVertex3) { var g = e.m_vertex3,
                _ = a,
                v = box2d.b2SubVV(g, _, box2d.b2CollideEdgeAndCircle.s_e2); if (box2d.b2DotVV(v, box2d.b2SubVV(s, _, box2d.b2Vec2.s_t0)) > 0) return } return u.cf.indexA = 1, u.cf.typeA = box2d.b2ContactFeatureType.e_vertex, t.pointCount = 1, t.type = box2d.b2ManifoldType.e_circles, t.localNormal.SetZero(), t.localPoint.Copy(p), t.points[0].id.Copy(u), void t.points[0].localPoint.Copy(o.m_p) } var x = box2d.b2DotVV(h, h);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(x > 0), (p = box2d.b2CollideEdgeAndCircle.s_P).x = 1 / x * (l * r.x + c * a.x), p.y = 1 / x * (l * r.y + c * a.y); var m = box2d.b2SubVV(s, p, box2d.b2CollideEdgeAndCircle.s_d),
        S = box2d.b2DotVV(m, m); if (!(S > d * d)) { var C = box2d.b2CollideEdgeAndCircle.s_n.SetXY(-h.y, h.x);
        box2d.b2DotVV(C, box2d.b2SubVV(s, r, box2d.b2Vec2.s_t0)) < 0 && C.SetXY(-C.x, -C.y), C.Normalize(), u.cf.indexA = 0, u.cf.typeA = box2d.b2ContactFeatureType.e_face, t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, t.localNormal.Copy(C), t.localPoint.Copy(r), t.points[0].id.Copy(u), t.points[0].localPoint.Copy(o.m_p) } }, box2d.b2CollideEdgeAndCircle.s_Q = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_e = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_d = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_e1 = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_e2 = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_P = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_n = new box2d.b2Vec2, box2d.b2CollideEdgeAndCircle.s_id = new box2d.b2ContactID, box2d.b2EPAxisType = { e_unknown: 0, e_edgeA: 1, e_edgeB: 2 }, goog.exportProperty(box2d.b2EPAxisType, "e_unknown", box2d.b2EPAxisType.e_unknown), goog.exportProperty(box2d.b2EPAxisType, "e_edgeA", box2d.b2EPAxisType.e_edgeA), goog.exportProperty(box2d.b2EPAxisType, "e_edgeB", box2d.b2EPAxisType.e_edgeB), box2d.b2EPAxis = function() {}, box2d.b2EPAxis.prototype.type = box2d.b2EPAxisType.e_unknown, box2d.b2EPAxis.prototype.index = 0, box2d.b2EPAxis.prototype.separation = 0, box2d.b2TempPolygon = function() { this.vertices = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices), this.normals = box2d.b2Vec2.MakeArray(box2d.b2_maxPolygonVertices), this.count = 0 }, box2d.b2TempPolygon.prototype.vertices = null, box2d.b2TempPolygon.prototype.normals = null, box2d.b2TempPolygon.prototype.count = 0, box2d.b2ReferenceFace = function() { this.i1 = 0, this.i2 = 0, this.v1 = new box2d.b2Vec2, this.v2 = new box2d.b2Vec2, this.normal = new box2d.b2Vec2, this.sideNormal1 = new box2d.b2Vec2, this.sideOffset1 = 0, this.sideNormal2 = new box2d.b2Vec2, this.sideOffset2 = 0 }, box2d.b2ReferenceFace.prototype.i1 = 0, box2d.b2ReferenceFace.prototype.i2 = 0, box2d.b2ReferenceFace.prototype.v1 = null, box2d.b2ReferenceFace.prototype.v2 = null, box2d.b2ReferenceFace.prototype.normal = null, box2d.b2ReferenceFace.prototype.sideNormal1 = null, box2d.b2ReferenceFace.prototype.sideOffset1 = 0, box2d.b2ReferenceFace.prototype.sideNormal2 = null, box2d.b2ReferenceFace.prototype.sideOffset2 = 0, box2d.b2EPColliderVertexType = { e_isolated: 0, e_concave: 1, e_convex: 2 }, goog.exportProperty(box2d.b2EPColliderVertexType, "e_isolated", box2d.b2EPColliderVertexType.e_isolated), goog.exportProperty(box2d.b2EPColliderVertexType, "e_concave", box2d.b2EPColliderVertexType.e_concave), goog.exportProperty(box2d.b2EPColliderVertexType, "e_convex", box2d.b2EPColliderVertexType.e_convex), box2d.b2EPCollider = function() { this.m_polygonB = new box2d.b2TempPolygon, this.m_xf = new box2d.b2Transform, this.m_centroidB = new box2d.b2Vec2, this.m_v0 = new box2d.b2Vec2, this.m_v1 = new box2d.b2Vec2, this.m_v2 = new box2d.b2Vec2, this.m_v3 = new box2d.b2Vec2, this.m_normal0 = new box2d.b2Vec2, this.m_normal1 = new box2d.b2Vec2, this.m_normal2 = new box2d.b2Vec2, this.m_normal = new box2d.b2Vec2, this.m_type1 = box2d.b2EPColliderVertexType.e_isolated, this.m_type2 = box2d.b2EPColliderVertexType.e_isolated, this.m_lowerLimit = new box2d.b2Vec2, this.m_upperLimit = new box2d.b2Vec2, this.m_radius = 0, this.m_front = !1 }, box2d.b2EPCollider.prototype.m_polygonB = null, box2d.b2EPCollider.prototype.m_xf = null, box2d.b2EPCollider.prototype.m_centroidB = null, box2d.b2EPCollider.prototype.m_v0 = null, box2d.b2EPCollider.prototype.m_v1 = null, box2d.b2EPCollider.prototype.m_v2 = null, box2d.b2EPCollider.prototype.m_v3 = null, box2d.b2EPCollider.prototype.m_normal0 = null, box2d.b2EPCollider.prototype.m_normal1 = null, box2d.b2EPCollider.prototype.m_normal2 = null, box2d.b2EPCollider.prototype.m_normal = null, box2d.b2EPCollider.prototype.m_type1 = box2d.b2EPColliderVertexType.e_isolated, box2d.b2EPCollider.prototype.m_type2 = box2d.b2EPColliderVertexType.e_isolated, box2d.b2EPCollider.prototype.m_lowerLimit = null, box2d.b2EPCollider.prototype.m_upperLimit = null, box2d.b2EPCollider.prototype.m_radius = 0, box2d.b2EPCollider.prototype.m_front = !1, box2d.b2EPCollider.prototype.Collide = function(t, e, i, o, n) { box2d.b2MulTXX(i, n, this.m_xf), box2d.b2MulXV(this.m_xf, o.m_centroid, this.m_centroidB), this.m_v0.Copy(e.m_vertex0), this.m_v1.Copy(e.m_vertex1), this.m_v2.Copy(e.m_vertex2), this.m_v3.Copy(e.m_vertex3); var s = e.m_hasVertex0,
        r = e.m_hasVertex3,
        a = box2d.b2SubVV(this.m_v2, this.m_v1, box2d.b2EPCollider.s_edge1);
    a.Normalize(), this.m_normal1.SetXY(a.y, -a.x); var h = box2d.b2DotVV(this.m_normal1, box2d.b2SubVV(this.m_centroidB, this.m_v1, box2d.b2Vec2.s_t0)),
        l = 0,
        c = 0,
        d = !1,
        u = !1; if (s) { var p = box2d.b2SubVV(this.m_v1, this.m_v0, box2d.b2EPCollider.s_edge0);
        p.Normalize(), this.m_normal0.SetXY(p.y, -p.x), d = box2d.b2CrossVV(p, a) >= 0, l = box2d.b2DotVV(this.m_normal0, box2d.b2SubVV(this.m_centroidB, this.m_v0, box2d.b2Vec2.s_t0)) } if (r) { var m = box2d.b2SubVV(this.m_v3, this.m_v2, box2d.b2EPCollider.s_edge2);
        m.Normalize(), this.m_normal2.SetXY(m.y, -m.x), u = box2d.b2CrossVV(a, m) > 0, c = box2d.b2DotVV(this.m_normal2, box2d.b2SubVV(this.m_centroidB, this.m_v2, box2d.b2Vec2.s_t0)) } s && r ? d && u ? (this.m_front = l >= 0 || h >= 0 || c >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg())) : d ? (this.m_front = l >= 0 || h >= 0 && c >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg())) : u ? (this.m_front = c >= 0 || l >= 0 && h >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal0).SelfNeg())) : (this.m_front = l >= 0 && h >= 0 && c >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(), this.m_upperLimit.Copy(this.m_normal0).SelfNeg())) : s ? d ? (this.m_front = l >= 0 || h >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal0), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1).SelfNeg())) : (this.m_front = l >= 0 && h >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal0).SelfNeg())) : r ? u ? (this.m_front = h >= 0 || c >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal2)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1))) : (this.m_front = h >= 0 && c >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1)) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal2).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1))) : (this.m_front = h >= 0, this.m_front ? (this.m_normal.Copy(this.m_normal1), this.m_lowerLimit.Copy(this.m_normal1).SelfNeg(), this.m_upperLimit.Copy(this.m_normal1).SelfNeg()) : (this.m_normal.Copy(this.m_normal1).SelfNeg(), this.m_lowerLimit.Copy(this.m_normal1), this.m_upperLimit.Copy(this.m_normal1))), this.m_polygonB.count = o.m_count; for (var f = 0, y = o.m_count; y > f; ++f) box2d.b2MulXV(this.m_xf, o.m_vertices[f], this.m_polygonB.vertices[f]), box2d.b2MulRV(this.m_xf.q, o.m_normals[f], this.m_polygonB.normals[f]);
    this.m_radius = 2 * box2d.b2_polygonRadius, t.pointCount = 0; var b = this.ComputeEdgeSeparation(box2d.b2EPCollider.s_edgeAxis); if (b.type !== box2d.b2EPAxisType.e_unknown && !(b.separation > this.m_radius)) { var g = this.ComputePolygonSeparation(box2d.b2EPCollider.s_polygonAxis); if (!(g.type !== box2d.b2EPAxisType.e_unknown && g.separation > this.m_radius)) { var _;
            _ = g.type === box2d.b2EPAxisType.e_unknown ? b : g.separation > .98 * b.separation + .001 ? g : b; var v = box2d.b2EPCollider.s_ie,
                x = box2d.b2EPCollider.s_rf; if (_.type === box2d.b2EPAxisType.e_edgeA) { t.type = box2d.b2ManifoldType.e_faceA; for (var S = 0, C = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[0]), f = 1, y = this.m_polygonB.count; y > f; ++f) { var w = box2d.b2DotVV(this.m_normal, this.m_polygonB.normals[f]);
                    C > w && (C = w, S = f) } var A = S,
                    T = (A + 1) % this.m_polygonB.count;
                (P = v[0]).v.Copy(this.m_polygonB.vertices[A]), P.id.cf.indexA = 0, P.id.cf.indexB = A, P.id.cf.typeA = box2d.b2ContactFeatureType.e_face, P.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex, (k = v[1]).v.Copy(this.m_polygonB.vertices[T]), k.id.cf.indexA = 0, k.id.cf.indexB = T, k.id.cf.typeA = box2d.b2ContactFeatureType.e_face, k.id.cf.typeB = box2d.b2ContactFeatureType.e_vertex, this.m_front ? (x.i1 = 0, x.i2 = 1, x.v1.Copy(this.m_v1), x.v2.Copy(this.m_v2), x.normal.Copy(this.m_normal1)) : (x.i1 = 1, x.i2 = 0, x.v1.Copy(this.m_v2), x.v2.Copy(this.m_v1), x.normal.Copy(this.m_normal1).SelfNeg()) } else { t.type = box2d.b2ManifoldType.e_faceB; var P = v[0];
                P.v.Copy(this.m_v1), P.id.cf.indexA = 0, P.id.cf.indexB = _.index, P.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex, P.id.cf.typeB = box2d.b2ContactFeatureType.e_face; var k = v[1];
                k.v.Copy(this.m_v2), k.id.cf.indexA = 0, k.id.cf.indexB = _.index, k.id.cf.typeA = box2d.b2ContactFeatureType.e_vertex, k.id.cf.typeB = box2d.b2ContactFeatureType.e_face, x.i1 = _.index, x.i2 = (x.i1 + 1) % this.m_polygonB.count, x.v1.Copy(this.m_polygonB.vertices[x.i1]), x.v2.Copy(this.m_polygonB.vertices[x.i2]), x.normal.Copy(this.m_polygonB.normals[x.i1]) } x.sideNormal1.SetXY(x.normal.y, -x.normal.x), x.sideNormal2.Copy(x.sideNormal1).SelfNeg(), x.sideOffset1 = box2d.b2DotVV(x.sideNormal1, x.v1), x.sideOffset2 = box2d.b2DotVV(x.sideNormal2, x.v2); var M = box2d.b2EPCollider.s_clipPoints1,
                E = box2d.b2EPCollider.s_clipPoints2; if (!(box2d.b2ClipSegmentToLine(M, v, x.sideNormal1, x.sideOffset1, x.i1) < box2d.b2_maxManifoldPoints || box2d.b2ClipSegmentToLine(E, M, x.sideNormal2, x.sideOffset2, x.i2) < box2d.b2_maxManifoldPoints)) { _.type === box2d.b2EPAxisType.e_edgeA ? (t.localNormal.Copy(x.normal), t.localPoint.Copy(x.v1)) : (t.localNormal.Copy(o.m_normals[x.i1]), t.localPoint.Copy(o.m_vertices[x.i1])); for (var B = 0, f = 0, y = box2d.b2_maxManifoldPoints; y > f; ++f) { if (box2d.b2DotVV(x.normal, box2d.b2SubVV(E[f].v, x.v1, box2d.b2Vec2.s_t0)) <= this.m_radius) { var I = t.points[B];
                        _.type === box2d.b2EPAxisType.e_edgeA ? (box2d.b2MulTXV(this.m_xf, E[f].v, I.localPoint), I.id = E[f].id) : (I.localPoint.Copy(E[f].v), I.id.cf.typeA = E[f].id.cf.typeB, I.id.cf.typeB = E[f].id.cf.typeA, I.id.cf.indexA = E[f].id.cf.indexB, I.id.cf.indexB = E[f].id.cf.indexA), ++B } } t.pointCount = B } } } }, box2d.b2EPCollider.s_edge1 = new box2d.b2Vec2, box2d.b2EPCollider.s_edge0 = new box2d.b2Vec2, box2d.b2EPCollider.s_edge2 = new box2d.b2Vec2, box2d.b2EPCollider.s_ie = box2d.b2ClipVertex.MakeArray(2), box2d.b2EPCollider.s_rf = new box2d.b2ReferenceFace, box2d.b2EPCollider.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2), box2d.b2EPCollider.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2), box2d.b2EPCollider.s_edgeAxis = new box2d.b2EPAxis, box2d.b2EPCollider.s_polygonAxis = new box2d.b2EPAxis, box2d.b2EPCollider.prototype.ComputeEdgeSeparation = function(t) { var e = t;
    e.type = box2d.b2EPAxisType.e_edgeA, e.index = this.m_front ? 0 : 1, e.separation = box2d.b2_maxFloat; for (var i = 0, o = this.m_polygonB.count; o > i; ++i) { var n = box2d.b2DotVV(this.m_normal, box2d.b2SubVV(this.m_polygonB.vertices[i], this.m_v1, box2d.b2Vec2.s_t0));
        n < e.separation && (e.separation = n) } return e }, box2d.b2EPCollider.prototype.ComputePolygonSeparation = function(t) { var e = t;
    e.type = box2d.b2EPAxisType.e_unknown, e.index = -1, e.separation = -box2d.b2_maxFloat; for (var i = box2d.b2EPCollider.s_perp.SetXY(-this.m_normal.y, this.m_normal.x), o = 0, n = this.m_polygonB.count; n > o; ++o) { var s = box2d.b2NegV(this.m_polygonB.normals[o], box2d.b2EPCollider.s_n),
            r = box2d.b2DotVV(s, box2d.b2SubVV(this.m_polygonB.vertices[o], this.m_v1, box2d.b2Vec2.s_t0)),
            a = box2d.b2DotVV(s, box2d.b2SubVV(this.m_polygonB.vertices[o], this.m_v2, box2d.b2Vec2.s_t0)),
            h = box2d.b2Min(r, a); if (h > this.m_radius) return e.type = box2d.b2EPAxisType.e_edgeB, e.index = o, e.separation = h, e; if (box2d.b2DotVV(s, i) >= 0) { if (box2d.b2DotVV(box2d.b2SubVV(s, this.m_upperLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop) continue } else if (box2d.b2DotVV(box2d.b2SubVV(s, this.m_lowerLimit, box2d.b2Vec2.s_t0), this.m_normal) < -box2d.b2_angularSlop) continue;
        h > e.separation && (e.type = box2d.b2EPAxisType.e_edgeB, e.index = o, e.separation = h) } return e }, box2d.b2EPCollider.s_n = new box2d.b2Vec2, box2d.b2EPCollider.s_perp = new box2d.b2Vec2, box2d.b2CollideEdgeAndPolygon = function(t, e, i, o, n) { box2d.b2CollideEdgeAndPolygon.s_collider.Collide(t, e, i, o, n) }, box2d.b2CollideEdgeAndPolygon.s_collider = new box2d.b2EPCollider, goog.provide("box2d.b2EdgeShape"), goog.require("box2d.b2Shape"), box2d.b2EdgeShape = function() { goog.base(this, box2d.b2ShapeType.e_edgeShape, box2d.b2_polygonRadius), this.m_vertex1 = new box2d.b2Vec2, this.m_vertex2 = new box2d.b2Vec2, this.m_vertex0 = new box2d.b2Vec2, this.m_vertex3 = new box2d.b2Vec2 }, goog.inherits(box2d.b2EdgeShape, box2d.b2Shape), box2d.b2EdgeShape.prototype.m_vertex1 = null, box2d.b2EdgeShape.prototype.m_vertex2 = null, box2d.b2EdgeShape.prototype.m_vertex0 = null, box2d.b2EdgeShape.prototype.m_vertex3 = null, box2d.b2EdgeShape.prototype.m_hasVertex0 = !1, box2d.b2EdgeShape.prototype.m_hasVertex3 = !1, box2d.b2EdgeShape.prototype.Set = function(t, e) { return this.m_vertex1.Copy(t), this.m_vertex2.Copy(e), this.m_hasVertex0 = !1, this.m_hasVertex3 = !1, this }, box2d.b2EdgeShape.prototype.SetAsEdge = box2d.b2EdgeShape.prototype.Set, box2d.b2EdgeShape.prototype.Clone = function() { return (new box2d.b2EdgeShape).Copy(this) }, box2d.b2EdgeShape.prototype.Copy = function(t) { return goog.base(this, "Copy", t), box2d.ENABLE_ASSERTS && box2d.b2Assert(t instanceof box2d.b2EdgeShape), this.m_vertex1.Copy(t.m_vertex1), this.m_vertex2.Copy(t.m_vertex2), this.m_vertex0.Copy(t.m_vertex0), this.m_vertex3.Copy(t.m_vertex3), this.m_hasVertex0 = t.m_hasVertex0, this.m_hasVertex3 = t.m_hasVertex3, this }, box2d.b2EdgeShape.prototype.GetChildCount = function() { return 1 }, box2d.b2EdgeShape.prototype.TestPoint = function() { return !1 }, box2d.b2EdgeShape.prototype.RayCast = function(t, e, i) { var o = box2d.b2MulTXV(i, e.p1, box2d.b2EdgeShape.prototype.RayCast.s_p1),
        n = box2d.b2MulTXV(i, e.p2, box2d.b2EdgeShape.prototype.RayCast.s_p2),
        s = box2d.b2SubVV(n, o, box2d.b2EdgeShape.prototype.RayCast.s_d),
        r = this.m_vertex1,
        a = this.m_vertex2,
        h = box2d.b2SubVV(a, r, box2d.b2EdgeShape.prototype.RayCast.s_e),
        l = t.normal.SetXY(h.y, -h.x).SelfNormalize(),
        c = box2d.b2DotVV(l, box2d.b2SubVV(r, o, box2d.b2Vec2.s_t0)),
        d = box2d.b2DotVV(l, s); if (0 === d) return !1; var u = c / d; if (0 > u || e.maxFraction < u) return !1; var p = box2d.b2AddVMulSV(o, u, s, box2d.b2EdgeShape.prototype.RayCast.s_q),
        m = box2d.b2SubVV(a, r, box2d.b2EdgeShape.prototype.RayCast.s_r),
        f = box2d.b2DotVV(m, m); if (0 === f) return !1; var y = box2d.b2DotVV(box2d.b2SubVV(p, r, box2d.b2Vec2.s_t0), m) / f; return !(0 > y || y > 1) && (t.fraction = u, box2d.b2MulRV(i.q, t.normal, t.normal), c > 0 && t.normal.SelfNeg(), !0) }, box2d.b2EdgeShape.prototype.RayCast.s_p1 = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_p2 = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_d = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_e = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_q = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.RayCast.s_r = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.ComputeAABB = function(t, e) { var i = box2d.b2MulXV(e, this.m_vertex1, box2d.b2EdgeShape.prototype.ComputeAABB.s_v1),
        o = box2d.b2MulXV(e, this.m_vertex2, box2d.b2EdgeShape.prototype.ComputeAABB.s_v2);
    box2d.b2MinV(i, o, t.lowerBound), box2d.b2MaxV(i, o, t.upperBound); var n = this.m_radius;
    t.lowerBound.SelfSubXY(n, n), t.upperBound.SelfAddXY(n, n) }, box2d.b2EdgeShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2, box2d.b2EdgeShape.prototype.ComputeMass = function(t) { t.mass = 0, box2d.b2MidVV(this.m_vertex1, this.m_vertex2, t.center), t.I = 0 }, box2d.b2EdgeShape.prototype.SetupDistanceProxy = function(t) { t.m_vertices = new Array(2), t.m_vertices[0] = this.m_vertex1, t.m_vertices[1] = this.m_vertex2, t.m_count = 2, t.m_radius = this.m_radius }, box2d.b2EdgeShape.prototype.ComputeSubmergedArea = function(t, e, i, o) { return o.SetZero(), 0 }, box2d.b2EdgeShape.prototype.Dump = function() { box2d.b2Log("    /*box2d.b2EdgeShape*/ var shape = new box2d.b2EdgeShape();\n"), box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius), box2d.b2Log("    shape.m_vertex0.SetXY(%.15f, %.15f);\n", this.m_vertex0.x, this.m_vertex0.y), box2d.b2Log("    shape.m_vertex1.SetXY(%.15f, %.15f);\n", this.m_vertex1.x, this.m_vertex1.y), box2d.b2Log("    shape.m_vertex2.SetXY(%.15f, %.15f);\n", this.m_vertex2.x, this.m_vertex2.y), box2d.b2Log("    shape.m_vertex3.SetXY(%.15f, %.15f);\n", this.m_vertex3.x, this.m_vertex3.y), box2d.b2Log("    shape.m_hasVertex0 = %s;\n", this.m_hasVertex0), box2d.b2Log("    shape.m_hasVertex3 = %s;\n", this.m_hasVertex3) }, goog.provide("box2d.b2ChainShape"), goog.require("box2d.b2Shape"), goog.require("box2d.b2EdgeShape"), box2d.b2ChainShape = function() { goog.base(this, box2d.b2ShapeType.e_chainShape, box2d.b2_polygonRadius), this.m_prevVertex = new box2d.b2Vec2, this.m_nextVertex = new box2d.b2Vec2 }, goog.inherits(box2d.b2ChainShape, box2d.b2Shape), box2d.b2ChainShape.prototype.m_vertices = null, box2d.b2ChainShape.prototype.m_count = 0, box2d.b2ChainShape.prototype.m_prevVertex = null, box2d.b2ChainShape.prototype.m_nextVertex = null, box2d.b2ChainShape.prototype.m_hasPrevVertex = !1, box2d.b2ChainShape.prototype.m_hasNextVertex = !1, box2d.b2ChainShape.prototype.CreateLoop = function(t, e) { if (e = e || t.length, box2d.ENABLE_ASSERTS && box2d.b2Assert(null === this.m_vertices && 0 === this.m_count), box2d.ENABLE_ASSERTS && box2d.b2Assert(e >= 3), box2d.ENABLE_ASSERTS)
        for (n = 1; e > n; ++n) { var i = t[n - 1],
                o = t[n];
            box2d.b2Assert(box2d.b2DistanceSquaredVV(i, o) > box2d.b2_linearSlop * box2d.b2_linearSlop) } this.m_count = e + 1, this.m_vertices = box2d.b2Vec2.MakeArray(this.m_count); for (var n = 0; e > n; ++n) this.m_vertices[n].Copy(t[n]); return this.m_vertices[e].Copy(this.m_vertices[0]), this.m_prevVertex.Copy(this.m_vertices[this.m_count - 2]), this.m_nextVertex.Copy(this.m_vertices[1]), this.m_hasPrevVertex = !0, this.m_hasNextVertex = !0, this }, box2d.b2ChainShape.prototype.CreateChain = function(t, e) { if (e = e || t.length, box2d.ENABLE_ASSERTS && box2d.b2Assert(null === this.m_vertices && 0 === this.m_count), box2d.ENABLE_ASSERTS && box2d.b2Assert(e >= 2), box2d.ENABLE_ASSERTS)
        for (n = 1; e > n; ++n) { var i = t[n - 1],
                o = t[n];
            box2d.b2Assert(box2d.b2DistanceSquaredVV(i, o) > box2d.b2_linearSlop * box2d.b2_linearSlop) } this.m_count = e, this.m_vertices = box2d.b2Vec2.MakeArray(e); for (var n = 0; e > n; ++n) this.m_vertices[n].Copy(t[n]); return this.m_hasPrevVertex = !1, this.m_hasNextVertex = !1, this.m_prevVertex.SetZero(), this.m_nextVertex.SetZero(), this }, box2d.b2ChainShape.prototype.SetPrevVertex = function(t) { return this.m_prevVertex.Copy(t), this.m_hasPrevVertex = !0, this }, box2d.b2ChainShape.prototype.SetNextVertex = function(t) { return this.m_nextVertex.Copy(t), this.m_hasNextVertex = !0, this }, box2d.b2ChainShape.prototype.Clone = function() { return (new box2d.b2ChainShape).Copy(this) }, box2d.b2ChainShape.prototype.Copy = function(t) { return goog.base(this, "Copy", t), box2d.ENABLE_ASSERTS && box2d.b2Assert(t instanceof box2d.b2ChainShape), this.CreateChain(t.m_vertices, t.m_count), this.m_prevVertex.Copy(t.m_prevVertex), this.m_nextVertex.Copy(t.m_nextVertex), this.m_hasPrevVertex = t.m_hasPrevVertex, this.m_hasNextVertex = t.m_hasNextVertex, this }, box2d.b2ChainShape.prototype.GetChildCount = function() { return this.m_count - 1 }, box2d.b2ChainShape.prototype.GetChildEdge = function(t, e) { box2d.ENABLE_ASSERTS && box2d.b2Assert(e >= 0 && e < this.m_count - 1), t.m_type = box2d.b2ShapeType.e_edgeShape, t.m_radius = this.m_radius, t.m_vertex1.Copy(this.m_vertices[e]), t.m_vertex2.Copy(this.m_vertices[e + 1]), e > 0 ? (t.m_vertex0.Copy(this.m_vertices[e - 1]), t.m_hasVertex0 = !0) : (t.m_vertex0.Copy(this.m_prevVertex), t.m_hasVertex0 = this.m_hasPrevVertex), e < this.m_count - 2 ? (t.m_vertex3.Copy(this.m_vertices[e + 2]), t.m_hasVertex3 = !0) : (t.m_vertex3.Copy(this.m_nextVertex), t.m_hasVertex3 = this.m_hasNextVertex) }, box2d.b2ChainShape.prototype.TestPoint = function() { return !1 }, box2d.b2ChainShape.prototype.RayCast = function(t, e, i, o) { box2d.ENABLE_ASSERTS && box2d.b2Assert(o < this.m_count); var n = box2d.b2ChainShape.s_edgeShape; return n.m_vertex1.Copy(this.m_vertices[o]), n.m_vertex2.Copy(this.m_vertices[(o + 1) % this.m_count]), n.RayCast(t, e, i, 0) }, box2d.b2ChainShape.s_edgeShape = new box2d.b2EdgeShape, box2d.b2ChainShape.prototype.ComputeAABB = function(t, e, i) { box2d.ENABLE_ASSERTS && box2d.b2Assert(i < this.m_count); var o = this.m_vertices[i],
        n = this.m_vertices[(i + 1) % this.m_count],
        s = box2d.b2MulXV(e, o, box2d.b2ChainShape.prototype.ComputeAABB.s_v1),
        r = box2d.b2MulXV(e, n, box2d.b2ChainShape.prototype.ComputeAABB.s_v2);
    box2d.b2MinV(s, r, t.lowerBound), box2d.b2MaxV(s, r, t.upperBound) }, box2d.b2ChainShape.prototype.ComputeAABB.s_v1 = new box2d.b2Vec2, box2d.b2ChainShape.prototype.ComputeAABB.s_v2 = new box2d.b2Vec2, box2d.b2ChainShape.prototype.ComputeMass = function(t) { t.mass = 0, t.center.SetZero(), t.I = 0 }, box2d.b2ChainShape.prototype.SetupDistanceProxy = function(t, e) { box2d.ENABLE_ASSERTS && box2d.b2Assert(e >= 0 && e < this.m_count), t.m_buffer[0].Copy(this.m_vertices[e]), t.m_buffer[1].Copy(e + 1 < this.m_count ? this.m_vertices[e + 1] : this.m_vertices[0]), t.m_vertices = t.m_buffer, t.m_count = 2, t.m_radius = this.m_radius }, box2d.b2ChainShape.prototype.ComputeSubmergedArea = function(t, e, i, o) { return o.SetZero(), 0 }, box2d.b2ChainShape.prototype.Dump = function() { box2d.b2Log("    /*box2d.b2ChainShape*/ var shape = new box2d.b2ChainShape();\n"), box2d.b2Log("    /*box2d.b2Vec2[]*/ var vs = box2d.b2Vec2.MakeArray(%d);\n", box2d.b2_maxPolygonVertices); for (var t = 0; t < this.m_count; ++t) box2d.b2Log("    vs[%d].SetXY(%.15f, %.15f);\n", t, this.m_vertices[t].x, this.m_vertices[t].y);
    box2d.b2Log("    shape.CreateChain(vs, %d);\n", this.m_count), box2d.b2Log("    shape.m_prevVertex.SetXY(%.15f, %.15f);\n", this.m_prevVertex.x, this.m_prevVertex.y), box2d.b2Log("    shape.m_nextVertex.SetXY(%.15f, %.15f);\n", this.m_nextVertex.x, this.m_nextVertex.y), box2d.b2Log("    shape.m_hasPrevVertex = %s;\n", this.m_hasPrevVertex ? "true" : "false"), box2d.b2Log("    shape.m_hasNextVertex = %s;\n", this.m_hasNextVertex ? "true" : "false") }, goog.provide("box2d.b2ChainAndPolygonContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollideEdge"), goog.require("box2d.b2ChainShape"), goog.require("box2d.b2PolygonShape"), box2d.b2ChainAndPolygonContact = function() { goog.base(this) }, goog.inherits(box2d.b2ChainAndPolygonContact, box2d.b2Contact), box2d.b2ChainAndPolygonContact.Create = function() { return new box2d.b2ChainAndPolygonContact }, box2d.b2ChainAndPolygonContact.Destroy = function() {}, box2d.b2ChainAndPolygonContact.prototype.Reset = function(t, e, i, o) { goog.base(this, "Reset", t, e, i, o), box2d.ENABLE_ASSERTS && box2d.b2Assert(t.GetType() === box2d.b2ShapeType.e_chainShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(i.GetType() === box2d.b2ShapeType.e_polygonShape) }, box2d.b2ChainAndPolygonContact.prototype.Evaluate = function(t, e, i) { var o = this.m_fixtureA.GetShape(),
        n = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2ChainShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(n instanceof box2d.b2PolygonShape); var s = o instanceof box2d.b2ChainShape ? o : null,
        r = box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge;
    s.GetChildEdge(r, this.m_indexA), box2d.b2CollideEdgeAndPolygon(t, r, e, n instanceof box2d.b2PolygonShape ? n : null, i) }, box2d.b2ChainAndPolygonContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape, goog.provide("box2d.b2CollidePolygon"), goog.require("box2d.b2Collision"), box2d.b2FindMaxSeparation = function(t, e, i, o, n) { for (var s = e.m_count, r = o.m_count, a = e.m_normals, h = e.m_vertices, l = o.m_vertices, c = box2d.b2MulTXX(n, i, box2d.b2FindMaxSeparation.s_xf), d = 0, u = -box2d.b2_maxFloat, p = 0; s > p; ++p) { for (var m = box2d.b2MulRV(c.q, a[p], box2d.b2FindMaxSeparation.s_n), f = box2d.b2MulXV(c, h[p], box2d.b2FindMaxSeparation.s_v1), y = box2d.b2_maxFloat, b = 0; r > b; ++b) { var g = box2d.b2DotVV(m, box2d.b2SubVV(l[b], f, box2d.b2Vec2.s_t0));
            y > g && (y = g) } y > u && (u = y, d = p) } return t[0] = d, u }, box2d.b2FindMaxSeparation.s_xf = new box2d.b2Transform, box2d.b2FindMaxSeparation.s_n = new box2d.b2Vec2, box2d.b2FindMaxSeparation.s_v1 = new box2d.b2Vec2, box2d.b2FindIncidentEdge = function(t, e, i, o, n, s) { var r = e.m_count,
        a = e.m_normals,
        h = n.m_count,
        l = n.m_vertices,
        c = n.m_normals;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o >= 0 && r > o); for (var d = box2d.b2MulTRV(s.q, box2d.b2MulRV(i.q, a[o], box2d.b2Vec2.s_t0), box2d.b2FindIncidentEdge.s_normal1), u = 0, p = box2d.b2_maxFloat, m = 0; h > m; ++m) { var f = box2d.b2DotVV(d, c[m]);
        p > f && (p = f, u = m) } var y = u,
        b = (y + 1) % h,
        g = t[0];
    box2d.b2MulXV(s, l[y], g.v); var _ = g.id.cf;
    _.indexA = o, _.indexB = y, _.typeA = box2d.b2ContactFeatureType.e_face, _.typeB = box2d.b2ContactFeatureType.e_vertex; var v = t[1];
    box2d.b2MulXV(s, l[b], v.v); var x = v.id.cf;
    x.indexA = o, x.indexB = b, x.typeA = box2d.b2ContactFeatureType.e_face, x.typeB = box2d.b2ContactFeatureType.e_vertex }, box2d.b2FindIncidentEdge.s_normal1 = new box2d.b2Vec2, box2d.b2CollidePolygons = function(t, e, i, o, n) { t.pointCount = 0; var s = e.m_radius + o.m_radius,
        r = box2d.b2CollidePolygons.s_edgeA;
    r[0] = 0; var a = box2d.b2FindMaxSeparation(r, e, i, o, n); if (!(a > s)) { var h = box2d.b2CollidePolygons.s_edgeB;
        h[0] = 0; var l = box2d.b2FindMaxSeparation(h, o, n, e, i); if (!(l > s)) { var c, d, u, p, m = 0,
                f = 0;
            l > .98 * a + .001 ? (c = o, d = e, u = n, p = i, m = h[0], t.type = box2d.b2ManifoldType.e_faceB, f = 1) : (c = e, d = o, u = i, p = n, m = r[0], t.type = box2d.b2ManifoldType.e_faceA, f = 0); var y = box2d.b2CollidePolygons.s_incidentEdge;
            box2d.b2FindIncidentEdge(y, c, u, m, d, p); var b = c.m_count,
                g = c.m_vertices,
                _ = m,
                v = (m + 1) % b,
                x = g[_],
                S = g[v],
                C = box2d.b2SubVV(S, x, box2d.b2CollidePolygons.s_localTangent);
            C.Normalize(); var w = box2d.b2CrossVOne(C, box2d.b2CollidePolygons.s_localNormal),
                A = box2d.b2MidVV(x, S, box2d.b2CollidePolygons.s_planePoint),
                T = box2d.b2MulRV(u.q, C, box2d.b2CollidePolygons.s_tangent),
                P = box2d.b2CrossVOne(T, box2d.b2CollidePolygons.s_normal),
                k = box2d.b2MulXV(u, x, box2d.b2CollidePolygons.s_v11),
                M = box2d.b2MulXV(u, S, box2d.b2CollidePolygons.s_v12),
                E = box2d.b2DotVV(P, k),
                B = -box2d.b2DotVV(T, k) + s,
                I = box2d.b2DotVV(T, M) + s,
                D = box2d.b2CollidePolygons.s_clipPoints1,
                L = box2d.b2CollidePolygons.s_clipPoints2,
                O = box2d.b2NegV(T, box2d.b2CollidePolygons.s_ntangent); if (!(2 > box2d.b2ClipSegmentToLine(D, y, O, B, _) || 2 > box2d.b2ClipSegmentToLine(L, D, T, I, v))) { t.localNormal.Copy(w), t.localPoint.Copy(A); for (var R = 0, F = 0; F < box2d.b2_maxManifoldPoints; ++F) { var V = L[F]; if (s >= box2d.b2DotVV(P, V.v) - E) { var G = t.points[R]; if (box2d.b2MulTXV(p, V.v, G.localPoint), G.id.Copy(V.id), f) { var U = G.id.cf;
                            G.id.cf.indexA = U.indexB, G.id.cf.indexB = U.indexA, G.id.cf.typeA = U.typeB, G.id.cf.typeB = U.typeA }++R } } t.pointCount = R } } } }, box2d.b2CollidePolygons.s_incidentEdge = box2d.b2ClipVertex.MakeArray(2), box2d.b2CollidePolygons.s_clipPoints1 = box2d.b2ClipVertex.MakeArray(2), box2d.b2CollidePolygons.s_clipPoints2 = box2d.b2ClipVertex.MakeArray(2), box2d.b2CollidePolygons.s_edgeA = box2d.b2MakeNumberArray(1), box2d.b2CollidePolygons.s_edgeB = box2d.b2MakeNumberArray(1), box2d.b2CollidePolygons.s_localTangent = new box2d.b2Vec2, box2d.b2CollidePolygons.s_localNormal = new box2d.b2Vec2, box2d.b2CollidePolygons.s_planePoint = new box2d.b2Vec2, box2d.b2CollidePolygons.s_normal = new box2d.b2Vec2, box2d.b2CollidePolygons.s_tangent = new box2d.b2Vec2, box2d.b2CollidePolygons.s_ntangent = new box2d.b2Vec2, box2d.b2CollidePolygons.s_v11 = new box2d.b2Vec2, box2d.b2CollidePolygons.s_v12 = new box2d.b2Vec2, goog.provide("box2d.b2PolygonContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollidePolygon"), box2d.b2PolygonContact = function() { goog.base(this) }, goog.inherits(box2d.b2PolygonContact, box2d.b2Contact), box2d.b2PolygonContact.Create = function() { return new box2d.b2PolygonContact }, box2d.b2PolygonContact.Destroy = function() {}, box2d.b2PolygonContact.prototype.Reset = function(t, e, i, o) { goog.base(this, "Reset", t, e, i, o) }, box2d.b2PolygonContact.prototype.Evaluate = function(t, e, i) { var o = this.m_fixtureA.GetShape(),
        n = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2PolygonShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(n instanceof box2d.b2PolygonShape), box2d.b2CollidePolygons(t, o instanceof box2d.b2PolygonShape ? o : null, e, n instanceof box2d.b2PolygonShape ? n : null, i) }, goog.provide("box2d.b2CollideCircle"), goog.require("box2d.b2Collision"), box2d.b2CollideCircles = function(t, e, i, o, n) { t.pointCount = 0; var s = box2d.b2MulXV(i, e.m_p, box2d.b2CollideCircles.s_pA),
        r = box2d.b2MulXV(n, o.m_p, box2d.b2CollideCircles.s_pB),
        a = box2d.b2DistanceSquaredVV(s, r),
        h = e.m_radius + o.m_radius;
    a > h * h || (t.type = box2d.b2ManifoldType.e_circles, t.localPoint.Copy(e.m_p), t.localNormal.SetZero(), t.pointCount = 1, t.points[0].localPoint.Copy(o.m_p), t.points[0].id.key = 0) }, box2d.b2CollideCircles.s_pA = new box2d.b2Vec2, box2d.b2CollideCircles.s_pB = new box2d.b2Vec2, box2d.b2CollidePolygonAndCircle = function(t, e, i, o, n) { t.pointCount = 0; for (var s = box2d.b2MulXV(n, o.m_p, box2d.b2CollidePolygonAndCircle.s_c), r = box2d.b2MulTXV(i, s, box2d.b2CollidePolygonAndCircle.s_cLocal), a = 0, h = -box2d.b2_maxFloat, l = e.m_radius + o.m_radius, c = e.m_count, d = e.m_vertices, u = e.m_normals, p = 0; c > p; ++p) { var m = box2d.b2DotVV(u[p], box2d.b2SubVV(r, d[p], box2d.b2Vec2.s_t0)); if (m > l) return;
        m > h && (h = m, a = p) } var f = a,
        y = (f + 1) % c,
        b = d[f],
        g = d[y]; if (h < box2d.b2_epsilon) return t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, t.localNormal.Copy(u[a]), box2d.b2MidVV(b, g, t.localPoint), t.points[0].localPoint.Copy(o.m_p), void(t.points[0].id.key = 0); var _ = box2d.b2DotVV(box2d.b2SubVV(r, b, box2d.b2Vec2.s_t0), box2d.b2SubVV(g, b, box2d.b2Vec2.s_t1)),
        v = box2d.b2DotVV(box2d.b2SubVV(r, g, box2d.b2Vec2.s_t0), box2d.b2SubVV(b, g, box2d.b2Vec2.s_t1)); if (0 >= _) { if (box2d.b2DistanceSquaredVV(r, b) > l * l) return;
        t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, box2d.b2SubVV(r, b, t.localNormal).SelfNormalize(), t.localPoint.Copy(b), t.points[0].localPoint.Copy(o.m_p), t.points[0].id.key = 0 } else if (0 >= v) { if (box2d.b2DistanceSquaredVV(r, g) > l * l) return;
        t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, box2d.b2SubVV(r, g, t.localNormal).SelfNormalize(), t.localPoint.Copy(g), t.points[0].localPoint.Copy(o.m_p), t.points[0].id.key = 0 } else { var x = box2d.b2MidVV(b, g, box2d.b2CollidePolygonAndCircle.s_faceCenter); if ((h = box2d.b2DotVV(box2d.b2SubVV(r, x, box2d.b2Vec2.s_t1), u[f])) > l) return;
        t.pointCount = 1, t.type = box2d.b2ManifoldType.e_faceA, t.localNormal.Copy(u[f]).SelfNormalize(), t.localPoint.Copy(x), t.points[0].localPoint.Copy(o.m_p), t.points[0].id.key = 0 } }, box2d.b2CollidePolygonAndCircle.s_c = new box2d.b2Vec2, box2d.b2CollidePolygonAndCircle.s_cLocal = new box2d.b2Vec2, box2d.b2CollidePolygonAndCircle.s_faceCenter = new box2d.b2Vec2, goog.provide("box2d.b2CircleContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollideCircle"), box2d.b2CircleContact = function() { goog.base(this) }, goog.inherits(box2d.b2CircleContact, box2d.b2Contact), box2d.b2CircleContact.Create = function() { return new box2d.b2CircleContact }, box2d.b2CircleContact.Destroy = function() {}, box2d.b2CircleContact.prototype.Reset = function(t, e, i, o) { goog.base(this, "Reset", t, e, i, o) }, box2d.b2CircleContact.prototype.Evaluate = function(t, e, i) { var o = this.m_fixtureA.GetShape(),
        n = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2CircleShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(n instanceof box2d.b2CircleShape), box2d.b2CollideCircles(t, o instanceof box2d.b2CircleShape ? o : null, e, n instanceof box2d.b2CircleShape ? n : null, i) }, goog.provide("box2d.b2ChainAndCircleContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollideEdge"), box2d.b2ChainAndCircleContact = function() { goog.base(this) }, goog.inherits(box2d.b2ChainAndCircleContact, box2d.b2Contact), box2d.b2ChainAndCircleContact.Create = function() { return new box2d.b2ChainAndCircleContact }, box2d.b2ChainAndCircleContact.Destroy = function() {}, box2d.b2ChainAndCircleContact.prototype.Reset = function(t, e, i, o) { goog.base(this, "Reset", t, e, i, o), box2d.ENABLE_ASSERTS && box2d.b2Assert(t.GetType() === box2d.b2ShapeType.e_chainShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(i.GetType() === box2d.b2ShapeType.e_circleShape) }, box2d.b2ChainAndCircleContact.prototype.Evaluate = function(t, e, i) { var o = this.m_fixtureA.GetShape(),
        n = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2ChainShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(n instanceof box2d.b2CircleShape); var s = o instanceof box2d.b2ChainShape ? o : null,
        r = box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge;
    s.GetChildEdge(r, this.m_indexA), box2d.b2CollideEdgeAndCircle(t, r, e, n instanceof box2d.b2CircleShape ? n : null, i) }, box2d.b2ChainAndCircleContact.prototype.Evaluate.s_edge = new box2d.b2EdgeShape, goog.provide("box2d.b2EdgeAndCircleContact"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), goog.require("box2d.b2CollideEdge"), box2d.b2EdgeAndCircleContact = function() { goog.base(this) }, goog.inherits(box2d.b2EdgeAndCircleContact, box2d.b2Contact), box2d.b2EdgeAndCircleContact.Create = function() { return new box2d.b2EdgeAndCircleContact }, box2d.b2EdgeAndCircleContact.Destroy = function() {}, box2d.b2EdgeAndCircleContact.prototype.Reset = function(t, e, i, o) { goog.base(this, "Reset", t, e, i, o), box2d.ENABLE_ASSERTS && box2d.b2Assert(t.GetType() === box2d.b2ShapeType.e_edgeShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(i.GetType() === box2d.b2ShapeType.e_circleShape) }, box2d.b2EdgeAndCircleContact.prototype.Evaluate = function(t, e, i) { var o = this.m_fixtureA.GetShape(),
        n = this.m_fixtureB.GetShape();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2EdgeShape), box2d.ENABLE_ASSERTS && box2d.b2Assert(n instanceof box2d.b2CircleShape), box2d.b2CollideEdgeAndCircle(t, o instanceof box2d.b2EdgeShape ? o : null, e, n instanceof box2d.b2CircleShape ? n : null, i) }, goog.provide("box2d.b2ContactSolver"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Collision"), goog.require("box2d.b2CircleContact"), goog.require("box2d.b2PolygonAndCircleContact"), goog.require("box2d.b2PolygonContact"), goog.require("box2d.b2EdgeAndCircleContact"), goog.require("box2d.b2EdgeAndPolygonContact"), goog.require("box2d.b2ChainAndCircleContact"), goog.require("box2d.b2ChainAndPolygonContact"), box2d.b2VelocityConstraintPoint = function() { this.rA = new box2d.b2Vec2, this.rB = new box2d.b2Vec2 }, box2d.b2VelocityConstraintPoint.prototype.rA = null, box2d.b2VelocityConstraintPoint.prototype.rB = null, box2d.b2VelocityConstraintPoint.prototype.normalImpulse = 0, box2d.b2VelocityConstraintPoint.prototype.tangentImpulse = 0, box2d.b2VelocityConstraintPoint.prototype.normalMass = 0, box2d.b2VelocityConstraintPoint.prototype.tangentMass = 0, box2d.b2VelocityConstraintPoint.prototype.velocityBias = 0, box2d.b2VelocityConstraintPoint.MakeArray = function(t) { return box2d.b2MakeArray(t, function() { return new box2d.b2VelocityConstraintPoint }) }, box2d.b2ContactVelocityConstraint = function() { this.points = box2d.b2VelocityConstraintPoint.MakeArray(box2d.b2_maxManifoldPoints), this.normal = new box2d.b2Vec2, this.tangent = new box2d.b2Vec2, this.normalMass = new box2d.b2Mat22, this.K = new box2d.b2Mat22 }, box2d.b2ContactVelocityConstraint.prototype.points = null, box2d.b2ContactVelocityConstraint.prototype.normal = null, box2d.b2ContactVelocityConstraint.prototype.tangent = null, box2d.b2ContactVelocityConstraint.prototype.normalMass = null, box2d.b2ContactVelocityConstraint.prototype.K = null, box2d.b2ContactVelocityConstraint.prototype.indexA = 0, box2d.b2ContactVelocityConstraint.prototype.indexB = 0, box2d.b2ContactVelocityConstraint.prototype.invMassA = 0, box2d.b2ContactVelocityConstraint.prototype.invMassB = 0, box2d.b2ContactVelocityConstraint.prototype.invIA = 0, box2d.b2ContactVelocityConstraint.prototype.invIB = 0, box2d.b2ContactVelocityConstraint.prototype.friction = 0, box2d.b2ContactVelocityConstraint.prototype.restitution = 0, box2d.b2ContactVelocityConstraint.prototype.tangentSpeed = 0, box2d.b2ContactVelocityConstraint.prototype.pointCount = 0, box2d.b2ContactVelocityConstraint.prototype.contactIndex = 0, box2d.b2ContactVelocityConstraint.MakeArray = function(t) { return box2d.b2MakeArray(t, function() { return new box2d.b2ContactVelocityConstraint }) }, box2d.b2ContactPositionConstraint = function() { this.localPoints = box2d.b2Vec2.MakeArray(box2d.b2_maxManifoldPoints), this.localNormal = new box2d.b2Vec2, this.localPoint = new box2d.b2Vec2, this.localCenterA = new box2d.b2Vec2, this.localCenterB = new box2d.b2Vec2 }, box2d.b2ContactPositionConstraint.prototype.localPoints = null, box2d.b2ContactPositionConstraint.prototype.localNormal = null, box2d.b2ContactPositionConstraint.prototype.localPoint = null, box2d.b2ContactPositionConstraint.prototype.indexA = 0, box2d.b2ContactPositionConstraint.prototype.indexB = 0, box2d.b2ContactPositionConstraint.prototype.invMassA = 0, box2d.b2ContactPositionConstraint.prototype.invMassB = 0, box2d.b2ContactPositionConstraint.prototype.localCenterA = null, box2d.b2ContactPositionConstraint.prototype.localCenterB = null, box2d.b2ContactPositionConstraint.prototype.invIA = 0, box2d.b2ContactPositionConstraint.prototype.invIB = 0, box2d.b2ContactPositionConstraint.prototype.type = box2d.b2ManifoldType.e_unknown, box2d.b2ContactPositionConstraint.prototype.radiusA = 0, box2d.b2ContactPositionConstraint.prototype.radiusB = 0, box2d.b2ContactPositionConstraint.prototype.pointCount = 0, box2d.b2ContactPositionConstraint.MakeArray = function(t) { return box2d.b2MakeArray(t, function() { return new box2d.b2ContactPositionConstraint }) }, box2d.b2ContactSolverDef = function() { this.step = new box2d.b2TimeStep }, box2d.b2ContactSolverDef.prototype.step = null, box2d.b2ContactSolverDef.prototype.contacts = null, box2d.b2ContactSolverDef.prototype.count = 0, box2d.b2ContactSolverDef.prototype.positions = null, box2d.b2ContactSolverDef.prototype.velocities = null, box2d.b2ContactSolverDef.prototype.allocator = null, box2d.b2ContactSolver = function() { this.m_step = new box2d.b2TimeStep, this.m_positionConstraints = box2d.b2ContactPositionConstraint.MakeArray(1024), this.m_velocityConstraints = box2d.b2ContactVelocityConstraint.MakeArray(1024) }, box2d.b2ContactSolver.prototype.m_step = null, box2d.b2ContactSolver.prototype.m_positions = null, box2d.b2ContactSolver.prototype.m_velocities = null, box2d.b2ContactSolver.prototype.m_allocator = null, box2d.b2ContactSolver.prototype.m_positionConstraints = null, box2d.b2ContactSolver.prototype.m_velocityConstraints = null, box2d.b2ContactSolver.prototype.m_contacts = null, box2d.b2ContactSolver.prototype.m_count = 0, box2d.b2ContactSolver.prototype.Initialize = function(t) { if (this.m_step.Copy(t.step), this.m_allocator = t.allocator, this.m_count = t.count, this.m_positionConstraints.length < this.m_count) { e = box2d.b2Max(2 * this.m_positionConstraints.length, this.m_count); for (box2d.DEBUG && window.console.log("box2d.b2ContactSolver.m_positionConstraints: " + e); this.m_positionConstraints.length < e;) this.m_positionConstraints[this.m_positionConstraints.length] = new box2d.b2ContactPositionConstraint } if (this.m_velocityConstraints.length < this.m_count) { var e = box2d.b2Max(2 * this.m_velocityConstraints.length, this.m_count); for (box2d.DEBUG && window.console.log("box2d.b2ContactSolver.m_velocityConstraints: " + e); this.m_velocityConstraints.length < e;) this.m_velocityConstraints[this.m_velocityConstraints.length] = new box2d.b2ContactVelocityConstraint } this.m_positions = t.positions, this.m_velocities = t.velocities, this.m_contacts = t.contacts; var i, o, n, s, r, a, h, l, c, d, u, p, m, f, y, b, g, _, v; for (i = 0, o = this.m_count; o > i; ++i)
        for (r = this.m_contacts[i], a = r.m_fixtureA, h = r.m_fixtureB, l = a.GetShape(), c = h.GetShape(), d = l.m_radius, u = c.m_radius, p = a.GetBody(), m = h.GetBody(), f = r.GetManifold(), y = f.pointCount, box2d.ENABLE_ASSERTS && box2d.b2Assert(y > 0), b = this.m_velocityConstraints[i], b.friction = r.m_friction, b.restitution = r.m_restitution, b.tangentSpeed = r.m_tangentSpeed, b.indexA = p.m_islandIndex, b.indexB = m.m_islandIndex, b.invMassA = p.m_invMass, b.invMassB = m.m_invMass, b.invIA = p.m_invI, b.invIB = m.m_invI, b.contactIndex = i, b.pointCount = y, b.K.SetZero(), b.normalMass.SetZero(), g = this.m_positionConstraints[i], g.indexA = p.m_islandIndex, g.indexB = m.m_islandIndex, g.invMassA = p.m_invMass, g.invMassB = m.m_invMass, g.localCenterA.Copy(p.m_sweep.localCenter), g.localCenterB.Copy(m.m_sweep.localCenter), g.invIA = p.m_invI, g.invIB = m.m_invI, g.localNormal.Copy(f.localNormal), g.localPoint.Copy(f.localPoint), g.pointCount = y, g.radiusA = d, g.radiusB = u, g.type = f.type, n = 0, s = y; s > n; ++n) _ = f.points[n], v = b.points[n], this.m_step.warmStarting ? (v.normalImpulse = this.m_step.dtRatio * _.normalImpulse, v.tangentImpulse = this.m_step.dtRatio * _.tangentImpulse) : (v.normalImpulse = 0, v.tangentImpulse = 0), v.rA.SetZero(), v.rB.SetZero(), v.normalMass = 0, v.tangentMass = 0, v.velocityBias = 0, g.localPoints[n].Copy(_.localPoint); return this }, box2d.b2ContactSolver.prototype.InitializeVelocityConstraints = function() { var t, e, i, o, n, s, r, a, h, l, c, d, u, p, m, f, y, b, g, _, v, x, S, C, w, A, T, P, k, M, E, B, I, D, L, O, R, F, V, G, U, N, j, W = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA,
        X = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB,
        H = box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold; for (t = 0, e = this.m_count; e > t; ++t) { for (n = this.m_velocityConstraints[t], r = (s = this.m_positionConstraints[t]).radiusA, a = s.radiusB, h = this.m_contacts[n.contactIndex].GetManifold(), l = n.indexA, c = n.indexB, d = n.invMassA, u = n.invMassB, p = n.invIA, m = n.invIB, f = s.localCenterA, y = s.localCenterB, b = this.m_positions[l].c, g = this.m_positions[l].a, _ = this.m_velocities[l].v, v = this.m_velocities[l].w, x = this.m_positions[c].c, S = this.m_positions[c].a, C = this.m_velocities[c].v, w = this.m_velocities[c].w, box2d.ENABLE_ASSERTS && box2d.b2Assert(h.pointCount > 0), W.q.SetAngleRadians(g), X.q.SetAngleRadians(S), box2d.b2SubVV(b, box2d.b2MulRV(W.q, f, box2d.b2Vec2.s_t0), W.p), box2d.b2SubVV(x, box2d.b2MulRV(X.q, y, box2d.b2Vec2.s_t0), X.p), H.Initialize(h, W, r, X, a), n.normal.Copy(H.normal), box2d.b2CrossVOne(n.normal, n.tangent), i = 0, o = n.pointCount; o > i; ++i) A = n.points[i], box2d.b2SubVV(H.points[i], b, A.rA), box2d.b2SubVV(H.points[i], x, A.rB), T = box2d.b2CrossVV(A.rA, n.normal), P = box2d.b2CrossVV(A.rB, n.normal), k = d + u + p * T * T + m * P * P, A.normalMass = k > 0 ? 1 / k : 0, M = n.tangent, E = box2d.b2CrossVV(A.rA, M), B = box2d.b2CrossVV(A.rB, M), I = d + u + p * E * E + m * B * B, A.tangentMass = I > 0 ? 1 / I : 0, A.velocityBias = 0, (D = box2d.b2DotVV(n.normal, box2d.b2SubVV(box2d.b2AddVCrossSV(C, w, A.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(_, v, A.rA, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t0))) < -box2d.b2_velocityThreshold && (A.velocityBias += -n.restitution * D);
        2 === n.pointCount && (L = n.points[0], O = n.points[1], R = box2d.b2CrossVV(L.rA, n.normal), F = box2d.b2CrossVV(L.rB, n.normal), V = box2d.b2CrossVV(O.rA, n.normal), G = box2d.b2CrossVV(O.rB, n.normal), U = d + u + p * R * R + m * F * F, N = d + u + p * V * V + m * G * G, j = d + u + p * R * V + m * F * G, 1e3 * (U * N - j * j) > U * U ? (n.K.ex.SetXY(U, j), n.K.ey.SetXY(j, N), n.K.GetInverse(n.normalMass)) : n.pointCount = 1) } }, box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfA = new box2d.b2Transform, box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_xfB = new box2d.b2Transform, box2d.b2ContactSolver.prototype.InitializeVelocityConstraints.s_worldManifold = new box2d.b2WorldManifold, box2d.b2ContactSolver.prototype.WarmStart = function() { var t, e, i, o, n, s, r, a, h, l, c, d, u, p, m, f, y, b, g, _ = box2d.b2ContactSolver.prototype.WarmStart.s_P; for (t = 0, e = this.m_count; e > t; ++t) { for (s = (n = this.m_velocityConstraints[t]).indexA, r = n.indexB, a = n.invMassA, h = n.invIA, l = n.invMassB, c = n.invIB, d = n.pointCount, u = this.m_velocities[s].v, p = this.m_velocities[s].w, m = this.m_velocities[r].v, f = this.m_velocities[r].w, y = n.normal, b = n.tangent, i = 0, o = d; o > i; ++i) g = n.points[i], box2d.b2AddVV(box2d.b2MulSV(g.normalImpulse, y, box2d.b2Vec2.s_t0), box2d.b2MulSV(g.tangentImpulse, b, box2d.b2Vec2.s_t1), _), p -= h * box2d.b2CrossVV(g.rA, _), u.SelfMulSub(a, _), f += c * box2d.b2CrossVV(g.rB, _), m.SelfMulAdd(l, _);
        this.m_velocities[s].w = p, this.m_velocities[r].w = f } }, box2d.b2ContactSolver.prototype.WarmStart.s_P = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints = function() { var t, e, i, o, n, s, r, a, h, l, c, d, u, p, m, f, y, b, g, _, v, x, S, C, w, A, T, P, k, M = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv,
        E = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1,
        B = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2,
        I = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P,
        D = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a,
        L = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b,
        O = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x,
        R = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d,
        F = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1,
        V = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2,
        G = box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2; for (t = 0, e = this.m_count; e > t; ++t) { for (s = (n = this.m_velocityConstraints[t]).indexA, r = n.indexB, a = n.invMassA, h = n.invIA, l = n.invMassB, c = n.invIB, d = n.pointCount, u = this.m_velocities[s].v, p = this.m_velocities[s].w, m = this.m_velocities[r].v, f = this.m_velocities[r].w, y = n.normal, b = n.tangent, g = n.friction, box2d.ENABLE_ASSERTS && box2d.b2Assert(1 === d || 2 === d), i = 0, o = d; o > i; ++i) _ = n.points[i], box2d.b2SubVV(box2d.b2AddVCrossSV(m, f, _.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(u, p, _.rA, box2d.b2Vec2.s_t1), M), v = box2d.b2DotVV(M, b) - n.tangentSpeed, S = _.tangentMass * -v, C = g * _.normalImpulse, w = box2d.b2Clamp(_.tangentImpulse + S, -C, C), S = w - _.tangentImpulse, _.tangentImpulse = w, box2d.b2MulSV(S, b, I), u.SelfMulSub(a, I), p -= h * box2d.b2CrossVV(_.rA, I), m.SelfMulAdd(l, I), f += c * box2d.b2CrossVV(_.rB, I); if (1 === n.pointCount) _ = n.points[0], box2d.b2SubVV(box2d.b2AddVCrossSV(m, f, _.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(u, p, _.rA, box2d.b2Vec2.s_t1), M), x = box2d.b2DotVV(M, y), S = -_.normalMass * (x - _.velocityBias), w = box2d.b2Max(_.normalImpulse + S, 0), S = w - _.normalImpulse, _.normalImpulse = w, box2d.b2MulSV(S, y, I), u.SelfMulSub(a, I), p -= h * box2d.b2CrossVV(_.rA, I), m.SelfMulAdd(l, I), f += c * box2d.b2CrossVV(_.rB, I);
        else
            for (A = n.points[0], T = n.points[1], D.SetXY(A.normalImpulse, T.normalImpulse), box2d.ENABLE_ASSERTS && box2d.b2Assert(D.x >= 0 && D.y >= 0), box2d.b2SubVV(box2d.b2AddVCrossSV(m, f, A.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(u, p, A.rA, box2d.b2Vec2.s_t1), E), box2d.b2SubVV(box2d.b2AddVCrossSV(m, f, T.rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(u, p, T.rA, box2d.b2Vec2.s_t1), B), P = box2d.b2DotVV(E, y), k = box2d.b2DotVV(B, y), L.x = P - A.velocityBias, L.y = k - T.velocityBias, L.SelfSub(box2d.b2MulMV(n.K, D, box2d.b2Vec2.s_t0));;) { if (box2d.b2MulMV(n.normalMass, L, O).SelfNeg(), O.x >= 0 && O.y >= 0) { box2d.b2SubVV(O, D, R), box2d.b2MulSV(R.x, y, F), box2d.b2MulSV(R.y, y, V), box2d.b2AddVV(F, V, G), u.SelfMulSub(a, G), p -= h * (box2d.b2CrossVV(A.rA, F) + box2d.b2CrossVV(T.rA, V)), m.SelfMulAdd(l, G), f += c * (box2d.b2CrossVV(A.rB, F) + box2d.b2CrossVV(T.rB, V)), A.normalImpulse = O.x, T.normalImpulse = O.y; break } if (O.x = -A.normalMass * L.x, O.y = 0, P = 0, k = n.K.ex.y * O.x + L.y, O.x >= 0 && k >= 0) { box2d.b2SubVV(O, D, R), box2d.b2MulSV(R.x, y, F), box2d.b2MulSV(R.y, y, V), box2d.b2AddVV(F, V, G), u.SelfMulSub(a, G), p -= h * (box2d.b2CrossVV(A.rA, F) + box2d.b2CrossVV(T.rA, V)), m.SelfMulAdd(l, G), f += c * (box2d.b2CrossVV(A.rB, F) + box2d.b2CrossVV(T.rB, V)), A.normalImpulse = O.x, T.normalImpulse = O.y; break } if (O.x = 0, O.y = -T.normalMass * L.y, P = n.K.ey.x * O.y + L.x, k = 0, O.y >= 0 && P >= 0) { box2d.b2SubVV(O, D, R), box2d.b2MulSV(R.x, y, F), box2d.b2MulSV(R.y, y, V), box2d.b2AddVV(F, V, G), u.SelfMulSub(a, G), p -= h * (box2d.b2CrossVV(A.rA, F) + box2d.b2CrossVV(T.rA, V)), m.SelfMulAdd(l, G), f += c * (box2d.b2CrossVV(A.rB, F) + box2d.b2CrossVV(T.rB, V)), A.normalImpulse = O.x, T.normalImpulse = O.y; break } if (O.x = 0, O.y = 0, P = L.x, k = L.y, P >= 0 && k >= 0) { box2d.b2SubVV(O, D, R), box2d.b2MulSV(R.x, y, F), box2d.b2MulSV(R.y, y, V), box2d.b2AddVV(F, V, G), u.SelfMulSub(a, G), p -= h * (box2d.b2CrossVV(A.rA, F) + box2d.b2CrossVV(T.rA, V)), m.SelfMulAdd(l, G), f += c * (box2d.b2CrossVV(A.rB, F) + box2d.b2CrossVV(T.rB, V)), A.normalImpulse = O.x, T.normalImpulse = O.y; break } break } this.m_velocities[s].w = p, this.m_velocities[r].w = f } }, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv1 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_dv2 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_a = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_b = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_x = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_d = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P2 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveVelocityConstraints.s_P1P2 = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.StoreImpulses = function() { var t, e, i, o, n, s; for (t = 0, e = this.m_count; e > t; ++t)
        for (n = this.m_velocityConstraints[t], s = this.m_contacts[n.contactIndex].GetManifold(), i = 0, o = n.pointCount; o > i; ++i) s.points[i].normalImpulse = n.points[i].normalImpulse, s.points[i].tangentImpulse = n.points[i].tangentImpulse }, box2d.b2PositionSolverManifold = function() { this.normal = new box2d.b2Vec2, this.point = new box2d.b2Vec2 }, box2d.b2PositionSolverManifold.prototype.normal = null, box2d.b2PositionSolverManifold.prototype.point = null, box2d.b2PositionSolverManifold.prototype.separation = 0, box2d.b2PositionSolverManifold.prototype.Initialize = function(t, e, i, o) { var n = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA,
        s = box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB,
        r = box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint,
        a = box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint; switch (box2d.ENABLE_ASSERTS && box2d.b2Assert(t.pointCount > 0), t.type) {
        case box2d.b2ManifoldType.e_circles:
            box2d.b2MulXV(e, t.localPoint, n), box2d.b2MulXV(i, t.localPoints[0], s), box2d.b2SubVV(s, n, this.normal).SelfNormalize(), box2d.b2MidVV(n, s, this.point), this.separation = box2d.b2DotVV(box2d.b2SubVV(s, n, box2d.b2Vec2.s_t0), this.normal) - t.radiusA - t.radiusB; break;
        case box2d.b2ManifoldType.e_faceA:
            box2d.b2MulRV(e.q, t.localNormal, this.normal), box2d.b2MulXV(e, t.localPoint, r), box2d.b2MulXV(i, t.localPoints[o], a), this.separation = box2d.b2DotVV(box2d.b2SubVV(a, r, box2d.b2Vec2.s_t0), this.normal) - t.radiusA - t.radiusB, this.point.Copy(a); break;
        case box2d.b2ManifoldType.e_faceB:
            box2d.b2MulRV(i.q, t.localNormal, this.normal), box2d.b2MulXV(i, t.localPoint, r), box2d.b2MulXV(e, t.localPoints[o], a), this.separation = box2d.b2DotVV(box2d.b2SubVV(a, r, box2d.b2Vec2.s_t0), this.normal) - t.radiusA - t.radiusB, this.point.Copy(a), this.normal.SelfNeg() } }, box2d.b2PositionSolverManifold.prototype.Initialize.s_pointA = new box2d.b2Vec2, box2d.b2PositionSolverManifold.prototype.Initialize.s_pointB = new box2d.b2Vec2, box2d.b2PositionSolverManifold.prototype.Initialize.s_planePoint = new box2d.b2Vec2, box2d.b2PositionSolverManifold.prototype.Initialize.s_clipPoint = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolvePositionConstraints = function() { var t, e, i, o, n, s, r, a, h, l, c, d, u, p, m, f, y, b, g, _, v, x, S, C, w, A, T = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA,
        P = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB,
        k = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm,
        M = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA,
        E = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB,
        B = box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P,
        I = 0; for (t = 0, e = this.m_count; e > t; ++t) { for (s = (n = this.m_positionConstraints[t]).indexA, r = n.indexB, a = n.localCenterA, h = n.invMassA, l = n.invIA, c = n.localCenterB, d = n.invMassB, u = n.invIB, p = n.pointCount, m = this.m_positions[s].c, f = this.m_positions[s].a, y = this.m_positions[r].c, b = this.m_positions[r].a, i = 0, o = p; o > i; ++i) T.q.SetAngleRadians(f), P.q.SetAngleRadians(b), box2d.b2SubVV(m, box2d.b2MulRV(T.q, a, box2d.b2Vec2.s_t0), T.p), box2d.b2SubVV(y, box2d.b2MulRV(P.q, c, box2d.b2Vec2.s_t0), P.p), k.Initialize(n, T, P, i), g = k.normal, _ = k.point, v = k.separation, box2d.b2SubVV(_, m, M), box2d.b2SubVV(_, y, E), I = box2d.b2Min(I, v), x = box2d.b2Clamp(box2d.b2_baumgarte * (v + box2d.b2_linearSlop), -box2d.b2_maxLinearCorrection, 0), S = box2d.b2CrossVV(M, g), C = box2d.b2CrossVV(E, g), w = h + d + l * S * S + u * C * C, A = w > 0 ? -x / w : 0, box2d.b2MulSV(A, g, B), m.SelfMulSub(h, B), f -= l * box2d.b2CrossVV(M, B), y.SelfMulAdd(d, B), b += u * box2d.b2CrossVV(E, B);
        this.m_positions[s].a = f, this.m_positions[r].a = b } return I > -3 * box2d.b2_linearSlop }, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfA = new box2d.b2Transform, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_xfB = new box2d.b2Transform, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_psm = new box2d.b2PositionSolverManifold, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rA = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_rB = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints = function(t, e) { var i, o, n, s, r, a, h, l, c, d, u, p, m, f, y, b, g, _, v, x, S, C, w, A, T, P, k = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA,
        M = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB,
        E = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm,
        B = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA,
        I = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB,
        D = box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P,
        L = 0; for (i = 0, o = this.m_count; o > i; ++i) { for (a = (r = this.m_positionConstraints[i]).indexA, h = r.indexB, l = r.localCenterA, c = r.localCenterB, d = r.pointCount, u = 0, p = 0, (a === t || a === e) && (u = r.invMassA, p = r.invIA), m = 0, f = 0, (h === t || h === e) && (m = r.invMassB, f = r.invIB), y = this.m_positions[a].c, b = this.m_positions[a].a, g = this.m_positions[h].c, _ = this.m_positions[h].a, n = 0, s = d; s > n; ++n) k.q.SetAngleRadians(b), M.q.SetAngleRadians(_), box2d.b2SubVV(y, box2d.b2MulRV(k.q, l, box2d.b2Vec2.s_t0), k.p), box2d.b2SubVV(g, box2d.b2MulRV(M.q, c, box2d.b2Vec2.s_t0), M.p), E.Initialize(r, k, M, n), v = E.normal, x = E.point, S = E.separation, box2d.b2SubVV(x, y, B), box2d.b2SubVV(x, g, I), L = box2d.b2Min(L, S), C = box2d.b2Clamp(box2d.b2_toiBaumgarte * (S + box2d.b2_linearSlop), -box2d.b2_maxLinearCorrection, 0), w = box2d.b2CrossVV(B, v), A = box2d.b2CrossVV(I, v), T = u + m + p * w * w + f * A * A, P = T > 0 ? -C / T : 0, box2d.b2MulSV(P, v, D), y.SelfMulSub(u, D), b -= p * box2d.b2CrossVV(B, D), g.SelfMulAdd(m, D), _ += f * box2d.b2CrossVV(I, D);
        this.m_positions[a].a = b, this.m_positions[h].a = _ } return L >= -1.5 * box2d.b2_linearSlop }, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfA = new box2d.b2Transform, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_xfB = new box2d.b2Transform, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_psm = new box2d.b2PositionSolverManifold, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rA = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_rB = new box2d.b2Vec2, box2d.b2ContactSolver.prototype.SolveTOIPositionConstraints.s_P = new box2d.b2Vec2, goog.provide("box2d.b2WorldCallbacks"), goog.require("box2d.b2Settings"), box2d.b2DestructionListener = function() {}, box2d.b2DestructionListener.prototype.SayGoodbyeJoint = function() {}, box2d.b2DestructionListener.prototype.SayGoodbyeFixture = function() {}, box2d.b2ContactFilter = function() {}, box2d.b2ContactFilter.prototype.ShouldCollide = function(t, e) { var i = t.GetFilterData(),
        o = e.GetFilterData(); return i.groupIndex === o.groupIndex && 0 !== i.groupIndex ? i.groupIndex > 0 : 0 != (i.maskBits & o.categoryBits) && 0 != (i.categoryBits & o.maskBits) }, box2d.b2ContactFilter.b2_defaultFilter = new box2d.b2ContactFilter, box2d.b2ContactImpulse = function() { this.normalImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints), this.tangentImpulses = box2d.b2MakeNumberArray(box2d.b2_maxManifoldPoints) }, box2d.b2ContactImpulse.prototype.normalImpulses = null, box2d.b2ContactImpulse.prototype.tangentImpulses = null, box2d.b2ContactImpulse.prototype.count = 0, box2d.b2ContactListener = function() {}, box2d.b2ContactListener.prototype.BeginContact = function() {}, box2d.b2ContactListener.prototype.EndContact = function() {}, box2d.b2ContactListener.prototype.PreSolve = function() {}, box2d.b2ContactListener.prototype.PostSolve = function() {}, box2d.b2ContactListener.b2_defaultListener = new box2d.b2ContactListener, box2d.b2QueryCallback = function() {}, box2d.b2QueryCallback.prototype.ReportFixture = function() { return !0 }, box2d.b2RayCastCallback = function() {}, box2d.b2RayCastCallback.prototype.ReportFixture = function(t, e, i, o) { return o }, goog.provide("box2d.b2Island"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Timer"), goog.require("box2d.b2TimeStep"), goog.require("box2d.b2WorldCallbacks"), goog.require("box2d.b2ContactSolver"), box2d.b2Island = function() { this.m_bodies = new Array(1024), this.m_contacts = new Array(1024), this.m_joints = new Array(1024), this.m_positions = box2d.b2Position.MakeArray(1024), this.m_velocities = box2d.b2Velocity.MakeArray(1024) }, box2d.b2Island.prototype.m_allocator = null, box2d.b2Island.prototype.m_listener = null, box2d.b2Island.prototype.m_bodies = null, box2d.b2Island.prototype.m_contacts = null, box2d.b2Island.prototype.m_joints = null, box2d.b2Island.prototype.m_positions = null, box2d.b2Island.prototype.m_velocities = null, box2d.b2Island.prototype.m_bodyCount = 0, box2d.b2Island.prototype.m_jointCount = 0, box2d.b2Island.prototype.m_contactCount = 0, box2d.b2Island.prototype.m_bodyCapacity = 0, box2d.b2Island.prototype.m_contactCapacity = 0, box2d.b2Island.prototype.m_jointCapacity = 0, box2d.b2Island.prototype.Initialize = function(t, e, i, o, n) { for (this.m_bodyCapacity = t, this.m_contactCapacity = e, this.m_jointCapacity = i, this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0, this.m_allocator = o, this.m_listener = n; this.m_bodies.length < t;) this.m_bodies[this.m_bodies.length] = null; for (; this.m_contacts.length < e;) this.m_contacts[this.m_contacts.length] = null; for (; this.m_joints.length < i;) this.m_joints[this.m_joints.length] = null; if (this.m_positions.length < t) { s = box2d.b2Max(2 * this.m_positions.length, t); for (box2d.DEBUG && window.console.log("box2d.b2Island.m_positions: " + s); this.m_positions.length < s;) this.m_positions[this.m_positions.length] = new box2d.b2Position } if (this.m_velocities.length < t) { var s = box2d.b2Max(2 * this.m_velocities.length, t); for (box2d.DEBUG && window.console.log("box2d.b2Island.m_velocities: " + s); this.m_velocities.length < s;) this.m_velocities[this.m_velocities.length] = new box2d.b2Velocity } }, box2d.b2Island.prototype.Clear = function() { this.m_bodyCount = 0, this.m_contactCount = 0, this.m_jointCount = 0 }, box2d.b2Island.prototype.AddBody = function(t) { box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_bodyCount < this.m_bodyCapacity), t.m_islandIndex = this.m_bodyCount, this.m_bodies[this.m_bodyCount++] = t }, box2d.b2Island.prototype.AddContact = function(t) { box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_contactCount < this.m_contactCapacity), this.m_contacts[this.m_contactCount++] = t }, box2d.b2Island.prototype.AddJoint = function(t) { box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_jointCount < this.m_jointCapacity), this.m_joints[this.m_jointCount++] = t }, box2d.b2Island.prototype.Solve = function(t, e, i, o) { for (var n = box2d.b2Island.s_timer.Reset(), s = e.dt, r = 0; r < this.m_bodyCount; ++r) { var a = this.m_bodies[r],
            h = this.m_positions[r].c.Copy(a.m_sweep.c),
            l = a.m_sweep.a,
            c = this.m_velocities[r].v.Copy(a.m_linearVelocity),
            d = a.m_angularVelocity;
        a.m_sweep.c0.Copy(a.m_sweep.c), a.m_sweep.a0 = a.m_sweep.a, a.m_type === box2d.b2BodyType.b2_dynamicBody && (c.x += s * (a.m_gravityScale * i.x + a.m_invMass * a.m_force.x), c.y += s * (a.m_gravityScale * i.y + a.m_invMass * a.m_force.y), d += s * a.m_invI * a.m_torque, c.SelfMul(1 / (1 + s * a.m_linearDamping)), d *= 1 / (1 + s * a.m_angularDamping)), this.m_positions[r].a = l, this.m_velocities[r].w = d } n.Reset(); var u = box2d.b2Island.s_solverData;
    u.step.Copy(e), u.positions = this.m_positions, u.velocities = this.m_velocities; var p = box2d.b2Island.s_contactSolverDef;
    p.step.Copy(e), p.contacts = this.m_contacts, p.count = this.m_contactCount, p.positions = this.m_positions, p.velocities = this.m_velocities, p.allocator = this.m_allocator; var m = box2d.b2Island.s_contactSolver.Initialize(p);
    m.InitializeVelocityConstraints(), e.warmStarting && m.WarmStart(); for (r = 0; r < this.m_jointCount; ++r) this.m_joints[r].InitVelocityConstraints(u);
    t.solveInit = n.GetMilliseconds(), n.Reset(); for (r = 0; r < e.velocityIterations; ++r) { for (x = 0; x < this.m_jointCount; ++x) this.m_joints[x].SolveVelocityConstraints(u);
        m.SolveVelocityConstraints() } m.StoreImpulses(), t.solveVelocity = n.GetMilliseconds(); for (r = 0; r < this.m_bodyCount; ++r) { var h = this.m_positions[r].c,
            l = this.m_positions[r].a,
            c = this.m_velocities[r].v,
            d = this.m_velocities[r].w,
            f = box2d.b2MulSV(s, c, box2d.b2Island.s_translation); if (box2d.b2DotVV(f, f) > box2d.b2_maxTranslationSquared) { var y = box2d.b2_maxTranslation / f.GetLength();
            c.SelfMul(y) } var b = s * d;
        b * b > box2d.b2_maxRotationSquared && (d *= y = box2d.b2_maxRotation / box2d.b2Abs(b)), h.x += s * c.x, h.y += s * c.y, l += s * d, this.m_positions[r].a = l, this.m_velocities[r].w = d } n.Reset(); for (var g = !1, r = 0; r < e.positionIterations; ++r) { for (var _ = m.SolvePositionConstraints(), v = !0, x = 0; x < this.m_jointCount; ++x) { var S = this.m_joints[x].SolvePositionConstraints(u);
            v = v && S } if (_ && v) { g = !0; break } } for (r = 0; r < this.m_bodyCount; ++r) { var C = this.m_bodies[r];
        C.m_sweep.c.Copy(this.m_positions[r].c), C.m_sweep.a = this.m_positions[r].a, C.m_linearVelocity.Copy(this.m_velocities[r].v), C.m_angularVelocity = this.m_velocities[r].w, C.SynchronizeTransform() } if (t.solvePosition = n.GetMilliseconds(), this.Report(m.m_velocityConstraints), o) { for (var w = box2d.b2_maxFloat, A = box2d.b2_linearSleepTolerance * box2d.b2_linearSleepTolerance, T = box2d.b2_angularSleepTolerance * box2d.b2_angularSleepTolerance, r = 0; r < this.m_bodyCount; ++r)(a = this.m_bodies[r]).GetType() !== box2d.b2BodyType.b2_staticBody && (0 == (a.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) || a.m_angularVelocity * a.m_angularVelocity > T || box2d.b2DotVV(a.m_linearVelocity, a.m_linearVelocity) > A ? (a.m_sleepTime = 0, w = 0) : (a.m_sleepTime += s, w = box2d.b2Min(w, a.m_sleepTime))); if (w >= box2d.b2_timeToSleep && g)
            for (r = 0; r < this.m_bodyCount; ++r)(a = this.m_bodies[r]).SetAwake(!1) } }, box2d.b2Island.prototype.SolveTOI = function(t, e, i) { box2d.ENABLE_ASSERTS && box2d.b2Assert(e < this.m_bodyCount), box2d.ENABLE_ASSERTS && box2d.b2Assert(i < this.m_bodyCount); for (r = 0; r < this.m_bodyCount; ++r) { var o = this.m_bodies[r];
        this.m_positions[r].c.Copy(o.m_sweep.c), this.m_positions[r].a = o.m_sweep.a, this.m_velocities[r].v.Copy(o.m_linearVelocity), this.m_velocities[r].w = o.m_angularVelocity } var n = box2d.b2Island.s_contactSolverDef;
    n.contacts = this.m_contacts, n.count = this.m_contactCount, n.allocator = this.m_allocator, n.step.Copy(t), n.positions = this.m_positions, n.velocities = this.m_velocities; for (var s = box2d.b2Island.s_contactSolver.Initialize(n), r = 0; r < t.positionIterations && !s.SolveTOIPositionConstraints(e, i); ++r);
    this.m_bodies[e].m_sweep.c0.Copy(this.m_positions[e].c), this.m_bodies[e].m_sweep.a0 = this.m_positions[e].a, this.m_bodies[i].m_sweep.c0.Copy(this.m_positions[i].c), this.m_bodies[i].m_sweep.a0 = this.m_positions[i].a, s.InitializeVelocityConstraints(); for (r = 0; r < t.velocityIterations; ++r) s.SolveVelocityConstraints(); for (var a = t.dt, r = 0; r < this.m_bodyCount; ++r) { var h = this.m_positions[r].c,
            l = this.m_positions[r].a,
            c = this.m_velocities[r].v,
            d = this.m_velocities[r].w,
            u = box2d.b2MulSV(a, c, box2d.b2Island.s_translation); if (box2d.b2DotVV(u, u) > box2d.b2_maxTranslationSquared) { var p = box2d.b2_maxTranslation / u.GetLength();
            c.SelfMul(p) } var m = a * d;
        m * m > box2d.b2_maxRotationSquared && (d *= p = box2d.b2_maxRotation / box2d.b2Abs(m)), h.SelfMulAdd(a, c), l += a * d, this.m_positions[r].a = l, this.m_velocities[r].w = d; var f = this.m_bodies[r];
        f.m_sweep.c.Copy(h), f.m_sweep.a = l, f.m_linearVelocity.Copy(c), f.m_angularVelocity = d, f.SynchronizeTransform() } this.Report(s.m_velocityConstraints) }, box2d.b2Island.prototype.Report = function(t) { if (null !== this.m_listener)
        for (var e = 0; e < this.m_contactCount; ++e) { var i = this.m_contacts[e]; if (i) { var o = t[e],
                    n = box2d.b2Island.s_impulse;
                n.count = o.pointCount; for (var s = 0; s < o.pointCount; ++s) n.normalImpulses[s] = o.points[s].normalImpulse, n.tangentImpulses[s] = o.points[s].tangentImpulse;
                this.m_listener.PostSolve(i, n) } } }, box2d.b2Island.s_timer = new box2d.b2Timer, box2d.b2Island.s_solverData = new box2d.b2SolverData, box2d.b2Island.s_contactSolverDef = new box2d.b2ContactSolverDef, box2d.b2Island.s_contactSolver = new box2d.b2ContactSolver, box2d.b2Island.s_translation = new box2d.b2Vec2, box2d.b2Island.s_impulse = new box2d.b2ContactImpulse, goog.provide("box2d.b2ContactFactory"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Contact"), box2d.b2ContactRegister = function() {}, box2d.b2ContactRegister.prototype.createFcn = null, box2d.b2ContactRegister.prototype.destroyFcn = null, box2d.b2ContactRegister.prototype.primary = !1, box2d.b2ContactFactory = function(t) { this.m_allocator = t, this.InitializeRegisters() }, box2d.b2ContactFactory.prototype.m_allocator = null, box2d.b2ContactFactory.prototype.AddType = function(t, e, i, o) { var n = box2d.b2MakeArray(256, function() { return t() }),
        s = function(e) { return n.length > 0 ? n.pop() : t(e) },
        r = function(t) { n.push(t) };
    this.m_registers[i][o].pool = n, this.m_registers[i][o].createFcn = s, this.m_registers[i][o].destroyFcn = r, this.m_registers[i][o].primary = !0, i !== o && (this.m_registers[o][i].pool = n, this.m_registers[o][i].createFcn = s, this.m_registers[o][i].destroyFcn = r, this.m_registers[o][i].primary = !1) }, box2d.b2ContactFactory.prototype.InitializeRegisters = function() { this.m_registers = new Array(box2d.b2ShapeType.e_shapeTypeCount); for (var t = 0; t < box2d.b2ShapeType.e_shapeTypeCount; t++) { this.m_registers[t] = new Array(box2d.b2ShapeType.e_shapeTypeCount); for (var e = 0; e < box2d.b2ShapeType.e_shapeTypeCount; e++) this.m_registers[t][e] = new box2d.b2ContactRegister } this.AddType(box2d.b2CircleContact.Create, box2d.b2CircleContact.Destroy, box2d.b2ShapeType.e_circleShape, box2d.b2ShapeType.e_circleShape), this.AddType(box2d.b2PolygonAndCircleContact.Create, box2d.b2PolygonAndCircleContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_circleShape), this.AddType(box2d.b2PolygonContact.Create, box2d.b2PolygonContact.Destroy, box2d.b2ShapeType.e_polygonShape, box2d.b2ShapeType.e_polygonShape), this.AddType(box2d.b2EdgeAndCircleContact.Create, box2d.b2EdgeAndCircleContact.Destroy, box2d.b2ShapeType.e_edgeShape, box2d.b2ShapeType.e_circleShape), this.AddType(box2d.b2EdgeAndPolygonContact.Create, box2d.b2EdgeAndPolygonContact.Destroy, box2d.b2ShapeType.e_edgeShape, box2d.b2ShapeType.e_polygonShape), this.AddType(box2d.b2ChainAndCircleContact.Create, box2d.b2ChainAndCircleContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_circleShape), this.AddType(box2d.b2ChainAndPolygonContact.Create, box2d.b2ChainAndPolygonContact.Destroy, box2d.b2ShapeType.e_chainShape, box2d.b2ShapeType.e_polygonShape) }, box2d.b2ContactFactory.prototype.Create = function(t, e, i, o) { var n = t.GetType(),
        s = i.GetType();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(n >= 0 && n < box2d.b2ShapeType.e_shapeTypeCount), box2d.ENABLE_ASSERTS && box2d.b2Assert(s >= 0 && s < box2d.b2ShapeType.e_shapeTypeCount); var r = this.m_registers[n][s],
        a = r.createFcn; if (null !== a) { if (r.primary) return (h = a(this.m_allocator)).Reset(t, e, i, o), h; var h = a(this.m_allocator); return h.Reset(i, o, t, e), h } return null }, box2d.b2ContactFactory.prototype.Destroy = function(t) { var e = t.m_fixtureA,
        i = t.m_fixtureB;
    t.m_manifold.pointCount > 0 && !1 === e.IsSensor() && !1 === i.IsSensor() && (e.GetBody().SetAwake(!0), i.GetBody().SetAwake(!0)); var o = e.GetType(),
        n = i.GetType();
    box2d.ENABLE_ASSERTS && box2d.b2Assert(o >= 0 && n < box2d.b2ShapeType.e_shapeTypeCount), box2d.ENABLE_ASSERTS && box2d.b2Assert(o >= 0 && n < box2d.b2ShapeType.e_shapeTypeCount), (0, this.m_registers[o][n].destroyFcn)(t, this.m_allocator) }, goog.provide("box2d.b2GrowableStack"), goog.require("box2d.b2Settings"), box2d.b2GrowableStack = function(t) { this.m_stack = new Array(t) }, box2d.b2GrowableStack.prototype.m_stack = null, box2d.b2GrowableStack.prototype.m_count = 0, box2d.b2GrowableStack.prototype.Reset = function() { return this.m_count = 0, this }, box2d.b2GrowableStack.prototype.Push = function(t) { this.m_stack[this.m_count] = t, ++this.m_count }, box2d.b2GrowableStack.prototype.Pop = function() { box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_count > 0), --this.m_count; var t = this.m_stack[this.m_count]; return this.m_stack[this.m_count] = null, t }, box2d.b2GrowableStack.prototype.GetCount = function() { return this.m_count }, goog.provide("box2d.b2DynamicTree"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Collision"), goog.require("box2d.b2GrowableStack"), box2d.b2TreeNode = function(t) { this.m_id = t || 0, this.aabb = new box2d.b2AABB }, box2d.b2TreeNode.prototype.m_id = 0, box2d.b2TreeNode.prototype.aabb = null, box2d.b2TreeNode.prototype.userData = null, box2d.b2TreeNode.prototype.parent = null, box2d.b2TreeNode.prototype.child1 = null, box2d.b2TreeNode.prototype.child2 = null, box2d.b2TreeNode.prototype.height = 0, box2d.b2TreeNode.prototype.IsLeaf = function() { return null === this.child1 }, box2d.b2DynamicTree = function() {}, box2d.b2DynamicTree.prototype.m_root = null, box2d.b2DynamicTree.prototype.m_freeList = null, box2d.b2DynamicTree.prototype.m_path = 0, box2d.b2DynamicTree.prototype.m_insertionCount = 0, box2d.b2DynamicTree.s_stack = new box2d.b2GrowableStack(256), box2d.b2DynamicTree.s_r = new box2d.b2Vec2, box2d.b2DynamicTree.s_v = new box2d.b2Vec2, box2d.b2DynamicTree.s_abs_v = new box2d.b2Vec2, box2d.b2DynamicTree.s_segmentAABB = new box2d.b2AABB, box2d.b2DynamicTree.s_subInput = new box2d.b2RayCastInput, box2d.b2DynamicTree.s_combinedAABB = new box2d.b2AABB, box2d.b2DynamicTree.s_aabb = new box2d.b2AABB, box2d.b2DynamicTree.prototype.GetUserData = function(t) { return box2d.ENABLE_ASSERTS && box2d.b2Assert(null !== t), t.userData }, box2d.b2DynamicTree.prototype.GetFatAABB = function(t) { return box2d.ENABLE_ASSERTS && box2d.b2Assert(null !== t), t.aabb }, box2d.b2DynamicTree.prototype.Query = function(t, e) { if (null !== this.m_root) { var i = box2d.b2DynamicTree.s_stack.Reset(); for (i.Push(this.m_root); i.GetCount() > 0;) { var o = i.Pop(); if (null !== o && o.aabb.TestOverlap(e))
                if (o.IsLeaf()) { if (!1 === t(o)) return } else i.Push(o.child1), i.Push(o.child2) } } }, box2d.b2DynamicTree.prototype.RayCast = function(t, e) { if (null !== this.m_root) { var i = e.p1,
            o = e.p2,
            n = box2d.b2SubVV(o, i, box2d.b2DynamicTree.s_r);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(n.GetLengthSquared() > 0), n.Normalize(); var s = box2d.b2CrossOneV(n, box2d.b2DynamicTree.s_v),
            r = box2d.b2AbsV(s, box2d.b2DynamicTree.s_abs_v),
            a = e.maxFraction,
            h = box2d.b2DynamicTree.s_segmentAABB,
            l = i.x + a * (o.x - i.x),
            c = i.y + a * (o.y - i.y);
        h.lowerBound.x = box2d.b2Min(i.x, l), h.lowerBound.y = box2d.b2Min(i.y, c), h.upperBound.x = box2d.b2Max(i.x, l), h.upperBound.y = box2d.b2Max(i.y, c); var d = box2d.b2DynamicTree.s_stack.Reset(); for (d.Push(this.m_root); d.GetCount() > 0;) { var u = d.Pop(); if (null !== u && !1 !== box2d.b2TestOverlapAABB(u.aabb, h)) { var p = u.aabb.GetCenter(),
                    m = u.aabb.GetExtents(); if (!(box2d.b2Abs(box2d.b2DotVV(s, box2d.b2SubVV(i, p, box2d.b2Vec2.s_t0))) - box2d.b2DotVV(r, m) > 0))
                    if (u.IsLeaf()) { var f = box2d.b2DynamicTree.s_subInput;
                        f.p1.Copy(e.p1), f.p2.Copy(e.p2), f.maxFraction = a; var y = t(f, u); if (0 === y) return;
                        y > 0 && (a = y, l = i.x + a * (o.x - i.x), c = i.y + a * (o.y - i.y), h.lowerBound.x = box2d.b2Min(i.x, l), h.lowerBound.y = box2d.b2Min(i.y, c), h.upperBound.x = box2d.b2Max(i.x, l), h.upperBound.y = box2d.b2Max(i.y, c)) } else d.Push(u.child1), d.Push(u.child2) } } } }, box2d.b2DynamicTree.prototype.AllocateNode = function() { if (this.m_freeList) { var t = this.m_freeList; return this.m_freeList = t.parent, t.parent = null, t.child1 = null, t.child2 = null, t.height = 0, t.userData = null, t } return new box2d.b2TreeNode(box2d.b2DynamicTree.prototype.s_node_id++) }, box2d.b2DynamicTree.prototype.s_node_id = 0, box2d.b2DynamicTree.prototype.FreeNode = function(t) { t.parent = this.m_freeList, t.height = -1, this.m_freeList = t }, box2d.b2DynamicTree.prototype.CreateProxy = function(t, e) { var i = this.AllocateNode(),
        o = box2d.b2_aabbExtension,
        n = box2d.b2_aabbExtension; return i.aabb.lowerBound.x = t.lowerBound.x - o, i.aabb.lowerBound.y = t.lowerBound.y - n, i.aabb.upperBound.x = t.upperBound.x + o, i.aabb.upperBound.y = t.upperBound.y + n, i.userData = e, i.height = 0, this.InsertLeaf(i), i }, box2d.b2DynamicTree.prototype.DestroyProxy = function(t) { box2d.ENABLE_ASSERTS && box2d.b2Assert(t.IsLeaf()), this.RemoveLeaf(t), this.FreeNode(t) }, box2d.b2DynamicTree.prototype.MoveProxy = function(t, e, i) { if (box2d.ENABLE_ASSERTS && box2d.b2Assert(t.IsLeaf()), t.aabb.Contains(e)) return !1;
    this.RemoveLeaf(t); var o = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (i.x > 0 ? i.x : -i.x),
        n = box2d.b2_aabbExtension + box2d.b2_aabbMultiplier * (i.y > 0 ? i.y : -i.y); return t.aabb.lowerBound.x = e.lowerBound.x - o, t.aabb.lowerBound.y = e.lowerBound.y - n, t.aabb.upperBound.x = e.upperBound.x + o, t.aabb.upperBound.y = e.upperBound.y + n, this.InsertLeaf(t), !0 }, box2d.b2DynamicTree.prototype.InsertLeaf = function(t) { if (++this.m_insertionCount, null === this.m_root) return this.m_root = t, void(this.m_root.parent = null); for (var e, i, o = t.aabb, n = (o.GetCenter(), this.m_root); !1 === n.IsLeaf();) { e = n.child1, i = n.child2; var s = n.aabb.GetPerimeter(),
            r = box2d.b2DynamicTree.s_combinedAABB;
        r.Combine2(n.aabb, o); var a, h, l, c = r.GetPerimeter(),
            d = 2 * c,
            u = 2 * (c - s),
            p = box2d.b2DynamicTree.s_aabb;
        e.IsLeaf() ? (p.Combine2(o, e.aabb), a = p.GetPerimeter() + u) : (p.Combine2(o, e.aabb), h = e.aabb.GetPerimeter(), l = p.GetPerimeter(), a = l - h + u); var m; if (i.IsLeaf() ? (p.Combine2(o, i.aabb), m = p.GetPerimeter() + u) : (p.Combine2(o, i.aabb), h = i.aabb.GetPerimeter(), l = p.GetPerimeter(), m = l - h + u), a > d && m > d) break;
        n = m > a ? e : i } var f = n,
        y = f.parent,
        b = this.AllocateNode(); for (b.parent = y, b.userData = null, b.aabb.Combine2(o, f.aabb), b.height = f.height + 1, y ? (y.child1 === f ? y.child1 = b : y.child2 = b, b.child1 = f, b.child2 = t, f.parent = b, t.parent = b) : (b.child1 = f, b.child2 = t, f.parent = b, t.parent = b, this.m_root = b), n = t.parent; null !== n;) n = this.Balance(n), e = n.child1, i = n.child2, box2d.ENABLE_ASSERTS && box2d.b2Assert(null !== e), box2d.ENABLE_ASSERTS && box2d.b2Assert(null !== i), n.height = 1 + box2d.b2Max(e.height, i.height), n.aabb.Combine2(e.aabb, i.aabb), n = n.parent }, box2d.b2DynamicTree.prototype.RemoveLeaf = function(t) { if (t !== this.m_root) { var e, i = t.parent,
            o = i.parent; if (e = i.child1 === t ? i.child2 : i.child1, o) { o.child1 === i ? o.child1 = e : o.child2 = e, e.parent = o, this.FreeNode(i); for (var n = o; n;) { var s = (n = this.Balance(n)).child1,
                    r = n.child2;
                n.aabb.Combine2(s.aabb, r.aabb), n.height = 1 + box2d.b2Max(s.height, r.height), n = n.parent } } else this.m_root = e, e.parent = null, this.FreeNode(i) } else this.m_root = null }, box2d.b2DynamicTree.prototype.Balance = function(t) { if (box2d.ENABLE_ASSERTS && box2d.b2Assert(null !== t), t.IsLeaf() || t.height < 2) return t; var e = t.child1,
        i = t.child2,
        o = i.height - e.height; if (o > 1) { var n = i.child1,
            s = i.child2; return i.child1 = t, i.parent = t.parent, t.parent = i, null !== i.parent ? i.parent.child1 === t ? i.parent.child1 = i : (box2d.ENABLE_ASSERTS && box2d.b2Assert(i.parent.child2 === t), i.parent.child2 = i) : this.m_root = i, n.height > s.height ? (i.child2 = n, t.child2 = s, s.parent = t, t.aabb.Combine2(e.aabb, s.aabb), i.aabb.Combine2(t.aabb, n.aabb), t.height = 1 + box2d.b2Max(e.height, s.height), i.height = 1 + box2d.b2Max(t.height, n.height)) : (i.child2 = s, t.child2 = n, n.parent = t, t.aabb.Combine2(e.aabb, n.aabb), i.aabb.Combine2(t.aabb, s.aabb), t.height = 1 + box2d.b2Max(e.height, n.height), i.height = 1 + box2d.b2Max(t.height, s.height)), i } if (-1 > o) { var r = e.child1,
            a = e.child2; return e.child1 = t, e.parent = t.parent, t.parent = e, null !== e.parent ? e.parent.child1 === t ? e.parent.child1 = e : (box2d.ENABLE_ASSERTS && box2d.b2Assert(e.parent.child2 === t), e.parent.child2 = e) : this.m_root = e, r.height > a.height ? (e.child2 = r, t.child1 = a, a.parent = t, t.aabb.Combine2(i.aabb, a.aabb), e.aabb.Combine2(t.aabb, r.aabb), t.height = 1 + box2d.b2Max(i.height, a.height), e.height = 1 + box2d.b2Max(t.height, r.height)) : (e.child2 = a, t.child1 = r, r.parent = t, t.aabb.Combine2(i.aabb, r.aabb), e.aabb.Combine2(t.aabb, a.aabb), t.height = 1 + box2d.b2Max(i.height, r.height), e.height = 1 + box2d.b2Max(t.height, a.height)), e } return t }, box2d.b2DynamicTree.prototype.GetHeight = function() { return null === this.m_root ? 0 : this.m_root.height }, box2d.b2DynamicTree.prototype.GetAreaRatio = function() { if (null === this.m_root) return 0; var t = this.m_root.aabb.GetPerimeter(),
        e = function(t) { if (null === t) return 0; if (t.IsLeaf()) return 0; var i = t.aabb.GetPerimeter(); return i += e(t.child1), i += e(t.child2) }; return e(this.m_root) / t }, box2d.b2DynamicTree.prototype.ComputeHeightNode = function(t) { if (t.IsLeaf()) return 0; var e = this.ComputeHeightNode(t.child1),
        i = this.ComputeHeightNode(t.child2); return 1 + box2d.b2Max(e, i) }, box2d.b2DynamicTree.prototype.ComputeHeight = function() { return this.ComputeHeightNode(this.m_root) }, box2d.b2DynamicTree.prototype.ValidateStructure = function(t) { if (null !== t) { t === this.m_root && box2d.ENABLE_ASSERTS && box2d.b2Assert(null === t.parent); var e = t,
            i = e.child1,
            o = e.child2; if (e.IsLeaf()) return box2d.ENABLE_ASSERTS && box2d.b2Assert(null === i), box2d.ENABLE_ASSERTS && box2d.b2Assert(null === o), void(box2d.ENABLE_ASSERTS && box2d.b2Assert(0 === e.height));
        box2d.ENABLE_ASSERTS && box2d.b2Assert(i.parent === t), box2d.ENABLE_ASSERTS && box2d.b2Assert(o.parent === t), this.ValidateStructure(i), this.ValidateStructure(o) } }, box2d.b2DynamicTree.prototype.ValidateMetrics = function(t) { if (null !== t) { var e = t,
            i = e.child1,
            o = e.child2; if (e.IsLeaf()) return box2d.ENABLE_ASSERTS && box2d.b2Assert(null === i), box2d.ENABLE_ASSERTS && box2d.b2Assert(null === o), void(box2d.ENABLE_ASSERTS && box2d.b2Assert(0 === e.height)); var n, s = i.height,
            r = o.height;
        n = 1 + box2d.b2Max(s, r), box2d.ENABLE_ASSERTS && box2d.b2Assert(e.height === n); var a = box2d.b2DynamicTree.s_aabb;
        a.Combine2(i.aabb, o.aabb), box2d.ENABLE_ASSERTS && box2d.b2Assert(a.lowerBound === e.aabb.lowerBound), box2d.ENABLE_ASSERTS && box2d.b2Assert(a.upperBound === e.aabb.upperBound), this.ValidateMetrics(i), this.ValidateMetrics(o) } }, box2d.b2DynamicTree.prototype.Validate = function() { this.ValidateStructure(this.m_root), this.ValidateMetrics(this.m_root); for (var t = this.m_freeList; null !== t;) t = t.parent, 0;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.GetHeight() === this.ComputeHeight()) }, box2d.b2DynamicTree.prototype.GetMaxBalance = function() { return function(t, e) { if (null === t) return e; if (t.height <= 1) return e;
        box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === t.IsLeaf()); var i = t.child1,
            o = t.child2,
            n = box2d.b2Abs(o.height - i.height); return box2d.b2Max(e, n) }(this.m_root, 0) }, box2d.b2DynamicTree.prototype.RebuildBottomUp = function() { this.Validate() }, box2d.b2DynamicTree.prototype.ShiftOrigin = function(t) { var e = function(t, i) { if (null !== t && !(t.height <= 1)) { box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === t.IsLeaf()); var o = t.child1,
                n = t.child2;
            e(o, i), e(n, i), t.aabb.lowerBound.SelfSub(i), t.aabb.upperBound.SelfSub(i) } };
    e(this.m_root, t) }, goog.provide("box2d.b2BroadPhase"), goog.require("box2d.b2Settings"), goog.require("box2d.b2DynamicTree"), box2d.b2Pair = function() {}, box2d.b2Pair.prototype.proxyA = null, box2d.b2Pair.prototype.proxyB = null, box2d.b2BroadPhase = function() { this.m_tree = new box2d.b2DynamicTree, this.m_moveBuffer = new Array, this.m_pairBuffer = new Array }, box2d.b2BroadPhase.prototype.m_tree = null, box2d.b2BroadPhase.prototype.m_proxyCount = 0, box2d.b2BroadPhase.prototype.m_moveCount = 0, box2d.b2BroadPhase.prototype.m_moveBuffer = null, box2d.b2BroadPhase.prototype.m_pairCount = 0, box2d.b2BroadPhase.prototype.m_pairBuffer = null, box2d.b2BroadPhase.prototype.CreateProxy = function(t, e) { var i = this.m_tree.CreateProxy(t, e); return ++this.m_proxyCount, this.BufferMove(i), i }, box2d.b2BroadPhase.prototype.DestroyProxy = function(t) { this.UnBufferMove(t), --this.m_proxyCount, this.m_tree.DestroyProxy(t) }, box2d.b2BroadPhase.prototype.MoveProxy = function(t, e, i) { this.m_tree.MoveProxy(t, e, i) && this.BufferMove(t) }, box2d.b2BroadPhase.prototype.TouchProxy = function(t) { this.BufferMove(t) }, box2d.b2BroadPhase.prototype.GetFatAABB = function(t) { return this.m_tree.GetFatAABB(t) }, box2d.b2BroadPhase.prototype.GetUserData = function(t) { return this.m_tree.GetUserData(t) }, box2d.b2BroadPhase.prototype.TestOverlap = function(t, e) { var i = this.m_tree.GetFatAABB(t),
        o = this.m_tree.GetFatAABB(e); return box2d.b2TestOverlapAABB(i, o) }, box2d.b2BroadPhase.prototype.GetProxyCount = function() { return this.m_proxyCount }, box2d.b2BroadPhase.prototype.GetTreeHeight = function() { return this.m_tree.GetHeight() }, box2d.b2BroadPhase.prototype.GetTreeBalance = function() { return this.m_tree.GetMaxBalance() }, box2d.b2BroadPhase.prototype.GetTreeQuality = function() { return this.m_tree.GetAreaRatio() }, box2d.b2BroadPhase.prototype.ShiftOrigin = function(t) { this.m_tree.ShiftOrigin(t) }, box2d.b2BroadPhase.prototype.UpdatePairs = function(t) { this.m_pairCount = 0; for (n = 0; n < this.m_moveCount; ++n) { var e = this.m_moveBuffer[n]; if (null !== e) { var i = this,
                o = this.m_tree.GetFatAABB(e);
            this.m_tree.Query(function(t) { if (t.m_id === e.m_id) return !0;
                i.m_pairCount === i.m_pairBuffer.length && (i.m_pairBuffer[i.m_pairCount] = new box2d.b2Pair); var o = i.m_pairBuffer[i.m_pairCount]; return t.m_id < e.m_id ? (o.proxyA = t, o.proxyB = e) : (o.proxyA = e, o.proxyB = t), ++i.m_pairCount, !0 }, o) } } this.m_moveCount = 0, this.m_pairBuffer.length = this.m_pairCount, this.m_pairBuffer.sort(box2d.b2PairLessThan); for (var n = 0; n < this.m_pairCount;) { var s = this.m_pairBuffer[n],
            r = this.m_tree.GetUserData(s.proxyA),
            a = this.m_tree.GetUserData(s.proxyB); for (t.AddPair(r, a), ++n; n < this.m_pairCount;) { var h = this.m_pairBuffer[n]; if (h.proxyA.m_id !== s.proxyA.m_id || h.proxyB.m_id !== s.proxyB.m_id) break;++n } } }, box2d.b2BroadPhase.prototype.Query = function(t, e) { this.m_tree.Query(t, e) }, box2d.b2BroadPhase.prototype.RayCast = function(t, e) { this.m_tree.RayCast(t, e) }, box2d.b2BroadPhase.prototype.BufferMove = function(t) { this.m_moveBuffer[this.m_moveCount] = t, ++this.m_moveCount }, box2d.b2BroadPhase.prototype.UnBufferMove = function(t) { var e = this.m_moveBuffer.indexOf(t);
    this.m_moveBuffer[e] = null }, box2d.b2PairLessThan = function(t, e) { return t.proxyA.m_id === e.proxyA.m_id ? t.proxyB.m_id - e.proxyB.m_id : t.proxyA.m_id - e.proxyA.m_id }, goog.provide("box2d.b2ContactManager"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Collision"), goog.require("box2d.b2BroadPhase"), goog.require("box2d.b2ContactFactory"), box2d.b2ContactManager = function() { this.m_broadPhase = new box2d.b2BroadPhase, this.m_contactFactory = new box2d.b2ContactFactory(this.m_allocator) }, box2d.b2ContactManager.prototype.m_broadPhase = null, box2d.b2ContactManager.prototype.m_contactList = null, box2d.b2ContactManager.prototype.m_contactCount = 0, box2d.b2ContactManager.prototype.m_contactFilter = box2d.b2ContactFilter.b2_defaultFilter, box2d.b2ContactManager.prototype.m_contactListener = box2d.b2ContactListener.b2_defaultListener, box2d.b2ContactManager.prototype.m_allocator = null, box2d.b2ContactManager.prototype.m_contactFactory = null, box2d.b2ContactManager.prototype.Destroy = function(t) { var e = t.GetFixtureA(),
        i = t.GetFixtureB(),
        o = e.GetBody(),
        n = i.GetBody();
    this.m_contactListener && t.IsTouching() && this.m_contactListener.EndContact(t), t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t === this.m_contactList && (this.m_contactList = t.m_next), t.m_nodeA.prev && (t.m_nodeA.prev.next = t.m_nodeA.next), t.m_nodeA.next && (t.m_nodeA.next.prev = t.m_nodeA.prev), t.m_nodeA === o.m_contactList && (o.m_contactList = t.m_nodeA.next), t.m_nodeB.prev && (t.m_nodeB.prev.next = t.m_nodeB.next), t.m_nodeB.next && (t.m_nodeB.next.prev = t.m_nodeB.prev), t.m_nodeB === n.m_contactList && (n.m_contactList = t.m_nodeB.next), this.m_contactFactory.Destroy(t), --this.m_contactCount }, box2d.b2ContactManager.prototype.Collide = function() { for (var t = this.m_contactList; t;) { var e = t.GetFixtureA(),
            i = t.GetFixtureB(),
            o = t.GetChildIndexA(),
            n = t.GetChildIndexB(),
            s = e.GetBody(),
            r = i.GetBody(); if (t.m_flags & box2d.b2ContactFlag.e_filterFlag) { if (!1 === r.ShouldCollide(s)) { var a = t;
                t = a.m_next, this.Destroy(a); continue } if (this.m_contactFilter && !1 === this.m_contactFilter.ShouldCollide(e, i)) { t = (a = t).m_next, this.Destroy(a); continue } t.m_flags &= ~box2d.b2ContactFlag.e_filterFlag } var h = s.IsAwake() && s.m_type !== box2d.b2BodyType.b2_staticBody,
            l = r.IsAwake() && r.m_type !== box2d.b2BodyType.b2_staticBody; if (!1 !== h || !1 !== l) { var c = e.m_proxies[o].proxy,
                d = i.m_proxies[n].proxy;!1 !== this.m_broadPhase.TestOverlap(c, d) ? (t.Update(this.m_contactListener), t = t.m_next) : (a = t, t = a.m_next, this.Destroy(a)) } else t = t.m_next } }, box2d.b2ContactManager.prototype.FindNewContacts = function() { this.m_broadPhase.UpdatePairs(this) }, box2d.b2ContactManager.prototype.AddPair = function(t, e) { box2d.ENABLE_ASSERTS && box2d.b2Assert(t instanceof box2d.b2FixtureProxy), box2d.ENABLE_ASSERTS && box2d.b2Assert(e instanceof box2d.b2FixtureProxy); var i = t,
        o = e,
        n = i.fixture,
        s = o.fixture,
        r = i.childIndex,
        a = o.childIndex,
        h = n.GetBody(),
        l = s.GetBody(); if (h !== l) { for (var c = l.GetContactList(); c;) { if (c.other === h) { var d = c.contact.GetFixtureA(),
                    u = c.contact.GetFixtureB(),
                    p = c.contact.GetChildIndexA(),
                    m = c.contact.GetChildIndexB(); if (d === n && u === s && p === r && m === a) return; if (d === s && u === n && p === a && m === r) return } c = c.next } if (!1 !== l.ShouldCollide(h) && (!this.m_contactFilter || !1 !== this.m_contactFilter.ShouldCollide(n, s))) { var f = this.m_contactFactory.Create(n, r, s, a);
            null !== f && (n = f.GetFixtureA(), s = f.GetFixtureB(), r = f.GetChildIndexA(), a = f.GetChildIndexB(), h = n.m_body, l = s.m_body, f.m_prev = null, f.m_next = this.m_contactList, null !== this.m_contactList && (this.m_contactList.m_prev = f), this.m_contactList = f, f.m_nodeA.contact = f, f.m_nodeA.other = l, f.m_nodeA.prev = null, f.m_nodeA.next = h.m_contactList, null !== h.m_contactList && (h.m_contactList.prev = f.m_nodeA), h.m_contactList = f.m_nodeA, f.m_nodeB.contact = f, f.m_nodeB.other = h, f.m_nodeB.prev = null, f.m_nodeB.next = l.m_contactList, null !== l.m_contactList && (l.m_contactList.prev = f.m_nodeB), l.m_contactList = f.m_nodeB, !1 === n.IsSensor() && !1 === s.IsSensor() && (h.SetAwake(!0), l.SetAwake(!0)), ++this.m_contactCount) } } }, goog.provide("box2d.b2JointFactory"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Joint"), box2d.b2JointFactory.Create = function(t) { var e = null; switch (t.type) {
        case box2d.b2JointType.e_distanceJoint:
            e = new box2d.b2DistanceJoint(t instanceof box2d.b2DistanceJointDef ? t : null); break;
        case box2d.b2JointType.e_mouseJoint:
            e = new box2d.b2MouseJoint(t instanceof box2d.b2MouseJointDef ? t : null); break;
        case box2d.b2JointType.e_prismaticJoint:
            e = new box2d.b2PrismaticJoint(t instanceof box2d.b2PrismaticJointDef ? t : null); break;
        case box2d.b2JointType.e_revoluteJoint:
            e = new box2d.b2RevoluteJoint(t instanceof box2d.b2RevoluteJointDef ? t : null); break;
        case box2d.b2JointType.e_pulleyJoint:
            e = new box2d.b2PulleyJoint(t instanceof box2d.b2PulleyJointDef ? t : null); break;
        case box2d.b2JointType.e_gearJoint:
            e = new box2d.b2GearJoint(t instanceof box2d.b2GearJointDef ? t : null); break;
        case box2d.b2JointType.e_wheelJoint:
            e = new box2d.b2WheelJoint(t instanceof box2d.b2WheelJointDef ? t : null); break;
        case box2d.b2JointType.e_weldJoint:
            e = new box2d.b2WeldJoint(t instanceof box2d.b2WeldJointDef ? t : null); break;
        case box2d.b2JointType.e_frictionJoint:
            e = new box2d.b2FrictionJoint(t instanceof box2d.b2FrictionJointDef ? t : null); break;
        case box2d.b2JointType.e_ropeJoint:
            e = new box2d.b2RopeJoint(t instanceof box2d.b2RopeJointDef ? t : null); break;
        case box2d.b2JointType.e_motorJoint:
            e = new box2d.b2MotorJoint(t instanceof box2d.b2MotorJointDef ? t : null); break;
        case box2d.b2JointType.e_areaJoint:
            e = new box2d.b2AreaJoint(t instanceof box2d.b2AreaJointDef ? t : null); break;
        default:
            box2d.ENABLE_ASSERTS && box2d.b2Assert(!1) } return e }, box2d.b2JointFactory.Destroy = function() {}, goog.provide("box2d.b2Draw"), goog.require("box2d.b2Settings"), box2d.b2Color = function(t, e, i) { this.r = t, this.g = e, this.b = i }, box2d.b2Color.prototype.r = .5, box2d.b2Color.prototype.g = .5, box2d.b2Color.prototype.b = .5, box2d.b2Color.prototype.SetRGB = function(t, e, i) { return this.r = t, this.g = e, this.b = i, this }, box2d.b2Color.prototype.MakeStyleString = function(t) { var e = Math.round(Math.max(0, Math.min(255, 255 * this.r))),
        i = Math.round(Math.max(0, Math.min(255, 255 * this.g))),
        o = Math.round(Math.max(0, Math.min(255, 255 * this.b))),
        n = void 0 === t ? 1 : Math.max(0, Math.min(1, t)); return box2d.b2Color.MakeStyleString(e, i, o, n) }, box2d.b2Color.MakeStyleString = function(t, e, i, o) { return 1 > o ? "rgba(" + t + "," + e + "," + i + "," + o + ")" : "rgb(" + t + "," + e + "," + i + ")" }, box2d.b2Color.RED = new box2d.b2Color(1, 0, 0), box2d.b2Color.GREEN = new box2d.b2Color(0, 1, 0), box2d.b2Color.BLUE = new box2d.b2Color(0, 0, 1), box2d.b2DrawFlags = { e_none: 0, e_shapeBit: 1, e_jointBit: 2, e_aabbBit: 4, e_pairBit: 8, e_centerOfMassBit: 16, e_controllerBit: 32, e_all: 63 }, goog.exportProperty(box2d.b2DrawFlags, "e_none", box2d.b2DrawFlags.e_none), goog.exportProperty(box2d.b2DrawFlags, "e_shapeBit", box2d.b2DrawFlags.e_shapeBit), goog.exportProperty(box2d.b2DrawFlags, "e_jointBit", box2d.b2DrawFlags.e_jointBit), goog.exportProperty(box2d.b2DrawFlags, "e_aabbBit", box2d.b2DrawFlags.e_aabbBit), goog.exportProperty(box2d.b2DrawFlags, "e_pairBit", box2d.b2DrawFlags.e_pairBit), goog.exportProperty(box2d.b2DrawFlags, "e_centerOfMassBit", box2d.b2DrawFlags.e_centerOfMassBit), goog.exportProperty(box2d.b2DrawFlags, "e_controllerBit", box2d.b2DrawFlags.e_controllerBit), goog.exportProperty(box2d.b2DrawFlags, "e_all", box2d.b2DrawFlags.e_all), box2d.b2Draw = function() {}, box2d.b2Draw.prototype.m_drawFlags = box2d.b2DrawFlags.e_none, box2d.b2Draw.prototype.SetFlags = function(t) { this.m_drawFlags = t }, box2d.b2Draw.prototype.GetFlags = function() { return this.m_drawFlags }, box2d.b2Draw.prototype.AppendFlags = function(t) { this.m_drawFlags |= t }, box2d.b2Draw.prototype.ClearFlags = function(t) { this.m_drawFlags &= ~t }, box2d.b2Draw.prototype.PushTransform = function() {}, box2d.b2Draw.prototype.PopTransform = function() {}, box2d.b2Draw.prototype.DrawPolygon = function() {}, box2d.b2Draw.prototype.DrawSolidPolygon = function() {}, box2d.b2Draw.prototype.DrawCircle = function() {}, box2d.b2Draw.prototype.DrawSolidCircle = function() {}, box2d.b2Draw.prototype.DrawSegment = function() {}, box2d.b2Draw.prototype.DrawTransform = function() {}, goog.provide("box2d.b2Fixture"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Collision"), goog.require("box2d.b2Shape"), box2d.b2Filter = function() {}, box2d.b2Filter.prototype.categoryBits = 1, box2d.b2Filter.prototype.maskBits = 65535, box2d.b2Filter.prototype.groupIndex = 0, box2d.b2Filter.prototype.Clone = function() { return (new box2d.b2Filter).Copy(this) }, box2d.b2Filter.prototype.Copy = function(t) { return box2d.ENABLE_ASSERTS && box2d.b2Assert(this !== t), this.categoryBits = t.categoryBits, this.maskBits = t.maskBits, this.groupIndex = t.groupIndex, this }, box2d.b2FixtureDef = function() { this.filter = new box2d.b2Filter }, box2d.b2FixtureDef.prototype.shape = null, box2d.b2FixtureDef.prototype.userData = null, box2d.b2FixtureDef.prototype.friction = .2, box2d.b2FixtureDef.prototype.restitution = 0, box2d.b2FixtureDef.prototype.density = 0, box2d.b2FixtureDef.prototype.isSensor = !1, box2d.b2FixtureDef.prototype.filter = null, box2d.b2FixtureProxy = function() { this.aabb = new box2d.b2AABB }, box2d.b2FixtureProxy.prototype.aabb = null, box2d.b2FixtureProxy.prototype.fixture = null, box2d.b2FixtureProxy.prototype.childIndex = 0, box2d.b2FixtureProxy.prototype.proxy = null, box2d.b2FixtureProxy.MakeArray = function(t) { return box2d.b2MakeArray(t, function() { return new box2d.b2FixtureProxy }) }, box2d.b2Fixture = function() { this.m_proxyCount = 0, this.m_filter = new box2d.b2Filter }, box2d.b2Fixture.prototype.m_density = 0, box2d.b2Fixture.prototype.m_next = null, box2d.b2Fixture.prototype.m_body = null, box2d.b2Fixture.prototype.m_shape = null, box2d.b2Fixture.prototype.m_friction = 0, box2d.b2Fixture.prototype.m_restitution = 0, box2d.b2Fixture.prototype.m_proxies = null, box2d.b2Fixture.prototype.m_proxyCount = 0, box2d.b2Fixture.prototype.m_filter = null, box2d.b2Fixture.prototype.m_isSensor = !1, box2d.b2Fixture.prototype.m_userData = null, box2d.b2Fixture.prototype.GetType = function() { return this.m_shape.GetType() }, box2d.b2Fixture.prototype.GetShape = function() { return this.m_shape }, box2d.b2Fixture.prototype.IsSensor = function() { return this.m_isSensor }, box2d.b2Fixture.prototype.GetFilterData = function() { return this.m_filter }, box2d.b2Fixture.prototype.GetUserData = function() { return this.m_userData }, box2d.b2Fixture.prototype.SetUserData = function(t) { this.m_userData = t }, box2d.b2Fixture.prototype.GetBody = function() { return this.m_body }, box2d.b2Fixture.prototype.GetNext = function() { return this.m_next }, box2d.b2Fixture.prototype.SetDensity = function(t) { this.m_density = t }, box2d.b2Fixture.prototype.GetDensity = function() { return this.m_density }, box2d.b2Fixture.prototype.GetFriction = function() { return this.m_friction }, box2d.b2Fixture.prototype.SetFriction = function(t) { this.m_friction = t }, box2d.b2Fixture.prototype.GetRestitution = function() { return this.m_restitution }, box2d.b2Fixture.prototype.SetRestitution = function(t) { this.m_restitution = t }, box2d.b2Fixture.prototype.TestPoint = function(t) { return this.m_shape.TestPoint(this.m_body.GetTransform(), t) }, box2d.b2Fixture.prototype.RayCast = function(t, e, i) { return this.m_shape.RayCast(t, e, this.m_body.GetTransform(), i) }, box2d.b2Fixture.prototype.GetMassData = function(t) { return t = t || new box2d.b2MassData, this.m_shape.ComputeMass(t, this.m_density), t }, box2d.b2Fixture.prototype.GetAABB = function(t) { return box2d.ENABLE_ASSERTS && box2d.b2Assert(t >= 0 && t < this.m_proxyCount), this.m_proxies[t].aabb }, box2d.b2Fixture.prototype.Create = function(t, e) { this.m_userData = e.userData, this.m_friction = e.friction, this.m_restitution = e.restitution, this.m_body = t, this.m_next = null, this.m_filter.Copy(e.filter), this.m_isSensor = e.isSensor, this.m_shape = e.shape.Clone(), this.m_proxies = box2d.b2FixtureProxy.MakeArray(this.m_shape.GetChildCount()), this.m_proxyCount = 0, this.m_density = e.density }, box2d.b2Fixture.prototype.Destroy = function() { box2d.ENABLE_ASSERTS && box2d.b2Assert(0 === this.m_proxyCount), this.m_shape = null }, box2d.b2Fixture.prototype.CreateProxies = function(t, e) { box2d.ENABLE_ASSERTS && box2d.b2Assert(0 === this.m_proxyCount), this.m_proxyCount = this.m_shape.GetChildCount(); for (var i = 0; i < this.m_proxyCount; ++i) { var o = this.m_proxies[i];
        this.m_shape.ComputeAABB(o.aabb, e, i), o.proxy = t.CreateProxy(o.aabb, o), o.fixture = this, o.childIndex = i } }, box2d.b2Fixture.prototype.DestroyProxies = function(t) { for (var e = 0; e < this.m_proxyCount; ++e) { var i = this.m_proxies[e];
        t.DestroyProxy(i.proxy), i.proxy = null } this.m_proxyCount = 0 }, box2d.b2Fixture.prototype.Synchronize = function(t, e, i) { if (0 !== this.m_proxyCount)
        for (var o = 0; o < this.m_proxyCount; ++o) { var n = this.m_proxies[o],
                s = box2d.b2Fixture.prototype.Synchronize.s_aabb1,
                r = box2d.b2Fixture.prototype.Synchronize.s_aabb2;
            this.m_shape.ComputeAABB(s, e, o), this.m_shape.ComputeAABB(r, i, o), n.aabb.Combine2(s, r); var a = box2d.b2SubVV(i.p, e.p, box2d.b2Fixture.prototype.Synchronize.s_displacement);
            t.MoveProxy(n.proxy, n.aabb, a) } }, box2d.b2Fixture.prototype.Synchronize.s_aabb1 = new box2d.b2AABB, box2d.b2Fixture.prototype.Synchronize.s_aabb2 = new box2d.b2AABB, box2d.b2Fixture.prototype.Synchronize.s_displacement = new box2d.b2Vec2, box2d.b2Fixture.prototype.SetFilterData = function(t) { this.m_filter.Copy(t), this.Refilter() }, box2d.b2Fixture.prototype.Refilter = function() { if (!this.m_body) { for (var t = this.m_body.GetContactList(); t;) { var e = t.contact,
                i = e.GetFixtureA(),
                o = e.GetFixtureB();
            (i === this || o === this) && e.FlagForFiltering(), t = t.next } var n = this.m_body.GetWorld(); if (null !== n)
            for (var s = n.m_contactManager.m_broadPhase, r = 0; r < this.m_proxyCount; ++r) s.TouchProxy(this.m_proxies[r].proxy) } }, box2d.b2Fixture.prototype.SetSensor = function(t) { t !== this.m_isSensor && (this.m_body.SetAwake(!0), this.m_isSensor = t) }, box2d.b2Fixture.prototype.Dump = function(t) { box2d.DEBUG && (box2d.b2Log("    /*box2d.b2FixtureDef*/ var fd = new box2d.b2FixtureDef();\n"), box2d.b2Log("    fd.friction = %.15f;\n", this.m_friction), box2d.b2Log("    fd.restitution = %.15f;\n", this.m_restitution), box2d.b2Log("    fd.density = %.15f;\n", this.m_density), box2d.b2Log("    fd.isSensor = %s;\n", this.m_isSensor ? "true" : "false"), box2d.b2Log("    fd.filter.categoryBits = %d;\n", this.m_filter.categoryBits), box2d.b2Log("    fd.filter.maskBits = %d;\n", this.m_filter.maskBits), box2d.b2Log("    fd.filter.groupIndex = %d;\n", this.m_filter.groupIndex), this.m_shape.Dump(), box2d.b2Log("\n"), box2d.b2Log("    fd.shape = shape;\n"), box2d.b2Log("\n"), box2d.b2Log("    bodies[%d].CreateFixture(fd);\n", t)) }, goog.provide("box2d.b2Body"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), goog.require("box2d.b2Fixture"), box2d.b2BodyType = { b2_unknown: -1, b2_staticBody: 0, b2_kinematicBody: 1, b2_dynamicBody: 2, b2_bulletBody: 3 }, goog.exportProperty(box2d.b2BodyType, "b2_unknown", box2d.b2BodyType.b2_unknown), goog.exportProperty(box2d.b2BodyType, "b2_staticBody", box2d.b2BodyType.b2_staticBody), goog.exportProperty(box2d.b2BodyType, "b2_kinematicBody", box2d.b2BodyType.b2_kinematicBody), goog.exportProperty(box2d.b2BodyType, "b2_dynamicBody", box2d.b2BodyType.b2_dynamicBody), goog.exportProperty(box2d.b2BodyType, "b2_bulletBody", box2d.b2BodyType.b2_bulletBody), box2d.b2BodyDef = function() { this.position = new box2d.b2Vec2(0, 0), this.linearVelocity = new box2d.b2Vec2(0, 0) }, box2d.b2BodyDef.prototype.type = box2d.b2BodyType.b2_staticBody, box2d.b2BodyDef.prototype.position = null, box2d.b2BodyDef.prototype.angle = 0, box2d.b2BodyDef.prototype.linearVelocity = null, box2d.b2BodyDef.prototype.angularVelocity = 0, box2d.b2BodyDef.prototype.linearDamping = 0, box2d.b2BodyDef.prototype.angularDamping = 0, box2d.b2BodyDef.prototype.allowSleep = !0, box2d.b2BodyDef.prototype.awake = !0, box2d.b2BodyDef.prototype.fixedRotation = !1, box2d.b2BodyDef.prototype.bullet = !1, box2d.b2BodyDef.prototype.active = !0, box2d.b2BodyDef.prototype.userData = null, box2d.b2BodyDef.prototype.gravityScale = 1, box2d.b2BodyFlag = { e_none: 0, e_islandFlag: 1, e_awakeFlag: 2, e_autoSleepFlag: 4, e_bulletFlag: 8, e_fixedRotationFlag: 16, e_activeFlag: 32, e_toiFlag: 64 }, goog.exportProperty(box2d.b2BodyFlag, "e_none", box2d.b2BodyFlag.e_none), goog.exportProperty(box2d.b2BodyFlag, "e_islandFlag", box2d.b2BodyFlag.e_islandFlag), goog.exportProperty(box2d.b2BodyFlag, "e_awakeFlag", box2d.b2BodyFlag.e_awakeFlag), goog.exportProperty(box2d.b2BodyFlag, "e_autoSleepFlag", box2d.b2BodyFlag.e_autoSleepFlag), goog.exportProperty(box2d.b2BodyFlag, "e_bulletFlag", box2d.b2BodyFlag.e_bulletFlag), goog.exportProperty(box2d.b2BodyFlag, "e_fixedRotationFlag", box2d.b2BodyFlag.e_fixedRotationFlag), goog.exportProperty(box2d.b2BodyFlag, "e_activeFlag", box2d.b2BodyFlag.e_activeFlag), goog.exportProperty(box2d.b2BodyFlag, "e_toiFlag", box2d.b2BodyFlag.e_toiFlag), box2d.b2Body = function(t, e) { this.m_xf = new box2d.b2Transform, this.m_out_xf = new box2d.b2Transform, this.m_sweep = new box2d.b2Sweep, this.m_out_sweep = new box2d.b2Sweep, this.m_linearVelocity = new box2d.b2Vec2, this.m_out_linearVelocity = new box2d.b2Vec2, this.m_force = new box2d.b2Vec2, box2d.ENABLE_ASSERTS && box2d.b2Assert(t.position.IsValid()), box2d.ENABLE_ASSERTS && box2d.b2Assert(t.linearVelocity.IsValid()), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.angle)), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.angularVelocity)), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.gravityScale) && t.gravityScale >= 0), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.angularDamping) && t.angularDamping >= 0), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.linearDamping) && t.linearDamping >= 0), this.m_flags = box2d.b2BodyFlag.e_none, t.bullet && (this.m_flags |= box2d.b2BodyFlag.e_bulletFlag), t.fixedRotation && (this.m_flags |= box2d.b2BodyFlag.e_fixedRotationFlag), t.allowSleep && (this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag), t.awake && (this.m_flags |= box2d.b2BodyFlag.e_awakeFlag), t.active && (this.m_flags |= box2d.b2BodyFlag.e_activeFlag), this.m_world = e, this.m_xf.p.Copy(t.position), this.m_xf.q.SetAngleRadians(t.angle), this.m_sweep.localCenter.SetZero(), this.m_sweep.c0.Copy(this.m_xf.p), this.m_sweep.c.Copy(this.m_xf.p), this.m_sweep.a0 = t.angle, this.m_sweep.a = t.angle, this.m_sweep.alpha0 = 0, this.m_linearVelocity.Copy(t.linearVelocity), this.m_angularVelocity = t.angularVelocity, this.m_linearDamping = t.linearDamping, this.m_angularDamping = t.angularDamping, this.m_gravityScale = t.gravityScale, this.m_force.SetZero(), this.m_torque = 0, this.m_sleepTime = 0, this.m_type = t.type, t.type === box2d.b2BodyType.b2_dynamicBody ? (this.m_mass = 1, this.m_invMass = 1) : (this.m_mass = 0, this.m_invMass = 0), this.m_I = 0, this.m_invI = 0, this.m_userData = t.userData, this.m_fixtureList = null, this.m_fixtureCount = 0, this.m_controllerList = null, this.m_controllerCount = 0 }, box2d.b2Body.prototype.m_flags = box2d.b2BodyFlag.e_none, box2d.b2Body.prototype.m_islandIndex = 0, box2d.b2Body.prototype.m_world = null, box2d.b2Body.prototype.m_xf = null, box2d.b2Body.prototype.m_out_xf = null, box2d.b2Body.prototype.m_sweep = null, box2d.b2Body.prototype.m_out_sweep = null, box2d.b2Body.prototype.m_jointList = null, box2d.b2Body.prototype.m_contactList = null, box2d.b2Body.prototype.m_prev = null, box2d.b2Body.prototype.m_next = null, box2d.b2Body.prototype.m_linearVelocity = null, box2d.b2Body.prototype.m_out_linearVelocity = null, box2d.b2Body.prototype.m_angularVelocity = 0, box2d.b2Body.prototype.m_linearDamping = 0, box2d.b2Body.prototype.m_angularDamping = 0, box2d.b2Body.prototype.m_gravityScale = 1, box2d.b2Body.prototype.m_force = null, box2d.b2Body.prototype.m_torque = 0, box2d.b2Body.prototype.m_sleepTime = 0, box2d.b2Body.prototype.m_type = box2d.b2BodyType.b2_staticBody, box2d.b2Body.prototype.m_mass = 1, box2d.b2Body.prototype.m_invMass = 1, box2d.b2Body.prototype.m_I = 0, box2d.b2Body.prototype.m_invI = 0, box2d.b2Body.prototype.m_userData = null, box2d.b2Body.prototype.m_fixtureList = null, box2d.b2Body.prototype.m_fixtureCount = 0, box2d.b2Body.prototype.m_controllerList = null, box2d.b2Body.prototype.m_controllerCount = 0, box2d.b2Body.prototype.CreateFixture = function(t) { if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.m_world.IsLocked()), !0 === this.m_world.IsLocked()) return null; var e = new box2d.b2Fixture; if (e.Create(this, t), this.m_flags & box2d.b2BodyFlag.e_activeFlag) { var i = this.m_world.m_contactManager.m_broadPhase;
        e.CreateProxies(i, this.m_xf) } return e.m_next = this.m_fixtureList, this.m_fixtureList = e, ++this.m_fixtureCount, e.m_body = this, e.m_density > 0 && this.ResetMassData(), this.m_world.m_flags |= box2d.b2WorldFlag.e_newFixture, e }, box2d.b2Body.prototype.CreateFixture2 = function(t, e) { void 0 === e && (e = 0); var i = box2d.b2Body.prototype.CreateFixture2.s_def; return i.shape = t, i.density = e, this.CreateFixture(i) }, box2d.b2Body.prototype.CreateFixture2.s_def = new box2d.b2FixtureDef, box2d.b2Body.prototype.DestroyFixture = function(t) { if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.m_world.IsLocked()), !0 !== this.m_world.IsLocked()) { box2d.ENABLE_ASSERTS && box2d.b2Assert(t.m_body === this), box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_fixtureCount > 0); for (var e = this.m_fixtureList, i = null, o = !1; null !== e;) { if (e === t) { i ? i.m_next = t.m_next : this.m_fixtureList = t.m_next, o = !0; break } i = e, e = e.m_next } box2d.ENABLE_ASSERTS && box2d.b2Assert(o); for (var n = this.m_contactList; n;) { var s = n.contact;
            n = n.next; var r = s.GetFixtureA(),
                a = s.GetFixtureB();
            (t === r || t === a) && this.m_world.m_contactManager.Destroy(s) } if (this.m_flags & box2d.b2BodyFlag.e_activeFlag) { var h = this.m_world.m_contactManager.m_broadPhase;
            t.DestroyProxies(h) } t.Destroy(), t.m_body = null, t.m_next = null, --this.m_fixtureCount, this.ResetMassData() } }, box2d.b2Body.prototype.SetTransformVecRadians = function(t, e) { this.SetTransformXYRadians(t.x, t.y, e) }, box2d.b2Body.prototype.SetTransformXYRadians = function(t, e, i) { if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.m_world.IsLocked()), !0 !== this.m_world.IsLocked() && (this.m_xf.p.x !== t || this.m_xf.p.y !== e || this.m_xf.q.GetAngleRadians() !== i)) { this.m_xf.q.SetAngleRadians(i), this.m_xf.p.SetXY(t, e), box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c), this.m_sweep.a = i, this.m_sweep.c0.Copy(this.m_sweep.c), this.m_sweep.a0 = i; for (var o = this.m_world.m_contactManager.m_broadPhase, n = this.m_fixtureList; n; n = n.m_next) n.Synchronize(o, this.m_xf, this.m_xf) } }, box2d.b2Body.prototype.SetTransform = function(t) { this.SetTransformVecRadians(t.p, t.GetAngleRadians()) }, box2d.b2Body.prototype.GetTransform = function(t) { return (t = t || this.m_out_xf).Copy(this.m_xf) }, box2d.b2Body.prototype.GetPosition = function(t) { return (t = t || this.m_out_xf.p).Copy(this.m_xf.p) }, box2d.b2Body.prototype.SetPosition = function(t) { this.SetTransformVecRadians(t, this.GetAngleRadians()) }, box2d.b2Body.prototype.SetPositionXY = function(t, e) { this.SetTransformXYRadians(t, e, this.GetAngleRadians()) }, box2d.b2Body.prototype.GetAngle = function() { return this.m_sweep.a }, box2d.b2Body.prototype.GetAngleRadians = box2d.b2Body.prototype.GetAngle, box2d.b2Body.prototype.GetAngleDegrees = function() { return box2d.b2RadToDeg(this.GetAngle()) }, box2d.b2Body.prototype.SetAngle = function(t) { this.SetTransformVecRadians(this.GetPosition(), t) }, box2d.b2Body.prototype.SetAngleRadians = box2d.b2Body.prototype.SetAngle, box2d.b2Body.prototype.SetAngleDegrees = function(t) { this.SetAngle(box2d.b2DegToRad(t)) }, box2d.b2Body.prototype.GetWorldCenter = function(t) { return (t = t || this.m_out_sweep.c).Copy(this.m_sweep.c) }, box2d.b2Body.prototype.GetLocalCenter = function(t) { return (t = t || this.m_out_sweep.localCenter).Copy(this.m_sweep.localCenter) }, box2d.b2Body.prototype.SetLinearVelocity = function(t) { this.m_type !== box2d.b2BodyType.b2_staticBody && (box2d.b2DotVV(t, t) > 0 && this.SetAwake(!0), this.m_linearVelocity.Copy(t)) }, box2d.b2Body.prototype.GetLinearVelocity = function(t) { return (t = t || this.m_out_linearVelocity).Copy(this.m_linearVelocity) }, box2d.b2Body.prototype.SetAngularVelocity = function(t) { this.m_type !== box2d.b2BodyType.b2_staticBody && (t * t > 0 && this.SetAwake(!0), this.m_angularVelocity = t) }, box2d.b2Body.prototype.GetAngularVelocity = function() { return this.m_angularVelocity }, box2d.b2Body.prototype.GetDefinition = function(t) { return t.type = this.GetType(), t.allowSleep = (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) === box2d.b2BodyFlag.e_autoSleepFlag, t.angle = this.GetAngleRadians(), t.angularDamping = this.m_angularDamping, t.gravityScale = this.m_gravityScale, t.angularVelocity = this.m_angularVelocity, t.fixedRotation = (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag, t.bullet = (this.m_flags & box2d.b2BodyFlag.e_bulletFlag) === box2d.b2BodyFlag.e_bulletFlag, t.awake = (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === box2d.b2BodyFlag.e_awakeFlag, t.linearDamping = this.m_linearDamping, t.linearVelocity.Copy(this.GetLinearVelocity()), t.position.Copy(this.GetPosition()), t.userData = this.GetUserData(), t }, box2d.b2Body.prototype.ApplyForce = function(t, e, i) { i = i || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (i && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_force.x += t.x, this.m_force.y += t.y, this.m_torque += (e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x)) }, box2d.b2Body.prototype.ApplyForceToCenter = function(t, e) { e = e || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (e && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_force.x += t.x, this.m_force.y += t.y)) }, box2d.b2Body.prototype.ApplyTorque = function(t, e) { e = e || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (e && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_torque += t)) }, box2d.b2Body.prototype.ApplyLinearImpulse = function(t, e, i) { i = i || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (i && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_linearVelocity.x += this.m_invMass * t.x, this.m_linearVelocity.y += this.m_invMass * t.y, this.m_angularVelocity += this.m_invI * ((e.x - this.m_sweep.c.x) * t.y - (e.y - this.m_sweep.c.y) * t.x))) }, box2d.b2Body.prototype.ApplyAngularImpulse = function(t, e) { e = e || !0, this.m_type === box2d.b2BodyType.b2_dynamicBody && (e && 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && this.SetAwake(!0), this.m_flags & box2d.b2BodyFlag.e_awakeFlag && (this.m_angularVelocity += this.m_invI * t)) }, box2d.b2Body.prototype.GetMass = function() { return this.m_mass }, box2d.b2Body.prototype.GetInertia = function() { return this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter) }, box2d.b2Body.prototype.GetMassData = function(t) { return t.mass = this.m_mass, t.I = this.m_I + this.m_mass * box2d.b2DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter), t.center.Copy(this.m_sweep.localCenter), t }, box2d.b2Body.prototype.SetMassData = function(t) { if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.m_world.IsLocked()), !0 !== this.m_world.IsLocked() && this.m_type === box2d.b2BodyType.b2_dynamicBody) { this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_mass = t.mass, this.m_mass <= 0 && (this.m_mass = 1), this.m_invMass = 1 / this.m_mass, t.I > 0 && 0 == (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) && (this.m_I = t.I - this.m_mass * box2d.b2DotVV(t.center, t.center), box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_I > 0), this.m_invI = 1 / this.m_I); var e = box2d.b2Body.prototype.SetMassData.s_oldCenter.Copy(this.m_sweep.c);
        this.m_sweep.localCenter.Copy(t.center), box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c), this.m_sweep.c0.Copy(this.m_sweep.c), box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, e, box2d.b2Vec2.s_t0), this.m_linearVelocity) } }, box2d.b2Body.prototype.SetMassData.s_oldCenter = new box2d.b2Vec2, box2d.b2Body.prototype.ResetMassData = function() { if (this.m_mass = 0, this.m_invMass = 0, this.m_I = 0, this.m_invI = 0, this.m_sweep.localCenter.SetZero(), this.m_type === box2d.b2BodyType.b2_staticBody || this.m_type === box2d.b2BodyType.b2_kinematicBody) return this.m_sweep.c0.Copy(this.m_xf.p), this.m_sweep.c.Copy(this.m_xf.p), void(this.m_sweep.a0 = this.m_sweep.a);
    box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_type === box2d.b2BodyType.b2_dynamicBody); for (var t = box2d.b2Body.prototype.ResetMassData.s_localCenter.SetZero(), e = this.m_fixtureList; e; e = e.m_next)
        if (0 !== e.m_density) { var i = e.GetMassData(box2d.b2Body.prototype.ResetMassData.s_massData);
            this.m_mass += i.mass, t.x += i.center.x * i.mass, t.y += i.center.y * i.mass, this.m_I += i.I } this.m_mass > 0 ? (this.m_invMass = 1 / this.m_mass, t.x *= this.m_invMass, t.y *= this.m_invMass) : (this.m_mass = 1, this.m_invMass = 1), this.m_I > 0 && 0 == (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) ? (this.m_I -= this.m_mass * box2d.b2DotVV(t, t), box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_I > 0), this.m_invI = 1 / this.m_I) : (this.m_I = 0, this.m_invI = 0); var o = box2d.b2Body.prototype.ResetMassData.s_oldCenter.Copy(this.m_sweep.c);
    this.m_sweep.localCenter.Copy(t), box2d.b2MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c), this.m_sweep.c0.Copy(this.m_sweep.c), box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(this.m_sweep.c, o, box2d.b2Vec2.s_t0), this.m_linearVelocity) }, box2d.b2Body.prototype.ResetMassData.s_localCenter = new box2d.b2Vec2, box2d.b2Body.prototype.ResetMassData.s_oldCenter = new box2d.b2Vec2, box2d.b2Body.prototype.ResetMassData.s_massData = new box2d.b2MassData, box2d.b2Body.prototype.GetWorldPoint = function(t, e) { return box2d.b2MulXV(this.m_xf, t, e) }, box2d.b2Body.prototype.GetWorldVector = function(t, e) { return box2d.b2MulRV(this.m_xf.q, t, e) }, box2d.b2Body.prototype.GetLocalPoint = function(t, e) { return box2d.b2MulTXV(this.m_xf, t, e) }, box2d.b2Body.prototype.GetLocalVector = function(t, e) { return box2d.b2MulTRV(this.m_xf.q, t, e) }, box2d.b2Body.prototype.GetLinearVelocityFromWorldPoint = function(t, e) { return box2d.b2AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, box2d.b2SubVV(t, this.m_sweep.c, box2d.b2Vec2.s_t0), e) }, box2d.b2Body.prototype.GetLinearVelocityFromLocalPoint = function(t, e) { return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(t, e), e) }, box2d.b2Body.prototype.GetLinearDamping = function() { return this.m_linearDamping }, box2d.b2Body.prototype.SetLinearDamping = function(t) { this.m_linearDamping = t }, box2d.b2Body.prototype.GetAngularDamping = function() { return this.m_angularDamping }, box2d.b2Body.prototype.SetAngularDamping = function(t) { this.m_angularDamping = t }, box2d.b2Body.prototype.GetGravityScale = function() { return this.m_gravityScale }, box2d.b2Body.prototype.SetGravityScale = function(t) { this.m_gravityScale = t }, box2d.b2Body.prototype.SetType = function(t) { if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.m_world.IsLocked()), !0 !== this.m_world.IsLocked() && this.m_type !== t) { this.m_type = t, this.ResetMassData(), this.m_type === box2d.b2BodyType.b2_staticBody && (this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_sweep.a0 = this.m_sweep.a, this.m_sweep.c0.Copy(this.m_sweep.c), this.SynchronizeFixtures()), this.SetAwake(!0), this.m_force.SetZero(), this.m_torque = 0; for (var e = this.m_contactList; e;) { var i = e;
            e = e.next, this.m_world.m_contactManager.Destroy(i.contact) } this.m_contactList = null; for (var o = this.m_world.m_contactManager.m_broadPhase, n = this.m_fixtureList; n; n = n.m_next)
            for (var s = n.m_proxyCount, r = 0; s > r; ++r) o.TouchProxy(n.m_proxies[r].proxy) } }, box2d.b2Body.prototype.GetType = function() { return this.m_type }, box2d.b2Body.prototype.SetBullet = function(t) { t ? this.m_flags |= box2d.b2BodyFlag.e_bulletFlag : this.m_flags &= ~box2d.b2BodyFlag.e_bulletFlag }, box2d.b2Body.prototype.IsBullet = function() { return (this.m_flags & box2d.b2BodyFlag.e_bulletFlag) === box2d.b2BodyFlag.e_bulletFlag }, box2d.b2Body.prototype.SetSleepingAllowed = function(t) { t ? this.m_flags |= box2d.b2BodyFlag.e_autoSleepFlag : (this.m_flags &= ~box2d.b2BodyFlag.e_autoSleepFlag, this.SetAwake(!0)) }, box2d.b2Body.prototype.IsSleepingAllowed = function() { return (this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag) === box2d.b2BodyFlag.e_autoSleepFlag }, box2d.b2Body.prototype.SetAwake = function(t) { t ? 0 == (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) && (this.m_flags |= box2d.b2BodyFlag.e_awakeFlag, this.m_sleepTime = 0) : (this.m_flags &= ~box2d.b2BodyFlag.e_awakeFlag, this.m_sleepTime = 0, this.m_linearVelocity.SetZero(), this.m_angularVelocity = 0, this.m_force.SetZero(), this.m_torque = 0) }, box2d.b2Body.prototype.IsAwake = function() { return (this.m_flags & box2d.b2BodyFlag.e_awakeFlag) === box2d.b2BodyFlag.e_awakeFlag }, box2d.b2Body.prototype.SetActive = function(t) { if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.m_world.IsLocked()), t !== this.IsActive())
        if (t) { this.m_flags |= box2d.b2BodyFlag.e_activeFlag; for (var e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.CreateProxies(e, this.m_xf) } else { this.m_flags &= ~box2d.b2BodyFlag.e_activeFlag; for (var e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.DestroyProxies(e); for (var o = this.m_contactList; o;) { var n = o;
                o = o.next, this.m_world.m_contactManager.Destroy(n.contact) } this.m_contactList = null } }, box2d.b2Body.prototype.IsActive = function() { return (this.m_flags & box2d.b2BodyFlag.e_activeFlag) === box2d.b2BodyFlag.e_activeFlag }, box2d.b2Body.prototype.SetFixedRotation = function(t) {
    (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag !== t && (t ? this.m_flags |= box2d.b2BodyFlag.e_fixedRotationFlag : this.m_flags &= ~box2d.b2BodyFlag.e_fixedRotationFlag, this.m_angularVelocity = 0, this.ResetMassData()) }, box2d.b2Body.prototype.IsFixedRotation = function() { return (this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag) === box2d.b2BodyFlag.e_fixedRotationFlag }, box2d.b2Body.prototype.GetFixtureList = function() { return this.m_fixtureList }, box2d.b2Body.prototype.GetJointList = function() { return this.m_jointList }, box2d.b2Body.prototype.GetContactList = function() { return this.m_contactList }, box2d.b2Body.prototype.GetNext = function() { return this.m_next }, box2d.b2Body.prototype.GetUserData = function() { return this.m_userData }, box2d.b2Body.prototype.SetUserData = function(t) { this.m_userData = t }, box2d.b2Body.prototype.GetWorld = function() { return this.m_world }, box2d.b2Body.prototype.SynchronizeFixtures = function() { var t = box2d.b2Body.prototype.SynchronizeFixtures.s_xf1;
    t.q.SetAngleRadians(this.m_sweep.a0), box2d.b2MulRV(t.q, this.m_sweep.localCenter, t.p), box2d.b2SubVV(this.m_sweep.c0, t.p, t.p); for (var e = this.m_world.m_contactManager.m_broadPhase, i = this.m_fixtureList; i; i = i.m_next) i.Synchronize(e, t, this.m_xf) }, box2d.b2Body.prototype.SynchronizeFixtures.s_xf1 = new box2d.b2Transform, box2d.b2Body.prototype.SynchronizeTransform = function() { this.m_xf.q.SetAngleRadians(this.m_sweep.a), box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p), box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p) }, box2d.b2Body.prototype.ShouldCollide = function(t) { if (this.m_type !== box2d.b2BodyType.b2_dynamicBody && t.m_type !== box2d.b2BodyType.b2_dynamicBody) return !1; for (var e = this.m_jointList; e; e = e.next)
        if (e.other === t && !1 === e.joint.m_collideConnected) return !1; return !0 }, box2d.b2Body.prototype.Advance = function(t) { this.m_sweep.Advance(t), this.m_sweep.c.Copy(this.m_sweep.c0), this.m_sweep.a = this.m_sweep.a0, this.m_xf.q.SetAngleRadians(this.m_sweep.a), box2d.b2MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p), box2d.b2SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p) }, box2d.b2Body.prototype.Dump = function() { if (box2d.DEBUG) { var t = this.m_islandIndex;
        box2d.b2Log("if (true)\n"), box2d.b2Log("{\n"), box2d.b2Log("  /*box2d.b2BodyDef*/ var bd = new box2d.b2BodyDef();\n"); var e = ""; switch (this.m_type) {
            case box2d.b2BodyType.b2_staticBody:
                e = "box2d.b2BodyType.b2_staticBody"; break;
            case box2d.b2BodyType.b2_kinematicBody:
                e = "box2d.b2BodyType.b2_kinematicBody"; break;
            case box2d.b2BodyType.b2_dynamicBody:
                e = "box2d.b2BodyType.b2_dynamicBody"; break;
            default:
                box2d.ENABLE_ASSERTS && box2d.b2Assert(!1) } box2d.b2Log("  bd.type = %s;\n", e), box2d.b2Log("  bd.position.SetXY(%.15f, %.15f);\n", this.m_xf.p.x, this.m_xf.p.y), box2d.b2Log("  bd.angle = %.15f;\n", this.m_sweep.a), box2d.b2Log("  bd.linearVelocity.SetXY(%.15f, %.15f);\n", this.m_linearVelocity.x, this.m_linearVelocity.y), box2d.b2Log("  bd.angularVelocity = %.15f;\n", this.m_angularVelocity), box2d.b2Log("  bd.linearDamping = %.15f;\n", this.m_linearDamping), box2d.b2Log("  bd.angularDamping = %.15f;\n", this.m_angularDamping), box2d.b2Log("  bd.allowSleep = %s;\n", this.m_flags & box2d.b2BodyFlag.e_autoSleepFlag ? "true" : "false"), box2d.b2Log("  bd.awake = %s;\n", this.m_flags & box2d.b2BodyFlag.e_awakeFlag ? "true" : "false"), box2d.b2Log("  bd.fixedRotation = %s;\n", this.m_flags & box2d.b2BodyFlag.e_fixedRotationFlag ? "true" : "false"), box2d.b2Log("  bd.bullet = %s;\n", this.m_flags & box2d.b2BodyFlag.e_bulletFlag ? "true" : "false"), box2d.b2Log("  bd.active = %s;\n", this.m_flags & box2d.b2BodyFlag.e_activeFlag ? "true" : "false"), box2d.b2Log("  bd.gravityScale = %.15f;\n", this.m_gravityScale), box2d.b2Log("\n"), box2d.b2Log("  bodies[%d] = this.m_world.CreateBody(bd);\n", this.m_islandIndex), box2d.b2Log("\n"); for (var i = this.m_fixtureList; i; i = i.m_next) box2d.b2Log("  if (true)\n"), box2d.b2Log("  {\n"), i.Dump(t), box2d.b2Log("  }\n");
        box2d.b2Log("}\n") } }, box2d.b2Body.prototype.GetControllerList = function() { return this.m_controllerList }, box2d.b2Body.prototype.GetControllerCount = function() { return this.m_controllerCount }, goog.provide("box2d.b2World"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Draw"), goog.require("box2d.b2ContactManager"), goog.require("box2d.b2ContactSolver"), goog.require("box2d.b2Island"), goog.require("box2d.b2Body"), goog.require("box2d.b2Math"), goog.require("box2d.b2Collision"), goog.require("box2d.b2TimeStep"), goog.require("box2d.b2WorldCallbacks"), goog.require("box2d.b2JointFactory"), box2d.b2WorldFlag = { e_none: 0, e_newFixture: 1, e_locked: 2, e_clearForces: 4 }, goog.exportProperty(box2d.b2WorldFlag, "e_none", box2d.b2WorldFlag.e_none), goog.exportProperty(box2d.b2WorldFlag, "e_newFixture", box2d.b2WorldFlag.e_newFixture), goog.exportProperty(box2d.b2WorldFlag, "e_locked", box2d.b2WorldFlag.e_locked), goog.exportProperty(box2d.b2WorldFlag, "e_clearForces", box2d.b2WorldFlag.e_clearForces), box2d.b2World = function(t) { this.m_flags = box2d.b2WorldFlag.e_clearForces, this.m_contactManager = new box2d.b2ContactManager, this.m_gravity = t.Clone(), this.m_out_gravity = new box2d.b2Vec2, this.m_allowSleep = !0, this.m_destructionListener = null, this.m_debugDraw = null, this.m_warmStarting = !0, this.m_continuousPhysics = !0, this.m_subStepping = !1, this.m_stepComplete = !0, this.m_profile = new box2d.b2Profile, this.m_island = new box2d.b2Island, this.s_stack = new Array }, box2d.b2World.prototype.m_flags = box2d.b2WorldFlag.e_none, box2d.b2World.prototype.m_contactManager = null, box2d.b2World.prototype.m_bodyList = null, box2d.b2World.prototype.m_jointList = null, box2d.b2World.prototype.m_bodyCount = 0, box2d.b2World.prototype.m_jointCount = 0, box2d.b2World.prototype.m_gravity = null, box2d.b2World.prototype.m_out_gravity = null, box2d.b2World.prototype.m_allowSleep = !0, box2d.b2World.prototype.m_destructionListener = null, box2d.b2World.prototype.m_debugDraw = null, box2d.b2World.prototype.m_inv_dt0 = 0, box2d.b2World.prototype.m_warmStarting = !0, box2d.b2World.prototype.m_continuousPhysics = !0, box2d.b2World.prototype.m_subStepping = !1, box2d.b2World.prototype.m_stepComplete = !0, box2d.b2World.prototype.m_profile = null, box2d.b2World.prototype.m_island = null, box2d.b2World.prototype.s_stack = null, box2d.b2World.prototype.m_controllerList = null, box2d.b2World.prototype.m_controllerCount = 0, box2d.b2World.prototype.SetAllowSleeping = function(t) { if (t !== this.m_allowSleep && (this.m_allowSleep = t, !1 === this.m_allowSleep))
        for (var e = this.m_bodyList; e; e = e.m_next) e.SetAwake(!0) }, box2d.b2World.prototype.GetAllowSleeping = function() { return this.m_allowSleep }, box2d.b2World.prototype.SetWarmStarting = function(t) { this.m_warmStarting = t }, box2d.b2World.prototype.GetWarmStarting = function() { return this.m_warmStarting }, box2d.b2World.prototype.SetContinuousPhysics = function(t) { this.m_continuousPhysics = t }, box2d.b2World.prototype.GetContinuousPhysics = function() { return this.m_continuousPhysics }, box2d.b2World.prototype.SetSubStepping = function(t) { this.m_subStepping = t }, box2d.b2World.prototype.GetSubStepping = function() { return this.m_subStepping }, box2d.b2World.prototype.GetBodyList = function() { return this.m_bodyList }, box2d.b2World.prototype.GetJointList = function() { return this.m_jointList }, box2d.b2World.prototype.GetContactList = function() { return this.m_contactManager.m_contactList }, box2d.b2World.prototype.GetBodyCount = function() { return this.m_bodyCount }, box2d.b2World.prototype.GetJointCount = function() { return this.m_jointCount }, box2d.b2World.prototype.GetContactCount = function() { return this.m_contactManager.m_contactCount }, box2d.b2World.prototype.SetGravity = function(t, e) { if (e = e || !0, (this.m_gravity.x !== t.x || this.m_gravity.y !== t.y) && (this.m_gravity.Copy(t), e))
        for (var i = this.m_bodyList; i; i = i.m_next) i.SetAwake(!0) }, box2d.b2World.prototype.GetGravity = function(t) { return (t = t || this.m_out_gravity).Copy(this.m_gravity) }, box2d.b2World.prototype.IsLocked = function() { return (this.m_flags & box2d.b2WorldFlag.e_locked) > 0 }, box2d.b2World.prototype.SetAutoClearForces = function(t) { t ? this.m_flags |= box2d.b2WorldFlag.e_clearForces : this.m_flags &= ~box2d.b2WorldFlag.e_clearForces }, box2d.b2World.prototype.GetAutoClearForces = function() { return (this.m_flags & box2d.b2WorldFlag.e_clearForces) === box2d.b2WorldFlag.e_clearForces }, box2d.b2World.prototype.GetContactManager = function() { return this.m_contactManager }, box2d.b2World.prototype.GetProfile = function() { return this.m_profile }, box2d.b2World.prototype.SetDestructionListener = function(t) { this.m_destructionListener = t }, box2d.b2World.prototype.SetContactFilter = function(t) { this.m_contactManager.m_contactFilter = t }, box2d.b2World.prototype.SetContactListener = function(t) { this.m_contactManager.m_contactListener = t }, box2d.b2World.prototype.SetDebugDraw = function(t) { this.m_debugDraw = t }, box2d.b2World.prototype.CreateBody = function(t) { if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.IsLocked()), this.IsLocked()) return null; var e = new box2d.b2Body(t, this); return e.m_prev = null, e.m_next = this.m_bodyList, this.m_bodyList && (this.m_bodyList.m_prev = e), this.m_bodyList = e, ++this.m_bodyCount, e }, box2d.b2World.prototype.DestroyBody = function(t) { if (box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_bodyCount > 0), box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.IsLocked()), !this.IsLocked()) { for (var e = t.m_jointList; e;) { var i = e;
            e = e.next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeJoint(i.joint), this.DestroyJoint(i.joint), t.m_jointList = e } t.m_jointList = null; for (var o = t.m_controllerList; o;) { var n = o;
            o = o.nextController, n.controller.RemoveBody(t) } for (var s = t.m_contactList; s;) { var r = s;
            s = s.next, this.m_contactManager.Destroy(r.contact) } t.m_contactList = null; for (var a = t.m_fixtureList; a;) { var h = a;
            a = a.m_next, this.m_destructionListener && this.m_destructionListener.SayGoodbyeFixture(h), h.DestroyProxies(this.m_contactManager.m_broadPhase), h.Destroy(), t.m_fixtureList = a, t.m_fixtureCount -= 1 } t.m_fixtureList = null, t.m_fixtureCount = 0, t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t === this.m_bodyList && (this.m_bodyList = t.m_next), --this.m_bodyCount } }, box2d.b2World.prototype.CreateJoint = function(t) { if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.IsLocked()), this.IsLocked()) return null; var e = box2d.b2JointFactory.Create(t, null);
    e.m_prev = null, e.m_next = this.m_jointList, this.m_jointList && (this.m_jointList.m_prev = e), this.m_jointList = e, ++this.m_jointCount, e.m_edgeA.joint = e, e.m_edgeA.other = e.m_bodyB, e.m_edgeA.prev = null, e.m_edgeA.next = e.m_bodyA.m_jointList, e.m_bodyA.m_jointList && (e.m_bodyA.m_jointList.prev = e.m_edgeA), e.m_bodyA.m_jointList = e.m_edgeA, e.m_edgeB.joint = e, e.m_edgeB.other = e.m_bodyA, e.m_edgeB.prev = null, e.m_edgeB.next = e.m_bodyB.m_jointList, e.m_bodyB.m_jointList && (e.m_bodyB.m_jointList.prev = e.m_edgeB), e.m_bodyB.m_jointList = e.m_edgeB; var i = t.bodyA,
        o = t.bodyB; if (!1 === t.collideConnected)
        for (var n = o.GetContactList(); n;) n.other === i && n.contact.FlagForFiltering(), n = n.next; return e }, box2d.b2World.prototype.DestroyJoint = function(t) { if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.IsLocked()), !this.IsLocked()) { var e = t.m_collideConnected;
        t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), t === this.m_jointList && (this.m_jointList = t.m_next); var i = t.m_bodyA,
            o = t.m_bodyB; if (i.SetAwake(!0), o.SetAwake(!0), t.m_edgeA.prev && (t.m_edgeA.prev.next = t.m_edgeA.next), t.m_edgeA.next && (t.m_edgeA.next.prev = t.m_edgeA.prev), t.m_edgeA === i.m_jointList && (i.m_jointList = t.m_edgeA.next), t.m_edgeA.prev = null, t.m_edgeA.next = null, t.m_edgeB.prev && (t.m_edgeB.prev.next = t.m_edgeB.next), t.m_edgeB.next && (t.m_edgeB.next.prev = t.m_edgeB.prev), t.m_edgeB === o.m_jointList && (o.m_jointList = t.m_edgeB.next), t.m_edgeB.prev = null, t.m_edgeB.next = null, box2d.b2JointFactory.Destroy(t, null), box2d.ENABLE_ASSERTS && box2d.b2Assert(this.m_jointCount > 0), --this.m_jointCount, !1 === e)
            for (var n = o.GetContactList(); n;) n.other === i && n.contact.FlagForFiltering(), n = n.next } }, box2d.b2World.prototype.Solve = function(t) { for (var e = this.m_controllerList; e; e = e.m_next) e.Step(t);
    this.m_profile.solveInit = 0, this.m_profile.solveVelocity = 0, this.m_profile.solvePosition = 0; var i = this.m_island;
    i.Initialize(this.m_bodyCount, this.m_contactManager.m_contactCount, this.m_jointCount, null, this.m_contactManager.m_contactListener); for (g = this.m_bodyList; g; g = g.m_next) g.m_flags &= ~box2d.b2BodyFlag.e_islandFlag; for (var o = this.m_contactManager.m_contactList; o; o = o.m_next) o.m_flags &= ~box2d.b2ContactFlag.e_islandFlag; for (var n = this.m_jointList; n; n = n.m_next) n.m_islandFlag = !1; for (var s = this.m_bodyCount, r = this.s_stack, a = this.m_bodyList; a; a = a.m_next)
        if (!(a.m_flags & box2d.b2BodyFlag.e_islandFlag) && !1 !== a.IsAwake() && !1 !== a.IsActive() && a.GetType() !== box2d.b2BodyType.b2_staticBody) { i.Clear(); var h = 0; for (r[h++] = a, a.m_flags |= box2d.b2BodyFlag.e_islandFlag; h > 0;) { g = r[--h]; if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!0 === g.IsActive()), i.AddBody(g), g.SetAwake(!0), g.GetType() !== box2d.b2BodyType.b2_staticBody) { for (var l = g.m_contactList; l; l = l.next) { var c = l.contact; if (!(c.m_flags & box2d.b2ContactFlag.e_islandFlag) && !1 !== c.IsEnabled() && !1 !== c.IsTouching()) { var d = c.m_fixtureA.m_isSensor,
                                u = c.m_fixtureB.m_isSensor;
                            d || u || (i.AddContact(c), c.m_flags |= box2d.b2ContactFlag.e_islandFlag, (m = l.other).m_flags & box2d.b2BodyFlag.e_islandFlag || (box2d.ENABLE_ASSERTS && box2d.b2Assert(s > h), r[h++] = m, m.m_flags |= box2d.b2BodyFlag.e_islandFlag)) } } for (var p = g.m_jointList; p; p = p.next)
                        if (!0 !== p.joint.m_islandFlag) { var m = p.other;!1 !== m.IsActive() && (i.AddJoint(p.joint), p.joint.m_islandFlag = !0, m.m_flags & box2d.b2BodyFlag.e_islandFlag || (box2d.ENABLE_ASSERTS && box2d.b2Assert(s > h), r[h++] = m, m.m_flags |= box2d.b2BodyFlag.e_islandFlag)) } } } var f = new box2d.b2Profile;
            i.Solve(f, t, this.m_gravity, this.m_allowSleep), this.m_profile.solveInit += f.solveInit, this.m_profile.solveVelocity += f.solveVelocity, this.m_profile.solvePosition += f.solvePosition; for (y = 0; y < i.m_bodyCount; ++y)(g = i.m_bodies[y]).GetType() === box2d.b2BodyType.b2_staticBody && (g.m_flags &= ~box2d.b2BodyFlag.e_islandFlag) } for (var y = 0; y < r.length && r[y]; ++y) r[y] = null; for (var b = new box2d.b2Timer, g = this.m_bodyList; g; g = g.m_next) 0 != (g.m_flags & box2d.b2BodyFlag.e_islandFlag) && g.GetType() !== box2d.b2BodyType.b2_staticBody && g.SynchronizeFixtures();
    this.m_contactManager.FindNewContacts(), this.m_profile.broadphase = b.GetMilliseconds() }, box2d.b2World.prototype.SolveTOI = function(t) { var e = this.m_island; if (e.Initialize(2 * box2d.b2_maxTOIContacts, box2d.b2_maxTOIContacts, 0, null, this.m_contactManager.m_contactListener), this.m_stepComplete) { for (var i = this.m_bodyList; i; i = i.m_next) i.m_flags &= ~box2d.b2BodyFlag.e_islandFlag, i.m_sweep.alpha0 = 0; for (s = this.m_contactManager.m_contactList; s; s = s.m_next) s.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag), s.m_toiCount = 0, s.m_toi = 1 } for (;;) { for (var o = null, n = 1, s = this.m_contactManager.m_contactList; s; s = s.m_next)
            if (!1 !== s.IsEnabled() && !(s.m_toiCount > box2d.b2_maxSubSteps)) { var r = 1; if (s.m_flags & box2d.b2ContactFlag.e_toiFlag) r = s.m_toi;
                else { var a = s.GetFixtureA(),
                        h = s.GetFixtureB(); if (a.IsSensor() || h.IsSensor()) continue; var l = a.GetBody(),
                        c = h.GetBody(),
                        d = l.m_type,
                        u = c.m_type;
                    box2d.ENABLE_ASSERTS && box2d.b2Assert(d === box2d.b2BodyType.b2_dynamicBody || u === box2d.b2BodyType.b2_dynamicBody); var p = l.IsAwake() && d !== box2d.b2BodyType.b2_staticBody,
                        m = c.IsAwake() && u !== box2d.b2BodyType.b2_staticBody; if (!1 === p && !1 === m) continue; var f = l.IsBullet() || d !== box2d.b2BodyType.b2_dynamicBody,
                        y = c.IsBullet() || u !== box2d.b2BodyType.b2_dynamicBody; if (!1 === f && !1 === y) continue; var b = l.m_sweep.alpha0;
                    l.m_sweep.alpha0 < c.m_sweep.alpha0 ? (b = c.m_sweep.alpha0, l.m_sweep.Advance(b)) : c.m_sweep.alpha0 < l.m_sweep.alpha0 && (b = l.m_sweep.alpha0, c.m_sweep.Advance(b)), box2d.ENABLE_ASSERTS && box2d.b2Assert(1 > b); var g = s.GetChildIndexA(),
                        _ = s.GetChildIndexB(),
                        v = box2d.b2World.prototype.SolveTOI.s_toi_input;
                    v.proxyA.SetShape(a.GetShape(), g), v.proxyB.SetShape(h.GetShape(), _), v.sweepA.Copy(l.m_sweep), v.sweepB.Copy(c.m_sweep), v.tMax = 1; var x = box2d.b2World.prototype.SolveTOI.s_toi_output;
                    box2d.b2TimeOfImpact(x, v); var S = x.t;
                    r = x.state === box2d.b2TOIOutputState.e_touching ? box2d.b2Min(b + (1 - b) * S, 1) : 1, s.m_toi = r, s.m_flags |= box2d.b2ContactFlag.e_toiFlag } n > r && (o = s, n = r) } if (null === o || 1 - 10 * box2d.b2_epsilon < n) { this.m_stepComplete = !0; break } var a = o.GetFixtureA(),
            h = o.GetFixtureB(),
            l = a.GetBody(),
            c = h.GetBody(),
            C = box2d.b2World.prototype.SolveTOI.s_backup1.Copy(l.m_sweep),
            w = box2d.b2World.prototype.SolveTOI.s_backup2.Copy(c.m_sweep); if (l.Advance(n), c.Advance(n), o.Update(this.m_contactManager.m_contactListener), o.m_flags &= ~box2d.b2ContactFlag.e_toiFlag, ++o.m_toiCount, !1 !== o.IsEnabled() && !1 !== o.IsTouching()) { l.SetAwake(!0), c.SetAwake(!0), e.Clear(), e.AddBody(l), e.AddBody(c), e.AddContact(o), l.m_flags |= box2d.b2BodyFlag.e_islandFlag, c.m_flags |= box2d.b2BodyFlag.e_islandFlag, o.m_flags |= box2d.b2ContactFlag.e_islandFlag; for (B = 0; 2 > B; ++B)
                if ((I = 0 === B ? l : c).m_type === box2d.b2BodyType.b2_dynamicBody)
                    for (D = I.m_contactList; D && e.m_bodyCount !== e.m_bodyCapacity && e.m_contactCount !== e.m_contactCapacity; D = D.next) { var A = D.contact; if (!(A.m_flags & box2d.b2ContactFlag.e_islandFlag)) { var T = D.other; if (T.m_type !== box2d.b2BodyType.b2_dynamicBody || !1 !== I.IsBullet() || !1 !== T.IsBullet()) { var P = A.m_fixtureA.m_isSensor,
                                    k = A.m_fixtureB.m_isSensor; if (!P && !k) { var M = box2d.b2World.prototype.SolveTOI.s_backup.Copy(T.m_sweep);
                                    0 == (T.m_flags & box2d.b2BodyFlag.e_islandFlag) && T.Advance(n), A.Update(this.m_contactManager.m_contactListener), !1 !== A.IsEnabled() && !1 !== A.IsTouching() ? (A.m_flags |= box2d.b2ContactFlag.e_islandFlag, e.AddContact(A), T.m_flags & box2d.b2BodyFlag.e_islandFlag || (T.m_flags |= box2d.b2BodyFlag.e_islandFlag, T.m_type !== box2d.b2BodyType.b2_staticBody && T.SetAwake(!0), e.AddBody(T))) : (T.m_sweep.Copy(M), T.SynchronizeTransform()) } } } }
            var E = box2d.b2World.prototype.SolveTOI.s_subStep;
            E.dt = (1 - n) * t.dt, E.inv_dt = 1 / E.dt, E.dtRatio = 1, E.positionIterations = 20, E.velocityIterations = t.velocityIterations, E.warmStarting = !1, e.SolveTOI(E, l.m_islandIndex, c.m_islandIndex); for (var B = 0; B < e.m_bodyCount; ++B) { var I = e.m_bodies[B]; if (I.m_flags &= ~box2d.b2BodyFlag.e_islandFlag, I.m_type === box2d.b2BodyType.b2_dynamicBody) { I.SynchronizeFixtures(); for (var D = I.m_contactList; D; D = D.next) D.contact.m_flags &= ~(box2d.b2ContactFlag.e_toiFlag | box2d.b2ContactFlag.e_islandFlag) } } if (this.m_contactManager.FindNewContacts(), this.m_subStepping) { this.m_stepComplete = !1; break } } else o.SetEnabled(!1), l.m_sweep.Copy(C), c.m_sweep.Copy(w), l.SynchronizeTransform(), c.SynchronizeTransform() } }, box2d.b2World.prototype.SolveTOI.s_subStep = new box2d.b2TimeStep, box2d.b2World.prototype.SolveTOI.s_backup = new box2d.b2Sweep, box2d.b2World.prototype.SolveTOI.s_backup1 = new box2d.b2Sweep, box2d.b2World.prototype.SolveTOI.s_backup2 = new box2d.b2Sweep, box2d.b2World.prototype.SolveTOI.s_toi_input = new box2d.b2TOIInput, box2d.b2World.prototype.SolveTOI.s_toi_output = new box2d.b2TOIOutput, box2d.b2World.prototype.Step = function(t, e, i) { var o = new box2d.b2Timer;
    this.m_flags & box2d.b2WorldFlag.e_newFixture && (this.m_contactManager.FindNewContacts(), this.m_flags &= ~box2d.b2WorldFlag.e_newFixture), this.m_flags |= box2d.b2WorldFlag.e_locked; var n = box2d.b2World.prototype.Step.s_step;
    n.dt = t, n.velocityIterations = e, n.positionIterations = i, n.inv_dt = t > 0 ? 1 / t : 0, n.dtRatio = this.m_inv_dt0 * t, n.warmStarting = this.m_warmStarting;
    s = new box2d.b2Timer; if (this.m_contactManager.Collide(), this.m_profile.collide = s.GetMilliseconds(), this.m_stepComplete && n.dt > 0) { s = new box2d.b2Timer;
        this.Solve(n), this.m_profile.solve = s.GetMilliseconds() } if (this.m_continuousPhysics && n.dt > 0) { var s = new box2d.b2Timer;
        this.SolveTOI(n), this.m_profile.solveTOI = s.GetMilliseconds() } n.dt > 0 && (this.m_inv_dt0 = n.inv_dt), this.m_flags & box2d.b2WorldFlag.e_clearForces && this.ClearForces(), this.m_flags &= ~box2d.b2WorldFlag.e_locked, this.m_profile.step = o.GetMilliseconds() }, box2d.b2World.prototype.Step.s_step = new box2d.b2TimeStep, box2d.b2World.prototype.ClearForces = function() { for (var t = this.m_bodyList; t; t = t.m_next) t.m_force.SetZero(), t.m_torque = 0 }, box2d.b2World.prototype.QueryAABB = function(t, e) { var i = this.m_contactManager.m_broadPhase;
    i.Query(function(e) { var o = i.GetUserData(e);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(o instanceof box2d.b2FixtureProxy); var n = o.fixture; return o.childIndex, t instanceof box2d.b2QueryCallback ? t.ReportFixture(n) : t(n) }, e) }, box2d.b2World.prototype.QueryShape = function(t, e, i) { var o = this.m_contactManager.m_broadPhase,
        n = box2d.b2World.prototype.QueryShape.s_aabb;
    e.ComputeAABB(n, i, 0), o.Query(function(n) { var s = o.GetUserData(n);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(s instanceof box2d.b2FixtureProxy); var r = s.fixture; return s.childIndex, !box2d.b2TestOverlapShape(e, 0, r.GetShape(), 0, i, r.GetBody().GetTransform()) || (t instanceof box2d.b2QueryCallback ? t.ReportFixture(r) : t(r)) }, n) }, box2d.b2World.prototype.QueryShape.s_aabb = new box2d.b2AABB, box2d.b2World.prototype.QueryPoint = function(t, e) { var i = this.m_contactManager.m_broadPhase,
        o = box2d.b2World.prototype.QueryPoint.s_aabb;
    o.lowerBound.SetXY(e.x - box2d.b2_linearSlop, e.y - box2d.b2_linearSlop), o.upperBound.SetXY(e.x + box2d.b2_linearSlop, e.y + box2d.b2_linearSlop), i.Query(function(o) { var n = i.GetUserData(o);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(n instanceof box2d.b2FixtureProxy); var s = n.fixture; return n.childIndex, !s.TestPoint(e) || (t instanceof box2d.b2QueryCallback ? t.ReportFixture(s) : t(s)) }, o) }, box2d.b2World.prototype.QueryPoint.s_aabb = new box2d.b2AABB, box2d.b2World.prototype.RayCast = function(t, e, i) { var o = this.m_contactManager.m_broadPhase,
        n = box2d.b2World.prototype.RayCast.s_input;
    n.maxFraction = 1, n.p1.Copy(e), n.p2.Copy(i), o.RayCast(function(n, s) { var r = o.GetUserData(s);
        box2d.ENABLE_ASSERTS && box2d.b2Assert(r instanceof box2d.b2FixtureProxy); var a = r.fixture,
            h = r.childIndex,
            l = box2d.b2World.prototype.RayCast.s_output; if (a.RayCast(l, n, h)) { var c = l.fraction,
                d = box2d.b2World.prototype.RayCast.s_point; return d.SetXY((1 - c) * e.x + c * i.x, (1 - c) * e.y + c * i.y), t instanceof box2d.b2RayCastCallback ? t.ReportFixture(a, d, l.normal, c) : t(a, d, l.normal, c) } return n.maxFraction }, n) }, box2d.b2World.prototype.RayCast.s_input = new box2d.b2RayCastInput, box2d.b2World.prototype.RayCast.s_output = new box2d.b2RayCastOutput, box2d.b2World.prototype.RayCast.s_point = new box2d.b2Vec2, box2d.b2World.prototype.RayCastOne = function(t, e) { var i = null,
        o = 1; return this.RayCast(function(t, e, n, s) { return o > s && (o = s, i = t), o }, t, e), i }, box2d.b2World.prototype.RayCastAll = function(t, e, i) { return i.length = 0, this.RayCast(function(t) { return i.push(t), 1 }, t, e), i }, box2d.b2World.prototype.DrawShape = function(t, e) { var i = t.GetShape(); switch (i.m_type) {
        case box2d.b2ShapeType.e_circleShape:
            var o = i instanceof box2d.b2CircleShape ? i : null,
                n = o.m_p,
                s = o.m_radius,
                r = box2d.b2Vec2.UNITX;
            this.m_debugDraw.DrawSolidCircle(n, s, r, e); break;
        case box2d.b2ShapeType.e_edgeShape:
            var a = i instanceof box2d.b2EdgeShape ? i : null,
                h = a.m_vertex1,
                l = a.m_vertex2;
            this.m_debugDraw.DrawSegment(h, l, e); break;
        case box2d.b2ShapeType.e_chainShape:
            for (var c = i instanceof box2d.b2ChainShape ? i : null, d = c.m_count, h = (f = c.m_vertices)[0], u = 0; d > u; ++u) { l = f[u];
                this.m_debugDraw.DrawSegment(h, l, e), this.m_debugDraw.DrawCircle(l, .05, e), h = l } break;
        case box2d.b2ShapeType.e_polygonShape:
            var p = i instanceof box2d.b2PolygonShape ? i : null,
                m = p.m_count,
                f = p.m_vertices;
            this.m_debugDraw.DrawSolidPolygon(f, m, e) } }, box2d.b2World.prototype.DrawJoint = function(t) { var e = t.GetBodyA(),
        i = t.GetBodyB(),
        o = e.m_xf,
        n = i.m_xf,
        s = o.p,
        r = n.p,
        a = t.GetAnchorA(box2d.b2World.prototype.DrawJoint.s_p1),
        h = t.GetAnchorB(box2d.b2World.prototype.DrawJoint.s_p2),
        l = box2d.b2World.prototype.DrawJoint.s_color.SetRGB(.5, .8, .8); switch (t.m_type) {
        case box2d.b2JointType.e_distanceJoint:
            this.m_debugDraw.DrawSegment(a, h, l); break;
        case box2d.b2JointType.e_pulleyJoint:
            var c = t instanceof box2d.b2PulleyJoint ? t : null,
                d = c.GetGroundAnchorA(box2d.b2World.prototype.DrawJoint.s_s1),
                u = c.GetGroundAnchorB(box2d.b2World.prototype.DrawJoint.s_s2);
            this.m_debugDraw.DrawSegment(d, a, l), this.m_debugDraw.DrawSegment(u, h, l), this.m_debugDraw.DrawSegment(d, u, l); break;
        case box2d.b2JointType.e_mouseJoint:
            this.m_debugDraw.DrawSegment(a, h, l); break;
        default:
            this.m_debugDraw.DrawSegment(s, a, l), this.m_debugDraw.DrawSegment(a, h, l), this.m_debugDraw.DrawSegment(r, h, l) } }, box2d.b2World.prototype.DrawJoint.s_p1 = new box2d.b2Vec2, box2d.b2World.prototype.DrawJoint.s_p2 = new box2d.b2Vec2, box2d.b2World.prototype.DrawJoint.s_color = new box2d.b2Color(.5, .8, .8), box2d.b2World.prototype.DrawJoint.s_s1 = new box2d.b2Vec2, box2d.b2World.prototype.DrawJoint.s_s2 = new box2d.b2Vec2, box2d.b2World.prototype.DrawDebugData = function() { if (null !== this.m_debugDraw) { var t = this.m_debugDraw.GetFlags(),
            e = box2d.b2World.prototype.DrawDebugData.s_color.SetRGB(0, 0, 0); if (t & box2d.b2DrawFlags.e_shapeBit)
            for (r = this.m_bodyList; r; r = r.m_next) { var i = r.m_xf;
                this.m_debugDraw.PushTransform(i); for (a = r.GetFixtureList(); a; a = a.m_next) !1 === r.IsActive() ? (e.SetRGB(.5, .5, .3), this.DrawShape(a, e)) : r.GetType() === box2d.b2BodyType.b2_staticBody ? (e.SetRGB(.5, .9, .5), this.DrawShape(a, e)) : r.GetType() === box2d.b2BodyType.b2_kinematicBody ? (e.SetRGB(.5, .5, .9), this.DrawShape(a, e)) : !1 === r.IsAwake() ? (e.SetRGB(.6, .6, .6), this.DrawShape(a, e)) : (e.SetRGB(.9, .7, .7), this.DrawShape(a, e));
                this.m_debugDraw.PopTransform(i) }
        if (t & box2d.b2DrawFlags.e_jointBit)
            for (var o = this.m_jointList; o; o = o.m_next) this.DrawJoint(o); if (t & box2d.b2DrawFlags.e_aabbBit) { e.SetRGB(.9, .3, .9); for (var n = this.m_contactManager.m_broadPhase, s = box2d.b2World.prototype.DrawDebugData.s_vs, r = this.m_bodyList; r; r = r.m_next)
                if (!1 !== r.IsActive())
                    for (var a = r.GetFixtureList(); a; a = a.m_next)
                        for (var h = 0; h < a.m_proxyCount; ++h) { var l = a.m_proxies[h],
                                c = n.GetFatAABB(l.proxy);
                            s[0].SetXY(c.lowerBound.x, c.lowerBound.y), s[1].SetXY(c.upperBound.x, c.lowerBound.y), s[2].SetXY(c.upperBound.x, c.upperBound.y), s[3].SetXY(c.lowerBound.x, c.upperBound.y), this.m_debugDraw.DrawPolygon(s, 4, e) } } if (t & box2d.b2DrawFlags.e_centerOfMassBit)
            for (r = this.m_bodyList; r; r = r.m_next)(i = box2d.b2World.prototype.DrawDebugData.s_xf).q.Copy(r.m_xf.q), i.p.Copy(r.GetWorldCenter()), this.m_debugDraw.DrawTransform(i); if (t & box2d.b2DrawFlags.e_controllerBit)
            for (var d = this.m_controllerList; d; d = d.m_next) d.Draw(this.m_debugDraw) } }, box2d.b2World.prototype.DrawDebugData.s_color = new box2d.b2Color(0, 0, 0), box2d.b2World.prototype.DrawDebugData.s_vs = box2d.b2Vec2.MakeArray(4), box2d.b2World.prototype.DrawDebugData.s_xf = new box2d.b2Transform, box2d.b2World.prototype.SetBroadPhase = function(t) { var e = this.m_contactManager.m_broadPhase;
    this.m_contactManager.m_broadPhase = t; for (var i = this.m_bodyList; i; i = i.m_next)
        for (var o = i.m_fixtureList; o; o = o.m_next) o.m_proxy = t.CreateProxy(e.GetFatAABB(o.m_proxy), o) }, box2d.b2World.prototype.GetProxyCount = function() { return this.m_contactManager.m_broadPhase.GetProxyCount() }, box2d.b2World.prototype.GetTreeHeight = function() { return this.m_contactManager.m_broadPhase.GetTreeHeight() }, box2d.b2World.prototype.GetTreeBalance = function() { return this.m_contactManager.m_broadPhase.GetTreeBalance() }, box2d.b2World.prototype.GetTreeQuality = function() { return this.m_contactManager.m_broadPhase.GetTreeQuality() }, box2d.b2World.prototype.ShiftOrigin = function(t) { if (box2d.ENABLE_ASSERTS && box2d.b2Assert(!1 === this.IsLocked()), !this.IsLocked()) { for (var e = this.m_bodyList; e; e = e.m_next) e.m_xf.p.SelfSub(t), e.m_sweep.c0.SelfSub(t), e.m_sweep.c.SelfSub(t); for (var i = this.m_jointList; i; i = i.m_next) i.ShiftOrigin(t);
        this.m_contactManager.m_broadPhase.ShiftOrigin(t) } }, box2d.b2World.prototype.Dump = function() { if (box2d.DEBUG) { if ((this.m_flags & box2d.b2WorldFlag.e_locked) === box2d.b2WorldFlag.e_locked) return;
        box2d.b2Log("/** @type {box2d.b2Vec2} */ var g = new box2d.b2Vec2(%.15f, %.15f);\n", this.m_gravity.x, this.m_gravity.y), box2d.b2Log("this.m_world.SetGravity(g);\n"), box2d.b2Log("/** @type {Array.<box2d.b2Body>} */ var bodies = new Array(%d);\n", this.m_bodyCount), box2d.b2Log("/** @type {Array.<box2d.b2Joint>} */ var joints = new Array(%d);\n", this.m_jointCount); for (var t = 0, e = this.m_bodyList; e; e = e.m_next) e.m_islandIndex = t, e.Dump(), ++t;
        t = 0; for (i = this.m_jointList; i; i = i.m_next) i.m_index = t, ++t; for (i = this.m_jointList; i; i = i.m_next) i.m_type !== box2d.b2JointType.e_gearJoint && (box2d.b2Log("if (true)\n"), box2d.b2Log("{\n"), i.Dump(), box2d.b2Log("}\n")); for (var i = this.m_jointList; i; i = i.m_next) i.m_type === box2d.b2JointType.e_gearJoint && (box2d.b2Log("if (true)\n"), box2d.b2Log("{\n"), i.Dump(), box2d.b2Log("}\n")) } }, box2d.b2World.prototype.AddController = function(t) { return box2d.ENABLE_ASSERTS && box2d.b2Assert(null === t.m_world, "Controller can only be a member of one world"), t.m_world = this, t.m_next = this.m_controllerList, t.m_prev = null, this.m_controllerList && (this.m_controllerList.m_prev = t), this.m_controllerList = t, ++this.m_controllerCount, t }, box2d.b2World.prototype.RemoveController = function(t) { box2d.ENABLE_ASSERTS && box2d.b2Assert(t.m_world === this, "Controller is not a member of this world"), t.m_prev && (t.m_prev.m_next = t.m_next), t.m_next && (t.m_next.m_prev = t.m_prev), this.m_controllerList === t && (this.m_controllerList = t.m_next), --this.m_controllerCount, t.m_prev = null, t.m_next = null, t.m_world = null }, goog.provide("box2d.b2AreaJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2AreaJointDef = function() { goog.base(this, box2d.b2JointType.e_areaJoint), this.bodies = new Array }, goog.inherits(box2d.b2AreaJointDef, box2d.b2JointDef), box2d.b2AreaJointDef.prototype.world = null, box2d.b2AreaJointDef.prototype.bodies = null, box2d.b2AreaJointDef.prototype.frequencyHz = 0, box2d.b2AreaJointDef.prototype.dampingRatio = 0, box2d.b2AreaJointDef.prototype.AddBody = function(t) { this.bodies.push(t), 1 === this.bodies.length ? this.bodyA = t : 2 === this.bodies.length && (this.bodyB = t) }, box2d.b2AreaJoint = function(t) { goog.base(this, t), box2d.ENABLE_ASSERTS && box2d.b2Assert(t.bodies.length >= 3, "You cannot create an area joint with less than three bodies."), this.m_bodies = t.bodies, this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_targetLengths = box2d.b2MakeNumberArray(t.bodies.length), this.m_normals = box2d.b2Vec2.MakeArray(t.bodies.length), this.m_joints = new Array(t.bodies.length), this.m_deltas = box2d.b2Vec2.MakeArray(t.bodies.length), this.m_delta = new box2d.b2Vec2; var e = new box2d.b2DistanceJointDef;
    e.frequencyHz = t.frequencyHz, e.dampingRatio = t.dampingRatio, this.m_targetArea = 0; for (var i = 0, o = this.m_bodies.length; o > i; ++i) { var n = this.m_bodies[i],
            s = this.m_bodies[(i + 1) % o],
            r = n.GetWorldCenter(),
            a = s.GetWorldCenter();
        this.m_targetLengths[i] = box2d.b2DistanceVV(r, a), this.m_targetArea += box2d.b2CrossVV(r, a), e.Initialize(n, s, r, a), this.m_joints[i] = t.world.CreateJoint(e) } this.m_targetArea *= .5 }, goog.inherits(box2d.b2AreaJoint, box2d.b2Joint), box2d.b2AreaJoint.prototype.m_bodies = null, box2d.b2AreaJoint.prototype.m_frequencyHz = 0, box2d.b2AreaJoint.prototype.m_dampingRatio = 0, box2d.b2AreaJoint.prototype.m_impulse = 0, box2d.b2AreaJoint.prototype.m_targetLengths = null, box2d.b2AreaJoint.prototype.m_targetArea = 0, box2d.b2AreaJoint.prototype.m_normals = null, box2d.b2AreaJoint.prototype.m_joints = null, box2d.b2AreaJoint.prototype.m_deltas = null, box2d.b2AreaJoint.prototype.m_delta = null, box2d.b2AreaJoint.prototype.GetAnchorA = function(t) { return t.SetZero() }, box2d.b2AreaJoint.prototype.GetAnchorB = function(t) { return t.SetZero() }, box2d.b2AreaJoint.prototype.GetReactionForce = function(t, e) { return e.SetZero() }, box2d.b2AreaJoint.prototype.GetReactionTorque = function() { return 0 }, box2d.b2AreaJoint.prototype.SetFrequency = function(t) { this.m_frequencyHz = t; for (var e = 0, i = this.m_joints.length; i > e; ++e) this.m_joints[e].SetFrequency(t) }, box2d.b2AreaJoint.prototype.GetFrequency = function() { return this.m_frequencyHz }, box2d.b2AreaJoint.prototype.SetDampingRatio = function(t) { this.m_dampingRatio = t; for (var e = 0, i = this.m_joints.length; i > e; ++e) this.m_joints[e].SetDampingRatio(t) }, box2d.b2AreaJoint.prototype.GetDampingRatio = function() { return this.m_dampingRatio }, box2d.b2AreaJoint.prototype.Dump = function() { box2d.DEBUG && box2d.b2Log("Area joint dumping is not supported.\n") }, box2d.b2AreaJoint.prototype.InitVelocityConstraints = function(t) { for (var e = 0, i = this.m_bodies.length; i > e; ++e) { var o = this.m_bodies[(e + i - 1) % i],
            n = this.m_bodies[(e + 1) % i],
            s = t.positions[o.m_islandIndex].c,
            r = t.positions[n.m_islandIndex].c,
            a = this.m_deltas[e];
        box2d.b2SubVV(r, s, a) } if (t.step.warmStarting) { this.m_impulse *= t.step.dtRatio; for (var e = 0, i = this.m_bodies.length; i > e; ++e) { var h = this.m_bodies[e],
                l = t.velocities[h.m_islandIndex].v,
                a = this.m_deltas[e];
            l.x += h.m_invMass * a.y * .5 * this.m_impulse, l.y += h.m_invMass * -a.x * .5 * this.m_impulse } } else this.m_impulse = 0 }, box2d.b2AreaJoint.prototype.SolveVelocityConstraints = function(t) { for (var e = 0, i = 0, o = 0, n = this.m_bodies.length; n > o; ++o) { var s = this.m_bodies[o],
            r = t.velocities[s.m_islandIndex].v;
        e += (h = this.m_deltas[o]).GetLengthSquared() / s.GetMass(), i += box2d.b2CrossVV(r, h) } var a = -2 * i / e;
    this.m_impulse += a; for (var o = 0, n = this.m_bodies.length; n > o; ++o) { var s = this.m_bodies[o],
            r = t.velocities[s.m_islandIndex].v,
            h = this.m_deltas[o];
        r.x += s.m_invMass * h.y * .5 * a, r.y += s.m_invMass * -h.x * .5 * a } }, box2d.b2AreaJoint.prototype.SolvePositionConstraints = function(t) { for (var e = 0, i = 0, o = 0, n = this.m_bodies.length; n > o; ++o) { var s = this.m_bodies[o],
            r = this.m_bodies[(o + 1) % n],
            a = t.positions[s.m_islandIndex].c,
            h = t.positions[r.m_islandIndex].c,
            l = (p = box2d.b2SubVV(h, a, this.m_delta)).GetLength();
        l < box2d.b2_epsilon && (l = 1), this.m_normals[o].x = p.y / l, this.m_normals[o].y = -p.x / l, e += l, i += box2d.b2CrossVV(a, h) } i *= .5; for (var c = .5 * (this.m_targetArea - i) / e, d = !0, o = 0, n = this.m_bodies.length; n > o; ++o) { var s = this.m_bodies[o],
            a = t.positions[s.m_islandIndex].c,
            u = (o + 1) % n,
            p = box2d.b2AddVV(this.m_normals[o], this.m_normals[u], this.m_delta);
        p.SelfMul(c); var m = p.GetLengthSquared();
        m > box2d.b2Sq(box2d.b2_maxLinearCorrection) && p.SelfMul(box2d.b2_maxLinearCorrection / box2d.b2Sqrt(m)), m > box2d.b2Sq(box2d.b2_linearSlop) && (d = !1), a.x += p.x, a.y += p.y } return d }, goog.provide("box2d.b2BuoyancyController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), goog.require("box2d.b2WorldCallbacks"), box2d.b2BuoyancyController = function() { goog.base(this), this.normal = new box2d.b2Vec2(0, 1), this.velocity = new box2d.b2Vec2(0, 0), this.gravity = new box2d.b2Vec2(0, 0) }, goog.inherits(box2d.b2BuoyancyController, box2d.b2Controller), box2d.b2BuoyancyController.prototype.normal = null, box2d.b2BuoyancyController.prototype.offset = 0, box2d.b2BuoyancyController.prototype.density = 0, box2d.b2BuoyancyController.prototype.velocity = null, box2d.b2BuoyancyController.prototype.linearDrag = 0, box2d.b2BuoyancyController.prototype.angularDrag = 0, box2d.b2BuoyancyController.prototype.useDensity = !1, box2d.b2BuoyancyController.prototype.useWorldGravity = !0, box2d.b2BuoyancyController.prototype.gravity = null, box2d.b2BuoyancyController.prototype.Step = function() { if (this.m_bodyList) { this.useWorldGravity && this.gravity.Copy(this.GetWorld().GetGravity()); for (var t = this.m_bodyList; t; t = t.nextBody) { var e = t.body; if (!1 !== e.IsAwake()) { for (var i = new box2d.b2Vec2, o = new box2d.b2Vec2, n = 0, s = 0, r = e.GetFixtureList(); r; r = r.m_next) { var a = new box2d.b2Vec2,
                        h = r.GetShape().ComputeSubmergedArea(this.normal, this.offset, e.GetTransform(), a);
                    n += h, i.x += h * a.x, i.y += h * a.y; var l = 0;
                    s += h * (l = this.useDensity ? r.GetDensity() : 1), o.x += h * a.x * l, o.y += h * a.y * l } if (i.x /= n, i.y /= n, o.x /= s, o.y /= s, !(n < box2d.b2_epsilon)) { var c = box2d.b2NegV(this.gravity, new box2d.b2Vec2);
                    c.SelfMul(this.density * n), e.ApplyForce(c, o); var d = e.GetLinearVelocityFromWorldPoint(i, new box2d.b2Vec2);
                    d.SelfSub(this.velocity), d.SelfMul(-this.linearDrag * n), e.ApplyForce(d, i), e.ApplyTorque(-e.GetInertia() / e.GetMass() * n * e.GetAngularVelocity() * this.angularDrag) } } } } }, box2d.b2BuoyancyController.prototype.Draw = function(t) { var e = 100,
        i = new box2d.b2Vec2,
        o = new box2d.b2Vec2;
    i.x = this.normal.x * this.offset + this.normal.y * e, i.y = this.normal.y * this.offset - this.normal.x * e, o.x = this.normal.x * this.offset - this.normal.y * e, o.y = this.normal.y * this.offset + this.normal.x * e; var n = new box2d.b2Color(0, 0, .8);
    t.DrawSegment(i, o, n) }, goog.provide("box2d.b2TensorDampingController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), box2d.b2TensorDampingController = function() { goog.base(this), this.T = new box2d.b2Mat22, this.maxTimestep = 0 }, goog.inherits(box2d.b2TensorDampingController, box2d.b2Controller), box2d.b2TensorDampingController.prototype.T = new box2d.b2Mat22, box2d.b2TensorDampingController.prototype.maxTimestep = 0, box2d.b2TensorDampingController.prototype.Step = function(t) { var e = t.dt; if (!(e <= box2d.b2_epsilon)) { e > this.maxTimestep && this.maxTimestep > 0 && (e = this.maxTimestep); for (var i = this.m_bodyList; i; i = i.nextBody) { var o = i.body; if (o.IsAwake()) { var n = o.GetWorldVector(box2d.b2MulMV(this.T, o.GetLocalVector(o.GetLinearVelocity(), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1), box2d.b2TensorDampingController.prototype.Step.s_damping);
                o.SetLinearVelocity(box2d.b2AddVV(o.GetLinearVelocity(), box2d.b2MulSV(e, n, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t1)) } } } }, box2d.b2TensorDampingController.prototype.Step.s_damping = new box2d.b2Vec2, box2d.b2TensorDampingController.prototype.SetAxisAligned = function(t, e) { this.T.ex.x = -t, this.T.ex.y = 0, this.T.ey.x = 0, this.T.ey.y = -e, this.maxTimestep = t > 0 || e > 0 ? 1 / box2d.b2Max(t, e) : 0 }, goog.provide("box2d.b2DistanceJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2DistanceJointDef = function() { goog.base(this, box2d.b2JointType.e_distanceJoint), this.localAnchorA = new box2d.b2Vec2, this.localAnchorB = new box2d.b2Vec2 }, goog.inherits(box2d.b2DistanceJointDef, box2d.b2JointDef), box2d.b2DistanceJointDef.prototype.localAnchorA = null, box2d.b2DistanceJointDef.prototype.localAnchorB = null, box2d.b2DistanceJointDef.prototype.length = 1, box2d.b2DistanceJointDef.prototype.frequencyHz = 0, box2d.b2DistanceJointDef.prototype.dampingRatio = 0, box2d.b2DistanceJointDef.prototype.Initialize = function(t, e, i, o) { this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(o, this.localAnchorB), this.length = box2d.b2DistanceVV(i, o), this.frequencyHz = 0, this.dampingRatio = 0 }, box2d.b2DistanceJoint = function(t) { goog.base(this, t), this.m_u = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_length = t.length }, goog.inherits(box2d.b2DistanceJoint, box2d.b2Joint), box2d.b2DistanceJoint.prototype.m_frequencyHz = 0, box2d.b2DistanceJoint.prototype.m_dampingRatio = 0, box2d.b2DistanceJoint.prototype.m_bias = 0, box2d.b2DistanceJoint.prototype.m_localAnchorA = null, box2d.b2DistanceJoint.prototype.m_localAnchorB = null, box2d.b2DistanceJoint.prototype.m_gamma = 0, box2d.b2DistanceJoint.prototype.m_impulse = 0, box2d.b2DistanceJoint.prototype.m_length = 0, box2d.b2DistanceJoint.prototype.m_indexA = 0, box2d.b2DistanceJoint.prototype.m_indexB = 0, box2d.b2DistanceJoint.prototype.m_u = null, box2d.b2DistanceJoint.prototype.m_rA = null, box2d.b2DistanceJoint.prototype.m_rB = null, box2d.b2DistanceJoint.prototype.m_localCenterA = null, box2d.b2DistanceJoint.prototype.m_localCenterB = null, box2d.b2DistanceJoint.prototype.m_invMassA = 0, box2d.b2DistanceJoint.prototype.m_invMassB = 0, box2d.b2DistanceJoint.prototype.m_invIA = 0, box2d.b2DistanceJoint.prototype.m_invIB = 0, box2d.b2DistanceJoint.prototype.m_mass = 0, box2d.b2DistanceJoint.prototype.m_qA = null, box2d.b2DistanceJoint.prototype.m_qB = null, box2d.b2DistanceJoint.prototype.m_lalcA = null, box2d.b2DistanceJoint.prototype.m_lalcB = null, box2d.b2DistanceJoint.prototype.GetAnchorA = function(t) { return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t) }, box2d.b2DistanceJoint.prototype.GetAnchorB = function(t) { return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t) }, box2d.b2DistanceJoint.prototype.GetReactionForce = function(t, e) { return e.SetXY(t * this.m_impulse * this.m_u.x, t * this.m_impulse * this.m_u.y) }, box2d.b2DistanceJoint.prototype.GetReactionTorque = function() { return 0 }, box2d.b2DistanceJoint.prototype.GetLocalAnchorA = function(t) { return t.Copy(this.m_localAnchorA) }, box2d.b2DistanceJoint.prototype.GetLocalAnchorB = function(t) { return t.Copy(this.m_localAnchorB) }, box2d.b2DistanceJoint.prototype.SetLength = function(t) { this.m_length = t }, box2d.b2DistanceJoint.prototype.GetLength = function() { return this.m_length }, box2d.b2DistanceJoint.prototype.SetFrequency = function(t) { this.m_frequencyHz = t }, box2d.b2DistanceJoint.prototype.GetFrequency = function() { return this.m_frequencyHz }, box2d.b2DistanceJoint.prototype.SetDampingRatio = function(t) { this.m_dampingRatio = t }, box2d.b2DistanceJoint.prototype.GetDampingRatio = function() { return this.m_dampingRatio }, box2d.b2DistanceJoint.prototype.Dump = function() { if (box2d.DEBUG) { var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2DistanceJointDef*/ var jd = new box2d.b2DistanceJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.length = %.15f;\n", this.m_length), box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz), box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index) } }, box2d.b2DistanceJoint.prototype.InitVelocityConstraints = function(t) { this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI; var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        n = t.velocities[this.m_indexA].w,
        s = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        c = this.m_qB.SetAngleRadians(r);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(l, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(c, this.m_lalcB, this.m_rB), this.m_u.x = s.x + this.m_rB.x - e.x - this.m_rA.x, this.m_u.y = s.y + this.m_rB.y - e.y - this.m_rA.y; var d = this.m_u.GetLength();
    d > box2d.b2_linearSlop ? this.m_u.SelfMul(1 / d) : this.m_u.SetZero(); var u = box2d.b2CrossVV(this.m_rA, this.m_u),
        p = box2d.b2CrossVV(this.m_rB, this.m_u),
        m = this.m_invMassA + this.m_invIA * u * u + this.m_invMassB + this.m_invIB * p * p; if (this.m_mass = 0 !== m ? 1 / m : 0, this.m_frequencyHz > 0) { var f = d - this.m_length,
            y = 2 * box2d.b2_pi * this.m_frequencyHz,
            b = 2 * this.m_mass * this.m_dampingRatio * y,
            g = this.m_mass * y * y,
            _ = t.step.dt;
        this.m_gamma = _ * (b + _ * g), this.m_gamma = 0 !== this.m_gamma ? 1 / this.m_gamma : 0, this.m_bias = f * _ * g * this.m_gamma, m += this.m_gamma, this.m_mass = 0 !== m ? 1 / m : 0 } else this.m_gamma = 0, this.m_bias = 0; if (t.step.warmStarting) { this.m_impulse *= t.step.dtRatio; var v = box2d.b2MulSV(this.m_impulse, this.m_u, box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P);
        o.SelfMulSub(this.m_invMassA, v), n -= this.m_invIA * box2d.b2CrossVV(this.m_rA, v), a.SelfMulAdd(this.m_invMassB, v), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, v) } else this.m_impulse = 0;
    t.velocities[this.m_indexA].w = n, t.velocities[this.m_indexB].w = h }, box2d.b2DistanceJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints = function(t) { var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        n = t.velocities[this.m_indexB].w,
        s = box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA),
        r = box2d.b2AddVCrossSV(o, n, this.m_rB, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB),
        a = box2d.b2DotVV(this.m_u, box2d.b2SubVV(r, s, box2d.b2Vec2.s_t0)),
        h = -this.m_mass * (a + this.m_bias + this.m_gamma * this.m_impulse);
    this.m_impulse += h; var l = box2d.b2MulSV(h, this.m_u, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P);
    e.SelfMulSub(this.m_invMassA, l), i -= this.m_invIA * box2d.b2CrossVV(this.m_rA, l), o.SelfMulAdd(this.m_invMassB, l), n += this.m_invIB * box2d.b2CrossVV(this.m_rB, l), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = n }, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2, box2d.b2DistanceJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2DistanceJoint.prototype.SolvePositionConstraints = function(t) { if (this.m_frequencyHz > 0) return !0; var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        n = t.positions[this.m_indexB].a,
        s = (this.m_qA.SetAngleRadians(i), this.m_qB.SetAngleRadians(n), box2d.b2MulRV(this.m_qA, this.m_lalcA, this.m_rA)),
        r = box2d.b2MulRV(this.m_qB, this.m_lalcB, this.m_rB),
        a = this.m_u;
    a.x = o.x + r.x - e.x - s.x, a.y = o.y + r.y - e.y - s.y; var h = this.m_u.Normalize() - this.m_length;
    h = box2d.b2Clamp(h, -box2d.b2_maxLinearCorrection, box2d.b2_maxLinearCorrection); var l = -this.m_mass * h,
        c = box2d.b2MulSV(l, a, box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P); return e.SelfMulSub(this.m_invMassA, c), i -= this.m_invIA * box2d.b2CrossVV(s, c), o.SelfMulAdd(this.m_invMassB, c), n += this.m_invIB * box2d.b2CrossVV(r, c), t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = n, box2d.b2Abs(h) < box2d.b2_linearSlop }, box2d.b2DistanceJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, goog.provide("box2d.b2FrictionJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2FrictionJointDef = function() { goog.base(this, box2d.b2JointType.e_frictionJoint), this.localAnchorA = new box2d.b2Vec2, this.localAnchorB = new box2d.b2Vec2 }, goog.inherits(box2d.b2FrictionJointDef, box2d.b2JointDef), box2d.b2FrictionJointDef.prototype.localAnchorA = null, box2d.b2FrictionJointDef.prototype.localAnchorB = null, box2d.b2FrictionJointDef.prototype.maxForce = 0, box2d.b2FrictionJointDef.prototype.maxTorque = 0, box2d.b2FrictionJointDef.prototype.Initialize = function(t, e, i) { this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB) }, box2d.b2FrictionJoint = function(t) { goog.base(this, t), this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_linearImpulse = (new box2d.b2Vec2).SetZero(), this.m_maxForce = t.maxForce, this.m_maxTorque = t.maxTorque, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_linearMass = (new box2d.b2Mat22).SetZero(), this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_K = new box2d.b2Mat22 }, goog.inherits(box2d.b2FrictionJoint, box2d.b2Joint), box2d.b2FrictionJoint.prototype.m_localAnchorA = null, box2d.b2FrictionJoint.prototype.m_localAnchorB = null, box2d.b2FrictionJoint.prototype.m_linearImpulse = null, box2d.b2FrictionJoint.prototype.m_angularImpulse = 0, box2d.b2FrictionJoint.prototype.m_maxForce = 0, box2d.b2FrictionJoint.prototype.m_maxTorque = 0, box2d.b2FrictionJoint.prototype.m_indexA = 0, box2d.b2FrictionJoint.prototype.m_indexB = 0, box2d.b2FrictionJoint.prototype.m_rA = null, box2d.b2FrictionJoint.prototype.m_rB = null, box2d.b2FrictionJoint.prototype.m_localCenterA = null, box2d.b2FrictionJoint.prototype.m_localCenterB = null, box2d.b2FrictionJoint.prototype.m_invMassA = 0, box2d.b2FrictionJoint.prototype.m_invMassB = 0, box2d.b2FrictionJoint.prototype.m_invIA = 0, box2d.b2FrictionJoint.prototype.m_invIB = 0, box2d.b2FrictionJoint.prototype.m_linearMass = null, box2d.b2FrictionJoint.prototype.m_angularMass = 0, box2d.b2FrictionJoint.prototype.m_qA = null, box2d.b2FrictionJoint.prototype.m_qB = null, box2d.b2FrictionJoint.prototype.m_lalcA = null, box2d.b2FrictionJoint.prototype.m_lalcB = null, box2d.b2FrictionJoint.prototype.m_K = null, box2d.b2FrictionJoint.prototype.InitVelocityConstraints = function(t) { this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI; var e = t.positions[this.m_indexA].a,
        i = t.velocities[this.m_indexA].v,
        o = t.velocities[this.m_indexA].w,
        n = t.positions[this.m_indexB].a,
        s = t.velocities[this.m_indexB].v,
        r = t.velocities[this.m_indexB].w,
        a = this.m_qA.SetAngleRadians(e),
        h = this.m_qB.SetAngleRadians(n);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA); var l = box2d.b2MulRV(a, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB); var c = box2d.b2MulRV(h, this.m_lalcB, this.m_rB),
        d = this.m_invMassA,
        u = this.m_invMassB,
        p = this.m_invIA,
        m = this.m_invIB,
        f = this.m_K; if (f.ex.x = d + u + p * l.y * l.y + m * c.y * c.y, f.ex.y = -p * l.x * l.y - m * c.x * c.y, f.ey.x = f.ex.y, f.ey.y = d + u + p * l.x * l.x + m * c.x * c.x, f.GetInverse(this.m_linearMass), this.m_angularMass = p + m, this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass), t.step.warmStarting) { this.m_linearImpulse.SelfMul(t.step.dtRatio), this.m_angularImpulse *= t.step.dtRatio; var y = this.m_linearImpulse;
        i.SelfMulSub(d, y), o -= p * (box2d.b2CrossVV(this.m_rA, y) + this.m_angularImpulse), s.SelfMulAdd(u, y), r += m * (box2d.b2CrossVV(this.m_rB, y) + this.m_angularImpulse) } else this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0;
    t.velocities[this.m_indexA].w = o, t.velocities[this.m_indexB].w = r }, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints = function(t) { var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        n = t.velocities[this.m_indexB].w,
        s = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB,
        l = t.step.dt,
        c = n - i,
        d = -this.m_angularMass * c,
        u = this.m_angularImpulse,
        p = l * this.m_maxTorque;
    this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + d, -p, p), i -= a * (d = this.m_angularImpulse - u), n += h * d; var c = box2d.b2SubVV(box2d.b2AddVCrossSV(o, n, this.m_rB, box2d.b2Vec2.s_t0), box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2Vec2.s_t1), box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot),
        m = box2d.b2MulMV(this.m_linearMass, c, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV).SelfNeg(),
        f = box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV.Copy(this.m_linearImpulse);
    this.m_linearImpulse.SelfAdd(m);
    p = l * this.m_maxForce;
    this.m_linearImpulse.GetLengthSquared() > p * p && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.SelfMul(p)), box2d.b2SubVV(this.m_linearImpulse, f, m), e.SelfMulSub(s, m), i -= a * box2d.b2CrossVV(this.m_rA, m), o.SelfMulAdd(r, m), n += h * box2d.b2CrossVV(this.m_rB, m), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = n }, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_impulseV = new box2d.b2Vec2, box2d.b2FrictionJoint.prototype.SolveVelocityConstraints.s_oldImpulseV = new box2d.b2Vec2, box2d.b2FrictionJoint.prototype.SolvePositionConstraints = function() { return !0 }, box2d.b2FrictionJoint.prototype.GetAnchorA = function(t) { return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t) }, box2d.b2FrictionJoint.prototype.GetAnchorB = function(t) { return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t) }, box2d.b2FrictionJoint.prototype.GetReactionForce = function(t, e) { return e.SetXY(t * this.m_linearImpulse.x, t * this.m_linearImpulse.y) }, box2d.b2FrictionJoint.prototype.GetReactionTorque = function(t) { return t * this.m_angularImpulse }, box2d.b2FrictionJoint.prototype.GetLocalAnchorA = function(t) { return t.Copy(this.m_localAnchorA) }, box2d.b2FrictionJoint.prototype.GetLocalAnchorB = function(t) { return t.Copy(this.m_localAnchorB) }, box2d.b2FrictionJoint.prototype.SetMaxForce = function(t) { this.m_maxForce = t }, box2d.b2FrictionJoint.prototype.GetMaxForce = function() { return this.m_maxForce }, box2d.b2FrictionJoint.prototype.SetMaxTorque = function(t) { this.m_maxTorque = t }, box2d.b2FrictionJoint.prototype.GetMaxTorque = function() { return this.m_maxTorque }, box2d.b2FrictionJoint.prototype.Dump = function() { if (box2d.DEBUG) { var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2FrictionJointDef*/ var jd = new box2d.b2FrictionJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.maxForce = %.15f;\n", this.m_maxForce), box2d.b2Log("  jd.maxTorque = %.15f;\n", this.m_maxTorque), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index) } }, goog.provide("box2d.b2MouseJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2MouseJointDef = function() { goog.base(this, box2d.b2JointType.e_mouseJoint), this.target = new box2d.b2Vec2 }, goog.inherits(box2d.b2MouseJointDef, box2d.b2JointDef), box2d.b2MouseJointDef.prototype.target = null, box2d.b2MouseJointDef.prototype.maxForce = 0, box2d.b2MouseJointDef.prototype.frequencyHz = 5, box2d.b2MouseJointDef.prototype.dampingRatio = .7, box2d.b2MouseJoint = function(t) { goog.base(this, t), this.m_localAnchorB = new box2d.b2Vec2, this.m_targetA = new box2d.b2Vec2, this.m_impulse = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_mass = new box2d.b2Mat22, this.m_C = new box2d.b2Vec2, this.m_qB = new box2d.b2Rot, this.m_lalcB = new box2d.b2Vec2, this.m_K = new box2d.b2Mat22, box2d.ENABLE_ASSERTS && box2d.b2Assert(t.target.IsValid()), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.maxForce) && t.maxForce >= 0), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.frequencyHz) && t.frequencyHz >= 0), box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t.dampingRatio) && t.dampingRatio >= 0), this.m_targetA.Copy(t.target), box2d.b2MulTXV(this.m_bodyB.GetTransform(), this.m_targetA, this.m_localAnchorB), this.m_maxForce = t.maxForce, this.m_impulse.SetZero(), this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_beta = 0, this.m_gamma = 0 }, goog.inherits(box2d.b2MouseJoint, box2d.b2Joint), box2d.b2MouseJoint.prototype.m_localAnchorB = null, box2d.b2MouseJoint.prototype.m_targetA = null, box2d.b2MouseJoint.prototype.m_frequencyHz = 0, box2d.b2MouseJoint.prototype.m_dampingRatio = 0, box2d.b2MouseJoint.prototype.m_beta = 0, box2d.b2MouseJoint.prototype.m_impulse = null, box2d.b2MouseJoint.prototype.m_maxForce = 0, box2d.b2MouseJoint.prototype.m_gamma = 0, box2d.b2MouseJoint.prototype.m_indexA = 0, box2d.b2MouseJoint.prototype.m_indexB = 0, box2d.b2MouseJoint.prototype.m_rB = null, box2d.b2MouseJoint.prototype.m_localCenterB = null, box2d.b2MouseJoint.prototype.m_invMassB = 0, box2d.b2MouseJoint.prototype.m_invIB = 0, box2d.b2MouseJoint.prototype.m_mass = null, box2d.b2MouseJoint.prototype.m_C = null, box2d.b2MouseJoint.prototype.m_qB = null, box2d.b2MouseJoint.prototype.m_lalcB = null, box2d.b2MouseJoint.prototype.m_K = null, box2d.b2MouseJoint.prototype.SetTarget = function(t) {!1 === this.m_bodyB.IsAwake() && this.m_bodyB.SetAwake(!0), this.m_targetA.Copy(t) }, box2d.b2MouseJoint.prototype.GetTarget = function(t) { return t.Copy(this.m_targetA) }, box2d.b2MouseJoint.prototype.SetMaxForce = function(t) { this.m_maxForce = t }, box2d.b2MouseJoint.prototype.GetMaxForce = function() { return this.m_maxForce }, box2d.b2MouseJoint.prototype.SetFrequency = function(t) { this.m_frequencyHz = t }, box2d.b2MouseJoint.prototype.GetFrequency = function() { return this.m_frequencyHz }, box2d.b2MouseJoint.prototype.SetDampingRatio = function(t) { this.m_dampingRatio = t }, box2d.b2MouseJoint.prototype.GetDampingRatio = function() { return this.m_dampingRatio }, box2d.b2MouseJoint.prototype.InitVelocityConstraints = function(t) { this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIB = this.m_bodyB.m_invI; var e = t.positions[this.m_indexB].c,
        i = t.positions[this.m_indexB].a,
        o = t.velocities[this.m_indexB].v,
        n = t.velocities[this.m_indexB].w,
        s = this.m_qB.SetAngleRadians(i),
        r = this.m_bodyB.GetMass(),
        a = 2 * box2d.b2_pi * this.m_frequencyHz,
        h = 2 * r * this.m_dampingRatio * a,
        l = r * a * a,
        c = t.step.dt;
    box2d.ENABLE_ASSERTS && box2d.b2Assert(h + c * l > box2d.b2_epsilon), this.m_gamma = c * (h + c * l), 0 !== this.m_gamma && (this.m_gamma = 1 / this.m_gamma), this.m_beta = c * l * this.m_gamma, box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(s, this.m_lalcB, this.m_rB); var d = this.m_K;
    d.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma, d.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y, d.ey.x = d.ex.y, d.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma, d.GetInverse(this.m_mass), this.m_C.x = e.x + this.m_rB.x - this.m_targetA.x, this.m_C.y = e.y + this.m_rB.y - this.m_targetA.y, this.m_C.SelfMul(this.m_beta), n *= .98, t.step.warmStarting ? (this.m_impulse.SelfMul(t.step.dtRatio), o.x += this.m_invMassB * this.m_impulse.x, o.y += this.m_invMassB * this.m_impulse.y, n += this.m_invIB * box2d.b2CrossVV(this.m_rB, this.m_impulse)) : this.m_impulse.SetZero(), t.velocities[this.m_indexB].w = n }, box2d.b2MouseJoint.prototype.SolveVelocityConstraints = function(t) { var e = t.velocities[this.m_indexB].v,
        i = t.velocities[this.m_indexB].w,
        o = box2d.b2AddVCrossSV(e, i, this.m_rB, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot),
        n = box2d.b2MulMV(this.m_mass, box2d.b2AddVV(o, box2d.b2AddVV(this.m_C, box2d.b2MulSV(this.m_gamma, this.m_impulse, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0).SelfNeg(), box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse),
        s = box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_impulse);
    this.m_impulse.SelfAdd(n); var r = t.step.dt * this.m_maxForce;
    this.m_impulse.GetLengthSquared() > r * r && this.m_impulse.SelfMul(r / this.m_impulse.GetLength()), box2d.b2SubVV(this.m_impulse, s, n), e.SelfMulAdd(this.m_invMassB, n), i += this.m_invIB * box2d.b2CrossVV(this.m_rB, n), t.velocities[this.m_indexB].w = i }, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2, box2d.b2MouseJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2, box2d.b2MouseJoint.prototype.SolvePositionConstraints = function() { return !0 }, box2d.b2MouseJoint.prototype.GetAnchorA = function(t) { return t.Copy(this.m_targetA) }, box2d.b2MouseJoint.prototype.GetAnchorB = function(t) { return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t) }, box2d.b2MouseJoint.prototype.GetReactionForce = function(t, e) { return box2d.b2MulSV(t, this.m_impulse, e) }, box2d.b2MouseJoint.prototype.GetReactionTorque = function() { return 0 }, box2d.b2MouseJoint.prototype.Dump = function() { box2d.DEBUG && box2d.b2Log("Mouse joint dumping is not supported.\n") }, box2d.b2MouseJoint.prototype.ShiftOrigin = function(t) { this.m_targetA.SelfSub(t) }, goog.provide("box2d.b2ConstantForceController"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Controller"), goog.require("box2d.b2Math"), box2d.b2ConstantForceController = function() { goog.base(this), this.F = new box2d.b2Vec2(0, 0) }, goog.inherits(box2d.b2ConstantForceController, box2d.b2Controller), box2d.b2ConstantAccelController.prototype.F = null, box2d.b2ConstantForceController.prototype.Step = function() { for (var t = this.m_bodyList; t; t = t.nextBody) { var e = t.body;
        e.IsAwake() && e.ApplyForce(this.F, e.GetWorldCenter()) } }, goog.provide("box2d.b2PulleyJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Joint"), goog.require("box2d.b2Math"), box2d.b2_minPulleyLength = 2, box2d.b2PulleyJointDef = function() { goog.base(this, box2d.b2JointType.e_pulleyJoint), this.collideConnected = !0, this.groundAnchorA = new box2d.b2Vec2(-1, 1), this.groundAnchorB = new box2d.b2Vec2(1, 1), this.localAnchorA = new box2d.b2Vec2(-1, 0), this.localAnchorB = new box2d.b2Vec2(1, 0) }, goog.inherits(box2d.b2PulleyJointDef, box2d.b2JointDef), box2d.b2PulleyJointDef.prototype.groundAnchorA = null, box2d.b2PulleyJointDef.prototype.groundAnchorB = null, box2d.b2PulleyJointDef.prototype.localAnchorA = null, box2d.b2PulleyJointDef.prototype.localAnchorB = null, box2d.b2PulleyJointDef.prototype.lengthA = 0, box2d.b2PulleyJointDef.prototype.lengthB = 0, box2d.b2PulleyJointDef.prototype.ratio = 1, box2d.b2PulleyJointDef.prototype.Initialize = function(t, e, i, o, n, s, r) { this.bodyA = t, this.bodyB = e, this.groundAnchorA.Copy(i), this.groundAnchorB.Copy(o), this.bodyA.GetLocalPoint(n, this.localAnchorA), this.bodyB.GetLocalPoint(s, this.localAnchorB), this.lengthA = box2d.b2DistanceVV(n, i), this.lengthB = box2d.b2DistanceVV(s, o), this.ratio = r, box2d.ENABLE_ASSERTS && box2d.b2Assert(this.ratio > box2d.b2_epsilon) }, box2d.b2PulleyJoint = function(t) { goog.base(this, t), this.m_groundAnchorA = new box2d.b2Vec2, this.m_groundAnchorB = new box2d.b2Vec2, this.m_localAnchorA = new box2d.b2Vec2, this.m_localAnchorB = new box2d.b2Vec2, this.m_uA = new box2d.b2Vec2, this.m_uB = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_groundAnchorA.Copy(t.groundAnchorA), this.m_groundAnchorB.Copy(t.groundAnchorB), this.m_localAnchorA.Copy(t.localAnchorA), this.m_localAnchorB.Copy(t.localAnchorB), this.m_lengthA = t.lengthA, this.m_lengthB = t.lengthB, box2d.ENABLE_ASSERTS && box2d.b2Assert(0 !== t.ratio), this.m_ratio = t.ratio, this.m_constant = t.lengthA + this.m_ratio * t.lengthB, this.m_impulse = 0 }, goog.inherits(box2d.b2PulleyJoint, box2d.b2Joint), box2d.b2PulleyJoint.prototype.m_groundAnchorA = null, box2d.b2PulleyJoint.prototype.m_groundAnchorB = null, box2d.b2PulleyJoint.prototype.m_lengthA = 0, box2d.b2PulleyJoint.prototype.m_lengthB = 0, box2d.b2PulleyJoint.prototype.m_localAnchorA = null, box2d.b2PulleyJoint.prototype.m_localAnchorB = null, box2d.b2PulleyJoint.prototype.m_constant = 0, box2d.b2PulleyJoint.prototype.m_ratio = 0, box2d.b2PulleyJoint.prototype.m_impulse = 0, box2d.b2PulleyJoint.prototype.m_indexA = 0, box2d.b2PulleyJoint.prototype.m_indexB = 0, box2d.b2PulleyJoint.prototype.m_uA = null, box2d.b2PulleyJoint.prototype.m_uB = null, box2d.b2PulleyJoint.prototype.m_rA = null, box2d.b2PulleyJoint.prototype.m_rB = null, box2d.b2PulleyJoint.prototype.m_localCenterA = null, box2d.b2PulleyJoint.prototype.m_localCenterB = null, box2d.b2PulleyJoint.prototype.m_invMassA = 0, box2d.b2PulleyJoint.prototype.m_invMassB = 0, box2d.b2PulleyJoint.prototype.m_invIA = 0, box2d.b2PulleyJoint.prototype.m_invIB = 0, box2d.b2PulleyJoint.prototype.m_mass = 0, box2d.b2PulleyJoint.prototype.m_qA = null, box2d.b2PulleyJoint.prototype.m_qB = null, box2d.b2PulleyJoint.prototype.m_lalcA = null, box2d.b2PulleyJoint.prototype.m_lalcB = null, box2d.b2PulleyJoint.prototype.InitVelocityConstraints = function(t) { this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI; var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        n = t.velocities[this.m_indexA].w,
        s = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        c = this.m_qB.SetAngleRadians(r);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA), box2d.b2MulRV(l, this.m_lalcA, this.m_rA), box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB), box2d.b2MulRV(c, this.m_lalcB, this.m_rB), this.m_uA.Copy(e).SelfAdd(this.m_rA).SelfSub(this.m_groundAnchorA), this.m_uB.Copy(s).SelfAdd(this.m_rB).SelfSub(this.m_groundAnchorB); var d = this.m_uA.GetLength(),
        u = this.m_uB.GetLength();
    d > 10 * box2d.b2_linearSlop ? this.m_uA.SelfMul(1 / d) : this.m_uA.SetZero(), u > 10 * box2d.b2_linearSlop ? this.m_uB.SelfMul(1 / u) : this.m_uB.SetZero(); var p = box2d.b2CrossVV(this.m_rA, this.m_uA),
        m = box2d.b2CrossVV(this.m_rB, this.m_uB),
        f = this.m_invMassA + this.m_invIA * p * p,
        y = this.m_invMassB + this.m_invIB * m * m; if (this.m_mass = f + this.m_ratio * this.m_ratio * y, this.m_mass > 0 && (this.m_mass = 1 / this.m_mass), t.step.warmStarting) { this.m_impulse *= t.step.dtRatio; var b = box2d.b2MulSV(-this.m_impulse, this.m_uA, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA),
            g = box2d.b2MulSV(-this.m_ratio * this.m_impulse, this.m_uB, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB);
        o.SelfMulAdd(this.m_invMassA, b), n += this.m_invIA * box2d.b2CrossVV(this.m_rA, b), a.SelfMulAdd(this.m_invMassB, g), h += this.m_invIB * box2d.b2CrossVV(this.m_rB, g) } else this.m_impulse = 0;
    t.velocities[this.m_indexA].w = n, t.velocities[this.m_indexB].w = h }, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PA = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.InitVelocityConstraints.s_PB = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints = function(t) { var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        n = t.velocities[this.m_indexB].w,
        s = box2d.b2AddVCrossSV(e, i, this.m_rA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA),
        r = box2d.b2AddVCrossSV(o, n, this.m_rB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB),
        a = -box2d.b2DotVV(this.m_uA, s) - this.m_ratio * box2d.b2DotVV(this.m_uB, r),
        h = -this.m_mass * a;
    this.m_impulse += h; var l = box2d.b2MulSV(-h, this.m_uA, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA),
        c = box2d.b2MulSV(-this.m_ratio * h, this.m_uB, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB);
    e.SelfMulAdd(this.m_invMassA, l), i += this.m_invIA * box2d.b2CrossVV(this.m_rA, l), o.SelfMulAdd(this.m_invMassB, c), n += this.m_invIB * box2d.b2CrossVV(this.m_rB, c), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = n }, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpA = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_vpB = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PA = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolveVelocityConstraints.s_PB = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolvePositionConstraints = function(t) { var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        n = t.positions[this.m_indexB].a,
        s = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(n);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA); var a = box2d.b2MulRV(s, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB); var h = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        l = this.m_uA.Copy(e).SelfAdd(a).SelfSub(this.m_groundAnchorA),
        c = this.m_uB.Copy(o).SelfAdd(h).SelfSub(this.m_groundAnchorB),
        d = l.GetLength(),
        u = c.GetLength();
    d > 10 * box2d.b2_linearSlop ? l.SelfMul(1 / d) : l.SetZero(), u > 10 * box2d.b2_linearSlop ? c.SelfMul(1 / u) : c.SetZero(); var p = box2d.b2CrossVV(a, l),
        m = box2d.b2CrossVV(h, c),
        f = this.m_invMassA + this.m_invIA * p * p,
        y = this.m_invMassB + this.m_invIB * m * m,
        b = f + this.m_ratio * this.m_ratio * y;
    b > 0 && (b = 1 / b); var g = this.m_constant - d - this.m_ratio * u,
        _ = box2d.b2Abs(g),
        v = -b * g,
        x = box2d.b2MulSV(-v, l, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA),
        S = box2d.b2MulSV(-this.m_ratio * v, c, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB); return e.SelfMulAdd(this.m_invMassA, x), i += this.m_invIA * box2d.b2CrossVV(a, x), o.SelfMulAdd(this.m_invMassB, S), n += this.m_invIB * box2d.b2CrossVV(h, S), t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = n, _ < box2d.b2_linearSlop }, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PA = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.SolvePositionConstraints.s_PB = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.GetAnchorA = function(t) { return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t) }, box2d.b2PulleyJoint.prototype.GetAnchorB = function(t) { return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t) }, box2d.b2PulleyJoint.prototype.GetReactionForce = function(t, e) { return e.SetXY(t * this.m_impulse * this.m_uB.x, t * this.m_impulse * this.m_uB.y) }, box2d.b2PulleyJoint.prototype.GetReactionTorque = function() { return 0 }, box2d.b2PulleyJoint.prototype.GetGroundAnchorA = function(t) { return t.Copy(this.m_groundAnchorA) }, box2d.b2PulleyJoint.prototype.GetGroundAnchorB = function(t) { return t.Copy(this.m_groundAnchorB) }, box2d.b2PulleyJoint.prototype.GetLengthA = function() { return this.m_lengthA }, box2d.b2PulleyJoint.prototype.GetLengthB = function() { return this.m_lengthB }, box2d.b2PulleyJoint.prototype.GetRatio = function() { return this.m_ratio }, box2d.b2PulleyJoint.prototype.GetCurrentLengthA = function() { var t = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p),
        e = this.m_groundAnchorA; return box2d.b2DistanceVV(t, e) }, box2d.b2PulleyJoint.prototype.GetCurrentLengthA.s_p = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.GetCurrentLengthB = function() { var t = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p),
        e = this.m_groundAnchorB; return box2d.b2DistanceVV(t, e) }, box2d.b2PulleyJoint.prototype.GetCurrentLengthB.s_p = new box2d.b2Vec2, box2d.b2PulleyJoint.prototype.Dump = function() { if (box2d.DEBUG) { var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2PulleyJointDef*/ var jd = new box2d.b2PulleyJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.groundAnchorA.SetXY(%.15f, %.15f);\n", this.m_groundAnchorA.x, this.m_groundAnchorA.y), box2d.b2Log("  jd.groundAnchorB.SetXY(%.15f, %.15f);\n", this.m_groundAnchorB.x, this.m_groundAnchorB.y), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.lengthA = %.15f;\n", this.m_lengthA), box2d.b2Log("  jd.lengthB = %.15f;\n", this.m_lengthB), box2d.b2Log("  jd.ratio = %.15f;\n", this.m_ratio), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index) } }, box2d.b2PulleyJoint.prototype.ShiftOrigin = function(t) { this.m_groundAnchorA.SelfSub(t), this.m_groundAnchorB.SelfSub(t) }, goog.provide("box2d.b2CircleShape"), goog.require("box2d.b2Shape"), box2d.b2CircleShape = function(t) { goog.base(this, box2d.b2ShapeType.e_circleShape, t || 0), this.m_p = new box2d.b2Vec2 }, goog.inherits(box2d.b2CircleShape, box2d.b2Shape), box2d.b2CircleShape.prototype.m_p = null, box2d.b2CircleShape.prototype.Clone = function() { return (new box2d.b2CircleShape).Copy(this) }, box2d.b2CircleShape.prototype.Copy = function(t) { return goog.base(this, "Copy", t), box2d.ENABLE_ASSERTS && box2d.b2Assert(t instanceof box2d.b2CircleShape), this.m_p.Copy(t.m_p), this }, box2d.b2CircleShape.prototype.GetChildCount = function() { return 1 }, box2d.b2CircleShape.prototype.TestPoint = function(t, e) { var i = box2d.b2MulXV(t, this.m_p, box2d.b2CircleShape.prototype.TestPoint.s_center),
        o = box2d.b2SubVV(e, i, box2d.b2CircleShape.prototype.TestPoint.s_d); return box2d.b2DotVV(o, o) <= box2d.b2Sq(this.m_radius) }, box2d.b2CircleShape.prototype.TestPoint.s_center = new box2d.b2Vec2, box2d.b2CircleShape.prototype.TestPoint.s_d = new box2d.b2Vec2, box2d.b2CircleShape.prototype.RayCast = function(t, e, i) { var o = box2d.b2MulXV(i, this.m_p, box2d.b2CircleShape.prototype.RayCast.s_position),
        n = box2d.b2SubVV(e.p1, o, box2d.b2CircleShape.prototype.RayCast.s_s),
        s = box2d.b2DotVV(n, n) - box2d.b2Sq(this.m_radius),
        r = box2d.b2SubVV(e.p2, e.p1, box2d.b2CircleShape.prototype.RayCast.s_r),
        a = box2d.b2DotVV(n, r),
        h = box2d.b2DotVV(r, r),
        l = a * a - h * s; if (0 > l || h < box2d.b2_epsilon) return !1; var c = -(a + box2d.b2Sqrt(l)); return c >= 0 && c <= e.maxFraction * h && (c /= h, t.fraction = c, box2d.b2AddVMulSV(n, c, r, t.normal).SelfNormalize(), !0) }, box2d.b2CircleShape.prototype.RayCast.s_position = new box2d.b2Vec2, box2d.b2CircleShape.prototype.RayCast.s_s = new box2d.b2Vec2, box2d.b2CircleShape.prototype.RayCast.s_r = new box2d.b2Vec2, box2d.b2CircleShape.prototype.ComputeAABB = function(t, e) { var i = box2d.b2MulXV(e, this.m_p, box2d.b2CircleShape.prototype.ComputeAABB.s_p);
    t.lowerBound.SetXY(i.x - this.m_radius, i.y - this.m_radius), t.upperBound.SetXY(i.x + this.m_radius, i.y + this.m_radius) }, box2d.b2CircleShape.prototype.ComputeAABB.s_p = new box2d.b2Vec2, box2d.b2CircleShape.prototype.ComputeMass = function(t, e) { var i = box2d.b2Sq(this.m_radius);
    t.mass = e * box2d.b2_pi * i, t.center.Copy(this.m_p), t.I = t.mass * (.5 * i + box2d.b2DotVV(this.m_p, this.m_p)) }, box2d.b2CircleShape.prototype.SetupDistanceProxy = function(t) { t.m_vertices = new Array(1, !0), t.m_vertices[0] = this.m_p, t.m_count = 1, t.m_radius = this.m_radius }, box2d.b2CircleShape.prototype.ComputeSubmergedArea = function(t, e, i, o) { var n = box2d.b2MulXV(i, this.m_p, new box2d.b2Vec2),
        s = -(box2d.b2DotVV(t, n) - e); if (s < -this.m_radius + box2d.b2_epsilon) return 0; if (s > this.m_radius) return o.Copy(n), box2d.b2_pi * this.m_radius * this.m_radius; var r = this.m_radius * this.m_radius,
        a = s * s,
        h = r * (box2d.b2Asin(s / this.m_radius) + box2d.b2_pi / 2) + s * box2d.b2Sqrt(r - a),
        l = -2 / 3 * box2d.b2Pow(r - a, 1.5) / h; return o.x = n.x + t.x * l, o.y = n.y + t.y * l, h }, box2d.b2CircleShape.prototype.Dump = function() { box2d.b2Log("    /*box2d.b2CircleShape*/ var shape = new box2d.b2CircleShape();\n"), box2d.b2Log("    shape.m_radius = %.15f;\n", this.m_radius), box2d.b2Log("    shape.m_p.SetXY(%.15f, %.15f);\n", this.m_p.x, this.m_p.y) }, goog.provide("box2d.b2Rope"), goog.require("box2d.b2Math"), goog.require("box2d.b2Draw"), box2d.b2RopeDef = function() { this.vertices = new Array, this.masses = new Array, this.gravity = new box2d.b2Vec2 }, box2d.b2RopeDef.prototype.vertices = null, box2d.b2RopeDef.prototype.count = 0, box2d.b2RopeDef.prototype.masses = null, box2d.b2RopeDef.prototype.gravity = null, box2d.b2RopeDef.prototype.damping = .1, box2d.b2RopeDef.prototype.k2 = .9, box2d.b2RopeDef.prototype.k3 = .1, box2d.b2Rope = function() { this.m_gravity = new box2d.b2Vec2 }, box2d.b2Rope.prototype.m_count = 0, box2d.b2Rope.prototype.m_ps = null, box2d.b2Rope.prototype.m_p0s = null, box2d.b2Rope.prototype.m_vs = null, box2d.b2Rope.prototype.m_ims = null, box2d.b2Rope.prototype.m_Ls = null, box2d.b2Rope.prototype.m_as = null, box2d.b2Rope.prototype.m_gravity = null, box2d.b2Rope.prototype.m_damping = 0, box2d.b2Rope.prototype.m_k2 = 1, box2d.b2Rope.prototype.m_k3 = .1, box2d.b2Rope.prototype.GetVertexCount = function() { return this.m_count }, box2d.b2Rope.prototype.GetVertices = function() { return this.m_ps }, box2d.b2Rope.prototype.Initialize = function(t) { box2d.ENABLE_ASSERTS && box2d.b2Assert(t.count >= 3), this.m_count = t.count, this.m_ps = box2d.b2Vec2.MakeArray(this.m_count), this.m_p0s = box2d.b2Vec2.MakeArray(this.m_count), this.m_vs = box2d.b2Vec2.MakeArray(this.m_count), this.m_ims = box2d.b2MakeNumberArray(this.m_count); for (r = 0; r < this.m_count; ++r) { this.m_ps[r].Copy(t.vertices[r]), this.m_p0s[r].Copy(t.vertices[r]), this.m_vs[r].SetZero(); var e = t.masses[r];
        this.m_ims[r] = e > 0 ? 1 / e : 0 } var i = this.m_count - 1,
        o = this.m_count - 2;
    this.m_Ls = box2d.b2MakeNumberArray(i), this.m_as = box2d.b2MakeNumberArray(o); for (r = 0; i > r; ++r) { var n = this.m_ps[r],
            s = this.m_ps[r + 1];
        this.m_Ls[r] = box2d.b2DistanceVV(n, s) } for (var r = 0; o > r; ++r) { var n = this.m_ps[r],
            s = this.m_ps[r + 1],
            a = this.m_ps[r + 2],
            h = box2d.b2SubVV(s, n, box2d.b2Vec2.s_t0),
            l = box2d.b2SubVV(a, s, box2d.b2Vec2.s_t1),
            c = box2d.b2CrossVV(h, l),
            d = box2d.b2DotVV(h, l);
        this.m_as[r] = box2d.b2Atan2(c, d) } this.m_gravity.Copy(t.gravity), this.m_damping = t.damping, this.m_k2 = t.k2, this.m_k3 = t.k3 }, box2d.b2Rope.prototype.Step = function(t, e) { if (0 !== t) { for (var i = Math.exp(-t * this.m_damping), o = 0; o < this.m_count; ++o) this.m_p0s[o].Copy(this.m_ps[o]), this.m_ims[o] > 0 && this.m_vs[o].SelfMulAdd(t, this.m_gravity), this.m_vs[o].SelfMul(i), this.m_ps[o].SelfMulAdd(t, this.m_vs[o]); for (o = 0; e > o; ++o) this.SolveC2(), this.SolveC3(), this.SolveC2(); for (var n = 1 / t, o = 0; o < this.m_count; ++o) box2d.b2MulSV(n, box2d.b2SubVV(this.m_ps[o], this.m_p0s[o], box2d.b2Vec2.s_t0), this.m_vs[o]) } }, box2d.b2Rope.prototype.SolveC2 = function() { for (var t = this.m_count - 1, e = 0; t > e; ++e) { var i = this.m_ps[e],
            o = this.m_ps[e + 1],
            n = box2d.b2SubVV(o, i, box2d.b2Rope.s_d),
            s = n.Normalize(),
            r = this.m_ims[e],
            a = this.m_ims[e + 1]; if (r + a !== 0) { var h = r / (r + a),
                l = a / (r + a);
            i.SelfMulSub(this.m_k2 * h * (this.m_Ls[e] - s), n), o.SelfMulAdd(this.m_k2 * l * (this.m_Ls[e] - s), n) } } }, box2d.b2Rope.s_d = new box2d.b2Vec2, box2d.b2Rope.prototype.SetAngleRadians = function(t) { for (var e = this.m_count - 2, i = 0; e > i; ++i) this.m_as[i] = t }, box2d.b2Rope.prototype.SolveC3 = function() { for (var t = this.m_count - 2, e = 0; t > e; ++e) { var i = this.m_ps[e],
            o = this.m_ps[e + 1],
            n = this.m_ps[e + 2],
            s = this.m_ims[e],
            r = this.m_ims[e + 1],
            a = this.m_ims[e + 2],
            h = box2d.b2SubVV(o, i, box2d.b2Rope.s_d1),
            l = box2d.b2SubVV(n, o, box2d.b2Rope.s_d2),
            c = h.GetLengthSquared(),
            d = l.GetLengthSquared(); if (c * d != 0) { var u = box2d.b2CrossVV(h, l),
                p = box2d.b2DotVV(h, l),
                m = box2d.b2Atan2(u, p),
                f = box2d.b2MulSV(-1 / c, h.SelfSkew(), box2d.b2Rope.s_Jd1),
                y = box2d.b2MulSV(1 / d, l.SelfSkew(), box2d.b2Rope.s_Jd2),
                b = box2d.b2NegV(f, box2d.b2Rope.s_J1),
                g = box2d.b2SubVV(f, y, box2d.b2Rope.s_J2),
                _ = y,
                v = s * box2d.b2DotVV(b, b) + r * box2d.b2DotVV(g, g) + a * box2d.b2DotVV(_, _); if (0 !== v) { v = 1 / v; for (var x = m - this.m_as[e]; x > box2d.b2_pi;) m -= 2 * box2d.b2_pi, x = m - this.m_as[e]; for (; x < -box2d.b2_pi;) m += 2 * box2d.b2_pi, x = m - this.m_as[e]; var S = -this.m_k3 * v * x;
                i.SelfMulAdd(s * S, b), o.SelfMulAdd(r * S, g), n.SelfMulAdd(a * S, _) } } } }, box2d.b2Rope.s_d1 = new box2d.b2Vec2, box2d.b2Rope.s_d2 = new box2d.b2Vec2, box2d.b2Rope.s_Jd1 = new box2d.b2Vec2, box2d.b2Rope.s_Jd2 = new box2d.b2Vec2, box2d.b2Rope.s_J1 = new box2d.b2Vec2, box2d.b2Rope.s_J2 = new box2d.b2Vec2, box2d.b2Rope.prototype.Draw = function(t) { for (var e = new box2d.b2Color(.4, .5, .7), i = 0; i < this.m_count - 1; ++i) t.DrawSegment(this.m_ps[i], this.m_ps[i + 1], e) }, goog.provide("box2d.b2WheelJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), box2d.b2WheelJointDef = function() { goog.base(this, box2d.b2JointType.e_wheelJoint), this.localAnchorA = new box2d.b2Vec2(0, 0), this.localAnchorB = new box2d.b2Vec2(0, 0), this.localAxisA = new box2d.b2Vec2(1, 0) }, goog.inherits(box2d.b2WheelJointDef, box2d.b2JointDef), box2d.b2WheelJointDef.prototype.localAnchorA = null, box2d.b2WheelJointDef.prototype.localAnchorB = null, box2d.b2WheelJointDef.prototype.localAxisA = null, box2d.b2WheelJointDef.prototype.enableMotor = !1, box2d.b2WheelJointDef.prototype.maxMotorTorque = 0, box2d.b2WheelJointDef.prototype.motorSpeed = 0, box2d.b2WheelJointDef.prototype.frequencyHz = 2, box2d.b2WheelJointDef.prototype.dampingRatio = .7, box2d.b2WheelJointDef.prototype.Initialize = function(t, e, i, o) { this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(i, this.localAnchorA), this.bodyB.GetLocalPoint(i, this.localAnchorB), this.bodyA.GetLocalVector(o, this.localAxisA) }, box2d.b2WheelJoint = function(t) { goog.base(this, t), this.m_frequencyHz = t.frequencyHz, this.m_dampingRatio = t.dampingRatio, this.m_localAnchorA = t.localAnchorA.Clone(), this.m_localAnchorB = t.localAnchorB.Clone(), this.m_localXAxisA = t.localAxisA.Clone(), this.m_localYAxisA = box2d.b2CrossOneV(this.m_localXAxisA, new box2d.b2Vec2), this.m_maxMotorTorque = t.maxMotorTorque, this.m_motorSpeed = t.motorSpeed, this.m_enableMotor = t.enableMotor, this.m_localCenterA = new box2d.b2Vec2, this.m_localCenterB = new box2d.b2Vec2, this.m_ax = new box2d.b2Vec2, this.m_ay = new box2d.b2Vec2, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_lalcA = new box2d.b2Vec2, this.m_lalcB = new box2d.b2Vec2, this.m_rA = new box2d.b2Vec2, this.m_rB = new box2d.b2Vec2, this.m_ax.SetZero(), this.m_ay.SetZero() }, goog.inherits(box2d.b2WheelJoint, box2d.b2Joint), box2d.b2WheelJoint.prototype.m_frequencyHz = 0, box2d.b2WheelJoint.prototype.m_dampingRatio = 0, box2d.b2WheelJoint.prototype.m_localAnchorA = null, box2d.b2WheelJoint.prototype.m_localAnchorB = null, box2d.b2WheelJoint.prototype.m_localXAxisA = null, box2d.b2WheelJoint.prototype.m_localYAxisA = null, box2d.b2WheelJoint.prototype.m_impulse = 0, box2d.b2WheelJoint.prototype.m_motorImpulse = 0, box2d.b2WheelJoint.prototype.m_springImpulse = 0, box2d.b2WheelJoint.prototype.m_maxMotorTorque = 0, box2d.b2WheelJoint.prototype.m_motorSpeed = 0, box2d.b2WheelJoint.prototype.m_enableMotor = !1, box2d.b2WheelJoint.prototype.m_indexA = 0, box2d.b2WheelJoint.prototype.m_indexB = 0, box2d.b2WheelJoint.prototype.m_localCenterA = null, box2d.b2WheelJoint.prototype.m_localCenterB = null, box2d.b2WheelJoint.prototype.m_invMassA = 0, box2d.b2WheelJoint.prototype.m_invMassB = 0, box2d.b2WheelJoint.prototype.m_invIA = 0, box2d.b2WheelJoint.prototype.m_invIB = 0, box2d.b2WheelJoint.prototype.m_ax = null, box2d.b2WheelJoint.prototype.m_ay = null, box2d.b2WheelJoint.prototype.m_sAx = 0, box2d.b2WheelJoint.prototype.m_sBx = 0, box2d.b2WheelJoint.prototype.m_sAy = 0, box2d.b2WheelJoint.prototype.m_sBy = 0, box2d.b2WheelJoint.prototype.m_mass = 0, box2d.b2WheelJoint.prototype.m_motorMass = 0, box2d.b2WheelJoint.prototype.m_springMass = 0, box2d.b2WheelJoint.prototype.m_bias = 0, box2d.b2WheelJoint.prototype.m_gamma = 0, box2d.b2WheelJoint.prototype.m_qA = null, box2d.b2WheelJoint.prototype.m_qB = null, box2d.b2WheelJoint.prototype.m_lalcA = null, box2d.b2WheelJoint.prototype.m_lalcB = null, box2d.b2WheelJoint.prototype.m_rA = null, box2d.b2WheelJoint.prototype.m_rB = null, box2d.b2WheelJoint.prototype.GetMotorSpeed = function() { return this.m_motorSpeed }, box2d.b2WheelJoint.prototype.GetMaxMotorTorque = function() { return this.m_maxMotorTorque }, box2d.b2WheelJoint.prototype.SetSpringFrequencyHz = function(t) { this.m_frequencyHz = t }, box2d.b2WheelJoint.prototype.GetSpringFrequencyHz = function() { return this.m_frequencyHz }, box2d.b2WheelJoint.prototype.SetSpringDampingRatio = function(t) { this.m_dampingRatio = t }, box2d.b2WheelJoint.prototype.GetSpringDampingRatio = function() { return this.m_dampingRatio }, box2d.b2WheelJoint.prototype.InitVelocityConstraints = function(t) { this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI; var e = this.m_invMassA,
        i = this.m_invMassB,
        o = this.m_invIA,
        n = this.m_invIB,
        s = t.positions[this.m_indexA].c,
        r = t.positions[this.m_indexA].a,
        a = t.velocities[this.m_indexA].v,
        h = t.velocities[this.m_indexA].w,
        l = t.positions[this.m_indexB].c,
        c = t.positions[this.m_indexB].a,
        d = t.velocities[this.m_indexB].v,
        u = t.velocities[this.m_indexB].w,
        p = this.m_qA.SetAngleRadians(r),
        m = this.m_qB.SetAngleRadians(c);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA); var f = box2d.b2MulRV(p, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB); var y = box2d.b2MulRV(m, this.m_lalcB, this.m_rB),
        b = box2d.b2SubVV(box2d.b2AddVV(l, y, box2d.b2Vec2.s_t0), box2d.b2AddVV(s, f, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d); if (box2d.b2MulRV(p, this.m_localYAxisA, this.m_ay), this.m_sAy = box2d.b2CrossVV(box2d.b2AddVV(b, f, box2d.b2Vec2.s_t0), this.m_ay), this.m_sBy = box2d.b2CrossVV(y, this.m_ay), this.m_mass = e + i + o * this.m_sAy * this.m_sAy + n * this.m_sBy * this.m_sBy, this.m_mass > 0 && (this.m_mass = 1 / this.m_mass), this.m_springMass = 0, this.m_bias = 0, this.m_gamma = 0, this.m_frequencyHz > 0) { box2d.b2MulRV(p, this.m_localXAxisA, this.m_ax), this.m_sAx = box2d.b2CrossVV(box2d.b2AddVV(b, f, box2d.b2Vec2.s_t0), this.m_ax), this.m_sBx = box2d.b2CrossVV(y, this.m_ax); var g = e + i + o * this.m_sAx * this.m_sAx + n * this.m_sBx * this.m_sBx; if (g > 0) { this.m_springMass = 1 / g; var _ = box2d.b2DotVV(b, this.m_ax),
                v = 2 * box2d.b2_pi * this.m_frequencyHz,
                x = 2 * this.m_springMass * this.m_dampingRatio * v,
                S = this.m_springMass * v * v,
                C = t.step.dt;
            this.m_gamma = C * (x + C * S), this.m_gamma > 0 && (this.m_gamma = 1 / this.m_gamma), this.m_bias = _ * C * S * this.m_gamma, this.m_springMass = g + this.m_gamma, this.m_springMass > 0 && (this.m_springMass = 1 / this.m_springMass) } } else this.m_springImpulse = 0; if (this.m_enableMotor ? (this.m_motorMass = o + n, this.m_motorMass > 0 && (this.m_motorMass = 1 / this.m_motorMass)) : (this.m_motorMass = 0, this.m_motorImpulse = 0), t.step.warmStarting) { this.m_impulse *= t.step.dtRatio, this.m_springImpulse *= t.step.dtRatio, this.m_motorImpulse *= t.step.dtRatio; var w = box2d.b2AddVV(box2d.b2MulSV(this.m_impulse, this.m_ay, box2d.b2Vec2.s_t0), box2d.b2MulSV(this.m_springImpulse, this.m_ax, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P),
            A = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse,
            T = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;
        a.SelfMulSub(this.m_invMassA, w), h -= this.m_invIA * A, d.SelfMulAdd(this.m_invMassB, w), u += this.m_invIB * T } else this.m_impulse = 0, this.m_springImpulse = 0, this.m_motorImpulse = 0;
    t.velocities[this.m_indexA].w = h, t.velocities[this.m_indexB].w = u }, box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_d = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.InitVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.SolveVelocityConstraints = function(t) { var e = this.m_invMassA,
        i = this.m_invMassB,
        o = this.m_invIA,
        n = this.m_invIB,
        s = t.velocities[this.m_indexA].v,
        r = t.velocities[this.m_indexA].w,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = box2d.b2DotVV(this.m_ax, box2d.b2SubVV(a, s, box2d.b2Vec2.s_t0)) + this.m_sBx * h - this.m_sAx * r,
        c = -this.m_springMass * (l + this.m_bias + this.m_gamma * this.m_springImpulse);
    this.m_springImpulse += c; var d = box2d.b2MulSV(c, this.m_ax, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P),
        u = c * this.m_sAx,
        p = c * this.m_sBx;
    s.SelfMulSub(e, d), r -= o * u, a.SelfMulAdd(i, d); var l = (h += n * p) - r - this.m_motorSpeed,
        c = -this.m_motorMass * l,
        m = this.m_motorImpulse,
        f = t.step.dt * this.m_maxMotorTorque;
    this.m_motorImpulse = box2d.b2Clamp(this.m_motorImpulse + c, -f, f), r -= o * (c = this.m_motorImpulse - m), h += n * c; var l = box2d.b2DotVV(this.m_ay, box2d.b2SubVV(a, s, box2d.b2Vec2.s_t0)) + this.m_sBy * h - this.m_sAy * r,
        c = -this.m_mass * l;
    this.m_impulse += c; var d = box2d.b2MulSV(c, this.m_ay, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P),
        u = c * this.m_sAy,
        p = c * this.m_sBy;
    s.SelfMulSub(e, d), r -= o * u, a.SelfMulAdd(i, d), h += n * p, t.velocities[this.m_indexA].w = r, t.velocities[this.m_indexB].w = h }, box2d.b2WheelJoint.prototype.SolveVelocityConstraints.s_P = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.SolvePositionConstraints = function(t) { var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.positions[this.m_indexB].c,
        n = t.positions[this.m_indexB].a,
        s = this.m_qA.SetAngleRadians(i),
        r = this.m_qB.SetAngleRadians(n);
    box2d.b2SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA); var a = box2d.b2MulRV(s, this.m_lalcA, this.m_rA);
    box2d.b2SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB); var h, l = box2d.b2MulRV(r, this.m_lalcB, this.m_rB),
        c = box2d.b2AddVV(box2d.b2SubVV(o, e, box2d.b2Vec2.s_t0), box2d.b2SubVV(l, a, box2d.b2Vec2.s_t1), box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d),
        d = box2d.b2MulRV(s, this.m_localYAxisA, this.m_ay),
        u = box2d.b2CrossVV(box2d.b2AddVV(c, a, box2d.b2Vec2.s_t0), d),
        p = box2d.b2CrossVV(l, d),
        m = box2d.b2DotVV(c, this.m_ay),
        f = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;
    h = 0 !== f ? -m / f : 0; var y = box2d.b2MulSV(h, d, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P),
        b = h * u,
        g = h * p; return e.SelfMulSub(this.m_invMassA, y), i -= this.m_invIA * b, o.SelfMulAdd(this.m_invMassB, y), n += this.m_invIB * g, t.positions[this.m_indexA].a = i, t.positions[this.m_indexB].a = n, box2d.b2Abs(m) <= box2d.b2_linearSlop }, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_d = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.SolvePositionConstraints.s_P = new box2d.b2Vec2, box2d.b2WheelJoint.prototype.GetDefinition = function(t) { return box2d.ENABLE_ASSERTS && box2d.b2Assert(!1), t }, box2d.b2WheelJoint.prototype.GetAnchorA = function(t) { return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, t) }, box2d.b2WheelJoint.prototype.GetAnchorB = function(t) { return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, t) }, box2d.b2WheelJoint.prototype.GetReactionForce = function(t, e) { return e.x = t * (this.m_impulse * this.m_ay.x + this.m_springImpulse * this.m_ax.x), e.y = t * (this.m_impulse * this.m_ay.y + this.m_springImpulse * this.m_ax.y), e }, box2d.b2WheelJoint.prototype.GetReactionTorque = function(t) { return t * this.m_motorImpulse }, box2d.b2WheelJoint.prototype.GetLocalAnchorA = function(t) { return t.Copy(this.m_localAnchorA) }, box2d.b2WheelJoint.prototype.GetLocalAnchorB = function(t) { return t.Copy(this.m_localAnchorB) }, box2d.b2WheelJoint.prototype.GetLocalAxisA = function(t) { return t.Copy(this.m_localXAxisA) }, box2d.b2WheelJoint.prototype.GetJointTranslation = function() { var t = this.m_bodyA,
        e = this.m_bodyB,
        i = t.GetWorldPoint(this.m_localAnchorA, new box2d.b2Vec2),
        o = e.GetWorldPoint(this.m_localAnchorB, new box2d.b2Vec2),
        n = box2d.b2SubVV(o, i, new box2d.b2Vec2),
        s = t.GetWorldVector(this.m_localXAxisA, new box2d.b2Vec2); return box2d.b2DotVV(n, s) }, box2d.b2WheelJoint.prototype.GetJointSpeed = function() { var t = this.m_bodyA.m_angularVelocity; return this.m_bodyB.m_angularVelocity - t }, box2d.b2WheelJoint.prototype.IsMotorEnabled = function() { return this.m_enableMotor }, box2d.b2WheelJoint.prototype.EnableMotor = function(t) { this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_enableMotor = t }, box2d.b2WheelJoint.prototype.SetMotorSpeed = function(t) { this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_motorSpeed = t }, box2d.b2WheelJoint.prototype.SetMaxMotorTorque = function(t) { this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_maxMotorTorque = t }, box2d.b2WheelJoint.prototype.GetMotorTorque = function(t) { return t * this.m_motorImpulse }, box2d.b2WheelJoint.prototype.Dump = function() { if (box2d.DEBUG) { var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2WheelJointDef*/ var jd = new box2d.b2WheelJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.localAnchorA.SetXY(%.15f, %.15f);\n", this.m_localAnchorA.x, this.m_localAnchorA.y), box2d.b2Log("  jd.localAnchorB.SetXY(%.15f, %.15f);\n", this.m_localAnchorB.x, this.m_localAnchorB.y), box2d.b2Log("  jd.localAxisA.Set(%.15f, %.15f);\n", this.m_localXAxisA.x, this.m_localXAxisA.y), box2d.b2Log("  jd.enableMotor = %s;\n", this.m_enableMotor ? "true" : "false"), box2d.b2Log("  jd.motorSpeed = %.15f;\n", this.m_motorSpeed), box2d.b2Log("  jd.maxMotorTorque = %.15f;\n", this.m_maxMotorTorque), box2d.b2Log("  jd.frequencyHz = %.15f;\n", this.m_frequencyHz), box2d.b2Log("  jd.dampingRatio = %.15f;\n", this.m_dampingRatio), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index) } }, goog.provide("box2d.b2MotorJoint"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Math"), box2d.b2MotorJointDef = function() { goog.base(this, box2d.b2JointType.e_motorJoint), this.linearOffset = new box2d.b2Vec2(0, 0) }, goog.inherits(box2d.b2MotorJointDef, box2d.b2JointDef), box2d.b2MotorJointDef.prototype.linearOffset = null, box2d.b2MotorJointDef.prototype.angularOffset = 0, box2d.b2MotorJointDef.prototype.maxForce = 1, box2d.b2MotorJointDef.prototype.maxTorque = 1, box2d.b2MotorJointDef.prototype.correctionFactor = .3, box2d.b2MotorJointDef.prototype.Initialize = function(t, e) { this.bodyA = t, this.bodyB = e, this.bodyA.GetLocalPoint(this.bodyB.GetPosition(), this.linearOffset); var i = this.bodyA.GetAngleRadians(),
        o = this.bodyB.GetAngleRadians();
    this.angularOffset = o - i }, box2d.b2MotorJoint = function(t) { goog.base(this, t), this.m_linearOffset = t.linearOffset.Clone(), this.m_linearImpulse = new box2d.b2Vec2(0, 0), this.m_maxForce = t.maxForce, this.m_maxTorque = t.maxTorque, this.m_correctionFactor = t.correctionFactor, this.m_rA = new box2d.b2Vec2(0, 0), this.m_rB = new box2d.b2Vec2(0, 0), this.m_localCenterA = new box2d.b2Vec2(0, 0), this.m_localCenterB = new box2d.b2Vec2(0, 0), this.m_linearError = new box2d.b2Vec2(0, 0), this.m_linearMass = new box2d.b2Mat22, this.m_qA = new box2d.b2Rot, this.m_qB = new box2d.b2Rot, this.m_K = new box2d.b2Mat22 }, goog.inherits(box2d.b2MotorJoint, box2d.b2Joint), box2d.b2MotorJoint.prototype.m_linearOffset = null, box2d.b2MotorJoint.prototype.m_angularOffset = 0, box2d.b2MotorJoint.prototype.m_linearImpulse = null, box2d.b2MotorJoint.prototype.m_angularImpulse = 0, box2d.b2MotorJoint.prototype.m_maxForce = 0, box2d.b2MotorJoint.prototype.m_maxTorque = 0, box2d.b2MotorJoint.prototype.m_correctionFactor = .3, box2d.b2MotorJoint.prototype.m_indexA = 0, box2d.b2MotorJoint.prototype.m_indexB = 0, box2d.b2MotorJoint.prototype.m_rA = null, box2d.b2MotorJoint.prototype.m_rB = null, box2d.b2MotorJoint.prototype.m_localCenterA = null, box2d.b2MotorJoint.prototype.m_localCenterB = null, box2d.b2MotorJoint.prototype.m_linearError = null, box2d.b2MotorJoint.prototype.m_angularError = 0, box2d.b2MotorJoint.prototype.m_invMassA = 0, box2d.b2MotorJoint.prototype.m_invMassB = 0, box2d.b2MotorJoint.prototype.m_invIA = 0, box2d.b2MotorJoint.prototype.m_invIB = 0, box2d.b2MotorJoint.prototype.m_linearMass = null, box2d.b2MotorJoint.prototype.m_angularMass = 0, box2d.b2MotorJoint.prototype.m_qA = null, box2d.b2MotorJoint.prototype.m_qB = null, box2d.b2MotorJoint.prototype.m_K = null, box2d.b2MotorJoint.prototype.GetAnchorA = function(t) { return this.m_bodyA.GetPosition(t) }, box2d.b2MotorJoint.prototype.GetAnchorB = function(t) { return this.m_bodyB.GetPosition(t) }, box2d.b2MotorJoint.prototype.GetReactionForce = function(t, e) { return box2d.b2MulSV(t, this.m_linearImpulse, e) }, box2d.b2MotorJoint.prototype.GetReactionTorque = function(t) { return t * this.m_angularImpulse }, box2d.b2MotorJoint.prototype.SetCorrectionFactor = function(t) { box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t) && t >= 0 && 1 >= t), this._correctionFactor = t }, box2d.b2MotorJoint.prototype.GetCorrectionFactor = function() { return this.m_correctionFactor }, box2d.b2MotorJoint.prototype.SetLinearOffset = function(t) { box2d.b2IsEqualToV(t, this.m_linearOffset) || (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_linearOffset.Copy(t)) }, box2d.b2MotorJoint.prototype.GetLinearOffset = function(t) { return t.Copy(this.m_linearOffset) }, box2d.b2MotorJoint.prototype.SetAngularOffset = function(t) { t !== this.m_angularOffset && (this.m_bodyA.SetAwake(!0), this.m_bodyB.SetAwake(!0), this.m_angularOffset = t) }, box2d.b2MotorJoint.prototype.GetAngularOffset = function() { return this.m_angularOffset }, box2d.b2MotorJoint.prototype.SetMaxForce = function(t) { box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t) && t >= 0), this.m_maxForce = t }, box2d.b2MotorJoint.prototype.GetMaxForce = function() { return this.m_maxForce }, box2d.b2MotorJoint.prototype.SetMaxTorque = function(t) { box2d.ENABLE_ASSERTS && box2d.b2Assert(box2d.b2IsValid(t) && t >= 0), this.m_maxTorque = t }, box2d.b2MotorJoint.prototype.GetMaxTorque = function() { return this.m_maxTorque }, box2d.b2MotorJoint.prototype.InitVelocityConstraints = function(t) { this.m_indexA = this.m_bodyA.m_islandIndex, this.m_indexB = this.m_bodyB.m_islandIndex, this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter), this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter), this.m_invMassA = this.m_bodyA.m_invMass, this.m_invMassB = this.m_bodyB.m_invMass, this.m_invIA = this.m_bodyA.m_invI, this.m_invIB = this.m_bodyB.m_invI; var e = t.positions[this.m_indexA].c,
        i = t.positions[this.m_indexA].a,
        o = t.velocities[this.m_indexA].v,
        n = t.velocities[this.m_indexA].w,
        s = t.positions[this.m_indexB].c,
        r = t.positions[this.m_indexB].a,
        a = t.velocities[this.m_indexB].v,
        h = t.velocities[this.m_indexB].w,
        l = this.m_qA.SetAngleRadians(i),
        c = this.m_qB.SetAngleRadians(r),
        d = box2d.b2MulRV(l, box2d.b2NegV(this.m_localCenterA, box2d.b2Vec2.s_t0), this.m_rA),
        u = box2d.b2MulRV(c, box2d.b2NegV(this.m_localCenterB, box2d.b2Vec2.s_t0), this.m_rB),
        p = this.m_invMassA,
        m = this.m_invMassB,
        f = this.m_invIA,
        y = this.m_invIB,
        b = this.m_K; if (b.ex.x = p + m + f * d.y * d.y + y * u.y * u.y, b.ex.y = -f * d.x * d.y - y * u.x * u.y, b.ey.x = b.ex.y, b.ey.y = p + m + f * d.x * d.x + y * u.x * u.x, b.GetInverse(this.m_linearMass), this.m_angularMass = f + y, this.m_angularMass > 0 && (this.m_angularMass = 1 / this.m_angularMass), box2d.b2SubVV(box2d.b2SubVV(box2d.b2AddVV(s, u, box2d.b2Vec2.s_t0), box2d.b2AddVV(e, d, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), box2d.b2MulRV(l, this.m_linearOffset, box2d.b2Vec2.s_t3), this.m_linearError), this.m_angularError = r - i - this.m_angularOffset, t.step.warmStarting) { this.m_linearImpulse.SelfMul(t.step.dtRatio), this.m_angularImpulse *= t.step.dtRatio; var g = this.m_linearImpulse;
        o.SelfMulSub(p, g), n -= f * (box2d.b2CrossVV(d, g) + this.m_angularImpulse), a.SelfMulAdd(m, g), h += y * (box2d.b2CrossVV(u, g) + this.m_angularImpulse) } else this.m_linearImpulse.SetZero(), this.m_angularImpulse = 0;
    t.velocities[this.m_indexA].w = n, t.velocities[this.m_indexB].w = h }, box2d.b2MotorJoint.prototype.SolveVelocityConstraints = function(t) { var e = t.velocities[this.m_indexA].v,
        i = t.velocities[this.m_indexA].w,
        o = t.velocities[this.m_indexB].v,
        n = t.velocities[this.m_indexB].w,
        s = this.m_invMassA,
        r = this.m_invMassB,
        a = this.m_invIA,
        h = this.m_invIB,
        l = t.step.dt,
        c = t.step.inv_dt,
        d = n - i + c * this.m_correctionFactor * this.m_angularError,
        u = -this.m_angularMass * d,
        p = this.m_angularImpulse,
        m = l * this.m_maxTorque;
    this.m_angularImpulse = box2d.b2Clamp(this.m_angularImpulse + u, -m, m), i -= a * (u = this.m_angularImpulse - p), n += h * u; var f = this.m_rA,
        y = this.m_rB,
        d = box2d.b2AddVV(box2d.b2SubVV(box2d.b2AddVV(o, box2d.b2CrossSV(n, y, box2d.b2Vec2.s_t0), box2d.b2Vec2.s_t0), box2d.b2AddVV(e, box2d.b2CrossSV(i, f, box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t1), box2d.b2Vec2.s_t2), box2d.b2MulSV(c * this.m_correctionFactor, this.m_linearError, box2d.b2Vec2.s_t3), box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot),
        u = box2d.b2MulMV(this.m_linearMass, d, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse).SelfNeg(),
        p = box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse.Copy(this.m_linearImpulse);
    this.m_linearImpulse.SelfAdd(u);
    m = l * this.m_maxForce;
    this.m_linearImpulse.GetLengthSquared() > m * m && (this.m_linearImpulse.Normalize(), this.m_linearImpulse.SelfMul(m)), box2d.b2SubVV(this.m_linearImpulse, p, u), e.SelfMulSub(s, u), i -= a * box2d.b2CrossVV(f, u), o.SelfMulAdd(r, u), n += h * box2d.b2CrossVV(y, u), t.velocities[this.m_indexA].w = i, t.velocities[this.m_indexB].w = n }, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_Cdot = new box2d.b2Vec2, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_impulse = new box2d.b2Vec2, box2d.b2MotorJoint.prototype.SolveVelocityConstraints.s_oldImpulse = new box2d.b2Vec2, box2d.b2MotorJoint.prototype.SolvePositionConstraints = function() { return !0 }, box2d.b2MotorJoint.prototype.Dump = function() { if (box2d.DEBUG) { var t = this.m_bodyA.m_islandIndex,
            e = this.m_bodyB.m_islandIndex;
        box2d.b2Log("  /*box2d.b2MotorJointDef*/ var jd = new box2d.b2MotorJointDef();\n"), box2d.b2Log("  jd.bodyA = bodies[%d];\n", t), box2d.b2Log("  jd.bodyB = bodies[%d];\n", e), box2d.b2Log("  jd.collideConnected = %s;\n", this.m_collideConnected ? "true" : "false"), box2d.b2Log("  jd.linearOffset.SetXY(%.15f, %.15f);\n", this.m_linearOffset.x, this.m_linearOffset.y), box2d.b2Log("  jd.angularOffset = %.15f;\n", this.m_angularOffset), box2d.b2Log("  jd.maxForce = %.15f;\n", this.m_maxForce), box2d.b2Log("  jd.maxTorque = %.15f;\n", this.m_maxTorque), box2d.b2Log("  jd.correctionFactor = %.15f;\n", this.m_correctionFactor), box2d.b2Log("  joints[%d] = this.m_world.CreateJoint(jd);\n", this.m_index) } }, goog.provide("box2d"), goog.require("box2d.b2Settings"), goog.require("box2d.b2Draw"), goog.require("box2d.b2Timer"), goog.require("box2d.b2CircleShape"), goog.require("box2d.b2EdgeShape"), goog.require("box2d.b2ChainShape"), goog.require("box2d.b2PolygonShape"), goog.require("box2d.b2BroadPhase"), goog.require("box2d.b2Distance"), goog.require("box2d.b2DynamicTree"), goog.require("box2d.b2TimeOfImpact"), goog.require("box2d.b2Body"), goog.require("box2d.b2Fixture"), goog.require("box2d.b2WorldCallbacks"), goog.require("box2d.b2TimeStep"), goog.require("box2d.b2World"), goog.require("box2d.b2Contact"), goog.require("box2d.b2AreaJoint"), goog.require("box2d.b2DistanceJoint"), goog.require("box2d.b2FrictionJoint"), goog.require("box2d.b2GearJoint"), goog.require("box2d.b2MotorJoint"), goog.require("box2d.b2MouseJoint"), goog.require("box2d.b2PrismaticJoint"), goog.require("box2d.b2PulleyJoint"), goog.require("box2d.b2RevoluteJoint"), goog.require("box2d.b2RopeJoint"), goog.require("box2d.b2WeldJoint"), goog.require("box2d.b2WheelJoint"), goog.require("box2d.b2Rope"), goog.require("box2d.b2BuoyancyController"), goog.require("box2d.b2ConstantAccelController"), goog.require("box2d.b2ConstantForceController"), goog.require("box2d.b2GravityController"), goog.require("box2d.b2TensorDampingController"), Phaser.Physics.Box2D = function(t, e) { this.game = t, this.version = "1.0.2", this.ptmRatio = 50, this.world = new box2d.b2World(new box2d.b2Vec2(0, 0)), this.debugDraw = new Phaser.Physics.Box2D.DefaultDebugDraw(this.mpx(1)), this.world.SetDebugDraw(this.debugDraw), this.contactListener = new Phaser.Physics.Box2D.DefaultContactListener, this.world.SetContactListener(this.contactListener), this.nextBodyId = 0, this.nextFixtureId = 0, this.gravity = new Phaser.Physics.Box2D.PointProxy(this, this.world, this.world.GetGravity, this.world.SetGravity), this.friction = .2, this.restitution = 0, this.density = 1, this.frameRate = 1 / 60, this.velocityIterations = 8, this.positionIterations = 3, this.useElapsedTime = !1, this.paused = !1, this.particleSystem = null; var i = new box2d.b2BodyDef;
    this.mouseJointBody = this.world.CreateBody(i), this.mouseJoint = null, e.hasOwnProperty("mpx") && e.hasOwnProperty("pxm") && (this.mpx = e.mpx, this.pxm = e.pxm), this.walls = { left: null, right: null, top: null, bottom: null }, this.onBodyAdded = new Phaser.Signal, this.onBodyRemoved = new Phaser.Signal, this._toRemove = [] }, Phaser.Physics.Box2D.worldBoundsFilterCategory = 32768, Phaser.Physics.Box2D.prototype = { getNextBodyId: function() { var t = this.nextBodyId; return this.nextBodyId += 1, t }, getNextFixtureId: function() { var t = this.nextFixtureId; return this.nextFixtureId += 1, t }, removeBodyNextStep: function(t) { this._toRemove.push(t) }, preUpdate: function() { for (var t = this._toRemove.length; t--;) this.removeBody(this._toRemove[t]);
        this._toRemove.length = 0 }, enable: function(t, e) { void 0 === e && (e = !0); var i = 1; if (Array.isArray(t))
            for (i = t.length; i--;) t[i] instanceof Phaser.Group ? this.enable(t[i].children, e) : (this.enableBody(t[i]), e && t[i].hasOwnProperty("children") && t[i].children.length > 0 && this.enable(t[i], !0));
        else t instanceof Phaser.Group ? this.enable(t.children, e) : (this.enableBody(t), e && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, !0)) }, enableBody: function(t) { t.hasOwnProperty("body") && null === t.body && (t.body = new Phaser.Physics.Box2D.Body(this.game, t, t.x, t.y, 2), t.anchor.set(.5)) }, setBoundsToWorld: function(t, e, i, o, n, s) { void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === o && (o = !0), void 0 === n && (n = 1), void 0 === s && (n = 4294967295), this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, t, e, i, o, n, s) }, setBounds: function(t, e, i, o, n, s, r, a, h, l) { void 0 === n && (n = !0), void 0 === s && (s = !0), void 0 === r && (r = !0), void 0 === a && (a = !0), void 0 === h && (h = 1), void 0 === l && (l = 4294967295), this.walls.left && this.removeBody(this.walls.left), this.walls.right && this.removeBody(this.walls.right), this.walls.top && this.removeBody(this.walls.top), this.walls.bottom && this.removeBody(this.walls.bottom); var c = new box2d.b2PolygonShape,
            d = new box2d.b2FixtureDef;
        d.shape = c, d.filter.categoryBits = Phaser.Physics.Box2D.worldBoundsFilterCategory, d.filter.maskBits = 65535; var u = this.pxm(100),
            p = this.game.world.bounds; if (n && (this.walls.left = this.createBody(0, 0, 0), c.SetAsOrientedBox(u, this.pxm(p.height) + u, new box2d.b2Vec2(u, 0), 0), (m = this.walls.left.data.CreateFixture(d)).id = this.getNextFixtureId()), s && (this.walls.right = this.createBody(0, 0, 0), c.SetAsOrientedBox(u, this.pxm(p.height) + u, new box2d.b2Vec2(this.pxm(-p.width) - u, 0), 0), (m = this.walls.right.data.CreateFixture(d)).id = this.getNextFixtureId()), r && (this.walls.top = this.createBody(0, 0, 0), c.SetAsOrientedBox(this.pxm(p.width) + u, u, new box2d.b2Vec2(0, u), 0), (m = this.walls.top.data.CreateFixture(d)).id = this.getNextFixtureId()), a) { this.walls.bottom = this.createBody(0, 0, 0), c.SetAsOrientedBox(this.pxm(p.width) + u, u, new box2d.b2Vec2(0, this.pxm(-p.height) - u), 0); var m = this.walls.bottom.data.CreateFixture(d);
            m.id = this.getNextFixtureId() } }, pause: function() { this.paused = !0 }, resume: function() { this.paused = !1 }, update: function() { this.paused || (this.useElapsedTime ? this.world.Step(this.game.time.physicsElapsed, this.velocityIterations, this.positionIterations) : this.world.Step(this.frameRate, this.velocityIterations, this.positionIterations)) }, reset: function() { this.clear() }, clear: function() { var t = this.world.GetGravity().Clone();
        this.world = new box2d.b2World(t), this.world.SetDebugDraw(this.debugDraw), this.world.SetContactListener(this.contactListener), this._toRemove = [] }, destroy: function() { this.clear(), this.gravity = null, this.world = null, this.game = null }, createBody: function(t, e, i) { return new Phaser.Physics.Box2D.Body(this.game, null, t, e, i, this) }, createCircle: function(t, e, i, o, n) { return this.createBody(t, e, 2).setCircle(i, o, n) }, createRectangle: function(t, e, i, o, n, s, r) { return this.createBody(t, e, 2).setRectangle(i, o, n, s, r) }, createPolygon: function(t, e, i, o, n) { return this.createBody(t, e, 2).setPolygon(i, o, n) }, addBody: function(t) { return !t.data.world && (t.data = this.world.CreateBody(t.bodyDef), t.data.world = this.world, t.data.parent = t, this.onBodyAdded.dispatch(t), !0) }, removeBody: function(t) { return t.data.world == this.world && (this.world.DestroyBody(t.data), this.onBodyRemoved.dispatch(t)), t }, getBodies: function() { for (var t = [], e = this.world.GetBodyList(); e; e = e.GetNext()) t.push(e); return t }, getBody: function(t) { return t instanceof box2d.b2Body ? t : t instanceof Phaser.Physics.Box2D.Body ? t.data : t.body && t.body.type === Phaser.Physics.BOX2D ? t.body.data : null }, toJSON: function() { return this.world.toJSON() }, mpx: function(t) { return t *= this.ptmRatio }, pxm: function(t) { return t / this.ptmRatio }, renderDebugDraw: function(t) { if (this.game.physics.box2d) { var e = this.game.physics.box2d;
            e.debugDraw.start(t), e.world.DrawDebugData(), e.debugDraw.stop() } }, renderBodyInfo: function(t, e) { t.line("Position: x: " + e.x.toFixed(3) + " y: " + e.y.toFixed(3)), t.line("Rotation: " + e.rotation.toFixed(3) + " degrees"), t.line("Velocity: x: " + e.velocity.x.toFixed(3) + " y: " + e.velocity.y.toFixed(3)), t.line("Angular velocity: " + e.angularVelocity.toFixed(3) + " degrees/sec") }, getFixturesAtPoint: function(t, e, i, o) { void 0 === i && (i = !1), void 0 === o && (o = !1); var n = this.pxm(-t),
            s = this.pxm(-e),
            r = new box2d.b2Vec2(n, s),
            a = new box2d.b2AABB,
            h = new box2d.b2Vec2;
        h.SetXY(.001, .001), box2d.b2SubVV(r, h, a.lowerBound), box2d.b2AddVV(r, h, a.upperBound); var l = []; return this.world.QueryAABB(function(t) { return !(!o || t.GetBody().GetType() === box2d.b2BodyType.b2_dynamicBody) || !t.TestPoint(r) || (l.push(t), !i) }, a), l }, getBodiesAtPoint: function(t, e, i, o) { void 0 === i && (i = !1), void 0 === o && (o = !1); var n = this.getFixturesAtPoint(t, e, i, o); if (n.length < 1) return n; for (var s = [], r = 0; r < n.length; r++) s.push(n[r].GetBody().parent); return s.filter(function(t, e) { return s.indexOf(t) === e }), s }, mouseDragStart: function(t) { this.mouseDragEnd(); var e = this.getFixturesAtPoint(t.x, t.y, !0, !0); if (!(e.length < 1)) { var i = this.pxm(-t.x),
                o = this.pxm(-t.y),
                n = new box2d.b2Vec2(i, o),
                s = new box2d.b2MouseJointDef;
            s.bodyA = this.mouseJointBody, s.bodyB = e[0].GetBody(), s.target.Copy(n), s.maxForce = 1e3 * s.bodyB.GetMass(), this.mouseJoint = this.world.CreateJoint(s), s.bodyB.SetAwake(!0) } }, mouseDragMove: function(t) { if (this.mouseJoint) { var e = this.pxm(-t.x),
                i = this.pxm(-t.y),
                o = new box2d.b2Vec2(e, i);
            this.mouseJoint.SetTarget(o) } }, mouseDragEnd: function() { this.mouseJoint && (this.world.DestroyJoint(this.mouseJoint), this.mouseJoint = null) }, distanceJoint: function(t, e, i, o, n, s, r, a, h) { void 0 === o && (o = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), o = this.pxm(-o), n = this.pxm(-n), s = this.pxm(-s), r = this.pxm(-r), t.body && (t = t.body), e.body && (e = e.body); var l = new box2d.b2DistanceJointDef; if (l.bodyA = t.data, l.bodyB = e.data, l.localAnchorA.SetXY(o, n), l.localAnchorB.SetXY(s, r), null === i || void 0 === i) { var c = new box2d.b2Vec2,
                d = new box2d.b2Vec2;
            l.bodyA.GetWorldPoint(l.localAnchorA, c), l.bodyB.GetWorldPoint(l.localAnchorB, d), c.SelfSub(d), i = c.Length() } else i = this.pxm(i); return l.length = i, l.frequencyHz = a, l.dampingRatio = h, this.world.CreateJoint(l) }, ropeJoint: function(t, e, i, o, n, s, r) { void 0 === o && (o = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), o = this.pxm(-o), n = this.pxm(-n), s = this.pxm(-s), r = this.pxm(-r), t.body && (t = t.body), e.body && (e = e.body); var a = new box2d.b2RopeJointDef; if (a.bodyA = t.data, a.bodyB = e.data, a.localAnchorA.SetXY(o, n), a.localAnchorB.SetXY(s, r), null === i || void 0 === i) { var h = new box2d.b2Vec2,
                l = new box2d.b2Vec2;
            a.bodyA.GetWorldPoint(a.localAnchorA, h), a.bodyB.GetWorldPoint(a.localAnchorB, l), h.SelfSub(l), i = h.Length() } else i = this.pxm(i); return a.maxLength = i, this.world.CreateJoint(a) }, revoluteJoint: function(t, e, i, o, n, s, r, a, h, l, c, d) { void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = !1), void 0 === l && (l = 0), void 0 === c && (c = 0), void 0 === d && (d = !1), i = this.pxm(-i), o = this.pxm(-o), n = this.pxm(-n), s = this.pxm(-s), t.body && (t = t.body), e.body && (e = e.body); var u = new box2d.b2RevoluteJointDef; return u.bodyA = t.data, u.bodyB = e.data, u.localAnchorA.SetXY(i, o), u.localAnchorB.SetXY(n, s), u.motorSpeed = Phaser.Math.degToRad(-r), u.maxMotorTorque = a, u.enableMotor = h, u.lowerAngle = Phaser.Math.degToRad(l), u.upperAngle = Phaser.Math.degToRad(c), u.enableLimit = d, this.world.CreateJoint(u) }, prismaticJoint: function(t, e, i, o, n, s, r, a, h, l, c, d, u, p, m) { void 0 === i && (i = 1), void 0 === o && (o = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), void 0 === l && (l = 0), void 0 === d && (d = 0), void 0 === u && (u = 0), void 0 === p && (p = !1), void 0 === c && (c = !1), void 0 === m && (m = 0), i *= -1, o *= -1, n = this.pxm(-n), s = this.pxm(-s), r = this.pxm(-r), a = this.pxm(-a), h = this.pxm(h), d = this.pxm(d), u = this.pxm(u), t.body && (t = t.body), e.body && (e = e.body); var f = new box2d.b2PrismaticJointDef; return f.bodyA = t.data, f.bodyB = e.data, f.localAxisA.SetXY(i, o), f.localAnchorA.SetXY(n, s), f.localAnchorB.SetXY(r, a), f.motorSpeed = h, f.maxMotorForce = l, f.enableMotor = c, f.lowerTranslation = d, f.upperTranslation = u, f.enableLimit = p, f.referenceAngle = Phaser.Math.degToRad(-m), this.world.CreateJoint(f) }, frictionJoint: function(t, e, i, o, n, s, r, a) { void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), n = this.pxm(-n), s = this.pxm(-s), r = this.pxm(-r), a = this.pxm(-a), t.body && (t = t.body), e.body && (e = e.body); var h = new box2d.b2FrictionJointDef; return h.bodyA = t.data, h.bodyB = e.data, h.localAnchorA.SetXY(n, s), h.localAnchorB.SetXY(r, a), h.maxForce = i, h.maxTorque = o, this.world.CreateJoint(h) }, weldJoint: function(t, e, i, o, n, s, r, a) { void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), i = this.pxm(-i), o = this.pxm(-o), n = this.pxm(-n), s = this.pxm(-s), t.body && (t = t.body), e.body && (e = e.body); var h = new box2d.b2WeldJointDef; return h.bodyA = t.data, h.bodyB = e.data, h.localAnchorA.SetXY(i, o), h.localAnchorB.SetXY(n, s), h.frequencyHz = r, h.dampingRatio = a, this.world.CreateJoint(h) }, motorJoint: function(t, e, i, o, n, s, r, a) { void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === n && (n = 1), s = this.pxm(-s), r = this.pxm(-r), t.body && (t = t.body), e.body && (e = e.body); var h = new box2d.b2MotorJointDef; return h.bodyA = t.data, h.bodyB = e.data, h.linearOffset.SetXY(s, r), h.maxForce = i, h.maxTorque = o, h.angularOffset = Phaser.Math.degToRad(-a), h.correctionFactor = n, this.world.CreateJoint(h) }, wheelJoint: function(t, e, i, o, n, s, r, a, h, l, c, d, u) { void 0 === r && (r = 0), void 0 === a && (a = 1), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === c && (c = 0), void 0 === d && (d = 0), void 0 === u && (u = !1), void 0 === h && (h = 0), void 0 === l && (l = 0), r *= -1, a *= -1, i = this.pxm(-i), o = this.pxm(-o), n = this.pxm(-n), s = this.pxm(-s), t.body && (t = t.body), e.body && (e = e.body); var p = new box2d.b2WheelJointDef; return p.bodyA = t.data, p.bodyB = e.data, p.localAxisA.SetXY(r, a), p.localAnchorA.SetXY(i, o), p.localAnchorB.SetXY(n, s), p.motorSpeed = Phaser.Math.degToRad(-c), p.maxMotorTorque = d, p.enableMotor = u, p.frequencyHz = h, p.dampingRatio = l, this.world.CreateJoint(p) }, pulleyJoint: function(t, e, i, o, n, s, r, a, h, l, c, d, u) { void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === a && (a = 0), void 0 === h && (h = 0), void 0 === l && (l = 0), void 0 === c && (c = 1), void 0 === d && (d = 100), void 0 === u && (u = 100), i = this.pxm(-i), o = this.pxm(-o), n = this.pxm(-n), s = this.pxm(-s), r = this.pxm(-r), a = this.pxm(-a), h = this.pxm(-h), l = this.pxm(-l), d = this.pxm(d), u = this.pxm(u), t.body && (t = t.body), e.body && (e = e.body); var p = new box2d.b2PulleyJointDef; return p.bodyA = t.data, p.bodyB = e.data, p.localAnchorA.SetXY(i, o), p.localAnchorB.SetXY(n, s), p.groundAnchorA.SetXY(r, a), p.groundAnchorB.SetXY(h, l), p.lengthA = d, p.lengthB = u, p.ratio = c, this.world.CreateJoint(p) }, gearJoint: function(t, e, i) { void 0 === i && (i = 1); var o = new box2d.b2GearJointDef; return o.joint1 = t, o.joint2 = e, o.ratio = -i, o.bodyA = t.GetBodyA(), o.bodyB = e.GetBodyB(), this.world.CreateJoint(o) }, clearTilemapLayerBodies: function(t, e) { e = t.getLayer(e); for (var i = t.layers[e].bodies.length; i--;) t.layers[e].bodies[i].destroy();
        t.layers[e].bodies.length = 0 }, convertTilemap: function(t, e, i, o) { e = t.getLayer(e), void 0 === i && (i = !0), void 0 === o && (o = !0), this.clearTilemapLayerBodies(t, e); for (var n = 0, s = 0, r = 0, a = 0, h = t.layers[e].height; h > a; a++) { n = 0; for (var l = 0, c = t.layers[e].width; c > l; l++) { var d = t.layers[e].data[a][l]; if (d && d.index > -1 && d.collides)
                    if (o) { var u = t.getTileRight(e, l, a);
                        0 === n && (s = d.x * d.width, r = d.y * d.height, n = d.width), u && u.collides ? n += d.width : ((p = new Phaser.Physics.Box2D.Body(this.game, null, s, r, 0)).addRectangle(n, d.height, n / 2, d.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p), n = 0) } else { var p = this.createBody(d.x * d.width, d.y * d.height, 0, !1);
                        p.addRectangle(d.width, d.height, d.width / 2, d.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p) } } } return t.layers[e].bodies }, raycast: function(t, e, i, o, n, s) { void 0 === n && (n = !0), void 0 === s && (s = null), t = this.pxm(-t), e = this.pxm(-e), i = this.pxm(-i), o = this.pxm(-o); var r = new box2d.b2Vec2(t, e),
            a = new box2d.b2Vec2(i, o),
            h = [],
            l = new Phaser.Physics.Box2D.RayCastCallback(this, n, s);
        this.world.RayCast(l, r, a); for (var c = 0; c < l.hits.length; c++) { var d = l.hits[c];
            d.point = { x: this.mpx(-d.point.x), y: this.mpx(-d.point.y) }, d.normal = { x: -d.normal.x, y: -d.normal.y }, h.push(d) } return h }, queryAABB: function(t, e, i, o) { t = this.pxm(-t), e = this.pxm(-e), i = this.pxm(i), o = this.pxm(o); var n = new box2d.b2AABB;
        n.lowerBound.SetXY(t - i, e - o), n.upperBound.SetXY(t, e); var s = new Phaser.Physics.Box2D.QueryCallback(this); return this.world.QueryAABB(s, n), s.hits }, queryFixture: function(t) { var e = new Phaser.Physics.Box2D.QueryCallback(this); return this.world.QueryShape(e, t.GetShape(), t.GetBody().GetTransform()), e.hits }, setPTMRatio: function(t) { this.ptmRatio = t, this.debugDraw = new Phaser.Physics.Box2D.DefaultDebugDraw(this.ptmRatio), this.world.SetDebugDraw(this.debugDraw) } }, Phaser.Physics.Box2D.RayCastCallback = function(t, e, i) { this.world = t, this.closestHitOnly = e, this.filterFunction = i, this.hits = [] }, goog.inherits(Phaser.Physics.Box2D.RayCastCallback, box2d.b2RayCastCallback), Phaser.Physics.Box2D.RayCastCallback.prototype.ReportFixture = function(t, e, i, o) { if (null !== this.filterFunction) { var n = { x: this.world.mpx(-e.x), y: this.world.mpx(-e.y) },
            s = { x: -i.x, y: -i.y },
            r = t.GetBody().parent; if (!this.filterFunction.call(this, r, t, n, s)) return -1 } this.closestHitOnly && (this.hits = []); var a = {}; return a.body = t.GetBody().parent, a.fixture = t, a.point = { x: e.x, y: e.y }, a.normal = { x: i.x, y: i.y }, this.hits.push(a), this.closestHitOnly ? o : 1 }, Phaser.Physics.Box2D.QueryCallback = function(t) { this.world = t, this.hits = [] }, goog.inherits(Phaser.Physics.Box2D.QueryCallback, box2d.b2QueryCallback), Phaser.Physics.Box2D.QueryCallback.prototype.ReportFixture = function(t) { var e = {}; return e.body = t.GetBody().parent, e.fixture = t, this.hits.push(e), !0 }, Phaser.Physics.Box2D.renderBody = function(t, e, i, o) { i = i || "rgb(255,255,255)", void 0 === o && (o = !0); var n = e.data,
        s = n.GetTransform(),
        r = e.world;
    s.p.x += -e.game.camera.x / r.ptmRatio, s.p.y -= -e.game.camera.y / r.ptmRatio, r.debugDraw.start(t), r.debugDraw.PushTransform(s); var a = Phaser.Color.webToColor(i),
        h = r.debugDraw.color;
    h.r = a.r / 255, h.g = a.g / 255, h.b = a.b / 255; for (var l = n.GetFixtureList(); l; l = l.GetNext()) r.world.DrawShape(l, h);
    r.debugDraw.PopTransform(), r.debugDraw.stop() }, Phaser.Physics.Box2D.Body = function(t, e, i, o, n, s) { void 0 === e && (e = null), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === n && (n = 2), void 0 === s && (s = t.physics.box2d), this.game = t, this.world = s, this.id = this.world.getNextBodyId(), this.sprite = e, this.type = Phaser.Physics.BOX2D, this.offset = new Phaser.Point, this.bodyDef = new box2d.b2BodyDef, this.bodyDef.position.SetXY(-this.world.pxm(i), -this.world.pxm(o)), 0 === n ? this.bodyDef.type = box2d.b2BodyType.b2_staticBody : 1 === n ? this.bodyDef.type = box2d.b2BodyType.b2_kinematicBody : 2 === n ? this.bodyDef.type = box2d.b2BodyType.b2_dynamicBody : 3 === n && (this.bodyDef.type = box2d.b2BodyType.b2_bulletBody), this.data = this.world.world.CreateBody(this.bodyDef), this.data.world = this.world.world, this.data.parent = this, this.velocity = new Phaser.Physics.Box2D.PointProxy(this.world, this.data, this.data.GetLinearVelocity, this.data.SetLinearVelocity), this.removeNextStep = !1, this._fixtureContactCallbacks = {}, this._fixtureContactCallbackContext = {}, this._bodyContactCallbacks = {}, this._bodyContactCallbackContext = {}, this._categoryContactCallbacks = {}, this._categoryContactCallbackContext = {}, this._fixturePresolveCallbacks = {}, this._fixturePresolveCallbackContext = {}, this._bodyPresolveCallbacks = {}, this._bodyPresolveCallbackContext = {}, this._categoryPresolveCallbacks = {}, this._categoryPresolveCallbackContext = {}, this._fixturePostsolveCallbacks = {}, this._fixturePostsolveCallbackContext = {}, this._bodyPostsolveCallbacks = {}, this._bodyPostsolveCallbackContext = {}, this._categoryPostsolveCallbacks = {}, this._categoryPostsolveCallbackContext = {}, e && this.setRectangleFromSprite(e) }, Phaser.Physics.Box2D.Body.prototype = { setBodyContactCallback: function(t, e, i) { var o = -1;
        t.id ? o = t.id : t.body && (o = t.body.id), o > -1 && (null === e ? (delete this._bodyContactCallbacks[o], delete this._bodyContactCallbackContext[o]) : (this._bodyContactCallbacks[o] = e, this._bodyContactCallbackContext[o] = i)) }, setFixtureContactCallback: function(t, e, i) { var o = t.id;
        o > -1 && (null === e ? (delete this._fixtureContactCallbacks[o], delete this._fixtureContactCallbackContext[o]) : (this._fixtureContactCallbacks[o] = e, this._fixtureContactCallbackContext[o] = i)) }, setCategoryContactCallback: function(t, e, i) { null === e ? (delete this._categoryContactCallbacks[t], delete this._categoryContactCallbacksContext[t]) : (this._categoryContactCallbacks[t] = e, this._categoryContactCallbackContext[t] = i) }, setBodyPresolveCallback: function(t, e, i) { var o = -1;
        t.id ? o = t.id : t.body && (o = t.body.id), o > -1 && (null === e ? (delete this._bodyPresolveCallbacks[o], delete this._bodyPresolveCallbackContext[o]) : (this._bodyPresolveCallbacks[o] = e, this._bodyPresolveCallbackContext[o] = i)) }, setFixturePresolveCallback: function(t, e, i) { var o = t.id;
        o > -1 && (null === e ? (delete this._fixturePresolveCallbacks[o], delete this._fixturePresolveCallbackContext[o]) : (this._fixturePresolveCallbacks[o] = e, this._fixturePresolveCallbackContext[o] = i)) }, setCategoryPresolveCallback: function(t, e, i) { null === e ? (delete this._categoryPresolveCallbacks[t], delete this._categoryPresolveCallbacksContext[t]) : (this._categoryPresolveCallbacks[t] = e, this._categoryPresolveCallbackContext[t] = i) }, setBodyPostsolveCallback: function(t, e, i) { var o = -1;
        t.id ? o = t.id : t.body && (o = t.body.id), o > -1 && (null === e ? (delete this._bodyPostsolveCallbacks[o], delete this._bodyPostsolveCallbackContext[o]) : (this._bodyPostsolveCallbacks[o] = e, this._bodyPostsolveCallbackContext[o] = i)) }, setFixturePostsolveCallback: function(t, e, i) { var o = t.id;
        o > -1 && (null === e ? (delete this._fixturePostsolveCallbacks[o], delete this._fixturePostsolveCallbackContext[o]) : (this._fixturePostsolveCallbacks[o] = e, this._fixturePostsolveCallbackContext[o] = i)) }, setCategoryPostsolveCallback: function(t, e, i) { null === e ? (delete this._categoryPostsolveCallbacks[t], delete this._categoryPostsolveCallbacksContext[t]) : (this._categoryPostsolveCallbacks[t] = e, this._categoryPostsolveCallbackContext[t] = i) }, setCollisionCategory: function(t, e) { if (void 0 === e)
            for (var i = this.data.GetFixtureList(); i; i = i.GetNext())(o = i.GetFilterData()).categoryBits = t;
        else { var o = e.GetFilterData();
            o.categoryBits = t } }, setCollisionMask: function(t, e) { if (void 0 === e)
            for (var i = this.data.GetFixtureList(); i; i = i.GetNext())(o = i.GetFilterData()).maskBits = t;
        else { var o = e.GetFilterData();
            o.maskBits = t } }, applyForce: function(t, e) { this.data.ApplyForce(new box2d.b2Vec2(-t, -e), this.data.GetWorldCenter(), !0) }, setZeroRotation: function() { this.data.SetAngularVelocity(0) }, setZeroVelocity: function() { this.data.SetLinearVelocity(box2d.b2Vec2.ZERO) }, setZeroDamping: function() { this.data.SetLinearDamping(0), this.data.SetAngularDamping(0) }, toLocalPoint: function(t, e) { return t.x = this.world.pxm(-e.x), t.y = this.world.pxm(-e.y), this.data.GetLocalPoint(t, t), t.x = this.world.mpx(-t.x), t.y = this.world.mpx(-t.y), t }, toWorldPoint: function(t, e) { return t.x = this.world.pxm(-e.x), t.y = this.world.pxm(-e.y), this.data.GetWorldPoint(t, t), t.x = this.world.mpx(-t.x), t.y = this.world.mpx(-t.y), t }, toLocalVector: function(t, e) { return t.x = this.world.pxm(-e.x), t.y = this.world.pxm(-e.y), this.data.GetLocalVector(t, t), t.x = this.world.mpx(-t.x), t.y = this.world.mpx(-t.y), t }, toWorldVector: function(t, e) { t.x = this.world.pxm(-e.x), t.y = this.world.pxm(-e.y), this.data.GetWorldVector(t, t), t.x = this.world.mpx(-t.x), t.y = this.world.mpx(-t.y) }, rotateLeft: function(t) { this.data.SetAngularVelocity(this.world.pxm(-t)) }, rotateRight: function(t) { this.data.SetAngularVelocity(this.world.pxm(t)) }, moveForward: function(t) { var e = this.world.pxm(t),
            i = new box2d.b2Vec2;
        this.toWorldVector(i, { x: 0, y: e }), this.data.SetLinearVelocity(i) }, moveBackward: function(t) { var e = this.world.pxm(-t),
            i = new box2d.b2Vec2;
        this.toWorldVector(i, { x: 0, y: e }), this.data.SetLinearVelocity(i) }, thrust: function(t) { var e = this.world.pxm(t) * this.data.GetMass(),
            i = new box2d.b2Vec2;
        this.toWorldVector(i, { x: 0, y: e }), this.data.ApplyForce(i, this.data.GetWorldCenter(), !0) }, reverse: function(t) { var e = -this.world.pxm(t) * this.data.GetMass(),
            i = new box2d.b2Vec2;
        this.toWorldVector(i, { x: 0, y: e }), this.data.ApplyForce(i, this.data.GetWorldCenter(), !0) }, moveLeft: function(t) { this.velocity.x = -t }, moveRight: function(t) { this.velocity.x = t }, moveUp: function(t) { this.velocity.y = -t }, moveDown: function(t) { this.velocity.y = t }, preUpdate: function() { this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1) }, postUpdate: function() { this.sprite && (this.sprite.x = this.world.mpx(-this.data.GetPosition().x), this.sprite.y = this.world.mpx(-this.data.GetPosition().y), this.sprite.rotation = this.data.GetAngle()) }, kill: function() { this.data.SetActive(!1) }, reset: function(t, e) { this.data.SetPositionXY(this.world.pxm(-t), this.world.pxm(-e)), this.data.SetActive(!0) }, removeFromWorld: function() { this.data.world === this.game.physics.box2d.world && this.game.physics.box2d.removeBodyNextStep(this) }, destroy: function() { this.removeFromWorld(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._categoryCallbacks = {}, this._categoryCallbackContext = {}, this.sprite = null }, clearFixtures: function() { for (var t = [], e = this.data.GetFixtureList(); e; e = e.GetNext()) t.push(e); for (var i = t.length; i--;) this.data.DestroyFixture(t[i]) }, addCircle: function(t, e, i) { var o = new box2d.b2CircleShape(this.world.pxm(t));
        o.m_p.SetXY(this.world.pxm(-e), this.world.pxm(-i)); var n = new box2d.b2FixtureDef;
        n.shape = o, n.friction = this.world.friction, n.restitution = this.world.restitution, n.density = this.world.density; var s = this.data.CreateFixture(n); return s.id = this.world.getNextFixtureId(), s }, addRectangle: function(t, e, i, o, n) { void 0 === t && (t = 16), void 0 === e && (e = 16), void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === n && (n = 0), t = this.world.pxm(t), e = this.world.pxm(e); var s = new box2d.b2PolygonShape;
        s.SetAsOrientedBox(.5 * t, .5 * e, new box2d.b2Vec2(this.world.pxm(-i), this.world.pxm(-o)), n); var r = new box2d.b2FixtureDef;
        r.shape = s, r.friction = this.world.friction, r.restitution = this.world.restitution, r.density = this.world.density; var a = this.data.CreateFixture(r); return a.id = this.world.getNextFixtureId(), a }, addEdge: function(t, e, i, o) { var n = new box2d.b2EdgeShape;
        n.Set(new box2d.b2Vec2(this.world.pxm(-t), this.world.pxm(-e)), new box2d.b2Vec2(this.world.pxm(-i), this.world.pxm(-o))); var s = new box2d.b2FixtureDef;
        s.shape = n, s.friction = this.world.friction, s.restitution = this.world.restitution, s.density = this.world.density; var r = this.data.CreateFixture(s); return r.id = this.world.getNextFixtureId(), r }, addChain: function(t, e, i, o) { if (void 0 === t) return null; if (t.length < 4) return null;
        void 0 === e && (e = 0), void 0 === i && (i = (t.length - e) / 2); for (var n = [], s = e; e + i > s; s++) n.push(new box2d.b2Vec2(this.world.pxm(-t[2 * s]), this.world.pxm(-t[2 * s + 1]))); var r = new box2d.b2ChainShape;
        o ? r.CreateLoop(n, n.length) : r.CreateChain(n, n.length); var a = new box2d.b2FixtureDef;
        a.shape = r, a.friction = this.world.friction, a.restitution = this.world.restitution, a.density = this.world.density; var h = this.data.CreateFixture(a); return h.id = this.world.getNextFixtureId(), h }, addLoop: function(t, e, i) { return this.addChain(t, e, i, !0) }, addPolygon: function(t, e, i) { if (void 0 === t) return null; if (t.length < 6) return null;
        void 0 === e && (e = 0), void 0 === i && (i = (t.length - e) / 2); for (var o = [], n = e; e + i > n; n++) o.push({ x: this.world.pxm(-t[2 * n]), y: this.world.pxm(-t[2 * n + 1]) }); var s = new Phaser.Physics.Box2D.Polygon;
        s.setFromXYObjects(o); for (var r = s.decompose(o), a = null, n = 0; n < r.length; n++) { var h = new box2d.b2PolygonShape;
            h.Set(r[n], r[n].length); var l = new box2d.b2FixtureDef;
            l.shape = h, l.friction = this.world.friction, l.restitution = this.world.restitution, l.density = this.world.density, (a = this.data.CreateFixture(l)).id = this.world.getNextFixtureId() } return a }, removeFixture: function(t) { return t.GetBody() == this.data && (this.data.DestroyFixture(t), !0) }, setCircle: function(t, e, i) { return void 0 === t && (t = 32), void 0 === e && (e = 0), void 0 === i && (i = 0), this.clearFixtures(), this.addCircle(t, e, i) }, setRectangle: function(t, e, i, o, n) { return this.clearFixtures(), this.addRectangle(t, e, i, o, n) }, setRectangleFromSprite: function(t) { return void 0 === t && (t = this.sprite), this.clearFixtures(), this.addRectangle(t.width, t.height, 0, 0, t.rotation) }, setEdge: function(t, e, i, o) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), this.clearFixtures(), this.addEdge(t, e, i, o) }, setChain: function(t, e, i, o) { return void 0 === t ? null : t.length < 4 ? null : (void 0 === e && (e = 0), void 0 === i && (i = (t.length - e) / 2), this.clearFixtures(), this.addChain(t, e, i, o)) }, setLoop: function(t, e, i) { return this.setChain(t, e, i, !0) }, setPolygon: function(t, e, i) { return void 0 === t ? null : t.length < 4 ? null : (void 0 === e && (e = 0), void 0 === i && (i = (t.length - e) / 2), this.clearFixtures(), this.addPolygon(t, e, i)) }, loadPolygon: function(t, e, i) { void 0 === i && (i = null); for (var o = this.game.cache.getPhysicsData(t, e), n = 0; n < o.length; n++) { for (var s = [], r = 0; r < o[n].shape.length; r += 2) s.push(new box2d.b2Vec2(this.world.pxm(-o[n].shape[r]), this.world.pxm(-o[n].shape[r + 1]))); if (i)
                for (var a = this.world.pxm(-.5 * i.width), h = this.world.pxm(-.5 * i.height), l = 0; l < s.length; l++) s[l].x -= a, s[l].y -= h; var c = new box2d.b2PolygonShape;
            c.Set(s, s.length); var d = new box2d.b2FixtureDef;
            d.shape = c, d.friction = o[n].friction, d.restitution = o[n].bounce, d.density = o[n].density, d.filter.categoryBits = o[n].filter.categoryBits, d.filter.maskBits = o[n].filter.maskBits, this.data.CreateFixture(d).id = this.world.getNextFixtureId() } return !0 }, containsPoint: function(t) { for (var e = this.world.pxm(-t.x), i = this.world.pxm(-t.y), o = new box2d.b2Vec2(e, i), n = this.data.GetFixtureList(); n; n = n.GetNext())
            if (n.TestPoint(o)) return !0; return !1 } }, Phaser.Physics.Box2D.Body.prototype.constructor = Phaser.Physics.Box2D.Body, Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "static", { get: function() { return this.data.GetType() === box2d.b2BodyType.b2_staticBody }, set: function(t) { t && this.data.GetType() !== box2d.b2BodyType.b2_staticBody ? this.data.SetType(box2d.b2BodyType.b2_staticBody) : t || this.data.GetType() !== box2d.b2BodyType.b2_staticBody || this.data.SetType(box2d.b2BodyType.b2_dynamicBody) } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "dynamic", { get: function() { return this.data.GetType() === box2d.b2BodyType.b2_dynamicBody }, set: function(t) { t && this.data.GetType() !== box2d.b2BodyType.b2_dynamicBody ? this.data.SetType(box2d.b2BodyType.b2_dynamicBody) : t || this.data.GetType() !== box2d.b2BodyType.b2_dynamicBody || this.data.SetType(box2d.b2BodyType.b2_staticBody) } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "kinematic", { get: function() { return this.data.GetType() === box2d.b2BodyType.b2_kinematicBody }, set: function(t) { t && this.data.GetType() !== box2d.b2BodyType.b2_kinematicBody ? this.data.SetType(box2d.b2BodyType.b2_kinematicBody) : t || this.data.GetType() !== box2d.b2BodyType.b2_kinematicBody || this.data.SetType(box2d.b2BodyType.b2_staticBody) } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "angle", { get: function() { return Phaser.Math.wrapAngle(Phaser.Math.radToDeg(this.data.GetAngle())) }, set: function(t) { this.data.SetAngle(Phaser.Math.degToRad(Phaser.Math.wrapAngle(t))) } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "linearDamping", { get: function() { return this.data.GetLinearDamping() }, set: function(t) { this.data.SetLinearDamping(t) } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "angularDamping", { get: function() { return this.data.GetAngularDamping() }, set: function(t) { this.data.SetAngularDamping(t) } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "angularVelocity", { get: function() { return this.data.GetAngularVelocity() }, set: function(t) { this.data.SetAngularVelocity(t) } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "fixedRotation", { get: function() { return this.data.IsFixedRotation() }, set: function(t) { this.data.SetFixedRotation(t) } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "gravityScale", { get: function() { return this.data.GetGravityScale() }, set: function(t) { this.data.SetGravityScale(t) } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "friction", { get: function() { var t = this.data.GetFixtureList(); return t ? t.GetFriction() : 0 }, set: function(t) { for (var e = this.data.GetFixtureList(); e; e = e.GetNext()) e.SetFriction(t), e.Refilter() } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "restitution", { get: function() { var t = this.data.GetFixtureList(); return t ? t.GetRestitution() : 0 }, set: function(t) { for (var e = this.data.GetFixtureList(); e; e = e.GetNext()) e.SetRestitution(t), e.Refilter() } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "sensor", { get: function() { var t = this.data.GetFixtureList(); return t ? t.IsSensor() : 0 }, set: function(t) { for (var e = this.data.GetFixtureList(); e; e = e.GetNext()) e.SetSensor(t), e.Refilter() } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "bullet", { get: function() { return this.data.IsBullet() }, set: function(t) { this.data.SetBullet(t) } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "mass", { get: function() { return this.data.GetMass() }, set: function(t) { if (0 === t) this.data.SetType(box2d.b2BodyType.b2_staticBody);
        else { this.data.GetType() !== box2d.b2BodyType.b2_dynamicBody && this.data.SetType(box2d.b2BodyType.b2_dynamicBody); for (var e = t / this.data.GetMass(), i = this.data.GetFixtureList(); i; i = i.GetNext()) { var o = i.GetDensity();
                i.SetDensity(o * e) } this.data.ResetMassData() } } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "rotation", { get: function() { return this.data.GetAngle() }, set: function(t) { this.data.SetAngle(t) } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "x", { get: function() { return this.world.mpx(-this.data.GetPosition().x) }, set: function(t) { this.data.SetPositionXY(this.world.pxm(-t), this.data.GetPosition().y) } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "y", { get: function() { return this.world.mpx(-this.data.GetPosition().y) }, set: function(t) { this.data.SetPositionXY(this.data.GetPosition().x, this.world.pxm(-t)) } }), Object.defineProperty(Phaser.Physics.Box2D.Body.prototype, "collideWorldBounds", { get: function() { for (var t = this.data.GetFixtureList(); t; t = t.GetNext())
            if (t.GetFilterData().maskBits & Phaser.Physics.Box2D.worldBoundsFilterCategory) return !0; return !1 }, set: function(t) { for (var e = this.data.GetFixtureList(); e; e = e.GetNext()) { var i = e.GetFilterData();
            t ? i.maskBits |= Phaser.Physics.Box2D.worldBoundsFilterCategory : i.maskBits &= ~Phaser.Physics.Box2D.worldBoundsFilterCategory } } }), Phaser.Physics.Box2D.PointProxy = function(t, e, i, o) { this.world = t, this.object = e, this.gettor = i, this.settor = o }, Phaser.Physics.Box2D.PointProxy.prototype.constructor = Phaser.Physics.Box2D.PointProxy, Object.defineProperty(Phaser.Physics.Box2D.PointProxy.prototype, "x", { get: function() { return this.world.mpx(-this.gettor.call(this.object).x) }, set: function(t) { var e = this.gettor.call(this.object);
        e.x = this.world.pxm(-t), this.settor.call(this.object, e) } }), Object.defineProperty(Phaser.Physics.Box2D.PointProxy.prototype, "y", { get: function() { return this.world.mpx(-this.gettor.call(this.object).y) }, set: function(t) { var e = this.gettor.call(this.object);
        e.y = this.world.pxm(-t), this.settor.call(this.object, e) } }), Phaser.Physics.Box2D.DefaultDebugDraw = function(t) { this.context = null, this.pixelsPerMeter = t, this.flags = box2d.b2DrawFlags.e_shapeBit }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.color = new box2d.b2Color(1, 1, 1), Phaser.Physics.Box2D.DefaultDebugDraw.prototype.SetFlags = function(t) { this.flags = t }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.GetFlags = function() { return this.flags }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.start = function(t) { this.context = t, this.context.save(), this.context.scale(-1, -1), this.context.scale(this.pixelsPerMeter, this.pixelsPerMeter) }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.stop = function() { this.context.restore() }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.PushTransform = function(t) { var e = this.context;
    e.save(), e.translate(t.p.x, t.p.y), e.rotate(t.q.GetAngleRadians()) }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.PopTransform = function() { this.context.restore() }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawPolygon = function(t, e, i) { if (e) { var o = this.context;
        o.lineWidth = 1 / this.pixelsPerMeter, o.beginPath(), o.moveTo(t[0].x, t[0].y); for (var n = 1; e > n; n++) o.lineTo(t[n].x, t[n].y);
        o.closePath(), o.strokeStyle = i.MakeStyleString(1), o.stroke() } }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSolidPolygon = function(t, e, i) { if (e) { var o = this.context;
        o.lineWidth = 1 / this.pixelsPerMeter, o.beginPath(), o.moveTo(t[0].x, t[0].y); for (var n = 1; e > n; n++) o.lineTo(t[n].x, t[n].y);
        o.closePath(), o.fillStyle = i.MakeStyleString(.5), o.fill(), o.strokeStyle = i.MakeStyleString(1), o.stroke() } }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawCircle = function(t, e, i) { if (e) { var o = this.context;
        o.beginPath(), o.arc(t.x, t.y, e, 0, 2 * Math.PI, !0), o.strokeStyle = i.MakeStyleString(1), o.stroke() } }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSolidCircle = function(t, e, i, o) { if (e) { var n = this.context;
        n.lineWidth = 1 / this.pixelsPerMeter; var s = t.x,
            r = t.y;
        n.beginPath(), n.arc(s, r, e, 0, 2 * Math.PI, !0), n.moveTo(s, r), n.lineTo(s + i.x * e, r + i.y * e), n.fillStyle = o.MakeStyleString(.5), n.fill(), n.strokeStyle = o.MakeStyleString(1), n.stroke() } }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawSegment = function(t, e, i) { var o = this.context;
    o.lineWidth = 1 / this.pixelsPerMeter, o.beginPath(), o.moveTo(t.x, t.y), o.lineTo(e.x, e.y), o.strokeStyle = i.MakeStyleString(1), o.stroke() }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawTransform = function(t) { var e = this.context;
    e.lineWidth = 1 / this.pixelsPerMeter, this.PushTransform(t), e.beginPath(), e.moveTo(0, 0), e.lineTo(1, 0), e.strokeStyle = box2d.b2Color.RED.MakeStyleString(1), e.stroke(), e.beginPath(), e.moveTo(0, 0), e.lineTo(0, 1), e.strokeStyle = box2d.b2Color.GREEN.MakeStyleString(1), e.stroke(), this.PopTransform(t) }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawPoint = function(t, e, i) { var o = this.context;
    o.fillStyle = i.MakeStyleString(); var n = e / 2;
    o.fillRect(t.x - n, t.y - n, e, e) }, Phaser.Physics.Box2D.DefaultDebugDraw.prototype.DrawAABB = function(t, e) { var i = this.context;
    i.strokeStyle = e.MakeStyleString(); var o = t.lowerBound.x,
        n = t.lowerBound.y,
        s = t.upperBound.x - t.lowerBound.x,
        r = t.upperBound.y - t.lowerBound.y;
    i.strokeRect(o, n, s, r) }, Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "shapes", { get: function() { return this.flags & box2d.b2DrawFlags.e_shapeBit }, set: function(t) { t ? this.flags |= box2d.b2DrawFlags.e_shapeBit : this.flags &= ~box2d.b2DrawFlags.e_shapeBit } }), Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "joints", { get: function() { return this.flags & box2d.b2DrawFlags.e_jointBit }, set: function(t) { t ? this.flags |= box2d.b2DrawFlags.e_jointBit : this.flags &= ~box2d.b2DrawFlags.e_jointBit } }), Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "aabbs", { get: function() { return this.flags & box2d.b2DrawFlags.e_aabbBit }, set: function(t) { t ? this.flags |= box2d.b2DrawFlags.e_aabbBit : this.flags &= ~box2d.b2DrawFlags.e_aabbBit } }), Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "pairs", { get: function() { return this.flags & box2d.b2DrawFlags.e_pairBit }, set: function(t) { t ? this.flags |= box2d.b2DrawFlags.e_pairBit : this.flags &= ~box2d.b2DrawFlags.e_pairBit } }), Object.defineProperty(Phaser.Physics.Box2D.DefaultDebugDraw.prototype, "centerOfMass", { get: function() { return this.flags & box2d.b2DrawFlags.e_centerOfMassBit }, set: function(t) { t ? this.flags |= box2d.b2DrawFlags.e_centerOfMassBit : this.flags &= ~box2d.b2DrawFlags.e_centerOfMassBit } }), Phaser.Physics.Box2D.DefaultContactListener = function() {}, Phaser.Physics.Box2D.DefaultContactListener.prototype.BeginContact = function(t) { this.handleContactBeginOrEnd(t, !0) }, Phaser.Physics.Box2D.DefaultContactListener.prototype.EndContact = function(t) { this.handleContactBeginOrEnd(t, !1) }, Phaser.Physics.Box2D.DefaultContactListener.prototype.handleContactBeginOrEnd = function(t, e) { var i = t.GetFixtureA(),
        o = t.GetFixtureB(),
        n = i.GetBody(),
        s = o.GetBody(),
        r = i.GetFilterData().categoryBits,
        a = o.GetFilterData().categoryBits,
        h = n.parent,
        l = s.parent; if (void 0 !== h && void 0 !== l) { var c = h.id,
            d = l.id;
        h._bodyContactCallbacks[d] && h._bodyContactCallbacks[d].call(h._bodyContactCallbackContext[d], h, l, i, o, e, t), l._bodyContactCallbacks[c] && l._bodyContactCallbacks[c].call(l._bodyContactCallbackContext[c], l, h, o, i, e, t), h._fixtureContactCallbacks[o.id] && h._fixtureContactCallbacks[o.id].call(h._fixtureContactCallbackContext[o.id], h, l, i, o, e, t), l._fixtureContactCallbacks[i.id] && l._fixtureContactCallbacks[i.id].call(l._fixtureContactCallbackContext[i.id], l, h, o, i, e, t), h._fixtureContactCallbacks[i.id] && h._fixtureContactCallbacks[i.id].call(h._fixtureContactCallbackContext[i.id], h, l, i, o, e, t), l._fixtureContactCallbacks[o.id] && l._fixtureContactCallbacks[o.id].call(l._fixtureContactCallbackContext[o.id], l, h, o, i, e, t), h._categoryContactCallbacks[a] && h._categoryContactCallbacks[a].call(h._categoryContactCallbackContext[a], h, l, i, o, e, t), l._categoryContactCallbacks[r] && l._categoryContactCallbacks[r].call(l._categoryContactCallbackContext[r], l, h, o, i, e, t), h._categoryContactCallbacks[r] && h._categoryContactCallbacks[r].call(h._categoryContactCallbackContext[r], h, l, i, o, e, t), l._categoryContactCallbacks[a] && l._categoryContactCallbacks[a].call(l._categoryContactCallbackContext[a], l, h, o, i, e, t) } }, Phaser.Physics.Box2D.DefaultContactListener.prototype.PreSolve = function(t, e) { var i = t.GetFixtureA(),
        o = t.GetFixtureB(),
        n = i.GetBody(),
        s = o.GetBody(),
        r = i.GetFilterData().categoryBits,
        a = o.GetFilterData().categoryBits,
        h = n.parent,
        l = s.parent; if (void 0 !== h && void 0 !== l) { var c = h.id,
            d = l.id;
        h._bodyPresolveCallbacks[d] && h._bodyPresolveCallbacks[d].call(h._bodyPresolveCallbackContext[d], h, l, i, o, t, e), l._bodyPresolveCallbacks[c] && l._bodyPresolveCallbacks[c].call(l._bodyPresolveCallbackContext[c], l, h, o, i, t, e), h._fixturePresolveCallbacks[o.id] && h._fixturePresolveCallbacks[o.id].call(h._fixturePresolveCallbackContext[o.id], h, l, i, o, t, e), l._fixturePresolveCallbacks[i.id] && l._fixturePresolveCallbacks[i.id].call(l._fixturePresolveCallbackContext[i.id], l, h, o, i, t, e), h._categoryPresolveCallbacks[a] && h._categoryPresolveCallbacks[a].call(h._categoryPresolveCallbackContext[a], h, l, i, o, t, e), l._categoryPresolveCallbacks[r] && l._categoryPresolveCallbacks[r].call(l._categoryPresolveCallbackContext[r], l, h, o, i, t, e) } }, Phaser.Physics.Box2D.DefaultContactListener.prototype.PostSolve = function(t, e) { var i = t.GetFixtureA(),
        o = t.GetFixtureB(),
        n = i.GetBody(),
        s = o.GetBody(),
        r = i.GetFilterData().categoryBits,
        a = o.GetFilterData().categoryBits,
        h = n.parent,
        l = s.parent; if (void 0 !== h && void 0 !== l) { var c = h.id,
            d = l.id;
        h._bodyPostsolveCallbacks[d] && h._bodyPostsolveCallbacks[d].call(h._bodyPostsolveCallbackContext[d], h, l, i, o, t, e), l._bodyPostsolveCallbacks[c] && l._bodyPostsolveCallbacks[c].call(l._bodyPostsolveCallbackContext[c], l, h, o, i, t, e), h._fixturePostsolveCallbacks[o.id] && h._fixturePostsolveCallbacks[o.id].call(h._fixturePostsolveCallbackContext[o.id], h, l, i, o, t, e), l._fixturePostsolveCallbacks[i.id] && l._fixturePostsolveCallbacks[i.id].call(l._fixturePostsolveCallbackContext[i.id], l, h, o, i, t, e), h._categoryPostsolveCallbacks[a] && h._categoryPostsolveCallbacks[a].call(h._categoryPostsolveCallbackContext[a], h, l, i, o, t, e), l._categoryPostsolveCallbacks[r] && l._categoryPostsolveCallbacks[r].call(l._categoryPostsolveCallbackContext[r], l, h, o, i, t, e) } }, Phaser.Physics.Box2D.Polygon = function() { this.vertices = [] }, Phaser.Physics.Box2D.Polygon.prototype.setFromFlatXYCoords = function(t) { this.vertices = []; for (var e = 0; e < t.length / 2; e++) this.vertices.push({ x: t[2 * e], y: t[2 * e + 1] }) }, Phaser.Physics.Box2D.Polygon.prototype.setFromXYObjects = function(t) { this.vertices = t.concat() }, Phaser.Physics.Box2D.Polygon.prototype.addVertex = function(t) { this.vertices.push(t) }, Phaser.Physics.Box2D.Polygon.prototype.at = function(t) { var e = this.vertices.length; return this.vertices[0 > t ? t % e + e : t % e] }, Phaser.Physics.Box2D.Polygon.prototype.indicesAreAdjacent = function(t, e) { if (t %= this.vertices.length, e %= this.vertices.length, t == e) return !0; var i = Math.abs(t - e); return 2 > i || i == this.vertices.length - 1 }, Phaser.Physics.Box2D.Polygon.prototype.areaInTriangle = function(t, e, i) { return t = this.at(t), e = this.at(e), i = this.at(i), .5 * ((e.x - t.x) * (i.y - t.y) - (i.x - t.x) * (e.y - t.y)) }, Phaser.Physics.Box2D.Polygon.prototype.left = function(t, e, i) { return this.areaInTriangle(t, e, i) > 0 }, Phaser.Physics.Box2D.Polygon.prototype.leftOn = function(t, e, i) { return this.areaInTriangle(t, e, i) >= 0 }, Phaser.Physics.Box2D.Polygon.prototype.right = function(t, e, i) { return this.areaInTriangle(t, e, i) < 0 }, Phaser.Physics.Box2D.Polygon.prototype.rightOn = function(t, e, i) { return this.areaInTriangle(t, e, i) <= 0 }, Phaser.Physics.Box2D.Polygon.sqdist = function(t, e) { var i = e.x - t.x,
        o = e.y - t.y; return i * i + o * o }, Phaser.Physics.Box2D.Polygon.prototype.makeCCW = function() { for (var t = 0, e = 1, i = this.vertices.length; i > e; e++)(this.at(e).y < this.at(t).y || this.at(e).y === this.at(t).y && this.at(e).x > this.at(t).x) && (t = e); return !this.left(t - 1, t, t + 1) && (this.vertices.reverse(), !0) }, Phaser.Physics.Box2D.Polygon.prototype.isConvex = function() { for (var t = !1, e = !1, i = 0, o = this.vertices.length; o > i; i++) { var n = i,
            s = (i + 1) % o,
            r = (i + 2) % o;
        this.areaInTriangle(this.vertices[n], this.vertices[s], this.vertices[r]) > 0 ? t = !0 : e = !0 } return e ^ t }, Phaser.Physics.Box2D.Polygon.prototype.isReflex = function(t) { return this.right(t - 1, t, t + 1) }, Phaser.Physics.Box2D.Polygon.areVecsEqual = function(t, e) { return t.x == e.x && t.y == e.y }, Phaser.Physics.Box2D.Polygon.linesCross = function(t, e, i, o) { if (Phaser.Physics.Box2D.Polygon.areVecsEqual(e, i) || Phaser.Physics.Box2D.Polygon.areVecsEqual(t, i) || Phaser.Physics.Box2D.Polygon.areVecsEqual(e, o) || Phaser.Physics.Box2D.Polygon.areVecsEqual(t, o)) return null; var n = {};
    box2d.b2SubVV(e, t, n), box2d.b2CrossVS(n, 1, n); var s = box2d.b2DotVV(n, t),
        r = box2d.b2DotVV(n, i),
        a = box2d.b2DotVV(n, o); if (r > s && a > s) return null; if (s > r && s > a) return null; var h = {};
    box2d.b2SubVV(o, i, h), box2d.b2CrossVS(h, 1, h); var r = box2d.b2DotVV(h, i),
        s = box2d.b2DotVV(h, t),
        l = box2d.b2DotVV(h, e); if (s > r && l > r) return null; if (r > s && r > l) return null; var c = (r - s) / (l - s); return { x: t.x + c * (e.x - t.x), y: t.y + c * (e.y - t.y) } }, Phaser.Physics.Box2D.Polygon.prototype.canSee = function(t, e) { if (this.indicesAreAdjacent(t, e)) return !1; if (this.leftOn(t + 1, t, e) && this.rightOn(t - 1, t, e)) return !1; for (var i = 0; i < this.vertices.length; ++i)
        if ((i + 1) % this.vertices.length != t && i != t && this.leftOn(t, e, i + 1) && this.rightOn(t, e, i) && Phaser.Physics.Box2D.Polygon.linesCross(this.at(t), this.at(e), this.at(i), this.at(i + 1))) return !1; return !0 }, Phaser.Physics.Box2D.Polygon.prototype.subPolygon = function(t, e) { var i = new Phaser.Physics.Box2D.Polygon; if (e > t)
        for (o = t; e + 1 > o; o++) i.addVertex(this.at(o));
    else { for (o = t; o < this.vertices.length; o++) i.addVertex(this.at(o)); for (var o = 0; e + 1 > o; o++) i.addVertex(this.at(o)) } return i }, Phaser.Physics.Box2D.Polygon.prototype.decomposeOptimal = function(t) { if (void 0 === t && (t = 0), t > 1) return this.vertices;
    this.makeCCW(); for (var e = [], i = [], o = [], n = Number.MAX_VALUE, s = 0; s < this.vertices.length; s++)
        if (this.isReflex(s))
            for (var r = 0; r < this.vertices.length; r++) this.canSee(s, r) && (i = this.subPolygon(s, r).decompose(t + 1), o = this.subPolygon(r, s).decompose(t + 1), i.length + o.length < n && (e = i.concat(o), n = e.length)); return 0 === e.length && e.push(this.vertices), e }, Phaser.Physics.Box2D.Polygon.prototype.decompose = function(t) { void 0 === t && (t = 0), this.makeCCW(); for (var e, i, o = [], n = Number.MAX_VALUE, s = !1, r = 0; r < this.vertices.length; r++)
        if (this.isReflex(r)) { s = !0; for (var a = this.at(r), h = 0; h < this.vertices.length; h++)
                if (this.canSee(r, h)) { var l = this.at(h),
                        c = l.x - a.x,
                        d = l.y - a.y,
                        u = c * c * d * d;
                    n > u && (e = r, i = h, n = u) } } if (!s && this.vertices.length > 8 && (e = 0, i = Math.floor(this.vertices.length / 2), s = !0), s) { var p = this.subPolygon(e, i).decompose(t + 1),
            m = this.subPolygon(i, e).decompose(t + 1);
        o = p.concat(m) } return 0 === o.length && o.push(this.vertices), o };
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    spine;
! function(t) { var e = function() {
        function t(t, e, i) { if (null == t) throw new Error("name cannot be null."); if (null == e) throw new Error("timelines cannot be null.");
            this.name = t, this.timelines = e, this.duration = i } return t.prototype.apply = function(t, e, i, o, n, s, r, a) { if (null == t) throw new Error("skeleton cannot be null.");
            o && 0 != this.duration && (i %= this.duration, e > 0 && (e %= this.duration)); for (var h = this.timelines, l = 0, c = h.length; l < c; l++) h[l].apply(t, e, i, n, s, r, a) }, t.binarySearch = function(t, e, i) { void 0 === i && (i = 1); var o = 0,
                n = t.length / i - 2; if (0 == n) return i; for (var s = n >>> 1;;) { if (t[(s + 1) * i] <= e ? o = s + 1 : n = s, o == n) return (o + 1) * i;
                s = o + n >>> 1 } }, t.linearSearch = function(t, e, i) { for (var o = 0, n = t.length - i; o <= n; o += i)
                if (t[o] > e) return o; return -1 }, t }();
    t.Animation = e; var i;! function(t) { t[t.setup = 0] = "setup", t[t.current = 1] = "current", t[t.currentLayered = 2] = "currentLayered" }(i = t.MixPose || (t.MixPose = {})); var o;! function(t) { t[t.in = 0] = "in", t[t.out = 1] = "out" }(o = t.MixDirection || (t.MixDirection = {})); var n;! function(t) { t[t.rotate = 0] = "rotate", t[t.translate = 1] = "translate", t[t.scale = 2] = "scale", t[t.shear = 3] = "shear", t[t.attachment = 4] = "attachment", t[t.color = 5] = "color", t[t.deform = 6] = "deform", t[t.event = 7] = "event", t[t.drawOrder = 8] = "drawOrder", t[t.ikConstraint = 9] = "ikConstraint", t[t.transformConstraint = 10] = "transformConstraint", t[t.pathConstraintPosition = 11] = "pathConstraintPosition", t[t.pathConstraintSpacing = 12] = "pathConstraintSpacing", t[t.pathConstraintMix = 13] = "pathConstraintMix", t[t.twoColor = 14] = "twoColor" }(n = t.TimelineType || (t.TimelineType = {})); var s = function() {
        function e(i) { if (i <= 0) throw new Error("frameCount must be > 0: " + i);
            this.curves = t.Utils.newFloatArray((i - 1) * e.BEZIER_SIZE) } return e.prototype.getFrameCount = function() { return this.curves.length / e.BEZIER_SIZE + 1 }, e.prototype.setLinear = function(t) { this.curves[t * e.BEZIER_SIZE] = e.LINEAR }, e.prototype.setStepped = function(t) { this.curves[t * e.BEZIER_SIZE] = e.STEPPED }, e.prototype.getCurveType = function(t) { var i = t * e.BEZIER_SIZE; if (i == this.curves.length) return e.LINEAR; var o = this.curves[i]; return o == e.LINEAR ? e.LINEAR : o == e.STEPPED ? e.STEPPED : e.BEZIER }, e.prototype.setCurve = function(t, i, o, n, s) { var r = .03 * (2 * -i + n),
                a = .03 * (2 * -o + s),
                h = .006 * (3 * (i - n) + 1),
                l = .006 * (3 * (o - s) + 1),
                c = 2 * r + h,
                d = 2 * a + l,
                u = .3 * i + r + .16666667 * h,
                p = .3 * o + a + .16666667 * l,
                m = t * e.BEZIER_SIZE,
                f = this.curves;
            f[m++] = e.BEZIER; for (var y = u, b = p, g = m + e.BEZIER_SIZE - 1; m < g; m += 2) f[m] = y, f[m + 1] = b, u += c, p += d, c += h, d += l, y += u, b += p }, e.prototype.getCurvePercent = function(i, o) { o = t.MathUtils.clamp(o, 0, 1); var n = this.curves,
                s = i * e.BEZIER_SIZE,
                r = n[s]; if (r == e.LINEAR) return o; if (r == e.STEPPED) return 0; for (var a = 0, h = ++s, l = s + e.BEZIER_SIZE - 1; s < l; s += 2)
                if ((a = n[s]) >= o) { var c = void 0,
                        d = void 0; return s == h ? (c = 0, d = 0) : (c = n[s - 2], d = n[s - 1]), d + (n[s + 1] - d) * (o - c) / (a - c) } var u = n[s - 1]; return u + (1 - u) * (o - a) / (1 - a) }, e }();
    s.LINEAR = 0, s.STEPPED = 1, s.BEZIER = 2, s.BEZIER_SIZE = 19, t.CurveTimeline = s; var r = function(o) {
        function s(e) { var i = o.call(this, e) || this; return i.frames = t.Utils.newFloatArray(e << 1), i } return __extends(s, o), s.prototype.getPropertyId = function() { return (n.rotate << 24) + this.boneIndex }, s.prototype.setFrame = function(t, e, i) { t <<= 1, this.frames[t] = e, this.frames[t + s.ROTATION] = i }, s.prototype.apply = function(t, o, n, r, a, h, l) { var c = this.frames,
                d = t.bones[this.boneIndex]; if (n < c[0]) switch (h) {
                case i.setup:
                    return void(d.rotation = d.data.rotation);
                case i.current:
                    var u = d.data.rotation - d.rotation;
                    u -= 360 * (16384 - (16384.499999999996 - u / 360 | 0)), d.rotation += u * a } else if (n >= c[c.length - s.ENTRIES])
                if (h == i.setup) d.rotation = d.data.rotation + c[c.length + s.PREV_ROTATION] * a;
                else { var p = d.data.rotation + c[c.length + s.PREV_ROTATION] - d.rotation;
                    p -= 360 * (16384 - (16384.499999999996 - p / 360 | 0)), d.rotation += p * a } else { var m = e.binarySearch(c, n, s.ENTRIES),
                    f = c[m + s.PREV_ROTATION],
                    y = c[m],
                    b = this.getCurvePercent((m >> 1) - 1, 1 - (n - y) / (c[m + s.PREV_TIME] - y)),
                    g = c[m + s.ROTATION] - f;
                g = f + (g -= 360 * (16384 - (16384.499999999996 - g / 360 | 0))) * b, h == i.setup ? (g -= 360 * (16384 - (16384.499999999996 - g / 360 | 0)), d.rotation = d.data.rotation + g * a) : (g = d.data.rotation + g - d.rotation, g -= 360 * (16384 - (16384.499999999996 - g / 360 | 0)), d.rotation += g * a) } }, s }(s);
    r.ENTRIES = 2, r.PREV_TIME = -2, r.PREV_ROTATION = -1, r.ROTATION = 1, t.RotateTimeline = r; var a = function(o) {
        function s(e) { var i = o.call(this, e) || this; return i.frames = t.Utils.newFloatArray(e * s.ENTRIES), i } return __extends(s, o), s.prototype.getPropertyId = function() { return (n.translate << 24) + this.boneIndex }, s.prototype.setFrame = function(t, e, i, o) { t *= s.ENTRIES, this.frames[t] = e, this.frames[t + s.X] = i, this.frames[t + s.Y] = o }, s.prototype.apply = function(t, o, n, r, a, h, l) { var c = this.frames,
                d = t.bones[this.boneIndex]; if (n < c[0]) switch (h) {
                case i.setup:
                    return d.x = d.data.x, void(d.y = d.data.y);
                case i.current:
                    d.x += (d.data.x - d.x) * a, d.y += (d.data.y - d.y) * a } else { var u = 0,
                    p = 0; if (n >= c[c.length - s.ENTRIES]) u = c[c.length + s.PREV_X], p = c[c.length + s.PREV_Y];
                else { var m = e.binarySearch(c, n, s.ENTRIES);
                    u = c[m + s.PREV_X], p = c[m + s.PREV_Y]; var f = c[m],
                        y = this.getCurvePercent(m / s.ENTRIES - 1, 1 - (n - f) / (c[m + s.PREV_TIME] - f));
                    u += (c[m + s.X] - u) * y, p += (c[m + s.Y] - p) * y } h == i.setup ? (d.x = d.data.x + u * a, d.y = d.data.y + p * a) : (d.x += (d.data.x + u - d.x) * a, d.y += (d.data.y + p - d.y) * a) } }, s }(s);
    a.ENTRIES = 3, a.PREV_TIME = -3, a.PREV_X = -2, a.PREV_Y = -1, a.X = 1, a.Y = 2, t.TranslateTimeline = a; var h = function(s) {
        function r(t) { return s.call(this, t) || this } return __extends(r, s), r.prototype.getPropertyId = function() { return (n.scale << 24) + this.boneIndex }, r.prototype.apply = function(n, s, a, h, l, c, d) { var u = this.frames,
                p = n.bones[this.boneIndex]; if (a < u[0]) switch (c) {
                case i.setup:
                    return p.scaleX = p.data.scaleX, void(p.scaleY = p.data.scaleY);
                case i.current:
                    p.scaleX += (p.data.scaleX - p.scaleX) * l, p.scaleY += (p.data.scaleY - p.scaleY) * l } else { var m = 0,
                    f = 0; if (a >= u[u.length - r.ENTRIES]) m = u[u.length + r.PREV_X] * p.data.scaleX, f = u[u.length + r.PREV_Y] * p.data.scaleY;
                else { var y = e.binarySearch(u, a, r.ENTRIES);
                    m = u[y + r.PREV_X], f = u[y + r.PREV_Y]; var b = u[y],
                        g = this.getCurvePercent(y / r.ENTRIES - 1, 1 - (a - b) / (u[y + r.PREV_TIME] - b));
                    m = (m + (u[y + r.X] - m) * g) * p.data.scaleX, f = (f + (u[y + r.Y] - f) * g) * p.data.scaleY } if (1 == l) p.scaleX = m, p.scaleY = f;
                else { var _ = 0,
                        v = 0;
                    c == i.setup ? (_ = p.data.scaleX, v = p.data.scaleY) : (_ = p.scaleX, v = p.scaleY), d == o.out ? (m = Math.abs(m) * t.MathUtils.signum(_), f = Math.abs(f) * t.MathUtils.signum(v)) : (_ = Math.abs(_) * t.MathUtils.signum(m), v = Math.abs(v) * t.MathUtils.signum(f)), p.scaleX = _ + (m - _) * l, p.scaleY = v + (f - v) * l } } }, r }(a);
    t.ScaleTimeline = h; var l = function(t) {
        function o(e) { return t.call(this, e) || this } return __extends(o, t), o.prototype.getPropertyId = function() { return (n.shear << 24) + this.boneIndex }, o.prototype.apply = function(t, n, s, r, a, h, l) { var c = this.frames,
                d = t.bones[this.boneIndex]; if (s < c[0]) switch (h) {
                case i.setup:
                    return d.shearX = d.data.shearX, void(d.shearY = d.data.shearY);
                case i.current:
                    d.shearX += (d.data.shearX - d.shearX) * a, d.shearY += (d.data.shearY - d.shearY) * a } else { var u = 0,
                    p = 0; if (s >= c[c.length - o.ENTRIES]) u = c[c.length + o.PREV_X], p = c[c.length + o.PREV_Y];
                else { var m = e.binarySearch(c, s, o.ENTRIES);
                    u = c[m + o.PREV_X], p = c[m + o.PREV_Y]; var f = c[m],
                        y = this.getCurvePercent(m / o.ENTRIES - 1, 1 - (s - f) / (c[m + o.PREV_TIME] - f));
                    u += (c[m + o.X] - u) * y, p += (c[m + o.Y] - p) * y } h == i.setup ? (d.shearX = d.data.shearX + u * a, d.shearY = d.data.shearY + p * a) : (d.shearX += (d.data.shearX + u - d.shearX) * a, d.shearY += (d.data.shearY + p - d.shearY) * a) } }, o }(a);
    t.ShearTimeline = l; var c = function(o) {
        function s(e) { var i = o.call(this, e) || this; return i.frames = t.Utils.newFloatArray(e * s.ENTRIES), i } return __extends(s, o), s.prototype.getPropertyId = function() { return (n.color << 24) + this.slotIndex }, s.prototype.setFrame = function(t, e, i, o, n, r) { t *= s.ENTRIES, this.frames[t] = e, this.frames[t + s.R] = i, this.frames[t + s.G] = o, this.frames[t + s.B] = n, this.frames[t + s.A] = r }, s.prototype.apply = function(t, o, n, r, a, h, l) { var c = t.slots[this.slotIndex],
                d = this.frames; if (n < d[0]) switch (h) {
                case i.setup:
                    return void c.color.setFromColor(c.data.color);
                case i.current:
                    var u = c.color,
                        p = c.data.color;
                    u.add((p.r - u.r) * a, (p.g - u.g) * a, (p.b - u.b) * a, (p.a - u.a) * a) } else { var m = 0,
                    f = 0,
                    y = 0,
                    b = 0; if (n >= d[d.length - s.ENTRIES]) { var g = d.length;
                    m = d[g + s.PREV_R], f = d[g + s.PREV_G], y = d[g + s.PREV_B], b = d[g + s.PREV_A] } else { var _ = e.binarySearch(d, n, s.ENTRIES);
                    m = d[_ + s.PREV_R], f = d[_ + s.PREV_G], y = d[_ + s.PREV_B], b = d[_ + s.PREV_A]; var v = d[_],
                        x = this.getCurvePercent(_ / s.ENTRIES - 1, 1 - (n - v) / (d[_ + s.PREV_TIME] - v));
                    m += (d[_ + s.R] - m) * x, f += (d[_ + s.G] - f) * x, y += (d[_ + s.B] - y) * x, b += (d[_ + s.A] - b) * x } if (1 == a) c.color.set(m, f, y, b);
                else { u = c.color;
                    h == i.setup && u.setFromColor(c.data.color), u.add((m - u.r) * a, (f - u.g) * a, (y - u.b) * a, (b - u.a) * a) } } }, s }(s);
    c.ENTRIES = 5, c.PREV_TIME = -5, c.PREV_R = -4, c.PREV_G = -3, c.PREV_B = -2, c.PREV_A = -1, c.R = 1, c.G = 2, c.B = 3, c.A = 4, t.ColorTimeline = c; var d = function(o) {
        function s(e) { var i = o.call(this, e) || this; return i.frames = t.Utils.newFloatArray(e * s.ENTRIES), i } return __extends(s, o), s.prototype.getPropertyId = function() { return (n.twoColor << 24) + this.slotIndex }, s.prototype.setFrame = function(t, e, i, o, n, r, a, h, l) { t *= s.ENTRIES, this.frames[t] = e, this.frames[t + s.R] = i, this.frames[t + s.G] = o, this.frames[t + s.B] = n, this.frames[t + s.A] = r, this.frames[t + s.R2] = a, this.frames[t + s.G2] = h, this.frames[t + s.B2] = l }, s.prototype.apply = function(t, o, n, r, a, h, l) { var c = t.slots[this.slotIndex],
                d = this.frames; if (n < d[0]) switch (h) {
                case i.setup:
                    return c.color.setFromColor(c.data.color), void c.darkColor.setFromColor(c.data.darkColor);
                case i.current:
                    var u = c.color,
                        p = c.darkColor,
                        m = c.data.color,
                        f = c.data.darkColor;
                    u.add((m.r - u.r) * a, (m.g - u.g) * a, (m.b - u.b) * a, (m.a - u.a) * a), p.add((f.r - p.r) * a, (f.g - p.g) * a, (f.b - p.b) * a, 0) } else { var y = 0,
                    b = 0,
                    g = 0,
                    _ = 0,
                    v = 0,
                    x = 0,
                    S = 0; if (n >= d[d.length - s.ENTRIES]) { var C = d.length;
                    y = d[C + s.PREV_R], b = d[C + s.PREV_G], g = d[C + s.PREV_B], _ = d[C + s.PREV_A], v = d[C + s.PREV_R2], x = d[C + s.PREV_G2], S = d[C + s.PREV_B2] } else { var w = e.binarySearch(d, n, s.ENTRIES);
                    y = d[w + s.PREV_R], b = d[w + s.PREV_G], g = d[w + s.PREV_B], _ = d[w + s.PREV_A], v = d[w + s.PREV_R2], x = d[w + s.PREV_G2], S = d[w + s.PREV_B2]; var A = d[w],
                        T = this.getCurvePercent(w / s.ENTRIES - 1, 1 - (n - A) / (d[w + s.PREV_TIME] - A));
                    y += (d[w + s.R] - y) * T, b += (d[w + s.G] - b) * T, g += (d[w + s.B] - g) * T, _ += (d[w + s.A] - _) * T, v += (d[w + s.R2] - v) * T, x += (d[w + s.G2] - x) * T, S += (d[w + s.B2] - S) * T } if (1 == a) c.color.set(y, b, g, _), c.darkColor.set(v, x, S, 1);
                else { var u = c.color,
                        p = c.darkColor;
                    h == i.setup && (u.setFromColor(c.data.color), p.setFromColor(c.data.darkColor)), u.add((y - u.r) * a, (b - u.g) * a, (g - u.b) * a, (_ - u.a) * a), p.add((v - p.r) * a, (x - p.g) * a, (S - p.b) * a, 0) } } }, s }(s);
    d.ENTRIES = 8, d.PREV_TIME = -8, d.PREV_R = -7, d.PREV_G = -6, d.PREV_B = -5, d.PREV_A = -4, d.PREV_R2 = -3, d.PREV_G2 = -2, d.PREV_B2 = -1, d.R = 1, d.G = 2, d.B = 3, d.A = 4, d.R2 = 5, d.G2 = 6, d.B2 = 7, t.TwoColorTimeline = d; var u = function() {
        function s(e) { this.frames = t.Utils.newFloatArray(e), this.attachmentNames = new Array(e) } return s.prototype.getPropertyId = function() { return (n.attachment << 24) + this.slotIndex }, s.prototype.getFrameCount = function() { return this.frames.length }, s.prototype.setFrame = function(t, e, i) { this.frames[t] = e, this.attachmentNames[t] = i }, s.prototype.apply = function(t, n, s, r, a, h, l) { var c = t.slots[this.slotIndex]; if (l != o.out || h != i.setup) { var d = this.frames; if (s < d[0]) { if (h == i.setup) { var u = c.data.attachmentName;
                        c.setAttachment(null == u ? null : t.getAttachment(this.slotIndex, u)) } } else { var p = 0;
                    p = s >= d[d.length - 1] ? d.length - 1 : e.binarySearch(d, s, 1) - 1; var m = this.attachmentNames[p];
                    t.slots[this.slotIndex].setAttachment(null == m ? null : t.getAttachment(this.slotIndex, m)) } } else { var f = c.data.attachmentName;
                c.setAttachment(null == f ? null : t.getAttachment(this.slotIndex, f)) } }, s }();
    t.AttachmentTimeline = u; var p = null,
        m = function(o) {
            function s(e) { var i = o.call(this, e) || this; return i.frames = t.Utils.newFloatArray(e), i.frameVertices = new Array(e), null == p && (p = t.Utils.newFloatArray(64)), i } return __extends(s, o), s.prototype.getPropertyId = function() { return (n.deform << 27) + +this.attachment.id + this.slotIndex }, s.prototype.setFrame = function(t, e, i) { this.frames[t] = e, this.frameVertices[t] = i }, s.prototype.apply = function(o, n, s, r, a, h, l) { var c = o.slots[this.slotIndex],
                    d = c.getAttachment(); if (d instanceof t.VertexAttachment && d.applyDeform(this.attachment)) { var u = c.attachmentVertices,
                        m = this.frameVertices,
                        f = m[0].length,
                        y = t.Utils.setArraySize(u, f),
                        b = this.frames; if (s < b[0]) { var g = d; switch (h) {
                            case i.setup:
                                var _; return null == g.bones ? _ = g.vertices : (_ = p).length < f && (p = _ = t.Utils.newFloatArray(f)), void t.Utils.arrayCopy(_, 0, y, 0, f);
                            case i.current:
                                if (1 == a) break; if (null == g.bones)
                                    for (var v = g.vertices, x = 0; x < f; x++) y[x] += (v[x] - y[x]) * a;
                                else { a = 1 - a; for (x = 0; x < f; x++) y[x] *= a } } } else if (s >= b[b.length - 1]) { var S = m[b.length - 1]; if (1 == a) t.Utils.arrayCopy(S, 0, y, 0, f);
                        else if (h == i.setup)
                            if (null == (g = d).bones)
                                for (var C = g.vertices, w = 0; w < f; w++) { R = C[w];
                                    y[w] = R + (S[w] - R) * a } else
                                    for (var A = 0; A < f; A++) y[A] = S[A] * a;
                            else
                                for (var T = 0; T < f; T++) y[T] += (S[T] - y[T]) * a } else { var P = e.binarySearch(b, s),
                            k = m[P - 1],
                            M = m[P],
                            E = b[P],
                            B = this.getCurvePercent(P - 1, 1 - (s - E) / (b[P - 1] - E)); if (1 == a)
                            for (var I = 0; I < f; I++) { O = k[I];
                                y[I] = O + (M[I] - O) * B } else if (h == i.setup)
                                if (null == (g = d).bones)
                                    for (var D = g.vertices, L = 0; L < f; L++) { var O = k[L],
                                            R = D[L];
                                        y[L] = R + (O + (M[L] - O) * B - R) * a } else
                                        for (var F = 0; F < f; F++) { O = k[F];
                                            y[F] = (O + (M[F] - O) * B) * a } else
                                            for (var V = 0; V < f; V++) { O = k[V];
                                                y[V] += (O + (M[V] - O) * B - y[V]) * a } } } }, s }(s);
    t.DeformTimeline = m; var f = function() {
        function i(e) { this.frames = t.Utils.newFloatArray(e), this.events = new Array(e) } return i.prototype.getPropertyId = function() { return n.event << 24 }, i.prototype.getFrameCount = function() { return this.frames.length }, i.prototype.setFrame = function(t, e) { this.frames[t] = e.time, this.events[t] = e }, i.prototype.apply = function(t, i, o, n, s, r, a) { if (null != n) { var h = this.frames,
                    l = this.frames.length; if (i > o) this.apply(t, i, Number.MAX_VALUE, n, s, r, a), i = -1;
                else if (i >= h[l - 1]) return; if (!(o < h[0])) { var c = 0; if (i < h[0]) c = 0;
                    else
                        for (var d = h[c = e.binarySearch(h, i)]; c > 0 && h[c - 1] == d;) c--; for (; c < l && o >= h[c]; c++) n.push(this.events[c]) } } }, i }();
    t.EventTimeline = f; var y = function() {
        function s(e) { this.frames = t.Utils.newFloatArray(e), this.drawOrders = new Array(e) } return s.prototype.getPropertyId = function() { return n.drawOrder << 24 }, s.prototype.getFrameCount = function() { return this.frames.length }, s.prototype.setFrame = function(t, e, i) { this.frames[t] = e, this.drawOrders[t] = i }, s.prototype.apply = function(n, s, r, a, h, l, c) { var d = n.drawOrder,
                u = n.slots; if (c != o.out || l != i.setup) { var p = this.frames; if (r < p[0]) l == i.setup && t.Utils.arrayCopy(n.slots, 0, n.drawOrder, 0, n.slots.length);
                else { var m = 0;
                    m = r >= p[p.length - 1] ? p.length - 1 : e.binarySearch(p, r) - 1; var f = this.drawOrders[m]; if (null == f) t.Utils.arrayCopy(u, 0, d, 0, u.length);
                    else
                        for (var y = 0, b = f.length; y < b; y++) d[y] = u[f[y]] } } else t.Utils.arrayCopy(n.slots, 0, n.drawOrder, 0, n.slots.length) }, s }();
    t.DrawOrderTimeline = y; var b = function(s) {
        function r(e) { var i = s.call(this, e) || this; return i.frames = t.Utils.newFloatArray(e * r.ENTRIES), i } return __extends(r, s), r.prototype.getPropertyId = function() { return (n.ikConstraint << 24) + this.ikConstraintIndex }, r.prototype.setFrame = function(t, e, i, o) { t *= r.ENTRIES, this.frames[t] = e, this.frames[t + r.MIX] = i, this.frames[t + r.BEND_DIRECTION] = o }, r.prototype.apply = function(t, n, s, a, h, l, c) { var d = this.frames,
                u = t.ikConstraints[this.ikConstraintIndex]; if (s < d[0]) switch (l) {
                    case i.setup:
                        return u.mix = u.data.mix, void(u.bendDirection = u.data.bendDirection);
                    case i.current:
                        u.mix += (u.data.mix - u.mix) * h, u.bendDirection = u.data.bendDirection } else if (s >= d[d.length - r.ENTRIES]) l == i.setup ? (u.mix = u.data.mix + (d[d.length + r.PREV_MIX] - u.data.mix) * h, u.bendDirection = c == o.out ? u.data.bendDirection : d[d.length + r.PREV_BEND_DIRECTION]) : (u.mix += (d[d.length + r.PREV_MIX] - u.mix) * h, c == o.in && (u.bendDirection = d[d.length + r.PREV_BEND_DIRECTION]));
                else { var p = e.binarySearch(d, s, r.ENTRIES),
                        m = d[p + r.PREV_MIX],
                        f = d[p],
                        y = this.getCurvePercent(p / r.ENTRIES - 1, 1 - (s - f) / (d[p + r.PREV_TIME] - f));
                    l == i.setup ? (u.mix = u.data.mix + (m + (d[p + r.MIX] - m) * y - u.data.mix) * h, u.bendDirection = c == o.out ? u.data.bendDirection : d[p + r.PREV_BEND_DIRECTION]) : (u.mix += (m + (d[p + r.MIX] - m) * y - u.mix) * h, c == o.in && (u.bendDirection = d[p + r.PREV_BEND_DIRECTION])) } }, r }(s);
    b.ENTRIES = 3, b.PREV_TIME = -3, b.PREV_MIX = -2, b.PREV_BEND_DIRECTION = -1, b.MIX = 1, b.BEND_DIRECTION = 2, t.IkConstraintTimeline = b; var g = function(o) {
        function s(e) { var i = o.call(this, e) || this; return i.frames = t.Utils.newFloatArray(e * s.ENTRIES), i } return __extends(s, o), s.prototype.getPropertyId = function() { return (n.transformConstraint << 24) + this.transformConstraintIndex }, s.prototype.setFrame = function(t, e, i, o, n, r) { t *= s.ENTRIES, this.frames[t] = e, this.frames[t + s.ROTATE] = i, this.frames[t + s.TRANSLATE] = o, this.frames[t + s.SCALE] = n, this.frames[t + s.SHEAR] = r }, s.prototype.apply = function(t, o, n, r, a, h, l) { var c = this.frames,
                d = t.transformConstraints[this.transformConstraintIndex]; if (n < c[0]) { v = d.data; switch (h) {
                    case i.setup:
                        return d.rotateMix = v.rotateMix, d.translateMix = v.translateMix, d.scaleMix = v.scaleMix, void(d.shearMix = v.shearMix);
                    case i.current:
                        d.rotateMix += (v.rotateMix - d.rotateMix) * a, d.translateMix += (v.translateMix - d.translateMix) * a, d.scaleMix += (v.scaleMix - d.scaleMix) * a, d.shearMix += (v.shearMix - d.shearMix) * a } } else { var u = 0,
                    p = 0,
                    m = 0,
                    f = 0; if (n >= c[c.length - s.ENTRIES]) { var y = c.length;
                    u = c[y + s.PREV_ROTATE], p = c[y + s.PREV_TRANSLATE], m = c[y + s.PREV_SCALE], f = c[y + s.PREV_SHEAR] } else { var b = e.binarySearch(c, n, s.ENTRIES);
                    u = c[b + s.PREV_ROTATE], p = c[b + s.PREV_TRANSLATE], m = c[b + s.PREV_SCALE], f = c[b + s.PREV_SHEAR]; var g = c[b],
                        _ = this.getCurvePercent(b / s.ENTRIES - 1, 1 - (n - g) / (c[b + s.PREV_TIME] - g));
                    u += (c[b + s.ROTATE] - u) * _, p += (c[b + s.TRANSLATE] - p) * _, m += (c[b + s.SCALE] - m) * _, f += (c[b + s.SHEAR] - f) * _ } if (h == i.setup) { var v = d.data;
                    d.rotateMix = v.rotateMix + (u - v.rotateMix) * a, d.translateMix = v.translateMix + (p - v.translateMix) * a, d.scaleMix = v.scaleMix + (m - v.scaleMix) * a, d.shearMix = v.shearMix + (f - v.shearMix) * a } else d.rotateMix += (u - d.rotateMix) * a, d.translateMix += (p - d.translateMix) * a, d.scaleMix += (m - d.scaleMix) * a, d.shearMix += (f - d.shearMix) * a } }, s }(s);
    g.ENTRIES = 5, g.PREV_TIME = -5, g.PREV_ROTATE = -4, g.PREV_TRANSLATE = -3, g.PREV_SCALE = -2, g.PREV_SHEAR = -1, g.ROTATE = 1, g.TRANSLATE = 2, g.SCALE = 3, g.SHEAR = 4, t.TransformConstraintTimeline = g; var _ = function(o) {
        function s(e) { var i = o.call(this, e) || this; return i.frames = t.Utils.newFloatArray(e * s.ENTRIES), i } return __extends(s, o), s.prototype.getPropertyId = function() { return (n.pathConstraintPosition << 24) + this.pathConstraintIndex }, s.prototype.setFrame = function(t, e, i) { t *= s.ENTRIES, this.frames[t] = e, this.frames[t + s.VALUE] = i }, s.prototype.apply = function(t, o, n, r, a, h, l) { var c = this.frames,
                d = t.pathConstraints[this.pathConstraintIndex]; if (n < c[0]) switch (h) {
                case i.setup:
                    return void(d.position = d.data.position);
                case i.current:
                    d.position += (d.data.position - d.position) * a } else { var u = 0; if (n >= c[c.length - s.ENTRIES]) u = c[c.length + s.PREV_VALUE];
                else { var p = e.binarySearch(c, n, s.ENTRIES);
                    u = c[p + s.PREV_VALUE]; var m = c[p],
                        f = this.getCurvePercent(p / s.ENTRIES - 1, 1 - (n - m) / (c[p + s.PREV_TIME] - m));
                    u += (c[p + s.VALUE] - u) * f } h == i.setup ? d.position = d.data.position + (u - d.data.position) * a : d.position += (u - d.position) * a } }, s }(s);
    _.ENTRIES = 2, _.PREV_TIME = -2, _.PREV_VALUE = -1, _.VALUE = 1, t.PathConstraintPositionTimeline = _; var v = function(t) {
        function o(e) { return t.call(this, e) || this } return __extends(o, t), o.prototype.getPropertyId = function() { return (n.pathConstraintSpacing << 24) + this.pathConstraintIndex }, o.prototype.apply = function(t, n, s, r, a, h, l) { var c = this.frames,
                d = t.pathConstraints[this.pathConstraintIndex]; if (s < c[0]) switch (h) {
                case i.setup:
                    return void(d.spacing = d.data.spacing);
                case i.current:
                    d.spacing += (d.data.spacing - d.spacing) * a } else { var u = 0; if (s >= c[c.length - o.ENTRIES]) u = c[c.length + o.PREV_VALUE];
                else { var p = e.binarySearch(c, s, o.ENTRIES);
                    u = c[p + o.PREV_VALUE]; var m = c[p],
                        f = this.getCurvePercent(p / o.ENTRIES - 1, 1 - (s - m) / (c[p + o.PREV_TIME] - m));
                    u += (c[p + o.VALUE] - u) * f } h == i.setup ? d.spacing = d.data.spacing + (u - d.data.spacing) * a : d.spacing += (u - d.spacing) * a } }, o }(_);
    t.PathConstraintSpacingTimeline = v; var x = function(o) {
        function s(e) { var i = o.call(this, e) || this; return i.frames = t.Utils.newFloatArray(e * s.ENTRIES), i } return __extends(s, o), s.prototype.getPropertyId = function() { return (n.pathConstraintMix << 24) + this.pathConstraintIndex }, s.prototype.setFrame = function(t, e, i, o) { t *= s.ENTRIES, this.frames[t] = e, this.frames[t + s.ROTATE] = i, this.frames[t + s.TRANSLATE] = o }, s.prototype.apply = function(t, o, n, r, a, h, l) { var c = this.frames,
                d = t.pathConstraints[this.pathConstraintIndex]; if (n < c[0]) switch (h) {
                case i.setup:
                    return d.rotateMix = d.data.rotateMix, void(d.translateMix = d.data.translateMix);
                case i.current:
                    d.rotateMix += (d.data.rotateMix - d.rotateMix) * a, d.translateMix += (d.data.translateMix - d.translateMix) * a } else { var u = 0,
                    p = 0; if (n >= c[c.length - s.ENTRIES]) u = c[c.length + s.PREV_ROTATE], p = c[c.length + s.PREV_TRANSLATE];
                else { var m = e.binarySearch(c, n, s.ENTRIES);
                    u = c[m + s.PREV_ROTATE], p = c[m + s.PREV_TRANSLATE]; var f = c[m],
                        y = this.getCurvePercent(m / s.ENTRIES - 1, 1 - (n - f) / (c[m + s.PREV_TIME] - f));
                    u += (c[m + s.ROTATE] - u) * y, p += (c[m + s.TRANSLATE] - p) * y } h == i.setup ? (d.rotateMix = d.data.rotateMix + (u - d.data.rotateMix) * a, d.translateMix = d.data.translateMix + (p - d.data.translateMix) * a) : (d.rotateMix += (u - d.rotateMix) * a, d.translateMix += (p - d.translateMix) * a) } }, s }(s);
    x.ENTRIES = 3, x.PREV_TIME = -3, x.PREV_ROTATE = -2, x.PREV_TRANSLATE = -1, x.ROTATE = 1, x.TRANSLATE = 2, t.PathConstraintMixTimeline = x }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e(e) { this.tracks = new Array, this.events = new Array, this.listeners = new Array, this.queue = new o(this), this.propertyIDs = new t.IntSet, this.mixingTo = new Array, this.animationsChanged = !1, this.timeScale = 1, this.trackEntryPool = new t.Pool(function() { return new i }), this.data = e } return e.prototype.update = function(t) { t *= this.timeScale; for (var e = this.tracks, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (null != n) { n.animationLast = n.nextAnimationLast, n.trackLast = n.nextTrackLast; var s = t * n.timeScale; if (n.delay > 0) { if (n.delay -= s, n.delay > 0) continue;
                        s = -n.delay, n.delay = 0 } var r = n.next; if (null != r) { var a = n.trackLast - r.delay; if (a >= 0) { for (r.delay = 0, r.trackTime = a + t * r.timeScale, n.trackTime += s, this.setCurrent(i, r, !0); null != r.mixingFrom;) r.mixTime += s, r = r.mixingFrom; continue } } else if (n.trackLast >= n.trackEnd && null == n.mixingFrom) { e[i] = null, this.queue.end(n), this.disposeNext(n); continue } if (null != n.mixingFrom && this.updateMixingFrom(n, t)) { var h = n.mixingFrom; for (n.mixingFrom = null; null != h;) this.queue.end(h), h = h.mixingFrom } n.trackTime += s } } this.queue.drain() }, e.prototype.updateMixingFrom = function(t, e) { var i = t.mixingFrom; if (null == i) return !0; var o = this.updateMixingFrom(i, e); return t.mixTime > 0 && (t.mixTime >= t.mixDuration || 0 == t.timeScale) ? (0 == i.totalAlpha && (t.mixingFrom = i.mixingFrom, t.interruptAlpha = i.interruptAlpha, this.queue.end(i)), o) : (i.animationLast = i.nextAnimationLast, i.trackLast = i.nextTrackLast, i.trackTime += e * i.timeScale, t.mixTime += e * t.timeScale, !1) }, e.prototype.apply = function(i) { if (null == i) throw new Error("skeleton cannot be null.");
            this.animationsChanged && this._animationsChanged(); for (var o = this.events, n = this.tracks, s = !1, r = 0, a = n.length; r < a; r++) { var h = n[r]; if (!(null == h || h.delay > 0)) { s = !0; var l = 0 == r ? t.MixPose.current : t.MixPose.currentLayered,
                        c = h.alpha;
                    null != h.mixingFrom ? c *= this.applyMixingFrom(h, i, l) : h.trackTime >= h.trackEnd && null == h.next && (c = 0); var d = h.animationLast,
                        u = h.getAnimationTime(),
                        p = h.animation.timelines.length,
                        m = h.animation.timelines; if (1 == c)
                        for (g = 0; g < p; g++) m[g].apply(i, d, u, o, 1, t.MixPose.setup, t.MixDirection.in);
                    else { var f = h.timelineData,
                            y = 0 == h.timelinesRotation.length;
                        y && t.Utils.setArraySize(h.timelinesRotation, p << 1, null); for (var b = h.timelinesRotation, g = 0; g < p; g++) { var _ = m[g],
                                v = f[g] >= e.FIRST ? t.MixPose.setup : l;
                            _ instanceof t.RotateTimeline ? this.applyRotateTimeline(_, i, u, c, v, b, g << 1, y) : _.apply(i, d, u, o, c, v, t.MixDirection.in) } } this.queueEvents(h, u), o.length = 0, h.nextAnimationLast = u, h.nextTrackLast = h.trackTime } } return this.queue.drain(), s }, e.prototype.applyMixingFrom = function(i, o, n) { var s = i.mixingFrom;
            null != s.mixingFrom && this.applyMixingFrom(s, o, n); var r = 0;
            0 == i.mixDuration ? r = 1 : (r = i.mixTime / i.mixDuration) > 1 && (r = 1); var a = r < s.eventThreshold ? this.events : null,
                h = r < s.attachmentThreshold,
                l = r < s.drawOrderThreshold,
                c = s.animationLast,
                d = s.getAnimationTime(),
                u = s.animation.timelines.length,
                p = s.animation.timelines,
                m = s.timelineData,
                f = s.timelineDipMix,
                y = 0 == s.timelinesRotation.length;
            y && t.Utils.setArraySize(s.timelinesRotation, u << 1, null); var b, g = s.timelinesRotation,
                _ = s.alpha * i.interruptAlpha,
                v = _ * (1 - r),
                x = 0;
            s.totalAlpha = 0; for (var S = 0; S < u; S++) { var C = p[S]; switch (m[S]) {
                    case e.SUBSEQUENT:
                        if (!h && C instanceof t.AttachmentTimeline) continue; if (!l && C instanceof t.DrawOrderTimeline) continue;
                        b = n, x = v; break;
                    case e.FIRST:
                        b = t.MixPose.setup, x = v; break;
                    case e.DIP:
                        b = t.MixPose.setup, x = _; break;
                    default:
                        b = t.MixPose.setup, x = _; var w = f[S];
                        x *= Math.max(0, 1 - w.mixTime / w.mixDuration) } s.totalAlpha += x, C instanceof t.RotateTimeline ? this.applyRotateTimeline(C, o, d, x, b, g, S << 1, y) : C.apply(o, c, d, a, x, b, t.MixDirection.out) } return i.mixDuration > 0 && this.queueEvents(s, d), this.events.length = 0, s.nextAnimationLast = d, s.nextTrackLast = s.trackTime, r }, e.prototype.applyRotateTimeline = function(e, i, o, n, s, r, a, h) { if (h && (r[a] = 0), 1 != n) { var l = e,
                    c = l.frames,
                    d = i.bones[l.boneIndex]; if (o < c[0]) s == t.MixPose.setup && (d.rotation = d.data.rotation);
                else { var u = 0; if (o >= c[c.length - t.RotateTimeline.ENTRIES]) u = d.data.rotation + c[c.length + t.RotateTimeline.PREV_ROTATION];
                    else { var p = t.Animation.binarySearch(c, o, t.RotateTimeline.ENTRIES),
                            m = c[p + t.RotateTimeline.PREV_ROTATION],
                            f = c[p],
                            y = l.getCurvePercent((p >> 1) - 1, 1 - (o - f) / (c[p + t.RotateTimeline.PREV_TIME] - f));
                        u = c[p + t.RotateTimeline.ROTATION] - m, u = m + (u -= 360 * (16384 - (16384.499999999996 - u / 360 | 0))) * y + d.data.rotation, u -= 360 * (16384 - (16384.499999999996 - u / 360 | 0)) } var b = s == t.MixPose.setup ? d.data.rotation : d.rotation,
                        g = 0,
                        _ = u - b; if (0 == _) g = r[a];
                    else { _ -= 360 * (16384 - (16384.499999999996 - _ / 360 | 0)); var v = 0,
                            x = 0;
                        h ? (v = 0, x = _) : (v = r[a], x = r[a + 1]); var S = _ > 0,
                            C = v >= 0;
                        t.MathUtils.signum(x) != t.MathUtils.signum(_) && Math.abs(x) <= 90 && (Math.abs(v) > 180 && (v += 360 * t.MathUtils.signum(v)), C = S), g = _ + v - v % 360, C != S && (g += 360 * t.MathUtils.signum(v)), r[a] = g } r[a + 1] = _, b += g * n, d.rotation = b - 360 * (16384 - (16384.499999999996 - b / 360 | 0)) } } else e.apply(i, 0, o, null, 1, s, t.MixDirection.in) }, e.prototype.queueEvents = function(t, e) { for (var i = t.animationStart, o = t.animationEnd, n = o - i, s = t.trackLast % n, r = this.events, a = 0, h = r.length; a < h; a++) { var l = r[a]; if (l.time < s) break;
                l.time > o || this.queue.event(t, l) } for ((t.loop ? s > t.trackTime % n : e >= o && t.animationLast < o) && this.queue.complete(t); a < h; a++) r[a].time < i || this.queue.event(t, r[a]) }, e.prototype.clearTracks = function() { var t = this.queue.drainDisabled;
            this.queue.drainDisabled = !0; for (var e = 0, i = this.tracks.length; e < i; e++) this.clearTrack(e);
            this.tracks.length = 0, this.queue.drainDisabled = t, this.queue.drain() }, e.prototype.clearTrack = function(t) { if (!(t >= this.tracks.length)) { var e = this.tracks[t]; if (null != e) { this.queue.end(e), this.disposeNext(e); for (var i = e;;) { var o = i.mixingFrom; if (null == o) break;
                        this.queue.end(o), i.mixingFrom = null, i = o } this.tracks[e.trackIndex] = null, this.queue.drain() } } }, e.prototype.setCurrent = function(t, e, i) { var o = this.expandToIndex(t);
            this.tracks[t] = e, null != o && (i && this.queue.interrupt(o), e.mixingFrom = o, e.mixTime = 0, null != o.mixingFrom && o.mixDuration > 0 && (e.interruptAlpha *= Math.min(1, o.mixTime / o.mixDuration)), o.timelinesRotation.length = 0), this.queue.start(e) }, e.prototype.setAnimation = function(t, e, i) { var o = this.data.skeletonData.findAnimation(e); if (null == o) throw new Error("Animation not found: " + e); return this.setAnimationWith(t, o, i) }, e.prototype.setAnimationWith = function(t, e, i) { if (null == e) throw new Error("animation cannot be null."); var o = !0,
                n = this.expandToIndex(t);
            null != n && (-1 == n.nextTrackLast ? (this.tracks[t] = n.mixingFrom, this.queue.interrupt(n), this.queue.end(n), this.disposeNext(n), n = n.mixingFrom, o = !1) : this.disposeNext(n)); var s = this.trackEntry(t, e, i, n); return this.setCurrent(t, s, o), this.queue.drain(), s }, e.prototype.addAnimation = function(t, e, i, o) { var n = this.data.skeletonData.findAnimation(e); if (null == n) throw new Error("Animation not found: " + e); return this.addAnimationWith(t, n, i, o) }, e.prototype.addAnimationWith = function(t, e, i, o) { if (null == e) throw new Error("animation cannot be null."); var n = this.expandToIndex(t); if (null != n)
                for (; null != n.next;) n = n.next; var s = this.trackEntry(t, e, i, n); if (null == n) this.setCurrent(t, s, !0), this.queue.drain();
            else if (n.next = s, o <= 0) { var r = n.animationEnd - n.animationStart;
                0 != r ? o += r * (1 + (n.trackTime / r | 0)) - this.data.getMix(n.animation, e) : o = 0 } return s.delay = o, s }, e.prototype.setEmptyAnimation = function(t, i) { var o = this.setAnimationWith(t, e.emptyAnimation, !1); return o.mixDuration = i, o.trackEnd = i, o }, e.prototype.addEmptyAnimation = function(t, i, o) { o <= 0 && (o -= i); var n = this.addAnimationWith(t, e.emptyAnimation, !1, o); return n.mixDuration = i, n.trackEnd = i, n }, e.prototype.setEmptyAnimations = function(t) { var e = this.queue.drainDisabled;
            this.queue.drainDisabled = !0; for (var i = 0, o = this.tracks.length; i < o; i++) { var n = this.tracks[i];
                null != n && this.setEmptyAnimation(n.trackIndex, t) } this.queue.drainDisabled = e, this.queue.drain() }, e.prototype.expandToIndex = function(e) { return e < this.tracks.length ? this.tracks[e] : (t.Utils.ensureArrayCapacity(this.tracks, e - this.tracks.length + 1, null), this.tracks.length = e + 1, null) }, e.prototype.trackEntry = function(t, e, i, o) { var n = this.trackEntryPool.obtain(); return n.trackIndex = t, n.animation = e, n.loop = i, n.eventThreshold = 0, n.attachmentThreshold = 0, n.drawOrderThreshold = 0, n.animationStart = 0, n.animationEnd = e.duration, n.animationLast = -1, n.nextAnimationLast = -1, n.delay = 0, n.trackTime = 0, n.trackLast = -1, n.nextTrackLast = -1, n.trackEnd = Number.MAX_VALUE, n.timeScale = 1, n.alpha = 1, n.interruptAlpha = 1, n.mixTime = 0, n.mixDuration = null == o ? 0 : this.data.getMix(o.animation, e), n }, e.prototype.disposeNext = function(t) { for (var e = t.next; null != e;) this.queue.dispose(e), e = e.next;
            t.next = null }, e.prototype._animationsChanged = function() { this.animationsChanged = !1; var t = this.propertyIDs;
            t.clear(); for (var e = this.mixingTo, i = 0, o = this.tracks.length; i < o; i++) { var n = this.tracks[i];
                null != n && n.setTimelineData(null, e, t) } }, e.prototype.getCurrent = function(t) { return t >= this.tracks.length ? null : this.tracks[t] }, e.prototype.addListener = function(t) { if (null == t) throw new Error("listener cannot be null.");
            this.listeners.push(t) }, e.prototype.removeListener = function(t) { var e = this.listeners.indexOf(t);
            e >= 0 && this.listeners.splice(e, 1) }, e.prototype.clearListeners = function() { this.listeners.length = 0 }, e.prototype.clearListenerNotifications = function() { this.queue.clear() }, e }();
    e.emptyAnimation = new t.Animation("<empty>", [], 0), e.SUBSEQUENT = 0, e.FIRST = 1, e.DIP = 2, e.DIP_MIX = 3, t.AnimationState = e; var i = function() {
        function i() { this.timelineData = new Array, this.timelineDipMix = new Array, this.timelinesRotation = new Array } return i.prototype.reset = function() { this.next = null, this.mixingFrom = null, this.animation = null, this.listener = null, this.timelineData.length = 0, this.timelineDipMix.length = 0, this.timelinesRotation.length = 0 }, i.prototype.setTimelineData = function(i, o, n) { null != i && o.push(i); var s = null != this.mixingFrom ? this.mixingFrom.setTimelineData(this, o, n) : this;
            null != i && o.pop(); var r = o,
                a = o.length - 1,
                h = this.animation.timelines,
                l = this.animation.timelines.length,
                c = t.Utils.setArraySize(this.timelineData, l);
            this.timelineDipMix.length = 0; var d = t.Utils.setArraySize(this.timelineDipMix, l);
            t: for (var u = 0; u < l; u++) { var p = h[u].getPropertyId(); if (n.add(p))
                    if (null != i && i.hasTimeline(p)) { for (var m = a; m >= 0; m--) { var f = r[m]; if (!f.hasTimeline(p) && f.mixDuration > 0) { c[u] = e.DIP_MIX, d[u] = f; continue t } } c[u] = e.DIP } else c[u] = e.FIRST;
                else c[u] = e.SUBSEQUENT }
            return s }, i.prototype.hasTimeline = function(t) { for (var e = this.animation.timelines, i = 0, o = e.length; i < o; i++)
                if (e[i].getPropertyId() == t) return !0; return !1 }, i.prototype.getAnimationTime = function() { if (this.loop) { var t = this.animationEnd - this.animationStart; return 0 == t ? this.animationStart : this.trackTime % t + this.animationStart } return Math.min(this.trackTime + this.animationStart, this.animationEnd) }, i.prototype.setAnimationLast = function(t) { this.animationLast = t, this.nextAnimationLast = t }, i.prototype.isComplete = function() { return this.trackTime >= this.animationEnd - this.animationStart }, i.prototype.resetRotationDirections = function() { this.timelinesRotation.length = 0 }, i }();
    t.TrackEntry = i; var o = function() {
        function t(t) { this.objects = [], this.drainDisabled = !1, this.animState = t } return t.prototype.start = function(t) { this.objects.push(n.start), this.objects.push(t), this.animState.animationsChanged = !0 }, t.prototype.interrupt = function(t) { this.objects.push(n.interrupt), this.objects.push(t) }, t.prototype.end = function(t) { this.objects.push(n.end), this.objects.push(t), this.animState.animationsChanged = !0 }, t.prototype.dispose = function(t) { this.objects.push(n.dispose), this.objects.push(t) }, t.prototype.complete = function(t) { this.objects.push(n.complete), this.objects.push(t) }, t.prototype.event = function(t, e) { this.objects.push(n.event), this.objects.push(t), this.objects.push(e) }, t.prototype.drain = function() { if (!this.drainDisabled) { this.drainDisabled = !0; for (var t = this.objects, e = this.animState.listeners, i = 0; i < t.length; i += 2) { var o = t[i],
                        s = t[i + 1]; switch (o) {
                        case n.start:
                            null != s.listener && s.listener.start && s.listener.start(s); for (a = 0; a < e.length; a++) e[a].start && e[a].start(s); break;
                        case n.interrupt:
                            null != s.listener && s.listener.interrupt && s.listener.interrupt(s); for (a = 0; a < e.length; a++) e[a].interrupt && e[a].interrupt(s); break;
                        case n.end:
                            null != s.listener && s.listener.end && s.listener.end(s); for (a = 0; a < e.length; a++) e[a].end && e[a].end(s);
                        case n.dispose:
                            null != s.listener && s.listener.dispose && s.listener.dispose(s); for (a = 0; a < e.length; a++) e[a].dispose && e[a].dispose(s);
                            this.animState.trackEntryPool.free(s); break;
                        case n.complete:
                            null != s.listener && s.listener.complete && s.listener.complete(s); for (a = 0; a < e.length; a++) e[a].complete && e[a].complete(s); break;
                        case n.event:
                            var r = t[2 + i++];
                            null != s.listener && s.listener.event && s.listener.event(s, r); for (var a = 0; a < e.length; a++) e[a].event && e[a].event(s, r) } } this.clear(), this.drainDisabled = !1 } }, t.prototype.clear = function() { this.objects.length = 0 }, t }();
    t.EventQueue = o; var n;! function(t) { t[t.start = 0] = "start", t[t.interrupt = 1] = "interrupt", t[t.end = 2] = "end", t[t.dispose = 3] = "dispose", t[t.complete = 4] = "complete", t[t.event = 5] = "event" }(n = t.EventType || (t.EventType = {})); var s = function() {
        function t() {} return t.prototype.start = function(t) {}, t.prototype.interrupt = function(t) {}, t.prototype.end = function(t) {}, t.prototype.dispose = function(t) {}, t.prototype.complete = function(t) {}, t.prototype.event = function(t, e) {}, t }();
    t.AnimationStateAdapter2 = s }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function t(t) { if (this.animationToMixTime = {}, this.defaultMix = 0, null == t) throw new Error("skeletonData cannot be null.");
            this.skeletonData = t } return t.prototype.setMix = function(t, e, i) { var o = this.skeletonData.findAnimation(t); if (null == o) throw new Error("Animation not found: " + t); var n = this.skeletonData.findAnimation(e); if (null == n) throw new Error("Animation not found: " + e);
            this.setMixWith(o, n, i) }, t.prototype.setMixWith = function(t, e, i) { if (null == t) throw new Error("from cannot be null."); if (null == e) throw new Error("to cannot be null."); var o = t.name + e.name;
            this.animationToMixTime[o] = i }, t.prototype.getMix = function(t, e) { var i = t.name + e.name,
                o = this.animationToMixTime[i]; return void 0 === o ? this.defaultMix : o }, t }();
    t.AnimationStateData = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function t(t, e) { void 0 === e && (e = ""), this.assets = {}, this.errors = {}, this.toLoad = 0, this.loaded = 0, this.textureLoader = t, this.pathPrefix = e } return t.prototype.loadText = function(t, e, i) { var o = this;
            void 0 === e && (e = null), void 0 === i && (i = null), t = this.pathPrefix + t, this.toLoad++; var n = new XMLHttpRequest;
            n.onreadystatechange = function() { n.readyState == XMLHttpRequest.DONE && (n.status >= 200 && n.status < 300 ? (o.assets[t] = n.responseText, e && e(t, n.responseText)) : (o.errors[t] = "Couldn't load text " + t + ": status " + n.status + ", " + n.responseText, i && i(t, "Couldn't load text " + t + ": status " + n.status + ", " + n.responseText)), o.toLoad--, o.loaded++) }, n.open("GET", t, !0), n.send() }, t.prototype.loadTexture = function(t, e, i) { var o = this;
            void 0 === e && (e = null), void 0 === i && (i = null), t = this.pathPrefix + t, this.toLoad++; var n = new Image;
            n.crossOrigin = "anonymous", n.onload = function(i) { var s = o.textureLoader(n);
                o.assets[t] = s, o.toLoad--, o.loaded++, e && e(t, n) }, n.onerror = function(e) { o.errors[t] = "Couldn't load image " + t, o.toLoad--, o.loaded++, i && i(t, "Couldn't load image " + t) }, n.src = t }, t.prototype.loadTextureData = function(t, e, i, o) { var n = this;
            void 0 === i && (i = null), void 0 === o && (o = null), t = this.pathPrefix + t, this.toLoad++; var s = new Image;
            s.onload = function(e) { var o = n.textureLoader(s);
                n.assets[t] = o, n.toLoad--, n.loaded++, i && i(t, s) }, s.onerror = function(e) { n.errors[t] = "Couldn't load image " + t, n.toLoad--, n.loaded++, o && o(t, "Couldn't load image " + t) }, s.src = e }, t.prototype.get = function(t) { return t = this.pathPrefix + t, this.assets[t] }, t.prototype.remove = function(t) { t = this.pathPrefix + t; var e = this.assets[t];
            e.dispose && e.dispose(), this.assets[t] = null }, t.prototype.removeAll = function() { for (var t in this.assets) { var e = this.assets[t];
                e.dispose && e.dispose() } this.assets = {} }, t.prototype.isLoadingComplete = function() { return 0 == this.toLoad }, t.prototype.getToLoad = function() { return this.toLoad }, t.prototype.getLoaded = function() { return this.loaded }, t.prototype.dispose = function() { this.removeAll() }, t.prototype.hasErrors = function() { return Object.keys(this.errors).length > 0 }, t.prototype.getErrors = function() { return this.errors }, t }();
    t.AssetManager = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e(t) { this.atlas = t } return e.prototype.newRegionAttachment = function(e, i, o) { var n = this.atlas.findRegion(o); if (null == n) throw new Error("Region not found in atlas: " + o + " (region attachment: " + i + ")");
            n.renderObject = n; var s = new t.RegionAttachment(i); return s.setRegion(n), s }, e.prototype.newMeshAttachment = function(e, i, o) { var n = this.atlas.findRegion(o); if (null == n) throw new Error("Region not found in atlas: " + o + " (mesh attachment: " + i + ")");
            n.renderObject = n; var s = new t.MeshAttachment(i); return s.region = n, s }, e.prototype.newBoundingBoxAttachment = function(e, i) { return new t.BoundingBoxAttachment(i) }, e.prototype.newPathAttachment = function(e, i) { return new t.PathAttachment(i) }, e.prototype.newPointAttachment = function(e, i) { return new t.PointAttachment(i) }, e.prototype.newClippingAttachment = function(e, i) { return new t.ClippingAttachment(i) }, e }();
    t.AtlasAttachmentLoader = e }(spine || (spine = {}));
var spine;
! function(t) {! function(t) { t[t.Normal = 0] = "Normal", t[t.Additive = 1] = "Additive", t[t.Multiply = 2] = "Multiply", t[t.Screen = 3] = "Screen" }(t.BlendMode || (t.BlendMode = {})) }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e(t, e, i) { if (this.children = new Array, this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 0, this.scaleY = 0, this.shearX = 0, this.shearY = 0, this.ax = 0, this.ay = 0, this.arotation = 0, this.ascaleX = 0, this.ascaleY = 0, this.ashearX = 0, this.ashearY = 0, this.appliedValid = !1, this.a = 0, this.b = 0, this.worldX = 0, this.c = 0, this.d = 0, this.worldY = 0, this.sorted = !1, null == t) throw new Error("data cannot be null."); if (null == e) throw new Error("skeleton cannot be null.");
            this.data = t, this.skeleton = e, this.parent = i, this.setToSetupPose() } return e.prototype.update = function() { this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY) }, e.prototype.updateWorldTransform = function() { this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY) }, e.prototype.updateWorldTransformWith = function(e, i, o, n, s, r, a) { this.ax = e, this.ay = i, this.arotation = o, this.ascaleX = n, this.ascaleY = s, this.ashearX = r, this.ashearY = a, this.appliedValid = !0; var h = this.parent; if (null == h) { var l = o + 90 + a,
                    c = t.MathUtils.cosDeg(o + r) * n,
                    d = t.MathUtils.cosDeg(l) * s,
                    u = t.MathUtils.sinDeg(o + r) * n,
                    p = t.MathUtils.sinDeg(l) * s,
                    m = this.skeleton; return m.flipX && (e = -e, c = -c, d = -d), m.flipY && (i = -i, u = -u, p = -p), this.a = c, this.b = d, this.c = u, this.d = p, this.worldX = e + m.x, void(this.worldY = i + m.y) } var f = h.a,
                y = h.b,
                b = h.c,
                g = h.d; switch (this.worldX = f * e + y * i + h.worldX, this.worldY = b * e + g * i + h.worldY, this.data.transformMode) {
                case t.TransformMode.Normal:
                    var l = o + 90 + a,
                        c = t.MathUtils.cosDeg(o + r) * n,
                        d = t.MathUtils.cosDeg(l) * s,
                        u = t.MathUtils.sinDeg(o + r) * n,
                        p = t.MathUtils.sinDeg(l) * s; return this.a = f * c + y * u, this.b = f * d + y * p, this.c = b * c + g * u, void(this.d = b * d + g * p);
                case t.TransformMode.OnlyTranslation:
                    l = o + 90 + a;
                    this.a = t.MathUtils.cosDeg(o + r) * n, this.b = t.MathUtils.cosDeg(l) * s, this.c = t.MathUtils.sinDeg(o + r) * n, this.d = t.MathUtils.sinDeg(l) * s; break;
                case t.TransformMode.NoRotationOrReflection:
                    var _ = 0;
                    (T = f * f + b * b) > 1e-4 ? (y = b * (T = Math.abs(f * g - y * b) / T), g = f * T, _ = Math.atan2(b, f) * t.MathUtils.radDeg) : (f = 0, b = 0, _ = 90 - Math.atan2(g, y) * t.MathUtils.radDeg); var v = o + r - _,
                        x = o + a - _ + 90,
                        c = t.MathUtils.cosDeg(v) * n,
                        d = t.MathUtils.cosDeg(x) * s,
                        u = t.MathUtils.sinDeg(v) * n,
                        p = t.MathUtils.sinDeg(x) * s;
                    this.a = f * c - y * u, this.b = f * d - y * p, this.c = b * c + g * u, this.d = b * d + g * p; break;
                case t.TransformMode.NoScale:
                case t.TransformMode.NoScaleOrReflection:
                    var S = t.MathUtils.cosDeg(o),
                        C = t.MathUtils.sinDeg(o),
                        w = f * S + y * C,
                        A = b * S + g * C,
                        T = Math.sqrt(w * w + A * A);
                    T > 1e-5 && (T = 1 / T), w *= T, A *= T, T = Math.sqrt(w * w + A * A); var P = Math.PI / 2 + Math.atan2(A, w),
                        k = Math.cos(P) * T,
                        M = Math.sin(P) * T,
                        c = t.MathUtils.cosDeg(r) * n,
                        d = t.MathUtils.cosDeg(90 + a) * s,
                        u = t.MathUtils.sinDeg(r) * n,
                        p = t.MathUtils.sinDeg(90 + a) * s; return (this.data.transformMode != t.TransformMode.NoScaleOrReflection ? f * g - y * b < 0 : this.skeleton.flipX != this.skeleton.flipY) && (k = -k, M = -M), this.a = w * c + k * u, this.b = w * d + k * p, this.c = A * c + M * u, void(this.d = A * d + M * p) } this.skeleton.flipX && (this.a = -this.a, this.b = -this.b), this.skeleton.flipY && (this.c = -this.c, this.d = -this.d) }, e.prototype.setToSetupPose = function() { var t = this.data;
            this.x = t.x, this.y = t.y, this.rotation = t.rotation, this.scaleX = t.scaleX, this.scaleY = t.scaleY, this.shearX = t.shearX, this.shearY = t.shearY }, e.prototype.getWorldRotationX = function() { return Math.atan2(this.c, this.a) * t.MathUtils.radDeg }, e.prototype.getWorldRotationY = function() { return Math.atan2(this.d, this.b) * t.MathUtils.radDeg }, e.prototype.getWorldScaleX = function() { return Math.sqrt(this.a * this.a + this.c * this.c) }, e.prototype.getWorldScaleY = function() { return Math.sqrt(this.b * this.b + this.d * this.d) }, e.prototype.updateAppliedTransform = function() { this.appliedValid = !0; var e = this.parent; if (null == e) return this.ax = this.worldX, this.ay = this.worldY, this.arotation = Math.atan2(this.c, this.a) * t.MathUtils.radDeg, this.ascaleX = Math.sqrt(this.a * this.a + this.c * this.c), this.ascaleY = Math.sqrt(this.b * this.b + this.d * this.d), this.ashearX = 0, void(this.ashearY = Math.atan2(this.a * this.b + this.c * this.d, this.a * this.d - this.b * this.c) * t.MathUtils.radDeg); var i = e.a,
                o = e.b,
                n = e.c,
                s = e.d,
                r = 1 / (i * s - o * n),
                a = this.worldX - e.worldX,
                h = this.worldY - e.worldY;
            this.ax = a * s * r - h * o * r, this.ay = h * i * r - a * n * r; var l = r * s,
                c = r * i,
                d = r * o,
                u = r * n,
                p = l * this.a - d * this.c,
                m = l * this.b - d * this.d,
                f = c * this.c - u * this.a,
                y = c * this.d - u * this.b; if (this.ashearX = 0, this.ascaleX = Math.sqrt(p * p + f * f), this.ascaleX > 1e-4) { var b = p * y - m * f;
                this.ascaleY = b / this.ascaleX, this.ashearY = Math.atan2(p * m + f * y, b) * t.MathUtils.radDeg, this.arotation = Math.atan2(f, p) * t.MathUtils.radDeg } else this.ascaleX = 0, this.ascaleY = Math.sqrt(m * m + y * y), this.ashearY = 0, this.arotation = 90 - Math.atan2(y, m) * t.MathUtils.radDeg }, e.prototype.worldToLocal = function(t) { var e = this.a,
                i = this.b,
                o = this.c,
                n = this.d,
                s = 1 / (e * n - i * o),
                r = t.x - this.worldX,
                a = t.y - this.worldY; return t.x = r * n * s - a * i * s, t.y = a * e * s - r * o * s, t }, e.prototype.localToWorld = function(t) { var e = t.x,
                i = t.y; return t.x = e * this.a + i * this.b + this.worldX, t.y = e * this.c + i * this.d + this.worldY, t }, e.prototype.worldToLocalRotation = function(e) { var i = t.MathUtils.sinDeg(e),
                o = t.MathUtils.cosDeg(e); return Math.atan2(this.a * i - this.c * o, this.d * o - this.b * i) * t.MathUtils.radDeg }, e.prototype.localToWorldRotation = function(e) { var i = t.MathUtils.sinDeg(e),
                o = t.MathUtils.cosDeg(e); return Math.atan2(o * this.c + i * this.d, o * this.a + i * this.b) * t.MathUtils.radDeg }, e.prototype.rotateWorld = function(e) { var i = this.a,
                o = this.b,
                n = this.c,
                s = this.d,
                r = t.MathUtils.cosDeg(e),
                a = t.MathUtils.sinDeg(e);
            this.a = r * i - a * n, this.b = r * o - a * s, this.c = a * i + r * n, this.d = a * o + r * s, this.appliedValid = !1 }, e }();
    t.Bone = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() { return function(t, e, o) { if (this.x = 0, this.y = 0, this.rotation = 0, this.scaleX = 1, this.scaleY = 1, this.shearX = 0, this.shearY = 0, this.transformMode = i.Normal, t < 0) throw new Error("index must be >= 0."); if (null == e) throw new Error("name cannot be null.");
            this.index = t, this.name = e, this.parent = o } }();
    t.BoneData = e; var i;! function(t) { t[t.Normal = 0] = "Normal", t[t.OnlyTranslation = 1] = "OnlyTranslation", t[t.NoRotationOrReflection = 2] = "NoRotationOrReflection", t[t.NoScale = 3] = "NoScale", t[t.NoScaleOrReflection = 4] = "NoScaleOrReflection" }(i = t.TransformMode || (t.TransformMode = {})) }(spine || (spine = {}));
var spine;
! function(t) { var e = function() { return function(t, e) { if (null == e) throw new Error("data cannot be null.");
            this.time = t, this.data = e } }();
    t.Event = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() { return function(t) { this.name = t } }();
    t.EventData = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e(t, e) { if (this.mix = 1, this.bendDirection = 0, null == t) throw new Error("data cannot be null."); if (null == e) throw new Error("skeleton cannot be null.");
            this.data = t, this.mix = t.mix, this.bendDirection = t.bendDirection, this.bones = new Array; for (var i = 0; i < t.bones.length; i++) this.bones.push(e.findBone(t.bones[i].name));
            this.target = e.findBone(t.target.name) } return e.prototype.getOrder = function() { return this.data.order }, e.prototype.apply = function() { this.update() }, e.prototype.update = function() { var t = this.target,
                e = this.bones; switch (e.length) {
                case 1:
                    this.apply1(e[0], t.worldX, t.worldY, this.mix); break;
                case 2:
                    this.apply2(e[0], e[1], t.worldX, t.worldY, this.bendDirection, this.mix) } }, e.prototype.apply1 = function(e, i, o, n) { e.appliedValid || e.updateAppliedTransform(); var s = e.parent,
                r = 1 / (s.a * s.d - s.b * s.c),
                a = i - s.worldX,
                h = o - s.worldY,
                l = (a * s.d - h * s.b) * r - e.ax,
                c = (h * s.a - a * s.c) * r - e.ay,
                d = Math.atan2(c, l) * t.MathUtils.radDeg - e.ashearX - e.arotation;
            e.ascaleX < 0 && (d += 180), d > 180 ? d -= 360 : d < -180 && (d += 360), e.updateWorldTransformWith(e.ax, e.ay, e.arotation + d * n, e.ascaleX, e.ascaleY, e.ashearX, e.ashearY) }, e.prototype.apply2 = function(e, i, o, n, s, r) { if (0 != r) { e.appliedValid || e.updateAppliedTransform(), i.appliedValid || i.updateAppliedTransform(); var a = e.ax,
                    h = e.ay,
                    l = e.ascaleX,
                    c = e.ascaleY,
                    d = i.ascaleX,
                    u = 0,
                    p = 0,
                    m = 0;
                l < 0 ? (l = -l, u = 180, m = -1) : (u = 0, m = 1), c < 0 && (c = -c, m = -m), d < 0 ? (d = -d, p = 180) : p = 0; var f = i.ax,
                    y = 0,
                    b = 0,
                    g = 0,
                    _ = e.a,
                    v = e.b,
                    x = e.c,
                    S = e.d,
                    C = Math.abs(l - c) <= 1e-4;
                C ? (b = _ * f + v * (y = i.ay) + e.worldX, g = x * f + S * y + e.worldY) : (y = 0, b = _ * f + e.worldX, g = x * f + e.worldY); var w = e.parent;
                _ = w.a, v = w.b, x = w.c; var A = 1 / (_ * (S = w.d) - v * x),
                    T = o - w.worldX,
                    P = n - w.worldY,
                    k = (T * S - P * v) * A - a,
                    M = (P * _ - T * x) * A - h,
                    E = ((T = b - w.worldX) * S - (P = g - w.worldY) * v) * A - a,
                    B = (P * _ - T * x) * A - h,
                    I = Math.sqrt(E * E + B * B),
                    D = i.data.length * d,
                    L = 0,
                    O = 0;
                t: if (C) { var R = (k * k + M * M - I * I - (D *= l) * D) / (2 * I * D);
                    R < -1 ? R = -1 : R > 1 && (R = 1), O = Math.acos(R) * s, _ = I + D * R, v = D * Math.sin(O), L = Math.atan2(M * _ - k * v, k * _ + M * v) } else { var F = (_ = l * D) * _,
                        V = (v = c * D) * v,
                        G = k * k + M * M,
                        U = Math.atan2(M, k),
                        N = -2 * V * I,
                        j = V - F; if ((S = N * N - 4 * j * (x = V * I * I + F * G - F * V)) >= 0) { var W = Math.sqrt(S);
                        N < 0 && (W = -W); var X = (W = -(N + W) / 2) / j,
                            H = x / W,
                            z = Math.abs(X) < Math.abs(H) ? X : H; if (z * z <= G) { P = Math.sqrt(G - z * z) * s, L = U - Math.atan2(P, z), O = Math.atan2(P / c, (z - I) / l); break t } } var J = t.MathUtils.PI,
                        q = I - _,
                        Y = q * q,
                        K = 0,
                        Z = 0,
                        Q = I + _,
                        $ = Q * Q,
                        tt = 0;
                    (x = -_ * I / (F - V)) >= -1 && x <= 1 && (x = Math.acos(x), (S = (T = _ * Math.cos(x) + I) * T + (P = v * Math.sin(x)) * P) < Y && (J = x, Y = S, q = T, K = P), S > $ && (Z = x, $ = S, Q = T, tt = P)), G <= (Y + $) / 2 ? (L = U - Math.atan2(K * s, q), O = J * s) : (L = U - Math.atan2(tt * s, Q), O = Z * s) } var et = Math.atan2(y, f) * m,
                    it = e.arotation;
                (L = (L - et) * t.MathUtils.radDeg + u - it) > 180 ? L -= 360 : L < -180 && (L += 360), e.updateWorldTransformWith(a, h, it + L * r, e.ascaleX, e.ascaleY, 0, 0), it = i.arotation, (O = ((O + et) * t.MathUtils.radDeg - i.ashearX) * m + p - it) > 180 ? O -= 360 : O < -180 && (O += 360), i.updateWorldTransformWith(f, y, it + O * r, i.ascaleX, i.ascaleY, i.ashearX, i.ashearY) } else i.updateWorldTransform() }, e }();
    t.IkConstraint = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() { return function(t) { this.order = 0, this.bones = new Array, this.bendDirection = 1, this.mix = 1, this.name = t } }();
    t.IkConstraintData = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e(t, e) { if (this.position = 0, this.spacing = 0, this.rotateMix = 0, this.translateMix = 0, this.spaces = new Array, this.positions = new Array, this.world = new Array, this.curves = new Array, this.lengths = new Array, this.segments = new Array, null == t) throw new Error("data cannot be null."); if (null == e) throw new Error("skeleton cannot be null.");
            this.data = t, this.bones = new Array; for (var i = 0, o = t.bones.length; i < o; i++) this.bones.push(e.findBone(t.bones[i].name));
            this.target = e.findSlot(t.target.name), this.position = t.position, this.spacing = t.spacing, this.rotateMix = t.rotateMix, this.translateMix = t.translateMix } return e.prototype.apply = function() { this.update() }, e.prototype.update = function() { var e = this.target.getAttachment(); if (e instanceof t.PathAttachment) { var i = this.rotateMix,
                    o = this.translateMix,
                    n = i > 0; if (o > 0 || n) { var s = this.data,
                        r = s.spacingMode,
                        a = r == t.SpacingMode.Length,
                        h = s.rotateMode,
                        l = h == t.RotateMode.Tangent,
                        c = h == t.RotateMode.ChainScale,
                        d = this.bones.length,
                        u = l ? d : d + 1,
                        p = this.bones,
                        m = t.Utils.setArraySize(this.spaces, u),
                        f = null,
                        y = this.spacing; if (c || a) { c && (f = t.Utils.setArraySize(this.lengths, d)); for (var b = 0, g = u - 1; b < g;) { var _ = (M = p[b]).data.length;
                            0 == _ && (_ = 1e-7); var v = _ * M.a,
                                x = _ * M.c,
                                S = Math.sqrt(v * v + x * x);
                            c && (f[b] = S), m[++b] = (a ? _ + y : y) * S / _ } } else
                        for (b = 1; b < u; b++) m[b] = y; var C = this.computeWorldPositions(e, u, l, s.positionMode == t.PositionMode.Percent, r == t.SpacingMode.Percent),
                        w = C[0],
                        A = C[1],
                        T = s.offsetRotation,
                        P = !1;
                    0 == T ? P = h == t.RotateMode.Chain : (P = !1, T *= (k = this.target.bone).a * k.d - k.b * k.c > 0 ? t.MathUtils.degRad : -t.MathUtils.degRad); for (var b = 0, k = 3; b < d; b++, k += 3) { var M = p[b];
                        M.worldX += (w - M.worldX) * o, M.worldY += (A - M.worldY) * o; var E = (v = C[k]) - w,
                            B = (x = C[k + 1]) - A; if (c) { var I = f[b]; if (0 != I) { var D = (Math.sqrt(E * E + B * B) / I - 1) * i + 1;
                                M.a *= D, M.c *= D } } if (w = v, A = x, n) { var L = M.a,
                                O = M.b,
                                R = M.c,
                                F = M.d,
                                V = 0,
                                G = 0,
                                U = 0; if (V = l ? C[k - 1] : 0 == m[b + 1] ? C[k + 2] : Math.atan2(B, E), V -= Math.atan2(R, L), P) { G = Math.cos(V), U = Math.sin(V); var N = M.data.length;
                                w += (N * (G * L - U * R) - E) * i, A += (N * (U * L + G * R) - B) * i } else V += T;
                            V > t.MathUtils.PI ? V -= t.MathUtils.PI2 : V < -t.MathUtils.PI && (V += t.MathUtils.PI2), V *= i, G = Math.cos(V), U = Math.sin(V), M.a = G * L - U * R, M.b = G * O - U * F, M.c = U * L + G * R, M.d = U * O + G * F } M.appliedValid = !1 } } } }, e.prototype.computeWorldPositions = function(i, o, n, s, r) { var a = this.target,
                h = this.position,
                l = this.spaces,
                c = t.Utils.setArraySize(this.positions, 3 * o + 2),
                d = null,
                u = i.closed,
                p = i.worldVerticesLength,
                m = p / 6,
                f = e.NONE; if (!i.constantSpeed) { var y = i.lengths,
                    b = y[m -= u ? 1 : 2]; if (s && (h *= b), r)
                    for (g = 0; g < o; g++) l[g] *= b;
                d = t.Utils.setArraySize(this.world, 8); for (var g = 0, _ = 0, v = 0; g < o; g++, _ += 3) { H = h += X = l[g]; if (u)(H %= b) < 0 && (H += b), v = 0;
                    else { if (H < 0) { f != e.BEFORE && (f = e.BEFORE, i.computeWorldVertices(a, 2, 4, d, 0, 2)), this.addBeforePosition(H, d, 0, c, _); continue } if (H > b) { f != e.AFTER && (f = e.AFTER, i.computeWorldVertices(a, p - 6, 4, d, 0, 2)), this.addAfterPosition(H - b, d, 0, c, _); continue } } for (;; v++) { var x = y[v]; if (!(H > x)) { 0 == v ? H /= x : H = (H - (Y = y[v - 1])) / (x - Y); break } } v != f && (f = v, u && v == m ? (i.computeWorldVertices(a, p - 4, 4, d, 0, 2), i.computeWorldVertices(a, 0, 4, d, 4, 2)) : i.computeWorldVertices(a, 6 * v + 2, 8, d, 0, 2)), this.addCurvePosition(H, d[0], d[1], d[2], d[3], d[4], d[5], d[6], d[7], c, _, n || g > 0 && 0 == X) } return c } u ? (p += 2, d = t.Utils.setArraySize(this.world, p), i.computeWorldVertices(a, 2, p - 4, d, 0, 2), i.computeWorldVertices(a, 0, 2, d, p - 4, 2), d[p - 2] = d[0], d[p - 1] = d[1]) : (m--, p -= 4, d = t.Utils.setArraySize(this.world, p), i.computeWorldVertices(a, 2, p, d, 0, 2)); for (var S = t.Utils.setArraySize(this.curves, m), C = 0, w = d[0], A = d[1], T = 0, P = 0, k = 0, M = 0, E = 0, B = 0, I = 0, D = 0, L = 0, O = 0, R = 0, F = 0, V = 0, G = 0, g = 0, U = 2; g < m; g++, U += 6) T = d[U], P = d[U + 1], k = d[U + 2], M = d[U + 3], R = 2 * (I = .1875 * (w - 2 * T + k)) + (L = .09375 * (3 * (T - k) - w + (E = d[U + 4]))), F = 2 * (D = .1875 * (A - 2 * P + M)) + (O = .09375 * (3 * (P - M) - A + (B = d[U + 5]))), V = .75 * (T - w) + I + .16666667 * L, G = .75 * (P - A) + D + .16666667 * O, C += Math.sqrt(V * V + G * G), V += R, G += F, R += L, F += O, C += Math.sqrt(V * V + G * G), V += R, G += F, C += Math.sqrt(V * V + G * G), V += R + L, G += F + O, C += Math.sqrt(V * V + G * G), S[g] = C, w = E, A = B; if (s && (h *= C), r)
                for (g = 0; g < o; g++) l[g] *= C; for (var N = this.segments, j = 0, g = 0, _ = 0, v = 0, W = 0; g < o; g++, _ += 3) { var X = l[g],
                    H = h += X; if (u)(H %= C) < 0 && (H += C), v = 0;
                else { if (H < 0) { this.addBeforePosition(H, d, 0, c, _); continue } if (H > C) { this.addAfterPosition(H - C, d, p - 4, c, _); continue } } for (;; v++) { var z = S[v]; if (!(H > z)) { 0 == v ? H /= z : H = (H - (Y = S[v - 1])) / (z - Y); break } } if (v != f) { f = v; var J = 6 * v; for (w = d[J], A = d[J + 1], T = d[J + 2], P = d[J + 3], k = d[J + 4], M = d[J + 5], R = 2 * (I = .03 * (w - 2 * T + k)) + (L = .006 * (3 * (T - k) - w + (E = d[J + 6]))), F = 2 * (D = .03 * (A - 2 * P + M)) + (O = .006 * (3 * (P - M) - A + (B = d[J + 7]))), V = .3 * (T - w) + I + .16666667 * L, G = .3 * (P - A) + D + .16666667 * O, j = Math.sqrt(V * V + G * G), N[0] = j, J = 1; J < 8; J++) V += R, G += F, R += L, F += O, j += Math.sqrt(V * V + G * G), N[J] = j;
                    V += R, G += F, j += Math.sqrt(V * V + G * G), N[8] = j, V += R + L, G += F + O, j += Math.sqrt(V * V + G * G), N[9] = j, W = 0 } for (H *= j;; W++) { var q = N[W]; if (!(H > q)) { if (0 == W) H /= q;
                        else { var Y = N[W - 1];
                            H = W + (H - Y) / (q - Y) } break } } this.addCurvePosition(.1 * H, w, A, T, P, k, M, E, B, c, _, n || g > 0 && 0 == X) } return c }, e.prototype.addBeforePosition = function(t, e, i, o, n) { var s = e[i],
                r = e[i + 1],
                a = e[i + 2] - s,
                h = e[i + 3] - r,
                l = Math.atan2(h, a);
            o[n] = s + t * Math.cos(l), o[n + 1] = r + t * Math.sin(l), o[n + 2] = l }, e.prototype.addAfterPosition = function(t, e, i, o, n) { var s = e[i + 2],
                r = e[i + 3],
                a = s - e[i],
                h = r - e[i + 1],
                l = Math.atan2(h, a);
            o[n] = s + t * Math.cos(l), o[n + 1] = r + t * Math.sin(l), o[n + 2] = l }, e.prototype.addCurvePosition = function(t, e, i, o, n, s, r, a, h, l, c, d) {
            (0 == t || isNaN(t)) && (t = 1e-4); var u = t * t,
                p = u * t,
                m = 1 - t,
                f = m * m,
                y = f * m,
                b = m * t,
                g = 3 * b,
                _ = m * g,
                v = g * t,
                x = e * y + o * _ + s * v + a * p,
                S = i * y + n * _ + r * v + h * p;
            l[c] = x, l[c + 1] = S, d && (l[c + 2] = Math.atan2(S - (i * f + n * b * 2 + r * u), x - (e * f + o * b * 2 + s * u))) }, e.prototype.getOrder = function() { return this.data.order }, e }();
    e.NONE = -1, e.BEFORE = -2, e.AFTER = -3, t.PathConstraint = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() { return function(t) { this.order = 0, this.bones = new Array, this.name = t } }();
    t.PathConstraintData = e;! function(t) { t[t.Fixed = 0] = "Fixed", t[t.Percent = 1] = "Percent" }(t.PositionMode || (t.PositionMode = {}));! function(t) { t[t.Length = 0] = "Length", t[t.Fixed = 1] = "Fixed", t[t.Percent = 2] = "Percent" }(t.SpacingMode || (t.SpacingMode = {}));! function(t) { t[t.Tangent = 0] = "Tangent", t[t.Chain = 1] = "Chain", t[t.ChainScale = 2] = "ChainScale" }(t.RotateMode || (t.RotateMode = {})) }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
            function t(t) { this.toLoad = new Array, this.assets = {}, this.clientId = t } return t.prototype.loaded = function() { var t = 0; for (var e in this.assets) t++; return t }, t }(),
        i = function() {
            function t(t) { void 0 === t && (t = ""), this.clientAssets = {}, this.queuedAssets = {}, this.rawAssets = {}, this.errors = {}, this.pathPrefix = t } return t.prototype.queueAsset = function(t, i, o) { var n = this.clientAssets[t]; return null !== n && void 0 !== n || (n = new e(t), this.clientAssets[t] = n), null !== i && (n.textureLoader = i), n.toLoad.push(o), this.queuedAssets[o] !== o && (this.queuedAssets[o] = o, !0) }, t.prototype.loadText = function(t, e) { var i = this; if (e = this.pathPrefix + e, this.queueAsset(t, null, e)) { var o = new XMLHttpRequest;
                    o.onreadystatechange = function() { o.readyState == XMLHttpRequest.DONE && (o.status >= 200 && o.status < 300 ? i.rawAssets[e] = o.responseText : i.errors[e] = "Couldn't load text " + e + ": status " + o.status + ", " + o.responseText) }, o.open("GET", e, !0), o.send() } }, t.prototype.loadJson = function(t, e) { var i = this; if (e = this.pathPrefix + e, this.queueAsset(t, null, e)) { var o = new XMLHttpRequest;
                    o.onreadystatechange = function() { o.readyState == XMLHttpRequest.DONE && (o.status >= 200 && o.status < 300 ? i.rawAssets[e] = JSON.parse(o.responseText) : i.errors[e] = "Couldn't load text " + e + ": status " + o.status + ", " + o.responseText) }, o.open("GET", e, !0), o.send() } }, t.prototype.loadTexture = function(t, e, i) { var o = this; if (i = this.pathPrefix + i, this.queueAsset(t, e, i)) { var n = new Image;
                    n.src = i, n.crossOrigin = "anonymous", n.onload = function(t) { o.rawAssets[i] = n }, n.onerror = function(t) { o.errors[i] = "Couldn't load image " + i } } }, t.prototype.get = function(t, e) { e = this.pathPrefix + e; var i = this.clientAssets[t]; return null === i || void 0 === i || i.assets[e] }, t.prototype.updateClientAssets = function(t) { for (var e = 0; e < t.toLoad.length; e++) { var i = t.toLoad[e],
                        o = t.assets[i]; if (null === o || void 0 === o) { var n = this.rawAssets[i]; if (null === n || void 0 === n) continue;
                        n instanceof HTMLImageElement ? t.assets[i] = t.textureLoader(n) : t.assets[i] = n } } }, t.prototype.isLoadingComplete = function(t) { var e = this.clientAssets[t]; return null === e || void 0 === e || (this.updateClientAssets(e), e.toLoad.length == e.loaded()) }, t.prototype.dispose = function() {}, t.prototype.hasErrors = function() { return Object.keys(this.errors).length > 0 }, t.prototype.getErrors = function() { return this.errors }, t }();
    t.SharedAssetManager = i }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e(e) { if (this._updateCache = new Array, this.updateCacheReset = new Array, this.time = 0, this.flipX = !1, this.flipY = !1, this.x = 0, this.y = 0, null == e) throw new Error("data cannot be null.");
            this.data = e, this.bones = new Array; for (l = 0; l < e.bones.length; l++) { var i = e.bones[l],
                    o = void 0; if (null == i.parent) o = new t.Bone(i, this, null);
                else { var n = this.bones[i.parent.index];
                    o = new t.Bone(i, this, n), n.children.push(o) } this.bones.push(o) } this.slots = new Array, this.drawOrder = new Array; for (l = 0; l < e.slots.length; l++) { var s = e.slots[l],
                    o = this.bones[s.boneData.index],
                    r = new t.Slot(s, o);
                this.slots.push(r), this.drawOrder.push(r) } this.ikConstraints = new Array; for (l = 0; l < e.ikConstraints.length; l++) { var a = e.ikConstraints[l];
                this.ikConstraints.push(new t.IkConstraint(a, this)) } this.transformConstraints = new Array; for (l = 0; l < e.transformConstraints.length; l++) { var h = e.transformConstraints[l];
                this.transformConstraints.push(new t.TransformConstraint(h, this)) } this.pathConstraints = new Array; for (var l = 0; l < e.pathConstraints.length; l++) { var c = e.pathConstraints[l];
                this.pathConstraints.push(new t.PathConstraint(c, this)) } this.color = new t.Color(1, 1, 1, 1), this.updateCache() } return e.prototype.updateCache = function() { this._updateCache.length = 0, this.updateCacheReset.length = 0; for (var t = this.bones, e = 0, i = t.length; e < i; e++) t[e].sorted = !1; var o = this.ikConstraints,
                n = this.transformConstraints,
                s = this.pathConstraints,
                r = o.length,
                a = n.length,
                h = s.length,
                l = r + a + h;
            t: for (e = 0; e < l; e++) { for (c = 0; c < r; c++)
                    if ((d = o[c]).data.order == e) { this.sortIkConstraint(d); continue t } for (c = 0; c < a; c++)
                    if ((d = n[c]).data.order == e) { this.sortTransformConstraint(d); continue t } for (var c = 0; c < h; c++) { var d = s[c]; if (d.data.order == e) { this.sortPathConstraint(d); continue t } } }
            for (var e = 0, i = t.length; e < i; e++) this.sortBone(t[e]) }, e.prototype.sortIkConstraint = function(t) { var e = t.target;
            this.sortBone(e); var i = t.bones,
                o = i[0]; if (this.sortBone(o), i.length > 1) { var n = i[i.length - 1];
                this._updateCache.indexOf(n) > -1 || this.updateCacheReset.push(n) } this._updateCache.push(t), this.sortReset(o.children), i[i.length - 1].sorted = !0 }, e.prototype.sortPathConstraint = function(e) { var i = e.target,
                o = i.data.index,
                n = i.bone;
            null != this.skin && this.sortPathConstraintAttachment(this.skin, o, n), null != this.data.defaultSkin && this.data.defaultSkin != this.skin && this.sortPathConstraintAttachment(this.data.defaultSkin, o, n); for (var s = 0, r = this.data.skins.length; s < r; s++) this.sortPathConstraintAttachment(this.data.skins[s], o, n); var a = i.getAttachment();
            a instanceof t.PathAttachment && this.sortPathConstraintAttachmentWith(a, n); for (var h = e.bones, l = h.length, s = 0; s < l; s++) this.sortBone(h[s]);
            this._updateCache.push(e); for (s = 0; s < l; s++) this.sortReset(h[s].children); for (s = 0; s < l; s++) h[s].sorted = !0 }, e.prototype.sortTransformConstraint = function(t) { this.sortBone(t.target); var e = t.bones,
                i = e.length; if (t.data.local)
                for (n = 0; n < i; n++) { var o = e[n];
                    this.sortBone(o.parent), this._updateCache.indexOf(o) > -1 || this.updateCacheReset.push(o) } else
                    for (var n = 0; n < i; n++) this.sortBone(e[n]);
            this._updateCache.push(t); for (s = 0; s < i; s++) this.sortReset(e[s].children); for (var s = 0; s < i; s++) e[s].sorted = !0 }, e.prototype.sortPathConstraintAttachment = function(t, e, i) { var o = t.attachments[e]; if (o)
                for (var n in o) this.sortPathConstraintAttachmentWith(o[n], i) }, e.prototype.sortPathConstraintAttachmentWith = function(e, i) { if (e instanceof t.PathAttachment) { var o = e.bones; if (null == o) this.sortBone(i);
                else
                    for (var n = this.bones, s = 0; s < o.length;)
                        for (var r = o[s++], a = s + r; s < a; s++) { var h = o[s];
                            this.sortBone(n[h]) } } }, e.prototype.sortBone = function(t) { if (!t.sorted) { var e = t.parent;
                null != e && this.sortBone(e), t.sorted = !0, this._updateCache.push(t) } }, e.prototype.sortReset = function(t) { for (var e = 0, i = t.length; e < i; e++) { var o = t[e];
                o.sorted && this.sortReset(o.children), o.sorted = !1 } }, e.prototype.updateWorldTransform = function() { for (var t = this.updateCacheReset, e = 0, i = t.length; e < i; e++) { var o = t[e];
                o.ax = o.x, o.ay = o.y, o.arotation = o.rotation, o.ascaleX = o.scaleX, o.ascaleY = o.scaleY, o.ashearX = o.shearX, o.ashearY = o.shearY, o.appliedValid = !0 } for (var n = this._updateCache, e = 0, i = n.length; e < i; e++) n[e].update() }, e.prototype.setToSetupPose = function() { this.setBonesToSetupPose(), this.setSlotsToSetupPose() }, e.prototype.setBonesToSetupPose = function() { for (var t = this.bones, e = 0, i = t.length; e < i; e++) t[e].setToSetupPose(); for (var o = this.ikConstraints, e = 0, i = o.length; e < i; e++)(r = o[e]).bendDirection = r.data.bendDirection, r.mix = r.data.mix; for (var n = this.transformConstraints, e = 0, i = n.length; e < i; e++) { a = (r = n[e]).data;
                r.rotateMix = a.rotateMix, r.translateMix = a.translateMix, r.scaleMix = a.scaleMix, r.shearMix = a.shearMix } for (var s = this.pathConstraints, e = 0, i = s.length; e < i; e++) { var r = s[e],
                    a = r.data;
                r.position = a.position, r.spacing = a.spacing, r.rotateMix = a.rotateMix, r.translateMix = a.translateMix } }, e.prototype.setSlotsToSetupPose = function() { var e = this.slots;
            t.Utils.arrayCopy(e, 0, this.drawOrder, 0, e.length); for (var i = 0, o = e.length; i < o; i++) e[i].setToSetupPose() }, e.prototype.getRootBone = function() { return 0 == this.bones.length ? null : this.bones[0] }, e.prototype.findBone = function(t) { if (null == t) throw new Error("boneName cannot be null."); for (var e = this.bones, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (n.data.name == t) return n } return null }, e.prototype.findBoneIndex = function(t) { if (null == t) throw new Error("boneName cannot be null."); for (var e = this.bones, i = 0, o = e.length; i < o; i++)
                if (e[i].data.name == t) return i; return -1 }, e.prototype.findSlot = function(t) { if (null == t) throw new Error("slotName cannot be null."); for (var e = this.slots, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (n.data.name == t) return n } return null }, e.prototype.findSlotIndex = function(t) { if (null == t) throw new Error("slotName cannot be null."); for (var e = this.slots, i = 0, o = e.length; i < o; i++)
                if (e[i].data.name == t) return i; return -1 }, e.prototype.setSkinByName = function(t) { var e = this.data.findSkin(t); if (null == e) throw new Error("Skin not found: " + t);
            this.setSkin(e) }, e.prototype.setSkin = function(t) { if (null != t)
                if (null != this.skin) t.attachAll(this, this.skin);
                else
                    for (var e = this.slots, i = 0, o = e.length; i < o; i++) { var n = e[i],
                            s = n.data.attachmentName; if (null != s) { var r = t.getAttachment(i, s);
                            null != r && n.setAttachment(r) } } this.skin = t }, e.prototype.getAttachmentByName = function(t, e) { return this.getAttachment(this.data.findSlotIndex(t), e) }, e.prototype.getAttachment = function(t, e) { if (null == e) throw new Error("attachmentName cannot be null."); if (null != this.skin) { var i = this.skin.getAttachment(t, e); if (null != i) return i } return null != this.data.defaultSkin ? this.data.defaultSkin.getAttachment(t, e) : null }, e.prototype.setAttachment = function(t, e) { if (null == t) throw new Error("slotName cannot be null."); for (var i = this.slots, o = 0, n = i.length; o < n; o++) { var s = i[o]; if (s.data.name == t) { var r = null; if (null != e && null == (r = this.getAttachment(o, e))) throw new Error("Attachment not found: " + e + ", for slot: " + t); return void s.setAttachment(r) } } throw new Error("Slot not found: " + t) }, e.prototype.findIkConstraint = function(t) { if (null == t) throw new Error("constraintName cannot be null."); for (var e = this.ikConstraints, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (n.data.name == t) return n } return null }, e.prototype.findTransformConstraint = function(t) { if (null == t) throw new Error("constraintName cannot be null."); for (var e = this.transformConstraints, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (n.data.name == t) return n } return null }, e.prototype.findPathConstraint = function(t) { if (null == t) throw new Error("constraintName cannot be null."); for (var e = this.pathConstraints, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (n.data.name == t) return n } return null }, e.prototype.getBounds = function(e, i, o) { if (null == e) throw new Error("offset cannot be null."); if (null == i) throw new Error("size cannot be null."); for (var n = this.drawOrder, s = Number.POSITIVE_INFINITY, r = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY, h = Number.NEGATIVE_INFINITY, l = 0, c = n.length; l < c; l++) { var d = n[l],
                    u = 0,
                    p = null,
                    m = d.getAttachment(); if (m instanceof t.RegionAttachment) u = 8, p = t.Utils.setArraySize(o, u, 0), m.computeWorldVertices(d.bone, p, 0, 2);
                else if (m instanceof t.MeshAttachment) { var f = m;
                    u = f.worldVerticesLength, p = t.Utils.setArraySize(o, u, 0), f.computeWorldVertices(d, 0, u, p, 0, 2) } if (null != p)
                    for (var y = 0, b = p.length; y < b; y += 2) { var g = p[y],
                            _ = p[y + 1];
                        s = Math.min(s, g), r = Math.min(r, _), a = Math.max(a, g), h = Math.max(h, _) } } e.set(s, r), i.set(a - s, h - r) }, e.prototype.update = function(t) { this.time += t }, e }();
    t.Skeleton = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e() { this.minX = 0, this.minY = 0, this.maxX = 0, this.maxY = 0, this.boundingBoxes = new Array, this.polygons = new Array, this.polygonPool = new t.Pool(function() { return t.Utils.newFloatArray(16) }) } return e.prototype.update = function(e, i) { if (null == e) throw new Error("skeleton cannot be null."); var o = this.boundingBoxes,
                n = this.polygons,
                s = this.polygonPool,
                r = e.slots,
                a = r.length;
            o.length = 0, s.freeAll(n), n.length = 0; for (var h = 0; h < a; h++) { var l = r[h],
                    c = l.getAttachment(); if (c instanceof t.BoundingBoxAttachment) { var d = c;
                    o.push(d); var u = s.obtain();
                    u.length != d.worldVerticesLength && (u = t.Utils.newFloatArray(d.worldVerticesLength)), n.push(u), d.computeWorldVertices(l, 0, d.worldVerticesLength, u, 0, 2) } } i ? this.aabbCompute() : (this.minX = Number.POSITIVE_INFINITY, this.minY = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.maxY = Number.NEGATIVE_INFINITY) }, e.prototype.aabbCompute = function() { for (var t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY, o = Number.NEGATIVE_INFINITY, n = this.polygons, s = 0, r = n.length; s < r; s++)
                for (var a = n[s], h = a, l = 0, c = a.length; l < c; l += 2) { var d = h[l],
                        u = h[l + 1];
                    t = Math.min(t, d), e = Math.min(e, u), i = Math.max(i, d), o = Math.max(o, u) } this.minX = t, this.minY = e, this.maxX = i, this.maxY = o }, e.prototype.aabbContainsPoint = function(t, e) { return t >= this.minX && t <= this.maxX && e >= this.minY && e <= this.maxY }, e.prototype.aabbIntersectsSegment = function(t, e, i, o) { var n = this.minX,
                s = this.minY,
                r = this.maxX,
                a = this.maxY; if (t <= n && i <= n || e <= s && o <= s || t >= r && i >= r || e >= a && o >= a) return !1; var h = (o - e) / (i - t),
                l = h * (n - t) + e; if (l > s && l < a) return !0; if ((l = h * (r - t) + e) > s && l < a) return !0; var c = (s - e) / h + t; return c > n && c < r || (c = (a - e) / h + t) > n && c < r }, e.prototype.aabbIntersectsSkeleton = function(t) { return this.minX < t.maxX && this.maxX > t.minX && this.minY < t.maxY && this.maxY > t.minY }, e.prototype.containsPoint = function(t, e) { for (var i = this.polygons, o = 0, n = i.length; o < n; o++)
                if (this.containsPointPolygon(i[o], t, e)) return this.boundingBoxes[o]; return null }, e.prototype.containsPointPolygon = function(t, e, i) { for (var o = t, n = t.length, s = n - 2, r = !1, a = 0; a < n; a += 2) { var h = o[a + 1],
                    l = o[s + 1]; if (h < i && l >= i || l < i && h >= i) { var c = o[a];
                    c + (i - h) / (l - h) * (o[s] - c) < e && (r = !r) } s = a } return r }, e.prototype.intersectsSegment = function(t, e, i, o) { for (var n = this.polygons, s = 0, r = n.length; s < r; s++)
                if (this.intersectsSegmentPolygon(n[s], t, e, i, o)) return this.boundingBoxes[s]; return null }, e.prototype.intersectsSegmentPolygon = function(t, e, i, o, n) { for (var s = t, r = t.length, a = e - o, h = i - n, l = e * n - i * o, c = s[r - 2], d = s[r - 1], u = 0; u < r; u += 2) { var p = s[u],
                    m = s[u + 1],
                    f = c * m - d * p,
                    y = c - p,
                    b = d - m,
                    g = a * b - h * y,
                    _ = (l * y - a * f) / g; if ((_ >= c && _ <= p || _ >= p && _ <= c) && (_ >= e && _ <= o || _ >= o && _ <= e)) { var v = (l * b - h * f) / g; if ((v >= d && v <= m || v >= m && v <= d) && (v >= i && v <= n || v >= n && v <= i)) return !0 } c = p, d = m } return !1 }, e.prototype.getPolygon = function(t) { if (null == t) throw new Error("boundingBox cannot be null."); var e = this.boundingBoxes.indexOf(t); return -1 == e ? null : this.polygons[e] }, e.prototype.getWidth = function() { return this.maxX - this.minX }, e.prototype.getHeight = function() { return this.maxY - this.minY }, e }();
    t.SkeletonBounds = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e() { this.triangulator = new t.Triangulator, this.clippingPolygon = new Array, this.clipOutput = new Array, this.clippedVertices = new Array, this.clippedTriangles = new Array, this.scratch = new Array } return e.prototype.clipStart = function(i, o) { if (null != this.clipAttachment) return 0;
            this.clipAttachment = o; var n = o.worldVerticesLength,
                s = t.Utils.setArraySize(this.clippingPolygon, n);
            o.computeWorldVertices(i, 0, n, s, 0, 2); var r = this.clippingPolygon;
            e.makeClockwise(r); for (var a = this.clippingPolygons = this.triangulator.decompose(r, this.triangulator.triangulate(r)), h = 0, l = a.length; h < l; h++) { var c = a[h];
                e.makeClockwise(c), c.push(c[0]), c.push(c[1]) } return a.length }, e.prototype.clipEndWithSlot = function(t) { null != this.clipAttachment && this.clipAttachment.endSlot == t.data && this.clipEnd() }, e.prototype.clipEnd = function() { null != this.clipAttachment && (this.clipAttachment = null, this.clippingPolygons = null, this.clippedVertices.length = 0, this.clippedTriangles.length = 0, this.clippingPolygon.length = 0) }, e.prototype.isClipping = function() { return null != this.clipAttachment }, e.prototype.clipTriangles = function(e, i, o, n, s, r, a, h) { var l = this.clipOutput,
                c = this.clippedVertices,
                d = this.clippedTriangles,
                u = this.clippingPolygons,
                p = this.clippingPolygons.length,
                m = h ? 12 : 8,
                f = 0;
            c.length = 0, d.length = 0;
            t: for (var y = 0; y < n; y += 3)
                for (var b = o[y] << 1, g = e[b], _ = e[b + 1], v = s[b], x = s[b + 1], S = e[b = o[y + 1] << 1], C = e[b + 1], w = s[b], A = s[b + 1], T = e[b = o[y + 2] << 1], P = e[b + 1], k = s[b], M = s[b + 1], E = 0; E < p; E++) { var B = c.length; if (!this.clip(g, _, S, C, T, P, u[E], l)) {
                        (U = t.Utils.setArraySize(c, B + 3 * m))[B] = g, U[B + 1] = _, U[B + 2] = r.r, U[B + 3] = r.g, U[B + 4] = r.b, U[B + 5] = r.a, h ? (U[B + 6] = v, U[B + 7] = x, U[B + 8] = a.r, U[B + 9] = a.g, U[B + 10] = a.b, U[B + 11] = a.a, U[B + 12] = S, U[B + 13] = C, U[B + 14] = r.r, U[B + 15] = r.g, U[B + 16] = r.b, U[B + 17] = r.a, U[B + 18] = w, U[B + 19] = A, U[B + 20] = a.r, U[B + 21] = a.g, U[B + 22] = a.b, U[B + 23] = a.a, U[B + 24] = T, U[B + 25] = P, U[B + 26] = r.r, U[B + 27] = r.g, U[B + 28] = r.b, U[B + 29] = r.a, U[B + 30] = k, U[B + 31] = M, U[B + 32] = a.r, U[B + 33] = a.g, U[B + 34] = a.b, U[B + 35] = a.a) : (U[B + 6] = v, U[B + 7] = x, U[B + 8] = S, U[B + 9] = C, U[B + 10] = r.r, U[B + 11] = r.g, U[B + 12] = r.b, U[B + 13] = r.a, U[B + 14] = w, U[B + 15] = A, U[B + 16] = T, U[B + 17] = P, U[B + 18] = r.r, U[B + 19] = r.g, U[B + 20] = r.b, U[B + 21] = r.a, U[B + 22] = k, U[B + 23] = M), B = d.length, (Y = t.Utils.setArraySize(d, B + 3))[B] = f, Y[B + 1] = f + 1, Y[B + 2] = f + 2, f += 3; continue t } var I = l.length; if (0 != I) { for (var D = C - P, L = T - S, O = g - T, R = P - _, F = 1 / (D * O + L * (_ - P)), V = I >> 1, G = this.clipOutput, U = t.Utils.setArraySize(c, B + V * m), N = 0; N < I; N += 2) { var j = G[N],
                                W = G[N + 1];
                            U[B] = j, U[B + 1] = W, U[B + 2] = r.r, U[B + 3] = r.g, U[B + 4] = r.b, U[B + 5] = r.a; var X = j - T,
                                H = W - P,
                                z = (D * X + L * H) * F,
                                J = (R * X + O * H) * F,
                                q = 1 - z - J;
                            U[B + 6] = v * z + w * J + k * q, U[B + 7] = x * z + A * J + M * q, h && (U[B + 8] = a.r, U[B + 9] = a.g, U[B + 10] = a.b, U[B + 11] = a.a), B += m } B = d.length; var Y = t.Utils.setArraySize(d, B + 3 * (V - 2));
                        V--; for (N = 1; N < V; N++) Y[B] = f, Y[B + 1] = f + N, Y[B + 2] = f + N + 1, B += 3;
                        f += V + 1 } } }, e.prototype.clip = function(t, e, i, o, n, s, r, a) { var h = a,
                l = !1,
                c = null;
            r.length % 4 >= 2 ? (c = a, a = this.scratch) : c = this.scratch, c.length = 0, c.push(t), c.push(e), c.push(i), c.push(o), c.push(n), c.push(s), c.push(t), c.push(e), a.length = 0; for (var d = r, u = r.length - 4, p = 0;; p += 2) { for (var m = d[p], f = d[p + 1], y = d[p + 2], b = d[p + 3], g = m - y, _ = f - b, v = c, x = c.length - 2, S = a.length, C = 0; C < x; C += 2) { var w = v[C],
                        A = v[C + 1],
                        T = v[C + 2],
                        P = v[C + 3],
                        k = g * (P - b) - _ * (T - y) > 0; if (g * (A - b) - _ * (w - y) > 0) { if (k) { a.push(T), a.push(P); continue } B = ((E = T - w) * (f - A) - (M = P - A) * (m - w)) / (M * (y - m) - E * (b - f));
                        a.push(m + (y - m) * B), a.push(f + (b - f) * B) } else if (k) { var M = P - A,
                            E = T - w,
                            B = (E * (f - A) - M * (m - w)) / (M * (y - m) - E * (b - f));
                        a.push(m + (y - m) * B), a.push(f + (b - f) * B), a.push(T), a.push(P) } l = !0 } if (S == a.length) return h.length = 0, !0; if (a.push(a[0]), a.push(a[1]), p == u) break; var I = a;
                (a = c).length = 0, c = I } if (h != a) { h.length = 0; for (var p = 0, D = a.length - 2; p < D; p++) h[p] = a[p] } else h.length = h.length - 2; return l }, e.makeClockwise = function(t) { for (var e = t, i = t.length, o = e[i - 2] * e[1] - e[0] * e[i - 1], n = 0, s = 0, r = 0, a = 0, h = i - 3; a < h; a += 2) n = e[a], s = e[a + 1], r = e[a + 2], o += n * e[a + 3] - r * s; if (!(o < 0))
                for (var a = 0, l = i - 2, h = i >> 1; a < h; a += 2) { var c = e[a],
                        d = e[a + 1],
                        u = l - a;
                    e[a] = e[u], e[a + 1] = e[u + 1], e[u] = c, e[u + 1] = d } }, e }();
    t.SkeletonClipping = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function t() { this.bones = new Array, this.slots = new Array, this.skins = new Array, this.events = new Array, this.animations = new Array, this.ikConstraints = new Array, this.transformConstraints = new Array, this.pathConstraints = new Array, this.fps = 0 } return t.prototype.findBone = function(t) { if (null == t) throw new Error("boneName cannot be null."); for (var e = this.bones, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (n.name == t) return n } return null }, t.prototype.findBoneIndex = function(t) { if (null == t) throw new Error("boneName cannot be null."); for (var e = this.bones, i = 0, o = e.length; i < o; i++)
                if (e[i].name == t) return i; return -1 }, t.prototype.findSlot = function(t) { if (null == t) throw new Error("slotName cannot be null."); for (var e = this.slots, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (n.name == t) return n } return null }, t.prototype.findSlotIndex = function(t) { if (null == t) throw new Error("slotName cannot be null."); for (var e = this.slots, i = 0, o = e.length; i < o; i++)
                if (e[i].name == t) return i; return -1 }, t.prototype.findSkin = function(t) { if (null == t) throw new Error("skinName cannot be null."); for (var e = this.skins, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (n.name == t) return n } return null }, t.prototype.findEvent = function(t) { if (null == t) throw new Error("eventDataName cannot be null."); for (var e = this.events, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (n.name == t) return n } return null }, t.prototype.findAnimation = function(t) { if (null == t) throw new Error("animationName cannot be null."); for (var e = this.animations, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (n.name == t) return n } return null }, t.prototype.findIkConstraint = function(t) { if (null == t) throw new Error("constraintName cannot be null."); for (var e = this.ikConstraints, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (n.name == t) return n } return null }, t.prototype.findTransformConstraint = function(t) { if (null == t) throw new Error("constraintName cannot be null."); for (var e = this.transformConstraints, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (n.name == t) return n } return null }, t.prototype.findPathConstraint = function(t) { if (null == t) throw new Error("constraintName cannot be null."); for (var e = this.pathConstraints, i = 0, o = e.length; i < o; i++) { var n = e[i]; if (n.name == t) return n } return null }, t.prototype.findPathConstraintIndex = function(t) { if (null == t) throw new Error("pathConstraintName cannot be null."); for (var e = this.pathConstraints, i = 0, o = e.length; i < o; i++)
                if (e[i].name == t) return i; return -1 }, t }();
    t.SkeletonData = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e(t) { this.scale = 1, this.linkedMeshes = new Array, this.attachmentLoader = t } return e.prototype.readSkeletonData = function(i) { var o = this.scale,
                n = new t.SkeletonData,
                s = "string" == typeof i ? JSON.parse(i) : i,
                r = s.skeleton; if (null != r && (n.hash = r.hash, n.version = r.spine, n.width = r.width, n.height = r.height, n.fps = r.fps, n.imagesPath = r.images), s.bones)
                for (P = 0; P < s.bones.length; P++) { var a = s.bones[P],
                        h = null,
                        l = this.getValue(a, "parent", null); if (null != l && null == (h = n.findBone(l))) throw new Error("Parent bone not found: " + l);
                    (p = new t.BoneData(n.bones.length, a.name, h)).length = this.getValue(a, "length", 0) * o, p.x = this.getValue(a, "x", 0) * o, p.y = this.getValue(a, "y", 0) * o, p.rotation = this.getValue(a, "rotation", 0), p.scaleX = this.getValue(a, "scaleX", 1), p.scaleY = this.getValue(a, "scaleY", 1), p.shearX = this.getValue(a, "shearX", 0), p.shearY = this.getValue(a, "shearY", 0), p.transformMode = e.transformModeFromString(this.getValue(a, "transform", "normal")), n.bones.push(p) }
            if (s.slots)
                for (P = 0; P < s.slots.length; P++) { var c = (w = s.slots[P]).name,
                        d = w.bone,
                        u = n.findBone(d); if (null == u) throw new Error("Slot bone not found: " + d); var p = new t.SlotData(n.slots.length, c, u),
                        m = this.getValue(w, "color", null);
                    null != m && p.color.setFromString(m); var f = this.getValue(w, "dark", null);
                    null != f && (p.darkColor = new t.Color(1, 1, 1, 1), p.darkColor.setFromString(f)), p.attachmentName = this.getValue(w, "attachment", null), p.blendMode = e.blendModeFromString(this.getValue(w, "blend", "normal")), n.slots.push(p) }
            if (s.ik)
                for (P = 0; P < s.ik.length; P++) { y = s.ik[P];
                    (p = new t.IkConstraintData(y.name)).order = this.getValue(y, "order", 0); for (b = 0; b < y.bones.length; b++) { d = y.bones[b]; if (null == (g = n.findBone(d))) throw new Error("IK bone not found: " + d);
                        p.bones.push(g) } _ = y.target; if (p.target = n.findBone(_), null == p.target) throw new Error("IK target bone not found: " + _);
                    p.bendDirection = this.getValue(y, "bendPositive", !0) ? 1 : -1, p.mix = this.getValue(y, "mix", 1), n.ikConstraints.push(p) }
            if (s.transform)
                for (P = 0; P < s.transform.length; P++) { y = s.transform[P];
                    (p = new t.TransformConstraintData(y.name)).order = this.getValue(y, "order", 0); for (b = 0; b < y.bones.length; b++) { d = y.bones[b]; if (null == (g = n.findBone(d))) throw new Error("Transform constraint bone not found: " + d);
                        p.bones.push(g) } _ = y.target; if (p.target = n.findBone(_), null == p.target) throw new Error("Transform constraint target bone not found: " + _);
                    p.local = this.getValue(y, "local", !1), p.relative = this.getValue(y, "relative", !1), p.offsetRotation = this.getValue(y, "rotation", 0), p.offsetX = this.getValue(y, "x", 0) * o, p.offsetY = this.getValue(y, "y", 0) * o, p.offsetScaleX = this.getValue(y, "scaleX", 0), p.offsetScaleY = this.getValue(y, "scaleY", 0), p.offsetShearY = this.getValue(y, "shearY", 0), p.rotateMix = this.getValue(y, "rotateMix", 1), p.translateMix = this.getValue(y, "translateMix", 1), p.scaleMix = this.getValue(y, "scaleMix", 1), p.shearMix = this.getValue(y, "shearMix", 1), n.transformConstraints.push(p) }
            if (s.path)
                for (P = 0; P < s.path.length; P++) { var y = s.path[P];
                    (p = new t.PathConstraintData(y.name)).order = this.getValue(y, "order", 0); for (var b = 0; b < y.bones.length; b++) { var d = y.bones[b],
                            g = n.findBone(d); if (null == g) throw new Error("Transform constraint bone not found: " + d);
                        p.bones.push(g) } var _ = y.target; if (p.target = n.findSlot(_), null == p.target) throw new Error("Path target slot not found: " + _);
                    p.positionMode = e.positionModeFromString(this.getValue(y, "positionMode", "percent")), p.spacingMode = e.spacingModeFromString(this.getValue(y, "spacingMode", "length")), p.rotateMode = e.rotateModeFromString(this.getValue(y, "rotateMode", "tangent")), p.offsetRotation = this.getValue(y, "rotation", 0), p.position = this.getValue(y, "position", 0), p.positionMode == t.PositionMode.Fixed && (p.position *= o), p.spacing = this.getValue(y, "spacing", 0), p.spacingMode != t.SpacingMode.Length && p.spacingMode != t.SpacingMode.Fixed || (p.spacing *= o), p.rotateMix = this.getValue(y, "rotateMix", 1), p.translateMix = this.getValue(y, "translateMix", 1), n.pathConstraints.push(p) }
            if (s.skins)
                for (var v in s.skins) { var x = s.skins[v],
                        S = new t.Skin(v); for (var c in x) { var C = n.findSlotIndex(c); if (-1 == C) throw new Error("Slot not found: " + c); var w = x[c]; for (var A in w) { var T = this.readAttachment(w[A], S, C, A, n);
                            null != T && S.addAttachment(C, A, T) } } n.skins.push(S), "default" == S.name && (n.defaultSkin = S) }
            for (var P = 0, k = this.linkedMeshes.length; P < k; P++) { var M = this.linkedMeshes[P]; if (null == (S = null == M.skin ? n.defaultSkin : n.findSkin(M.skin))) throw new Error("Skin not found: " + M.skin); var E = S.getAttachment(M.slotIndex, M.parent); if (null == E) throw new Error("Parent mesh not found: " + M.parent);
                M.mesh.setParentMesh(E), M.mesh.updateUVs() } if (this.linkedMeshes.length = 0, s.events)
                for (var B in s.events) { var I = s.events[B];
                    (p = new t.EventData(B)).intValue = this.getValue(I, "int", 0), p.floatValue = this.getValue(I, "float", 0), p.stringValue = this.getValue(I, "string", ""), n.events.push(p) }
            if (s.animations)
                for (var D in s.animations) { var L = s.animations[D];
                    this.readAnimation(L, D, n) }
            return n }, e.prototype.readAttachment = function(e, o, n, s, r) { var a = this.scale; switch (s = this.getValue(e, "name", s), this.getValue(e, "type", "region")) {
                case "region":
                    var h = this.getValue(e, "path", s),
                        l = this.attachmentLoader.newRegionAttachment(o, s, h); return null == l ? null : (l.path = h, l.x = this.getValue(e, "x", 0) * a, l.y = this.getValue(e, "y", 0) * a, l.scaleX = this.getValue(e, "scaleX", 1), l.scaleY = this.getValue(e, "scaleY", 1), l.rotation = this.getValue(e, "rotation", 0), l.width = e.width * a, l.height = e.height * a, null != (x = this.getValue(e, "color", null)) && l.color.setFromString(x), l.updateOffset(), l);
                case "boundingbox":
                    var c = this.attachmentLoader.newBoundingBoxAttachment(o, s); return null == c ? null : (this.readVertices(e, c, e.vertexCount << 1), null != (x = this.getValue(e, "color", null)) && c.color.setFromString(x), c);
                case "mesh":
                case "linkedmesh":
                    var h = this.getValue(e, "path", s),
                        d = this.attachmentLoader.newMeshAttachment(o, s, h); if (null == d) return null;
                    d.path = h, null != (x = this.getValue(e, "color", null)) && d.color.setFromString(x); var u = this.getValue(e, "parent", null); if (null != u) return d.inheritDeform = this.getValue(e, "deform", !0), this.linkedMeshes.push(new i(d, this.getValue(e, "skin", null), n, u)), d; var p = e.uvs; return this.readVertices(e, d, p.length), d.triangles = e.triangles, d.regionUVs = p, d.updateUVs(), d.hullLength = 2 * this.getValue(e, "hull", 0), d;
                case "path":
                    if (null == (h = this.attachmentLoader.newPathAttachment(o, s))) return null;
                    h.closed = this.getValue(e, "closed", !1), h.constantSpeed = this.getValue(e, "constantSpeed", !0);
                    v = e.vertexCount;
                    this.readVertices(e, h, v << 1); for (var m = t.Utils.newArray(v / 3, 0), f = 0; f < e.lengths.length; f++) m[f] = e.lengths[f] * a; return h.lengths = m, null != (x = this.getValue(e, "color", null)) && h.color.setFromString(x), h;
                case "point":
                    var y = this.attachmentLoader.newPointAttachment(o, s); return null == y ? null : (y.x = this.getValue(e, "x", 0) * a, y.y = this.getValue(e, "y", 0) * a, y.rotation = this.getValue(e, "rotation", 0), null != (x = this.getValue(e, "color", null)) && y.color.setFromString(x), y);
                case "clipping":
                    var b = this.attachmentLoader.newClippingAttachment(o, s); if (null == b) return null; var g = this.getValue(e, "end", null); if (null != g) { var _ = r.findSlot(g); if (null == _) throw new Error("Clipping end slot not found: " + g);
                        b.endSlot = _ } var v = e.vertexCount;
                    this.readVertices(e, b, v << 1); var x = this.getValue(e, "color", null); return null != x && b.color.setFromString(x), b } return null }, e.prototype.readVertices = function(e, i, o) { var n = this.scale;
            i.worldVerticesLength = o; var s = e.vertices; if (o != s.length) { for (var r = new Array, a = new Array, h = 0, l = s.length; h < l;) { var c = s[h++];
                    a.push(c); for (var d = h + 4 * c; h < d; h += 4) a.push(s[h]), r.push(s[h + 1] * n), r.push(s[h + 2] * n), r.push(s[h + 3]) } i.bones = a, i.vertices = t.Utils.toFloatArray(r) } else { var u = t.Utils.toFloatArray(s); if (1 != n)
                    for (var h = 0, l = s.length; h < l; h++) u[h] *= n;
                i.vertices = u } }, e.prototype.readAnimation = function(e, i, o) { var n = this.scale,
                s = new Array,
                r = 0; if (e.slots)
                for (var a in e.slots) { E = e.slots[a]; if (-1 == (K = o.findSlotIndex(a))) throw new Error("Slot not found: " + a); for (var h in E) { B = E[h]; if ("attachment" == h) {
                            (g = new t.AttachmentTimeline(B.length)).slotIndex = K; for (var l = 0, c = 0; c < B.length; c++) { d = B[c];
                                g.setFrame(l++, d.time, d.name) } s.push(g), r = Math.max(r, g.frames[g.getFrameCount() - 1]) } else if ("color" == h) {
                            (g = new t.ColorTimeline(B.length)).slotIndex = K; for (var l = 0, c = 0; c < B.length; c++) { var d = B[c],
                                    u = new t.Color;
                                u.setFromString(d.color), g.setFrame(l, d.time, u.r, u.g, u.b, u.a), this.readCurve(d, g, l), l++ } s.push(g), r = Math.max(r, g.frames[(g.getFrameCount() - 1) * t.ColorTimeline.ENTRIES]) } else { if ("twoColor" != h) throw new Error("Invalid timeline type for a slot: " + h + " (" + a + ")");
                            (g = new t.TwoColorTimeline(B.length)).slotIndex = K; for (var l = 0, c = 0; c < B.length; c++) { var d = B[c],
                                    p = new t.Color,
                                    m = new t.Color;
                                p.setFromString(d.light), m.setFromString(d.dark), g.setFrame(l, d.time, p.r, p.g, p.b, p.a, m.r, m.g, m.b), this.readCurve(d, g, l), l++ } s.push(g), r = Math.max(r, g.frames[(g.getFrameCount() - 1) * t.TwoColorTimeline.ENTRIES]) } } }
            if (e.bones)
                for (var f in e.bones) { var y = e.bones[f],
                        b = o.findBoneIndex(f); if (-1 == b) throw new Error("Bone not found: " + f); for (var h in y) { B = y[h]; if ("rotate" === h) {
                            (g = new t.RotateTimeline(B.length)).boneIndex = b; for (var l = 0, c = 0; c < B.length; c++) { d = B[c];
                                g.setFrame(l, d.time, d.angle), this.readCurve(d, g, l), l++ } s.push(g), r = Math.max(r, g.frames[(g.getFrameCount() - 1) * t.RotateTimeline.ENTRIES]) } else { if ("translate" !== h && "scale" !== h && "shear" !== h) throw new Error("Invalid timeline type for a bone: " + h + " (" + f + ")"); var g = null,
                                _ = 1; "scale" === h ? g = new t.ScaleTimeline(B.length) : "shear" === h ? g = new t.ShearTimeline(B.length) : (g = new t.TranslateTimeline(B.length), _ = n), g.boneIndex = b; for (var l = 0, c = 0; c < B.length; c++) { var d = B[c],
                                    v = this.getValue(d, "x", 0),
                                    x = this.getValue(d, "y", 0);
                                g.setFrame(l, d.time, v * _, x * _), this.readCurve(d, g, l), l++ } s.push(g), r = Math.max(r, g.frames[(g.getFrameCount() - 1) * t.TranslateTimeline.ENTRIES]) } } }
            if (e.ik)
                for (var S in e.ik) { var C = e.ik[S],
                        w = o.findIkConstraint(S);
                    (g = new t.IkConstraintTimeline(C.length)).ikConstraintIndex = o.ikConstraints.indexOf(w); for (var l = 0, c = 0; c < C.length; c++) { d = C[c];
                        g.setFrame(l, d.time, this.getValue(d, "mix", 1), this.getValue(d, "bendPositive", !0) ? 1 : -1), this.readCurve(d, g, l), l++ } s.push(g), r = Math.max(r, g.frames[(g.getFrameCount() - 1) * t.IkConstraintTimeline.ENTRIES]) }
            if (e.transform)
                for (var S in e.transform) { var C = e.transform[S],
                        w = o.findTransformConstraint(S);
                    (g = new t.TransformConstraintTimeline(C.length)).transformConstraintIndex = o.transformConstraints.indexOf(w); for (var l = 0, c = 0; c < C.length; c++) { d = C[c];
                        g.setFrame(l, d.time, this.getValue(d, "rotateMix", 1), this.getValue(d, "translateMix", 1), this.getValue(d, "scaleMix", 1), this.getValue(d, "shearMix", 1)), this.readCurve(d, g, l), l++ } s.push(g), r = Math.max(r, g.frames[(g.getFrameCount() - 1) * t.TransformConstraintTimeline.ENTRIES]) }
            if (e.paths)
                for (var S in e.paths) { var C = e.paths[S],
                        A = o.findPathConstraintIndex(S); if (-1 == A) throw new Error("Path constraint not found: " + S); var T = o.pathConstraints[A]; for (var h in C) { B = C[h]; if ("position" === h || "spacing" === h) { var g = null,
                                _ = 1; "spacing" === h ? (g = new t.PathConstraintSpacingTimeline(B.length), T.spacingMode != t.SpacingMode.Length && T.spacingMode != t.SpacingMode.Fixed || (_ = n)) : (g = new t.PathConstraintPositionTimeline(B.length), T.positionMode == t.PositionMode.Fixed && (_ = n)), g.pathConstraintIndex = A; for (var l = 0, c = 0; c < B.length; c++) { d = B[c];
                                g.setFrame(l, d.time, this.getValue(d, h, 0) * _), this.readCurve(d, g, l), l++ } s.push(g), r = Math.max(r, g.frames[(g.getFrameCount() - 1) * t.PathConstraintPositionTimeline.ENTRIES]) } else if ("mix" === h) {
                            (g = new t.PathConstraintMixTimeline(B.length)).pathConstraintIndex = A; for (var l = 0, c = 0; c < B.length; c++) { d = B[c];
                                g.setFrame(l, d.time, this.getValue(d, "rotateMix", 1), this.getValue(d, "translateMix", 1)), this.readCurve(d, g, l), l++ } s.push(g), r = Math.max(r, g.frames[(g.getFrameCount() - 1) * t.PathConstraintMixTimeline.ENTRIES]) } } }
            if (e.deform)
                for (var P in e.deform) { var k = e.deform[P],
                        M = o.findSkin(P); if (null == M) throw new Error("Skin not found: " + P); for (var a in k) { var E = k[a]; if (-1 == (K = o.findSlotIndex(a))) throw new Error("Slot not found: " + E.name); for (var h in E) { var B = E[h],
                                I = M.getAttachment(K, h); if (null == I) throw new Error("Deform attachment not found: " + B.name); var D = null != I.bones,
                                L = I.vertices,
                                O = D ? L.length / 3 * 2 : L.length;
                            (g = new t.DeformTimeline(B.length)).slotIndex = K, g.attachment = I; for (var l = 0, R = 0; R < B.length; R++) { var d = B[R],
                                    F = void 0,
                                    V = this.getValue(d, "vertices", null); if (null == V) F = D ? t.Utils.newFloatArray(O) : L;
                                else { F = t.Utils.newFloatArray(O); var G = this.getValue(d, "offset", 0); if (t.Utils.arrayCopy(V, 0, F, G, V.length), 1 != n)
                                        for (var U = (c = G) + V.length; c < U; c++) F[c] *= n; if (!D)
                                        for (c = 0; c < O; c++) F[c] += L[c] } g.setFrame(l, d.time, F), this.readCurve(d, g, l), l++ } s.push(g), r = Math.max(r, g.frames[g.getFrameCount() - 1]) } } }
            var N = e.drawOrder; if (null == N && (N = e.draworder), null != N) { for (var g = new t.DrawOrderTimeline(N.length), j = o.slots.length, l = 0, R = 0; R < N.length; R++) { var W = N[R],
                        X = null,
                        H = this.getValue(W, "offsets", null); if (null != H) { X = t.Utils.newArray(j, -1); for (var z = t.Utils.newArray(j - H.length, 0), J = 0, q = 0, c = 0; c < H.length; c++) { var Y = H[c],
                                K = o.findSlotIndex(Y.slot); if (-1 == K) throw new Error("Slot not found: " + Y.slot); for (; J != K;) z[q++] = J++;
                            X[J + Y.offset] = J++ } for (; J < j;) z[q++] = J++; for (c = j - 1; c >= 0; c--) - 1 == X[c] && (X[c] = z[--q]) } g.setFrame(l++, W.time, X) } s.push(g), r = Math.max(r, g.frames[g.getFrameCount() - 1]) } if (e.events) { for (var g = new t.EventTimeline(e.events.length), l = 0, c = 0; c < e.events.length; c++) { var Z = e.events[c],
                        Q = o.findEvent(Z.name); if (null == Q) throw new Error("Event not found: " + Z.name); var $ = new t.Event(Z.time, Q);
                    $.intValue = this.getValue(Z, "int", Q.intValue), $.floatValue = this.getValue(Z, "float", Q.floatValue), $.stringValue = this.getValue(Z, "string", Q.stringValue), g.setFrame(l++, $) } s.push(g), r = Math.max(r, g.frames[g.getFrameCount() - 1]) } if (isNaN(r)) throw new Error("Error while parsing animation, duration is NaN");
            o.animations.push(new t.Animation(i, s, r)) }, e.prototype.readCurve = function(t, e, i) { if (t.curve)
                if ("stepped" === t.curve) e.setStepped(i);
                else if ("[object Array]" === Object.prototype.toString.call(t.curve)) { var o = t.curve;
                e.setCurve(i, o[0], o[1], o[2], o[3]) } }, e.prototype.getValue = function(t, e, i) { return void 0 !== t[e] ? t[e] : i }, e.blendModeFromString = function(e) { if ("normal" == (e = e.toLowerCase())) return t.BlendMode.Normal; if ("additive" == e) return t.BlendMode.Additive; if ("multiply" == e) return t.BlendMode.Multiply; if ("screen" == e) return t.BlendMode.Screen; throw new Error("Unknown blend mode: " + e) }, e.positionModeFromString = function(e) { if ("fixed" == (e = e.toLowerCase())) return t.PositionMode.Fixed; if ("percent" == e) return t.PositionMode.Percent; throw new Error("Unknown position mode: " + e) }, e.spacingModeFromString = function(e) { if ("length" == (e = e.toLowerCase())) return t.SpacingMode.Length; if ("fixed" == e) return t.SpacingMode.Fixed; if ("percent" == e) return t.SpacingMode.Percent; throw new Error("Unknown position mode: " + e) }, e.rotateModeFromString = function(e) { if ("tangent" == (e = e.toLowerCase())) return t.RotateMode.Tangent; if ("chain" == e) return t.RotateMode.Chain; if ("chainscale" == e) return t.RotateMode.ChainScale; throw new Error("Unknown rotate mode: " + e) }, e.transformModeFromString = function(e) { if ("normal" == (e = e.toLowerCase())) return t.TransformMode.Normal; if ("onlytranslation" == e) return t.TransformMode.OnlyTranslation; if ("norotationorreflection" == e) return t.TransformMode.NoRotationOrReflection; if ("noscale" == e) return t.TransformMode.NoScale; if ("noscaleorreflection" == e) return t.TransformMode.NoScaleOrReflection; throw new Error("Unknown transform mode: " + e) }, e }();
    t.SkeletonJson = e; var i = function() { return function(t, e, i, o) { this.mesh = t, this.skin = e, this.slotIndex = i, this.parent = o } }() }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function t(t) { if (this.attachments = new Array, null == t) throw new Error("name cannot be null.");
            this.name = t } return t.prototype.addAttachment = function(t, e, i) { if (null == i) throw new Error("attachment cannot be null."); var o = this.attachments;
            t >= o.length && (o.length = t + 1), o[t] || (o[t] = {}), o[t][e] = i }, t.prototype.getAttachment = function(t, e) { var i = this.attachments[t]; return i ? i[e] : null }, t.prototype.attachAll = function(t, e) { for (var i = 0, o = 0; o < t.slots.length; o++) { var n = t.slots[o],
                    s = n.getAttachment(); if (s && i < e.attachments.length) { var r = e.attachments[i]; for (var a in r)
                        if (s == r[a]) { var h = this.getAttachment(i, a);
                            null != h && n.setAttachment(h); break } } i++ } }, t }();
    t.Skin = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e(e, i) { if (this.attachmentVertices = new Array, null == e) throw new Error("data cannot be null."); if (null == i) throw new Error("bone cannot be null.");
            this.data = e, this.bone = i, this.color = new t.Color, this.darkColor = null == e.darkColor ? null : new t.Color, this.setToSetupPose() } return e.prototype.getAttachment = function() { return this.attachment }, e.prototype.setAttachment = function(t) { this.attachment != t && (this.attachment = t, this.attachmentTime = this.bone.skeleton.time, this.attachmentVertices.length = 0) }, e.prototype.setAttachmentTime = function(t) { this.attachmentTime = this.bone.skeleton.time - t }, e.prototype.getAttachmentTime = function() { return this.bone.skeleton.time - this.attachmentTime }, e.prototype.setToSetupPose = function() { this.color.setFromColor(this.data.color), null != this.darkColor && this.darkColor.setFromColor(this.data.darkColor), null == this.data.attachmentName ? this.attachment = null : (this.attachment = null, this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName))) }, e }();
    t.Slot = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() { return function(e, i, o) { if (this.color = new t.Color(1, 1, 1, 1), e < 0) throw new Error("index must be >= 0."); if (null == i) throw new Error("name cannot be null."); if (null == o) throw new Error("boneData cannot be null.");
            this.index = e, this.name = i, this.boneData = o } }();
    t.SlotData = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function t(t) { this._image = t } return t.prototype.getImage = function() { return this._image }, t.filterFromString = function(t) { switch (t.toLowerCase()) {
                case "nearest":
                    return i.Nearest;
                case "linear":
                    return i.Linear;
                case "mipmap":
                    return i.MipMap;
                case "mipmapnearestnearest":
                    return i.MipMapNearestNearest;
                case "mipmaplinearnearest":
                    return i.MipMapLinearNearest;
                case "mipmapnearestlinear":
                    return i.MipMapNearestLinear;
                case "mipmaplinearlinear":
                    return i.MipMapLinearLinear;
                default:
                    throw new Error("Unknown texture filter " + t) } }, t.wrapFromString = function(t) { switch (t.toLowerCase()) {
                case "mirroredtepeat":
                    return o.MirroredRepeat;
                case "clamptoedge":
                    return o.ClampToEdge;
                case "repeat":
                    return o.Repeat;
                default:
                    throw new Error("Unknown texture wrap " + t) } }, t }();
    t.Texture = e; var i;! function(t) { t[t.Nearest = 9728] = "Nearest", t[t.Linear = 9729] = "Linear", t[t.MipMap = 9987] = "MipMap", t[t.MipMapNearestNearest = 9984] = "MipMapNearestNearest", t[t.MipMapLinearNearest = 9985] = "MipMapLinearNearest", t[t.MipMapNearestLinear = 9986] = "MipMapNearestLinear", t[t.MipMapLinearLinear = 9987] = "MipMapLinearLinear" }(i = t.TextureFilter || (t.TextureFilter = {})); var o;! function(t) { t[t.MirroredRepeat = 33648] = "MirroredRepeat", t[t.ClampToEdge = 33071] = "ClampToEdge", t[t.Repeat = 10497] = "Repeat" }(o = t.TextureWrap || (t.TextureWrap = {})); var n = function() { return function() { this.u = 0, this.v = 0, this.u2 = 0, this.v2 = 0, this.width = 0, this.height = 0, this.rotate = !1, this.offsetX = 0, this.offsetY = 0, this.originalWidth = 0, this.originalHeight = 0 } }();
    t.TextureRegion = n }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e(t, e) { this.pages = new Array, this.regions = new Array, this.load(t, e) } return e.prototype.load = function(e, s) { if (null == s) throw new Error("textureLoader cannot be null."); for (var r = new i(e), a = new Array(4), h = null;;) { var l = r.readLine(); if (null == l) break; if (0 == (l = l.trim()).length) h = null;
                else if (h) { var c = new n;
                    c.name = l, c.page = h, c.rotate = "true" == r.readValue(), r.readTuple(a); var d = parseInt(a[0]),
                        u = parseInt(a[1]);
                    r.readTuple(a); var p = parseInt(a[0]),
                        m = parseInt(a[1]);
                    c.u = d / h.width, c.v = u / h.height, c.rotate ? (c.u2 = (d + m) / h.width, c.v2 = (u + p) / h.height) : (c.u2 = (d + p) / h.width, c.v2 = (u + m) / h.height), c.x = d, c.y = u, c.width = Math.abs(p), c.height = Math.abs(m), 4 == r.readTuple(a) && 4 == r.readTuple(a) && r.readTuple(a), c.originalWidth = parseInt(a[0]), c.originalHeight = parseInt(a[1]), r.readTuple(a), c.offsetX = parseInt(a[0]), c.offsetY = parseInt(a[1]), c.index = parseInt(r.readValue()), c.texture = h.texture, this.regions.push(c) } else {
                    (h = new o).name = l, 2 == r.readTuple(a) && (h.width = parseInt(a[0]), h.height = parseInt(a[1]), r.readTuple(a)), r.readTuple(a); var f = { min: a[0], mag: a[1] };
                    h.minFilter = t.Texture.filterFromString(f.min), h.magFilter = t.Texture.filterFromString(f.mag); var y = r.readValue();
                    h.uWrap = t.TextureWrap.ClampToEdge, h.vWrap = t.TextureWrap.ClampToEdge, "x" == y ? h.uWrap = t.TextureWrap.Repeat : "y" == y ? h.vWrap = t.TextureWrap.Repeat : "xy" == y && (h.uWrap = h.vWrap = t.TextureWrap.Repeat), h.texture = s(l, f), h.texture.setFilters(h.minFilter, h.magFilter), h.texture.setWraps(h.uWrap, h.vWrap), h.width = h.texture.getImage().width, h.height = h.texture.getImage().height, this.pages.push(h) } } }, e.prototype.findRegion = function(t) { for (var e = 0; e < this.regions.length; e++)
                if (this.regions[e].name == t) return this.regions[e]; return null }, e.prototype.dispose = function() { for (var t = 0; t < this.pages.length; t++) this.pages[t].texture.dispose() }, e }();
    t.TextureAtlas = e; var i = function() {
            function t(t) { this.index = 0, this.lines = t.split(/\r\n|\r|\n/) } return t.prototype.readLine = function() { return this.index >= this.lines.length ? null : this.lines[this.index++] }, t.prototype.readValue = function() { var t = this.readLine(),
                    e = t.indexOf(":"); if (-1 == e) throw new Error("Invalid line: " + t); return t.substring(e + 1).trim() }, t.prototype.readTuple = function(t) { var e = this.readLine(),
                    i = e.indexOf(":"); if (-1 == i) throw new Error("Invalid line: " + e); for (var o = 0, n = i + 1; o < 3; o++) { var s = e.indexOf(",", n); if (-1 == s) break;
                    t[o] = e.substr(n, s - n).trim(), n = s + 1 } return t[o] = e.substring(n).trim(), o + 1 }, t }(),
        o = function() { return function() {} }();
    t.TextureAtlasPage = o; var n = function(t) {
        function e() { return null !== t && t.apply(this, arguments) || this } return __extends(e, t), e }(t.TextureRegion);
    t.TextureAtlasRegion = n }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e(e, i) { if (this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, this.temp = new t.Vector2, null == e) throw new Error("data cannot be null."); if (null == i) throw new Error("skeleton cannot be null.");
            this.data = e, this.rotateMix = e.rotateMix, this.translateMix = e.translateMix, this.scaleMix = e.scaleMix, this.shearMix = e.shearMix, this.bones = new Array; for (var o = 0; o < e.bones.length; o++) this.bones.push(i.findBone(e.bones[o].name));
            this.target = i.findBone(e.target.name) } return e.prototype.apply = function() { this.update() }, e.prototype.update = function() { this.data.local ? this.data.relative ? this.applyRelativeLocal() : this.applyAbsoluteLocal() : this.data.relative ? this.applyRelativeWorld() : this.applyAbsoluteWorld() }, e.prototype.applyAbsoluteWorld = function() { for (var e = this.rotateMix, i = this.translateMix, o = this.scaleMix, n = this.shearMix, s = this.target, r = s.a, a = s.b, h = s.c, l = s.d, c = r * l - a * h > 0 ? t.MathUtils.degRad : -t.MathUtils.degRad, d = this.data.offsetRotation * c, u = this.data.offsetShearY * c, p = this.bones, m = 0, f = p.length; m < f; m++) { var y = p[m],
                    b = !1; if (0 != e) { var g = y.a,
                        _ = y.b,
                        v = y.c,
                        x = y.d;
                    (k = Math.atan2(h, r) - Math.atan2(v, g) + d) > t.MathUtils.PI ? k -= t.MathUtils.PI2 : k < -t.MathUtils.PI && (k += t.MathUtils.PI2), k *= e; var S = Math.cos(k),
                        C = Math.sin(k);
                    y.a = S * g - C * v, y.b = S * _ - C * x, y.c = C * g + S * v, y.d = C * _ + S * x, b = !0 } if (0 != i) { var w = this.temp;
                    s.localToWorld(w.set(this.data.offsetX, this.data.offsetY)), y.worldX += (w.x - y.worldX) * i, y.worldY += (w.y - y.worldY) * i, b = !0 } if (o > 0) { var A = Math.sqrt(y.a * y.a + y.c * y.c),
                        T = Math.sqrt(r * r + h * h);
                    A > 1e-5 && (A = (A + (T - A + this.data.offsetScaleX) * o) / A), y.a *= A, y.c *= A, A = Math.sqrt(y.b * y.b + y.d * y.d), T = Math.sqrt(a * a + l * l), A > 1e-5 && (A = (A + (T - A + this.data.offsetScaleY) * o) / A), y.b *= A, y.d *= A, b = !0 } if (n > 0) { var _ = y.b,
                        x = y.d,
                        P = Math.atan2(x, _),
                        k = Math.atan2(l, a) - Math.atan2(h, r) - (P - Math.atan2(y.c, y.a));
                    k > t.MathUtils.PI ? k -= t.MathUtils.PI2 : k < -t.MathUtils.PI && (k += t.MathUtils.PI2), k = P + (k + u) * n;
                    A = Math.sqrt(_ * _ + x * x);
                    y.b = Math.cos(k) * A, y.d = Math.sin(k) * A, b = !0 } b && (y.appliedValid = !1) } }, e.prototype.applyRelativeWorld = function() { for (var e = this.rotateMix, i = this.translateMix, o = this.scaleMix, n = this.shearMix, s = this.target, r = s.a, a = s.b, h = s.c, l = s.d, c = r * l - a * h > 0 ? t.MathUtils.degRad : -t.MathUtils.degRad, d = this.data.offsetRotation * c, u = this.data.offsetShearY * c, p = this.bones, m = 0, f = p.length; m < f; m++) { var y = p[m],
                    b = !1; if (0 != e) { var g = y.a,
                        _ = y.b,
                        v = y.c,
                        x = y.d;
                    (A = Math.atan2(h, r) + d) > t.MathUtils.PI ? A -= t.MathUtils.PI2 : A < -t.MathUtils.PI && (A += t.MathUtils.PI2), A *= e; var S = Math.cos(A),
                        C = Math.sin(A);
                    y.a = S * g - C * v, y.b = S * _ - C * x, y.c = C * g + S * v, y.d = C * _ + S * x, b = !0 } if (0 != i) { var w = this.temp;
                    s.localToWorld(w.set(this.data.offsetX, this.data.offsetY)), y.worldX += w.x * i, y.worldY += w.y * i, b = !0 } if (o > 0) { T = (Math.sqrt(r * r + h * h) - 1 + this.data.offsetScaleX) * o + 1;
                    y.a *= T, y.c *= T, T = (Math.sqrt(a * a + l * l) - 1 + this.data.offsetScaleY) * o + 1, y.b *= T, y.d *= T, b = !0 } if (n > 0) { var A = Math.atan2(l, a) - Math.atan2(h, r);
                    A > t.MathUtils.PI ? A -= t.MathUtils.PI2 : A < -t.MathUtils.PI && (A += t.MathUtils.PI2); var _ = y.b,
                        x = y.d;
                    A = Math.atan2(x, _) + (A - t.MathUtils.PI / 2 + u) * n; var T = Math.sqrt(_ * _ + x * x);
                    y.b = Math.cos(A) * T, y.d = Math.sin(A) * T, b = !0 } b && (y.appliedValid = !1) } }, e.prototype.applyAbsoluteLocal = function() { var t = this.rotateMix,
                e = this.translateMix,
                i = this.scaleMix,
                o = this.shearMix,
                n = this.target;
            n.appliedValid || n.updateAppliedTransform(); for (var s = this.bones, r = 0, a = s.length; r < a; r++) { var h = s[r];
                h.appliedValid || h.updateAppliedTransform(); var l = h.arotation; if (0 != t) { f = n.arotation - l + this.data.offsetRotation;
                    l += (f -= 360 * (16384 - (16384.499999999996 - f / 360 | 0))) * t } var c = h.ax,
                    d = h.ay;
                0 != e && (c += (n.ax - c + this.data.offsetX) * e, d += (n.ay - d + this.data.offsetY) * e); var u = h.ascaleX,
                    p = h.ascaleY;
                i > 0 && (u > 1e-5 && (u = (u + (n.ascaleX - u + this.data.offsetScaleX) * i) / u), p > 1e-5 && (p = (p + (n.ascaleY - p + this.data.offsetScaleY) * i) / p)); var m = h.ashearY; if (o > 0) { var f = n.ashearY - m + this.data.offsetShearY;
                    f -= 360 * (16384 - (16384.499999999996 - f / 360 | 0)), h.shearY += f * o } h.updateWorldTransformWith(c, d, l, u, p, h.ashearX, m) } }, e.prototype.applyRelativeLocal = function() { var t = this.rotateMix,
                e = this.translateMix,
                i = this.scaleMix,
                o = this.shearMix,
                n = this.target;
            n.appliedValid || n.updateAppliedTransform(); for (var s = this.bones, r = 0, a = s.length; r < a; r++) { var h = s[r];
                h.appliedValid || h.updateAppliedTransform(); var l = h.arotation;
                0 != t && (l += (n.arotation + this.data.offsetRotation) * t); var c = h.ax,
                    d = h.ay;
                0 != e && (c += (n.ax + this.data.offsetX) * e, d += (n.ay + this.data.offsetY) * e); var u = h.ascaleX,
                    p = h.ascaleY;
                i > 0 && (u > 1e-5 && (u *= (n.ascaleX - 1 + this.data.offsetScaleX) * i + 1), p > 1e-5 && (p *= (n.ascaleY - 1 + this.data.offsetScaleY) * i + 1)); var m = h.ashearY;
                o > 0 && (m += (n.ashearY + this.data.offsetShearY) * o), h.updateWorldTransformWith(c, d, l, u, p, h.ashearX, m) } }, e.prototype.getOrder = function() { return this.data.order }, e }();
    t.TransformConstraint = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() { return function(t) { if (this.order = 0, this.bones = new Array, this.rotateMix = 0, this.translateMix = 0, this.scaleMix = 0, this.shearMix = 0, this.offsetRotation = 0, this.offsetX = 0, this.offsetY = 0, this.offsetScaleX = 0, this.offsetScaleY = 0, this.offsetShearY = 0, this.relative = !1, this.local = !1, null == t) throw new Error("name cannot be null.");
            this.name = t } }();
    t.TransformConstraintData = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e() { this.convexPolygons = new Array, this.convexPolygonsIndices = new Array, this.indicesArray = new Array, this.isConcaveArray = new Array, this.triangles = new Array, this.polygonPool = new t.Pool(function() { return new Array }), this.polygonIndicesPool = new t.Pool(function() { return new Array }) } return e.prototype.triangulate = function(t) { var i = t,
                o = t.length >> 1,
                n = this.indicesArray;
            n.length = 0; for (r = 0; r < o; r++) n[r] = r; var s = this.isConcaveArray;
            s.length = 0; for (var r = 0, a = o; r < a; ++r) s[r] = e.isConcave(r, o, i, n); var h = this.triangles; for (h.length = 0; o > 3;) { for (var l = o - 1, r = 0, c = 1;;) { t: if (!s[r]) { for (var d = n[l] << 1, u = n[r] << 1, p = n[c] << 1, m = i[d], f = i[d + 1], y = i[u], b = i[u + 1], g = i[p], _ = i[p + 1], v = (c + 1) % o; v != l; v = (v + 1) % o)
                            if (s[v]) { var x = n[v] << 1,
                                    S = i[x],
                                    C = i[x + 1]; if (e.positiveArea(g, _, m, f, S, C) && e.positiveArea(m, f, y, b, S, C) && e.positiveArea(y, b, g, _, S, C)) break t } break } if (0 == c) { do { if (!s[r]) break;
                            r-- } while (r > 0); break } l = r, r = c, c = (c + 1) % o } h.push(n[(o + r - 1) % o]), h.push(n[r]), h.push(n[(r + 1) % o]), n.splice(r, 1), s.splice(r, 1); var w = (--o + r - 1) % o,
                    A = r == o ? 0 : r;
                s[w] = e.isConcave(w, o, i, n), s[A] = e.isConcave(A, o, i, n) } return 3 == o && (h.push(n[2]), h.push(n[0]), h.push(n[1])), h }, e.prototype.decompose = function(t, i) { var o = t,
                n = this.convexPolygons;
            this.polygonPool.freeAll(n), n.length = 0; var s = this.convexPolygonsIndices;
            this.polygonIndicesPool.freeAll(s), s.length = 0; var r = this.polygonIndicesPool.obtain();
            r.length = 0; var a = this.polygonPool.obtain();
            a.length = 0; for (var h = -1, l = 0, c = 0, d = i.length; c < d; c += 3) { var u = i[c] << 1,
                    p = i[c + 1] << 1,
                    m = i[c + 2] << 1,
                    f = o[u],
                    y = o[u + 1],
                    b = o[p],
                    g = o[p + 1],
                    _ = o[m],
                    v = o[m + 1],
                    x = !1; if (h == u) { var S = a.length - 4,
                        C = e.winding(a[S], a[S + 1], a[S + 2], a[S + 3], _, v),
                        w = e.winding(_, v, a[0], a[1], a[2], a[3]);
                    C == l && w == l && (a.push(_), a.push(v), r.push(m), x = !0) } x || (a.length > 0 ? (n.push(a), s.push(r)) : (this.polygonPool.free(a), this.polygonIndicesPool.free(r)), (a = this.polygonPool.obtain()).length = 0, a.push(f), a.push(y), a.push(b), a.push(g), a.push(_), a.push(v), (r = this.polygonIndicesPool.obtain()).length = 0, r.push(u), r.push(p), r.push(m), l = e.winding(f, y, b, g, _, v), h = u) } a.length > 0 && (n.push(a), s.push(r)); for (var c = 0, d = n.length; c < d; c++)
                if (0 != (r = s[c]).length)
                    for (var A = r[0], T = r[r.length - 1], P = (a = n[c])[S = a.length - 4], k = a[S + 1], M = a[S + 2], E = a[S + 3], B = a[0], I = a[1], D = a[2], L = a[3], O = e.winding(P, k, M, E, B, I), R = 0; R < d; R++)
                        if (R != c) { var F = s[R]; if (3 == F.length) { var V = F[0],
                                    G = F[1],
                                    U = F[2],
                                    N = n[R],
                                    _ = N[N.length - 2],
                                    v = N[N.length - 1]; if (V == A && G == T) { var C = e.winding(P, k, M, E, _, v),
                                        w = e.winding(_, v, B, I, D, L);
                                    C == O && w == O && (N.length = 0, F.length = 0, a.push(_), a.push(v), r.push(U), P = M, k = E, M = _, E = v, R = 0) } } } for (c = n.length - 1; c >= 0; c--) 0 == (a = n[c]).length && (n.splice(c, 1), this.polygonPool.free(a), r = s[c], s.splice(c, 1), this.polygonIndicesPool.free(r)); return n }, e.isConcave = function(t, e, i, o) { var n = o[(e + t - 1) % e] << 1,
                s = o[t] << 1,
                r = o[(t + 1) % e] << 1; return !this.positiveArea(i[n], i[n + 1], i[s], i[s + 1], i[r], i[r + 1]) }, e.positiveArea = function(t, e, i, o, n, s) { return t * (s - o) + i * (e - s) + n * (o - e) >= 0 }, e.winding = function(t, e, i, o, n, s) { var r = i - t,
                a = o - e; return n * a - s * r + r * e - t * a >= 0 ? 1 : -1 }, e }();
    t.Triangulator = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function t() { this.array = new Array } return t.prototype.add = function(t) { var e = this.contains(t); return this.array[0 | t] = 0 | t, !e }, t.prototype.contains = function(t) { return void 0 != this.array[0 | t] }, t.prototype.remove = function(t) { this.array[0 | t] = void 0 }, t.prototype.clear = function() { this.array.length = 0 }, t }();
    t.IntSet = e; var i = function() {
        function t(t, e, i, o) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === o && (o = 0), this.r = t, this.g = e, this.b = i, this.a = o } return t.prototype.set = function(t, e, i, o) { return this.r = t, this.g = e, this.b = i, this.a = o, this.clamp(), this }, t.prototype.setFromColor = function(t) { return this.r = t.r, this.g = t.g, this.b = t.b, this.a = t.a, this }, t.prototype.setFromString = function(t) { return t = "#" == t.charAt(0) ? t.substr(1) : t, this.r = parseInt(t.substr(0, 2), 16) / 255, this.g = parseInt(t.substr(2, 2), 16) / 255, this.b = parseInt(t.substr(4, 2), 16) / 255, this.a = (8 != t.length ? 255 : parseInt(t.substr(6, 2), 16)) / 255, this }, t.prototype.add = function(t, e, i, o) { return this.r += t, this.g += e, this.b += i, this.a += o, this.clamp(), this }, t.prototype.clamp = function() { return this.r < 0 ? this.r = 0 : this.r > 1 && (this.r = 1), this.g < 0 ? this.g = 0 : this.g > 1 && (this.g = 1), this.b < 0 ? this.b = 0 : this.b > 1 && (this.b = 1), this.a < 0 ? this.a = 0 : this.a > 1 && (this.a = 1), this }, t }();
    i.WHITE = new i(1, 1, 1, 1), i.RED = new i(1, 0, 0, 1), i.GREEN = new i(0, 1, 0, 1), i.BLUE = new i(0, 0, 1, 1), i.MAGENTA = new i(1, 0, 1, 1), t.Color = i; var o = function() {
        function t() {} return t.clamp = function(t, e, i) { return t < e ? e : t > i ? i : t }, t.cosDeg = function(e) { return Math.cos(e * t.degRad) }, t.sinDeg = function(e) { return Math.sin(e * t.degRad) }, t.signum = function(t) { return t > 0 ? 1 : t < 0 ? -1 : 0 }, t.toInt = function(t) { return t > 0 ? Math.floor(t) : Math.ceil(t) }, t.cbrt = function(t) { var e = Math.pow(Math.abs(t), 1 / 3); return t < 0 ? -e : e }, t.randomTriangular = function(e, i) { return t.randomTriangularWith(e, i, .5 * (e + i)) }, t.randomTriangularWith = function(t, e, i) { var o = Math.random(),
                n = e - t; return o <= (i - t) / n ? t + Math.sqrt(o * n * (i - t)) : e - Math.sqrt((1 - o) * n * (e - i)) }, t }();
    o.PI = 3.1415927, o.PI2 = 2 * o.PI, o.radiansToDegrees = 180 / o.PI, o.radDeg = o.radiansToDegrees, o.degreesToRadians = o.PI / 180, o.degRad = o.degreesToRadians, t.MathUtils = o; var n = function() {
        function t() {} return t.prototype.apply = function(t, e, i) { return t + (e - t) * this.applyInternal(i) }, t }();
    t.Interpolation = n; var s = function(t) {
        function e(e) { var i = t.call(this) || this; return i.power = 2, i.power = e, i } return __extends(e, t), e.prototype.applyInternal = function(t) { return t <= .5 ? Math.pow(2 * t, this.power) / 2 : Math.pow(2 * (t - 1), this.power) / (this.power % 2 == 0 ? -2 : 2) + 1 }, e }(n);
    t.Pow = s; var r = function(t) {
        function e(e) { return t.call(this, e) || this } return __extends(e, t), e.prototype.applyInternal = function(t) { return Math.pow(t - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1 }, e }(s);
    t.PowOut = r; var a = function() {
        function t() {} return t.arrayCopy = function(t, e, i, o, n) { for (var s = e, r = o; s < e + n; s++, r++) i[r] = t[s] }, t.setArraySize = function(t, e, i) { void 0 === i && (i = 0); var o = t.length; if (o == e) return t; if (t.length = e, o < e)
                for (var n = o; n < e; n++) t[n] = i; return t }, t.ensureArrayCapacity = function(e, i, o) { return void 0 === o && (o = 0), e.length >= i ? e : t.setArraySize(e, i, o) }, t.newArray = function(t, e) { for (var i = new Array(t), o = 0; o < t; o++) i[o] = e; return i }, t.newFloatArray = function(e) { if (t.SUPPORTS_TYPED_ARRAYS) return new Float32Array(e); for (var i = new Array(e), o = 0; o < i.length; o++) i[o] = 0; return i }, t.newShortArray = function(e) { if (t.SUPPORTS_TYPED_ARRAYS) return new Int16Array(e); for (var i = new Array(e), o = 0; o < i.length; o++) i[o] = 0; return i }, t.toFloatArray = function(e) { return t.SUPPORTS_TYPED_ARRAYS ? new Float32Array(e) : e }, t }();
    a.SUPPORTS_TYPED_ARRAYS = "undefined" != typeof Float32Array, t.Utils = a; var h = function() {
        function t() {} return t.logBones = function(t) { for (var e = 0; e < t.bones.length; e++) t.bones[e] }, t }();
    t.DebugUtils = h; var l = function() {
        function t(t) { this.items = new Array, this.instantiator = t } return t.prototype.obtain = function() { return this.items.length > 0 ? this.items.pop() : this.instantiator() }, t.prototype.free = function(t) { t.reset && t.reset(), this.items.push(t) }, t.prototype.freeAll = function(t) { for (var e = 0; e < t.length; e++) t[e].reset && t[e].reset(), this.items[e] = t[e] }, t.prototype.clear = function() { this.items.length = 0 }, t }();
    t.Pool = l; var c = function() {
        function t(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), this.x = t, this.y = e } return t.prototype.set = function(t, e) { return this.x = t, this.y = e, this }, t.prototype.length = function() { var t = this.x,
                e = this.y; return Math.sqrt(t * t + e * e) }, t.prototype.normalize = function() { var t = this.length(); return 0 != t && (this.x /= t, this.y /= t), this }, t }();
    t.Vector2 = c; var d = function() {
        function t() { this.maxDelta = .064, this.framesPerSecond = 0, this.delta = 0, this.totalTime = 0, this.lastTime = Date.now() / 1e3, this.frameCount = 0, this.frameTime = 0 } return t.prototype.update = function() { var t = Date.now() / 1e3;
            this.delta = t - this.lastTime, this.frameTime += this.delta, this.totalTime += this.delta, this.delta > this.maxDelta && (this.delta = this.maxDelta), this.lastTime = t, this.frameCount++, this.frameTime > 1 && (this.framesPerSecond = this.frameCount / this.frameTime, this.frameTime = 0, this.frameCount = 0) }, t }();
    t.TimeKeeper = d; var u = function() {
        function t(t) { void 0 === t && (t = 32), this.addedValues = 0, this.lastValue = 0, this.mean = 0, this.dirty = !0, this.values = new Array(t) } return t.prototype.hasEnoughData = function() { return this.addedValues >= this.values.length }, t.prototype.addValue = function(t) { this.addedValues < this.values.length && this.addedValues++, this.values[this.lastValue++] = t, this.lastValue > this.values.length - 1 && (this.lastValue = 0), this.dirty = !0 }, t.prototype.getMean = function() { if (this.hasEnoughData()) { if (this.dirty) { for (var t = 0, e = 0; e < this.values.length; e++) t += this.values[e];
                    this.mean = t / this.values.length, this.dirty = !1 } return this.mean } return 0 }, t }();
    t.WindowedMean = u }(spine || (spine = {}));
var spine;
! function(t) { var e = function() { return function(t) { if (null == t) throw new Error("name cannot be null.");
            this.name = t } }();
    t.Attachment = e; var i = function(t) {
        function e(i) { var o = t.call(this, i) || this; return o.id = (65535 & e.nextID++) << 11, o.worldVerticesLength = 0, o } return __extends(e, t), e.prototype.computeWorldVertices = function(t, e, i, o, n, s) { i = n + (i >> 1) * s; var r = t.bone.skeleton,
                a = t.attachmentVertices,
                h = this.vertices,
                l = this.bones; if (null != l) { for (var c = 0, d = 0, u = 0; u < e; u += 2) c += (g = l[c]) + 1, d += g; var p = r.bones; if (0 == a.length)
                    for (var m = n, f = 3 * d; m < i; m += s) { var y = 0,
                            b = 0,
                            g = l[c++]; for (g += c; c < g; c++, f += 3) { var _ = p[l[c]],
                                v = h[f],
                                x = h[f + 1],
                                S = h[f + 2];
                            y += (v * _.a + x * _.b + _.worldX) * S, b += (v * _.c + x * _.d + _.worldY) * S } o[m] = y, o[m + 1] = b } else
                        for (var C = a, m = n, f = 3 * d, w = d << 1; m < i; m += s) { var y = 0,
                                b = 0,
                                g = l[c++]; for (g += c; c < g; c++, f += 3, w += 2) { var _ = p[l[c]],
                                    v = h[f] + C[w],
                                    x = h[f + 1] + C[w + 1],
                                    S = h[f + 2];
                                y += (v * _.a + x * _.b + _.worldX) * S, b += (v * _.c + x * _.d + _.worldY) * S } o[m] = y, o[m + 1] = b } } else { a.length > 0 && (h = a); for (var A = (_ = t.bone).worldX, T = _.worldY, P = _.a, f = _.b, k = _.c, M = _.d, E = e, m = n; m < i; E += 2, m += s) { var v = h[E],
                        x = h[E + 1];
                    o[m] = v * P + x * f + A, o[m + 1] = v * k + x * M + T } } }, e.prototype.applyDeform = function(t) { return this == t }, e }(e);
    i.nextID = 0, t.VertexAttachment = i }(spine || (spine = {}));
var spine;
! function(t) {! function(t) { t[t.Region = 0] = "Region", t[t.BoundingBox = 1] = "BoundingBox", t[t.Mesh = 2] = "Mesh", t[t.LinkedMesh = 3] = "LinkedMesh", t[t.Path = 4] = "Path", t[t.Point = 5] = "Point" }(t.AttachmentType || (t.AttachmentType = {})) }(spine || (spine = {}));
var spine;
! function(t) { var e = function(e) {
        function i(i) { var o = e.call(this, i) || this; return o.color = new t.Color(1, 1, 1, 1), o } return __extends(i, e), i }(t.VertexAttachment);
    t.BoundingBoxAttachment = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function(e) {
        function i(i) { var o = e.call(this, i) || this; return o.color = new t.Color(.2275, .2275, .8078, 1), o } return __extends(i, e), i }(t.VertexAttachment);
    t.ClippingAttachment = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function(e) {
        function i(i) { var o = e.call(this, i) || this; return o.color = new t.Color(1, 1, 1, 1), o.inheritDeform = !1, o.tempColor = new t.Color(0, 0, 0, 0), o } return __extends(i, e), i.prototype.updateUVs = function() { var e = 0,
                i = 0,
                o = 0,
                n = 0;
            null == this.region ? (e = i = 0, o = n = 1) : (e = this.region.u, i = this.region.v, o = this.region.u2 - e, n = this.region.v2 - i); var s = this.regionUVs;
            null != this.uvs && this.uvs.length == s.length || (this.uvs = t.Utils.newFloatArray(s.length)); var r = this.uvs; if (this.region.rotate)
                for (var a = 0, h = r.length; a < h; a += 2) r[a] = e + s[a + 1] * o, r[a + 1] = i + n - s[a] * n;
            else
                for (var a = 0, h = r.length; a < h; a += 2) r[a] = e + s[a] * o, r[a + 1] = i + s[a + 1] * n }, i.prototype.applyDeform = function(t) { return this == t || this.inheritDeform && this.parentMesh == t }, i.prototype.getParentMesh = function() { return this.parentMesh }, i.prototype.setParentMesh = function(t) { this.parentMesh = t, null != t && (this.bones = t.bones, this.vertices = t.vertices, this.worldVerticesLength = t.worldVerticesLength, this.regionUVs = t.regionUVs, this.triangles = t.triangles, this.hullLength = t.hullLength, this.worldVerticesLength = t.worldVerticesLength) }, i }(t.VertexAttachment);
    t.MeshAttachment = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function(e) {
        function i(i) { var o = e.call(this, i) || this; return o.closed = !1, o.constantSpeed = !1, o.color = new t.Color(1, 1, 1, 1), o } return __extends(i, e), i }(t.VertexAttachment);
    t.PathAttachment = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function(e) {
        function i(i) { var o = e.call(this, i) || this; return o.color = new t.Color(.38, .94, 0, 1), o } return __extends(i, e), i.prototype.computeWorldPosition = function(t, e) { return e.x = this.x * t.a + this.y * t.b + t.worldX, e.y = this.x * t.c + this.y * t.d + t.worldY, e }, i.prototype.computeWorldRotation = function(e) { var i = t.MathUtils.cosDeg(this.rotation),
                o = t.MathUtils.sinDeg(this.rotation),
                n = i * e.a + o * e.b,
                s = i * e.c + o * e.d; return Math.atan2(s, n) * t.MathUtils.radDeg }, i }(t.VertexAttachment);
    t.PointAttachment = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function(e) {
        function i(i) { var o = e.call(this, i) || this; return o.x = 0, o.y = 0, o.scaleX = 1, o.scaleY = 1, o.rotation = 0, o.width = 0, o.height = 0, o.color = new t.Color(1, 1, 1, 1), o.offset = t.Utils.newFloatArray(8), o.uvs = t.Utils.newFloatArray(8), o.tempColor = new t.Color(1, 1, 1, 1), o } return __extends(i, e), i.prototype.updateOffset = function() { var t = this.width / this.region.originalWidth * this.scaleX,
                e = this.height / this.region.originalHeight * this.scaleY,
                o = -this.width / 2 * this.scaleX + this.region.offsetX * t,
                n = -this.height / 2 * this.scaleY + this.region.offsetY * e,
                s = o + this.region.width * t,
                r = n + this.region.height * e,
                a = this.rotation * Math.PI / 180,
                h = Math.cos(a),
                l = Math.sin(a),
                c = o * h + this.x,
                d = o * l,
                u = n * h + this.y,
                p = n * l,
                m = s * h + this.x,
                f = s * l,
                y = r * h + this.y,
                b = r * l,
                g = this.offset;
            g[i.OX1] = c - p, g[i.OY1] = u + d, g[i.OX2] = c - b, g[i.OY2] = y + d, g[i.OX3] = m - b, g[i.OY3] = y + f, g[i.OX4] = m - p, g[i.OY4] = u + f }, i.prototype.setRegion = function(t) { this.region = t; var e = this.uvs;
            t.rotate ? (e[2] = t.u, e[3] = t.v2, e[4] = t.u, e[5] = t.v, e[6] = t.u2, e[7] = t.v, e[0] = t.u2, e[1] = t.v2) : (e[0] = t.u, e[1] = t.v2, e[2] = t.u, e[3] = t.v, e[4] = t.u2, e[5] = t.v, e[6] = t.u2, e[7] = t.v2) }, i.prototype.computeWorldVertices = function(t, e, o, n) { var s = this.offset,
                r = t.worldX,
                a = t.worldY,
                h = t.a,
                l = t.b,
                c = t.c,
                d = t.d,
                u = 0,
                p = 0;
            u = s[i.OX1], p = s[i.OY1], e[o] = u * h + p * l + r, e[o + 1] = u * c + p * d + a, o += n, u = s[i.OX2], p = s[i.OY2], e[o] = u * h + p * l + r, e[o + 1] = u * c + p * d + a, o += n, u = s[i.OX3], p = s[i.OY3], e[o] = u * h + p * l + r, e[o + 1] = u * c + p * d + a, o += n, u = s[i.OX4], p = s[i.OY4], e[o] = u * h + p * l + r, e[o + 1] = u * c + p * d + a }, i }(t.Attachment);
    e.OX1 = 0, e.OY1 = 1, e.OX2 = 2, e.OY2 = 3, e.OX3 = 4, e.OY3 = 5, e.OX4 = 6, e.OY4 = 7, e.X1 = 0, e.Y1 = 1, e.C1R = 2, e.C1G = 3, e.C1B = 4, e.C1A = 5, e.U1 = 6, e.V1 = 7, e.X2 = 8, e.Y2 = 9, e.C2R = 10, e.C2G = 11, e.C2B = 12, e.C2A = 13, e.U2 = 14, e.V2 = 15, e.X3 = 16, e.Y3 = 17, e.C3R = 18, e.C3G = 19, e.C3B = 20, e.C3A = 21, e.U3 = 22, e.V3 = 23, e.X4 = 24, e.Y4 = 25, e.C4R = 26, e.C4G = 27, e.C4B = 28, e.C4A = 29, e.U4 = 30, e.V4 = 31, t.RegionAttachment = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e(t, e) { this.jitterX = 0, this.jitterY = 0, this.jitterX = t, this.jitterY = e } return e.prototype.begin = function(t) {}, e.prototype.transform = function(e, i, o, n) { e.x += t.MathUtils.randomTriangular(-this.jitterX, this.jitterY), e.y += t.MathUtils.randomTriangular(-this.jitterX, this.jitterY) }, e.prototype.end = function() {}, e }();
    t.JitterEffect = e }(spine || (spine = {}));
var spine;
! function(t) { var e = function() {
        function e(t) { this.centerX = 0, this.centerY = 0, this.radius = 0, this.angle = 0, this.worldX = 0, this.worldY = 0, this.radius = t } return e.prototype.begin = function(t) { this.worldX = t.x + this.centerX, this.worldY = t.y + this.centerY }, e.prototype.transform = function(i, o, n, s) { var r = this.angle * t.MathUtils.degreesToRadians,
                a = i.x - this.worldX,
                h = i.y - this.worldY,
                l = Math.sqrt(a * a + h * h); if (l < this.radius) { var c = e.interpolation.apply(0, r, (this.radius - l) / this.radius),
                    d = Math.cos(c),
                    u = Math.sin(c);
                i.x = d * a - u * h + this.worldX, i.y = u * a + d * h + this.worldY } }, e.prototype.end = function() {}, e }();
    e.interpolation = new t.PowOut(2), t.SwirlEffect = e }(spine || (spine = {}));
var spine;
! function(t) {! function(e) { var i = function(e) {
            function i(i, o) { return void 0 === o && (o = ""), e.call(this, function(e) { return new t.webgl.GLTexture(i, e) }, o) || this } return __extends(i, e), i }(t.AssetManager);
        e.AssetManager = i }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(t) { var e = function() {
            function e(e, i) { this.position = new t.Vector3(0, 0, 0), this.direction = new t.Vector3(0, 0, -1), this.up = new t.Vector3(0, 1, 0), this.near = 0, this.far = 100, this.zoom = 1, this.viewportWidth = 0, this.viewportHeight = 0, this.projectionView = new t.Matrix4, this.inverseProjectionView = new t.Matrix4, this.projection = new t.Matrix4, this.view = new t.Matrix4, this.tmp = new t.Vector3, this.viewportWidth = e, this.viewportHeight = i, this.update() } return e.prototype.update = function() { var t = this.projection,
                    e = this.view,
                    i = this.projectionView,
                    o = this.inverseProjectionView,
                    n = this.zoom,
                    s = this.viewportWidth,
                    r = this.viewportHeight;
                t.ortho(n * (-s / 2), n * (s / 2), n * (-r / 2), n * (r / 2), this.near, this.far), e.lookAt(this.position, this.direction, this.up), i.set(t.values), i.multiply(e), o.set(i.values).invert() }, e.prototype.screenToWorld = function(t, e, i) { var o = t.x,
                    n = i - t.y - 1,
                    s = this.tmp; return s.x = 2 * o / e - 1, s.y = 2 * n / i - 1, s.z = 2 * t.z - 1, s.project(this.inverseProjectionView), t.set(s.x, s.y, s.z), t }, e.prototype.setViewport = function(t, e) { this.viewportWidth = t, this.viewportHeight = e }, e }();
        t.OrthoCamera = e }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(e) { var i = function(t) {
            function i(i, o, n) { void 0 === n && (n = !1); var s = t.call(this, o) || this; return s.texture = null, s.boundUnit = 0, s.useMipMaps = !1, s.context = i instanceof e.ManagedWebGLRenderingContext ? i : new e.ManagedWebGLRenderingContext(i), s.useMipMaps = n, s.restore(), s.context.addRestorable(s), s } return __extends(i, t), i.prototype.setFilters = function(t, e) { var i = this.context.gl;
                this.bind(), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, e) }, i.prototype.setWraps = function(t, e) { var i = this.context.gl;
                this.bind(), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, e) }, i.prototype.update = function(t) { var e = this.context.gl;
                this.texture || (this.texture = this.context.gl.createTexture()), this.bind(), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, this._image), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t ? e.LINEAR_MIPMAP_LINEAR : e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), t && e.generateMipmap(e.TEXTURE_2D) }, i.prototype.restore = function() { this.texture = null, this.update(this.useMipMaps) }, i.prototype.bind = function(t) { void 0 === t && (t = 0); var e = this.context.gl;
                this.boundUnit = t, e.activeTexture(e.TEXTURE0 + t), e.bindTexture(e.TEXTURE_2D, this.texture) }, i.prototype.unbind = function() { var t = this.context.gl;
                t.activeTexture(t.TEXTURE0 + this.boundUnit), t.bindTexture(t.TEXTURE_2D, null) }, i.prototype.dispose = function() { this.context.removeRestorable(this), this.context.gl.deleteTexture(this.texture) }, i }(t.Texture);
        e.GLTexture = i }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(e) { var i = function() {
            function e(e) { this.lastX = 0, this.lastY = 0, this.buttonDown = !1, this.currTouch = null, this.touchesPool = new t.Pool(function() { return new t.webgl.Touch(0, 0, 0) }), this.listeners = new Array, this.element = e, this.setupCallbacks(e) } return e.prototype.setupCallbacks = function(t) { var e = this;
                t.addEventListener("mousedown", function(i) { if (i instanceof MouseEvent) { for (var o = t.getBoundingClientRect(), n = i.clientX - o.left, s = i.clientY - o.top, r = e.listeners, a = 0; a < r.length; a++) r[a].down(n, s);
                        e.lastX = n, e.lastY = s, e.buttonDown = !0 } }, !0), t.addEventListener("mousemove", function(i) { if (i instanceof MouseEvent) { for (var o = t.getBoundingClientRect(), n = i.clientX - o.left, s = i.clientY - o.top, r = e.listeners, a = 0; a < r.length; a++) e.buttonDown ? r[a].dragged(n, s) : r[a].moved(n, s);
                        e.lastX = n, e.lastY = s } }, !0), t.addEventListener("mouseup", function(i) { if (i instanceof MouseEvent) { for (var o = t.getBoundingClientRect(), n = i.clientX - o.left, s = i.clientY - o.top, r = e.listeners, a = 0; a < r.length; a++) r[a].up(n, s);
                        e.lastX = n, e.lastY = s, e.buttonDown = !1 } }, !0), t.addEventListener("touchstart", function(i) { if (null == e.currTouch) { for (var o = i.changedTouches, n = 0; n < o.length; n++) { var s = o[n],
                                r = t.getBoundingClientRect(),
                                a = s.clientX - r.left,
                                h = s.clientY - r.top;
                            e.currTouch = e.touchesPool.obtain(), e.currTouch.identifier = s.identifier, e.currTouch.x = a, e.currTouch.y = h; break } for (var l = e.listeners, c = 0; c < l.length; c++) l[c].down(e.currTouch.x, e.currTouch.y);
                        e.lastX = e.currTouch.x, e.lastY = e.currTouch.y, e.buttonDown = !0, i.preventDefault() } }, !1), t.addEventListener("touchend", function(i) { for (var o = i.changedTouches, n = 0; n < o.length; n++) { var s = o[n]; if (e.currTouch.identifier === s.identifier) { var r = t.getBoundingClientRect(),
                                a = e.currTouch.x = s.clientX - r.left,
                                h = e.currTouch.y = s.clientY - r.top;
                            e.touchesPool.free(e.currTouch); for (var l = e.listeners, c = 0; c < l.length; c++) l[c].up(a, h);
                            e.lastX = a, e.lastY = h, e.buttonDown = !1, e.currTouch = null; break } } i.preventDefault() }, !1), t.addEventListener("touchcancel", function(i) { for (var o = i.changedTouches, n = 0; n < o.length; n++) { var s = o[n]; if (e.currTouch.identifier === s.identifier) { var r = t.getBoundingClientRect(),
                                a = e.currTouch.x = s.clientX - r.left,
                                h = e.currTouch.y = s.clientY - r.top;
                            e.touchesPool.free(e.currTouch); for (var l = e.listeners, c = 0; c < l.length; c++) l[c].up(a, h);
                            e.lastX = a, e.lastY = h, e.buttonDown = !1, e.currTouch = null; break } } i.preventDefault() }, !1), t.addEventListener("touchmove", function(i) { if (null != e.currTouch) { for (var o = i.changedTouches, n = 0; n < o.length; n++) { var s = o[n]; if (e.currTouch.identifier === s.identifier) { for (var r = t.getBoundingClientRect(), a = s.clientX - r.left, h = s.clientY - r.top, l = e.listeners, c = 0; c < l.length; c++) l[c].dragged(a, h);
                                e.lastX = e.currTouch.x = a, e.lastY = e.currTouch.y = h; break } } i.preventDefault() } }, !1) }, e.prototype.addListener = function(t) { this.listeners.push(t) }, e.prototype.removeListener = function(t) { var e = this.listeners.indexOf(t);
                e > -1 && this.listeners.splice(e, 1) }, e }();
        e.Input = i; var o = function() { return function(t, e, i) { this.identifier = t, this.x = e, this.y = i } }();
        e.Touch = o }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(e) { var i = function() {
            function i(e) { if (this.logo = null, this.spinner = null, this.angle = 0, this.fadeOut = 0, this.timeKeeper = new t.TimeKeeper, this.backgroundColor = new t.Color(.135, .135, .135, 1), this.tempColor = new t.Color, this.firstDraw = 0, this.renderer = e, this.timeKeeper.maxDelta = 9, null === i.logoImg) { var o = navigator.userAgent.indexOf("Safari") > -1;
                    i.logoImg = new Image, i.logoImg.src = i.SPINE_LOGO_DATA, o || (i.logoImg.crossOrigin = "anonymous"), i.logoImg.onload = function(t) { i.loaded++ }, i.spinnerImg = new Image, i.spinnerImg.src = i.SPINNER_DATA, o || (i.spinnerImg.crossOrigin = "anonymous"), i.spinnerImg.onload = function(t) { i.loaded++ } } } return i.prototype.draw = function(t) { if (void 0 === t && (t = !1), !(t && this.fadeOut > i.FADE_SECONDS)) { this.timeKeeper.update(); var o = Math.abs(Math.sin(this.timeKeeper.totalTime + .75));
                    this.angle -= 360 * this.timeKeeper.delta * (1 + 1.5 * Math.pow(o, 5)); var n = this.renderer,
                        s = n.canvas,
                        r = n.context.gl,
                        a = n.camera.position.x,
                        h = n.camera.position.y; if (n.camera.position.set(s.width / 2, s.height / 2, 0), n.camera.viewportWidth = s.width, n.camera.viewportHeight = s.height, n.resize(e.ResizeMode.Stretch), t) { if (this.fadeOut += this.timeKeeper.delta * (this.timeKeeper.totalTime < 1 ? 2 : 1), this.fadeOut > i.FADE_SECONDS) return void n.camera.position.set(a, h, 0);
                        o = 1 - this.fadeOut / i.FADE_SECONDS, this.tempColor.setFromColor(this.backgroundColor), this.tempColor.a = 1 - (o - 1) * (o - 1), n.begin(), n.quad(!0, 0, 0, s.width, 0, s.width, s.height, 0, s.height, this.tempColor, this.tempColor, this.tempColor, this.tempColor), n.end() } else r.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a), r.clear(r.COLOR_BUFFER_BIT), this.tempColor.a = 1; if (this.tempColor.set(1, 1, 1, this.tempColor.a), 2 == i.loaded) { null === this.logo && (this.logo = new e.GLTexture(n.context, i.logoImg), this.spinner = new e.GLTexture(n.context, i.spinnerImg)), this.logo.update(!1), this.spinner.update(!1); var l = this.logo.getImage().width,
                            c = this.logo.getImage().height,
                            d = this.spinner.getImage().width,
                            u = this.spinner.getImage().height;
                        n.batcher.setBlendMode(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA), n.begin(), n.drawTexture(this.logo, (s.width - l) / 2, (s.height - c) / 2, l, c, this.tempColor), n.drawTextureRotated(this.spinner, (s.width - d) / 2, (s.height - u) / 2, d, u, d / 2, u / 2, this.angle, this.tempColor), n.end(), n.camera.position.set(a, h, 0) } } }, i }();
        i.FADE_SECONDS = 1, i.loaded = 0, i.spinnerImg = null, i.logoImg = null, i.SPINNER_DATA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAChCAMAAAB3TUS6AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAYNQTFRFAAAA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AA/0AAkTDRyAAAAIB0Uk5TAAABAgMEBQYHCAkKCwwODxAREhMUFRYXGBkaHB0eICEiIyQlJicoKSorLC0uLzAxMjM0Nzg5Ojs8PT4/QEFDRUlKS0xNTk9QUlRWWFlbXF1eYWJjZmhscHF0d3h5e3x+f4CIiYuMj5GSlJWXm56io6arr7rAxcjO0dXe6Onr8fmb5sOOAAADuElEQVQYGe3B+3vTVBwH4M/3nCRt13br2Lozhug2q25gYQubcxqVKYoMCYoKjEsUdSpeiBc0Kl7yp9t2za39pely7PF5zvuiQKc+/e2f8K+f9g2oyQ77Ag4VGX+HketQ0XYYe0JQ0CdhogwF+WFiBgr6JkxUoKCDMMGgoP0w9gdUtB3GfoCKVsPYAVQ0H8YuQUWVMHYGKuJhrAklPQkjJpT0bdj3O9S0FfZ9ADXxP8MjVSiqFfa8B2VVV8+df14QtB4iwn+BpuZEgyM38WMQHDYhnbkgukrIh5ygZ48glyn6KshlL+jbhVRcxCzk0ApiC5CI5kVsgTAy9jiI/WxBGmqIFBMjqwYphwRZaiLNwsjqQdoVSFISGRwjM4OMFUjBRcYCYWT0XZD2SwUS0LzIKCGH2SDja0LxKiJjCrm0gowVFI6aIs1CTouPg5QvUTgSKXMMuVUeBSmEopFITBPGwO8HCYbCTYtImTAWejuI3CMUjmZFT5NjbM/9GvQcMkhADdFRIxxD7aug4wGDFGSVTcLx0MzutQ2CpmmapmmapmmapmmapmmaphWBmGFV6rNNcaLC0GUuv3LROftUo8wJk0a10207sVED6IIf+9673LIwQeW2PaCEJX/A+xYmhTbtQUu46g96SJgQZg9Zwxf+EAMTwuwhm3jkD7EwIdweBn+YhQlh9pA2HvpDTEwIs4es4GN/CMekNOxBJ9D2B10nTAyfW7fT1hjYgZ/xYIUwUcycaiwuv2h3tOcZADr7ud/12c0ru2cWSwQ1UAcixIgImqZpmqZpmqZpmqZpmqZp2v8HMSIcF186t8oghbnlOJt1wnHwl7yOGxwSlHacrjWG8dVuej03OApn7jhHtiyMiZa9yD6haLYTebWOsbDXvQRHwchJWSTkV/rQS+EoWttJaTHkJe56KXcJRZt20jY48nnBy9hE4WjLSbvAkIfwMm5zFG/KyWgRRke3vYwGZDjpZHCMruJltCAFrTtpVYxu1ktzCHKwbSdlGqOreynXGGQpOylljI5uebFbBuSZc2IbhBxmvcj9GiSiZ52+HQO5nPb6TkIqajs9L5eQk7jnddxZgGT0jNOxYSI36+Kdj9oG5OPV6QpB6yJuGAYnqIrecLveYlDUKffIOtREl90+BiWV3cgMlNR0I09DSS030oaSttzILpT0phu5BBWRmyAoiLkJgoIMN8GgoJKb4FBQzU0YUFDdTRhQUNVNcCjIdBMEBdE7buQ8lFRz+97lUFN5fe+qu//aMkeB/gU2ae9y2HgbngAAAABJRU5ErkJggg==", i.SPINE_LOGO_DATA = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFIAAAAZCAYAAACis3k0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAtNJREFUaN7tmT2I1EAUxwN+oWgRT0HFKo0WCkJ6ObmAWFwZbCxsXGysLNJaiCyIoDaSwk4ETzvhmnBaCRbBWoQ01ho4PwotjP8cE337mMy8TLK757mBH3fLTWbe/PbN53neNniqZW8FvAVvQAqugwvgDDgO9niLRyTyJagM/ACPF6bsIl9ZRDac/Cc6tLn5xQdRQ496QlKPLxD5QCDxO9jtGM8QfYoIgUlgCipGCRJL5VvlyOdCU09iEXkCfLSIfCrs7Fab6nOsiafu06iDwES9w/uU1QnDC+ekkVS9vEaDsgVeB0d+z1VDtOGxRaYPboP3Gokb4GgXkZp4chZPJKgvZ3U0XkriK/TIt9YUDllFgTAjGwoaoHqfBhMI58yD4BQ4V6/aHYdfxToftvw9F2SiVroawU2/Cv5C4Thv0KB9S5nxlOd4STxjwUjzSdYlgrYijw2BsEfgsaFcM09lhiys94xXQQwugcvgJrgFLjrEE7WUiTuWCQzt/ZXN7FfqGwuGClyVy2xZAFmfDQvNtwFFSspMDGsD+UTWqu1KoVmVooFEJgKRXw0if85RpISEzwsjzeqWzkjkC4PIJ3MUmQgITAHlQwTFhnZhELkEntfZRwR+AvfAgXmJHOqU02XligWT8ppg67NXbdCXeq7afUQ6L8C2DalEZNt2YyQ94Qy8/ekjMpBMbfyl5iTjG7YAI8cNecROAb4kJmTjaXAF3AGvwQewOiuRxEtlSaT4j2h2lMsUueQEoMlIKpTvAmKhxPMtC876jEX6rE8l8TNx/KVbn6xlWU9NWcSDUsO4NGWpQOTZFpHPOooMXcswmW2XFk3ixb2v0Nq+XVKP00QNaffBLyWwBI/AkTlfMYZDXMf12kc6yjwEjoFdO/5me5oi/6tnyhlZX6OtgmX1c2Uh0k3khmbB2b9TRfpd/jfTUeRDJvHdYg5wE7kPXAN3wQ1weDvH+xufEgpi5qIl3QAAAABJRU5ErkJggg==", e.LoadingScreen = i }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(t) { t.M00 = 0, t.M01 = 4, t.M02 = 8, t.M03 = 12, t.M10 = 1, t.M11 = 5, t.M12 = 9, t.M13 = 13, t.M20 = 2, t.M21 = 6, t.M22 = 10, t.M23 = 14, t.M30 = 3, t.M31 = 7, t.M32 = 11, t.M33 = 15; var e = function() {
            function e() { this.temp = new Float32Array(16), this.values = new Float32Array(16); var e = this.values;
                e[t.M00] = 1, e[t.M11] = 1, e[t.M22] = 1, e[t.M33] = 1 } return e.prototype.set = function(t) { return this.values.set(t), this }, e.prototype.transpose = function() { var e = this.temp,
                    i = this.values; return e[t.M00] = i[t.M00], e[t.M01] = i[t.M10], e[t.M02] = i[t.M20], e[t.M03] = i[t.M30], e[t.M10] = i[t.M01], e[t.M11] = i[t.M11], e[t.M12] = i[t.M21], e[t.M13] = i[t.M31], e[t.M20] = i[t.M02], e[t.M21] = i[t.M12], e[t.M22] = i[t.M22], e[t.M23] = i[t.M32], e[t.M30] = i[t.M03], e[t.M31] = i[t.M13], e[t.M32] = i[t.M23], e[t.M33] = i[t.M33], this.set(e) }, e.prototype.identity = function() { var e = this.values; return e[t.M00] = 1, e[t.M01] = 0, e[t.M02] = 0, e[t.M03] = 0, e[t.M10] = 0, e[t.M11] = 1, e[t.M12] = 0, e[t.M13] = 0, e[t.M20] = 0, e[t.M21] = 0, e[t.M22] = 1, e[t.M23] = 0, e[t.M30] = 0, e[t.M31] = 0, e[t.M32] = 0, e[t.M33] = 1, this }, e.prototype.invert = function() { var e = this.values,
                    i = this.temp,
                    o = e[t.M30] * e[t.M21] * e[t.M12] * e[t.M03] - e[t.M20] * e[t.M31] * e[t.M12] * e[t.M03] - e[t.M30] * e[t.M11] * e[t.M22] * e[t.M03] + e[t.M10] * e[t.M31] * e[t.M22] * e[t.M03] + e[t.M20] * e[t.M11] * e[t.M32] * e[t.M03] - e[t.M10] * e[t.M21] * e[t.M32] * e[t.M03] - e[t.M30] * e[t.M21] * e[t.M02] * e[t.M13] + e[t.M20] * e[t.M31] * e[t.M02] * e[t.M13] + e[t.M30] * e[t.M01] * e[t.M22] * e[t.M13] - e[t.M00] * e[t.M31] * e[t.M22] * e[t.M13] - e[t.M20] * e[t.M01] * e[t.M32] * e[t.M13] + e[t.M00] * e[t.M21] * e[t.M32] * e[t.M13] + e[t.M30] * e[t.M11] * e[t.M02] * e[t.M23] - e[t.M10] * e[t.M31] * e[t.M02] * e[t.M23] - e[t.M30] * e[t.M01] * e[t.M12] * e[t.M23] + e[t.M00] * e[t.M31] * e[t.M12] * e[t.M23] + e[t.M10] * e[t.M01] * e[t.M32] * e[t.M23] - e[t.M00] * e[t.M11] * e[t.M32] * e[t.M23] - e[t.M20] * e[t.M11] * e[t.M02] * e[t.M33] + e[t.M10] * e[t.M21] * e[t.M02] * e[t.M33] + e[t.M20] * e[t.M01] * e[t.M12] * e[t.M33] - e[t.M00] * e[t.M21] * e[t.M12] * e[t.M33] - e[t.M10] * e[t.M01] * e[t.M22] * e[t.M33] + e[t.M00] * e[t.M11] * e[t.M22] * e[t.M33]; if (0 == o) throw new Error("non-invertible matrix"); var n = 1 / o; return i[t.M00] = e[t.M12] * e[t.M23] * e[t.M31] - e[t.M13] * e[t.M22] * e[t.M31] + e[t.M13] * e[t.M21] * e[t.M32] - e[t.M11] * e[t.M23] * e[t.M32] - e[t.M12] * e[t.M21] * e[t.M33] + e[t.M11] * e[t.M22] * e[t.M33], i[t.M01] = e[t.M03] * e[t.M22] * e[t.M31] - e[t.M02] * e[t.M23] * e[t.M31] - e[t.M03] * e[t.M21] * e[t.M32] + e[t.M01] * e[t.M23] * e[t.M32] + e[t.M02] * e[t.M21] * e[t.M33] - e[t.M01] * e[t.M22] * e[t.M33], i[t.M02] = e[t.M02] * e[t.M13] * e[t.M31] - e[t.M03] * e[t.M12] * e[t.M31] + e[t.M03] * e[t.M11] * e[t.M32] - e[t.M01] * e[t.M13] * e[t.M32] - e[t.M02] * e[t.M11] * e[t.M33] + e[t.M01] * e[t.M12] * e[t.M33], i[t.M03] = e[t.M03] * e[t.M12] * e[t.M21] - e[t.M02] * e[t.M13] * e[t.M21] - e[t.M03] * e[t.M11] * e[t.M22] + e[t.M01] * e[t.M13] * e[t.M22] + e[t.M02] * e[t.M11] * e[t.M23] - e[t.M01] * e[t.M12] * e[t.M23], i[t.M10] = e[t.M13] * e[t.M22] * e[t.M30] - e[t.M12] * e[t.M23] * e[t.M30] - e[t.M13] * e[t.M20] * e[t.M32] + e[t.M10] * e[t.M23] * e[t.M32] + e[t.M12] * e[t.M20] * e[t.M33] - e[t.M10] * e[t.M22] * e[t.M33], i[t.M11] = e[t.M02] * e[t.M23] * e[t.M30] - e[t.M03] * e[t.M22] * e[t.M30] + e[t.M03] * e[t.M20] * e[t.M32] - e[t.M00] * e[t.M23] * e[t.M32] - e[t.M02] * e[t.M20] * e[t.M33] + e[t.M00] * e[t.M22] * e[t.M33], i[t.M12] = e[t.M03] * e[t.M12] * e[t.M30] - e[t.M02] * e[t.M13] * e[t.M30] - e[t.M03] * e[t.M10] * e[t.M32] + e[t.M00] * e[t.M13] * e[t.M32] + e[t.M02] * e[t.M10] * e[t.M33] - e[t.M00] * e[t.M12] * e[t.M33], i[t.M13] = e[t.M02] * e[t.M13] * e[t.M20] - e[t.M03] * e[t.M12] * e[t.M20] + e[t.M03] * e[t.M10] * e[t.M22] - e[t.M00] * e[t.M13] * e[t.M22] - e[t.M02] * e[t.M10] * e[t.M23] + e[t.M00] * e[t.M12] * e[t.M23], i[t.M20] = e[t.M11] * e[t.M23] * e[t.M30] - e[t.M13] * e[t.M21] * e[t.M30] + e[t.M13] * e[t.M20] * e[t.M31] - e[t.M10] * e[t.M23] * e[t.M31] - e[t.M11] * e[t.M20] * e[t.M33] + e[t.M10] * e[t.M21] * e[t.M33], i[t.M21] = e[t.M03] * e[t.M21] * e[t.M30] - e[t.M01] * e[t.M23] * e[t.M30] - e[t.M03] * e[t.M20] * e[t.M31] + e[t.M00] * e[t.M23] * e[t.M31] + e[t.M01] * e[t.M20] * e[t.M33] - e[t.M00] * e[t.M21] * e[t.M33], i[t.M22] = e[t.M01] * e[t.M13] * e[t.M30] - e[t.M03] * e[t.M11] * e[t.M30] + e[t.M03] * e[t.M10] * e[t.M31] - e[t.M00] * e[t.M13] * e[t.M31] - e[t.M01] * e[t.M10] * e[t.M33] + e[t.M00] * e[t.M11] * e[t.M33], i[t.M23] = e[t.M03] * e[t.M11] * e[t.M20] - e[t.M01] * e[t.M13] * e[t.M20] - e[t.M03] * e[t.M10] * e[t.M21] + e[t.M00] * e[t.M13] * e[t.M21] + e[t.M01] * e[t.M10] * e[t.M23] - e[t.M00] * e[t.M11] * e[t.M23], i[t.M30] = e[t.M12] * e[t.M21] * e[t.M30] - e[t.M11] * e[t.M22] * e[t.M30] - e[t.M12] * e[t.M20] * e[t.M31] + e[t.M10] * e[t.M22] * e[t.M31] + e[t.M11] * e[t.M20] * e[t.M32] - e[t.M10] * e[t.M21] * e[t.M32], i[t.M31] = e[t.M01] * e[t.M22] * e[t.M30] - e[t.M02] * e[t.M21] * e[t.M30] + e[t.M02] * e[t.M20] * e[t.M31] - e[t.M00] * e[t.M22] * e[t.M31] - e[t.M01] * e[t.M20] * e[t.M32] + e[t.M00] * e[t.M21] * e[t.M32], i[t.M32] = e[t.M02] * e[t.M11] * e[t.M30] - e[t.M01] * e[t.M12] * e[t.M30] - e[t.M02] * e[t.M10] * e[t.M31] + e[t.M00] * e[t.M12] * e[t.M31] + e[t.M01] * e[t.M10] * e[t.M32] - e[t.M00] * e[t.M11] * e[t.M32], i[t.M33] = e[t.M01] * e[t.M12] * e[t.M20] - e[t.M02] * e[t.M11] * e[t.M20] + e[t.M02] * e[t.M10] * e[t.M21] - e[t.M00] * e[t.M12] * e[t.M21] - e[t.M01] * e[t.M10] * e[t.M22] + e[t.M00] * e[t.M11] * e[t.M22], e[t.M00] = i[t.M00] * n, e[t.M01] = i[t.M01] * n, e[t.M02] = i[t.M02] * n, e[t.M03] = i[t.M03] * n, e[t.M10] = i[t.M10] * n, e[t.M11] = i[t.M11] * n, e[t.M12] = i[t.M12] * n, e[t.M13] = i[t.M13] * n, e[t.M20] = i[t.M20] * n, e[t.M21] = i[t.M21] * n, e[t.M22] = i[t.M22] * n, e[t.M23] = i[t.M23] * n, e[t.M30] = i[t.M30] * n, e[t.M31] = i[t.M31] * n, e[t.M32] = i[t.M32] * n, e[t.M33] = i[t.M33] * n, this }, e.prototype.determinant = function() { var e = this.values; return e[t.M30] * e[t.M21] * e[t.M12] * e[t.M03] - e[t.M20] * e[t.M31] * e[t.M12] * e[t.M03] - e[t.M30] * e[t.M11] * e[t.M22] * e[t.M03] + e[t.M10] * e[t.M31] * e[t.M22] * e[t.M03] + e[t.M20] * e[t.M11] * e[t.M32] * e[t.M03] - e[t.M10] * e[t.M21] * e[t.M32] * e[t.M03] - e[t.M30] * e[t.M21] * e[t.M02] * e[t.M13] + e[t.M20] * e[t.M31] * e[t.M02] * e[t.M13] + e[t.M30] * e[t.M01] * e[t.M22] * e[t.M13] - e[t.M00] * e[t.M31] * e[t.M22] * e[t.M13] - e[t.M20] * e[t.M01] * e[t.M32] * e[t.M13] + e[t.M00] * e[t.M21] * e[t.M32] * e[t.M13] + e[t.M30] * e[t.M11] * e[t.M02] * e[t.M23] - e[t.M10] * e[t.M31] * e[t.M02] * e[t.M23] - e[t.M30] * e[t.M01] * e[t.M12] * e[t.M23] + e[t.M00] * e[t.M31] * e[t.M12] * e[t.M23] + e[t.M10] * e[t.M01] * e[t.M32] * e[t.M23] - e[t.M00] * e[t.M11] * e[t.M32] * e[t.M23] - e[t.M20] * e[t.M11] * e[t.M02] * e[t.M33] + e[t.M10] * e[t.M21] * e[t.M02] * e[t.M33] + e[t.M20] * e[t.M01] * e[t.M12] * e[t.M33] - e[t.M00] * e[t.M21] * e[t.M12] * e[t.M33] - e[t.M10] * e[t.M01] * e[t.M22] * e[t.M33] + e[t.M00] * e[t.M11] * e[t.M22] * e[t.M33] }, e.prototype.translate = function(e, i, o) { var n = this.values; return n[t.M03] += e, n[t.M13] += i, n[t.M23] += o, this }, e.prototype.copy = function() { return (new e).set(this.values) }, e.prototype.projection = function(e, i, o, n) { this.identity(); var s = 1 / Math.tan(o * (Math.PI / 180) / 2),
                    r = (i + e) / (e - i),
                    a = 2 * i * e / (e - i),
                    h = this.values; return h[t.M00] = s / n, h[t.M10] = 0, h[t.M20] = 0, h[t.M30] = 0, h[t.M01] = 0, h[t.M11] = s, h[t.M21] = 0, h[t.M31] = 0, h[t.M02] = 0, h[t.M12] = 0, h[t.M22] = r, h[t.M32] = -1, h[t.M03] = 0, h[t.M13] = 0, h[t.M23] = a, h[t.M33] = 0, this }, e.prototype.ortho2d = function(t, e, i, o) { return this.ortho(t, t + i, e, e + o, 0, 1) }, e.prototype.ortho = function(e, i, o, n, s, r) { this.identity(); var a = 2 / (i - e),
                    h = 2 / (n - o),
                    l = -2 / (r - s),
                    c = -(i + e) / (i - e),
                    d = -(n + o) / (n - o),
                    u = -(r + s) / (r - s),
                    p = this.values; return p[t.M00] = a, p[t.M10] = 0, p[t.M20] = 0, p[t.M30] = 0, p[t.M01] = 0, p[t.M11] = h, p[t.M21] = 0, p[t.M31] = 0, p[t.M02] = 0, p[t.M12] = 0, p[t.M22] = l, p[t.M32] = 0, p[t.M03] = c, p[t.M13] = d, p[t.M23] = u, p[t.M33] = 1, this }, e.prototype.multiply = function(e) { var i = this.temp,
                    o = this.values,
                    n = e.values; return i[t.M00] = o[t.M00] * n[t.M00] + o[t.M01] * n[t.M10] + o[t.M02] * n[t.M20] + o[t.M03] * n[t.M30], i[t.M01] = o[t.M00] * n[t.M01] + o[t.M01] * n[t.M11] + o[t.M02] * n[t.M21] + o[t.M03] * n[t.M31], i[t.M02] = o[t.M00] * n[t.M02] + o[t.M01] * n[t.M12] + o[t.M02] * n[t.M22] + o[t.M03] * n[t.M32], i[t.M03] = o[t.M00] * n[t.M03] + o[t.M01] * n[t.M13] + o[t.M02] * n[t.M23] + o[t.M03] * n[t.M33], i[t.M10] = o[t.M10] * n[t.M00] + o[t.M11] * n[t.M10] + o[t.M12] * n[t.M20] + o[t.M13] * n[t.M30], i[t.M11] = o[t.M10] * n[t.M01] + o[t.M11] * n[t.M11] + o[t.M12] * n[t.M21] + o[t.M13] * n[t.M31], i[t.M12] = o[t.M10] * n[t.M02] + o[t.M11] * n[t.M12] + o[t.M12] * n[t.M22] + o[t.M13] * n[t.M32], i[t.M13] = o[t.M10] * n[t.M03] + o[t.M11] * n[t.M13] + o[t.M12] * n[t.M23] + o[t.M13] * n[t.M33], i[t.M20] = o[t.M20] * n[t.M00] + o[t.M21] * n[t.M10] + o[t.M22] * n[t.M20] + o[t.M23] * n[t.M30], i[t.M21] = o[t.M20] * n[t.M01] + o[t.M21] * n[t.M11] + o[t.M22] * n[t.M21] + o[t.M23] * n[t.M31], i[t.M22] = o[t.M20] * n[t.M02] + o[t.M21] * n[t.M12] + o[t.M22] * n[t.M22] + o[t.M23] * n[t.M32], i[t.M23] = o[t.M20] * n[t.M03] + o[t.M21] * n[t.M13] + o[t.M22] * n[t.M23] + o[t.M23] * n[t.M33], i[t.M30] = o[t.M30] * n[t.M00] + o[t.M31] * n[t.M10] + o[t.M32] * n[t.M20] + o[t.M33] * n[t.M30], i[t.M31] = o[t.M30] * n[t.M01] + o[t.M31] * n[t.M11] + o[t.M32] * n[t.M21] + o[t.M33] * n[t.M31], i[t.M32] = o[t.M30] * n[t.M02] + o[t.M31] * n[t.M12] + o[t.M32] * n[t.M22] + o[t.M33] * n[t.M32], i[t.M33] = o[t.M30] * n[t.M03] + o[t.M31] * n[t.M13] + o[t.M32] * n[t.M23] + o[t.M33] * n[t.M33], this.set(this.temp) }, e.prototype.multiplyLeft = function(e) { var i = this.temp,
                    o = this.values,
                    n = e.values; return i[t.M00] = n[t.M00] * o[t.M00] + n[t.M01] * o[t.M10] + n[t.M02] * o[t.M20] + n[t.M03] * o[t.M30], i[t.M01] = n[t.M00] * o[t.M01] + n[t.M01] * o[t.M11] + n[t.M02] * o[t.M21] + n[t.M03] * o[t.M31], i[t.M02] = n[t.M00] * o[t.M02] + n[t.M01] * o[t.M12] + n[t.M02] * o[t.M22] + n[t.M03] * o[t.M32], i[t.M03] = n[t.M00] * o[t.M03] + n[t.M01] * o[t.M13] + n[t.M02] * o[t.M23] + n[t.M03] * o[t.M33], i[t.M10] = n[t.M10] * o[t.M00] + n[t.M11] * o[t.M10] + n[t.M12] * o[t.M20] + n[t.M13] * o[t.M30], i[t.M11] = n[t.M10] * o[t.M01] + n[t.M11] * o[t.M11] + n[t.M12] * o[t.M21] + n[t.M13] * o[t.M31], i[t.M12] = n[t.M10] * o[t.M02] + n[t.M11] * o[t.M12] + n[t.M12] * o[t.M22] + n[t.M13] * o[t.M32], i[t.M13] = n[t.M10] * o[t.M03] + n[t.M11] * o[t.M13] + n[t.M12] * o[t.M23] + n[t.M13] * o[t.M33], i[t.M20] = n[t.M20] * o[t.M00] + n[t.M21] * o[t.M10] + n[t.M22] * o[t.M20] + n[t.M23] * o[t.M30], i[t.M21] = n[t.M20] * o[t.M01] + n[t.M21] * o[t.M11] + n[t.M22] * o[t.M21] + n[t.M23] * o[t.M31], i[t.M22] = n[t.M20] * o[t.M02] + n[t.M21] * o[t.M12] + n[t.M22] * o[t.M22] + n[t.M23] * o[t.M32], i[t.M23] = n[t.M20] * o[t.M03] + n[t.M21] * o[t.M13] + n[t.M22] * o[t.M23] + n[t.M23] * o[t.M33], i[t.M30] = n[t.M30] * o[t.M00] + n[t.M31] * o[t.M10] + n[t.M32] * o[t.M20] + n[t.M33] * o[t.M30], i[t.M31] = n[t.M30] * o[t.M01] + n[t.M31] * o[t.M11] + n[t.M32] * o[t.M21] + n[t.M33] * o[t.M31], i[t.M32] = n[t.M30] * o[t.M02] + n[t.M31] * o[t.M12] + n[t.M32] * o[t.M22] + n[t.M33] * o[t.M32], i[t.M33] = n[t.M30] * o[t.M03] + n[t.M31] * o[t.M13] + n[t.M32] * o[t.M23] + n[t.M33] * o[t.M33], this.set(this.temp) }, e.prototype.lookAt = function(i, o, n) { e.initTemps(); var s = e.xAxis,
                    r = e.yAxis,
                    a = e.zAxis;
                a.setFrom(o).normalize(), s.setFrom(o).normalize(), s.cross(n).normalize(), r.setFrom(s).cross(a).normalize(), this.identity(); var h = this.values; return h[t.M00] = s.x, h[t.M01] = s.y, h[t.M02] = s.z, h[t.M10] = r.x, h[t.M11] = r.y, h[t.M12] = r.z, h[t.M20] = -a.x, h[t.M21] = -a.y, h[t.M22] = -a.z, e.tmpMatrix.identity(), e.tmpMatrix.values[t.M03] = -i.x, e.tmpMatrix.values[t.M13] = -i.y, e.tmpMatrix.values[t.M23] = -i.z, this.multiply(e.tmpMatrix), this }, e.initTemps = function() { null === e.xAxis && (e.xAxis = new t.Vector3), null === e.yAxis && (e.yAxis = new t.Vector3), null === e.zAxis && (e.zAxis = new t.Vector3) }, e }();
        e.xAxis = null, e.yAxis = null, e.zAxis = null, e.tmpMatrix = new e, t.Matrix4 = e }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(t) { var e = function() {
            function e(e, i, o, n) { this.attributes = i, this.verticesLength = 0, this.dirtyVertices = !1, this.indicesLength = 0, this.dirtyIndices = !1, this.elementsPerVertex = 0, this.context = e instanceof t.ManagedWebGLRenderingContext ? e : new t.ManagedWebGLRenderingContext(e), this.elementsPerVertex = 0; for (var s = 0; s < i.length; s++) this.elementsPerVertex += i[s].numElements;
                this.vertices = new Float32Array(o * this.elementsPerVertex), this.indices = new Uint16Array(n), this.context.addRestorable(this) } return e.prototype.getAttributes = function() { return this.attributes }, e.prototype.maxVertices = function() { return this.vertices.length / this.elementsPerVertex }, e.prototype.numVertices = function() { return this.verticesLength / this.elementsPerVertex }, e.prototype.setVerticesLength = function(t) { this.dirtyVertices = !0, this.verticesLength = t }, e.prototype.getVertices = function() { return this.vertices }, e.prototype.maxIndices = function() { return this.indices.length }, e.prototype.numIndices = function() { return this.indicesLength }, e.prototype.setIndicesLength = function(t) { this.dirtyIndices = !0, this.indicesLength = t }, e.prototype.getIndices = function() { return this.indices }, e.prototype.getVertexSizeInFloats = function() { for (var t = 0, e = 0; e < this.attributes.length; e++) t += this.attributes[e].numElements; return t }, e.prototype.setVertices = function(t) { if (this.dirtyVertices = !0, t.length > this.vertices.length) throw Error("Mesh can't store more than " + this.maxVertices() + " vertices");
                this.vertices.set(t, 0), this.verticesLength = t.length }, e.prototype.setIndices = function(t) { if (this.dirtyIndices = !0, t.length > this.indices.length) throw Error("Mesh can't store more than " + this.maxIndices() + " indices");
                this.indices.set(t, 0), this.indicesLength = t.length }, e.prototype.draw = function(t, e) { this.drawWithOffset(t, e, 0, this.indicesLength > 0 ? this.indicesLength : this.verticesLength / this.elementsPerVertex) }, e.prototype.drawWithOffset = function(t, e, i, o) { var n = this.context.gl;
                (this.dirtyVertices || this.dirtyIndices) && this.update(), this.bind(t), this.indicesLength > 0 ? n.drawElements(e, o, n.UNSIGNED_SHORT, 2 * i) : n.drawArrays(e, i, o), this.unbind(t) }, e.prototype.bind = function(t) { var e = this.context.gl;
                e.bindBuffer(e.ARRAY_BUFFER, this.verticesBuffer); for (var i = 0, o = 0; o < this.attributes.length; o++) { var n = this.attributes[o],
                        s = t.getAttributeLocation(n.name);
                    e.enableVertexAttribArray(s), e.vertexAttribPointer(s, n.numElements, e.FLOAT, !1, 4 * this.elementsPerVertex, 4 * i), i += n.numElements } this.indicesLength > 0 && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.indicesBuffer) }, e.prototype.unbind = function(t) { for (var e = this.context.gl, i = 0; i < this.attributes.length; i++) { var o = this.attributes[i],
                        n = t.getAttributeLocation(o.name);
                    e.disableVertexAttribArray(n) } e.bindBuffer(e.ARRAY_BUFFER, null), this.indicesLength > 0 && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null) }, e.prototype.update = function() { var t = this.context.gl;
                this.dirtyVertices && (this.verticesBuffer || (this.verticesBuffer = t.createBuffer()), t.bindBuffer(t.ARRAY_BUFFER, this.verticesBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices.subarray(0, this.verticesLength), t.DYNAMIC_DRAW), this.dirtyVertices = !1), this.dirtyIndices && (this.indicesBuffer || (this.indicesBuffer = t.createBuffer()), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indicesBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices.subarray(0, this.indicesLength), t.DYNAMIC_DRAW), this.dirtyIndices = !1) }, e.prototype.restore = function() { this.verticesBuffer = null, this.indicesBuffer = null, this.update() }, e.prototype.dispose = function() { this.context.removeRestorable(this); var t = this.context.gl;
                t.deleteBuffer(this.verticesBuffer), t.deleteBuffer(this.indicesBuffer) }, e }();
        t.Mesh = e; var i = function() { return function(t, e, i) { this.name = t, this.type = e, this.numElements = i } }();
        t.VertexAttribute = i; var o = function(e) {
            function i() { return e.call(this, t.Shader.POSITION, h.Float, 2) || this } return __extends(i, e), i }(i);
        t.Position2Attribute = o; var n = function(e) {
            function i() { return e.call(this, t.Shader.POSITION, h.Float, 3) || this } return __extends(i, e), i }(i);
        t.Position3Attribute = n; var s = function(e) {
            function i(i) { return void 0 === i && (i = 0), e.call(this, t.Shader.TEXCOORDS + (0 == i ? "" : i), h.Float, 2) || this } return __extends(i, e), i }(i);
        t.TexCoordAttribute = s; var r = function(e) {
            function i() { return e.call(this, t.Shader.COLOR, h.Float, 4) || this } return __extends(i, e), i }(i);
        t.ColorAttribute = r; var a = function(e) {
            function i() { return e.call(this, t.Shader.COLOR2, h.Float, 4) || this } return __extends(i, e), i }(i);
        t.Color2Attribute = a; var h;! function(t) { t[t.Float = 0] = "Float" }(h = t.VertexAttributeType || (t.VertexAttributeType = {})) }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(t) { var e = function() {
            function e(e, i, o) { if (void 0 === i && (i = !0), void 0 === o && (o = 10920), this.isDrawing = !1, this.shader = null, this.lastTexture = null, this.verticesLength = 0, this.indicesLength = 0, o > 10920) throw new Error("Can't have more than 10920 triangles per batch: " + o);
                this.context = e instanceof t.ManagedWebGLRenderingContext ? e : new t.ManagedWebGLRenderingContext(e); var n = i ? [new t.Position2Attribute, new t.ColorAttribute, new t.TexCoordAttribute, new t.Color2Attribute] : [new t.Position2Attribute, new t.ColorAttribute, new t.TexCoordAttribute];
                this.mesh = new t.Mesh(e, n, o, 3 * o), this.srcBlend = this.context.gl.SRC_ALPHA, this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA } return e.prototype.begin = function(t) { var e = this.context.gl; if (this.isDrawing) throw new Error("PolygonBatch is already drawing. Call PolygonBatch.end() before calling PolygonBatch.begin()");
                this.drawCalls = 0, this.shader = t, this.lastTexture = null, this.isDrawing = !0, e.enable(e.BLEND), e.blendFunc(this.srcBlend, this.dstBlend) }, e.prototype.setBlendMode = function(t, e) { var i = this.context.gl;
                this.srcBlend = t, this.dstBlend = e, this.isDrawing && (this.flush(), i.blendFunc(this.srcBlend, this.dstBlend)) }, e.prototype.draw = function(t, e, i) { t != this.lastTexture ? (this.flush(), this.lastTexture = t) : (this.verticesLength + e.length > this.mesh.getVertices().length || this.indicesLength + i.length > this.mesh.getIndices().length) && this.flush(); var o = this.mesh.numVertices();
                this.mesh.getVertices().set(e, this.verticesLength), this.verticesLength += e.length, this.mesh.setVerticesLength(this.verticesLength); for (var n = this.mesh.getIndices(), s = this.indicesLength, r = 0; r < i.length; s++, r++) n[s] = i[r] + o;
                this.indicesLength += i.length, this.mesh.setIndicesLength(this.indicesLength) }, e.prototype.flush = function() { var t = this.context.gl;
                0 != this.verticesLength && (this.lastTexture.bind(), this.mesh.draw(this.shader, t.TRIANGLES), this.verticesLength = 0, this.indicesLength = 0, this.mesh.setVerticesLength(0), this.mesh.setIndicesLength(0), this.drawCalls++) }, e.prototype.end = function() { var t = this.context.gl; if (!this.isDrawing) throw new Error("PolygonBatch is not drawing. Call PolygonBatch.begin() before calling PolygonBatch.end()");
                (this.verticesLength > 0 || this.indicesLength > 0) && this.flush(), this.shader = null, this.lastTexture = null, this.isDrawing = !1, t.disable(t.BLEND) }, e.prototype.getDrawCalls = function() { return this.drawCalls }, e.prototype.dispose = function() { this.mesh.dispose() }, e }();
        t.PolygonBatcher = e }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(e) { var i = function() {
            function i(i, o, n) { void 0 === n && (n = !0), this.twoColorTint = !1, this.activeRenderer = null, this.QUAD = [0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], this.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0], this.WHITE = new t.Color(1, 1, 1, 1), this.canvas = i, this.context = o instanceof e.ManagedWebGLRenderingContext ? o : new e.ManagedWebGLRenderingContext(o), this.twoColorTint = n, this.camera = new e.OrthoCamera(i.width, i.height), this.batcherShader = n ? e.Shader.newTwoColoredTextured(this.context) : e.Shader.newColoredTextured(this.context), this.batcher = new e.PolygonBatcher(this.context, n), this.shapesShader = e.Shader.newColored(this.context), this.shapes = new e.ShapeRenderer(this.context), this.skeletonRenderer = new e.SkeletonRenderer(this.context, n), this.skeletonDebugRenderer = new e.SkeletonDebugRenderer(this.context) } return i.prototype.begin = function() { this.camera.update(), this.enableRenderer(this.batcher) }, i.prototype.drawSkeleton = function(t, e) { void 0 === e && (e = !1), this.enableRenderer(this.batcher), this.skeletonRenderer.premultipliedAlpha = e, this.skeletonRenderer.draw(this.batcher, t) }, i.prototype.drawSkeletonDebug = function(t, e, i) { void 0 === e && (e = !1), void 0 === i && (i = null), this.enableRenderer(this.shapes), this.skeletonDebugRenderer.premultipliedAlpha = e, this.skeletonDebugRenderer.draw(this.shapes, t, i) }, i.prototype.drawTexture = function(t, e, i, o, n, s) { void 0 === s && (s = null), this.enableRenderer(this.batcher), null === s && (s = this.WHITE); var r = this.QUAD,
                    a = 0;
                r[a++] = e, r[a++] = i, r[a++] = s.r, r[a++] = s.g, r[a++] = s.b, r[a++] = s.a, r[a++] = 0, r[a++] = 1, this.twoColorTint && (r[a++] = 0, r[a++] = 0, r[a++] = 0, r[a++] = 0), r[a++] = e + o, r[a++] = i, r[a++] = s.r, r[a++] = s.g, r[a++] = s.b, r[a++] = s.a, r[a++] = 1, r[a++] = 1, this.twoColorTint && (r[a++] = 0, r[a++] = 0, r[a++] = 0, r[a++] = 0), r[a++] = e + o, r[a++] = i + n, r[a++] = s.r, r[a++] = s.g, r[a++] = s.b, r[a++] = s.a, r[a++] = 1, r[a++] = 0, this.twoColorTint && (r[a++] = 0, r[a++] = 0, r[a++] = 0, r[a++] = 0), r[a++] = e, r[a++] = i + n, r[a++] = s.r, r[a++] = s.g, r[a++] = s.b, r[a++] = s.a, r[a++] = 0, r[a++] = 0, this.twoColorTint && (r[a++] = 0, r[a++] = 0, r[a++] = 0, r[a++] = 0), this.batcher.draw(t, r, this.QUAD_TRIANGLES) }, i.prototype.drawTextureRotated = function(e, i, o, n, s, r, a, h, l, c) { void 0 === l && (l = null), void 0 === c && (c = !1), this.enableRenderer(this.batcher), null === l && (l = this.WHITE); var d = this.QUAD,
                    u = i + r,
                    p = o + a,
                    m = -r,
                    f = -a,
                    y = n - r,
                    b = s - a,
                    g = m,
                    _ = f,
                    v = m,
                    x = b,
                    S = y,
                    C = b,
                    w = y,
                    A = f,
                    T = 0,
                    P = 0,
                    k = 0,
                    M = 0,
                    E = 0,
                    B = 0,
                    I = 0,
                    D = 0; if (0 != h) { var L = t.MathUtils.cosDeg(h),
                        O = t.MathUtils.sinDeg(h);
                    k = (E = L * S - O * C) + ((T = L * g - O * _) - (I = L * v - O * x)), M = (B = O * S + L * C) + ((P = O * g + L * _) - (D = O * v + L * x)) } else T = g, P = _, I = v, D = x, E = S, B = C, k = w, M = A;
                T += u, P += p, k += u, M += p, E += u, B += p, I += u, D += p; var R = 0;
                d[R++] = T, d[R++] = P, d[R++] = l.r, d[R++] = l.g, d[R++] = l.b, d[R++] = l.a, d[R++] = 0, d[R++] = 1, this.twoColorTint && (d[R++] = 0, d[R++] = 0, d[R++] = 0, d[R++] = 0), d[R++] = k, d[R++] = M, d[R++] = l.r, d[R++] = l.g, d[R++] = l.b, d[R++] = l.a, d[R++] = 1, d[R++] = 1, this.twoColorTint && (d[R++] = 0, d[R++] = 0, d[R++] = 0, d[R++] = 0), d[R++] = E, d[R++] = B, d[R++] = l.r, d[R++] = l.g, d[R++] = l.b, d[R++] = l.a, d[R++] = 1, d[R++] = 0, this.twoColorTint && (d[R++] = 0, d[R++] = 0, d[R++] = 0, d[R++] = 0), d[R++] = I, d[R++] = D, d[R++] = l.r, d[R++] = l.g, d[R++] = l.b, d[R++] = l.a, d[R++] = 0, d[R++] = 0, this.twoColorTint && (d[R++] = 0, d[R++] = 0, d[R++] = 0, d[R++] = 0), this.batcher.draw(e, d, this.QUAD_TRIANGLES) }, i.prototype.drawRegion = function(t, e, i, o, n, s, r) { void 0 === s && (s = null), void 0 === r && (r = !1), this.enableRenderer(this.batcher), null === s && (s = this.WHITE); var a = this.QUAD,
                    h = 0;
                a[h++] = e, a[h++] = i, a[h++] = s.r, a[h++] = s.g, a[h++] = s.b, a[h++] = s.a, a[h++] = t.u, a[h++] = t.v2, this.twoColorTint && (a[h++] = 0, a[h++] = 0, a[h++] = 0, a[h++] = 0), a[h++] = e + o, a[h++] = i, a[h++] = s.r, a[h++] = s.g, a[h++] = s.b, a[h++] = s.a, a[h++] = t.u2, a[h++] = t.v2, this.twoColorTint && (a[h++] = 0, a[h++] = 0, a[h++] = 0, a[h++] = 0), a[h++] = e + o, a[h++] = i + n, a[h++] = s.r, a[h++] = s.g, a[h++] = s.b, a[h++] = s.a, a[h++] = t.u2, a[h++] = t.v, this.twoColorTint && (a[h++] = 0, a[h++] = 0, a[h++] = 0, a[h++] = 0), a[h++] = e, a[h++] = i + n, a[h++] = s.r, a[h++] = s.g, a[h++] = s.b, a[h++] = s.a, a[h++] = t.u, a[h++] = t.v, this.twoColorTint && (a[h++] = 0, a[h++] = 0, a[h++] = 0, a[h++] = 0), this.batcher.draw(t.texture, a, this.QUAD_TRIANGLES) }, i.prototype.line = function(t, e, i, o, n, s) { void 0 === n && (n = null), void 0 === s && (s = null), this.enableRenderer(this.shapes), this.shapes.line(t, e, i, o, n) }, i.prototype.triangle = function(t, e, i, o, n, s, r, a, h, l) { void 0 === a && (a = null), void 0 === h && (h = null), void 0 === l && (l = null), this.enableRenderer(this.shapes), this.shapes.triangle(t, e, i, o, n, s, r, a, h, l) }, i.prototype.quad = function(t, e, i, o, n, s, r, a, h, l, c, d, u) { void 0 === l && (l = null), void 0 === c && (c = null), void 0 === d && (d = null), void 0 === u && (u = null), this.enableRenderer(this.shapes), this.shapes.quad(t, e, i, o, n, s, r, a, h, l, c, d, u) }, i.prototype.rect = function(t, e, i, o, n, s) { void 0 === s && (s = null), this.enableRenderer(this.shapes), this.shapes.rect(t, e, i, o, n, s) }, i.prototype.rectLine = function(t, e, i, o, n, s, r) { void 0 === r && (r = null), this.enableRenderer(this.shapes), this.shapes.rectLine(t, e, i, o, n, s, r) }, i.prototype.polygon = function(t, e, i, o) { void 0 === o && (o = null), this.enableRenderer(this.shapes), this.shapes.polygon(t, e, i, o) }, i.prototype.circle = function(t, e, i, o, n, s) { void 0 === n && (n = null), void 0 === s && (s = 0), this.enableRenderer(this.shapes), this.shapes.circle(t, e, i, o, n, s) }, i.prototype.curve = function(t, e, i, o, n, s, r, a, h, l) { void 0 === l && (l = null), this.enableRenderer(this.shapes), this.shapes.curve(t, e, i, o, n, s, r, a, h, l) }, i.prototype.end = function() { this.activeRenderer === this.batcher ? this.batcher.end() : this.activeRenderer === this.shapes && this.shapes.end(), this.activeRenderer = null }, i.prototype.resize = function(t) { var e = this.canvas,
                    i = e.clientWidth,
                    n = e.clientHeight; if (e.width == i && e.height == n || (e.width = i, e.height = n), this.context.gl.viewport(0, 0, e.width, e.height), t === o.Stretch);
                else if (t === o.Expand) this.camera.setViewport(i, n);
                else if (t === o.Fit) { var s = e.width,
                        r = e.height,
                        a = this.camera.viewportWidth,
                        h = this.camera.viewportHeight,
                        l = h / a < r / s ? a / s : h / r;
                    this.camera.viewportWidth = s * l, this.camera.viewportHeight = r * l } this.camera.update() }, i.prototype.enableRenderer = function(t) { this.activeRenderer !== t && (this.end(), t instanceof e.PolygonBatcher ? (this.batcherShader.bind(), this.batcherShader.setUniform4x4f(e.Shader.MVP_MATRIX, this.camera.projectionView.values), this.batcherShader.setUniformi("u_texture", 0), this.batcher.begin(this.batcherShader), this.activeRenderer = this.batcher) : t instanceof e.ShapeRenderer ? (this.shapesShader.bind(), this.shapesShader.setUniform4x4f(e.Shader.MVP_MATRIX, this.camera.projectionView.values), this.shapes.begin(this.shapesShader), this.activeRenderer = this.shapes) : this.activeRenderer = this.skeletonDebugRenderer) }, i.prototype.dispose = function() { this.batcher.dispose(), this.batcherShader.dispose(), this.shapes.dispose(), this.shapesShader.dispose(), this.skeletonDebugRenderer.dispose() }, i }();
        e.SceneRenderer = i; var o;! function(t) { t[t.Stretch = 0] = "Stretch", t[t.Expand = 1] = "Expand", t[t.Fit = 2] = "Fit" }(o = e.ResizeMode || (e.ResizeMode = {})) }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(t) { var e = function() {
            function e(e, i, o) { this.vertexShader = i, this.fragmentShader = o, this.vs = null, this.fs = null, this.program = null, this.tmp2x2 = new Float32Array(4), this.tmp3x3 = new Float32Array(9), this.tmp4x4 = new Float32Array(16), this.context = e instanceof t.ManagedWebGLRenderingContext ? e : new t.ManagedWebGLRenderingContext(e), this.context.addRestorable(this), this.compile() } return e.prototype.getProgram = function() { return this.program }, e.prototype.getVertexShader = function() { return this.vertexShader }, e.prototype.getFragmentShader = function() { return this.fragmentShader }, e.prototype.compile = function() { var t = this.context.gl; try { this.vs = this.compileShader(t.VERTEX_SHADER, this.vertexShader), this.fs = this.compileShader(t.FRAGMENT_SHADER, this.fragmentShader), this.program = this.compileProgram(this.vs, this.fs) } catch (t) { throw this.dispose(), t } }, e.prototype.compileShader = function(t, e) { var i = this.context.gl,
                    o = i.createShader(t); if (i.shaderSource(o, e), i.compileShader(o), !i.getShaderParameter(o, i.COMPILE_STATUS)) { var n = "Couldn't compile shader: " + i.getShaderInfoLog(o); if (i.deleteShader(o), !i.isContextLost()) throw new Error(n) } return o }, e.prototype.compileProgram = function(t, e) { var i = this.context.gl,
                    o = i.createProgram(); if (i.attachShader(o, t), i.attachShader(o, e), i.linkProgram(o), !i.getProgramParameter(o, i.LINK_STATUS)) { var n = "Couldn't compile shader program: " + i.getProgramInfoLog(o); if (i.deleteProgram(o), !i.isContextLost()) throw new Error(n) } return o }, e.prototype.restore = function() { this.compile() }, e.prototype.bind = function() { this.context.gl.useProgram(this.program) }, e.prototype.unbind = function() { this.context.gl.useProgram(null) }, e.prototype.setUniformi = function(t, e) { this.context.gl.uniform1i(this.getUniformLocation(t), e) }, e.prototype.setUniformf = function(t, e) { this.context.gl.uniform1f(this.getUniformLocation(t), e) }, e.prototype.setUniform2f = function(t, e, i) { this.context.gl.uniform2f(this.getUniformLocation(t), e, i) }, e.prototype.setUniform3f = function(t, e, i, o) { this.context.gl.uniform3f(this.getUniformLocation(t), e, i, o) }, e.prototype.setUniform4f = function(t, e, i, o, n) { this.context.gl.uniform4f(this.getUniformLocation(t), e, i, o, n) }, e.prototype.setUniform2x2f = function(t, e) { var i = this.context.gl;
                this.tmp2x2.set(e), i.uniformMatrix2fv(this.getUniformLocation(t), !1, this.tmp2x2) }, e.prototype.setUniform3x3f = function(t, e) { var i = this.context.gl;
                this.tmp3x3.set(e), i.uniformMatrix3fv(this.getUniformLocation(t), !1, this.tmp3x3) }, e.prototype.setUniform4x4f = function(t, e) { var i = this.context.gl;
                this.tmp4x4.set(e), i.uniformMatrix4fv(this.getUniformLocation(t), !1, this.tmp4x4) }, e.prototype.getUniformLocation = function(t) { var e = this.context.gl,
                    i = e.getUniformLocation(this.program, t); if (!i && !e.isContextLost()) throw new Error("Couldn't find location for uniform " + t); return i }, e.prototype.getAttributeLocation = function(t) { var e = this.context.gl,
                    i = e.getAttribLocation(this.program, t); if (-1 == i && !e.isContextLost()) throw new Error("Couldn't find location for attribute " + t); return i }, e.prototype.dispose = function() { this.context.removeRestorable(this); var t = this.context.gl;
                this.vs && (t.deleteShader(this.vs), this.vs = null), this.fs && (t.deleteShader(this.fs), this.fs = null), this.program && (t.deleteProgram(this.program), this.program = null) }, e.newColoredTextured = function(t) { return new e(t, "\n\t\t\t\tattribute vec4 " + e.POSITION + ";\n\t\t\t\tattribute vec4 " + e.COLOR + ";\n\t\t\t\tattribute vec2 " + e.TEXCOORDS + ";\n\t\t\t\tuniform mat4 " + e.MVP_MATRIX + ";\n\t\t\t\tvarying vec4 v_color;\n\t\t\t\tvarying vec2 v_texCoords;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tv_color = " + e.COLOR + ";\n\t\t\t\t\tv_texCoords = " + e.TEXCOORDS + ";\n\t\t\t\t\tgl_Position = " + e.MVP_MATRIX + " * " + e.POSITION + ";\n\t\t\t\t}\n\t\t\t", "\n\t\t\t\t#ifdef GL_ES\n\t\t\t\t\t#define LOWP lowp\n\t\t\t\t\tprecision mediump float;\n\t\t\t\t#else\n\t\t\t\t\t#define LOWP\n\t\t\t\t#endif\n\t\t\t\tvarying LOWP vec4 v_color;\n\t\t\t\tvarying vec2 v_texCoords;\n\t\t\t\tuniform sampler2D u_texture;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tgl_FragColor = v_color * texture2D(u_texture, v_texCoords);\n\t\t\t\t}\n\t\t\t") }, e.newTwoColoredTextured = function(t) { return new e(t, "\n\t\t\t\tattribute vec4 " + e.POSITION + ";\n\t\t\t\tattribute vec4 " + e.COLOR + ";\n\t\t\t\tattribute vec4 " + e.COLOR2 + ";\n\t\t\t\tattribute vec2 " + e.TEXCOORDS + ";\n\t\t\t\tuniform mat4 " + e.MVP_MATRIX + ";\n\t\t\t\tvarying vec4 v_light;\n\t\t\t\tvarying vec4 v_dark;\n\t\t\t\tvarying vec2 v_texCoords;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tv_light = " + e.COLOR + ";\n\t\t\t\t\tv_dark = " + e.COLOR2 + ";\n\t\t\t\t\tv_texCoords = " + e.TEXCOORDS + ";\n\t\t\t\t\tgl_Position = " + e.MVP_MATRIX + " * " + e.POSITION + ";\n\t\t\t\t}\n\t\t\t", "\n\t\t\t\t#ifdef GL_ES\n\t\t\t\t\t#define LOWP lowp\n\t\t\t\t\tprecision mediump float;\n\t\t\t\t#else\n\t\t\t\t\t#define LOWP\n\t\t\t\t#endif\n\t\t\t\tvarying LOWP vec4 v_light;\n\t\t\t\tvarying LOWP vec4 v_dark;\n\t\t\t\tvarying vec2 v_texCoords;\n\t\t\t\tuniform sampler2D u_texture;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tvec4 texColor = texture2D(u_texture, v_texCoords);\n\t\t\t\t\tfloat alpha = texColor.a * v_light.a;\n\t\t\t\t\tgl_FragColor.a = alpha;\n\t\t\t\t\tgl_FragColor.rgb = (1.0 - texColor.rgb) * v_dark.rgb * alpha + texColor.rgb * v_light.rgb;\n\t\t\t\t}\n\t\t\t") }, e.newColored = function(t) { return new e(t, "\n\t\t\t\tattribute vec4 " + e.POSITION + ";\n\t\t\t\tattribute vec4 " + e.COLOR + ";\n\t\t\t\tuniform mat4 " + e.MVP_MATRIX + ";\n\t\t\t\tvarying vec4 v_color;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tv_color = " + e.COLOR + ";\n\t\t\t\t\tgl_Position = " + e.MVP_MATRIX + " * " + e.POSITION + ";\n\t\t\t\t}\n\t\t\t", "\n\t\t\t\t#ifdef GL_ES\n\t\t\t\t\t#define LOWP lowp\n\t\t\t\t\tprecision mediump float;\n\t\t\t\t#else\n\t\t\t\t\t#define LOWP\n\t\t\t\t#endif\n\t\t\t\tvarying LOWP vec4 v_color;\n\n\t\t\t\tvoid main () {\n\t\t\t\t\tgl_FragColor = v_color;\n\t\t\t\t}\n\t\t\t") }, e }();
        e.MVP_MATRIX = "u_projTrans", e.POSITION = "a_position", e.COLOR = "a_color", e.COLOR2 = "a_color2", e.TEXCOORDS = "a_texCoords", e.SAMPLER = "u_texture", t.Shader = e }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(e) { var i = function() {
            function i(i, n) { if (void 0 === n && (n = 10920), this.isDrawing = !1, this.shapeType = o.Filled, this.color = new t.Color(1, 1, 1, 1), this.vertexIndex = 0, this.tmp = new t.Vector2, n > 10920) throw new Error("Can't have more than 10920 triangles per batch: " + n);
                this.context = i instanceof e.ManagedWebGLRenderingContext ? i : new e.ManagedWebGLRenderingContext(i), this.mesh = new e.Mesh(i, [new e.Position2Attribute, new e.ColorAttribute], n, 0), this.srcBlend = this.context.gl.SRC_ALPHA, this.dstBlend = this.context.gl.ONE_MINUS_SRC_ALPHA } return i.prototype.begin = function(t) { if (this.isDrawing) throw new Error("ShapeRenderer.begin() has already been called");
                this.shader = t, this.vertexIndex = 0, this.isDrawing = !0; var e = this.context.gl;
                e.enable(e.BLEND), e.blendFunc(this.srcBlend, this.dstBlend) }, i.prototype.setBlendMode = function(t, e) { var i = this.context.gl;
                this.srcBlend = t, this.dstBlend = e, this.isDrawing && (this.flush(), i.blendFunc(this.srcBlend, this.dstBlend)) }, i.prototype.setColor = function(t) { this.color.setFromColor(t) }, i.prototype.setColorWith = function(t, e, i, o) { this.color.set(t, e, i, o) }, i.prototype.point = function(t, e, i) { void 0 === i && (i = null), this.check(o.Point, 1), null === i && (i = this.color), this.vertex(t, e, i) }, i.prototype.line = function(t, e, i, n, s) { void 0 === s && (s = null), this.check(o.Line, 2);
                this.mesh.getVertices(), this.vertexIndex;
                null === s && (s = this.color), this.vertex(t, e, s), this.vertex(i, n, s) }, i.prototype.triangle = function(t, e, i, n, s, r, a, h, l, c) { void 0 === h && (h = null), void 0 === l && (l = null), void 0 === c && (c = null), this.check(t ? o.Filled : o.Line, 3);
                this.mesh.getVertices(), this.vertexIndex;
                null === h && (h = this.color), null === l && (l = this.color), null === c && (c = this.color), t ? (this.vertex(e, i, h), this.vertex(n, s, l), this.vertex(r, a, c)) : (this.vertex(e, i, h), this.vertex(n, s, l), this.vertex(n, s, h), this.vertex(r, a, l), this.vertex(r, a, h), this.vertex(e, i, l)) }, i.prototype.quad = function(t, e, i, n, s, r, a, h, l, c, d, u, p) { void 0 === c && (c = null), void 0 === d && (d = null), void 0 === u && (u = null), void 0 === p && (p = null), this.check(t ? o.Filled : o.Line, 3);
                this.mesh.getVertices(), this.vertexIndex;
                null === c && (c = this.color), null === d && (d = this.color), null === u && (u = this.color), null === p && (p = this.color), t ? (this.vertex(e, i, c), this.vertex(n, s, d), this.vertex(r, a, u), this.vertex(r, a, u), this.vertex(h, l, p), this.vertex(e, i, c)) : (this.vertex(e, i, c), this.vertex(n, s, d), this.vertex(n, s, d), this.vertex(r, a, u), this.vertex(r, a, u), this.vertex(h, l, p), this.vertex(h, l, p), this.vertex(e, i, c)) }, i.prototype.rect = function(t, e, i, o, n, s) { void 0 === s && (s = null), this.quad(t, e, i, e + o, i, e + o, i + n, e, i + n, s, s, s, s) }, i.prototype.rectLine = function(t, e, i, n, s, r, a) { void 0 === a && (a = null), this.check(t ? o.Filled : o.Line, 8), null === a && (a = this.color); var h = this.tmp.set(s - i, e - n);
                h.normalize(), r *= .5; var l = h.x * r,
                    c = h.y * r;
                t ? (this.vertex(e + l, i + c, a), this.vertex(e - l, i - c, a), this.vertex(n + l, s + c, a), this.vertex(n - l, s - c, a), this.vertex(n + l, s + c, a), this.vertex(e - l, i - c, a)) : (this.vertex(e + l, i + c, a), this.vertex(e - l, i - c, a), this.vertex(n + l, s + c, a), this.vertex(n - l, s - c, a), this.vertex(n + l, s + c, a), this.vertex(e + l, i + c, a), this.vertex(n - l, s - c, a), this.vertex(e - l, i - c, a)) }, i.prototype.x = function(t, e, i) { this.line(t - i, e - i, t + i, e + i), this.line(t - i, e + i, t + i, e - i) }, i.prototype.polygon = function(t, e, i, n) { if (void 0 === n && (n = null), i < 3) throw new Error("Polygon must contain at least 3 vertices");
                this.check(o.Line, 2 * i), null === n && (n = this.color);
                this.mesh.getVertices(), this.vertexIndex;
                i <<= 1; for (var s = t[e <<= 1], r = t[e + 1], a = e + i, h = e, l = e + i - 2; h < l; h += 2) { var c = t[h],
                        d = t[h + 1],
                        u = 0,
                        p = 0;
                    h + 2 >= a ? (u = s, p = r) : (u = t[h + 2], p = t[h + 3]), this.vertex(c, d, n), this.vertex(u, p, n) } }, i.prototype.circle = function(e, i, n, s, r, a) { if (void 0 === r && (r = null), void 0 === a && (a = 0), 0 === a && (a = Math.max(1, 6 * t.MathUtils.cbrt(s) | 0)), a <= 0) throw new Error("segments must be > 0.");
                null === r && (r = this.color); var h = 2 * t.MathUtils.PI / a,
                    l = Math.cos(h),
                    c = Math.sin(h),
                    d = s,
                    u = 0; if (e) { this.check(o.Filled, 3 * a + 3), a--; for (m = 0; m < a; m++) { this.vertex(i, n, r), this.vertex(i + d, n + u, r); var p = d;
                        d = l * d - c * u, u = c * p + l * u, this.vertex(i + d, n + u, r) } this.vertex(i, n, r), this.vertex(i + d, n + u, r) } else { this.check(o.Line, 2 * a + 2); for (var m = 0; m < a; m++) { this.vertex(i + d, n + u, r); var f = d;
                        d = l * d - c * u, u = c * f + l * u, this.vertex(i + d, n + u, r) } this.vertex(i + d, n + u, r) } d = s, u = 0, this.vertex(i + d, n + u, r) }, i.prototype.curve = function(t, e, i, n, s, r, a, h, l, c) { void 0 === c && (c = null), this.check(o.Line, 2 * l + 2), null === c && (c = this.color); for (var d = 1 / l, u = d * d, p = d * d * d, m = 3 * d, f = 3 * u, y = 6 * u, b = 6 * p, g = t - 2 * i + s, _ = e - 2 * n + r, v = 3 * (i - s) - t + a, x = 3 * (n - r) - e + h, S = t, C = e, w = (i - t) * m + g * f + v * p, A = (n - e) * m + _ * f + x * p, T = g * y + v * b, P = _ * y + x * b, k = v * b, M = x * b; l-- > 0;) this.vertex(S, C, c), S += w, C += A, w += T, A += P, T += k, P += M, this.vertex(S, C, c);
                this.vertex(S, C, c), this.vertex(a, h, c) }, i.prototype.vertex = function(t, e, i) { var o = this.vertexIndex,
                    n = this.mesh.getVertices();
                n[o++] = t, n[o++] = e, n[o++] = i.r, n[o++] = i.g, n[o++] = i.b, n[o++] = i.a, this.vertexIndex = o }, i.prototype.end = function() { if (!this.isDrawing) throw new Error("ShapeRenderer.begin() has not been called");
                this.flush(), this.context.gl.disable(this.context.gl.BLEND), this.isDrawing = !1 }, i.prototype.flush = function() { 0 != this.vertexIndex && (this.mesh.setVerticesLength(this.vertexIndex), this.mesh.draw(this.shader, this.shapeType), this.vertexIndex = 0) }, i.prototype.check = function(t, e) { if (!this.isDrawing) throw new Error("ShapeRenderer.begin() has not been called"); if (this.shapeType == t) { if (!(this.mesh.maxVertices() - this.mesh.numVertices() < e)) return;
                    this.flush() } else this.flush(), this.shapeType = t }, i.prototype.dispose = function() { this.mesh.dispose() }, i }();
        e.ShapeRenderer = i; var o;! function(t) { t[t.Point = 0] = "Point", t[t.Line = 1] = "Line", t[t.Filled = 4] = "Filled" }(o = e.ShapeType || (e.ShapeType = {})) }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(e) { var i = function() {
            function i(i) { this.boneLineColor = new t.Color(1, 0, 0, 1), this.boneOriginColor = new t.Color(0, 1, 0, 1), this.attachmentLineColor = new t.Color(0, 0, 1, .5), this.triangleLineColor = new t.Color(1, .64, 0, .5), this.pathColor = (new t.Color).setFromString("FF7F00"), this.clipColor = new t.Color(.8, 0, 0, 2), this.aabbColor = new t.Color(0, 1, 0, .5), this.drawBones = !0, this.drawRegionAttachments = !0, this.drawBoundingBoxes = !0, this.drawMeshHull = !0, this.drawMeshTriangles = !0, this.drawPaths = !0, this.drawSkeletonXY = !1, this.drawClipping = !0, this.premultipliedAlpha = !1, this.scale = 1, this.boneWidth = 2, this.bounds = new t.SkeletonBounds, this.temp = new Array, this.vertices = t.Utils.newFloatArray(2048), this.context = i instanceof e.ManagedWebGLRenderingContext ? i : new e.ManagedWebGLRenderingContext(i) } return i.prototype.draw = function(e, o, n) { void 0 === n && (n = null); var s = o.x,
                    r = o.y,
                    a = this.context.gl,
                    h = this.premultipliedAlpha ? a.ONE : a.SRC_ALPHA;
                e.setBlendMode(h, a.ONE_MINUS_SRC_ALPHA); var l = o.bones; if (this.drawBones) { e.setColor(this.boneLineColor); for (var c = 0, d = l.length; c < d; c++) { N = l[c]; if (!(n && n.indexOf(N.data.name) > -1) && null != N.parent) { var u = s + N.data.length * N.a + N.worldX,
                                p = r + N.data.length * N.c + N.worldY;
                            e.rectLine(!0, s + N.worldX, r + N.worldY, u, p, this.boneWidth * this.scale) } } this.drawSkeletonXY && e.x(s, r, 4 * this.scale) } if (this.drawRegionAttachments) { e.setColor(this.attachmentLineColor); for (var c = 0, d = (j = o.slots).length; c < d; c++)
                        if ((X = (W = j[c]).getAttachment()) instanceof t.RegionAttachment) { var m = X,
                                f = this.vertices;
                            m.computeWorldVertices(W.bone, f, 0, 2), e.line(f[0], f[1], f[2], f[3]), e.line(f[2], f[3], f[4], f[5]), e.line(f[4], f[5], f[6], f[7]), e.line(f[6], f[7], f[0], f[1]) } } if (this.drawMeshHull || this.drawMeshTriangles)
                    for (var c = 0, d = (j = o.slots).length; c < d; c++)
                        if ((X = (W = j[c]).getAttachment()) instanceof t.MeshAttachment) { var y = X,
                                f = this.vertices;
                            y.computeWorldVertices(W, 0, y.worldVerticesLength, f, 0, 2); var b = y.triangles,
                                g = y.hullLength; if (this.drawMeshTriangles) { e.setColor(this.triangleLineColor); for (var _ = 0, v = b.length; _ < v; _ += 3) { var x = 2 * b[_],
                                        S = 2 * b[_ + 1],
                                        C = 2 * b[_ + 2];
                                    e.triangle(!1, f[x], f[x + 1], f[S], f[S + 1], f[C], f[C + 1]) } } if (this.drawMeshHull && g > 0) { e.setColor(this.attachmentLineColor); for (var w = f[(g = 2 * (g >> 1)) - 2], A = f[g - 1], _ = 0, v = g; _ < v; _ += 2) { var u = f[_],
                                        p = f[_ + 1];
                                    e.line(u, p, w, A), w = u, A = p } } } if (this.drawBoundingBoxes) { var T = this.bounds;
                    T.update(o, !0), e.setColor(this.aabbColor), e.rect(!1, T.minX, T.minY, T.getWidth(), T.getHeight()); for (var P = T.polygons, k = T.boundingBoxes, c = 0, d = P.length; c < d; c++) { var M = P[c];
                        e.setColor(k[c].color), e.polygon(M, 0, M.length) } } if (this.drawPaths)
                    for (var c = 0, d = (j = o.slots).length; c < d; c++)
                        if ((X = (W = j[c]).getAttachment()) instanceof t.PathAttachment) { var E = X,
                                v = E.worldVerticesLength,
                                B = this.temp = t.Utils.setArraySize(this.temp, v, 0);
                            E.computeWorldVertices(W, 0, v, B, 0, 2); var I = this.pathColor,
                                D = B[2],
                                L = B[3],
                                O = 0,
                                R = 0; if (E.closed) { e.setColor(I); var F = B[0],
                                    V = B[1],
                                    G = B[v - 2],
                                    U = B[v - 1];
                                O = B[v - 4], R = B[v - 3], e.curve(D, L, F, V, G, U, O, R, 32), e.setColor(i.LIGHT_GRAY), e.line(D, L, F, V), e.line(O, R, G, U) } v -= 4; for (_ = 4; _ < v; _ += 6) { var F = B[_],
                                    V = B[_ + 1],
                                    G = B[_ + 2],
                                    U = B[_ + 3];
                                O = B[_ + 4], R = B[_ + 5], e.setColor(I), e.curve(D, L, F, V, G, U, O, R, 32), e.setColor(i.LIGHT_GRAY), e.line(D, L, F, V), e.line(O, R, G, U), D = O, L = R } } if (this.drawBones) { e.setColor(this.boneOriginColor); for (var c = 0, d = l.length; c < d; c++) { var N = l[c];
                        n && n.indexOf(N.data.name) > -1 || e.circle(!0, s + N.worldX, r + N.worldY, 3 * this.scale, i.GREEN, 8) } } if (this.drawClipping) { var j = o.slots;
                    e.setColor(this.clipColor); for (var c = 0, d = j.length; c < d; c++) { var W = j[c],
                            X = W.getAttachment(); if (X instanceof t.ClippingAttachment) { var H = X,
                                v = H.worldVerticesLength,
                                B = this.temp = t.Utils.setArraySize(this.temp, v, 0);
                            H.computeWorldVertices(W, 0, v, B, 0, 2); for (var z = 0, J = B.length; z < J; z += 2) { var u = B[z],
                                    p = B[z + 1],
                                    O = B[(z + 2) % B.length],
                                    R = B[(z + 3) % B.length];
                                e.line(u, p, O, R) } } } } }, i.prototype.dispose = function() {}, i }();
        i.LIGHT_GRAY = new t.Color(192 / 255, 192 / 255, 192 / 255, 1), i.GREEN = new t.Color(0, 1, 0, 1), e.SkeletonDebugRenderer = i }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(e) { var i = function() { return function(t, e, i) { this.vertices = t, this.numVertices = e, this.numFloats = i } }(),
            o = function() {
                function o(e, o) { void 0 === o && (o = !0), this.premultipliedAlpha = !1, this.vertexEffect = null, this.tempColor = new t.Color, this.tempColor2 = new t.Color, this.vertexSize = 8, this.twoColorTint = !1, this.renderable = new i(null, 0, 0), this.clipper = new t.SkeletonClipping, this.temp = new t.Vector2, this.temp2 = new t.Vector2, this.temp3 = new t.Color, this.temp4 = new t.Color, this.twoColorTint = o, o && (this.vertexSize += 4), this.vertices = t.Utils.newFloatArray(1024 * this.vertexSize) } return o.prototype.draw = function(i, n) { for (var s = this.clipper, r = this.premultipliedAlpha, a = this.twoColorTint, h = null, l = this.temp, c = this.temp2, d = this.temp3, u = this.temp4, p = this.renderable, m = null, f = null, y = n.drawOrder, b = null, g = n.color, _ = a ? 12 : 8, v = 0, x = y.length; v < x; v++) { var S = s.isClipping() ? 2 : _,
                            C = y[v],
                            w = C.getAttachment(),
                            A = null; if (w instanceof t.RegionAttachment) { var T = w;
                            p.vertices = this.vertices, p.numVertices = 4, p.numFloats = S << 2, T.computeWorldVertices(C.bone, p.vertices, 0, S), f = o.QUAD_TRIANGLES, m = T.uvs, A = T.region.renderObject.texture, b = T.color } else { if (!(w instanceof t.MeshAttachment)) { if (w instanceof t.ClippingAttachment) { var P = w;
                                    s.clipStart(C, P); continue } continue } var k = w;
                            p.vertices = this.vertices, p.numVertices = k.worldVerticesLength >> 1, p.numFloats = p.numVertices * S, p.numFloats > p.vertices.length && (p.vertices = this.vertices = t.Utils.newFloatArray(p.numFloats)), k.computeWorldVertices(C, 0, k.worldVerticesLength, p.vertices, 0, S), f = k.triangles, A = k.region.renderObject.texture, m = k.uvs, b = k.color } if (null != A) { var M = C.color,
                                E = this.tempColor;
                            E.r = g.r * M.r * b.r, E.g = g.g * M.g * b.g, E.b = g.b * M.b * b.b, E.a = g.a * M.a * b.a, r && (E.r *= E.a, E.g *= E.a, E.b *= E.a); var B = this.tempColor2;
                            null == C.darkColor ? B.set(0, 0, 0, 1) : B.setFromColor(C.darkColor); var I = C.data.blendMode; if (I != h && (h = I, i.setBlendMode(e.WebGLBlendModeConverter.getSourceGLBlendMode(h, r), e.WebGLBlendModeConverter.getDestGLBlendMode(h))), s.isClipping()) { s.clipTriangles(p.vertices, p.numFloats, f, f.length, m, E, B, a); var D = new Float32Array(s.clippedVertices),
                                    L = s.clippedTriangles; if (null != this.vertexEffect) { var O = this.vertexEffect,
                                        R = D; if (a)
                                        for (var F = 0, V = D.length; F < V; F += _) l.x = R[F], l.y = R[F + 1], d.set(R[F + 2], R[F + 3], R[F + 4], R[F + 5]), c.x = R[F + 6], c.y = R[F + 7], u.set(R[F + 8], R[F + 9], R[F + 10], R[F + 11]), O.transform(l, c, d, u), R[F] = l.x, R[F + 1] = l.y, R[F + 2] = d.r, R[F + 3] = d.g, R[F + 4] = d.b, R[F + 5] = d.a, R[F + 6] = c.x, R[F + 7] = c.y, R[F + 8] = u.r, R[F + 9] = u.g, R[F + 10] = u.b, R[F + 11] = u.a;
                                    else
                                        for (var F = 0, G = D.length; F < G; F += _) l.x = R[F], l.y = R[F + 1], d.set(R[F + 2], R[F + 3], R[F + 4], R[F + 5]), c.x = R[F + 6], c.y = R[F + 7], u.set(0, 0, 0, 0), O.transform(l, c, d, u), R[F] = l.x, R[F + 1] = l.y, R[F + 2] = d.r, R[F + 3] = d.g, R[F + 4] = d.b, R[F + 5] = d.a, R[F + 6] = c.x, R[F + 7] = c.y } i.draw(A, D, L) } else { R = p.vertices; if (null != this.vertexEffect) { O = this.vertexEffect; if (a)
                                        for (var F = 0, U = 0, N = p.numFloats; F < N; F += _, U += 2) l.x = R[F], l.y = R[F + 1], c.x = m[U], c.y = m[U + 1], d.setFromColor(E), u.setFromColor(B), O.transform(l, c, d, u), R[F] = l.x, R[F + 1] = l.y, R[F + 2] = d.r, R[F + 3] = d.g, R[F + 4] = d.b, R[F + 5] = d.a, R[F + 6] = c.x, R[F + 7] = c.y, R[F + 8] = u.r, R[F + 9] = u.g, R[F + 10] = u.b, R[F + 11] = u.a;
                                    else
                                        for (var F = 0, U = 0, j = p.numFloats; F < j; F += _, U += 2) l.x = R[F], l.y = R[F + 1], c.x = m[U], c.y = m[U + 1], d.setFromColor(E), u.set(0, 0, 0, 0), O.transform(l, c, d, u), R[F] = l.x, R[F + 1] = l.y, R[F + 2] = d.r, R[F + 3] = d.g, R[F + 4] = d.b, R[F + 5] = d.a, R[F + 6] = c.x, R[F + 7] = c.y } else if (a)
                                    for (var F = 2, U = 0, W = p.numFloats; F < W; F += _, U += 2) R[F] = E.r, R[F + 1] = E.g, R[F + 2] = E.b, R[F + 3] = E.a, R[F + 4] = m[U], R[F + 5] = m[U + 1], R[F + 6] = B.r, R[F + 7] = B.g, R[F + 8] = B.b, R[F + 9] = B.a;
                                else
                                    for (var F = 2, U = 0, X = p.numFloats; F < X; F += _, U += 2) R[F] = E.r, R[F + 1] = E.g, R[F + 2] = E.b, R[F + 3] = E.a, R[F + 4] = m[U], R[F + 5] = m[U + 1]; var H = p.vertices.subarray(0, p.numFloats);
                                i.draw(A, H, f) } } s.clipEndWithSlot(C) } s.clipEnd() }, o }();
        o.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0], e.SkeletonRenderer = o }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(t) { var e = function() {
            function e(t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.x = 0, this.y = 0, this.z = 0, this.x = t, this.y = e, this.z = i } return e.prototype.setFrom = function(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }, e.prototype.set = function(t, e, i) { return this.x = t, this.y = e, this.z = i, this }, e.prototype.add = function(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this }, e.prototype.sub = function(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this }, e.prototype.scale = function(t) { return this.x *= t, this.y *= t, this.z *= t, this }, e.prototype.normalize = function() { var t = this.length(); return 0 == t ? this : (t = 1 / t, this.x *= t, this.y *= t, this.z *= t, this) }, e.prototype.cross = function(t) { return this.set(this.y * t.z - this.z * t.y, this.z * t.x - this.x * t.z, this.x * t.y - this.y * t.x) }, e.prototype.multiply = function(e) { var i = e.values; return this.set(this.x * i[t.M00] + this.y * i[t.M01] + this.z * i[t.M02] + i[t.M03], this.x * i[t.M10] + this.y * i[t.M11] + this.z * i[t.M12] + i[t.M13], this.x * i[t.M20] + this.y * i[t.M21] + this.z * i[t.M22] + i[t.M23]) }, e.prototype.project = function(e) { var i = e.values,
                    o = 1 / (this.x * i[t.M30] + this.y * i[t.M31] + this.z * i[t.M32] + i[t.M33]); return this.set((this.x * i[t.M00] + this.y * i[t.M01] + this.z * i[t.M02] + i[t.M03]) * o, (this.x * i[t.M10] + this.y * i[t.M11] + this.z * i[t.M12] + i[t.M13]) * o, (this.x * i[t.M20] + this.y * i[t.M21] + this.z * i[t.M22] + i[t.M23]) * o) }, e.prototype.dot = function(t) { return this.x * t.x + this.y * t.y + this.z * t.z }, e.prototype.length = function() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, e.prototype.distance = function(t) { var e = t.x - this.x,
                    i = t.y - this.y,
                    o = t.z - this.z; return Math.sqrt(e * e + i * i + o * o) }, e }();
        t.Vector3 = e }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var spine;
! function(t) {! function(e) { var i = function() {
            function t(t, e) { void 0 === e && (e = { alpha: "true" }); var i = this; if (this.restorables = new Array, t instanceof HTMLCanvasElement) { var o = t;
                    this.gl = o.getContext("webgl", e) || o.getContext("experimental-webgl", e), this.canvas = o, o.addEventListener("webglcontextlost", function(t) { t && t.preventDefault() }), o.addEventListener("webglcontextrestored", function(t) { for (var e = 0, o = i.restorables.length; e < o; e++) i.restorables[e].restore() }) } else this.gl = t, this.canvas = this.gl.canvas } return t.prototype.addRestorable = function(t) { this.restorables.push(t) }, t.prototype.removeRestorable = function(t) { var e = this.restorables.indexOf(t);
                e > -1 && this.restorables.splice(e, 1) }, t }();
        e.ManagedWebGLRenderingContext = i; var o = function() {
            function e() {} return e.getDestGLBlendMode = function(i) { switch (i) {
                    case t.BlendMode.Normal:
                        return e.ONE_MINUS_SRC_ALPHA;
                    case t.BlendMode.Additive:
                        return e.ONE;
                    case t.BlendMode.Multiply:
                    case t.BlendMode.Screen:
                        return e.ONE_MINUS_SRC_ALPHA;
                    default:
                        throw new Error("Unknown blend mode: " + i) } }, e.getSourceGLBlendMode = function(i, o) { switch (void 0 === o && (o = !1), i) {
                    case t.BlendMode.Normal:
                    case t.BlendMode.Additive:
                        return o ? e.ONE : e.SRC_ALPHA;
                    case t.BlendMode.Multiply:
                        return e.DST_COLOR;
                    case t.BlendMode.Screen:
                        return e.ONE;
                    default:
                        throw new Error("Unknown blend mode: " + i) } }, e }();
        o.ZERO = 0, o.ONE = 1, o.SRC_COLOR = 768, o.ONE_MINUS_SRC_COLOR = 769, o.SRC_ALPHA = 770, o.ONE_MINUS_SRC_ALPHA = 771, o.DST_ALPHA = 772, o.ONE_MINUS_DST_ALPHA = 773, o.DST_COLOR = 774, e.WebGLBlendModeConverter = o }(t.webgl || (t.webgl = {})) }(spine || (spine = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    PhaserSpine;
! function(t) {! function(e) { var i = function() {
            function e(t) { this.vertices = spine.Utils.newFloatArray(8192), this.tempColor = new spine.Color, this.game = t } return e.prototype.destroy = function() { this.game = null, this.vertices = null, this.tempColor = null }, e.prototype.resize = function(t, e, i) { var o = i.resolution;
                i.context.globalAlpha = 1, i.context.resetTransform ? i.context.resetTransform() : i.context.setTransform(1, 0, 0, 1, 0, 0), i.context.scale(e.x * o, e.y * o), i.context.translate(t.width / 2 / e.x, t.height / e.y / o), o > 1 && i.context.translate(0, t.height / e.y / o / 2), i.context.translate(t.x / e.x, t.y / e.y) }, e.prototype.drawImages = function(e, i) { var o = i.context,
                    n = e.skeleton.drawOrder,
                    s = i.resolution;
                t.SpinePlugin.DEBUG && (o.strokeStyle = "green"), o.save(); for (var r = 0, a = n.length; r < a; r++) { var h = n[r],
                        l = h.getAttachment(),
                        c = null,
                        d = null,
                        u = null; if (l instanceof spine.RegionAttachment) { u = (d = (c = l).region).texture.getImage(); var p = h.bone.skeleton.color,
                            m = h.color,
                            f = c.color,
                            y = p.a * m.a * f.a,
                            b = this.tempColor;
                        b.set(p.r * m.r * f.r, p.g * m.g * f.g, p.b * m.b * f.b, y); var g = l,
                            _ = h.bone,
                            v = d.width,
                            x = d.height;
                        o.save(), o.transform(_.a, _.c, _.b, _.d, _.worldX, _.worldY), o.translate(l.offset[0], l.offset[1]), o.rotate(l.rotation * Math.PI / 180); var S = g.width / v; if (o.scale(S * l.scaleX, S * l.scaleY), o.translate(v / 2, x / 2), l.region.rotate) { var C = v;
                            v = x, x = C, o.rotate(-Math.PI / 2) } o.scale(1, -1), o.translate(-v / 2 / s, -x / 2 / s), 1 == b.r && 1 == b.g && 1 == b.b && 1 == b.a || (o.globalAlpha = b.a), o.drawImage(u, d.x, d.y, v, x, 0, 0, v / s, x / s), t.SpinePlugin.DEBUG && o.strokeRect(0, 0, v / s, x / s), o.restore() } } o.restore() }, e.prototype.drawTriangles = function(i, o) { for (var n = null, s = null, r = null, a = i.skeleton.drawOrder, h = o.resolution, l = 0, c = a.length; l < c; l++) { var d = a[l],
                        u = d.getAttachment(),
                        p = null; if (u instanceof spine.RegionAttachment) { var m = u;
                        s = this.computeRegionVertices(d, m, !1), r = e.QUAD_TRIANGLES, p = m.region.texture.getImage() } else { if (!(u instanceof spine.MeshAttachment)) continue; var f = u;
                        s = this.computeMeshVertices(d, f, !1), r = f.triangles, p = f.region.renderObject.texture.getImage() } if (null != p) { var y = d.data.blendMode;
                        y != n && (n = y); for (var b = o.context, g = 0; g < r.length; g += 3) { var _ = 8 * r[g],
                                v = 8 * r[g + 1],
                                x = 8 * r[g + 2],
                                S = s[_],
                                C = s[_ + 1],
                                w = s[_ + 6],
                                A = s[_ + 7],
                                T = s[v],
                                P = s[v + 1],
                                k = s[v + 6],
                                M = s[v + 7],
                                E = s[x],
                                B = s[x + 1],
                                I = s[x + 6],
                                D = s[x + 7];
                            this.drawTriangle(o, p, S / h, C / h, w, A, T / h, P / h, k, M, E / h, B / h, I, D), t.SpinePlugin.DEBUG && (b.strokeStyle = "green", b.beginPath(), b.moveTo(S / h, C / h), b.lineTo(T / h, P / h), b.lineTo(E / h, B / h), b.lineTo(S / h, C / h), b.stroke()) } } } }, e.prototype.drawTriangle = function(t, e, i, o, n, s, r, a, h, l, c, d, u, p) { var m = t.context;
                n *= e.width, s *= e.height, h *= e.width, l *= e.height, u *= e.width, p *= e.height, m.beginPath(), m.moveTo(i, o), m.lineTo(r, a), m.lineTo(c, d), m.closePath(); var f = 1 / ((h -= n) * (p -= s) - (u -= n) * (l -= s)),
                    y = (p * (r -= i) - l * (c -= i)) * f,
                    b = (p * (a -= o) - l * (d -= o)) * f,
                    g = (h * c - u * r) * f,
                    _ = (h * d - u * a) * f,
                    v = i - y * n - g * s,
                    x = o - b * n - _ * s;
                m.save(), m.transform(y, b, g, _, v, x), m.clip(), m.drawImage(e, 0, 0), m.restore() }, e.prototype.computeRegionVertices = function(t, i, o) { var n = t.bone.skeleton.color,
                    s = t.color,
                    r = i.color,
                    a = n.a * s.a * r.a,
                    h = o ? a : 1,
                    l = this.tempColor;
                l.set(n.r * s.r * r.r * h, n.g * s.g * r.g * h, n.b * s.b * r.b * h, a), i.computeWorldVertices(t.bone, this.vertices, 0, e.VERTEX_SIZE); var c = this.vertices,
                    d = i.uvs; return c[spine.RegionAttachment.C1R] = l.r, c[spine.RegionAttachment.C1G] = l.g, c[spine.RegionAttachment.C1B] = l.b, c[spine.RegionAttachment.C1A] = l.a, c[spine.RegionAttachment.U1] = d[0], c[spine.RegionAttachment.V1] = d[1], c[spine.RegionAttachment.C2R] = l.r, c[spine.RegionAttachment.C2G] = l.g, c[spine.RegionAttachment.C2B] = l.b, c[spine.RegionAttachment.C2A] = l.a, c[spine.RegionAttachment.U2] = d[2], c[spine.RegionAttachment.V2] = d[3], c[spine.RegionAttachment.C3R] = l.r, c[spine.RegionAttachment.C3G] = l.g, c[spine.RegionAttachment.C3B] = l.b, c[spine.RegionAttachment.C3A] = l.a, c[spine.RegionAttachment.U3] = d[4], c[spine.RegionAttachment.V3] = d[5], c[spine.RegionAttachment.C4R] = l.r, c[spine.RegionAttachment.C4G] = l.g, c[spine.RegionAttachment.C4B] = l.b, c[spine.RegionAttachment.C4A] = l.a, c[spine.RegionAttachment.U4] = d[6], c[spine.RegionAttachment.V4] = d[7], c }, e.prototype.computeMeshVertices = function(t, i, o) { var n = t.bone.skeleton.color,
                    s = t.color,
                    r = i.color,
                    a = n.a * s.a * r.a,
                    h = o ? a : 1,
                    l = this.tempColor;
                l.set(n.r * s.r * r.r * h, n.g * s.g * r.g * h, n.b * s.b * r.b * h, a); var c = i.worldVerticesLength / 2;
                this.vertices.length < i.worldVerticesLength && (this.vertices = spine.Utils.newFloatArray(i.worldVerticesLength)); var d = this.vertices;
                i.computeWorldVertices(t, 0, i.worldVerticesLength, d, 0, e.VERTEX_SIZE); for (var u = i.uvs, p = 0, m = c, f = 0, y = 2; p < m; p++) d[y++] = l.r, d[y++] = l.g, d[y++] = l.b, d[y++] = l.a, d[y++] = u[f++], d[y++] = u[f++], y += 2; return d }, e.QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0], e.VERTEX_SIZE = 8, e }();
        e.Renderer = i }(t.Canvas || (t.Canvas = {})) }(PhaserSpine || (PhaserSpine = {}));
var PhaserSpine;
! function(t) {! function(t) { var e = function(t) {
            function e(e) { return t.call(this, e) || this } return __extends(e, t), e.prototype.setFilters = function(t, e) {}, e.prototype.setWraps = function(t, e) {}, e.prototype.dispose = function() {}, e }(spine.Texture);
        t.Texture = e }(t.Canvas || (t.Canvas = {})) }(PhaserSpine || (PhaserSpine = {}));
var PhaserSpine;
! function(t) { var e = function(e) {
        function i(t, i) { return e.call(this, t, i) || this } return __extends(i, e), i.prototype.init = function(t) { void 0 === t && (t = {}), i.DEBUG = t.debugRendering || !1, i.TRIANGLE = t.triangleRendering || !1, this.addSpineCache(), this.addSpineFactory(), this.addSpineLoader() }, i.prototype.addSpineLoader = function() { Phaser.Loader.prototype.spine = function(t, e, o) { var n = this,
                    s = e.substr(0, e.lastIndexOf(".")),
                    r = e.substr(0, e.lastIndexOf("/")),
                    a = e.substring(e.lastIndexOf("/") + 1, e.lastIndexOf("."));
                this.text("atlas_" + i.SPINE_NAMESPACE + "_" + t, s + ".atlas"), this.json(i.SPINE_NAMESPACE + t, s + ".json"), this.onFileComplete.add(function(e, i) { if (0 === i.indexOf("atlas_spine_")) { var o = null;
                        n.game.cache.getText(i).split(/\r\n|\r|\n/).forEach(function(e, n) { 0 !== e.length && -1 === e.indexOf(":") && (null === o && (o = e.substr(0, e.lastIndexOf("."))), null !== o && -1 !== e.indexOf(o) && -1 !== e.indexOf(".") && (a !== i.replace("atlas_spine_", "") && t !== i.replace("atlas_spine_", "") || this.image(e, r + "/" + e))) }.bind(n)) } }) } }, i.prototype.addSpineFactory = function() { Phaser.GameObjectFactory.prototype.spine = function(e, i, o, n, s, r) { void 0 === n && (n = !1), void 0 === r && (r = this.world); var a = new t.Spine(this.game, e, i, o, n); return r.add(a) }, Phaser.GameObjectCreator.prototype.spine = function(e, i, o, n, s, r) { return void 0 === n && (n = !1), new t.Spine(this.game, e, i, o, n) } }, i.prototype.addSpineCache = function() { Phaser.Cache.prototype.spine = {}, Phaser.Cache.prototype.addSpine = function(t, e) { this.spine[t] = e }, Phaser.Cache.prototype.getSpine = function(t) { return this.spine.hasOwnProperty(t), this.spine[t] } }, i.RESOLUTION_REGEXP = /@(.+)x/, i.SPINE_NAMESPACE = "spine", i.DEBUG = !1, i.TRIANGLE = !1, i }(Phaser.Plugin);
    t.SpinePlugin = e }(PhaserSpine || (PhaserSpine = {})), Phaser.Rope.prototype.postUpdate = function() {};
var PhaserSpine;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r) { void 0 === r && (r = !1); var a = e.call(this, i, o, n, "") || this;
            a.premultipliedAlpha = !1, a.premultipliedAlpha = r, a.skeleton = a.createSkeleton(s), a.skeleton.flipY = a.game.renderType === Phaser.CANVAS, a.skeleton.setToSetupPose(), a.skeleton.updateWorldTransform(); var h = new spine.Vector2; return a.skeleton.getBounds(new spine.Vector2, h, []), a.texture.setFrame(new PIXI.Rectangle(0, 0, h.x, h.y)), a.skeleton.setToSetupPose(), a.skeleton.updateWorldTransform(), a.updateSize(), a.stateData = new spine.AnimationStateData(a.skeleton.data), a.state = new spine.AnimationState(a.stateData), a.onEvent = new Phaser.Signal, a.onComplete = new Phaser.Signal, a.onEnd = new Phaser.Signal, a.onInterrupt = new Phaser.Signal, a.onStart = new Phaser.Signal, a.onDispose = new Phaser.Signal, a.state.addListener({ interrupt: a.onInterrupt.dispatch.bind(a.onInterrupt), dispose: a.onDispose.dispatch.bind(a.onDispose), event: a.onEvent.dispatch.bind(a.onEvent), complete: a.onComplete.dispatch.bind(a.onComplete), start: a.onStart.dispatch.bind(a.onStart), end: a.onEnd.dispatch.bind(a.onEnd) }), a.game.renderType === Phaser.CANVAS ? a.renderer = new t.Canvas.Renderer(a.game) : a.renderer = new t.WebGL.Renderer(a.game), a } return __extends(i, e), i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), null === this.game || this.destroyPhase || (this.specialBounds = null, this.renderer && (this.renderer.destroy(), this.renderer = null), this.onEvent && (this.onEvent.dispose(), this.onEvent = null, this.onStart.dispose(), this.onStart = null, this.onInterrupt.dispose(), this.onInterrupt = null, this.onDispose.dispose(), this.onDispose = null, this.onComplete.dispose(), this.onComplete = null, this.onEnd.dispose(), this.onEnd = null), this.state && (this.state.clearListeners(), this.state = null, this.stateData = null)) }, i.prototype.createSkeleton = function(e) { var i = this,
                o = new spine.TextureAtlas(this.game.cache.getText("atlas_" + t.SpinePlugin.SPINE_NAMESPACE + "_" + e), function(e, o) { if (i.game.renderType === Phaser.CANVAS) return new t.Canvas.Texture(i.game.cache.getImage(e)); var n = -1 !== o.min.toLowerCase().indexOf("mip"); return new t.WebGL.Texture(i.game.renderer.gl, i.game.cache.getImage(e), n) }),
                n = new spine.AtlasAttachmentLoader(o),
                s = new spine.SkeletonJson(n).readSkeletonData(this.game.cache.getJSON(t.SpinePlugin.SPINE_NAMESPACE + e)); return new spine.Skeleton(s) }, i.prototype.update = function() { e.prototype.update.call(this), this.state.update(this.game.time.elapsed / 1e3), this.state.apply(this.skeleton), this.skeleton.color.a = this.worldAlpha, this.skeleton.getRootBone().rotation = 180 * this.worldRotation / Math.PI, this.skeleton.updateWorldTransform() }, i.prototype._renderCanvas = function(e, i) { this.visible && this.alive && (this.texture.setFrame(new PIXI.Rectangle(0, 0, this.size.x, this.size.y)), this.renderer.resize(this.getBounds(), this.scale, e), t.SpinePlugin.TRIANGLE ? this.renderer.drawTriangles(this, e) : this.renderer.drawImages(this, e)) }, i.prototype._renderWebGL = function(t, e) { this.visible && this.alive && (this.texture.setFrame(new PIXI.Rectangle(0, 0, this.size.x, this.size.y)), this.renderer.resize(this, this.getBounds(), this.scale, t), this.renderer.draw(this, t, this.premultipliedAlpha)) }, i.prototype.setMixByName = function(t, e, i) { this.stateData.setMix(t, e, i) }, i.prototype.setAnimationByName = function(t, e, i) { return void 0 === i && (i = !1), this.state.setAnimation(t, e, i) }, i.prototype.addAnimationByName = function(t, e, i, o) { return void 0 === i && (i = !1), void 0 === o && (o = 0), this.state.addAnimation(t, e, i, o) }, i.prototype.getCurrentAnimationForTrack = function(t) { return this.state.tracks[t] && this.state.tracks[t].animation ? this.state.tracks[t].animation.name : "" }, i.prototype.setSkinByName = function(t) { var e = this.skeleton.data.findSkin(t);
            e && (this.skeleton.setSkin(e), this.updateSize()) }, i.prototype.updateSize = function() { var t = new spine.Vector2,
                e = new spine.Vector2;
            this.skeleton.getBounds(t, e, []), this.specialBounds = new PIXI.Rectangle(t.x, t.y, e.x, e.y), this.size = e }, i.prototype.setSkin = function(t) { this.skeleton.setSkin(t), this.updateSize() }, i.prototype.setToSetupPose = function() { this.skeleton.setToSetupPose() }, i.prototype.createCombinedSkin = function(t) { for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i]; if (0 !== e.length) { for (var o = new spine.Skin(t), n = 0; n < e.length; n++) { var s = e[n],
                        r = this.skeleton.data.findSkin(s); if (!r) return; for (var a in r.attachments) { var h = a.split(":"),
                            l = parseInt(h[0]),
                            c = Object.keys(r.attachments[a])[0],
                            d = r.attachments[a][c]; if (void 0 === l || void 0 === c) return;
                        o.addAttachment(l, c, d) } } return this.skeleton.data.skins.push(o), o } }, i }(Phaser.Sprite);
    t.Spine = e }(PhaserSpine || (PhaserSpine = {}));
var PhaserSpine;
! function(t) {! function(e) { var i = function() {
            function e(t) { this.mvp = new spine.webgl.Matrix4, this.game = t; var e = this.game.renderer.renderSession.gl;
                this.shader = spine.webgl.Shader.newTwoColoredTextured(e), this.batcher = new spine.webgl.PolygonBatcher(e), this.mvp.ortho2d(0, 0, this.game.width - 1, this.game.height - 1), this.skeletonRenderer = new spine.webgl.SkeletonRenderer(e), this.debugRenderer = new spine.webgl.SkeletonDebugRenderer(e), this.debugRenderer.drawRegionAttachments = !1, this.debugRenderer.drawBoundingBoxes = !1, this.debugRenderer.drawMeshHull = !1, this.debugRenderer.drawMeshTriangles = !1, this.debugRenderer.drawPaths = !1, this.debugShader = spine.webgl.Shader.newColored(e), this.shapes = new spine.webgl.ShapeRenderer(e) } return e.prototype.destroy = function() { this.shader.dispose(), this.batcher.dispose(), this.debugShader.dispose(), this.shapes.dispose(), this.game = null, this.shader = null, this.debugShader = null, this.batcher = null, this.shapes = null, this.skeletonRenderer = null, this.debugRenderer = null }, e.prototype.resize = function(t, e, i, o) { var n = this.game.width,
                    s = this.game.height,
                    r = o.resolution;
                t.skeleton.flipX = i.x < 0, t.skeleton.flipY = i.y < 0; var a = Math.max(i.x, i.y),
                    h = n / a,
                    l = s / a,
                    c = -e.centerX / a,
                    d = ((-s + e.centerY) * r + e.height / 2) / a;
                this.mvp.ortho2d(c * r, d, h * r, l * r), o.gl.viewport(0, 0, n * r, s * r) }, e.prototype.draw = function(e, i, o) { i.spriteBatch.end(); for (var n = i.blendModeManager.currentBlendMode, s = i.shaderManager.currentShader, r = 0; r < i.shaderManager.attribState.length; r++) i.shaderManager.attribState[r] = null, i.gl.disableVertexAttribArray(r);
                this.shader.bind(), this.shader.setUniformi(spine.webgl.Shader.SAMPLER, 0), this.shader.setUniform4x4f(spine.webgl.Shader.MVP_MATRIX, this.mvp.values), this.batcher.begin(this.shader), this.skeletonRenderer.premultipliedAlpha = o, this.skeletonRenderer.draw(this.batcher, e.skeleton), this.batcher.end(), this.shader.unbind(), t.SpinePlugin.DEBUG && (this.debugShader.bind(), this.debugShader.setUniform4x4f(spine.webgl.Shader.MVP_MATRIX, this.mvp.values), this.debugRenderer.premultipliedAlpha = o, this.shapes.begin(this.debugShader), this.debugRenderer.draw(this.shapes, e.skeleton), this.shapes.end(), this.debugShader.unbind()), i.blendModeManager.currentBlendMode = -1, i.blendModeManager.setBlendMode(n), i.gl.enable(i.gl.BLEND), i.shaderManager._currentId = null, i.shaderManager.setShader(s), i.spriteBatch.dirty = !0, ["2.7.3", "2.7.4", "2.7.5", "2.7.6", "2.7.7"].indexOf(Phaser.VERSION) > -1 && i.spriteBatch.sprites.map(function(t) { t.texture && t.texture.baseTexture && (t.texture.baseTexture._dirty[i.spriteBatch.gl.id] = !0) }), i.drawCount++ }, e }();
        e.Renderer = i }(t.WebGL || (t.WebGL = {})) }(PhaserSpine || (PhaserSpine = {}));
var PhaserSpine;
! function(t) {! function(t) { var e = function(t) {
            function e(e, i, o) { void 0 === o && (o = !1); var n = t.call(this, i) || this; return n.texture = null, n.boundUnit = 0, n.useMipMaps = !1, n.context = e instanceof spine.webgl.ManagedWebGLRenderingContext ? e : new spine.webgl.ManagedWebGLRenderingContext(e), n.useMipMaps = o, n.restore(), n.context.addRestorable(n), n } return __extends(e, t), e.prototype.setFilters = function(t, e) { var i = this.context.gl;
                this.bind(), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, e) }, e.prototype.setWraps = function(t, e) { var i = this.context.gl;
                this.bind(), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, e) }, e.prototype.update = function(t) { var e = this.context.gl;
                this.texture || (this.texture = this.context.gl.createTexture()), this.bind(), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, this._image), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t ? e.LINEAR_MIPMAP_LINEAR : e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), t && e.generateMipmap(e.TEXTURE_2D) }, e.prototype.restore = function() { this.texture = null, this.update(this.useMipMaps) }, e.prototype.bind = function(t) { void 0 === t && (t = 0); var e = this.context.gl;
                this.boundUnit = t, e.activeTexture(e.TEXTURE0 + t), e.bindTexture(e.TEXTURE_2D, this.texture) }, e.prototype.unbind = function() { var t = this.context.gl;
                t.activeTexture(t.TEXTURE0 + this.boundUnit), t.bindTexture(t.TEXTURE_2D, null) }, e.prototype.dispose = function() { this.context.removeRestorable(this), this.context.gl.deleteTexture(this.texture) }, e }(spine.Texture);
        t.Texture = e }(t.WebGL || (t.WebGL = {})) }(PhaserSpine || (PhaserSpine = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    PhaserNineSlice;
! function(t) { var e = function(t) {
        function e(e, i, o, n, s, r, a, h) { var l = t.call(this, e, i, o, n, s) || this; return l.baseTexture = l.texture.baseTexture, l.baseFrame = l.texture.frame, l.atlasKey = n, null === s || h ? h || (h = e.cache.getNineSlice(n)) : h = e.cache.getNineSlice(s), void 0 === h ? l : (l.topSize = h.top, h.left ? l.leftSize = h.left : l.leftSize = l.topSize, h.right ? l.rightSize = h.right : l.rightSize = l.leftSize, h.bottom ? l.bottomSize = h.bottom : l.bottomSize = l.topSize, l.loadTexture(new Phaser.RenderTexture(l.game, l.localWidth, l.localHeight)), l.resize(r, a), l) } return __extends(e, t), e.prototype.renderTexture = function() { this.texture.resize(this.localWidth, this.localHeight, !0); var t = [0, this.leftSize, this.baseFrame.width - this.rightSize, this.baseFrame.width],
                e = [0, this.topSize, this.baseFrame.height - this.bottomSize, this.baseFrame.height],
                i = [0, this.leftSize, this.localWidth - this.rightSize, this.localWidth],
                o = [0, this.topSize, this.localHeight - this.bottomSize, this.localHeight];
            this.texture.clear(); for (var n = 0; n < 3; n++)
                for (var s = 0; s < 3; s++) { var r = this.createTexturePart(t[s], e[n], t[s + 1] - t[s], e[n + 1] - e[n]);
                    r.width = i[s + 1] - i[s], r.height = o[n + 1] - o[n], this.texture.renderXY(r, i[s], o[n]) } }, e.prototype.resize = function(t, e) { this.localWidth = t, this.localHeight = e, this.renderTexture() }, e.prototype.changeFrame = function(t) { var e = this.game.cache.getFrameByName(this.atlasKey, t);
            this.baseFrame = new PIXI.Rectangle(e.x, e.y, e.width, e.height), this.resize(this.localWidth, this.localHeight) }, e.prototype.destroy = function() { for (var e = [], i = 0; i < arguments.length; i++) e[i] = arguments[i];
            t.prototype.destroy.call(this, e[0]), this.texture.destroy(!0), this.texture = null, this.baseTexture = null, this.baseFrame = null }, e.prototype.createTexturePart = function(t, e, i, o) { var n = new PIXI.Rectangle(this.baseFrame.x + this.texture.frame.x + t, this.baseFrame.y + this.texture.frame.y + e, Math.max(i, 1), Math.max(o, 1)); return new Phaser.Sprite(this.game, 0, 0, new PIXI.Texture(this.baseTexture, n)) }, e }(Phaser.Sprite);
    t.NineSlice = e }(PhaserNineSlice || (PhaserNineSlice = {}));
var PhaserNineSlice;
! function(t) { var e = function(e) {
        function i(t, i) { var o = e.call(this, t, i) || this; return o.addNineSliceCache(), o.addNineSliceFactory(), o.addNineSliceLoader(), o } return __extends(i, e), i.prototype.addNineSliceLoader = function() { Phaser.Loader.prototype.nineSlice = function(t, e, i, o, n, s) { var r = { top: i };
                o && (r.left = o), n && (r.right = n), s && (r.bottom = s), this.addToFileList("image", t, e), this.game.cache.addNineSlice(t, r) } }, i.prototype.addNineSliceFactory = function() { Phaser.GameObjectFactory.prototype.nineSlice = function(e, i, o, n, s, r, a) { void 0 === a && (a = this.world); var h = new t.NineSlice(this.game, e, i, o, n, s, r); return a.add(h) }, Phaser.GameObjectCreator.prototype.nineSlice = function(e, i, o, n, s, r) { return new t.NineSlice(this.game, e, i, o, n, s, r) } }, i.prototype.addNineSliceCache = function() { Phaser.Cache.prototype.nineSlice = {}, Phaser.Cache.prototype.addNineSlice = function(t, e) { this.nineSlice[t] = e }, Phaser.Cache.prototype.getNineSlice = function(t) { var e = this.nineSlice[t]; return e } }, i }(Phaser.Plugin);
    t.Plugin = e }(PhaserNineSlice || (PhaserNineSlice = {})), Phaser.VirtualJoystick = function(t, e) { Phaser.Plugin.call(this, t, e), this.sticks = null, this.buttons = null, this._pointerTotal = 0 }, Phaser.VirtualJoystick.prototype = Object.create(Phaser.Plugin.prototype), Phaser.VirtualJoystick.prototype.constructor = Phaser.VirtualJoystick, Phaser.VirtualJoystick.NONE = 0, Phaser.VirtualJoystick.HORIZONTAL = 1, Phaser.VirtualJoystick.VERTICAL = 2, Phaser.VirtualJoystick.CIRC_BUTTON = 0, Phaser.VirtualJoystick.RECT_BUTTON = 1, Phaser.VirtualJoystick.prototype.init = function() { this.sticks = new Phaser.ArraySet, this.buttons = new Phaser.ArraySet }, Phaser.VirtualJoystick.prototype.addStick = function(t, e, i, o, n, s) { void 0 === n && (n = "base"), void 0 === s && (s = "stick"); var r = new Phaser.VirtualJoystick.Stick(this, t, e, i, o, n, s); return this.sticks.add(r), ++this._pointerTotal > 2 && this.game.input.addPointer(), r }, Phaser.VirtualJoystick.prototype.addDPad = function(t, e, i, o, n, s, r, a, h) { void 0 === n && (n = "neutral"), void 0 === s && (s = "up"), void 0 === r && (r = "down"), void 0 === a && (a = "left"), void 0 === h && (h = "right"); var l = new Phaser.VirtualJoystick.DPad(this, t, e, i, o, n, s, r, a, h); return this.sticks.add(l), ++this._pointerTotal > 2 && this.game.input.addPointer(), l }, Phaser.VirtualJoystick.prototype.removeStick = function(t) { this.sticks.remove(t), t.destroy() }, Phaser.VirtualJoystick.prototype.addButton = function(t, e, i, o, n, s) { void 0 === s && (s = Phaser.VirtualJoystick.CIRC_BUTTON); var r = new Phaser.VirtualJoystick.Button(this, s, t, e, i, o, n); return this.buttons.add(r), ++this._pointerTotal > 2 && this.game.input.addPointer(), r }, Phaser.VirtualJoystick.prototype.removeButton = function(t) { this.buttons.remove(t), t.destroy() }, Phaser.VirtualJoystick.prototype.update = function() { this.sticks.callAll("update"), this.buttons.callAll("update") }, Phaser.VirtualJoystick.prototype.destroy = function() { this.sticks.removeAll(!0), this.buttons.removeAll(!0) }, Phaser.VirtualJoystick.Stick = function(t, e, i, o, n, s, r) { this.pad = t, this.baseFrame = s, this.stickFrame = r, this.position = new Phaser.Point(e, i), this.line = new Phaser.Line(this.position.x, this.position.y, this.position.x, this.position.y), this.baseSprite = this.pad.game.make.sprite(this.position.x, this.position.y, n, s), this.baseSprite.anchor.set(.5), this.stickSprite = this.pad.game.make.sprite(this.position.x, this.position.y, n, r), this.stickSprite.anchor.set(.5), this.baseHitArea = new Phaser.Circle(this.position.x, this.position.y, o), this.stickHitArea = new Phaser.Circle(this.position.x, this.position.y, this.stickSprite.width), this.limitPoint = new Phaser.Point, this.pointer = null, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.onDown = new Phaser.Signal, this.onUp = new Phaser.Signal, this.onMove = new Phaser.Signal, this.onUpdate = new Phaser.Signal, this.timeDown = 0, this.timeUp = 0, this.angle = 0, this.angleFull = 0, this.quadrant = 0, this.octant = 0, this.motionLock = Phaser.VirtualJoystick.NONE, this._distance = o, this._deadZone = .15 * o, this._scale = 1, this._tracking = !1, this._showOnTouch = !1, this.pad.game.stage.addChild(this.baseSprite), this.pad.game.stage.addChild(this.stickSprite), this.pad.game.input.onDown.add(this.checkDown, this), this.pad.game.input.onUp.add(this.checkUp, this), this.pad.game.input.addMoveCallback(this.moveStick, this) }, Phaser.VirtualJoystick.Stick.prototype = { checkDown: function(t) { this.enabled && this.isUp && (this.pointer = t, this.motionLock === Phaser.VirtualJoystick.NONE ? this.line.end.copyFrom(this.pointer) : this.motionLock === Phaser.VirtualJoystick.HORIZONTAL ? this.line.end.x = this.pointer.x : this.motionLock === Phaser.VirtualJoystick.VERTICAL && (this.line.end.y = this.pointer.y), this._showOnTouch ? (this.line.start.copyFrom(t), this.posX = t.x, this.posY = t.y, this.visible = !0, this.setDown()) : this.stickHitArea.contains(t.x, t.y) && (this.line.length <= this.deadZone ? this._tracking = !0 : (this.setDown(), this.moveStick()))) }, checkUp: function(t) { t === this.pointer && (this.pointer = null, this.stickHitArea.x = this.position.x, this.stickHitArea.y = this.position.y, this.stickSprite.x = this.stickHitArea.x, this.stickSprite.y = this.stickHitArea.y, this.line.end.copyFrom(this.line.start), this.isDown = !1, this.isUp = !0, this.timeUp = this.pad.game.time.time, this.onUp.dispatch(this, t), this._showOnTouch && (this.visible = !1)) }, setDown: function() { this.isDown = !0, this.isUp = !1, this.timeDown = this.pad.game.time.time, this.timeUp = 0, this._tracking = !1, this.checkArea(), this.onDown.dispatch(this, this.pointer) }, checkArea: function() { this.angle = this.pad.game.math.radToDeg(this.line.angle), this.angleFull = this.angle, this.angleFull < 0 && (this.angleFull += 360), this.octant = 45 * Math.round(this.angleFull / 45), this.quadrant = this.angleFull >= 45 && this.angleFull < 135 ? 1 : this.angleFull >= 135 && this.angleFull < 225 ? 2 : this.angleFull >= 225 && this.angleFull < 315 ? 3 : 0 }, moveStick: function() { this.pointer && (this.isDown || this._tracking) && (this.motionLock === Phaser.VirtualJoystick.NONE ? this.line.end.copyFrom(this.pointer) : this.motionLock === Phaser.VirtualJoystick.HORIZONTAL ? this.line.end.x = this.pointer.x : this.motionLock === Phaser.VirtualJoystick.VERTICAL && (this.line.end.y = this.pointer.y), this.checkArea(), !this.isDown && this.line.length <= this.deadZone || (this._tracking && this.setDown(), this.line.length < this.baseHitArea.radius ? this.motionLock === Phaser.VirtualJoystick.NONE ? (this.stickHitArea.x = this.pointer.x, this.stickHitArea.y = this.pointer.y) : this.motionLock === Phaser.VirtualJoystick.HORIZONTAL ? this.stickHitArea.x = this.pointer.x : this.motionLock === Phaser.VirtualJoystick.VERTICAL && (this.stickHitArea.y = this.pointer.y) : (this.baseHitArea.circumferencePoint(this.line.angle, !1, this.limitPoint), this.motionLock === Phaser.VirtualJoystick.NONE ? (this.stickHitArea.x = this.limitPoint.x, this.stickHitArea.y = this.limitPoint.y) : this.motionLock === Phaser.VirtualJoystick.HORIZONTAL ? this.stickHitArea.x = this.limitPoint.x : this.motionLock === Phaser.VirtualJoystick.VERTICAL && (this.stickHitArea.y = this.limitPoint.y)), this.stickSprite.x = this.stickHitArea.x, this.stickSprite.y = this.stickHitArea.y, this.onMove.dispatch(this, this.force, this.forceX, this.forceY))) }, update: function() { this.isDown && !this._tracking && this.onUpdate.dispatch(this, this.force, this.forceX, this.forceY) }, alignBottomLeft: function(t) { void 0 === t && (t = 0); var e = this.baseSprite.width / 2 + t,
                i = this.baseSprite.height / 2 + t;
            this.posX = e, this.posY = this.pad.game.height - i }, alignBottomRight: function(t) { void 0 === t && (t = 0); var e = this.baseSprite.width / 2 + t,
                i = this.baseSprite.height / 2 + t;
            this.posX = this.pad.game.width - e, this.posY = this.pad.game.height - i }, destroy: function() { this.pad.game.input.onDown.remove(this.checkDown, this), this.pad.game.input.onUp.remove(this.checkUp, this); for (var t = this.pad.game.input.moveCallbacks, e = 0; e < t.length; e++)
                if (t.callback === this.moveStick && t.context === this) { t.splice(e, 1); break } this.stickSprite.destroy(), this.baseSprite.destroy(), this.stickHitArea = null, this.baseHitArea = null, this.line = null, this.limitPoint = null, this.onDown.dispose(), this.onUp.dispose(), this.onMove.dispose(), this.onUpdate.dispose(), this.pointer = null, this._scale = null, this.pad = null }, debug: function(t, e, i) { void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = this.baseSprite.right); var o = this.pad.game.debug; if (t && (o.context.lineWidth = 2, o.geom(this.baseHitArea, "rgba(255, 0, 0, 1)", !1), o.geom(this.stickHitArea, "rgba(0, 255, 0, 1)", !1), o.geom(this.line, "rgba(255, 255, 0, 1)"), o.context.lineWidth = 1), e) { var n = o.renderShadow,
                    s = i,
                    r = this.baseSprite.y - 114;
                o.renderShadow = !0, o.text("Force: " + this.force.toFixed(2), s, r), o.text("ForceX: " + this.forceX.toFixed(2), s, r + 24), o.text("ForceY: " + this.forceY.toFixed(2), s, r + 48), o.text("Rotation: " + this.rotation.toFixed(2), s, r + 96), o.text("Angle: " + this.angle.toFixed(2), s, r + 120), o.text("Distance: " + this.distance, s, r + 172), o.text("Quadrant: " + this.quadrant, s, r + 196), o.text("Octant: " + this.octant, s, r + 220), o.renderShadow = n } } }, Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "rotation", { get: function() { return this.line.angle } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "posX", { get: function() { return this.position.x }, set: function(t) { this.position.x !== t && (this.position.x = t, this.baseSprite.x = t, this.stickSprite.x = t, this.baseHitArea.x = t, this.stickHitArea.x = t, this.line.start.x = t, this.line.end.x = t) } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "posY", { get: function() { return this.position.y }, set: function(t) { this.position.y !== t && (this.position.y = t, this.baseSprite.y = t, this.stickSprite.y = t, this.baseHitArea.y = t, this.stickHitArea.y = t, this.line.start.y = t, this.line.end.y = t) } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "force", { get: function() { return Math.min(1, this.line.length / this.distance * 2) } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "forceX", { get: function() { return this.force * this.x } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "forceY", { get: function() { return this.force * this.y } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "x", { get: function() { return this.line.angle >= 0 ? this.line.angle <= 1.5707963267948966 ? (1.5707963267948966 - this.line.angle) / 1.5707963267948966 : (3.141592653589793 - this.line.angle) / 3.141592653589793 * 2 - 1 : this.line.angle >= -1.5707963267948966 ? Math.abs(-1.5707963267948966 - this.line.angle) / 1.5707963267948966 : Math.abs(-3.141592653589793 - this.line.angle) / 3.141592653589793 * 2 - 1 } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "y", { get: function() { return this.line.angle >= 0 ? 1 - Math.abs(1.5707963267948966 - this.line.angle) / 1.5707963267948966 : Math.abs(-1.5707963267948966 - this.line.angle) / 1.5707963267948966 - 1 } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "filterX", { get: function() { if (0 === this.x) return .5; var t = Math.abs(this.forceX) / 2; return this.x < 0 ? (.5 - t).toFixed(2) : (.5 + t).toFixed(2) } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "filterY", { get: function() { if (0 === this.y) return .5; var t = Math.abs(this.forceY) / 2; return this.y < 0 ? 1 - (.5 - t).toFixed(2) : 1 - (.5 + t).toFixed(2) } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "alpha", { get: function() { return this.stickSprite.alpha }, set: function(t) { this.stickSprite.alpha = t, this.baseSprite.alpha = t } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "visible", { get: function() { return this.stickSprite.visible }, set: function(t) { this.stickSprite.visible = t, this.baseSprite.visible = t } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "distance", { get: function() { return this._distance * this._scale }, set: function(t) { this._distance !== t && (this._distance = t) } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "deadZone", { get: function() { return this._deadZone * this._scale }, set: function(t) { this._deadZone = t } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "scale", { get: function() { return this._scale }, set: function(t) { this._scale !== t && (this.stickSprite.scale.set(t), this.baseSprite.scale.set(t), this.baseHitArea.setTo(this.position.x, this.position.y, this.distance * t), this.stickHitArea.setTo(this.position.x, this.position.y, this.stickSprite.width), this._scale = t) } }), Object.defineProperty(Phaser.VirtualJoystick.Stick.prototype, "showOnTouch", { get: function() { return this._showOnTouch }, set: function(t) { this._showOnTouch !== t && (this._showOnTouch = t, this._showOnTouch && this.visible && (this.visible = !1)) } }), Phaser.VirtualJoystick.Button = function(t, e, i, o, n, s, r) { this.pad = t, this.upFrame = s, this.downFrame = r, this.sprite = this.pad.game.make.sprite(i, o, n, s), this.sprite.anchor.set(.5), e === Phaser.VirtualJoystick.CIRC_BUTTON ? this.hitArea = new Phaser.Circle(this.sprite.x, this.sprite.y, this.sprite.width) : e === Phaser.VirtualJoystick.RECT_BUTTON && (this.hitArea = new Phaser.Rectangle(this.sprite.x, this.sprite.y, this.sprite.width, this.sprite.height)), this.pointer = null, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.onDown = new Phaser.Signal, this.onUp = new Phaser.Signal, this.timeDown = 0, this.timeUp = 0, this.repeatRate = 0, this.key = null, this._timeNext = 0, this._scale = 1, this.pad.game.stage.addChild(this.sprite), this.pad.game.input.onDown.add(this.checkDown, this), this.pad.game.input.onUp.add(this.checkUp, this) }, Phaser.VirtualJoystick.Button.prototype = { addKey: function(t) { if (this.key) { if (this.key.keyCode === t) return !1;
                this.key.onDown.removeAll(), this.key.onUp.removeAll(), this.pad.game.input.keyboard.removeKey(this.key), this.key = null } return t && (this.key = this.pad.game.input.keyboard.addKey(t), this.key.onDown.add(this.keyDown, this), this.key.onUp.add(this.keyUp, this)), this.key }, keyDown: function() { this.isDown || (this.sprite.frameName = this.downFrame, this.isDown = !0, this.isUp = !1, this.timeDown = this.pad.game.time.time, this.timeUp = 0, this.onDown.dispatch(this, this.key)) }, keyUp: function() { this.isDown && (this.sprite.frameName = this.upFrame, this.isDown = !1, this.isUp = !0, this.timeUp = this.pad.game.time.time, this.onUp.dispatch(this, this.key, this.duration)) }, checkDown: function(t) { this.enabled && this.isUp && this.hitArea.contains(t.x, t.y) && (this.pointer = t, this.sprite.frameName = this.downFrame, this.isDown = !0, this.isUp = !1, this.timeDown = this.pad.game.time.time, this.timeUp = 0, this.onDown.dispatch(this, t)) }, checkUp: function(t) { t === this.pointer && (this.pointer = null, this.sprite.frameName = this.upFrame, this.isDown = !1, this.isUp = !0, this.timeUp = this.pad.game.time.time, this.onUp.dispatch(this, t, this.duration)) }, update: function() { this.repeatRate > 0 && this.isDown && this.pad.game.time.time >= this._timeNext && (this.onDown.dispatch(this, this.pointer), this._timeNext = this.pad.game.time.time + this.repeatRate) }, alignBottomLeft: function(t) { void 0 === t && (t = 0); var e = this.sprite.width / 2 + t,
                i = this.sprite.height / 2 + t;
            this.posX = e, this.posY = this.pad.game.height - i }, alignBottomRight: function(t) { void 0 === t && (t = 0); var e = this.sprite.width / 2 + t,
                i = this.sprite.height / 2 + t;
            this.posX = this.pad.game.width - e, this.posY = this.pad.game.height - i }, destroy: function() { this.pad.game.input.onDown.remove(this.checkDown, this), this.pad.game.input.onUp.remove(this.checkUp, this), this.sprite.destroy(), this.onDown.dispose(), this.onUp.dispose(), this.hitArea = null, this.pointer = null, this._scale = null, this.pad = null } }, Object.defineProperty(Phaser.VirtualJoystick.Button.prototype, "posX", { get: function() { return this.sprite.x }, set: function(t) { this.sprite.x !== t && (this.sprite.x = t, this.hitArea.x = t) } }), Object.defineProperty(Phaser.VirtualJoystick.Button.prototype, "posY", { get: function() { return this.sprite.y }, set: function(t) { this.sprite.y !== t && (this.sprite.y = t, this.hitArea.y = t) } }), Object.defineProperty(Phaser.VirtualJoystick.Button.prototype, "alpha", { get: function() { return this.sprite.alpha }, set: function(t) { this.sprite.alpha = t } }), Object.defineProperty(Phaser.VirtualJoystick.Button.prototype, "visible", { get: function() { return this.sprite.visible }, set: function(t) { this.sprite.visible = t } }), Object.defineProperty(Phaser.VirtualJoystick.Button.prototype, "scale", { get: function() { return this._scale }, set: function(t) { this._scale !== t && (this.sprite.scale.set(t), this.hitArea.setTo(this.sprite.x, this.sprite.y, this.sprite.width), this._scale = t) } }), Object.defineProperty(Phaser.VirtualJoystick.Button.prototype, "duration", { get: function() { return this.isUp ? this.timeUp - this.timeDown : this.game.time.time - this.timeDown } }), Phaser.VirtualJoystick.DPad = function(t, e, i, o, n, s, r, a, h, l) { this.pad = t, this.neutralFrame = s, this.upFrame = r, this.downFrame = a, this.leftFrame = h, this.rightFrame = l, this.position = new Phaser.Point(e, i), this.line = new Phaser.Line(this.position.x, this.position.y, this.position.x, this.position.y), this.sprite = this.pad.game.make.sprite(e, i, n, s), this.sprite.anchor.set(.5), this.baseHitArea = new Phaser.Circle(this.position.x, this.position.y, o), this.stickHitArea = new Phaser.Circle(this.position.x, this.position.y, this.sprite.width), this.limitPoint = new Phaser.Point, this.pointer = null, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.onDown = new Phaser.Signal, this.onUp = new Phaser.Signal, this.onMove = new Phaser.Signal, this.onUpdate = new Phaser.Signal, this.timeDown = 0, this.timeUp = 0, this.angle = 0, this.angleFull = 0, this.quadrant = 0, this.octant = 0, this.direction = Phaser.NONE, this._distance = o, this._deadZone = .15 * o, this._scale = 1, this._tracking = !1, this._showOnTouch = !1, this.pad.game.stage.addChild(this.sprite), this.pad.game.input.onDown.add(this.checkDown, this), this.pad.game.input.onUp.add(this.checkUp, this), this.pad.game.input.addMoveCallback(this.moveStick, this) }, Phaser.VirtualJoystick.DPad.prototype = { checkDown: function(t) { this.enabled && this.isUp && (this.pointer = t, this.line.end.copyFrom(t), this._showOnTouch ? (this.line.start.copyFrom(t), this.posX = t.x, this.posY = t.y, this.visible = !0, this.setDown()) : this.stickHitArea.contains(t.x, t.y) && (this.line.length <= this.deadZone ? this._tracking = !0 : (this.setDown(), this.moveStick()))) }, checkUp: function(t) { t === this.pointer && (this.pointer = null, this.stickHitArea.x = this.position.x, this.stickHitArea.y = this.position.y, this.sprite.frameName = this.neutralFrame, this.line.end.copyFrom(this.line.start), this.isDown = !1, this.isUp = !0, this.direction = Phaser.NONE, this.timeUp = this.pad.game.time.time, this.onUp.dispatch(this, t), this._showOnTouch && (this.visible = !1)) }, setDown: function() { this.isDown = !0, this.isUp = !1, this.timeDown = this.pad.game.time.time, this.timeUp = 0, this._tracking = !1, this.checkArea(), this.onDown.dispatch(this, this.pointer) }, checkArea: function() { this.angle = this.pad.game.math.radToDeg(this.line.angle), this.angleFull = this.angle, this.angleFull < 0 && (this.angleFull += 360), this.octant = 45 * Math.round(this.angleFull / 45), this.quadrant = this.angleFull >= 45 && this.angleFull < 135 ? 1 : this.angleFull >= 135 && this.angleFull < 225 ? 2 : this.angleFull >= 225 && this.angleFull < 315 ? 3 : 0 }, moveStick: function() { return this.pointer && (this.isDown || this._tracking) ? (this.line.end.copyFrom(this.pointer), this.checkArea(), !this.isDown && this.line.length <= this.deadZone ? (this.direction = Phaser.NONE, void(this.sprite.frameName = this.neutralFrame)) : (this._tracking && this.setDown(), this.line.length < this.baseHitArea.radius ? this.motionLock === Phaser.VirtualJoystick.NONE ? (this.stickHitArea.x = this.pointer.x, this.stickHitArea.y = this.pointer.y) : this.motionLock === Phaser.VirtualJoystick.HORIZONTAL ? this.stickHitArea.x = this.pointer.x : this.motionLock === Phaser.VirtualJoystick.VERTICAL && (this.stickHitArea.y = this.pointer.y) : (this.baseHitArea.circumferencePoint(this.line.angle, !1, this.limitPoint), this.motionLock === Phaser.VirtualJoystick.NONE ? (this.stickHitArea.x = this.limitPoint.x, this.stickHitArea.y = this.limitPoint.y) : this.motionLock === Phaser.VirtualJoystick.HORIZONTAL ? this.stickHitArea.x = this.limitPoint.x : this.motionLock === Phaser.VirtualJoystick.VERTICAL && (this.stickHitArea.y = this.limitPoint.y)), 1 === this.quadrant ? (this.sprite.frameName = this.downFrame, this.direction = Phaser.DOWN) : 2 === this.quadrant ? (this.sprite.frameName = this.leftFrame, this.direction = Phaser.LEFT) : 3 === this.quadrant ? (this.sprite.frameName = this.upFrame, this.direction = Phaser.UP) : (this.sprite.frameName = this.rightFrame, this.direction = Phaser.RIGHT), void this.onMove.dispatch(this, this.x, this.y))) : (this.direction = Phaser.NONE, void(this.sprite.frameName = this.neutralFrame)) }, update: function() { this.isDown && !this._tracking && this.onUpdate.dispatch(this, this.x, this.y) }, alignBottomLeft: function(t) { void 0 === t && (t = 0); var e = this.sprite.width / 2 + t,
                i = this.sprite.height / 2 + t;
            this.posX = e, this.posY = this.pad.game.height - i }, alignBottomRight: function(t) { void 0 === t && (t = 0); var e = this.sprite.width / 2 + t,
                i = this.sprite.height / 2 + t;
            this.posX = this.pad.game.width - e, this.posY = this.pad.game.height - i }, destroy: function() { this.pad.game.input.onDown.remove(this.checkDown, this), this.pad.game.input.onUp.remove(this.checkUp, this); for (var t = this.pad.game.input.moveCallbacks, e = 0; e < t.length; e++)
                if (t.callback === this.moveStick && t.context === this) { t.splice(e, 1); break } this.sprite.destroy(), this.stickHitArea = null, this.baseHitArea = null, this.line = null, this.limitPoint = null, this.onDown.dispose(), this.onUp.dispose(), this.pointer = null, this._scale = null, this.pad = null }, debug: function(t, e, i) { void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = this.sprite.right); var o = this.pad.game.debug; if (t && (o.context.lineWidth = 2, o.geom(this.baseHitArea, "rgba(255, 0, 0, 1)", !1), o.geom(this.stickHitArea, "rgba(0, 255, 0, 1)", !1), o.geom(this.line, "rgba(255, 255, 0, 1)"), o.context.lineWidth = 1), e) { var n = o.renderShadow,
                    s = i,
                    r = this.sprite.y - 48;
                o.renderShadow = !0, o.text("X: " + this.x, s, r), o.text("Y: " + this.y, s, r + 24), o.text("Distance: " + this.distance, s, r + 48), o.text("Quadrant: " + this.quadrant, s, r + 96), o.text("Octant: " + this.octant, s, r + 120), o.renderShadow = n } } }, Object.defineProperty(Phaser.VirtualJoystick.DPad.prototype, "rotation", { get: function() { return this.line.angle } }), Object.defineProperty(Phaser.VirtualJoystick.DPad.prototype, "posX", { get: function() { return this.position.x }, set: function(t) { this.position.x !== t && (this.position.x = t, this.sprite.x = t, this.baseHitArea.x = t, this.stickHitArea.x = t, this.line.start.x = t, this.line.end.x = t) } }), Object.defineProperty(Phaser.VirtualJoystick.DPad.prototype, "posY", { get: function() { return this.position.y }, set: function(t) { this.position.y !== t && (this.position.y = t, this.sprite.y = t, this.baseHitArea.y = t, this.stickHitArea.y = t, this.line.start.y = t, this.line.end.y = t) } }), Object.defineProperty(Phaser.VirtualJoystick.DPad.prototype, "x", { get: function() { return this.direction === Phaser.LEFT ? -1 : this.direction === Phaser.RIGHT ? 1 : 0 } }), Object.defineProperty(Phaser.VirtualJoystick.DPad.prototype, "y", { get: function() { return this.direction === Phaser.UP ? -1 : this.direction === Phaser.DOWN ? 1 : 0 } }), Object.defineProperty(Phaser.VirtualJoystick.DPad.prototype, "alpha", { get: function() { return this.sprite.alpha }, set: function(t) { this.sprite.alpha = t } }), Object.defineProperty(Phaser.VirtualJoystick.DPad.prototype, "visible", { get: function() { return this.sprite.visible }, set: function(t) { this.sprite.visible = t } }), Object.defineProperty(Phaser.VirtualJoystick.DPad.prototype, "distance", { get: function() { return this._distance * this._scale }, set: function(t) { this._distance !== t && (this._distance = t) } }), Object.defineProperty(Phaser.VirtualJoystick.DPad.prototype, "deadZone", { get: function() { return this._deadZone * this._scale }, set: function(t) { this._deadZone = t } }), Object.defineProperty(Phaser.VirtualJoystick.DPad.prototype, "scale", { get: function() { return this._scale }, set: function(t) { this._scale !== t && (this.sprite.scale.set(t), this.baseHitArea.setTo(this.position.x, this.position.y, this.distance * t), this.stickHitArea.setTo(this.position.x, this.position.y, this.sprite.width), this._scale = t) } }), Object.defineProperty(Phaser.VirtualJoystick.DPad.prototype, "showOnTouch", { get: function() { return this._showOnTouch }, set: function(t) { this._showOnTouch !== t && (this._showOnTouch = t, this._showOnTouch && this.visible && (this.visible = !1)) } }),
    function(t) {
        function e(t, e) { for (var i = t.length; i--;)
                if (t[i] === e) return i; return -1 }

        function i(t, e) { if (t.length != e.length) return !1; for (var i = 0; i < t.length; i++)
                if (t[i] !== e[i]) return !1; return !0 }

        function o(t) { for (u in f) f[u] = t[x[u]] }

        function n(t) {
            [32, 37, 38, 39, 40].indexOf(t.keyCode) > -1 && t.preventDefault(); var i, n, s, r, l, c; if (i = t.keyCode, -1 == e(v, i) && v.push(i), 93 != i && 224 != i || (i = 91), i in f) { f[i] = !0; for (s in b) b[s] == i && (a[s] = !0) } else if (o(t), a.filter.call(this, t) && i in m)
                for (c = h(), r = 0; r < m[i].length; r++)
                    if ((n = m[i][r]).scope == c || "all" == n.scope) { l = n.mods.length > 0; for (s in f)(!f[s] && e(n.mods, +s) > -1 || f[s] && -1 == e(n.mods, +s)) && (l = !1);
                        (0 != n.mods.length || f[16] || f[18] || f[17] || f[91]) && !l || !1 === n.method(t, n) && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation && t.stopPropagation(), t.cancelBubble && (t.cancelBubble = !0)) } }

        function s(t) { var i, o = t.keyCode,
                n = e(v, o); if (n >= 0 && v.splice(n, 1), 93 != o && 224 != o || (o = 91), o in f) { f[o] = !1; for (i in b) b[i] == o && (a[i] = !1) } }

        function r() { for (u in f) f[u] = !1; for (u in b) a[u] = !1 }

        function a(t, e, i) { var o, n;
            o = l(t), void 0 === i && (i = e, e = "all"); for (var s = 0; s < o.length; s++) n = [], (t = o[s].split("+")).length > 1 && (n = c(t), t = [t[t.length - 1]]), t = t[0], (t = _(t)) in m || (m[t] = []), m[t].push({ shortcut: o[s], scope: e, method: i, key: o[s], mods: n }) }

        function h() { return y || "all" }

        function l(t) { var e; return t = t.replace(/\s/g, ""), "" == (e = t.split(","))[e.length - 1] && (e[e.length - 2] += ","), e }

        function c(t) { for (var e = t.slice(0, t.length - 1), i = 0; i < e.length; i++) e[i] = b[e[i]]; return e }

        function d(t, e, i) { t.addEventListener ? t.addEventListener(e, i, !1) : t.attachEvent && t.attachEvent("on" + e, function() { i(p.event) }) } var u, p = window,
            m = {},
            f = { 16: !1, 18: !1, 17: !1, 91: !1 },
            y = "all",
            b = { "⇧": 16, shift: 16, "⌥": 18, alt: 18, option: 18, "⌃": 17, ctrl: 17, control: 17, "⌘": 91, command: 91 },
            g = { backspace: 8, tab: 9, clear: 12, enter: 13, return: 13, esc: 27, escape: 27, space: 32, left: 37, up: 38, right: 39, down: 40, del: 46, delete: 46, home: 36, end: 35, pageup: 33, pagedown: 34, ",": 188, ".": 190, "/": 191, "`": 192, "-": 189, "=": 187, ";": 186, "'": 222, "[": 219, "]": 221, "\\": 220 },
            _ = function(t) { return g[t] || t.toUpperCase().charCodeAt(0) },
            v = []; for (u = 1; u < 20; u++) g["f" + u] = 111 + u; var x = { 16: "shiftKey", 18: "altKey", 17: "ctrlKey", 91: "metaKey" }; for (u in b) a[u] = !1;
        d(p, "keydown", function(t) { n(t) }), d(p, "keyup", s), d(document, "keydown", function(t) { n(t) }), d(document, "keyup", s), d(p, "focus", r), d(document, "focus", r); var S = t.key;
        t.key = a, t.key.setScope = function(t) { y = t || "all" }, t.key.getScope = h, t.key.deleteScope = function(t) { var e, i, o; for (e in m)
                for (i = m[e], o = 0; o < i.length;) i[o].scope === t ? i.splice(o, 1) : o++ }, t.key.filter = function(t) { var e = (t.target || t.srcElement).tagName; return !("INPUT" == e || "SELECT" == e || "TEXTAREA" == e) }, t.key.isPressed = function(t) { return "string" == typeof t && (t = _(t)), -1 != e(v, t) }, t.key.getPressedKeyCodes = function() { return v.slice(0) }, t.key.noConflict = function() { var e = t.key; return t.key = S, e }, t.key.unbind = function(t, e) { var o, n, s, r, a, d = []; for (o = l(t), r = 0; r < o.length; r++) { if ((n = o[r].split("+")).length > 1 && (d = c(n)), t = n[n.length - 1], t = _(t), void 0 === e && (e = h()), !m[t]) return; for (s = 0; s < m[t].length; s++)(a = m[t][s]).scope === e && i(a.mods, d) && (m[t][s] = {}) } }, "undefined" != typeof module && (module.exports = a), forceFocus = function() { p.focus(), setTimeout(forceFocus, 1e3) }, forceFocus() }(this);
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Ph2;
! function(t) { var e;! function(t) { t[t.STOPPED = 0] = "STOPPED", t[t.PLAYING = 1] = "PLAYING", t[t.PAUSED = 2] = "PAUSED", t[t.AUTO_PAUSED = 3] = "AUTO_PAUSED", t[t.BATCH_PAUSED = 4] = "BATCH_PAUSED" }(e = t.AnimationStatus || (t.AnimationStatus = {})); var i = function() {
        function t(t, i, o, n) { this.initValues = [], this.name = t, this.speed = i, this.parent = o, this.loop = n, this.status = e.STOPPED, this.loopCount = 0, this.onComplete = new Phaser.Signal, this.onLoop = new Phaser.Signal, this.onStart = new Phaser.Signal, this.onEvent = new Phaser.Signal, this.timeline = new TimelineMax({ paused: !0, autoRemoveChildren: !1 }), this.timeline.eventCallback("onComplete", this.onCompleteCallback, null, this), this.timeline.eventCallback("onRepeat", this.onLoopCallback, null, this), this.timeline.eventCallback("onStart", this.onStartCallback, null, this) } return t.prototype.onCompleteCallback = function() { this.status = e.STOPPED, this.onComplete.dispatch(this.parent, this) }, t.prototype.onStartCallback = function() { this.onStart.dispatch(this.parent, this) }, t.prototype.onLoopCallback = function() { this.loopCount++, this.onLoop.dispatch(this.parent, this) }, t.prototype.onEventCallback = function(t) { this.onEvent.dispatch(t, this.parent, this) }, t.prototype.addTimelineChild = function(t) { this.timeline.add(t, 0), t.resume() }, t.prototype.play = function(t, i) { if (this.timeline.invalidate(), this.initValues)
                for (var o = 0; o < this.initValues.length; o++) { var n = this.initValues[o];
                    n.target[n.property] = n.value }
            return t = void 0 !== t ? t : 1, void 0 === i && (i = this.loop), i ? (this.loopCount = 0, this.timeline.repeat(-1)) : this.timeline.repeat(0), this.timeline.timeScale(t), this.timeline.seek(this.timeline.duration()), this.timeline.play(0), this.status = e.PLAYING, this }, t.prototype.stop = function(t, i) { var o = !1;
            void 0 !== i && (o = !i), void 0 !== t ? t ? this.timeline.pause(this.timeline.duration(), o) : this.timeline.pause(null, o) : this.timeline.pause(this.timeline.duration(), o), this.removeListeners(), this.status = e.STOPPED }, t.prototype.isPlaying = function() { return this.status === e.PLAYING }, t.prototype.isStopped = function() { return this.status === e.STOPPED }, t.prototype.isPaused = function() { return this.status === e.PAUSED }, t.prototype.pause = function() { this.status !== e.PAUSED && (this.status = e.PAUSED, this.timeline.pause()) }, t.prototype.resume = function() { this.status !== e.PAUSED && this.status !== e.BATCH_PAUSED || (this.status = e.PLAYING, this.timeline.play()) }, t.prototype.autoPause = function() { this.status === e.PLAYING && (this.status = e.AUTO_PAUSED, this.timeline.pause()) }, t.prototype.autoResume = function() { this.status === e.AUTO_PAUSED && (this.status = e.PLAYING, this.timeline.play()) }, t.prototype.batchPause = function() { this.status === e.PLAYING && (this.status = e.BATCH_PAUSED, this.timeline.pause()) }, t.prototype.batchResume = function() { this.status === e.BATCH_PAUSED && (this.status = e.PLAYING, this.timeline.play()) }, t.prototype.addEvent = function(t) { this.timeline.addCallback(this.onEventCallback, t.frame / 1e3, [t.name], this) }, t.prototype.removeListeners = function() { this.onLoop.removeAll(), this.onEvent.removeAll(), this.onStart.removeAll(), this.onComplete.removeAll() }, t.prototype.changeFrame = function(t, e) { t.frameName = e }, t.prototype.checkTimelineDuration = function() { 0 === this.timeline.duration() && this.timeline.addCallback(function() {}, "+=0.0001") }, t.prototype.getTimelineMax = function() { return this.timeline }, t.prototype.addInitValue = function(t, e, i) { this.initValues.push({ target: t, property: e, value: i }) }, t.prototype.destroy = function() { this.removeListeners(), this.timeline.eventCallback("onComplete", null), this.timeline.eventCallback("onRepeat", null), this.timeline.eventCallback("onStart", null), this.timeline.vars.onCompleteScope = null, this.timeline.vars.onRepeatScope = null, this.timeline.vars.onStartScope = null, this.initValues.length = 0, this.initValues = null, this.timeline.kill(), this.timeline = null }, t }();
    t.Animation = i }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function e(e) { this.game = e, this.cache = new t.AnimationCache(this.game), this.scale = 1, this.pauseAllSignal = new Phaser.Signal, this.resumeAllSignal = new Phaser.Signal, this.stopAllSignal = new Phaser.Signal } return e.prototype.setGameScale = function(t) { this.scale = t }, Object.defineProperty(e.prototype, "gameScale", { get: function() { return this.scale }, enumerable: !0, configurable: !0 }), e.prototype.pauseAll = function() { this.pauseAllSignal.dispatch() }, e.prototype.resumeAll = function() { this.resumeAllSignal.dispatch() }, e.prototype.stopAll = function(t) { var e = !0;
            void 0 !== t && (e = t), this.stopAllSignal.dispatch(e) }, e.prototype.getAnimationData = function(t) { var e = this.game.ph2AnimationManager.cache.getAnimationData(t); return e || (e = this.getAnimationDataFromJSON(t)) && this.cache.saveAnimationData(t, e), e }, e.prototype.getAnimationObject = function(t, e) { var i = this.getAnimationData(t); return this.createTree(i.hierarchy, e, null) }, e.prototype.getAnimationDataFromJSON = function(t) { var e = this.game.cache.getJSON(t); return e ? this.generateAnimationData(e) : null }, e.prototype.generateAnimationData = function(e) { var i = e.hierarchy,
                o = e.properties,
                n = this.createCacheAnimationDataTree(i, o, null, null); return new t.AnimationData(n) }, e.prototype.createCacheAnimationDataTree = function(t, e, i, o) { var n = null; if (t) { var s = t.name; if (n = this.createCacheNode(t, e, t.animations, i, o), t.children) { o = null !== o ? 0 === o.length ? s : o + "/" + s : ""; for (var r = t.children, a = 0; a < r.length; a++) { var h = this.createCacheAnimationDataTree(r[a], e, n, o);
                        h && n.addChild(h) } } } return n }, e.prototype.createCacheNode = function(e, i, o, n, s) { var r = e.name,
                a = r;
            s && (a = s + "/" + r); var h = null; if (null === n)(h = new t.CacheAnimationElementGroup).name = r;
            else { var l = i[a],
                    c = l.type; "sprite" === c ? ((h = new t.CacheAnimationElementSprite).name = r, h.textureName = l.file, void 0 !== l.anchor && (h.anchor.x = l.anchor.x, h.anchor.y = l.anchor.y), void 0 !== l.angle && (h.angle = l.angle), void 0 !== l.scale && (h.scale.x = l.scale.x, h.scale.y = l.scale.y), void 0 !== l.color && (h.tint = Phaser.Color.hexToRGB(l.color)), void 0 !== l.alpha && (h.alpha = l.alpha), void 0 !== l.position && (h.position.x = l.position.x, h.position.y = l.position.y)) : "container" === c ? ((h = new t.CacheAnimationElementGroup).name = r, void 0 !== l.position && (h.position.x = l.position.x, h.position.y = l.position.y), void 0 !== l.angle && (h.angle = l.angle), void 0 !== l.scale && (h.scale.x = l.scale.x, h.scale.y = l.scale.y), void 0 !== l.alpha && (h.alpha = l.alpha)) : "text" === c && ((h = new t.CacheAnimationElementText).name = r, void 0 !== l.anchor && (h.anchor.x = l.anchor.x, h.anchor.y = l.anchor.y), void 0 !== l.angle && (h.angle = l.angle), void 0 !== l.scale && (h.scale.x = l.scale.x, h.scale.y = l.scale.y), void 0 !== l.color && (h.tint = l.color), void 0 !== l.alpha && (h.alpha = l.alpha), void 0 !== l.position && (h.position.x = l.position.x, h.position.y = l.position.y), void 0 !== l.font && (h.fontName = l.font.name, h.fontSize = l.font.fontSize), void 0 !== l.text && (h.text = l.text), void 0 !== l.align && (h.align = l.align), void 0 !== l.stroke && (h.stroke = l.stroke), void 0 !== l.strokeThickness && (h.strokeThickness = l.strokeThickness)) } if (o)
                for (var d = 0; d < o.length; d++) this.addCacheAnimation(h, o[d]); return h }, e.prototype.addCacheAnimation = function(e, i) { var o = this.game.cache.getJSON(i); if (o) { var n = void 0 !== o.speed ? o.speed : 1,
                    s = void 0 !== o.mode ? o.mode : null,
                    r = o.data,
                    a = o.events,
                    h = t.AnimationMode.NORMAL;
                s && "loop" === s.toLowerCase() && (h = t.AnimationMode.LOOP), e.addAnimation(this.createCacheTimelineForAnimation(i, r, n, h, a)) } }, e.prototype.createCacheTimelineForAnimation = function(e, i, o, n, s) { var r = new t.CacheAnimation(e, o);
            r.mode = n; for (var a = Object.keys(i), h = 0; h < a.length; h++)
                for (var l = a[h], c = i[l], d = Object.keys(c), u = 0; u < d.length; u++) { var p = d[u],
                        m = c[p],
                        f = this.createCacheTimelineForProperty(l, p, m);
                    r.addTimeline(f) }
            if (s && s.length > 0)
                for (h = 0; h < s.length; h++) { var y = new t.CacheEvent;
                    y.frame = s[h].frame, y.name = s[h].name, r.addEvent(y) }
            return r }, e.prototype.createCacheTimelineForProperty = function(e, i, o) { for (var n = new t.CacheTimeline(e, i), s = 0; s < o.length; s++) { var r = new t.CacheFrame;
                r.frame = o[s].frame, r.value = o[s].value, n.addFrame(r) } return n }, e.prototype.createTree = function(t, e, i) { var o = null; if (t) { if (o = this.createNode(t, e, i), t.children)
                    for (var n = t.children, s = 0; s < n.length; s++) { var r = this.createTree(n[s], e, o);
                        r && o.addChild(r) }
                if (t.animations && t.animations.length > 0)
                    for (var a = t.animations, h = 0; h < a.length; h++) this.addAnimationToNode(o, a[h]) } return o }, e.prototype.createNode = function(e, i, o) { var n = e.name,
                s = null; return null === o ? (s = new t.AnimationGroup(this.game)).name = n : e instanceof t.CacheAnimationElementSprite ? ((s = new t.AnimationSprite(this.game, i, e.textureName)).name = n, s.anchor.x = e.anchor.x, s.anchor.y = e.anchor.y, s.angle = e.angle, s.scale.x = e.scale.x, s.scale.y = e.scale.y, s.alpha = e.alpha, s.tint = e.tint, s.x = e.position.x * this.gameScale, s.y = e.position.y * this.gameScale) : e instanceof t.CacheAnimationElementGroup ? ((s = new t.AnimationGroup(this.game)).name = n, s.x = e.position.x * this.gameScale, s.y = e.position.y * this.gameScale, s.angle = e.angle, s.scale.x = e.scale.x, s.scale.y = e.scale.y, s.alpha = e.alpha) : e instanceof t.CacheAnimationElementText && ((s = new t.AnimationText(this.game, e.position.x * this.gameScale, e.position.y * this.gameScale, e.text, { font: e.fontSize * this.gameScale + "px " + e.fontName, fill: e.tint, align: e.align, stroke: e.stroke, strokeThickness: e.strokeThickness * this.gameScale })).name = e.name, s.angle = e.angle, s.anchor.x = e.anchor.x, s.anchor.y = e.anchor.y, s.scale.x = e.scale.x, s.scale.y = e.scale.y, s.alpha = e.alpha), s }, e.prototype.addAnimationToNode = function(e, i) { for (var o = i.mode === t.AnimationMode.LOOP, n = new t.Animation(i.name, i.speed, e, o), s = null, r = null, a = 0; a < i.timelines.length; a++) { var h = i.timelines[a],
                    l = h.target;
                l !== s && (r = "__this__" === l ? e : t.AnimationSystem.findObject(l, e)); for (var c = new TimelineMax({ paused: !0, autoRemoveChildren: !1 }), d = 0, u = 0; u < h.frames.length; u++) { var p = h.frames[u],
                        m = p.frame / 1e3,
                        f = m - d,
                        y = p.value; switch (h.property) {
                        case "scaleX":
                            0 === m ? (n.addInitValue(r, "scaleX", y), c.set(r, { scaleX: y }, 0)) : c.to(r, f, { scaleX: y }); break;
                        case "scaleY":
                            0 === m ? (n.addInitValue(r, "scaleY", y), c.set(r, { scaleY: y }, 0)) : c.to(r, f, { scaleY: y }); break;
                        case "angle":
                            0 === m ? (n.addInitValue(r, "angle", y), c.set(r, { angle: y }, 0)) : c.to(r, f, { angle: y }); break;
                        case "alpha":
                            0 === m ? (n.addInitValue(r, "alpha", y), c.set(r, { alpha: y }, 0)) : c.to(r, f, { alpha: y }); break;
                        case "position":
                            0 === m ? (n.addInitValue(r, "x", y[0] * this.gameScale), n.addInitValue(r, "y", y[1] * this.gameScale), c.set(r, { x: y[0] * this.gameScale, y: y[1] * this.gameScale }, 0)) : c.to(r, f, { x: y[0] * this.gameScale, y: y[1] * this.gameScale }); break;
                        case "x":
                            0 === m ? (n.addInitValue(r, "x", y * this.gameScale), c.set(r, { x: y * this.gameScale }, 0)) : c.to(r, f, { x: y * this.gameScale }); break;
                        case "y":
                            0 === m ? (n.addInitValue(r, "y", y * this.gameScale), c.set(r, { y: y * this.gameScale }, 0)) : c.to(r, f, { y: y * this.gameScale }); break;
                        case "frameName":
                            0 === m && n.addInitValue(r, "frameName", y), c.addCallback(n.changeFrame, m, [r, y], this) } d = m } n.addTimelineChild(c), s = l } if (n.checkTimelineDuration(), i.events && i.events.length > 0)
                for (a = 0; a < i.events.length; a++) n.addEvent(i.events[a]);
            e.ph2Animations.add(n) }, e.findObject = function(t, e) { for (var i = e, o = "/" !== t[0] ? 0 : 1, n = t.split("/"), s = o; s < n.length; s++) { var r = n[s],
                    a = i.children;
                i = null; for (var h = 0, l = a.length; h < l; ++h) { var c = a[h]; if (c.name === r) { i = c; break } } if (!i) return null } return i }, e }();
    t.AnimationSystem = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function t(t) { this.game = t, this.animationData = {} } return t.prototype.getAnimationData = function(t) { var e = this.animationData[t]; return e || null }, t.prototype.saveAnimationData = function(t, e) { this.animationData[t] = e }, t }();
    t.AnimationCache = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function t() { this.animations = [], this.children = [] } return t.prototype.addChild = function(t) { this.children.push(t) }, t.prototype.addAnimation = function(t) { this.animations.push(t) }, t }();
    t.CacheAnimationElement = e; var i = function(t) {
        function e() { var e = t.call(this) || this; return e.anchor = new Phaser.Point(.5, .5), e.angle = 0, e.scale = new Phaser.Point(1, 1), e.tint = 16777215, e.alpha = 1, e.position = new Phaser.Point(0, 0), e } return __extends(e, t), e }(e);
    t.CacheAnimationElementSprite = i; var o = function(t) {
        function e() { var e = t.call(this) || this; return e.position = new Phaser.Point(0, 0), e.angle = 0, e.scale = new Phaser.Point(1, 1), e.alpha = 1, e } return __extends(e, t), e }(e);
    t.CacheAnimationElementGroup = o; var n = function(t) {
        function e() { var e = t.call(this) || this; return e.anchor = new Phaser.Point(.5, .5), e.angle = 0, e.scale = new Phaser.Point(1, 1), e.tint = "#FFFFFF", e.alpha = 1, e.position = new Phaser.Point(0, 0), e.text = "", e.fontName = "Arial", e.fontSize = 24, e.align = "center", e.stroke = "black", e.strokeThickness = 0, e } return __extends(e, t), e }(e);
    t.CacheAnimationElementText = n; var s = function() {
        function t(t, e) { this.name = t, this.timelines = [], this.speed = e, this.events = [] } return t.prototype.addTimeline = function(t) { this.timelines.push(t) }, t.prototype.addEvent = function(t) { this.events.push(t) }, t }();
    t.CacheAnimation = s; var r = function() {
        function t(t, e) { this.target = t, this.property = e, this.frames = [] } return t.prototype.addFrame = function(t) { this.frames.push(t) }, t }();
    t.CacheTimeline = r; var a = function() { return function() {} }();
    t.CacheFrame = a; var h = function() { return function() {} }();
    t.CacheEvent = h; var l = function() { return function(t) { this.hierarchy = t } }();
    t.AnimationData = l;! function(t) { t[t.NORMAL = 0] = "NORMAL", t[t.LOOP = 1] = "LOOP" }(t.AnimationMode || (t.AnimationMode = {})) }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() { return function(t, e) { this.key = t, this.value = e } }();
    t.CacheOrientationProperty = e; var i = function() {
        function i() { this.backup = [], this.portrait = [], this.landscape = [] } return i.prototype.addProperty = function(i, o, n) { null === n ? this.backup.push(new e(i, o)) : n === t.AlignmentScope.LANDSCAPE ? this.landscape.push(new e(i, o)) : n === t.AlignmentScope.PORTRAIT && this.portrait.push(new e(i, o)) }, i }();
    t.CacheOrientationProperties = i; var o = function() {
        function e() { this.children = [], this.animations = [], this.orientationVisibility = t.OrientationType.BOTH, this.platformVisibility = t.PlatformType.BOTH } return e.prototype.addChild = function(t) { this.children.push(t) }, e.prototype.addAlignment = function(e, i, o, s, r, a) { var h = new n;
            h.type = e, h.offset.x = i, h.offset.y = o, h.isAbsoluteX = s, h.isAbsoluteY = r, a === t.AlignmentScope.ALL ? this.alignment = h : a === t.AlignmentScope.PORTRAIT ? this.portraitAlignment = h : a === t.AlignmentScope.LANDSCAPE && (this.landscapeAlignment = h) }, e.prototype.addOrientationProperty = function(t, e, o) { this.orientationProperties || (this.orientationProperties = new i), void 0 !== e && this.orientationProperties.addProperty(t, e, o) }, e.prototype.setOrientationVisibility = function(t) { this.orientationVisibility = t }, e.prototype.setPlatformVisibility = function(t) { this.platformVisibility = t }, e }();
    t.CacheUIElement = o; var n = function() { return function() { this.offset = new Phaser.Point(0, 0), this.isAbsoluteX = !0, this.isAbsoluteY = !0 } }();
    t.CacheAlignment = n; var s = function() { return function(t, e, i, o) { this.top = t, this.bottom = e, this.left = i, this.right = o } }();
    t.CacheSliceData = s; var r = function() { return function(t, e) { this.width = t, this.height = e } }();
    t.CacheTiledData = r; var a = function(t) {
        function e() { var e = t.call(this) || this; return e.anchor = new Phaser.Point(.5, .5), e.angle = 0, e.scale = new Phaser.Point(1, 1), e.tint = 16777215, e.alpha = 1, e.position = new Phaser.Point(0, 0), e.imageType = "SIMPLE", e } return __extends(e, t), e.prototype.addSliceData = function(t, e, i, o, n, r) { this.sliceData = new s(t, e, i, o), this.sliceData.width = n, this.sliceData.height = r }, e.prototype.addTiledData = function(t, e) { this.tiledData = new r(t, e) }, e }(o);
    t.CacheUISprite = a; var h = function(t) {
        function e() { var e = t.call(this) || this; return e.designResolution = new Phaser.Rectangle(0, 0, 0, 0), e } return __extends(e, t), e.prototype.setSafeZone = function(t, e) { this.safeZone = new Phaser.Rectangle(0, 0, t, e) }, e }(o);
    t.CacheUICanvas = h; var l = function(t) {
        function e() { var e = t.call(this) || this; return e.size = new Phaser.Rectangle(0, 0, 0, 0), e.position = new Phaser.Point(0, 0), e.angle = 0, e.scale = new Phaser.Point(1, 1), e.alpha = 1, e } return __extends(e, t), e.prototype.addSize = function(t, e) { this.size.width = t, this.size.height = e }, e }(o);
    t.CacheUIGroup = l; var c = function() { return function(t, e, i) { this.normal = t, this.pressed = e, this.hover = i } }();
    t.CacheUIButtonStates = c; var d = function(t) {
        function e() { var e = t.call(this) || this; return e.anchor = new Phaser.Point(.5, .5), e.angle = 0, e.scale = new Phaser.Point(1, 1), e.tint = 16777215, e.alpha = 1, e.position = new Phaser.Point(0, 0), e.imageType = "SIMPLE", e } return __extends(e, t), e.prototype.addSliceData = function(t, e, i, o, n, r) { this.sliceData = new s(t, e, i, o), this.sliceData.width = n, this.sliceData.height = r }, e.prototype.addStates = function(t, e, i) { this.statesData = new c(t, e, i) }, e }(o);
    t.CacheUIButton = d; var u = function(t) {
        function e() { var e = t.call(this) || this; return e.anchor = new Phaser.Point(.5, .5), e.angle = 0, e.scale = new Phaser.Point(1, 1), e.tint = "#FFFFFF", e.alpha = 1, e.position = new Phaser.Point(0, 0), e.text = "", e.fontName = "Arial", e.fontSize = 24, e.lineHeight = 24, e.align = "center", e.stroke = "black", e.strokeThickness = 0, e } return __extends(e, t), e }(o);
    t.CacheUIText = u; var p = function(t) {
        function e() { return t.call(this) || this } return __extends(e, t), e }(o);
    t.CacheUINode = p; var m = function() { return function(t) { this.hierarchy = t } }();
    t.UIData = m }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(e) {
        function i(i) { var o = e.call(this, i, 0, 0, null) || this; return o.ph2Animations = new t.AnimationManager(i), o } return __extends(i, e), Object.defineProperty(i.prototype, "scaleX", { get: function() { return this.scale.x }, set: function(t) { this.scale.x = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "scaleY", { get: function() { return this.scale.y }, set: function(t) { this.scale.y = t }, enumerable: !0, configurable: !0 }), i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.ph2Animations && this.ph2Animations.destroy() }, i }(Phaser.Sprite);
    t.AnimationGroup = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(e) {
        function i(i, o, n) { var s = e.call(this, i, 0, 0, o, n) || this; return s.ph2Animations = new t.AnimationManager(i), s } return __extends(i, e), Object.defineProperty(i.prototype, "scaleX", { get: function() { return this.scale.x }, set: function(t) { this.scale.x = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "scaleY", { get: function() { return this.scale.y }, set: function(t) { this.scale.y = t }, enumerable: !0, configurable: !0 }), i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.ph2Animations && this.ph2Animations.destroy() }, i }(Phaser.Sprite);
    t.AnimationSprite = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r) { var a = e.call(this, i, o, n, s, r) || this; return a.ph2Animations = new t.AnimationManager(i), a } return __extends(i, e), i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.ph2Animations && this.ph2Animations.destroy() }, i }(Phaser.Text);
    t.AnimationText = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) {! function(t) { t[t.PORTRAIT = 0] = "PORTRAIT", t[t.LANDSCAPE = 1] = "LANDSCAPE", t[t.BOTH = 2] = "BOTH", t[t.NONE = 3] = "NONE" }(t.OrientationType || (t.OrientationType = {}));! function(t) { t[t.DESKTOP = 0] = "DESKTOP", t[t.MOBILE = 1] = "MOBILE", t[t.BOTH = 2] = "BOTH" }(t.PlatformType || (t.PlatformType = {}));! function(t) { t[t.PARENT = 0] = "PARENT", t[t.WORLD = 1] = "WORLD" }(t.AlignTargetType || (t.AlignTargetType = {}));! function(t) { t[t.ALL = 0] = "ALL", t[t.PORTRAIT = 1] = "PORTRAIT", t[t.LANDSCAPE = 2] = "LANDSCAPE" }(t.AlignmentScope || (t.AlignmentScope = {})) }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function t() {} return t.prototype.getOffset = function(t) { return this.isAbsolute ? this.offset : this.offset * t }, t }();
    t.AlignmentOffset = e; var i = function() {
        function t() { this.offsetX = new e, this.offsetY = new e } return t.prototype.getType = function() { switch (this.type) {
                case "TOP_LEFT":
                    return Phaser.TOP_LEFT;
                case "TOP_CENTER":
                    return Phaser.TOP_CENTER;
                case "TOP_RIGHT":
                    return Phaser.TOP_RIGHT;
                case "LEFT_TOP":
                    return Phaser.LEFT_TOP;
                case "LEFT_CENTER":
                    return Phaser.LEFT_CENTER;
                case "LEFT_BOTTOM":
                    return Phaser.LEFT_BOTTOM;
                case "CENTER":
                    return Phaser.CENTER;
                case "RIGHT_TOP":
                    return Phaser.RIGHT_TOP;
                case "RIGHT_CENTER":
                    return Phaser.RIGHT_CENTER;
                case "RIGHT_BOTTOM":
                    return Phaser.RIGHT_BOTTOM;
                case "BOTTOM_LEFT":
                    return Phaser.BOTTOM_LEFT;
                case "BOTTOM_CENTER":
                    return Phaser.BOTTOM_CENTER;
                case "BOTTOM_RIGHT":
                    return Phaser.BOTTOM_RIGHT;
                default:
                    return Phaser.CENTER } }, t }();
    t.Alignment = i; var o = function() {
        function e(t) { this.game = t, this.landscapeAlignment = new i, this.portraitAlignment = new i, this.enabled = !0 } return e.prototype.enable = function(t) { this.enabled = t }, e.prototype.setAlignTarget = function(t) { this.alignTargetType = t }, e.prototype.setLandscapeAlignment = function(t, e, i, o, n) { this.landscapeAlignment.type = t, this.landscapeAlignment.offsetX.offset = e * (i ? this.game.ph2UIManager.gameScale : 1), this.landscapeAlignment.offsetX.isAbsolute = i, this.landscapeAlignment.offsetY.offset = o * (n ? this.game.ph2UIManager.gameScale : 1), this.landscapeAlignment.offsetY.isAbsolute = n }, e.prototype.setPortraitAlignment = function(t, e, i, o, n) { this.portraitAlignment.type = t, this.portraitAlignment.offsetX.offset = e * (i ? this.game.ph2UIManager.gameScale : 1), this.portraitAlignment.offsetX.isAbsolute = i, this.portraitAlignment.offsetY.offset = o * (n ? this.game.ph2UIManager.gameScale : 1), this.portraitAlignment.offsetY.isAbsolute = n }, e.prototype.getCurrentAlignment = function() { return this.game.ph2UIManager.alignmentManager.getCurrentOrientation() === t.Orientation.LANDSCAPE ? this.landscapeAlignment : this.portraitAlignment }, e.prototype.applyAlignment = function(e) { if (this.enabled) { var i = this.getCurrentAlignment();
                this.alignTargetType === t.AlignTargetType.WORLD ? e.alignIn(this.game.ph2UIManager.alignmentManager.alignBounds, i.getType(), i.offsetX.getOffset(this.game.ph2UIManager.alignmentManager.alignBounds.width), i.offsetY.getOffset(this.game.ph2UIManager.alignmentManager.alignBounds.height)) : this.alignTargetType === t.AlignTargetType.PARENT && t.AlignmentSystem.alignInParent(e, i.getType(), i.offsetX.getOffset(e.parent.width), i.offsetY.getOffset(e.parent.height)) } }, e.prototype.destroy = function() { this.game = null, this.alignTargetType = null, this.landscapeAlignment = null, this.portraitAlignment = null }, e }();
    t.UIAlignment = o }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function e(t, e) { this.game = t, this.enabled = this.game.ph2UIManager.enableVisibilityAndOrientationComponent, this.elementProperties = {}, this.landscapeProperties = {}, this.portraitProperties = {} } return e.prototype.enable = function(t) { this.enabled = t }, e.prototype.backupOriginalProperty = function(t, e) { this.elementProperties[t] = e }, e.prototype.addPortraitProperty = function(t, e) { this.portraitProperties[t] = e }, e.prototype.addLandscapePortrait = function(t, e) { this.landscapeProperties[t] = e }, e.prototype.applyOriginalProperties = function(t) { for (var e = Object.keys(this.elementProperties), i = 0; i < e.length; i++) { var o = e[i];
                t[o] = this.elementProperties[o] } }, e.prototype.applyPortraitProperties = function(t) { this.applyOriginalProperties(t); for (var e = Object.keys(this.portraitProperties), i = 0; i < e.length; i++) { var o = e[i];
                t[o] = this.portraitProperties[o] } }, e.prototype.applyLandscapeProperties = function(t) { this.applyOriginalProperties(t); for (var e = Object.keys(this.landscapeProperties), i = 0; i < e.length; i++) { var o = e[i];
                t[o] = this.landscapeProperties[o] } }, e.prototype.apply = function(e) { this.enabled && (this.game.ph2UIManager.alignmentManager.getCurrentOrientation() === t.Orientation.PORTRAIT ? this.applyPortraitProperties(e) : this.game.ph2UIManager.alignmentManager.getCurrentOrientation() === t.Orientation.LANDSCAPE && this.applyLandscapeProperties(e)) }, e }();
    t.UIOrientationProperties = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function e(t, e) { this.gameObject = t, this.currentState = null, this.states = e } return e.prototype.setCurrentState = function(t) { if (this.states) { this.currentState = t, this.states.hasOwnProperty(this.currentState); var e = this.states[this.currentState];
                this.setProperty(e) } }, e.prototype.setProperty = function(e) { for (var i in e)
                if (e.hasOwnProperty(i))
                    if ("transition" === i) this.gameObject.setFrames(e[i].hover, e[i].normal, e[i].pressed, e[i].normal);
                    else if ("anchor" === i || "scale" === i || "position" === i) this.gameObject[i].x = void 0 === e[i].x ? this.gameObject[i].x : e[i].x, this.gameObject[i].y = void 0 === e[i].y ? this.gameObject[i].y : e[i].y;
            else if ("alignment" === i) { var o = new t.CacheUISprite;
                t.CacheFactory.addAlignmentProperty(o, e, t.AlignmentScope.ALL), this.gameObject.alignment.setLandscapeAlignment(o[i].type, o[i].offset.x, o[i].isAbsoluteX, o[i].offset.y, o[i].isAbsoluteY), this.gameObject.alignment.setPortraitAlignment(o[i].type, o[i].offset.x, o[i].isAbsoluteX, o[i].offset.y, o[i].isAbsoluteY), this.gameObject.parent instanceof t.UI ? this.gameObject.alignment.setAlignTarget(t.AlignTargetType.WORLD) : this.gameObject.alignment.setAlignTarget(t.AlignTargetType.PARENT), this.gameObject.alignment.applyAlignment(this.gameObject) } else if ("portraitAlignment" === i) this.gameObject.alignment.setPortraitAlignment(e[i].type, e[i].offset.x, e[i].isAbsoluteX, e[i].offset.y, e[i].isAbsoluteY), this.gameObject.alignment.applyAlignment(this.gameObject);
            else if ("landscapeAlignment" === i) this.gameObject.alignment.setLandscapeAlignment(e[i].type, e[i].offset.x, e[i].isAbsoluteX, e[i].offset.y, e[i].isAbsoluteY), this.gameObject.alignment.applyAlignment(this.gameObject);
            else if ("font" === i) { var n = this.gameObject,
                    s = void 0 === e[i].fontSize ? n.fontSize : e[i].fontSize,
                    r = void 0 === e[i].name ? n._fontComponents.fontFamily : e[i].name,
                    a = void 0 === e[i].tint ? n.style.fill : e[i].tint,
                    h = void 0 === e[i].align ? n.style.align : e[i].align,
                    l = void 0 === e[i].stroke ? n.style.stroke : e[i].stroke,
                    c = void 0 === e[i].strokeThickness ? n.style.strokeThickness : e[i].strokeThickness,
                    d = { font: s * n.game.ph2UIManager.gameScale + "px " + r, fill: a, align: h, stroke: l, strokeThickness: c * n.game.ph2UIManager.gameScale };
                n.setStyle(d) } else "file" === i ? this.gameObject.frameName = e[i] : "size" === i ? (this.gameObject.width = void 0 === e[i].width ? this.gameObject.width : e[i].width, this.gameObject.height = void 0 === e[i].height ? this.gameObject.height : e[i].height) : this.gameObject[i] = e[i] }, e.prototype.checkExistState = function(t) { for (var e in this.states)
                if (this.states.hasOwnProperty(e) && t === e) return !0; return !1 }, e.prototype.getAllStates = function() { var t = []; if (!this.states) return t; for (var e in this.states) this.states.hasOwnProperty(e) && t.push(e); return t }, e.prototype.getCurrentState = function() { return this.currentState }, e }();
    t.UIStates = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function e(e) { this.game = e, this.enabled = this.game.ph2UIManager.enableVisibilityAndOrientationComponent, this.orientationType = t.OrientationType.BOTH, this.platformType = t.PlatformType.BOTH } return e.prototype.setOrientationVisible = function(t) { this.orientationType = t }, e.prototype.setPlatformVisible = function(t) { this.platformType = t }, e.prototype.enable = function(t) { this.enabled = t }, e.prototype.applyVisibility = function(e) { if (this.enabled) { var i = this.platformType === t.PlatformType.BOTH || this.platformType === t.PlatformType.DESKTOP && "desktop" === this.game.ph2UIManager.currentPlatform || this.platformType === t.PlatformType.MOBILE && "mobile" === this.game.ph2UIManager.currentPlatform,
                    o = this.orientationType === t.OrientationType.BOTH || this.orientationType === t.OrientationType.LANDSCAPE && this.game.ph2UIManager.alignmentManager.getCurrentOrientation() === t.Orientation.LANDSCAPE || this.orientationType === t.OrientationType.PORTRAIT && this.game.ph2UIManager.alignmentManager.getCurrentOrientation() === t.Orientation.PORTRAIT; return e.visible = i && o, e.visible } }, e }();
    t.UIVisibility = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function e() {} return e.UICanvas = function(e, i) { var o = new t.CacheUICanvas; return o.name = e, void 0 !== i.design && (o.designResolution.width = i.design.width, o.designResolution.height = i.design.height), void 0 !== i.safeZone && o.setSafeZone(i.safeZone.width, i.safeZone.height), o }, e.UISprite = function(e, i, o) { var n = new t.CacheUISprite; if (n.name = e, n.textureName = i.file, t.CacheFactory.addAnchorProperty(n, i), t.CacheFactory.addAngleProperty(n, i), t.CacheFactory.addScaleProperty(n, i), t.CacheFactory.addColorProperty(n, i), t.CacheFactory.addPositionProperty(n, i), t.CacheFactory.addAnimations(n, o), t.CacheFactory.addAlphaProperty(n, i), t.CacheFactory.addAlignmentProperty(n, i, t.AlignmentScope.ALL), t.CacheFactory.addOrientationProperty(n, i), t.CacheFactory.addPlatformVisibilityProperty(n, i), t.CacheFactory.addStateProperty(n, i), void 0 !== i.image) { var s = i.image; if (n.imageType = s, "SLICED" === s) { var r = i.slice;
                    n.addSliceData(r.top, r.bottom, r.left, r.right, i.size.width, i.size.height) } else "TILED" === s && n.addTiledData(i.size.width, i.size.height) } else n.imageType = "NORMAL"; return n }, e.UIGroup = function(e, i, o) { var n = new t.CacheUIGroup; return n.name = e, t.CacheFactory.addPositionProperty(n, i), t.CacheFactory.addAngleProperty(n, i), t.CacheFactory.addScaleProperty(n, i), t.CacheFactory.addAlphaProperty(n, i), t.CacheFactory.addAlignmentProperty(n, i, t.AlignmentScope.ALL), t.CacheFactory.addPlatformVisibilityProperty(n, i), t.CacheFactory.addOrientationProperty(n, i), t.CacheFactory.addStateProperty(n, i), t.CacheFactory.addAnimations(n, o), void 0 !== i.size && n.addSize(i.size.width, i.size.height), n }, e.UIButton = function(e, i, o) { var n = new t.CacheUIButton; if (n.name = e, n.textureName = i.file, t.CacheFactory.addAnchorProperty(n, i), t.CacheFactory.addAngleProperty(n, i), t.CacheFactory.addScaleProperty(n, i), t.CacheFactory.addColorProperty(n, i), t.CacheFactory.addAlphaProperty(n, i), t.CacheFactory.addPositionProperty(n, i), t.CacheFactory.addAlignmentProperty(n, i, t.AlignmentScope.ALL), t.CacheFactory.addPlatformVisibilityProperty(n, i), t.CacheFactory.addOrientationProperty(n, i), t.CacheFactory.addStateProperty(n, i), t.CacheFactory.addAnimations(n, o), void 0 !== i.image) { var s = i.image; if (n.imageType = s, "SLICED" === s) { var r = i.slice;
                    n.addSliceData(r.top, r.bottom, r.left, r.right, i.size.width, i.size.height) } } else n.imageType = "NORMAL"; return void 0 !== i.transitionMode && (n.transitionMode = i.transitionMode, "image" === n.transitionMode ? n.addStates(i.transition.normal, i.transition.pressed, i.transition.hover) : "color" === n.transitionMode ? n.addStates(i.transition.normal, i.transition.pressed, i.transition.hover) : "scale" === n.transitionMode && n.addStates(i.transition.normal, i.transition.pressed, i.transition.hover)), n }, e.UIText = function(e, i, o) { var n = new t.CacheUIText; return n.name = e, t.CacheFactory.addAnchorProperty(n, i), t.CacheFactory.addAngleProperty(n, i), t.CacheFactory.addScaleProperty(n, i), t.CacheFactory.addColorProperty(n, i, !0), t.CacheFactory.addAlphaProperty(n, i), t.CacheFactory.addPositionProperty(n, i), t.CacheFactory.addPlatformVisibilityProperty(n, i), t.CacheFactory.addAlignmentProperty(n, i, t.AlignmentScope.ALL), t.CacheFactory.addOrientationProperty(n, i), t.CacheFactory.addStateProperty(n, i), t.CacheFactory.addAnimations(n, o), void 0 !== i.font && (n.fontName = i.font.name, n.fontSize = i.font.fontSize, n.lineHeight = i.font.lineHeight), void 0 !== i.mode && "shrink" === i.mode && (n.maxWidth = i.maxWidth, n.maxHeight = i.maxHeight), void 0 !== i.text && (n.text = i.text), void 0 !== i.align && (n.align = i.align), void 0 !== i.stroke && (n.stroke = i.stroke), void 0 !== i.strokeThickness && (n.strokeThickness = i.strokeThickness), n }, e.addAnimations = function(t, e) { void 0 !== e && (t.animations = e) }, e.addStateProperty = function(t, e) { void 0 !== e.states && (t.states = e.states) }, e.addAnchorProperty = function(t, e) { void 0 !== e.anchor && (t.anchor.x = e.anchor.x, t.anchor.y = e.anchor.y) }, e.addAngleProperty = function(t, e) { void 0 !== e.angle && (t.angle = e.angle) }, e.addScaleProperty = function(t, e) { void 0 !== e.scale && (t.scale.x = e.scale.x, t.scale.y = e.scale.y) }, e.addColorProperty = function(t, e, i) { void 0 !== e.color && (i ? t.tint = e.color : e.color.length >= 7 ? t.tint = parseInt("0x" + e.color.slice(1, 3) + e.color.slice(3, 5) + e.color.slice(5, 7), 16) : t.tint = Phaser.Color.hexToRGB(e.color)) }, e.addAlphaProperty = function(t, e) { void 0 !== e.alpha && (t.alpha = e.alpha) }, e.addPositionProperty = function(t, e) { void 0 !== e.position && (t.position.x = e.position.x, t.position.y = e.position.y) }, e.addAlignmentProperty = function(t, e, i) { if (void 0 !== e.alignment) { var o = 0,
                    n = 0,
                    s = !0,
                    r = !0;
                void 0 !== e.alignment.offset && (o = e.alignment.offset.x, n = e.alignment.offset.y, "string" == typeof o && (s = !1, o = Number(o.split("%")[0]) / 100), "string" == typeof n && (r = !1, n = Number(n.split("%")[0]) / 100)), t.addAlignment(e.alignment.type, o, n, s, r, i) } }, e.addOrientationProperty = function(e, i) { var o = t.OrientationType.BOTH; if (void 0 !== i.orientation) { if ((void 0 !== i.orientation.landscape && void 0 !== i.orientation.landscape.properties || void 0 !== i.orientation.portrait && void 0 !== i.orientation.portrait.properties) && (e.addOrientationProperty("scale", e.scale, null), e.addOrientationProperty("angle", e.angle, null), e.addOrientationProperty("anchor", e.anchor, null), e.addOrientationProperty("alpha", e.alpha, null), e.addOrientationProperty("position", e.position, null)), void 0 !== i.orientation.landscape) { if (void 0 !== i.orientation.landscape.alignment) { n = i.orientation.landscape;
                        t.CacheFactory.addAlignmentProperty(e, n, t.AlignmentScope.LANDSCAPE) } void 0 !== i.orientation.landscape.properties && t.CacheFactory.addOrientationPropertyForOrientation(e, i.orientation.landscape.properties, t.AlignmentScope.LANDSCAPE), void 0 !== i.orientation.landscape.hide && i.orientation.landscape.hide && (o = t.OrientationType.PORTRAIT) } if (void 0 !== i.orientation.portrait) { if (void 0 !== i.orientation.portrait.alignment) { var n = i.orientation.portrait;
                        t.CacheFactory.addAlignmentProperty(e, n, t.AlignmentScope.PORTRAIT) } void 0 !== i.orientation.portrait.properties && t.CacheFactory.addOrientationPropertyForOrientation(e, i.orientation.portrait.properties, t.AlignmentScope.PORTRAIT), void 0 !== i.orientation.portrait.hide && i.orientation.portrait.hide && (o === t.OrientationType.PORTRAIT ? o = t.OrientationType.NONE : o === t.OrientationType.BOTH && (o = t.OrientationType.LANDSCAPE)) } } e.setOrientationVisibility(o) }, e.addOrientationPropertyForOrientation = function(t, e, i) { void 0 !== e.scale && t.addOrientationProperty("scale", new Phaser.Point(e.scale.x, e.scale.y), i), void 0 !== e.angle && t.addOrientationProperty("angle", e.angle, i), void 0 !== e.anchor && t.addOrientationProperty("anchor", new Phaser.Point(e.anchor.x, e.anchor.y), i), void 0 !== e.alpha && t.addOrientationProperty("alpha", e.alpha, i), void 0 !== e.position && t.addOrientationProperty("position", new Phaser.Point(e.position.x, e.position.y), i) }, e.addPlatformVisibilityProperty = function(e, i) { var o = t.PlatformType.BOTH;
            void 0 !== i.visibility && (o = "desktop" === i.visibility ? t.PlatformType.DESKTOP : "mobile" === i.visibility ? t.PlatformType.MOBILE : t.PlatformType.BOTH), e.setPlatformVisibility(o) }, e }();
    t.CacheFactory = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function e() {} return e.UICanvas = function(e, i) { var o = new t.UI(e, i.designResolution.width, i.designResolution.height); return o.name = i.name, i.safeZone && o.setSafeZone(i.safeZone.width * e.ph2UIManager.gameScale, i.safeZone.height * e.ph2UIManager.gameScale), o }, e.UISprite = function(i, o, n, s) { var r; if (o.sliceData ? ((r = new t.UISlicedSprite(i, o.position.x * i.ph2UIManager.gameScale, o.position.y * i.ph2UIManager.gameScale, n, o.textureName, o.sliceData.width * i.ph2UIManager.gameScale, o.sliceData.height * i.ph2UIManager.gameScale, { top: o.sliceData.top * i.ph2UIManager.gameScale, bottom: o.sliceData.bottom * i.ph2UIManager.gameScale, left: o.sliceData.left * i.ph2UIManager.gameScale, right: o.sliceData.right * i.ph2UIManager.gameScale })).name = o.name, r.anchor.x = o.anchor.x, r.anchor.y = o.anchor.y, r.angle = o.angle, r.scale.x = o.scale.x, r.scale.y = o.scale.y, r.alpha = o.alpha, r.tint = o.tint, r.x = o.position.x * i.ph2UIManager.gameScale, r.y = o.position.y * i.ph2UIManager.gameScale) : o.tiledData ? ((r = new t.UITiledSprite(i, 0, 0, o.tiledData.width * i.ph2UIManager.gameScale, o.tiledData.height * i.ph2UIManager.gameScale, n, o.textureName)).name = o.name, r.anchor.x = o.anchor.x, r.anchor.y = o.anchor.y, r.angle = o.angle, r.scale.x = o.scale.x, r.scale.y = o.scale.y, r.alpha = o.alpha, r.tint = o.tint, r.x = o.position.x * i.ph2UIManager.gameScale, r.y = o.position.y * i.ph2UIManager.gameScale) : ((r = new t.UISprite(i, 0, 0, n, o.textureName)).name = o.name, r.anchor.x = o.anchor.x, r.anchor.y = o.anchor.y, r.angle = o.angle, r.scale.x = o.scale.x, r.scale.y = o.scale.y, r.alpha = o.alpha, r.tint = o.tint, r.x = o.position.x * i.ph2UIManager.gameScale, r.y = o.position.y * i.ph2UIManager.gameScale), e.addAnimationUIElement(r, o.animations), void 0 !== o.states && r.enableState(o.states), o.alignment && (r.enableAlignment(), r.alignment.setLandscapeAlignment(o.alignment.type, o.alignment.offset.x, o.alignment.isAbsoluteX, o.alignment.offset.y, o.alignment.isAbsoluteY), r.alignment.setPortraitAlignment(o.alignment.type, o.alignment.offset.x, o.alignment.isAbsoluteX, o.alignment.offset.y, o.alignment.isAbsoluteY), s instanceof t.UI ? r.alignment.setAlignTarget(t.AlignTargetType.WORLD) : r.alignment.setAlignTarget(t.AlignTargetType.PARENT)), o.portraitAlignment && (r.alignment || r.enableAlignment(), r.alignment.setPortraitAlignment(o.portraitAlignment.type, o.portraitAlignment.offset.x, o.portraitAlignment.isAbsoluteX, o.portraitAlignment.offset.y, o.portraitAlignment.isAbsoluteY)), o.landscapeAlignment && (r.alignment || r.enableAlignment(), r.alignment.setLandscapeAlignment(o.landscapeAlignment.type, o.landscapeAlignment.offset.x, o.landscapeAlignment.isAbsoluteX, o.landscapeAlignment.offset.y, o.landscapeAlignment.isAbsoluteY)), o.orientationProperties) { r.enableOrientationProperties(); for (a = 0; a < o.orientationProperties.backup.length; a++) "position" === (h = o.orientationProperties.backup[a]).key && (h.value.x = h.value.x * i.ph2UIManager.gameScale, h.value.y = h.value.y * i.ph2UIManager.gameScale), r.orientationProperties.backupOriginalProperty(h.key, h.value); for (a = 0; a < o.orientationProperties.portrait.length; a++) "position" === (h = o.orientationProperties.portrait[a]).key && (h.value.x = h.value.x * i.ph2UIManager.gameScale, h.value.y = h.value.y * i.ph2UIManager.gameScale), r.orientationProperties.addPortraitProperty(h.key, h.value); for (var a = 0; a < o.orientationProperties.landscape.length; a++) { var h = o.orientationProperties.landscape[a]; "position" === h.key && (h.value.x = h.value.x * i.ph2UIManager.gameScale, h.value.y = h.value.y * i.ph2UIManager.gameScale), r.orientationProperties.addLandscapePortrait(h.key, h.value) } } return r.enableVisibility(o.platformVisibility, o.orientationVisibility), r }, e.UIGroup = function(i, o, n) { var s = new t.UIGroup(i); if (s.width = o.size.width * i.ph2UIManager.gameScale, s.height = o.size.height * i.ph2UIManager.gameScale, s.name = o.name, s.x = o.position.x * i.ph2UIManager.gameScale, s.y = o.position.y * i.ph2UIManager.gameScale, s.angle = o.angle, s.scale.x = o.scale.x, s.scale.y = o.scale.y, s.alpha = o.alpha, o.alignment && (s.enableAlignment(), s.alignment.setLandscapeAlignment(o.alignment.type, o.alignment.offset.x, o.alignment.isAbsoluteX, o.alignment.offset.y, o.alignment.isAbsoluteY), s.alignment.setPortraitAlignment(o.alignment.type, o.alignment.offset.x, o.alignment.isAbsoluteX, o.alignment.offset.y, o.alignment.isAbsoluteY), n instanceof t.UI ? s.alignment.setAlignTarget(t.AlignTargetType.WORLD) : s.alignment.setAlignTarget(t.AlignTargetType.PARENT)), e.addAnimationUIElement(s, o.animations), o.portraitAlignment && (s.alignment || s.enableAlignment(), s.alignment.setPortraitAlignment(o.portraitAlignment.type, o.portraitAlignment.offset.x, o.portraitAlignment.isAbsoluteX, o.portraitAlignment.offset.y, o.portraitAlignment.isAbsoluteY)), o.landscapeAlignment && (s.alignment || s.enableAlignment(), s.alignment.setLandscapeAlignment(o.landscapeAlignment.type, o.landscapeAlignment.offset.x, o.landscapeAlignment.isAbsoluteX, o.landscapeAlignment.offset.y, o.landscapeAlignment.isAbsoluteY)), void 0 !== o.states && s.enableState(o.states), o.orientationProperties) { s.enableOrientationProperties(); for (r = 0; r < o.orientationProperties.backup.length; r++) "position" === (a = o.orientationProperties.backup[r]).key && (a.value.x = a.value.x * i.ph2UIManager.gameScale, a.value.y = a.value.y * i.ph2UIManager.gameScale), s.orientationProperties.backupOriginalProperty(a.key, a.value); for (r = 0; r < o.orientationProperties.portrait.length; r++) "position" === (a = o.orientationProperties.portrait[r]).key && (a.value.x = a.value.x * i.ph2UIManager.gameScale, a.value.y = a.value.y * i.ph2UIManager.gameScale), s.orientationProperties.addPortraitProperty(a.key, a.value); for (var r = 0; r < o.orientationProperties.landscape.length; r++) { var a = o.orientationProperties.landscape[r]; "position" === a.key && (a.value.x = a.value.x * i.ph2UIManager.gameScale, a.value.y = a.value.y * i.ph2UIManager.gameScale), s.orientationProperties.addLandscapePortrait(a.key, a.value) } } return s.enableVisibility(o.platformVisibility, o.orientationVisibility), s }, e.UIText = function(i, o, n) { var s = new t.UIText(i, o.position.x * i.ph2UIManager.gameScale, o.position.y * i.ph2UIManager.gameScale, o.text, { font: o.fontSize * i.ph2UIManager.gameScale + "px " + o.fontName, fill: o.tint, align: o.align, stroke: o.stroke, strokeThickness: o.strokeThickness * i.ph2UIManager.gameScale }); if (s.name = o.name, s.angle = o.angle, s.anchor.x = o.anchor.x, s.anchor.y = o.anchor.y, s.scale.x = o.scale.x, s.scale.y = o.scale.y, s.alpha = o.alpha, void 0 !== o.lineHeight && (s.lineSpacing = o.lineHeight * i.ph2UIManager.gameScale - o.fontSize * i.ph2UIManager.gameScale), o.maxWidth && (s.wordWrap = !0, s.wordWrapWidth = o.maxWidth * i.ph2UIManager.gameScale, s.enableFitSizetext(o.fontSize * i.ph2UIManager.gameScale, o.maxWidth * i.ph2UIManager.gameScale, o.maxHeight * i.ph2UIManager.gameScale)), void 0 !== o.states && s.enableState(o.states), e.addAnimationUIElement(s, o.animations), o.alignment && (s.enableAlignment(), s.alignment.setLandscapeAlignment(o.alignment.type, o.alignment.offset.x, o.alignment.isAbsoluteX, o.alignment.offset.y, o.alignment.isAbsoluteY), s.alignment.setPortraitAlignment(o.alignment.type, o.alignment.offset.x, o.alignment.isAbsoluteX, o.alignment.offset.y, o.alignment.isAbsoluteY), n instanceof t.UI ? s.alignment.setAlignTarget(t.AlignTargetType.WORLD) : s.alignment.setAlignTarget(t.AlignTargetType.PARENT)), o.portraitAlignment && (s.alignment || s.enableAlignment(), s.alignment.setPortraitAlignment(o.portraitAlignment.type, o.portraitAlignment.offset.x, o.portraitAlignment.isAbsoluteX, o.portraitAlignment.offset.y, o.portraitAlignment.isAbsoluteY)), o.landscapeAlignment && (s.alignment || s.enableAlignment(), s.alignment.setLandscapeAlignment(o.landscapeAlignment.type, o.landscapeAlignment.offset.x, o.landscapeAlignment.isAbsoluteX, o.landscapeAlignment.offset.y, o.landscapeAlignment.isAbsoluteY)), o.orientationProperties) { s.enableOrientationProperties(); for (r = 0; r < o.orientationProperties.backup.length; r++) "position" === (a = o.orientationProperties.backup[r]).key && (a.value.x = a.value.x * i.ph2UIManager.gameScale, a.value.y = a.value.y * i.ph2UIManager.gameScale), s.orientationProperties.backupOriginalProperty(a.key, a.value); for (r = 0; r < o.orientationProperties.portrait.length; r++) "position" === (a = o.orientationProperties.portrait[r]).key && (a.value.x = a.value.x * i.ph2UIManager.gameScale, a.value.y = a.value.y * i.ph2UIManager.gameScale), s.orientationProperties.addPortraitProperty(a.key, a.value); for (var r = 0; r < o.orientationProperties.landscape.length; r++) { var a = o.orientationProperties.landscape[r]; "position" === a.key && (a.value.x = a.value.x * i.ph2UIManager.gameScale, a.value.y = a.value.y * i.ph2UIManager.gameScale), s.orientationProperties.addLandscapePortrait(a.key, a.value) } } return s.enableVisibility(o.platformVisibility, o.orientationVisibility), s }, e.UIButton = function(i, o, n, s) { var r; if (o.sliceData ? ((r = new t.UISlicedButton(i, o.position.x * i.ph2UIManager.gameScale, o.position.y * i.ph2UIManager.gameScale, n, o.textureName, o.sliceData.width * i.ph2UIManager.gameScale, o.sliceData.height * i.ph2UIManager.gameScale, { top: o.sliceData.top * i.ph2UIManager.gameScale, bottom: o.sliceData.bottom * i.ph2UIManager.gameScale, left: o.sliceData.left * i.ph2UIManager.gameScale, right: o.sliceData.right * i.ph2UIManager.gameScale })).name = o.name, r.anchor.x = o.anchor.x, r.anchor.y = o.anchor.y, r.angle = o.angle, r.scale.x = o.scale.x, r.scale.y = o.scale.y, r.alpha = o.alpha, r.tint = o.tint, r.x = o.position.x * i.ph2UIManager.gameScale, r.y = o.position.y * i.ph2UIManager.gameScale, o.statesData && ("color" === o.transitionMode ? r.setTransitionColor(o.statesData.normal, o.statesData.pressed, o.statesData.hover) : "image" === o.transitionMode && r.setFrames(o.statesData.hover, o.statesData.normal, o.statesData.pressed, o.statesData.normal))) : (r = new t.UIButton(i, n), o.statesData ? "image" === o.transitionMode && r.setFrames(o.statesData.hover, o.statesData.normal, o.statesData.pressed, o.statesData.normal) : r.setFrames(o.textureName, o.textureName, o.textureName, o.textureName), r.name = o.name, r.anchor.x = o.anchor.x, r.anchor.y = o.anchor.y, r.angle = o.angle, r.scale.x = o.scale.x, r.scale.y = o.scale.y, r.alpha = o.alpha, r.tint = o.tint, r.x = o.position.x * i.ph2UIManager.gameScale, r.y = o.position.y * i.ph2UIManager.gameScale), e.addAnimationUIElement(r, o.animations), void 0 !== o.states && r.enableState(o.states), o.alignment && (r.enableAlignment(), r.alignment.setLandscapeAlignment(o.alignment.type, o.alignment.offset.x, o.alignment.isAbsoluteX, o.alignment.offset.y, o.alignment.isAbsoluteY), r.alignment.setPortraitAlignment(o.alignment.type, o.alignment.offset.x, o.alignment.isAbsoluteX, o.alignment.offset.y, o.alignment.isAbsoluteY), s instanceof t.UI ? r.alignment.setAlignTarget(t.AlignTargetType.WORLD) : r.alignment.setAlignTarget(t.AlignTargetType.PARENT)), o.portraitAlignment && (r.alignment || r.enableAlignment(), r.alignment.setPortraitAlignment(o.portraitAlignment.type, o.portraitAlignment.offset.x, o.portraitAlignment.isAbsoluteX, o.portraitAlignment.offset.y, o.portraitAlignment.isAbsoluteY)), o.landscapeAlignment && (r.alignment || r.enableAlignment(), r.alignment.setLandscapeAlignment(o.landscapeAlignment.type, o.landscapeAlignment.offset.x, o.landscapeAlignment.isAbsoluteX, o.landscapeAlignment.offset.y, o.landscapeAlignment.isAbsoluteY)), o.orientationProperties) { r.enableOrientationProperties(); for (a = 0; a < o.orientationProperties.backup.length; a++) "position" === (h = o.orientationProperties.backup[a]).key && (h.value.x = h.value.x * i.ph2UIManager.gameScale, h.value.y = h.value.y * i.ph2UIManager.gameScale), r.orientationProperties.backupOriginalProperty(h.key, h.value); for (a = 0; a < o.orientationProperties.portrait.length; a++) "position" === (h = o.orientationProperties.portrait[a]).key && (h.value.x = h.value.x * i.ph2UIManager.gameScale, h.value.y = h.value.y * i.ph2UIManager.gameScale), r.orientationProperties.addPortraitProperty(h.key, h.value); for (var a = 0; a < o.orientationProperties.landscape.length; a++) { var h = o.orientationProperties.landscape[a]; "position" === h.key && (h.value.x = h.value.x * i.ph2UIManager.gameScale, h.value.y = h.value.y * i.ph2UIManager.gameScale), r.orientationProperties.addLandscapePortrait(h.key, h.value) } } return r.enableVisibility(o.platformVisibility, o.orientationVisibility), r }, e.addAnimationUIElement = function(t, i) { if (i && i.length > 0) { t.enableAnimation(); for (var o = 0; o < i.length; o++) e.addAnimation(t.game, t, i[o]) } }, e.addAnimation = function(i, o, n) { var s = i.cache.getJSON(n); if (s) { var r = void 0 !== s.speed ? s.speed : 1,
                    a = void 0 !== s.mode ? s.mode : null,
                    h = s.data,
                    l = s.events,
                    c = t.AnimationMode.NORMAL;
                a && "loop" === a.toLowerCase() && (c = t.AnimationMode.LOOP); var d = e.createCacheTimelineForAnimation(n, h, r, c, l);
                o.addAnimation(d) } }, e.addAnimationToNode = function(e, i) { for (var o = i.mode === t.AnimationMode.LOOP, n = new t.Animation(i.name, i.speed, e, o), s = e.game.ph2UIManager.gameScale, r = null, a = null, h = 0; h < i.timelines.length; h++) { var l = i.timelines[h],
                    c = l.target;
                c !== r && (a = "__this__" === c ? e : t.UISystem.findObject(c, e)); for (var d = new TimelineMax({ paused: !0, autoRemoveChildren: !1 }), u = 0, p = 0; p < l.frames.length; p++) { var m = l.frames[p],
                        f = m.frame / 1e3,
                        y = f - u,
                        b = m.value; switch (l.property) {
                        case "scaleX":
                            0 === f ? (n.addInitValue(a, "scaleX", b), d.set(a, { scaleX: b }, 0)) : d.to(a, y, { scaleX: b }); break;
                        case "scaleY":
                            0 === f ? (n.addInitValue(a, "scaleY", b), d.set(a, { scaleY: b }, 0)) : d.to(a, y, { scaleY: b }); break;
                        case "angle":
                            0 === f ? (n.addInitValue(a, "angle", b), d.set(a, { angle: b }, 0)) : d.to(a, y, { angle: b }); break;
                        case "alpha":
                            0 === f ? (n.addInitValue(a, "alpha", b), d.set(a, { alpha: b }, 0)) : d.to(a, y, { alpha: b }); break;
                        case "position":
                            0 === f ? (n.addInitValue(a, "x", b[0] * s), n.addInitValue(a, "y", b[1] * s), d.set(a, { x: b[0] * s, y: b[1] * s }, 0)) : d.to(a, y, { x: b[0] * s, y: b[1] * s }); break;
                        case "x":
                            0 === f ? (n.addInitValue(a, "x", b * s), d.set(a, { x: b * s }, 0)) : d.to(a, y, { x: b * s }); break;
                        case "y":
                            0 === f ? (n.addInitValue(a, "y", b * s), d.set(a, { y: b * s }, 0)) : d.to(a, y, { y: b * s }); break;
                        case "frameName":
                            0 === f && n.addInitValue(a, "frameName", b), d.addCallback(n.changeFrame, f, [a, b], this) } u = f } n.addTimelineChild(d), r = c } if (n.checkTimelineDuration(), i.events && i.events.length > 0)
                for (h = 0; h < i.events.length; h++) n.addEvent(i.events[h]);
            e.ph2Animations.add(n) }, e.createCacheTimelineForAnimation = function(e, i, o, n, s) { var r = new t.CacheAnimation(e, o);
            r.mode = n; for (var a = Object.keys(i), h = 0; h < a.length; h++)
                for (var l = a[h], c = i[l], d = Object.keys(c), u = 0; u < d.length; u++) { var p = d[u],
                        m = c[p],
                        f = this.createCacheTimelineForProperty(l, p, m);
                    r.addTimeline(f) }
            if (s && s.length > 0)
                for (h = 0; h < s.length; h++) { var y = new t.CacheEvent;
                    y.frame = s[h].frame, y.name = s[h].name, r.addEvent(y) }
            return r }, e.createCacheTimelineForProperty = function(e, i, o) { for (var n = new t.CacheTimeline(e, i), s = 0; s < o.length; s++) { var r = new t.CacheFrame;
                r.frame = o[s].frame, r.value = o[s].value, n.addFrame(r) } return n }, e }();
    t.UIFactory = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(t) {
        function e(e, i, o) { var n = t.call(this, e) || this; return n.designResolution = new Phaser.Rectangle(0, 0, i, o), n.safeZone = new Phaser.Rectangle(0, 0, i, o), e.ph2UIManager.events.gameSizeChanged.add(n.onGameSizeChanged, n), n } return __extends(e, t), e.prototype.onGameSizeChanged = function() { this.windowSizeChanged() }, e.prototype.setSafeZone = function(t, e) { this.safeZone.width = t, this.safeZone.height = e }, e.prototype.setDesignResolution = function(t, e) { this.designResolution.width = t, this.designResolution.height = e }, e.prototype.getDesignResolution = function() { return this.designResolution }, e.prototype.getSafeZone = function() { return this.safeZone }, e.prototype.enableAlignment = function() {}, e.prototype.enableOrientationProperties = function() {}, e.prototype.checkExistState = function(t) { return !1 }, e.prototype.setCurrentState = function(t) {}, e.prototype.getAnimations = function() { return [] }, e.prototype.getAnimationsName = function() { return [] }, e.prototype.addAnimation = function(t) {}, e.prototype.windowSizeChanged = function() { for (var t = 0; t < this.children.length; t++) "function" == typeof this.children[t].windowSizeChanged && this.children[t].windowSizeChanged() }, e.prototype.destroy = function(e, i) { this.game.ph2UIManager.events.gameSizeChanged.removeAll(this), t.prototype.destroy.call(this, e, i), this.safeZone = null, this.designResolution = null }, e }(Phaser.Group);
    t.UI = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(e) {
        function i(t, i) { var o = e.call(this, t, 0, 0, i) || this; return o.forceOut = !0, o } return __extends(i, e), i.prototype.enableAlignment = function() { this.alignment = new t.UIAlignment(this.game) }, i.prototype.enableOrientationProperties = function() { this.orientationProperties = new t.UIOrientationProperties(this.game, this) }, i.prototype.enableAnimation = function() { this.ph2Animations = new t.AnimationManager(this.game), this.animationsName = [], this.cacheAnimations = [] }, i.prototype.addAnimation = function(t) { this.cacheAnimations.push(t), this.animationsName.push(t.name) }, i.prototype.getAnimations = function() { return this.cacheAnimations }, i.prototype.getAnimationsName = function() { return this.animationsName }, Object.defineProperty(i.prototype, "scaleX", { get: function() { return this.scale.x }, set: function(t) { this.scale.x = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "scaleY", { get: function() { return this.scale.y }, set: function(t) { this.scale.y = t }, enumerable: !0, configurable: !0 }), i.prototype.enableVisibility = function(e, i) { this.visibility = new t.UIVisibility(this.game), this.visibility.setPlatformVisible(e), this.visibility.setOrientationVisible(i) }, i.prototype.enableState = function(e) { this.stateManager = new t.UIStates(this, e) }, i.prototype.setCurrentState = function(t) { this.stateManager && this.stateManager.setCurrentState(t) }, i.prototype.getAllStates = function() { return this.stateManager ? this.stateManager.getAllStates() : [] }, i.prototype.getCurrentState = function() { return this.stateManager ? this.stateManager.getCurrentState() : null }, i.prototype.checkExistState = function(t) { return void 0 !== this.stateManager && this.stateManager.checkExistState(t) }, i.prototype.windowSizeChanged = function() { this.visibility && this.visibility.applyVisibility(this), this.orientationProperties && this.orientationProperties.apply(this), this.alignment && this.alignment.applyAlignment(this); for (var t = 0; t < this.children.length; t++) "function" == typeof this.children[t].windowSizeChanged && this.children[t].windowSizeChanged() }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.alignment && (this.alignment.destroy(), this.alignment = null), this.visibility = null, this.ph2Animations && this.ph2Animations.destroy(), this.stateManager && (this.stateManager = null), this.cacheAnimations && (this.cacheAnimations.length = 0, this.cacheAnimations = null), this.animationsName && (this.animationsName.length = 0, this.animationsName = null) }, i }(Phaser.Button);
    t.UIButton = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(e) {
        function i(t) { var i = e.call(this, t) || this; return i.innerWidth = 0, i.innerHeight = 0, i.anchor = new Phaser.Point(.5, .5), i } return __extends(i, e), Object.defineProperty(i.prototype, "width", { get: function() { return this.innerWidth }, set: function(t) { this.innerWidth = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "height", { get: function() { return this.innerHeight }, set: function(t) { this.innerHeight = t }, enumerable: !0, configurable: !0 }), i.prototype.getBounds = function(t) { var e, i = t && t instanceof PIXI.DisplayObject,
                o = !0; if (i ? o = t instanceof PIXI.DisplayObjectContainer && t.contains(this) : t = this, i) { e = t.worldTransform, t.worldTransform = PIXI.identityMatrix; for (k = 0; k < t.children.length; k++) t.children[k].updateTransform() } var n, s, r, a, h = new PIXI.Rectangle,
                l = h.x,
                c = this.innerWidth + h.x,
                d = h.y,
                u = this.innerHeight + h.y,
                p = this.worldTransform,
                m = p.a,
                f = p.b,
                y = p.c,
                b = p.d,
                g = p.tx,
                _ = p.ty,
                v = m * c + y * u + g,
                x = b * u + f * c + _,
                S = m * l + y * u + g,
                C = b * u + f * l + _,
                w = m * l + y * d + g,
                A = b * d + f * l + _,
                T = m * c + y * d + g,
                P = b * d + f * c + _; if (r = v, a = x, n = v, s = x, n = S < n ? S : n, n = w < n ? w : n, n = T < n ? T : n, s = C < s ? C : s, s = A < s ? A : s, s = P < s ? P : s, r = S > r ? S : r, r = w > r ? w : r, r = T > r ? T : r, a = C > a ? C : a, a = A > a ? A : a, a = P > a ? P : a, h.x = n, h.y = s, h.width = r - n, h.height = a - s, i) { t.worldTransform = e; for (var k = 0; k < t.children.length; k++) t.children[k].updateTransform() } if (!o) { var M = t.getBounds();
                h.x -= M.x, h.y -= M.y } return h }, i.prototype.enableAnimation = function() { this.ph2Animations = new t.AnimationManager(this.game), this.animationsName = [], this.cacheAnimations = [] }, i.prototype.addAnimation = function(t) { this.cacheAnimations.push(t), this.animationsName.push(t.name) }, i.prototype.getAnimations = function() { return this.cacheAnimations }, i.prototype.getAnimationsName = function() { return this.animationsName }, Object.defineProperty(i.prototype, "scaleX", { get: function() { return this.scale.x }, set: function(t) { this.scale.x = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "right", { get: function() { return this.x + this.innerWidth - this.innerWidth * this.anchor.x }, set: function(t) { this.x = t - this.innerWidth + this.innerWidth * this.anchor.x }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "left", { get: function() { return this.x - this.innerWidth * this.anchor.x }, set: function(t) { this.x = t + this.innerWidth * this.anchor.x }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "top", { get: function() { return this.y - this.innerHeight * this.anchor.y }, set: function(t) { this.y = t + this.innerHeight * this.anchor.y }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "bottom", { get: function() { return this.y + this.innerHeight - this.innerHeight * this.anchor.y }, set: function(t) { this.y = t - this.innerHeight + this.innerHeight * this.anchor.y }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "centerX", { get: function() { return this.x - this.innerWidth * this.anchor.x + .5 * this.innerWidth }, set: function(t) { this.x = t + this.innerWidth * this.anchor.x - .5 * this.innerWidth }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "centerY", { get: function() { return this.y - this.innerHeight * this.anchor.y + .5 * this.innerHeight }, set: function(t) { this.y = t + this.innerHeight * this.anchor.y - .5 * this.innerHeight }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "scaleY", { get: function() { return this.scale.y }, set: function(t) { this.scale.y = t }, enumerable: !0, configurable: !0 }), i.prototype.enableAlignment = function() { this.alignment = new t.UIAlignment(this.game) }, i.prototype.enableVisibility = function(e, i) { this.visibility = new t.UIVisibility(this.game), this.visibility.setPlatformVisible(e), this.visibility.setOrientationVisible(i) }, i.prototype.enableOrientationProperties = function() { this.orientationProperties = new t.UIOrientationProperties(this.game, this) }, i.prototype.enableState = function(e) { this.stateManager = new t.UIStates(this, e) }, i.prototype.setCurrentState = function(t) { this.stateManager.setCurrentState(t) }, i.prototype.getAllStates = function() { return this.stateManager ? this.stateManager.getAllStates() : [] }, i.prototype.getCurrentState = function() { return this.stateManager.getCurrentState() }, i.prototype.checkExistState = function(t) { return void 0 !== this.stateManager && this.stateManager.checkExistState(t) }, i.prototype.windowSizeChanged = function() { this.visibility && this.visibility.applyVisibility(this), this.orientationProperties && this.orientationProperties.apply(this), this.alignment && this.alignment.applyAlignment(this); for (var t = 0; t < this.children.length; t++) "function" == typeof this.children[t].windowSizeChanged && this.children[t].windowSizeChanged() }, i.prototype.destroy = function(t, i) { e.prototype.destroy.call(this, t, i), this.alignment && (this.alignment.destroy(), this.alignment = null), this.visibility = null, this.ph2Animations && this.ph2Animations.destroy(), this.stateManager && (this.stateManager = null), this.cacheAnimations && (this.cacheAnimations.length = 0, this.cacheAnimations = null), this.animationsName && (this.animationsName.length = 0, this.animationsName = null) }, i }(Phaser.Group);
    t.UIGroup = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(e) {
        function i(t, i, o, n, s, r, a, h) { var l = e.call(this, t, i, o, n, s, r, a, h) || this; return l.currentState = "outFrame", l.setFrames(s, s, s, s), l.inputEnabled = !0, l.input.start(0, !0), l.input.useHandCursor = !0, l.events.onInputOver.add(l.onInputOverHandler, l), l.events.onInputOut.add(l.onInputOutHandler, l), l.events.onInputDown.add(l.onInputDownHandler, l), l.events.onInputUp.add(l.onInputUpHandler, l), l.justReleasedPreventsOver = Phaser.PointerMode.CURSOR, l.onOverMouseOnly = !0, l.onInputOver = new Phaser.Signal, l.onInputOut = new Phaser.Signal, l.onInputDown = new Phaser.Signal, l.onInputUp = new Phaser.Signal, l.freezeFrames = !1, l.forceOut = !0, l.hoverColor = "#FFFFFF", l.normalColor = "#FFFFFF", l.pressedColor = "#FFFFFF", l } return __extends(i, e), Object.defineProperty(i.prototype, "frameName", { set: function(t) { this.changeFrame(t) }, enumerable: !0, configurable: !0 }), i.prototype.setFrames = function(t, e, i, o) { switch (this.overFrame = t, this.outFrame = e, this.downFrame = i, this.upFrame = o, this.currentState) {
                case "overFrame":
                    this.frameName = this.overFrame; break;
                case "outFrame":
                    this.frameName = this.outFrame; break;
                case "downFrame":
                    this.frameName = this.downFrame; break;
                case "upFrame":
                    this.frameName = this.upFrame } }, i.prototype.onInputOverHandler = function(t, e) { e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || this.onOverMouseOnly && !e.isMouse || this.onInputOver && (this.onInputOver.dispatch(this, e), this.frameName = this.overFrame, this.currentState = "overFrame") }, i.prototype.onInputOutHandler = function(t, e) { this.onInputOut && (this.onInputOut.dispatch(this, e), this.frameName = this.outFrame, this.currentState = "outFrame") }, i.prototype.onInputDownHandler = function(t, e) { this.onInputDown && (this.onInputDown.dispatch(this, e), this.frameName = this.downFrame, this.currentState = "downFrame") }, i.prototype.onInputUpHandler = function(t, e, i) { this.onInputUp && (this.onInputUp.dispatch(this, e, i), this.frameName = this.upFrame, this.currentState = "upFrame") }, i.prototype.setTransitionColor = function(t, e, i) { this.normalColor = t, this.pressedColor = e, this.hoverColor = i }, i.prototype.enableAnimation = function() { this.ph2Animations = new t.AnimationManager(this.game), this.cacheAnimations = [], this.animationsName = [] }, i.prototype.addAnimation = function(t) { this.cacheAnimations.push(t), this.animationsName.push(t.name) }, i.prototype.getAnimations = function() { return this.cacheAnimations }, i.prototype.getAnimationsName = function() { return this.animationsName }, Object.defineProperty(i.prototype, "scaleX", { get: function() { return this.scale.x }, set: function(t) { this.scale.x = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "scaleY", { get: function() { return this.scale.y }, set: function(t) { this.scale.y = t }, enumerable: !0, configurable: !0 }), i.prototype.enableAlignment = function() { this.alignment = new t.UIAlignment(this.game) }, i.prototype.enableOrientationProperties = function() { this.orientationProperties = new t.UIOrientationProperties(this.game, this) }, i.prototype.enableVisibility = function(e, i) { this.visibility = new t.UIVisibility(this.game), this.visibility.setPlatformVisible(e), this.visibility.setOrientationVisible(i) }, i.prototype.enableState = function(e) { this.stateManager = new t.UIStates(this, e) }, i.prototype.setCurrentState = function(t) { this.stateManager.setCurrentState(t) }, i.prototype.getAllStates = function() { return this.stateManager ? this.stateManager.getAllStates() : [] }, i.prototype.getCurrentState = function() { return this.stateManager.getCurrentState() }, i.prototype.checkExistState = function(t) { return void 0 !== this.stateManager && this.stateManager.checkExistState(t) }, i.prototype.windowSizeChanged = function() { this.visibility && this.visibility.applyVisibility(this), this.orientationProperties && this.orientationProperties.apply(this), this.alignment && this.alignment.applyAlignment(this); for (var t = 0; t < this.children.length; t++) "function" == typeof this.children[t].windowSizeChanged && this.children[t].windowSizeChanged() }, i.prototype.destroy = function() { for (var t = [], i = 0; i < arguments.length; i++) t[i] = arguments[i];
            e.prototype.destroy.call(this, t), this.onInputOver.dispose(), this.onInputOut.dispose(), this.onInputDown.dispose(), this.onInputUp.dispose(), this.visibility = null, this.ph2Animations && this.ph2Animations.destroy(), this.stateManager && (this.stateManager = null), this.cacheAnimations && (this.cacheAnimations.length = 0, this.cacheAnimations = null), this.animationsName && (this.animationsName.length = 0, this.animationsName = null) }, i }(PhaserNineSlice.NineSlice);
    t.UISlicedButton = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(e) {
        function i(t, i, o, n, s, r, a, h) { return e.call(this, t, i, o, n, s, r, a, h) || this } return __extends(i, e), Object.defineProperty(i.prototype, "frameName", { set: function(t) { this.changeFrame(t) }, enumerable: !0, configurable: !0 }), i.prototype.enableAnimation = function() { this.ph2Animations = new t.AnimationManager(this.game), this.cacheAnimations = [], this.animationsName = [] }, i.prototype.addAnimation = function(t) { this.cacheAnimations.push(t), this.animationsName.push(t.name) }, i.prototype.getAnimations = function() { return this.cacheAnimations }, i.prototype.getAnimationsName = function() { return this.animationsName }, Object.defineProperty(i.prototype, "scaleX", { get: function() { return this.scale.x }, set: function(t) { this.scale.x = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "scaleY", { get: function() { return this.scale.y }, set: function(t) { this.scale.y = t }, enumerable: !0, configurable: !0 }), i.prototype.enableAlignment = function() { this.alignment = new t.UIAlignment(this.game) }, i.prototype.enableOrientationProperties = function() { this.orientationProperties = new t.UIOrientationProperties(this.game, this) }, i.prototype.enableVisibility = function(e, i) { this.visibility = new t.UIVisibility(this.game), this.visibility.setPlatformVisible(e), this.visibility.setOrientationVisible(i) }, i.prototype.enableState = function(e) { this.stateManager = new t.UIStates(this, e) }, i.prototype.setCurrentState = function(t) { this.stateManager.setCurrentState(t) }, i.prototype.getAllStates = function() { return this.stateManager ? this.stateManager.getAllStates() : [] }, i.prototype.getCurrentState = function() { return this.stateManager.getCurrentState() }, i.prototype.checkExistState = function(t) { return void 0 !== this.stateManager && this.stateManager.checkExistState(t) }, i.prototype.windowSizeChanged = function() { this.visibility && this.visibility.applyVisibility(this), this.orientationProperties && this.orientationProperties.apply(this), this.alignment && this.alignment.applyAlignment(this); for (var t = 0; t < this.children.length; t++) "function" == typeof this.children[t].windowSizeChanged && this.children[t].windowSizeChanged() }, i.prototype.destroy = function() { for (var t = [], i = 0; i < arguments.length; i++) t[i] = arguments[i];
            e.prototype.destroy.call(this, t), this.alignment && (this.alignment.destroy(), this.alignment = null), this.visibility = null, this.ph2Animations && this.ph2Animations.destroy(), this.stateManager && (this.stateManager = null), this.cacheAnimations && (this.cacheAnimations.length = 0, this.cacheAnimations = null), this.animationsName && (this.animationsName.length = 0, this.animationsName = null) }, i }(PhaserNineSlice.NineSlice);
    t.UISlicedSprite = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(e) {
        function i(t, i, o, n, s) { return e.call(this, t, i, o, n, s) || this } return __extends(i, e), i.prototype.enableAlignment = function() { this.alignment = new t.UIAlignment(this.game) }, i.prototype.enableAnimation = function() { this.ph2Animations = new t.AnimationManager(this.game), this.animationsName = [], this.cacheAnimations = [] }, i.prototype.addAnimation = function(t) { this.cacheAnimations.push(t), this.animationsName.push(t.name) }, i.prototype.getAnimations = function() { return this.cacheAnimations }, i.prototype.getAnimationsName = function() { return this.animationsName }, Object.defineProperty(i.prototype, "scaleX", { get: function() { return this.scale.x }, set: function(t) { this.scale.x = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "scaleY", { get: function() { return this.scale.y }, set: function(t) { this.scale.y = t }, enumerable: !0, configurable: !0 }), i.prototype.enableVisibility = function(e, i) { this.visibility = new t.UIVisibility(this.game), this.visibility.setPlatformVisible(e), this.visibility.setOrientationVisible(i) }, i.prototype.enableOrientationProperties = function() { this.orientationProperties = new t.UIOrientationProperties(this.game, this) }, i.prototype.enableState = function(e) { this.stateManager = new t.UIStates(this, e) }, i.prototype.setCurrentState = function(t) { this.stateManager.setCurrentState(t) }, i.prototype.getAllStates = function() { return this.stateManager ? this.stateManager.getAllStates() : [] }, i.prototype.getCurrentState = function() { return this.stateManager.getCurrentState() }, i.prototype.checkExistState = function(t) { return void 0 !== this.stateManager && this.stateManager.checkExistState(t) }, i.prototype.windowSizeChanged = function() { this.visibility && this.visibility.applyVisibility(this), this.orientationProperties && this.orientationProperties.apply(this), this.alignment && this.alignment.applyAlignment(this); for (var t = 0; t < this.children.length; t++) "function" == typeof this.children[t].windowSizeChanged && this.children[t].windowSizeChanged() }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.alignment && (this.alignment.destroy(), this.alignment = null), this.visibility = null, this.ph2Animations && this.ph2Animations.destroy(), this.stateManager && (this.stateManager = null), this.cacheAnimations && (this.cacheAnimations.length = 0, this.cacheAnimations = null), this.animationsName && (this.animationsName.length = 0, this.animationsName = null) }, i }(Phaser.Sprite);
    t.UISprite = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e;! function(t) { t[t.TESTPIXEL = 0] = "TESTPIXEL", t[t.FUNCTION = 1] = "FUNCTION" }(e = t.UITextFitLogic || (t.UITextFitLogic = {})); var i = function(i) {
        function o(t, e, o, n, s) { var r = i.call(this, t, e, o, n, s) || this; return r.fitEnable = !1, r } return __extends(o, i), o.prototype.enableAnimation = function() { this.ph2Animations = new t.AnimationManager(this.game), this.cacheAnimations = [], this.animationsName = [] }, o.prototype.addAnimation = function(t) { this.cacheAnimations.push(t), this.animationsName.push(t.name) }, o.prototype.getAnimations = function() { return this.cacheAnimations }, o.prototype.getAnimationsName = function() { return this.animationsName }, o.prototype.enableFitSizetext = function(t, e, i) { this.originSize = t, this.maxWidth = e, this.maxHeight = i, this.fitFontSizeText(), this.fitEnable = !0 }, o.prototype.fitFontSizeText = function() { o.logicReduction === e.FUNCTION ? this.fitFunction() : this.fitTest() }, o.prototype.fitFunction = function() { var t, e, i;
            this.fontSize = this.originSize, e = this.width, this.height, i = this.fontSize, this.wordWrap = !1, e > this.maxWidth && (t = i * this.maxWidth / e, this.fontSize = Math.abs(t)) }, o.prototype.fitTest = function() { var t, e, i, n; for (this.fontSize = this.originSize, e = this.width, i = this.height, n = this.fontSize; e > this.maxWidth || i > this.maxHeight && -1 !== this.maxHeight;) { if ((t = parseInt(n.toString().replace("px", ""), 10) - o.pixelToTest) < o.minFontSize) { n = t = o.minFontSize, this.setStyle({ fontSize: n }, !0); break } n = t, this.fontSize = n, e = this.width, i = this.height } }, Object.defineProperty(o.prototype, "text", { get: function() { return this._text }, set: function(t) { t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform()), !0 === this.fitEnable && this.fitFontSizeText() }, enumerable: !0, configurable: !0 }), Object.defineProperty(o.prototype, "scaleX", { get: function() { return this.scale.x }, set: function(t) { this.scale.x = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(o.prototype, "scaleY", { get: function() { return this.scale.y }, set: function(t) { this.scale.y = t }, enumerable: !0, configurable: !0 }), o.prototype.enableAlignment = function() { this.alignment = new t.UIAlignment(this.game) }, o.prototype.enableOrientationProperties = function() { this.orientationProperties = new t.UIOrientationProperties(this.game, this) }, o.prototype.enableVisibility = function(e, i) { this.visibility = new t.UIVisibility(this.game), this.visibility.setPlatformVisible(e), this.visibility.setOrientationVisible(i) }, o.prototype.enableState = function(e) { this.stateManager = new t.UIStates(this, e) }, o.prototype.setCurrentState = function(t) { this.stateManager.setCurrentState(t) }, o.prototype.getAllStates = function() { return this.stateManager ? this.stateManager.getAllStates() : [] }, o.prototype.getCurrentState = function() { return this.stateManager.getCurrentState() }, o.prototype.checkExistState = function(t) { return void 0 !== this.stateManager && this.stateManager.checkExistState(t) }, o.prototype.windowSizeChanged = function() { this.visibility && this.visibility.applyVisibility(this), this.orientationProperties && this.orientationProperties.apply(this), this.alignment && this.alignment.applyAlignment(this); for (var t = 0; t < this.children.length; t++) void 0 !== this.children[t].windowSizeChanged && this.children[t].windowSizeChanged() }, o.prototype.determineFontProperties = function(e) { var i, o = Phaser.Text.fontPropertiesCache[e]; if (t.UITextStyle.textStyles[e] || (i = new t.UITextStyle, t.UITextStyle.textStyles[e] = i), (i = t.UITextStyle.textStyles[e]).needUpdate || !o) { i.needUpdate = !1; var n = Phaser.Text.fontPropertiesCanvas,
                    s = Phaser.Text.fontPropertiesContext;
                s.font = e; var r = Math.ceil(s.measureText(i.testString).width * i.baselineX),
                    a = r,
                    h = 2 * a; if (a = a * i.baselineY | 0, n.width = r, n.height = h, s.fillStyle = "#f00", s.fillRect(0, 0, r, h), s.font = e, s.textBaseline = "alphabetic", s.fillStyle = "#000", s.fillText(i.testString, 0, a), o = { ascent: 0, descent: 0, fontSize: 0 }, !s.getImageData(0, 0, r, h)) return o.ascent = a, o.descent = a + 6, o.fontSize = o.ascent + o.descent, Phaser.Text.fontPropertiesCache[e] = o, o; var l = s.getImageData(0, 0, r, h).data,
                    c = l.length,
                    d = 4 * r,
                    u = void 0,
                    p = void 0,
                    m = 0,
                    f = !1; for (u = 0; u < a; u++) { for (p = 0; p < d; p += 4)
                        if (255 !== l[m + p]) { f = !0; break } if (f) break;
                    m += d } for (o.ascent = a - u, m = c - d, f = !1, u = h; u > a; u--) { for (p = 0; p < d; p += 4)
                        if (255 !== l[m + p]) { f = !0; break } if (f) break;
                    m -= d } o.descent = u - a, o.fontSize = o.descent + o.ascent, Phaser.Text.fontPropertiesCache[e] = o } return o }, o.prototype.destroy = function(t) { i.prototype.destroy.call(this, t), this.alignment && (this.alignment.destroy(), this.alignment = null), this.visibility = null, this.ph2Animations && this.ph2Animations.destroy(), this.stateManager && (this.stateManager = null), this.cacheAnimations && (this.cacheAnimations.length = 0, this.cacheAnimations = null), this.animationsName && (this.animationsName.length = 0, this.animationsName = null) }, o.minFontSize = 10, o.logicReduction = e.FUNCTION, o.pixelToTest = 1, o }(Phaser.Text);
    t.UIText = i }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function t() { this.needUpdate = !0, this.innerTestString = t.testStringDefault, this.innerBaselineX = t.baseLineXDefault, this.innerBaselineY = t.baseLineYDefault } return Object.defineProperty(t.prototype, "testString", { get: function() { return this.innerTestString }, set: function(t) { this.innerTestString = t, this.needUpdate = !0 }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, "baselineX", { get: function() { return this.innerBaselineX }, set: function(t) { this.innerBaselineX = t, this.needUpdate = !0 }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, "baselineY", { get: function() { return this.innerBaselineY }, set: function(t) { this.innerBaselineY = t, this.needUpdate = !0 }, enumerable: !0, configurable: !0 }), t.textStyles = {}, t.testStringDefault = "|MÃ‰qgy", t.baseLineXDefault = 1.2, t.baseLineYDefault = 1.4, t }();
    t.UITextStyle = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(e) {
        function i(t, i, o, n, s, r, a) { return e.call(this, t, i, o, n, s, r, a) || this } return __extends(i, e), i.prototype.enableAnimation = function() { this.ph2Animations = new t.AnimationManager(this.game), this.cacheAnimations = [], this.animationsName = [] }, i.prototype.addAnimation = function(t) { this.cacheAnimations.push(t), this.animationsName.push(t.name) }, i.prototype.getAnimations = function() { return this.cacheAnimations }, i.prototype.getAnimationsName = function() { return this.animationsName }, Object.defineProperty(i.prototype, "scaleX", { get: function() { return this.scale.x }, set: function(t) { this.scale.x = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "scaleY", { get: function() { return this.scale.y }, set: function(t) { this.scale.y = t }, enumerable: !0, configurable: !0 }), i.prototype.enableAlignment = function() { this.alignment = new t.UIAlignment(this.game) }, i.prototype.enableOrientationProperties = function() { this.orientationProperties = new t.UIOrientationProperties(this.game, this) }, i.prototype.enableVisibility = function(e, i) { this.visibility = new t.UIVisibility(this.game), this.visibility.setPlatformVisible(e), this.visibility.setOrientationVisible(i) }, i.prototype.enableState = function(e) { this.stateManager = new t.UIStates(this, e) }, i.prototype.setCurrentState = function(t) { this.stateManager.setCurrentState(t) }, i.prototype.getAllStates = function() { return this.stateManager ? this.stateManager.getAllStates() : [] }, i.prototype.getCurrentState = function() { return this.stateManager.getCurrentState() }, i.prototype.checkExistState = function(t) { return void 0 !== this.stateManager && this.stateManager.checkExistState(t) }, i.prototype.windowSizeChanged = function() { this.visibility && this.visibility.applyVisibility(this), this.orientationProperties && this.orientationProperties.apply(this), this.alignment && this.alignment.applyAlignment(this); for (var t = 0; t < this.children.length; t++) "function" == typeof this.children[t].windowSizeChanged && this.children[t].windowSizeChanged() }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.alignment && (this.alignment.destroy(), this.alignment = null), this.visibility = null, this.ph2Animations && this.ph2Animations.destroy(), this.stateManager && (this.stateManager = null), this.cacheAnimations && (this.cacheAnimations.length = 0, this.cacheAnimations = null), this.animationsName && (this.animationsName.length = 0, this.animationsName = null) }, i }(Phaser.TileSprite);
    t.UITiledSprite = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function t(t) { this.animations = {}, this.game = t, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this), this.game.ph2AnimationManager.pauseAllSignal.add(this.pauseAll, this), this.game.ph2AnimationManager.resumeAllSignal.add(this.resumeAll, this), this.game.ph2AnimationManager.stopAllSignal.add(this.stopAll, this) } return t.prototype.play = function(t, e, i) { return this.animations[t] ? this.currentAnim ? this.currentAnim.name === t ? this.currentAnim.isPlaying() ? this.currentAnim : this.currentAnim.play(e, i) : (this.currentAnim.isPlaying() && this.currentAnim.stop(), this.currentAnim = this.animations[t], this.currentAnim.play(e, i)) : (this.currentAnim = this.animations[t], this.currentAnim.play(e, i)) : null }, t.prototype.stop = function(t, e, i) { this.currentAnim && (t ? this.currentAnim.name === t && this.currentAnim.stop(e, i) : this.currentAnim.stop(e, i)) }, t.prototype.pause = function(t) { this.currentAnim && (t ? this.currentAnim.name === t && this.currentAnim.pause() : this.currentAnim.pause()) }, t.prototype.resume = function(t) { this.currentAnim && (t ? this.currentAnim.name === t && this.currentAnim.resume() : this.currentAnim.resume()) }, t.prototype.add = function(t) { this.animations[t.name] = t }, t.prototype.onPause = function() { this.currentAnim && this.currentAnim.autoPause() }, t.prototype.onResume = function() { this.currentAnim && this.currentAnim.autoResume() }, t.prototype.getAnimations = function() { return this.animations }, t.prototype.getCurrentAnimation = function() { return this.currentAnim }, t.prototype.removeListeners = function(t) { var e = this.animations[t];
            e && e.removeListeners() }, t.prototype.pauseAll = function() { this.currentAnim && this.currentAnim.batchPause() }, t.prototype.resumeAll = function() { this.currentAnim && this.currentAnim.batchResume() }, t.prototype.stopAll = function(t) { this.currentAnim && !this.currentAnim.isStopped() && this.currentAnim.stop(!0, t) }, t.prototype.destroy = function() { this.currentAnim && this.currentAnim.stop(), this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game.ph2AnimationManager.pauseAllSignal.remove(this.pauseAll, this), this.game.ph2AnimationManager.resumeAllSignal.remove(this.resumeAll, this), this.game.ph2AnimationManager.stopAllSignal.remove(this.stopAll, this); for (var t = Object.keys(this.animations), e = 0; e < t.length; e++) this.animations[t[e]].destroy() }, t }();
    t.AnimationManager = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function t(t) { this.game = t, this.alignBounds = new Phaser.Rectangle(0, 0, this.game.width, this.game.height) } return t.prototype.changeOrientation = function(t) { this.currentOrientation = t }, t.prototype.getCurrentOrientation = function() { return this.currentOrientation }, t.alignInParent = function(t, e, i, o) { if ("__world" !== t.parent.name) { var n = t.parent.scale;
                t.parent.scale.setTo(1), t.alignIn(t.parent, e, i, o), t.left -= t.parent.left + t.parent.width * t.parent.anchor.x, t.top -= t.parent.top + t.parent.height * t.parent.anchor.y, t.parent.scale = n } }, t }();
    t.AlignmentSystem = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) {! function(t) { t[t.LANDSCAPE = 0] = "LANDSCAPE", t[t.PORTRAIT = 1] = "PORTRAIT" }(t.Orientation || (t.Orientation = {})); var e = function() {
        function e(t) { this.game = t, this.gameSizeChanged = new Phaser.Signal, this.orientationChanged = new Phaser.Signal } return e.prototype.onGameResize = function(e, i) { this.game.ph2UIManager.alignmentManager.alignBounds.width = e, this.game.ph2UIManager.alignmentManager.alignBounds.height = i, e > i ? this.game.ph2UIManager.alignmentManager.changeOrientation(t.Orientation.LANDSCAPE) : this.game.ph2UIManager.alignmentManager.changeOrientation(t.Orientation.PORTRAIT), this.gameSizeChanged.dispatch(e, i) }, e }();
    t.UIEventManager = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(e) {
        function i(t, i) { var o = e.call(this, t, i) || this; return TweenLite.defaultEase = Linear.easeNone, o.addAnimationManager(), o.addAnimationFactory(), o } return __extends(i, e), i.prototype.addAnimationManager = function() { Phaser.Game.prototype.ph2AnimationManager = new t.AnimationSystem(this.game), Phaser.Game.prototype.ph2UIManager = new t.UISystem(this.game) }, i.prototype.addAnimationFactory = function() { Phaser.GameObjectFactory.prototype.ph2AnimationObject = function(t, e, i, o, n) { void 0 === n && (n = this.world); var s = this.game.ph2AnimationManager.getAnimationObject(i, o); return s.x = t, s.y = e, n.add(s), s }, Phaser.GameObjectCreator.prototype.ph2AnimationObject = function(t, e, i, o) { var n = this.game.ph2AnimationManager.getAnimationObject(i, o); return n.x = t, n.y = e, n }, Phaser.GameObjectFactory.prototype.ph2UI = function(t, e, i) { void 0 === i && (i = this.world); var o = this.game.ph2UIManager.getUI(t, e); return i.add(o), o }, Phaser.GameObjectCreator.prototype.ph2UI = function(t, e) { return this.game.ph2UIManager.getUI(t, e) } }, i }(Phaser.Plugin);
    t.AnimationPlugin = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function e(e) { this.game = e, this.events = new t.UIEventManager(this.game), this.alignmentManager = new t.AlignmentSystem(this.game), this.scale = 1, this.enableVisibilityAndOrientationComponent = !0 } return e.prototype.setCurrentPlatform = function(t) { this.currentPlatform = t }, e.prototype.setGameScale = function(t) { this.scale = t }, Object.defineProperty(e.prototype, "gameScale", { get: function() { return this.scale }, enumerable: !0, configurable: !0 }), e.prototype.createCacheUINode = function(e, i, o, n, s) { var r = e.name,
                a = r;
            s && (a = s + "/" + r); var h = null,
                l = i[a]; if (null === n) h = t.CacheFactory.UICanvas(r, l);
            else { var c = l.type; "sprite" === c ? h = t.CacheFactory.UISprite(r, l, e.animations) : "container" === c ? h = t.CacheFactory.UIGroup(r, l, e.animations) : "button" === c ? h = t.CacheFactory.UIButton(r, l, e.animations) : "text" === c && (h = t.CacheFactory.UIText(r, l, e.animations)) } return h }, e.prototype.createCacheUIDataTree = function(t, e, i, o) { var n = null; if (t) { var s = t.name; if (n = this.createCacheUINode(t, e, t.animations, i, o), t.children) { o = null !== o ? 0 === o.length ? s : o + "/" + s : ""; for (var r = t.children, a = 0; a < r.length; a++) { var h = this.createCacheUIDataTree(r[a], e, n, o);
                        h && n.addChild(h) } } } return n }, e.prototype.generateUIData = function(e) { var i = e.hierarchy,
                o = e.properties,
                n = this.createCacheUIDataTree(i, o, null, null); return new t.UIData(n) }, e.prototype.getUIDataFromJSON = function(t) { var e = this.game.cache.getJSON(t); return e ? this.generateUIData(e) : null }, e.prototype.getUIData = function(t) { return this.getUIDataFromJSON(t) }, e.prototype.getUI = function(t, e) { var i = this.getUIData(t),
                o = this.createTree(i.hierarchy, e, null); return this.addAnimations(o), o.windowSizeChanged(), o }, e.prototype.createTree = function(t, e, i) { var o = null; if (t && (o = this.createNode(t, e, i), t.children))
                for (var n = t.children, s = 0; s < n.length; s++) { var r = this.createTree(n[s], e, o);
                    r && o.addChild(r) }
            return o }, e.prototype.createNode = function(e, i, o) { var n = null; return null === o ? n = t.UIFactory.UICanvas(this.game, e) : e instanceof t.CacheUISprite ? n = t.UIFactory.UISprite(this.game, e, i, o) : e instanceof t.CacheUIGroup ? n = t.UIFactory.UIGroup(this.game, e, o) : e instanceof t.CacheUIButton ? n = t.UIFactory.UIButton(this.game, e, i, o) : e instanceof t.CacheUIText && (n = t.UIFactory.UIText(this.game, e, o)), n }, e.prototype.addAnimations = function(e) { var i = e.getAnimations(); if (i)
                for (var o = 0, n = i; o < n.length; o++) { var s = n[o];
                    t.UIFactory.addAnimationToNode(e, s) }
            for (var r = e.children, a = 0; a < r.length; a++) this.addAnimations(r[a]) }, e.findObject = function(t, e) { for (var i = e, o = "/" !== t[0] ? 0 : 1, n = t.split("/"), s = o; s < n.length; s++) { var r = n[s],
                    a = i.children;
                i = null; for (var h = 0, l = a.length; h < l; ++h) { var c = a[h]; if (c.name === r) { i = c; break } } if (!i) return null } return i }, e.changeStateObject = function(t, i, o, n) { void 0 === n && (n = !1); var s = "" === t ? i : e.findObject(t, i);
            s && (s.checkExistState(o) && s.setCurrentState(o), n && e.sendStateSignalChildrens(s.children, o)) }, e.playAnimationObject = function(t, i, o, n, s) { var r = "" === t ? i : e.findObject(t, i); return r ? void 0 === r.ph2Animations ? null : -1 === r.getAnimationsName().indexOf(o) ? null : r.ph2Animations.play(o, n, s) : null }, e.stopAnimationObject = function(t, i, o, n, s) { var r = "" === t ? i : e.findObject(t, i);
            r && void 0 !== r.ph2Animations && -1 !== r.getAnimationsName().indexOf(o) && r.ph2Animations.stop(o, n, s) }, e.pauseAnimationObject = function(t, i, o) { var n = "" === t ? i : e.findObject(t, i);
            n && void 0 !== n.ph2Animations && -1 !== n.getAnimationsName().indexOf(o) && n.ph2Animations.pause(o) }, e.resumeAnimationObject = function(t, i, o) { var n = "" === t ? i : e.findObject(t, i); if (n) { if (void 0 === n.ph2Animations) return; if (-1 === n.getAnimationsName().indexOf(o)) return;
                n.ph2Animations.resume(o) } }, e.sendStateSignalChildrens = function(t, e) { for (var i = 0, o = t; i < o.length; i++) { var n = o[i];
                n.checkExistState(e) ? (n.setCurrentState(e), this.sendStateSignalChildrens(n.children, e)) : this.sendStateSignalChildrens(n.children, e) } }, e }();
    t.UISystem = e }(Ph2 || (Ph2 = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Ph2;
! function(t) { var e = function() {
        function e(t) { this.game = t, this.onProgress = new Phaser.Signal, this.useScaledAssets = !1, this.spineScaleVariant = void 0, this.debugEnabled = !1, this.searchPath = "", this.defaultAtlasExtension = this.defaultJSONExtension = ".json", this.defaultImageExtension = ".png", this.defaultBitmapFontImageExtension = ".png", this.defaultBitmapFontFontExtension = ".fnt" } return e.prototype.debug = function(t) { this.debugEnabled = t }, e.prototype.useScalingVariant = function(t) { this.useScaledAssets = !0, this.scaleFolder = t }, e.prototype.useSpineScalingVariant = function(t) { this.spineScaleVariant = t }, e.prototype.disableScalingVariant = function() { this.useScaledAssets = !1 }, e.prototype.disableSpineScalingVariant = function() { this.spineScaleVariant = void 0 }, e.prototype.setAssetsResources = function(t) { this.resources = t }, e.prototype.load = function(t) { if (this.debugMessage("Loading Resource Groups: " + JSON.stringify(t)), this.resources)
                if ("string" == typeof t) this.loadGroup(t);
                else
                    for (var e = 0, i = t; e < i.length; e++) { var o = i[e];
                        this.loadGroup(o) } }, e.prototype.loadGroup = function(t) { this.debugMessage("Loading: " + t); var e = this.resources[t]; if (e) { if (this.useScaledAssets && this.debugMessage("Using scaling variant: " + this.scaleFolder), e.image) { this.cleanSearchPath(); for (var i = 0, o = e.image; i < o.length; i++) { var n = o[i];
                        void 0 !== n.searchPath ? this.setSearchPath(n.searchPath) : this.loadImage(n.key, n.url) } } if (e.json) { this.cleanSearchPath(); for (var s = 0, r = e.json; s < r.length; s++) { var a = r[s];
                        void 0 !== a.searchPath ? this.setSearchPath(a.searchPath) : this.loadJson(a.key, a.url) } } if (e.atlas) { this.cleanSearchPath(); for (var h = 0, l = e.atlas; h < l.length; h++) { var c = l[h];
                        void 0 !== c.searchPath ? this.setSearchPath(c.searchPath) : this.loadAtlas(c.key, c.texture, c.atlas) } } if (e.spine) { this.cleanSearchPath(); for (var d = 0, u = e.spine; d < u.length; d++) { var p = u[d];
                        void 0 !== p.searchPath ? this.setSearchPath(p.searchPath) : this.loadSpine(p.key, p.url) } } if (e.bitmapFont) { this.cleanSearchPath(); for (var m = 0, f = e.bitmapFont; m < f.length; m++) { var y = f[m];
                        void 0 !== y.searchPath ? this.setSearchPath(y.searchPath) : this.loadBitmapFont(y.key, y.texture, y.fnt) } } } }, e.prototype.cleanSearchPath = function() { this.searchPath = "", this.debugMessage('+++ searchPath: ""') }, e.prototype.setSearchPath = function(t) { this.searchPath = t, this.debugMessage('+++ searchPath: "' + t + '"') }, e.prototype.loadImage = function(t, e) { void 0 === e && (e = t + this.defaultImageExtension), e = this.getUrl(e), this.game.load.image(t, e), this.debugMessage("load.image: " + t + " | " + e) }, e.prototype.loadJson = function(e, i) { void 0 === i && (i = e + this.defaultJSONExtension), i = t.Loader.joinPath(this.searchPath, i), this.game.load.json(e, i), this.debugMessage("load.json: " + e + " | " + i) }, e.prototype.loadAtlas = function(t, e, i) { void 0 === e && (e = t + this.defaultImageExtension), void 0 === i && (i = t + this.defaultAtlasExtension), e = this.getUrl(e), i = this.getUrl(i), this.game.load.atlas(t, e, i), this.debugMessage("load.atlas: " + t + " | " + e + " | " + i) }, e.prototype.loadSpine = function(e, i) { this.game.load.spine && (void 0 === i && (i = e + this.defaultJSONExtension), i = t.Loader.joinPath(this.searchPath, i), this.spineScaleVariant ? (this.game.load.spine(e, i, [this.spineScaleVariant]), this.debugMessage("load.spine: " + e + " | " + i + " | " + this.spineScaleVariant)) : (this.game.load.spine(e, i), this.debugMessage("load.atlas: " + e + " | " + i))) }, e.prototype.loadBitmapFont = function(t, e, i) { void 0 === e && (e = t + this.defaultBitmapFontImageExtension), void 0 === i && (i = t + this.defaultBitmapFontFontExtension), e = this.getUrl(e), i = this.getUrl(i), this.game.load.bitmapFont(t, e, i), this.debugMessage("load.bitmapFont: " + t + " | " + e + " | " + i) }, e.prototype.debugMessage = function(t) { this.debugEnabled }, e.prototype.getUrl = function(e) { if (this.useScaledAssets) { var i = t.Loader.getDirectoryName(e),
                    o = t.Loader.getBaseName(e);
                e = t.Loader.joinPath(i, this.scaleFolder, o) } return t.Loader.joinPath(this.searchPath, e) }, e.getDirectoryName = function(t) { return t.replace(/((.*)(\/|\\|\\\\))?(.*?\..*$)?/, "$2") }, e.getBaseName = function(t) { var e = t.indexOf("?");
            e > 0 && (t = t.substring(0, e)); var i = /(\/|\\\\)([^(\/|\\\\)]+)$/g.exec(t.replace(/(\/|\\\\)$/, "")); return i ? i[2] : t }, e.joinPath = function() { for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e]; for (var i = arguments.length, o = "", n = 0; n < i; n++) o = (o + ("" === o ? "" : "/") + arguments[n]).replace(/(\/|\\\\)$/, ""); return o }, e }();
    t.Loader = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(e) {
        function i(t, i) { var o = e.call(this, t, i) || this; return o.addLoader(), o } return __extends(i, e), i.prototype.addLoader = function() { Phaser.Game.prototype.ph2Loader = new t.Loader(this.game) }, i }(Phaser.Plugin);
    t.LoaderPlugin = e }(Ph2 || (Ph2 = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Ph2;
! function(t) { var e = function() {
        function t(t) { this.game = t, this.signals = {} } return t.prototype.addObserver = function(t, e, i, o) { this.signals[t] ? o ? this.signals[t].addOnce(e, i) : this.signals[t].add(e, i) : (this.createNotification(t), this.addObserver(t, e, i, o)) }, t.prototype.removeObserver = function(t, e, i) { this.signals[t] && this.signals[t].remove(e, i) }, t.prototype.removeAllObservers = function(t, e) { this.signals[t] && (this.signals[t].removeAll(e), void 0 === e && this.removeSignal(t)) }, t.prototype.removeAllObserversFromContext = function(t) { for (var e in this.signals) this.signals.hasOwnProperty(e) && this.signals[e].removeAll(t) }, t.prototype.postNotification = function(t) { for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i]; if (this.signals[t]) { var o = [];
                arguments.length > 1 && (o = Array.prototype.splice.call(arguments, 1)), Phaser.Signal.prototype.dispatch.apply(this.signals[t], o) } }, t.prototype.createNotification = function(t) { this.signals[t] || (this.signals[t] = new Phaser.Signal) }, t.prototype.removeSignal = function(t) { this.signals[t] && (this.signals[t].dispose(), delete this.signals[t]) }, t }();
    t.NotificationManager = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(e) {
        function i(t, i) { var o = e.call(this, t, i) || this; return o.addNotificationManager(), o } return __extends(i, e), i.prototype.addNotificationManager = function() { Phaser.Game.prototype.ph2NotificationManager = new t.NotificationManager(this.game) }, i }(Phaser.Plugin);
    t.NotificationPlugin = e }(Ph2 || (Ph2 = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Ph2;
! function(t) { var e = function() {
        function t(t) { this.game = t, this.musicEnabled = !0, this.sfxEnabled = !0, this.playingMusic = !1, this.game.onPause.add(this.gamePaused, this), this.game.onResume.add(this.gameResumed, this) } return t.prototype.setAudioEffectsFile = function(t) { this.soundsFile = t }, t.prototype.playEffect = function(t, e) { if (!this.sfxEnabled) return null; var i = null; return e ? this.loopSoundExist(t) || (i = this.soundsFile.play(t), this.loopingSounds[t] = i) : i = this.soundsFile.play(t), i }, t.prototype.stopEffect = function(t) { this.sfxEnabled && this.soundsFile.stop(t) }, t.prototype.pauseEffect = function(t) { this.soundsFile.pause(t) }, t.prototype.pauseLoopEffect = function(t) { var e = this.loopingSounds[t];
            e && this.soundsFile.pause(e) }, t.prototype.resumeEffect = function(t) { this.sfxEnabled && this.soundsFile.play(t) }, t.prototype.resumeLoopEffect = function(t) { if (this.sfxEnabled) { var e = this.loopingSounds[t];
                e && this.soundsFile.play(e) } }, t.prototype.stopAllLoopEffects = function() { for (var t in this.loopingSounds) this.loopingSounds.hasOwnProperty(t) && this.soundsFile.stop(t);
            this.loopingSounds = {} }, t.prototype.pauseAllLoopEffects = function() { for (var t in this.loopingSounds) this.loopingSounds.hasOwnProperty(t) && this.soundsFile.pause(t) }, t.prototype.resumeAllLoopEffects = function() { for (var t in this.loopingSounds) this.loopingSounds.hasOwnProperty(t) && this.soundsFile.play(t) }, t.prototype.stopLoopEffect = function(t) { this.loopingSounds[t] && this.soundsFile.stop(this.loopingSounds[t]), delete this.loopingSounds[t] }, t.prototype.switchMusicState = function() { this.musicEnabled = !this.musicEnabled }, t.prototype.switchSfxState = function() { this.sfxEnabled = !this.sfxEnabled }, t.prototype.playMusic = function(t) { this.musicEnabled && (this.selectMusic(t), this.musicFile && (this.musicFile.play(), this.playingMusic = !0)) }, t.prototype.pauseMusic = function() { this.playingMusic && this.musicFile && (this.musicFile.pause(), this.playingMusic = !1) }, t.prototype.stopMusic = function() { this.musicFile && (this.musicFile.stop(), this.playingMusic = !1, this.musicFile = null) }, t.prototype.resumeMusic = function() { this.musicFile && !this.playingMusic && this.musicEnabled && (this.musicFile.play(), this.playingMusic = !0) }, t.prototype.selectMusic = function(t) { this.musicFile && this.stopMusic(), this.musicFile = t }, t.prototype.switchMusic = function(t) { this.musicFile && this.musicFile._src == t._src || this.playMusic(t) }, t.prototype.fadeCurrentMusic = function(t, e, i) { this.musicEnabled && this.musicFile && this.playingMusic && this.musicFile.fade(t, e, i) }, t.prototype.setVolumeCurrentMusic = function(t) { this.musicEnabled && this.musicFile && this.playingMusic && this.musicFile.volume(t) }, t.prototype.getMusicEnabled = function() { return this.musicEnabled }, t.prototype.getSfxEnabled = function() { return this.sfxEnabled }, t.prototype.isPlayingMusic = function() { return this.playingMusic }, t.prototype.mute = function() { this.gamePaused() }, t.prototype.unmute = function() { this.gameResumed() }, t.prototype.loopSoundExist = function(t) { return this.loopingSounds[t] }, t.prototype.gamePaused = function() { this.musicFile && this.musicFile.mute(!0), this.soundsFile && this.soundsFile.mute(!0) }, t.prototype.gameResumed = function() { this.musicFile && this.musicFile.mute(!1), this.soundsFile && this.soundsFile.mute(!1) }, t }();
    t.AudioManager = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function(e) {
        function i(t, i) { var o = e.call(this, t, i) || this; return o.addAudioManager(), o } return __extends(i, e), i.prototype.addAudioManager = function() { Phaser.Game.prototype.ph2AudioManager = new t.AudioManager(this.game) }, i }(Phaser.Plugin);
    t.AudioPlugin = e }(Ph2 || (Ph2 = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Ph2;
! function(t) { var e = function() {
        function e(e, i) { this.game = null, this.gameObject = null, this.priority = e || 0, this.__id = t.ComponentManager.generateId(), this.flags = 0, i && (this.flags |= t.Flags.isUnique) } return e.prototype.start = function() {}, e.prototype.update = function() {}, e.prototype.lateUpdate = function() {}, e.prototype.onEnable = function() {}, e.prototype.onDisable = function() {}, e.prototype.onDestroy = function() {}, e.prototype.enable = function() { 0 == (this.flags & t.Flags.isEnabledCalled) && (this.isEnabled || (this.flags |= t.Flags.isEnable, this.flags |= t.Flags.isEnabledCalled, this.componentManager.enableComponent(this), this.onEnable(), this.flags &= ~t.Flags.isEnabledCalled)) }, e.prototype.disable = function() { 0 == (this.flags & t.Flags.isDisabledCalled) && this.isEnabled && (this.flags &= ~t.Flags.isEnable, this.flags |= t.Flags.isDisabledCalled, this.componentManager.disableComponent(this), this.onDisable(), this.flags &= ~t.Flags.isDisabledCalled) }, Object.defineProperty(e.prototype, "isEnabled", { get: function() { return 0 != (this.flags & t.Flags.isEnable) }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "isUnique", { get: function() { return 0 != (this.flags & t.Flags.isUnique) }, enumerable: !0, configurable: !0 }), e.prototype.remove = function() { this.flags & t.Flags.isPendingRemove || (this.isEnabled && (this.flags &= ~t.Flags.isEnable, this.componentManager.disableComponent(this)), this.flags |= t.Flags.isPendingRemove, this.onDestroy && this.onDestroy(), this.componentManager.scheduleRemove(this)) }, e.prototype.getId = function() { return this.__id }, e }();
    t.Component = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function e(t, e) { this.game = t, this.componentList = [], this.gameObject = e } return e.prototype.addComponent = function(t) { for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i]; var o; switch (typeof t) {
                case "function":
                    o = new(Function.prototype.bind.apply(t, arguments)); break;
                case "object":
                    o = t; break;
                default:
                    return null } if (this.componentList.length > 0 && o.isUnique)
                for (var n = 0, s = this.componentList; n < s.length; n++)
                    if (o instanceof s[n].constructor) return null; return o.game = this.game, o.gameObject = this.gameObject, o.componentManager = this, this.componentList.push(o), o.enable(), o }, e.prototype.addManyComponents = function(t) { for (var e = 0, i = t; e < i.length; e++) { var o = i[e];
                this.addComponent(o) } }, e.prototype.removeComponent = function(t) { switch (typeof t) {
                case "function":
                    return this.__removeComponentByConstructor(t);
                case "object":
                    return t.remove(), !0;
                default:
                    return !1 } }, e.prototype.removeAllComponents = function() { for (var e = 0; e < this.componentList.length; e++) this.__removeComponentNoSchedule(this.componentList[e], e), this.componentList[e].flags & t.Flags.isPendingRemove && t.ComponentPlugin._scheduleComponentDestruction(this.componentList[e]);
            this.componentList.length = 0 }, e.prototype.__removeComponentNoSchedule = function(e, i) { e.flags & t.Flags.isPendingRemove || (e.isEnabled && (e.flags &= ~t.Flags.isEnable, this.disableComponent(e)), e.flags |= t.Flags.isPendingRemove, e.onDestroy()) }, e.prototype.removeAllComponentsOf = function(t) { for (var e = 0, i = 0; i < this.componentList.length; i++) this.componentList[i] instanceof t && (this.__removeComponentAt(this.componentList[i], i), i--, e++); return e }, e.prototype.removeManyComponents = function(t) { for (var e = 0, i = t; e < i.length; e++) { var o = i[e];
                this.removeComponent(o) } }, e.prototype.__removeComponentByConstructor = function(t) { for (var e = 0; e < this.componentList.length; e++)
                if (this.componentList[e] instanceof t) return this.__removeComponentAt(this.componentList[e], e), !0; return !1 }, e.prototype.__removeComponentAt = function(e, i) { e.flags & t.Flags.isPendingRemove || (e.isEnabled && (e.flags &= ~t.Flags.isEnable, this.disableComponent(e)), e.flags |= t.Flags.isPendingRemove, e.onDestroy && e.onDestroy(), t.InvokeList.fastRemoveAt(this.componentList, e, i), e.flags & t.Flags.isPendingRemove && t.ComponentPlugin._scheduleComponentDestruction(e)) }, e.generateId = function() { return t.ComponentPlugin.generateComponentId() }, e.prototype.getComponent = function(t) { return this.getComponentByConstructor(t) }, e.prototype.getAllComponentsOf = function(t) { for (var e = [], i = 0, o = this.componentList; i < o.length; i++) { var n = o[i];
                n instanceof t && e.push(n) } return e }, e.prototype.getComponentByConstructor = function(t) { for (var e = 0; e < this.componentList.length; e++)
                if (this.componentList[e] instanceof t) return this.componentList[e]; return null }, e.prototype.enableComponent = function(e) { t.ComponentPlugin.addComponentToSchedule(e) }, e.prototype.disableComponent = function(e) { t.ComponentPlugin.removeComponentFromSchedule(e) }, e.prototype.printComponentList = function() { for (var t = 0, e = this.componentList; t < e.length; t++) e[t] }, e.prototype.sendMessage = function(t) { for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i]; for (var o = 0, n = 0, s = this.componentList; n < s.length; n++) { var r = s[n];
                r[t] && (r[t].apply(r, e), o++) } return o }, e.prototype.destroy = function() { this.removeAllComponents(), t.ComponentPlugin._scheduleManagerDestruction(this) }, e.prototype.scheduleRemove = function(e) { t.InvokeList.fastRemove(this.componentList, e), e.flags & t.Flags.isPendingRemove && t.ComponentPlugin._scheduleComponentDestruction(e) }, e }();
    t.ComponentManager = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e = function() {
        function t(t, e) { void 0 === e && (e = !1), this.invokeFuntion = t, this.deleteAfterInvoke = e, this.zeroList = [], this.posList = [], this.negList = [] } return t.prototype.add = function(e) { var i = e,
                o = i.priority; if (0 === o) this.zeroList.push(e);
            else { var n = o < 0 ? this.negList : this.posList,
                    s = t.sortedIndex(n, i); if (!(s < 0)) return null;
                n.splice(~s, 0, e) } return e }, t.prototype.remove = function(e) { var i = e.priority; if (0 === i) t.fastRemove(this.zeroList, e);
            else { var o = i < 0 ? this.negList : this.posList,
                    n = t.sortedIndex(o, e);
                n >= 0 && t.removeAt(o, n) } }, t.prototype.invoke = function() { this.negList.length > 0 && (this.invokeFuntion(this.negList), this.deleteAfterInvoke && (this.negList.length = 0)), this.invokeFuntion(this.zeroList), this.deleteAfterInvoke && (this.zeroList.length = 0), this.posList.length > 0 && (this.invokeFuntion(this.posList), this.deleteAfterInvoke && (this.posList.length = 0)) }, t.sortedIndex = function(t, e) { for (var i = e.priority, o = e.getId(), n = 0, s = t.length - 1, r = s >>> 1; n <= s; r = n + s >>> 1) { var a = t[r],
                    h = a.priority; if (h > i) s = r - 1;
                else if (h < i) n = r + 1;
                else { var l = a.getId(); if (l > o) s = r - 1;
                    else { if (!(l < o)) return r;
                        n = r + 1 } } } return ~n }, t.fastRemove = function(t, e) { var i = t.indexOf(e); return i >= 0 && (t[i] = t[t.length - 1], --t.length, !0) }, t.fastRemoveAt = function(t, e, i) { return i >= 0 && (t[i] = t[t.length - 1], --t.length, !0) }, t.removeAt = function(t, e) { t.splice(e, 1) }, t.compareOrder = function(t, e) { return t.priority - e.priority }, t.prototype.printLists = function() { if (this.posList.length > 0)
                for (var t = 0, e = this.posList; t < e.length; t++) e[t];
            else 1; if (this.zeroList.length > 0)
                for (var i = 0, o = this.zeroList; i < o.length; i++) o[i];
            else 1; if (this.negList.length > 0)
                for (var n = 0, s = this.negList; n < s.length; n++) s[n];
            else 1 }, t.prototype.getTotalLength = function() { return this.posList.length + this.zeroList.length + this.negList.length }, t }();
    t.InvokeList = e }(Ph2 || (Ph2 = {}));
var Ph2;
! function(t) { var e;! function(t) { t[t.isEnable = 1] = "isEnable", t[t.isUnique = 2] = "isUnique", t[t.IsStartCalled = 4] = "IsStartCalled", t[t.isPendingRemove = 8] = "isPendingRemove", t[t.isEnabledCalled = 16] = "isEnabledCalled", t[t.isDisabledCalled = 32] = "isDisabledCalled" }(e = t.Flags || (t.Flags = {})); var i = function(i) {
        function o(e, n) { var s = i.call(this, e, n) || this; return o.game = e, o.toScheduleList = [], o.toDestroyComponentList = [], o.toDestroyManagersList = [], o.idCorrelative = 0, o.startInvoker = new t.InvokeList(o.startCaller, !0), o.updateInvoker = new t.InvokeList(o.updateCaller, !1), o.lateUpdateInvoker = new t.InvokeList(o.lateUpdateCaller, !1), o.componentManagerList = [], o.cleanOnStateChange = !0, o.game.state.onStateChange.add(o.stateChangeCleaning, o), o._updating = !1, o._paused = !1, s } return __extends(o, i), o.startCaller = function(t) { for (var i = 0, o = t; i < o.length; i++) { var n = o[i];
                n.start(), n.flags |= e.IsStartCalled } }, o.updateCaller = function(t) { for (var e = 0, i = t; e < i.length; e++) i[e].update() }, o.lateUpdateCaller = function(t) { for (var e = 0, i = t; e < i.length; e++) i[e].lateUpdate() }, o.prototype.preUpdate = function() { if (!o._paused) { if (o._pauseNextFrame) return o._paused = !0, void(o._pauseNextFrame = !1); if (o._updating = !0, o.toScheduleList.length > 0) { for (var t = 0; t < o.toScheduleList.length; t++) o.scheduleComponent(o.toScheduleList[t]);
                    o.toScheduleList.length = 0 } o.startInvoker.invoke() } }, o.scheduleComponent = function(t) { t.__proto__.hasOwnProperty("start") && 0 == (t.flags & e.IsStartCalled) && this.startInvoker.add(t), t.__proto__.hasOwnProperty("update") && this.updateInvoker.add(t), t.__proto__.hasOwnProperty("lateUpdate") && this.lateUpdateInvoker.add(t) }, o.prototype.update = function() { o._paused || o.updateInvoker.invoke() }, o.prototype.postUpdate = function() { o._paused || (o.lateUpdateInvoker.invoke(), o.__clean(), o._updating = !1) }, o.addComponentToSchedule = function(t) { return this._updating ? this.toScheduleList.push(t) : this.scheduleComponent(t), t }, o.removeComponentFromSchedule = function(e) { t.InvokeList.fastRemove(this.toScheduleList, e) || (this.startInvoker.remove(e), this.updateInvoker.remove(e), this.lateUpdateInvoker.remove(e)) }, o.__clean = function() { if (this.toDestroyComponentList.length > 0) { for (var t = 0, e = this.toDestroyComponentList; t < e.length; t++) { var i = e[t];
                    this.nullifyObject(i) } this.toDestroyComponentList.length = 0 } if (this.toDestroyManagersList.length > 0) { for (var o = 0, n = this.toDestroyManagersList; o < n.length; o++) { var s = n[o];
                    this.nullifyObject(s) } this.toDestroyManagersList.length = 0 } }, o.generateComponentId = function() { return this.idCorrelative++ }, o.initComponents = function(e) { var i = new t.ComponentManager(this.game, e); return this.componentManagerList.push(i), i }, o.printAllComponets = function() { for (var t = 0, e = this.componentManagerList; t < e.length; t++) e[t].printComponentList() }, o.printAllComponetsInInvokers = function() { this.startInvoker.printLists(), this.updateInvoker.printLists(), this.lateUpdateInvoker.printLists() }, o.nullifyObject = function(t) { for (var e = 0, i = Object.keys(t); e < i.length; e++) { var o = i[e]; switch (typeof t[o]) {
                    case "object":
                        t[o] = null; break;
                    default:
                        t[o] = void 0 } } }, o.destroyAllManagers = function() { for (var t = 0, e = this.componentManagerList; t < e.length; t++) { var i = e[t];
                i.removeAllComponents(), this._updating ? this.toDestroyManagersList.push(i) : this.nullifyObject(i) } this.componentManagerList.length = 0 }, o.stateChangeCleaning = function() { this.cleanOnStateChange && this.destroyAllManagers() }, o._scheduleComponentDestruction = function(t) { this._updating ? this.toDestroyComponentList.push(t) : this.nullifyObject(t) }, o._scheduleManagerDestruction = function(e) { t.InvokeList.fastRemove(this.componentManagerList, e), this._updating ? this.toDestroyManagersList.push(e) : this.nullifyObject(e) }, o.pause = function() { o._updating ? o._pauseNextFrame = !0 : o._paused = !0 }, o.resume = function() { o._paused = !1, o._pauseNextFrame = !1 }, o }(Phaser.Plugin);
    t.ComponentPlugin = i }(Ph2 || (Ph2 = {}));
var __extends = this && this.__extends || function(t, e) {
        function i() { this.constructor = t } for (var o in e) e.hasOwnProperty(o) && (t[o] = e[o]);
        t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i) },
    PhaserCachebuster;
! function(t) { var e = function(t) {
        function e(e, i) { var o = t.call(this, e, i) || this; return o.patchLoader(), o } return __extends(e, t), e.prototype.patchLoader = function() { Object.defineProperty(Phaser.Loader, "cacheBuster", { value: null }), Phaser.Loader.prototype.transformUrl = function(t, e) { return t ? (null !== this.cacheBuster && null === t.match(/^(data:)/) && (t += "?v=" + this.cacheBuster), t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t) : "" } }, e }(Phaser.Plugin);
    t.CacheBuster = e }(PhaserCachebuster || (PhaserCachebuster = {}));
var PhaserSuperStorage;
! function(t) {! function(t) { var e = function() {
            function t(t) { void 0 === t && (t = ""), this.namespace = "", this.forcePromises = !1, this.setNamespace(t) } return Object.defineProperty(t.prototype, "length", { get: function() { return null !== this.getNameSpaceMatches() ? this.getNameSpaceMatches().length : 0 }, enumerable: !0, configurable: !0 }), t.prototype.key = function(t) { var e = this.getNameSpaceMatches()[t],
                    i = this.getCookiesForNameSpace()[e] || null; return this.forcePromises ? this.promisefy(i) : i }, t.prototype.getItem = function(t) { var e = this.getCookiesForNameSpace()[t] || null; return this.forcePromises ? this.promisefy(e) : e }, t.prototype.setItem = function(t, e) { if (document.cookie = encodeURIComponent(this.namespace + t) + "=" + encodeURIComponent(e) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/", this.forcePromises) return this.promisefy(null) }, t.prototype.removeItem = function(t) { if (document.cookie = encodeURIComponent(this.namespace + t) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/", this.forcePromises) return this.promisefy(null) }, t.prototype.clear = function() { var t = this.getCookiesForNameSpace(); for (var e in t) t.hasOwnProperty(e) && this.removeItem(e); if (this.forcePromises) return this.promisefy(null) }, t.prototype.setNamespace = function(t) { if (t && (this.namespace = t + ":", this.reg = new RegExp("^" + this.namespace + "[a-zA-Z0-9]*", "g")), this.forcePromises) return this.promisefy(t) }, t.prototype.getNameSpaceMatches = function() { var t = this; return decodeURIComponent(document.cookie).split("; ").filter(function(e) { return null !== e.match(t.reg) && e.match(t.reg).length > 0 }) }, t.prototype.getCookiesForNameSpace = function() { var t = this,
                    e = {}; return this.getNameSpaceMatches().forEach(function(i) { var o = i.replace(t.namespace, "").split("=");
                    e[o[0]] = o[1] }), e }, t.prototype.promisefy = function(t) { return new Promise(function(e, i) { e(t) }) }, t }();
        t.CookieStorage = e }(t.StorageAdapters || (t.StorageAdapters = {})) }(PhaserSuperStorage || (PhaserSuperStorage = {}));
var PhaserSuperStorage;
! function(t) {! function(t) { var e = function() {
            function t() { this.namespace = "", this.keys = [] } return Object.defineProperty(t.prototype, "forcePromises", { get: function() { return !0 }, set: function(t) {}, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, "length", { get: function() { return this.keys.length }, enumerable: !0, configurable: !0 }), t.prototype.key = function(t) { return this.promisefy(this.keys[t]) }, t.prototype.getItem = function(t) { var e = this; return new Promise(function(i, o) { NativeStorage.getItem(e.namespace + t, function(t) { i(t) }, function(t) { 2 === t.code ? i(null) : o(t) }) }) }, t.prototype.setItem = function(t, e) { var i = this; if (!(t.length < 1)) return new Promise(function(o, n) { NativeStorage.setItem(i.namespace + t, e, function() { i.keys.indexOf(t) < 0 && (i.keys.push(t), i.save()), o(null) }, function(t) { n(t) }) }) }, t.prototype.removeItem = function(t) { var e = this; return new Promise(function(i, o) { NativeStorage.remove(e.namespace + t, function() { var o = e.keys.indexOf(t);
                        o >= 0 && (e.keys.splice(o, 1), e.save()), i(null) }, function(t) { o(t) }) }) }, t.prototype.clear = function() { var t = this; return new Promise(function(e, i) { for (var o = 0, n = 0; n < t.keys.length; n++) NativeStorage.remove(t.namespace + t.keys[n], function() {++o >= t.keys.length && (t.keys = [], t.save(), e(null)) }, function(t) { i(t) }) }) }, t.prototype.setNamespace = function(t) { var e = this; return void 0 === t && (t = ""), this.namespace = t + ":", this.keys = [], new Promise(function(t, i) { e.load().then(t).catch(t) }) }, t.prototype.promisefy = function(t) { return new Promise(function(e, i) { e(t) }) }, t.prototype.load = function() { var t = this; return new Promise(function(e, i) { NativeStorage.getItem(t.namespace, function(i) { t.keys = JSON.parse(i), e(null) }, function(t) { i(t) }) }) }, t.prototype.save = function() { NativeStorage.setItem(this.namespace, JSON.stringify(this.keys), function() {}, function(t) {}) }, t }();
        t.CordovaStorage = e }(t.StorageAdapters || (t.StorageAdapters = {})) }(PhaserSuperStorage || (PhaserSuperStorage = {}));
var PhaserSuperStorage;
! function(t) {! function(e) { var i = function() {
            function e(t, e) { void 0 === t && (t = ""), void 0 === e && (e = "*"), this.namespace = "", this.expectedOrigin = "", this.storageLength = 0, this.enabled = !1, "" !== t && this.setNamespace(t), this.expectedOrigin = e } return Object.defineProperty(e.prototype, "forcePromises", { get: function() { return !0 }, set: function(t) {}, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "length", { get: function() { return this.storageLength }, enumerable: !0, configurable: !0 }), e.prototype.init = function() { var e = this; return this.sendMessage({ command: t.StorageCommand.init }).then(function() { e.enabled = !0 }) }, e.prototype.key = function(e) { return this.sendMessage({ command: t.StorageCommand.key, value: e }) }, e.prototype.getItem = function(e) { return this.sendMessage({ command: t.StorageCommand.getItem, key: e }) }, e.prototype.setItem = function(e, i) { return this.sendMessage({ command: t.StorageCommand.setItem, key: e, value: i }) }, e.prototype.removeItem = function(e) { return this.sendMessage({ command: t.StorageCommand.removeItem, key: e }) }, e.prototype.clear = function() { return this.sendMessage({ command: t.StorageCommand.clear }) }, e.prototype.setNamespace = function(e) { return this.sendMessage({ command: t.StorageCommand.setNamespace, value: e }) }, e.prototype.sendMessage = function(e) { var i, o = this;
                e.command === t.StorageCommand.init && (i = !1); var n = new MessageChannel; return new Promise(function(s, r) { o.enabled || e.command === t.StorageCommand.init || r("Messaging not enabled!"), e.command === t.StorageCommand.init && setTimeout(function() { i || r("Unable to get a response in time") }, 1e3), n.port1.onmessage = function(e) { var n = t.StorageUtils.validateMessage(e.data); switch (n.command === t.StorageCommand.init && (i = !0), void 0 !== n.status && "ok" === n.status || r(n.value), void 0 !== n.length && (o.storageLength = n.length), n.command) {
                            case t.StorageCommand.setNamespace:
                                o.namespace = n.value + ":";
                            case t.StorageCommand.getItem:
                            case t.StorageCommand.length:
                            case t.StorageCommand.key:
                                s(n.value); break;
                            case t.StorageCommand.setItem:
                            case t.StorageCommand.removeItem:
                            case t.StorageCommand.clear:
                            case t.StorageCommand.init:
                                s(n.status); break;
                            default:
                                r(n.value) } }, (o.enabled || e.command === t.StorageCommand.init) && window.parent.postMessage(e, o.expectedOrigin, [n.port2]) }) }, e }();
        e.IframeStorage = i }(t.StorageAdapters || (t.StorageAdapters = {})) }(PhaserSuperStorage || (PhaserSuperStorage = {}));
var PhaserSuperStorage;
! function(t) {! function(e) { var i = function() {
            function e(t) { void 0 === t && (t = ""), this.namespace = "", this.forcePromises = !1, this.setNamespace(t) } return Object.defineProperty(e.prototype, "length", { get: function() { var e = Object.keys(localStorage); return t.StorageUtils.nameSpaceKeyFilter(e, this.namespace).length }, enumerable: !0, configurable: !0 }), e.prototype.key = function(t) { return this.forcePromises ? this.promisefy(this._key, arguments) : this._key(t) }, e.prototype._key = function(e) { var i = Object.keys(localStorage),
                    o = t.StorageUtils.nameSpaceKeyFilter(i, this.namespace); return localStorage.getItem(o[e]) }, e.prototype.getItem = function(t) { return this.forcePromises ? this.promisefy(this._getItem, arguments) : this._getItem(t) }, e.prototype._getItem = function(t) { return localStorage.getItem(this.namespace + t) }, e.prototype.setItem = function(t, e) { return this.forcePromises ? this.promisefy(this._setItem, arguments) : this._setItem(t, e) }, e.prototype._setItem = function(t, e) { return localStorage.setItem(this.namespace + t, e) }, e.prototype.removeItem = function(t) { return this.forcePromises ? this.promisefy(this._removeItem, arguments) : this._removeItem(t) }, e.prototype._removeItem = function(t) { return localStorage.removeItem(this.namespace + t) }, e.prototype.clear = function() { return this.forcePromises ? this.promisefy(this._clear, arguments) : this._clear() }, e.prototype._clear = function() { for (var e = Object.keys(localStorage), i = t.StorageUtils.nameSpaceKeyFilter(e, this.namespace), o = 0; o < i.length; o++) localStorage.removeItem(i[o]) }, e.prototype.setNamespace = function(t) { return this.forcePromises ? this.promisefy(this._setNameSpace, arguments) : this._setNameSpace(t) }, e.prototype._setNameSpace = function(t) { t && (this.namespace = t + ":") }, e.prototype.promisefy = function(t, e) { var i = this; return new Promise(function(o, n) { o(t.apply(i, e)) }) }, e }();
        e.LocalStorage = i }(t.StorageAdapters || (t.StorageAdapters = {})) }(PhaserSuperStorage || (PhaserSuperStorage = {}));
var PhaserSuperStorage;
! function(t) { var e = function() {
        function e(i) { if (void 0 !== i) Object.defineProperty(i, "storage", { value: this });
            else { if (null !== e.instance) return e.instance;
                e.instance = this } t.StorageUtils.isLocalStorageSupport() ? this.setAdapter(new t.StorageAdapters.LocalStorage) : this.setAdapter(new t.StorageAdapters.CookieStorage) } return e.prototype.setAdapter = function(t) { this.storage = t }, Object.defineProperty(e.prototype, "forcePromises", { get: function() { return this.storage.forcePromises }, set: function(t) { this.storage.forcePromises = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(e.prototype, "length", { get: function() { return null === this.storage ? 0 : this.storage.length }, enumerable: !0, configurable: !0 }), e.prototype.setNamespace = function(t) { if (null !== this.storage) return this.storage.setNamespace(t) }, e.prototype.key = function(t) { return null === this.storage ? "" : this.storage.key(t) }, e.prototype.getItem = function(t) { return null === this.storage ? null : this.storage.getItem(t) }, e.prototype.setItem = function(t, e) { if (null !== this.storage) return this.storage.setItem(t, e) }, e.prototype.removeItem = function(t) { if (null !== this.storage) return this.storage.removeItem(t) }, e.prototype.clear = function() { if (null !== this.storage) return this.storage.clear() }, e }();
    e.instance = null, t.StoragePlugin = e }(PhaserSuperStorage || (PhaserSuperStorage = {})), void 0 !== window.Phaser && Phaser.Utils.mixinPrototype(PhaserSuperStorage.StoragePlugin, Phaser.Plugin);
var PhaserSuperStorage;
! function(t) {! function(t) { t[t.init = 0] = "init", t[t.setItem = 1] = "setItem", t[t.getItem = 2] = "getItem", t[t.removeItem = 3] = "removeItem", t[t.clear = 4] = "clear", t[t.setNamespace = 5] = "setNamespace", t[t.length = 6] = "length", t[t.key = 7] = "key", t[t.error = 8] = "error" }(t.StorageCommand || (t.StorageCommand = {})); var e = function() {
        function t() {} return t.isLocalStorageSupport = function() { try { if ("object" == typeof localStorage) return localStorage.setItem("testingLocalStorage", "foo"), localStorage.removeItem("testingLocalStorage"), !0 } catch (t) { return !1 } return !1 }, t.validateMessage = function(t) { return t.hasOwnProperty("command") ? t : null }, t.nameSpaceKeyFilter = function(t, e) { return t.filter(function(t) { return t.substring(0, e.length) === e }) }, t }();
    t.StorageUtils = e }(PhaserSuperStorage || (PhaserSuperStorage = {}));
var PhaserSuperStorage;
! function(t) {! function(t) { t[t.init = 0] = "init", t[t.setItem = 1] = "setItem", t[t.getItem = 2] = "getItem", t[t.removeItem = 3] = "removeItem", t[t.clear = 4] = "clear", t[t.setNamespace = 5] = "setNamespace", t[t.length = 6] = "length", t[t.key = 7] = "key", t[t.error = 8] = "error" }(t.StorageCommand || (t.StorageCommand = {})); var e = function() {
        function t() {} return t.isLocalStorageSupport = function() { try { if ("object" == typeof localStorage) return localStorage.setItem("testingLocalStorage", "foo"), localStorage.removeItem("testingLocalStorage"), !0 } catch (t) { return !1 } return !1 }, t.validateMessage = function(t) { return t.hasOwnProperty("command") ? t : null }, t.nameSpaceKeyFilter = function(t, e) { return t.filter(function(t) { return t.substring(0, e.length) === e }) }, t }();
    t.StorageUtils = e }(PhaserSuperStorage || (PhaserSuperStorage = {}));
var PhaserSuperStorage;
! function(t) {! function(e) { var i = function() {
            function e(t) { void 0 === t && (t = ""), this.namespace = "", this.forcePromises = !1, this.setNamespace(t) } return Object.defineProperty(e.prototype, "length", { get: function() { var e = Object.keys(localStorage); return t.StorageUtils.nameSpaceKeyFilter(e, this.namespace).length }, enumerable: !0, configurable: !0 }), e.prototype.key = function(t) { return this.forcePromises ? this.promisefy(this._key, arguments) : this._key(t) }, e.prototype._key = function(e) { var i = Object.keys(localStorage),
                    o = t.StorageUtils.nameSpaceKeyFilter(i, this.namespace); return localStorage.getItem(o[e]) }, e.prototype.getItem = function(t) { return this.forcePromises ? this.promisefy(this._getItem, arguments) : this._getItem(t) }, e.prototype._getItem = function(t) { return localStorage.getItem(this.namespace + t) }, e.prototype.setItem = function(t, e) { return this.forcePromises ? this.promisefy(this._setItem, arguments) : this._setItem(t, e) }, e.prototype._setItem = function(t, e) { return localStorage.setItem(this.namespace + t, e) }, e.prototype.removeItem = function(t) { return this.forcePromises ? this.promisefy(this._removeItem, arguments) : this._removeItem(t) }, e.prototype._removeItem = function(t) { return localStorage.removeItem(this.namespace + t) }, e.prototype.clear = function() { return this.forcePromises ? this.promisefy(this._clear, arguments) : this._clear() }, e.prototype._clear = function() { for (var e = Object.keys(localStorage), i = t.StorageUtils.nameSpaceKeyFilter(e, this.namespace), o = 0; o < i.length; o++) localStorage.removeItem(i[o]) }, e.prototype.setNamespace = function(t) { return this.forcePromises ? this.promisefy(this._setNameSpace, arguments) : this._setNameSpace(t) }, e.prototype._setNameSpace = function(t) { t && (this.namespace = t + ":") }, e.prototype.promisefy = function(t, e) { var i = this; return new Promise(function(o, n) { o(t.apply(i, e)) }) }, e }();
        e.LocalStorage = i }(t.StorageAdapters || (t.StorageAdapters = {})) }(PhaserSuperStorage || (PhaserSuperStorage = {}));
var StorageCommand = PhaserSuperStorage.StorageCommand,
    StorageUtils = PhaserSuperStorage.StorageUtils,
    LocalStorage = PhaserSuperStorage.StorageAdapters.LocalStorage;
! function() { var t = window.gameOrigin || "*",
        e = StorageUtils.isLocalStorageSupport(),
        i = e ? new LocalStorage : null;
    window.addEventListener("message", function(o) { if ("*" === t || o.origin === t) { var n = StorageUtils.validateMessage(o.data),
                s = o.ports[0]; if (void 0 !== s && s) { var r = function(t, e) { s.postMessage({ status: "error", command: t, value: e }) }; if (null !== n) switch (e || r(n.command, "localStorage not supported"), n.command) {
                    case StorageCommand.init:
                        s.postMessage({ status: "ok", command: n.command, length: i.length }); break;
                    case StorageCommand.getItem:
                        try { var a = i.getItem(n.key);
                            s.postMessage({ status: "ok", command: n.command, value: a, length: i.length }) } catch (t) { r(n.command, t.message) } break;
                    case StorageCommand.setItem:
                        try { i.setItem(n.key, n.value), s.postMessage({ status: "ok", command: n.command, length: i.length }) } catch (t) { r(n.command, t.message) } break;
                    case StorageCommand.removeItem:
                        try { i.removeItem(n.key), s.postMessage({ status: "ok", command: n.command, length: i.length }) } catch (t) { r(n.command, t.message) } break;
                    case StorageCommand.setNamespace:
                        try { i.setNamespace(n.value), s.postMessage({ status: "ok", command: n.command, value: n.value, length: i.length }) } catch (t) { r(n.command, t.message) } break;
                    case StorageCommand.clear:
                        try { i.clear(), s.postMessage({ status: "ok", command: n.command, length: i.length }) } catch (t) { r(n.command, t.message) } break;
                    case StorageCommand.length:
                        try { s.postMessage({ status: "ok", command: n.command, value: i.length, length: i.length }) } catch (t) { r(n.command, t.message) } break;
                    case StorageCommand.key:
                        try { var h = i.key(n.value);
                            s.postMessage({ status: "ok", command: n.command, value: h, length: i.length }) } catch (t) { r(n.command, t.message) } break;
                    default:
                        r(n.command, "Command not found") } else r(StorageCommand.error, "Empty message!") } } }) }();
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() { "use strict";
        _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) { var o = function(t) { var e, i = [],
                            o = t.length; for (e = 0; e !== o; i.push(t[e++])); return i },
                    n = function(t, e, i) { var o, n, s = t.cycle; for (o in s) n = s[o], t[o] = "function" == typeof n ? n(i, e[i]) : n[i % n.length];
                        delete t.cycle },
                    s = function(t, e, o) { i.call(this, t, e, o), this._cycle = 0, this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = s.prototype.render },
                    r = i._internals,
                    a = r.isSelector,
                    h = r.isArray,
                    l = s.prototype = i.to({}, .1, {}),
                    c = [];
                s.version = "1.20.5", l.constructor = s, l.kill()._gc = !1, s.killTweensOf = s.killDelayedCallsTo = i.killTweensOf, s.getTweensOf = i.getTweensOf, s.lagSmoothing = i.lagSmoothing, s.ticker = i.ticker, s.render = i.render, l.invalidate = function() { return this._yoyo = !0 === this.vars.yoyo || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), i.prototype.invalidate.call(this) }, l.updateTo = function(t, e) { var o, n = this.ratio,
                        s = this.vars.immediateRender || t.immediateRender;
                    e && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay)); for (o in t) this.vars[o] = t[o]; if (this._initted || s)
                        if (e) this._initted = !1, s && this.render(0, !0, !0);
                        else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) { var r = this._totalTime;
                        this.render(0, !0, !1), this._initted = !1, this.render(r, !0, !1) } else if (this._initted = !1, this._init(), this._time > 0 || s)
                        for (var a, h = 1 / (1 - n), l = this._firstPT; l;) a = l.s + l.c, l.c *= h, l.s = a - l.c, l = l._next; return this }, l.render = function(t, e, o) { this._initted || 0 === this._duration && this.vars.repeat && this.invalidate(); var n, s, a, h, l, c, d, u, p, m = this._dirty ? this.totalDuration() : this._totalDuration,
                        f = this._time,
                        y = this._totalTime,
                        b = this._cycle,
                        g = this._duration,
                        _ = this._rawPrevTime; if (t >= m - 1e-7 && t >= 0 ? (this._totalTime = m, this._cycle = this._repeat, this._yoyo && 0 != (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = g, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (n = !0, s = "onComplete", o = o || this._timeline.autoRemoveChildren), 0 === g && (this._initted || !this.vars.lazy || o) && (this._startTime === this._timeline._duration && (t = 0), (_ < 0 || t <= 0 && t >= -1e-7 || 1e-10 === _ && "isPause" !== this.data) && _ !== t && (o = !0, _ > 1e-10 && (s = "onReverseComplete")), this._rawPrevTime = u = !e || t || _ === t ? t : 1e-10)) : t < 1e-7 ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== y || 0 === g && _ > 0) && (s = "onReverseComplete", n = this._reversed), t < 0 && (this._active = !1, 0 === g && (this._initted || !this.vars.lazy || o) && (_ >= 0 && (o = !0), this._rawPrevTime = u = !e || t || _ === t ? t : 1e-10)), this._initted || (o = !0)) : (this._totalTime = this._time = t, 0 !== this._repeat && (h = g + this._repeatDelay, this._cycle = this._totalTime / h >> 0, 0 !== this._cycle && this._cycle === this._totalTime / h && y <= t && this._cycle--, this._time = this._totalTime - this._cycle * h, this._yoyo && 0 != (1 & this._cycle) && (this._time = g - this._time, (p = this._yoyoEase || this.vars.yoyoEase) && (this._yoyoEase || (!0 !== p || this._initted ? this._yoyoEase = p = !0 === p ? this._ease : p instanceof Ease ? p : Ease.map[p] : (p = this.vars.ease, this._yoyoEase = p = p ? p instanceof Ease ? p : "function" == typeof p ? new Ease(p, this.vars.easeParams) : Ease.map[p] || i.defaultEase : i.defaultEase)), this.ratio = p ? 1 - p.getRatio((g - this._time) / g) : 0)), this._time > g ? this._time = g : this._time < 0 && (this._time = 0)), this._easeType && !p ? (l = this._time / g, c = this._easeType, d = this._easePower, (1 === c || 3 === c && l >= .5) && (l = 1 - l), 3 === c && (l *= 2), 1 === d ? l *= l : 2 === d ? l *= l * l : 3 === d ? l *= l * l * l : 4 === d && (l *= l * l * l * l), 1 === c ? this.ratio = 1 - l : 2 === c ? this.ratio = l : this._time / g < .5 ? this.ratio = l / 2 : this.ratio = 1 - l / 2) : p || (this.ratio = this._ease.getRatio(this._time / g))), f !== this._time || o || b !== this._cycle) { if (!this._initted) { if (this._init(), !this._initted || this._gc) return; if (!o && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = f, this._totalTime = y, this._rawPrevTime = _, this._cycle = b, r.lazyTweens.push(this), void(this._lazy = [t, e]);!this._time || n || p ? n && this._ease._calcEnd && !p && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) : this.ratio = this._ease.getRatio(this._time / g) } for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== f && t >= 0 && (this._active = !0), 0 === y && (2 === this._initted && t > 0 && this._init(), this._startAt && (t >= 0 ? this._startAt.render(t, !0, o) : s || (s = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== g || e || this._callback("onStart"))), a = this._firstPT; a;) a.f ? a.t[a.p](a.c * this.ratio + a.s) : a.t[a.p] = a.c * this.ratio + a.s, a = a._next;
                        this._onUpdate && (t < 0 && this._startAt && this._startTime && this._startAt.render(t, !0, o), e || (this._totalTime !== y || s) && this._callback("onUpdate")), this._cycle !== b && (e || this._gc || this.vars.onRepeat && this._callback("onRepeat")), s && (this._gc && !o || (t < 0 && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(t, !0, o), n && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[s] && this._callback(s), 0 === g && 1e-10 === this._rawPrevTime && 1e-10 !== u && (this._rawPrevTime = 0))) } else y !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")) }, s.to = function(t, e, i) { return new s(t, e, i) }, s.from = function(t, e, i) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new s(t, e, i) }, s.fromTo = function(t, e, i, o) { return o.startAt = i, o.immediateRender = 0 != o.immediateRender && 0 != i.immediateRender, new s(t, e, o) }, s.staggerTo = s.allTo = function(t, e, r, l, d, u, p) { l = l || 0; var m, f, y, b, g = 0,
                        _ = [],
                        v = r.cycle,
                        x = r.startAt && r.startAt.cycle; for (h(t) || ("string" == typeof t && (t = i.selector(t) || t), a(t) && (t = o(t))), t = t || [], l < 0 && ((t = o(t)).reverse(), l *= -1), m = t.length - 1, y = 0; y <= m; y++) { f = {}; for (b in r) f[b] = r[b]; if (v && (n(f, t, y), null != f.duration && (e = f.duration, delete f.duration)), x) { x = f.startAt = {}; for (b in r.startAt) x[b] = r.startAt[b];
                            n(f.startAt, t, y) } f.delay = g + (f.delay || 0), y === m && d && (f.onComplete = function() { r.onComplete && r.onComplete.apply(r.onCompleteScope || this, arguments), d.apply(p || r.callbackScope || this, u || c) }), _[y] = new s(t[y], e, f), g += l } return _ }, s.staggerFrom = s.allFrom = function(t, e, i, o, n, r, a) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, s.staggerTo(t, e, i, o, n, r, a) }, s.staggerFromTo = s.allFromTo = function(t, e, i, o, n, r, a, h) { return o.startAt = i, o.immediateRender = 0 != o.immediateRender && 0 != i.immediateRender, s.staggerTo(t, e, o, n, r, a, h) }, s.delayedCall = function(t, e, i, o, n) { return new s(e, 0, { delay: t, onComplete: e, onCompleteParams: i, callbackScope: o, onReverseComplete: e, onReverseCompleteParams: i, immediateRender: !1, useFrames: n, overwrite: 0 }) }, s.set = function(t, e) { return new s(t, 0, e) }, s.isTweening = function(t) { return i.getTweensOf(t, !0).length > 0 }; var d = function(t, e) { for (var o = [], n = 0, s = t._first; s;) s instanceof i ? o[n++] = s : (e && (o[n++] = s), n = (o = o.concat(d(s, e))).length), s = s._next; return o },
                    u = s.getAllTweens = function(e) { return d(t._rootTimeline, e).concat(d(t._rootFramesTimeline, e)) };
                s.killAll = function(t, i, o, n) { null == i && (i = !0), null == o && (o = !0); var s, r, a, h = u(0 != n),
                        l = h.length,
                        c = i && o && n; for (a = 0; a < l; a++) r = h[a], (c || r instanceof e || (s = r.target === r.vars.onComplete) && o || i && !s) && (t ? r.totalTime(r._reversed ? 0 : r.totalDuration()) : r._enabled(!1, !1)) }, s.killChildTweensOf = function(t, e) { if (null != t) { var n, l, c, d, u, p = r.tweenLookup; if ("string" == typeof t && (t = i.selector(t) || t), a(t) && (t = o(t)), h(t))
                            for (d = t.length; --d > -1;) s.killChildTweensOf(t[d], e);
                        else { n = []; for (c in p)
                                for (l = p[c].target.parentNode; l;) l === t && (n = n.concat(p[c].tweens)), l = l.parentNode; for (u = n.length, d = 0; d < u; d++) e && n[d].totalTime(n[d].totalDuration()), n[d]._enabled(!1, !1) } } }; var p = function(t, i, o, n) { i = !1 !== i, o = !1 !== o; for (var s, r, a = u(n = !1 !== n), h = i && o && n, l = a.length; --l > -1;) r = a[l], (h || r instanceof e || (s = r.target === r.vars.onComplete) && o || i && !s) && r.paused(t) }; return s.pauseAll = function(t, e, i) { p(!0, t, e, i) }, s.resumeAll = function(t, e, i) { p(!1, t, e, i) }, s.globalTimeScale = function(e) { var o = t._rootTimeline,
                        n = i.ticker.time; return arguments.length ? (e = e || 1e-10, o._startTime = n - (n - o._startTime) * o._timeScale / e, o = t._rootFramesTimeline, n = i.ticker.frame, o._startTime = n - (n - o._startTime) * o._timeScale / e, o._timeScale = t._rootTimeline._timeScale = e, e) : o._timeScale }, l.progress = function(t, e) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() }, l.totalProgress = function(t, e) { return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() }, l.time = function(t, e) { return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time }, l.duration = function(e) { return arguments.length ? t.prototype.duration.call(this, e) : this._duration }, l.totalDuration = function(t) { return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration) }, l.repeat = function(t) { return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat }, l.repeatDelay = function(t) { return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay }, l.yoyo = function(t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, s }, !0), _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(t, e, i) { var o = function(t) { e.call(this, t), this._labels = {}, this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren, this.smoothChildTiming = !0 === this.vars.smoothChildTiming, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate; var i, o, n = this.vars; for (o in n) i = n[o], a(i) && -1 !== i.join("").indexOf("{self}") && (n[o] = this._swapSelfInParams(i));
                        a(n.tweens) && this.add(n.tweens, 0, n.align, n.stagger) },
                    n = i._internals,
                    s = o._internals = {},
                    r = n.isSelector,
                    a = n.isArray,
                    h = n.lazyTweens,
                    l = n.lazyRender,
                    c = _gsScope._gsDefine.globals,
                    d = function(t) { var e, i = {}; for (e in t) i[e] = t[e]; return i },
                    u = function(t, e, i) { var o, n, s = t.cycle; for (o in s) n = s[o], t[o] = "function" == typeof n ? n(i, e[i]) : n[i % n.length];
                        delete t.cycle },
                    p = s.pauseCallback = function() {},
                    m = function(t) { var e, i = [],
                            o = t.length; for (e = 0; e !== o; i.push(t[e++])); return i },
                    f = o.prototype = new e; return o.version = "1.20.4", f.constructor = o, f.kill()._gc = f._forcingPlayhead = f._hasPause = !1, f.to = function(t, e, o, n) { var s = o.repeat && c.TweenMax || i; return e ? this.add(new s(t, e, o), n) : this.set(t, o, n) }, f.from = function(t, e, o, n) { return this.add((o.repeat && c.TweenMax || i).from(t, e, o), n) }, f.fromTo = function(t, e, o, n, s) { var r = n.repeat && c.TweenMax || i; return e ? this.add(r.fromTo(t, e, o, n), s) : this.set(t, n, s) }, f.staggerTo = function(t, e, n, s, a, h, l, c) { var p, f, y = new o({ onComplete: h, onCompleteParams: l, callbackScope: c, smoothChildTiming: this.smoothChildTiming }),
                        b = n.cycle; for ("string" == typeof t && (t = i.selector(t) || t), r(t = t || []) && (t = m(t)), (s = s || 0) < 0 && ((t = m(t)).reverse(), s *= -1), f = 0; f < t.length; f++)(p = d(n)).startAt && (p.startAt = d(p.startAt), p.startAt.cycle && u(p.startAt, t, f)), b && (u(p, t, f), null != p.duration && (e = p.duration, delete p.duration)), y.to(t[f], e, p, f * s); return this.add(y, a) }, f.staggerFrom = function(t, e, i, o, n, s, r, a) { return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(t, e, i, o, n, s, r, a) }, f.staggerFromTo = function(t, e, i, o, n, s, r, a, h) { return o.startAt = i, o.immediateRender = 0 != o.immediateRender && 0 != i.immediateRender, this.staggerTo(t, e, o, n, s, r, a, h) }, f.call = function(t, e, o, n) { return this.add(i.delayedCall(0, t, e, o), n) }, f.set = function(t, e, o) { return o = this._parseTimeOrLabel(o, 0, !0), null == e.immediateRender && (e.immediateRender = o === this._time && !this._paused), this.add(new i(t, 0, e), o) }, o.exportRoot = function(t, e) { null == (t = t || {}).smoothChildTiming && (t.smoothChildTiming = !0); var n, s, r, a, h = new o(t),
                        l = h._timeline; for (null == e && (e = !0), l._remove(h, !0), h._startTime = 0, h._rawPrevTime = h._time = h._totalTime = l._time, r = l._first; r;) a = r._next, e && r instanceof i && r.target === r.vars.onComplete || ((s = r._startTime - r._delay) < 0 && (n = 1), h.add(r, s)), r = a; return l.add(h, 0), n && h.totalDuration(), h }, f.add = function(n, s, r, h) { var l, c, d, u, p, m; if ("number" != typeof s && (s = this._parseTimeOrLabel(s, 0, !0, n)), !(n instanceof t)) { if (n instanceof Array || n && n.push && a(n)) { for (r = r || "normal", h = h || 0, l = s, c = n.length, d = 0; d < c; d++) a(u = n[d]) && (u = new o({ tweens: u })), this.add(u, l), "string" != typeof u && "function" != typeof u && ("sequence" === r ? l = u._startTime + u.totalDuration() / u._timeScale : "start" === r && (u._startTime -= u.delay())), l += h; return this._uncache(!0) } if ("string" == typeof n) return this.addLabel(n, s); if ("function" != typeof n) throw "Cannot add " + n + " into the timeline; it is not a tween, timeline, function, or string.";
                        n = i.delayedCall(0, n) } if (e.prototype.add.call(this, n, s), n._time && n.render((this.rawTime() - n._startTime) * n._timeScale, !1, !1), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                        for (m = (p = this).rawTime() > n._startTime; p._timeline;) m && p._timeline.smoothChildTiming ? p.totalTime(p._totalTime, !0) : p._gc && p._enabled(!0, !1), p = p._timeline; return this }, f.remove = function(e) { if (e instanceof t) { this._remove(e, !1); var i = e._timeline = e.vars.useFrames ? t._rootFramesTimeline : t._rootTimeline; return e._startTime = (e._paused ? e._pauseTime : i._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this } if (e instanceof Array || e && e.push && a(e)) { for (var o = e.length; --o > -1;) this.remove(e[o]); return this } return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e) }, f._remove = function(t, i) { return e.prototype._remove.call(this, t, i), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this }, f.append = function(t, e) { return this.add(t, this._parseTimeOrLabel(null, e, !0, t)) }, f.insert = f.insertMultiple = function(t, e, i, o) { return this.add(t, e || 0, i, o) }, f.appendMultiple = function(t, e, i, o) { return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, o) }, f.addLabel = function(t, e) { return this._labels[t] = this._parseTimeOrLabel(e), this }, f.addPause = function(t, e, o, n) { var s = i.delayedCall(0, p, o, n || this); return s.vars.onComplete = s.vars.onReverseComplete = e, s.data = "isPause", this._hasPause = !0, this.add(s, t) }, f.removeLabel = function(t) { return delete this._labels[t], this }, f.getLabelTime = function(t) { return null != this._labels[t] ? this._labels[t] : -1 }, f._parseTimeOrLabel = function(e, i, o, n) { var s, r; if (n instanceof t && n.timeline === this) this.remove(n);
                    else if (n && (n instanceof Array || n.push && a(n)))
                        for (r = n.length; --r > -1;) n[r] instanceof t && n[r].timeline === this && this.remove(n[r]); if (s = "number" != typeof e || i ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof i) return this._parseTimeOrLabel(i, o && "number" == typeof e && null == this._labels[i] ? e - s : 0, o); if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = s);
                    else { if (-1 === (r = e.indexOf("="))) return null == this._labels[e] ? o ? this._labels[e] = s + i : i : this._labels[e] + i;
                        i = parseInt(e.charAt(r - 1) + "1", 10) * Number(e.substr(r + 1)), e = r > 1 ? this._parseTimeOrLabel(e.substr(0, r - 1), 0, o) : s } return Number(e) + i }, f.seek = function(t, e) { return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), !1 !== e) }, f.stop = function() { return this.paused(!0) }, f.gotoAndPlay = function(t, e) { return this.play(t, e) }, f.gotoAndStop = function(t, e) { return this.pause(t, e) }, f.render = function(t, e, i) { this._gc && this._enabled(!0, !1); var o, n, s, r, a, c, d, u = this._time,
                        p = this._dirty ? this.totalDuration() : this._totalDuration,
                        m = this._startTime,
                        f = this._timeScale,
                        y = this._paused; if (u !== this._time && (t += this._time - u), t >= p - 1e-7 && t >= 0) this._totalTime = this._time = p, this._reversed || this._hasPausedChild() || (n = !0, r = "onComplete", a = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || this._rawPrevTime < 0 || 1e-10 === this._rawPrevTime) && this._rawPrevTime !== t && this._first && (a = !0, this._rawPrevTime > 1e-10 && (r = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, t = p + 1e-4;
                    else if (t < 1e-7)
                        if (this._totalTime = this._time = 0, (0 !== u || 0 === this._duration && 1e-10 !== this._rawPrevTime && (this._rawPrevTime > 0 || t < 0 && this._rawPrevTime >= 0)) && (r = "onReverseComplete", n = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (a = n = !0, r = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (a = !0), this._rawPrevTime = t;
                        else { if (this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && n)
                                for (o = this._first; o && 0 === o._startTime;) o._duration || (n = !1), o = o._next;
                            t = 0, this._initted || (a = !0) } else { if (this._hasPause && !this._forcingPlayhead && !e) { if (t >= u)
                                for (o = this._first; o && o._startTime <= t && !c;) o._duration || "isPause" !== o.data || o.ratio || 0 === o._startTime && 0 === this._rawPrevTime || (c = o), o = o._next;
                            else
                                for (o = this._last; o && o._startTime >= t && !c;) o._duration || "isPause" === o.data && o._rawPrevTime > 0 && (c = o), o = o._prev;
                            c && (this._time = t = c._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay)) } this._totalTime = this._time = this._rawPrevTime = t } if (this._time !== u && this._first || i || a || c) { if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== u && t > 0 && (this._active = !0), 0 === u && this.vars.onStart && (0 === this._time && this._duration || e || this._callback("onStart")), (d = this._time) >= u)
                            for (o = this._first; o && (s = o._next, d === this._time && (!this._paused || y));)(o._active || o._startTime <= d && !o._paused && !o._gc) && (c === o && this.pause(), o._reversed ? o.render((o._dirty ? o.totalDuration() : o._totalDuration) - (t - o._startTime) * o._timeScale, e, i) : o.render((t - o._startTime) * o._timeScale, e, i)), o = s;
                        else
                            for (o = this._last; o && (s = o._prev, d === this._time && (!this._paused || y));) { if (o._active || o._startTime <= u && !o._paused && !o._gc) { if (c === o) { for (c = o._prev; c && c.endTime() > this._time;) c.render(c._reversed ? c.totalDuration() - (t - c._startTime) * c._timeScale : (t - c._startTime) * c._timeScale, e, i), c = c._prev;
                                        c = null, this.pause() } o._reversed ? o.render((o._dirty ? o.totalDuration() : o._totalDuration) - (t - o._startTime) * o._timeScale, e, i) : o.render((t - o._startTime) * o._timeScale, e, i) } o = s } this._onUpdate && (e || (h.length && l(), this._callback("onUpdate"))), r && (this._gc || m !== this._startTime && f === this._timeScale || (0 === this._time || p >= this.totalDuration()) && (n && (h.length && l(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[r] && this._callback(r))) } }, f._hasPausedChild = function() { for (var t = this._first; t;) { if (t._paused || t instanceof o && t._hasPausedChild()) return !0;
                        t = t._next } return !1 }, f.getChildren = function(t, e, o, n) { n = n || -9999999999; for (var s = [], r = this._first, a = 0; r;) r._startTime < n || (r instanceof i ? !1 !== e && (s[a++] = r) : (!1 !== o && (s[a++] = r), !1 !== t && (a = (s = s.concat(r.getChildren(!0, e, o))).length))), r = r._next; return s }, f.getTweensOf = function(t, e) { var o, n, s = this._gc,
                        r = [],
                        a = 0; for (s && this._enabled(!0, !0), n = (o = i.getTweensOf(t)).length; --n > -1;)(o[n].timeline === this || e && this._contains(o[n])) && (r[a++] = o[n]); return s && this._enabled(!1, !0), r }, f.recent = function() { return this._recent }, f._contains = function(t) { for (var e = t.timeline; e;) { if (e === this) return !0;
                        e = e.timeline } return !1 }, f.shiftChildren = function(t, e, i) { i = i || 0; for (var o, n = this._first, s = this._labels; n;) n._startTime >= i && (n._startTime += t), n = n._next; if (e)
                        for (o in s) s[o] >= i && (s[o] += t); return this._uncache(!0) }, f._kill = function(t, e) { if (!t && !e) return this._enabled(!1, !1); for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), o = i.length, n = !1; --o > -1;) i[o]._kill(t, e) && (n = !0); return n }, f.clear = function(t) { var e = this.getChildren(!1, !0, !0),
                        i = e.length; for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1); return !1 !== t && (this._labels = {}), this._uncache(!0) }, f.invalidate = function() { for (var e = this._first; e;) e.invalidate(), e = e._next; return t.prototype.invalidate.call(this) }, f._enabled = function(t, i) { if (t === this._gc)
                        for (var o = this._first; o;) o._enabled(t, !0), o = o._next; return e.prototype._enabled.call(this, t, i) }, f.totalTime = function(e, i, o) { this._forcingPlayhead = !0; var n = t.prototype.totalTime.apply(this, arguments); return this._forcingPlayhead = !1, n }, f.duration = function(t) { return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration) }, f.totalDuration = function(t) { if (!arguments.length) { if (this._dirty) { for (var e, i, o = 0, n = this._last, s = 999999999999; n;) e = n._prev, n._dirty && n.totalDuration(), n._startTime > s && this._sortChildren && !n._paused && !this._calculatingDuration ? (this._calculatingDuration = 1, this.add(n, n._startTime - n._delay), this._calculatingDuration = 0) : s = n._startTime, n._startTime < 0 && !n._paused && (o -= n._startTime, this._timeline.smoothChildTiming && (this._startTime += n._startTime / this._timeScale, this._time -= n._startTime, this._totalTime -= n._startTime, this._rawPrevTime -= n._startTime), this.shiftChildren(-n._startTime, !1, -9999999999), s = 0), (i = n._startTime + n._totalDuration / n._timeScale) > o && (o = i), n = e;
                            this._duration = this._totalDuration = o, this._dirty = !1 } return this._totalDuration } return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this }, f.paused = function(e) { if (!e)
                        for (var i = this._first, o = this._time; i;) i._startTime === o && "isPause" === i.data && (i._rawPrevTime = 0), i = i._next; return t.prototype.paused.apply(this, arguments) }, f.usesFrames = function() { for (var e = this._timeline; e._timeline;) e = e._timeline; return e === t._rootFramesTimeline }, f.rawTime = function(t) { return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale }, o }, !0), _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(t, e, i) { var o = function(e) { t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !0 === this.vars.yoyo, this._dirty = !0 },
                    n = e._internals,
                    s = n.lazyTweens,
                    r = n.lazyRender,
                    a = _gsScope._gsDefine.globals,
                    h = new i(null, null, 1, 0),
                    l = o.prototype = new t; return l.constructor = o, l.kill()._gc = !1, o.version = "1.20.4", l.invalidate = function() { return this._yoyo = !0 === this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this) }, l.addCallback = function(t, i, o, n) { return this.add(e.delayedCall(0, t, o, n), i) }, l.removeCallback = function(t, e) { if (t)
                        if (null == e) this._kill(null, t);
                        else
                            for (var i = this.getTweensOf(t, !1), o = i.length, n = this._parseTimeOrLabel(e); --o > -1;) i[o]._startTime === n && i[o]._enabled(!1, !1); return this }, l.removePause = function(e) { return this.removeCallback(t._internals.pauseCallback, e) }, l.tweenTo = function(t, i) { i = i || {}; var o, n, s, r = { ease: h, useFrames: this.usesFrames(), immediateRender: !1, lazy: !1 },
                        l = i.repeat && a.TweenMax || e; for (n in i) r[n] = i[n]; return r.time = this._parseTimeOrLabel(t), o = Math.abs(Number(r.time) - this._time) / this._timeScale || .001, s = new l(this, o, r), r.onStart = function() { s.target.paused(!0), s.vars.time === s.target.time() || o !== s.duration() || s.isFromTo || s.duration(Math.abs(s.vars.time - s.target.time()) / s.target._timeScale).render(s.time(), !0, !0), i.onStart && i.onStart.apply(i.onStartScope || i.callbackScope || s, i.onStartParams || []) }, s }, l.tweenFromTo = function(t, e, i) { i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = { onComplete: this.seek, onCompleteParams: [t], callbackScope: this }, i.immediateRender = !1 !== i.immediateRender; var o = this.tweenTo(e, i); return o.isFromTo = 1, o.duration(Math.abs(o.vars.time - t) / this._timeScale || .001) }, l.render = function(t, e, i) { this._gc && this._enabled(!0, !1); var o, n, a, h, l, c, d, u, p = this._time,
                        m = this._dirty ? this.totalDuration() : this._totalDuration,
                        f = this._duration,
                        y = this._totalTime,
                        b = this._startTime,
                        g = this._timeScale,
                        _ = this._rawPrevTime,
                        v = this._paused,
                        x = this._cycle; if (p !== this._time && (t += this._time - p), t >= m - 1e-7 && t >= 0) this._locked || (this._totalTime = m, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (n = !0, h = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (t <= 0 && t >= -1e-7 || _ < 0 || 1e-10 === _) && _ !== t && this._first && (l = !0, _ > 1e-10 && (h = "onReverseComplete"))), this._rawPrevTime = this._duration || !e || t || this._rawPrevTime === t ? t : 1e-10, this._yoyo && 0 != (1 & this._cycle) ? this._time = t = 0 : (this._time = f, t = f + 1e-4);
                    else if (t < 1e-7)
                        if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== p || 0 === f && 1e-10 !== _ && (_ > 0 || t < 0 && _ >= 0) && !this._locked) && (h = "onReverseComplete", n = this._reversed), t < 0) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = n = !0, h = "onReverseComplete") : _ >= 0 && this._first && (l = !0), this._rawPrevTime = t;
                        else { if (this._rawPrevTime = f || !e || t || this._rawPrevTime === t ? t : 1e-10, 0 === t && n)
                                for (o = this._first; o && 0 === o._startTime;) o._duration || (n = !1), o = o._next;
                            t = 0, this._initted || (l = !0) } else if (0 === f && _ < 0 && (l = !0), this._time = this._rawPrevTime = t, this._locked || (this._totalTime = t, 0 !== this._repeat && (c = f + this._repeatDelay, this._cycle = this._totalTime / c >> 0, 0 !== this._cycle && this._cycle === this._totalTime / c && y <= t && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 0 != (1 & this._cycle) && (this._time = f - this._time), this._time > f ? (this._time = f, t = f + 1e-4) : this._time < 0 ? this._time = t = 0 : t = this._time)), this._hasPause && !this._forcingPlayhead && !e) { if ((t = this._time) >= p || this._repeat && x !== this._cycle)
                            for (o = this._first; o && o._startTime <= t && !d;) o._duration || "isPause" !== o.data || o.ratio || 0 === o._startTime && 0 === this._rawPrevTime || (d = o), o = o._next;
                        else
                            for (o = this._last; o && o._startTime >= t && !d;) o._duration || "isPause" === o.data && o._rawPrevTime > 0 && (d = o), o = o._prev;
                        d && d._startTime < f && (this._time = t = d._startTime, this._totalTime = t + this._cycle * (this._totalDuration + this._repeatDelay)) } if (this._cycle !== x && !this._locked) { var S = this._yoyo && 0 != (1 & x),
                            C = S === (this._yoyo && 0 != (1 & this._cycle)),
                            w = this._totalTime,
                            A = this._cycle,
                            T = this._rawPrevTime,
                            P = this._time; if (this._totalTime = x * f, this._cycle < x ? S = !S : this._totalTime += f, this._time = p, this._rawPrevTime = 0 === f ? _ - 1e-4 : _, this._cycle = x, this._locked = !0, p = S ? 0 : f, this.render(p, e, 0 === f), e || this._gc || this.vars.onRepeat && (this._cycle = A, this._locked = !1, this._callback("onRepeat")), p !== this._time) return; if (C && (this._cycle = x, this._locked = !0, p = S ? f + 1e-4 : -1e-4, this.render(p, !0, !1)), this._locked = !1, this._paused && !v) return;
                        this._time = P, this._totalTime = w, this._cycle = A, this._rawPrevTime = T } if (this._time !== p && this._first || i || l || d) { if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== y && t > 0 && (this._active = !0), 0 === y && this.vars.onStart && (0 === this._totalTime && this._totalDuration || e || this._callback("onStart")), (u = this._time) >= p)
                            for (o = this._first; o && (a = o._next, u === this._time && (!this._paused || v));)(o._active || o._startTime <= this._time && !o._paused && !o._gc) && (d === o && this.pause(), o._reversed ? o.render((o._dirty ? o.totalDuration() : o._totalDuration) - (t - o._startTime) * o._timeScale, e, i) : o.render((t - o._startTime) * o._timeScale, e, i)), o = a;
                        else
                            for (o = this._last; o && (a = o._prev, u === this._time && (!this._paused || v));) { if (o._active || o._startTime <= p && !o._paused && !o._gc) { if (d === o) { for (d = o._prev; d && d.endTime() > this._time;) d.render(d._reversed ? d.totalDuration() - (t - d._startTime) * d._timeScale : (t - d._startTime) * d._timeScale, e, i), d = d._prev;
                                        d = null, this.pause() } o._reversed ? o.render((o._dirty ? o.totalDuration() : o._totalDuration) - (t - o._startTime) * o._timeScale, e, i) : o.render((t - o._startTime) * o._timeScale, e, i) } o = a } this._onUpdate && (e || (s.length && r(), this._callback("onUpdate"))), h && (this._locked || this._gc || b !== this._startTime && g === this._timeScale || (0 === this._time || m >= this.totalDuration()) && (n && (s.length && r(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[h] && this._callback(h))) } else y !== this._totalTime && this._onUpdate && (e || this._callback("onUpdate")) }, l.getActive = function(t, e, i) { null == t && (t = !0), null == e && (e = !0), null == i && (i = !1); var o, n, s = [],
                        r = this.getChildren(t, e, i),
                        a = 0,
                        h = r.length; for (o = 0; o < h; o++)(n = r[o]).isActive() && (s[a++] = n); return s }, l.getLabelAfter = function(t) { t || 0 !== t && (t = this._time); var e, i = this.getLabelsArray(),
                        o = i.length; for (e = 0; e < o; e++)
                        if (i[e].time > t) return i[e].name; return null }, l.getLabelBefore = function(t) { null == t && (t = this._time); for (var e = this.getLabelsArray(), i = e.length; --i > -1;)
                        if (e[i].time < t) return e[i].name; return null }, l.getLabelsArray = function() { var t, e = [],
                        i = 0; for (t in this._labels) e[i++] = { time: this._labels[t], name: t }; return e.sort(function(t, e) { return t.time - e.time }), e }, l.invalidate = function() { return this._locked = !1, t.prototype.invalidate.call(this) }, l.progress = function(t, e) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() || 0 }, l.totalProgress = function(t, e) { return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() || 0 }, l.totalDuration = function(e) { return arguments.length ? -1 !== this._repeat && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration) }, l.time = function(t, e) { return arguments.length ? (this._dirty && this.totalDuration(), t > this._duration && (t = this._duration), this._yoyo && 0 != (1 & this._cycle) ? t = this._duration - t + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (t += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(t, e)) : this._time }, l.repeat = function(t) { return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat }, l.repeatDelay = function(t) { return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay }, l.yoyo = function(t) { return arguments.length ? (this._yoyo = t, this) : this._yoyo }, l.currentLabel = function(t) { return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + 1e-8) }, o }, !0),
            function() { var t = 180 / Math.PI,
                    e = [],
                    i = [],
                    o = [],
                    n = {},
                    s = _gsScope._gsDefine.globals,
                    r = function(t, e, i, o) { i === o && (i = o - (o - e) / 1e6), t === e && (e = t + (i - t) / 1e6), this.a = t, this.b = e, this.c = i, this.d = o, this.da = o - t, this.ca = i - t, this.ba = e - t },
                    a = function(t, e, i, o) { var n = { a: t },
                            s = {},
                            r = {},
                            a = { c: o },
                            h = (t + e) / 2,
                            l = (e + i) / 2,
                            c = (i + o) / 2,
                            d = (h + l) / 2,
                            u = (l + c) / 2,
                            p = (u - d) / 8; return n.b = h + (t - h) / 4, s.b = d + p, n.c = s.a = (n.b + s.b) / 2, s.c = r.a = (d + u) / 2, r.b = u - p, a.b = c + (o - c) / 4, r.c = a.a = (r.b + a.b) / 2, [n, s, r, a] },
                    h = function(t, n, s, r, h) { var l, c, d, u, p, m, f, y, b, g, _, v, x, S = t.length - 1,
                            C = 0,
                            w = t[0].a; for (l = 0; l < S; l++) c = (p = t[C]).a, d = p.d, u = t[C + 1].d, h ? (_ = e[l], x = ((v = i[l]) + _) * n * .25 / (r ? .5 : o[l] || .5), y = d - ((m = d - (d - c) * (r ? .5 * n : 0 !== _ ? x / _ : 0)) + (((f = d + (u - d) * (r ? .5 * n : 0 !== v ? x / v : 0)) - m) * (3 * _ / (_ + v) + .5) / 4 || 0))) : y = d - ((m = d - (d - c) * n * .5) + (f = d + (u - d) * n * .5)) / 2, m += y, f += y, p.c = b = m, p.b = 0 !== l ? w : w = p.a + .6 * (p.c - p.a), p.da = d - c, p.ca = b - c, p.ba = w - c, s ? (g = a(c, w, b, d), t.splice(C, 1, g[0], g[1], g[2], g[3]), C += 4) : C++, w = f;
                        (p = t[C]).b = w, p.c = w + .4 * (p.d - w), p.da = p.d - p.a, p.ca = p.c - p.a, p.ba = w - p.a, s && (g = a(p.a, w, p.c, p.d), t.splice(C, 1, g[0], g[1], g[2], g[3])) },
                    l = function(t, o, n, s) { var a, h, l, c, d, u, p = []; if (s)
                            for (h = (t = [s].concat(t)).length; --h > -1;) "string" == typeof(u = t[h][o]) && "=" === u.charAt(1) && (t[h][o] = s[o] + Number(u.charAt(0) + u.substr(2))); if ((a = t.length - 2) < 0) return p[0] = new r(t[0][o], 0, 0, t[0][o]), p; for (h = 0; h < a; h++) l = t[h][o], c = t[h + 1][o], p[h] = new r(l, 0, 0, c), n && (d = t[h + 2][o], e[h] = (e[h] || 0) + (c - l) * (c - l), i[h] = (i[h] || 0) + (d - c) * (d - c)); return p[h] = new r(t[h][o], 0, 0, t[h + 1][o]), p },
                    c = function(t, s, r, a, c, d) { var u, p, m, f, y, b, g, _, v = {},
                            x = [],
                            S = d || t[0];
                        c = "string" == typeof c ? "," + c + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == s && (s = 1); for (p in t[0]) x.push(p); if (t.length > 1) { for (_ = t[t.length - 1], g = !0, u = x.length; --u > -1;)
                                if (p = x[u], Math.abs(S[p] - _[p]) > .05) { g = !1; break } g && (t = t.concat(), d && t.unshift(d), t.push(t[1]), d = t[t.length - 3]) } for (e.length = i.length = o.length = 0, u = x.length; --u > -1;) p = x[u], n[p] = -1 !== c.indexOf("," + p + ","), v[p] = l(t, p, n[p], d); for (u = e.length; --u > -1;) e[u] = Math.sqrt(e[u]), i[u] = Math.sqrt(i[u]); if (!a) { for (u = x.length; --u > -1;)
                                if (n[p])
                                    for (b = (m = v[x[u]]).length - 1, f = 0; f < b; f++) y = m[f + 1].da / i[f] + m[f].da / e[f] || 0, o[f] = (o[f] || 0) + y * y; for (u = o.length; --u > -1;) o[u] = Math.sqrt(o[u]) } for (u = x.length, f = r ? 4 : 1; --u > -1;) m = v[p = x[u]], h(m, s, r, a, n[p]), g && (m.splice(0, f), m.splice(m.length - f, f)); return v },
                    d = function(t, e, i) { var o, n, s, a, h, l, c, d, u, p, m, f = {},
                            y = "cubic" === (e = e || "soft") ? 3 : 2,
                            b = "soft" === e,
                            g = []; if (b && i && (t = [i].concat(t)), null == t || t.length < y + 1) throw "invalid Bezier data"; for (u in t[0]) g.push(u); for (l = g.length; --l > -1;) { for (f[u = g[l]] = h = [], p = 0, d = t.length, c = 0; c < d; c++) o = null == i ? t[c][u] : "string" == typeof(m = t[c][u]) && "=" === m.charAt(1) ? i[u] + Number(m.charAt(0) + m.substr(2)) : Number(m), b && c > 1 && c < d - 1 && (h[p++] = (o + h[p - 2]) / 2), h[p++] = o; for (d = p - y + 1, p = 0, c = 0; c < d; c += y) o = h[c], n = h[c + 1], s = h[c + 2], a = 2 === y ? 0 : h[c + 3], h[p++] = m = 3 === y ? new r(o, n, s, a) : new r(o, (2 * n + o) / 3, (2 * n + s) / 3, s);
                            h.length = p } return f },
                    u = function(t, e, i) { for (var o, n, s, r, a, h, l, c, d, u, p, m = 1 / i, f = t.length; --f > -1;)
                            for (s = (u = t[f]).a, r = u.d - s, a = u.c - s, h = u.b - s, o = n = 0, c = 1; c <= i; c++) o = n - (n = ((l = m * c) * l * r + 3 * (d = 1 - l) * (l * a + d * h)) * l), e[p = f * i + c - 1] = (e[p] || 0) + o * o },
                    p = function(t, e) { var i, o, n, s, r = [],
                            a = [],
                            h = 0,
                            l = 0,
                            c = (e = e >> 0 || 6) - 1,
                            d = [],
                            p = []; for (i in t) u(t[i], r, e); for (n = r.length, o = 0; o < n; o++) h += Math.sqrt(r[o]), p[s = o % e] = h, s === c && (l += h, d[s = o / e >> 0] = p, a[s] = l, h = 0, p = []); return { length: l, lengths: a, segments: d } },
                    m = _gsScope._gsDefine.plugin({ propName: "bezier", priority: -1, version: "1.3.8", API: 2, global: !0, init: function(t, e, i) { this._target = t, e instanceof Array && (e = { values: e }), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10); var o, n, s, r, a, h = e.values || [],
                                l = {},
                                u = h[0],
                                m = e.autoRotate || i.vars.orientToBezier;
                            this._autoRotate = m ? m instanceof Array ? m : [
                                ["x", "y", "rotation", !0 === m ? 0 : Number(m) || 0]
                            ] : null; for (o in u) this._props.push(o); for (s = this._props.length; --s > -1;) o = this._props[s], this._overwriteProps.push(o), n = this._func[o] = "function" == typeof t[o], l[o] = n ? t[o.indexOf("set") || "function" != typeof t["get" + o.substr(3)] ? o : "get" + o.substr(3)]() : parseFloat(t[o]), a || l[o] !== h[0][o] && (a = l); if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? c(h, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, a) : d(h, e.type, l), this._segCount = this._beziers[o].length, this._timeRes) { var f = p(this._beziers, this._timeRes);
                                this._length = f.length, this._lengths = f.lengths, this._segments = f.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length } if (m = this._autoRotate)
                                for (this._initialRotations = [], m[0] instanceof Array || (this._autoRotate = m = [m]), s = m.length; --s > -1;) { for (r = 0; r < 3; r++) o = m[s][r], this._func[o] = "function" == typeof t[o] && t[o.indexOf("set") || "function" != typeof t["get" + o.substr(3)] ? o : "get" + o.substr(3)];
                                    o = m[s][2], this._initialRotations[s] = (this._func[o] ? this._func[o].call(this._target) : this._target[o]) || 0, this._overwriteProps.push(o) }
                            return this._startRatio = i.vars.runBackwards ? 1 : 0, !0 }, set: function(e) { var i, o, n, s, r, a, h, l, c, d, u = this._segCount,
                                p = this._func,
                                m = this._target,
                                f = e !== this._startRatio; if (this._timeRes) { if (c = this._lengths, d = this._curSeg, e *= this._length, n = this._li, e > this._l2 && n < u - 1) { for (l = u - 1; n < l && (this._l2 = c[++n]) <= e;);
                                    this._l1 = c[n - 1], this._li = n, this._curSeg = d = this._segments[n], this._s2 = d[this._s1 = this._si = 0] } else if (e < this._l1 && n > 0) { for (; n > 0 && (this._l1 = c[--n]) >= e;);
                                    0 === n && e < this._l1 ? this._l1 = 0 : n++, this._l2 = c[n], this._li = n, this._curSeg = d = this._segments[n], this._s1 = d[(this._si = d.length - 1) - 1] || 0, this._s2 = d[this._si] } if (i = n, e -= this._l1, n = this._si, e > this._s2 && n < d.length - 1) { for (l = d.length - 1; n < l && (this._s2 = d[++n]) <= e;);
                                    this._s1 = d[n - 1], this._si = n } else if (e < this._s1 && n > 0) { for (; n > 0 && (this._s1 = d[--n]) >= e;);
                                    0 === n && e < this._s1 ? this._s1 = 0 : n++, this._s2 = d[n], this._si = n } a = (n + (e - this._s1) / (this._s2 - this._s1)) * this._prec || 0 } else a = (e - (i = e < 0 ? 0 : e >= 1 ? u - 1 : u * e >> 0) * (1 / u)) * u; for (o = 1 - a, n = this._props.length; --n > -1;) s = this._props[n], h = (a * a * (r = this._beziers[s][i]).da + 3 * o * (a * r.ca + o * r.ba)) * a + r.a, this._mod[s] && (h = this._mod[s](h, m)), p[s] ? m[s](h) : m[s] = h; if (this._autoRotate) { var y, b, g, _, v, x, S, C = this._autoRotate; for (n = C.length; --n > -1;) s = C[n][2], x = C[n][3] || 0, S = !0 === C[n][4] ? 1 : t, r = this._beziers[C[n][0]], y = this._beziers[C[n][1]], r && y && (r = r[i], y = y[i], b = r.a + (r.b - r.a) * a, b += ((_ = r.b + (r.c - r.b) * a) - b) * a, _ += (r.c + (r.d - r.c) * a - _) * a, g = y.a + (y.b - y.a) * a, g += ((v = y.b + (y.c - y.b) * a) - g) * a, v += (y.c + (y.d - y.c) * a - v) * a, h = f ? Math.atan2(v - g, _ - b) * S + x : this._initialRotations[n], this._mod[s] && (h = this._mod[s](h, m)), p[s] ? m[s](h) : m[s] = h) } } }),
                    f = m.prototype;
                m.bezierThrough = c, m.cubicToQuadratic = a, m._autoCSS = !0, m.quadraticToCubic = function(t, e, i) { return new r(t, (2 * e + t) / 3, (2 * e + i) / 3, i) }, m._cssRegister = function() { var t = s.CSSPlugin; if (t) { var e = t._internals,
                            i = e._parseToProxy,
                            o = e._setPluginRatio,
                            n = e.CSSPropTween;
                        e._registerComplexSpecialProp("bezier", { parser: function(t, e, s, r, a, h) { e instanceof Array && (e = { values: e }), h = new m; var l, c, d, u = e.values,
                                    p = u.length - 1,
                                    f = [],
                                    y = {}; if (p < 0) return a; for (l = 0; l <= p; l++) d = i(t, u[l], r, a, h, p !== l), f[l] = d.end; for (c in e) y[c] = e[c]; return y.values = f, a = new n(t, "bezier", 0, 0, d.pt, 2), a.data = d, a.plugin = h, a.setRatio = o, 0 === y.autoRotate && (y.autoRotate = !0), !y.autoRotate || y.autoRotate instanceof Array || (l = !0 === y.autoRotate ? 0 : Number(y.autoRotate), y.autoRotate = null != d.end.left ? [
                                    ["left", "top", "rotation", l, !1]
                                ] : null != d.end.x && [
                                    ["x", "y", "rotation", l, !1]
                                ]), y.autoRotate && (r._transform || r._enableTransforms(!1), d.autoRotate = r._target._gsTransform, d.proxy.rotation = d.autoRotate.rotation || 0, r._overwriteProps.push("rotation")), h._onInitTween(d.proxy, y, r._tween), a } }) } }, f._mod = function(t) { for (var e, i = this._overwriteProps, o = i.length; --o > -1;)(e = t[i[o]]) && "function" == typeof e && (this._mod[i[o]] = e) }, f._kill = function(t) { var e, i, o = this._props; for (e in this._beziers)
                        if (e in t)
                            for (delete this._beziers[e], delete this._func[e], i = o.length; --i > -1;) o[i] === e && o.splice(i, 1); if (o = this._autoRotate)
                        for (i = o.length; --i > -1;) t[o[i][2]] && o.splice(i, 1); return this._super._kill.call(this, t) } }(), _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(t, e) { var i, o, n, s, r = function() { t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = r.prototype.setRatio },
                    a = _gsScope._gsDefine.globals,
                    h = {},
                    l = r.prototype = new t("css");
                l.constructor = r, r.version = "1.20.5", r.API = 2, r.defaultTransformPerspective = 0, r.defaultSkewType = "compensated", r.defaultSmoothOrigin = !0, l = "px", r.suffixMap = { top: l, right: l, bottom: l, left: l, width: l, height: l, fontSize: l, padding: l, margin: l, perspective: l, lineHeight: "" }; var c, d, u, p, m, f, y, b, g = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
                    _ = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                    v = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                    x = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                    S = /(?:\d|\-|\+|=|#|\.)*/g,
                    C = /opacity *= *([^)]*)/i,
                    w = /opacity:([^;]*)/i,
                    A = /alpha\(opacity *=.+?\)/i,
                    T = /^(rgb|hsl)/,
                    P = /([A-Z])/g,
                    k = /-([a-z])/gi,
                    M = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                    E = function(t, e) { return e.toUpperCase() },
                    B = /(?:Left|Right|Width)/i,
                    I = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                    D = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                    L = /,(?=[^\)]*(?:\(|$))/gi,
                    O = /[\s,\(]/i,
                    R = Math.PI / 180,
                    F = 180 / Math.PI,
                    V = {},
                    G = { style: {} },
                    U = _gsScope.document || { createElement: function() { return G } },
                    N = function(t, e) { return U.createElementNS ? U.createElementNS(e || "http://www.w3.org/1999/xhtml", t) : U.createElement(t) },
                    j = N("div"),
                    W = N("img"),
                    X = r._internals = { _specialProps: h },
                    H = (_gsScope.navigator || {}).userAgent || "",
                    z = function() { var t = H.indexOf("Android"),
                            e = N("a"); return u = -1 !== H.indexOf("Safari") && -1 === H.indexOf("Chrome") && (-1 === t || parseFloat(H.substr(t + 8, 2)) > 3), m = u && parseFloat(H.substr(H.indexOf("Version/") + 8, 2)) < 6, p = -1 !== H.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(H) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(H)) && (f = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity)) }(),
                    J = function(t) { return C.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1 },
                    q = function(t) { _gsScope.console },
                    Y = "",
                    K = "",
                    Z = function(t, e) { var i, o, n = (e = e || j).style; if (void 0 !== n[t]) return t; for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], o = 5; --o > -1 && void 0 === n[i[o] + t];); return o >= 0 ? (K = 3 === o ? "ms" : i[o], Y = "-" + K.toLowerCase() + "-", K + t) : null },
                    Q = ("undefined" != typeof window ? window : U.defaultView || { getComputedStyle: function() {} }).getComputedStyle,
                    $ = r.getStyle = function(t, e, i, o, n) { var s; return z || "opacity" !== e ? (!o && t.style[e] ? s = t.style[e] : (i = i || Q(t)) ? s = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(P, "-$1").toLowerCase()) : t.currentStyle && (s = t.currentStyle[e]), null == n || s && "none" !== s && "auto" !== s && "auto auto" !== s ? s : n) : J(t) },
                    tt = X.convertToPixels = function(t, i, o, n, s) { if ("px" === n || !n && "lineHeight" !== i) return o; if ("auto" === n || !o) return 0; var a, h, l, c = B.test(i),
                            d = t,
                            u = j.style,
                            p = o < 0,
                            m = 1 === o; if (p && (o = -o), m && (o *= 100), "lineHeight" !== i || n)
                            if ("%" === n && -1 !== i.indexOf("border")) a = o / 100 * (c ? t.clientWidth : t.clientHeight);
                            else { if (u.cssText = "border:0 solid red;position:" + $(t, "position") + ";line-height:0;", "%" !== n && d.appendChild && "v" !== n.charAt(0) && "rem" !== n) u[c ? "borderLeftWidth" : "borderTopWidth"] = o + n;
                                else { if (d = t.parentNode || U.body, -1 !== $(d, "display").indexOf("flex") && (u.position = "absolute"), h = d._gsCache, l = e.ticker.frame, h && c && h.time === l) return h.width * o / 100;
                                    u[c ? "width" : "height"] = o + n } d.appendChild(j), a = parseFloat(j[c ? "offsetWidth" : "offsetHeight"]), d.removeChild(j), c && "%" === n && !1 !== r.cacheWidths && ((h = d._gsCache = d._gsCache || {}).time = l, h.width = a / o * 100), 0 !== a || s || (a = tt(t, i, o, n, !0)) } else h = Q(t).lineHeight, t.style.lineHeight = o, a = parseFloat(Q(t).lineHeight), t.style.lineHeight = h; return m && (a /= 100), p ? -a : a },
                    et = X.calculateOffset = function(t, e, i) { if ("absolute" !== $(t, "position", i)) return 0; var o = "left" === e ? "Left" : "Top",
                            n = $(t, "margin" + o, i); return t["offset" + o] - (tt(t, e, parseFloat(n), n.replace(S, "")) || 0) },
                    it = function(t, e) { var i, o, n, s = {}; if (e = e || Q(t, null))
                            if (i = e.length)
                                for (; --i > -1;) - 1 !== (n = e[i]).indexOf("-transform") && Mt !== n || (s[n.replace(k, E)] = e.getPropertyValue(n));
                            else
                                for (i in e) - 1 !== i.indexOf("Transform") && kt !== i || (s[i] = e[i]);
                        else if (e = t.currentStyle || t.style)
                            for (i in e) "string" == typeof i && void 0 === s[i] && (s[i.replace(k, E)] = e[i]); return z || (s.opacity = J(t)), o = Wt(t, e, !1), s.rotation = o.rotation, s.skewX = o.skewX, s.scaleX = o.scaleX, s.scaleY = o.scaleY, s.x = o.x, s.y = o.y, Bt && (s.z = o.z, s.rotationX = o.rotationX, s.rotationY = o.rotationY, s.scaleZ = o.scaleZ), s.filters && delete s.filters, s },
                    ot = function(t, e, i, o, n) { var s, r, a, h = {},
                            l = t.style; for (r in i) "cssText" !== r && "length" !== r && isNaN(r) && (e[r] !== (s = i[r]) || n && n[r]) && -1 === r.indexOf("Origin") && ("number" != typeof s && "string" != typeof s || (h[r] = "auto" !== s || "left" !== r && "top" !== r ? "" !== s && "auto" !== s && "none" !== s || "string" != typeof e[r] || "" === e[r].replace(x, "") ? s : 0 : et(t, r), void 0 !== l[r] && (a = new gt(l, r, l[r], a)))); if (o)
                            for (r in o) "className" !== r && (h[r] = o[r]); return { difs: h, firstMPT: a } },
                    nt = { width: ["Left", "Right"], height: ["Top", "Bottom"] },
                    st = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                    rt = function(t, e, i) { if ("svg" === (t.nodeName + "").toLowerCase()) return (i || Q(t))[e] || 0; if (t.getCTM && Ut(t)) return t.getBBox()[e] || 0; var o = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight),
                            n = nt[e],
                            s = n.length; for (i = i || Q(t, null); --s > -1;) o -= parseFloat($(t, "padding" + n[s], i, !0)) || 0, o -= parseFloat($(t, "border" + n[s] + "Width", i, !0)) || 0; return o },
                    at = function(t, e) { if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
                        null != t && "" !== t || (t = "0 0"); var i, o = t.split(" "),
                            n = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : o[0],
                            s = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : o[1]; if (o.length > 3 && !e) { for (o = t.split(", ").join(",").split(","), t = [], i = 0; i < o.length; i++) t.push(at(o[i])); return t.join(",") } return null == s ? s = "center" === n ? "50%" : "0" : "center" === s && (s = "50%"), ("center" === n || isNaN(parseFloat(n)) && -1 === (n + "").indexOf("=")) && (n = "50%"), t = n + " " + s + (o.length > 2 ? " " + o[2] : ""), e && (e.oxp = -1 !== n.indexOf("%"), e.oyp = -1 !== s.indexOf("%"), e.oxr = "=" === n.charAt(1), e.oyr = "=" === s.charAt(1), e.ox = parseFloat(n.replace(x, "")), e.oy = parseFloat(s.replace(x, "")), e.v = t), e || t },
                    ht = function(t, e) { return "function" == typeof t && (t = t(b, y)), "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0 },
                    lt = function(t, e) { return "function" == typeof t && (t = t(b, y)), null == t ? e : "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0 },
                    ct = function(t, e, i, o) { var n, s, r, a, h; return "function" == typeof t && (t = t(b, y)), null == t ? a = e : "number" == typeof t ? a = t : (n = 360, s = t.split("_"), r = ((h = "=" === t.charAt(1)) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(s[0].substr(2)) : parseFloat(s[0])) * (-1 === t.indexOf("rad") ? 1 : F) - (h ? 0 : e), s.length && (o && (o[i] = e + r), -1 !== t.indexOf("short") && (r %= n) !== r % (n / 2) && (r = r < 0 ? r + n : r - n), -1 !== t.indexOf("_cw") && r < 0 ? r = (r + 9999999999 * n) % n - (r / n | 0) * n : -1 !== t.indexOf("ccw") && r > 0 && (r = (r - 9999999999 * n) % n - (r / n | 0) * n)), a = e + r), a < 1e-6 && a > -1e-6 && (a = 0), a },
                    dt = { aqua: [0, 255, 255], lime: [0, 255, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, 255], navy: [0, 0, 128], white: [255, 255, 255], fuchsia: [255, 0, 255], olive: [128, 128, 0], yellow: [255, 255, 0], orange: [255, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [255, 0, 0], pink: [255, 192, 203], cyan: [0, 255, 255], transparent: [255, 255, 255, 0] },
                    ut = function(t, e, i) { return 255 * (6 * (t = t < 0 ? t + 1 : t > 1 ? t - 1 : t) < 1 ? e + (i - e) * t * 6 : t < .5 ? i : 3 * t < 2 ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0 },
                    pt = r.parseColor = function(t, e) { var i, o, n, s, r, a, h, l, c, d, u; if (t)
                            if ("number" == typeof t) i = [t >> 16, t >> 8 & 255, 255 & t];
                            else { if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), dt[t]) i = dt[t];
                                else if ("#" === t.charAt(0)) 4 === t.length && (t = "#" + (o = t.charAt(1)) + o + (n = t.charAt(2)) + n + (s = t.charAt(3)) + s), i = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & 255, 255 & t];
                                else if ("hsl" === t.substr(0, 3))
                                    if (i = u = t.match(g), e) { if (-1 !== t.indexOf("=")) return t.match(_) } else r = Number(i[0]) % 360 / 360, a = Number(i[1]) / 100, o = 2 * (h = Number(i[2]) / 100) - (n = h <= .5 ? h * (a + 1) : h + a - h * a), i.length > 3 && (i[3] = Number(i[3])), i[0] = ut(r + 1 / 3, o, n), i[1] = ut(r, o, n), i[2] = ut(r - 1 / 3, o, n);
                                else i = t.match(g) || dt.transparent;
                                i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), i.length > 3 && (i[3] = Number(i[3])) } else i = dt.black; return e && !u && (o = i[0] / 255, n = i[1] / 255, s = i[2] / 255, h = ((l = Math.max(o, n, s)) + (c = Math.min(o, n, s))) / 2, l === c ? r = a = 0 : (d = l - c, a = h > .5 ? d / (2 - l - c) : d / (l + c), r = l === o ? (n - s) / d + (n < s ? 6 : 0) : l === n ? (s - o) / d + 2 : (o - n) / d + 4, r *= 60), i[0] = r + .5 | 0, i[1] = 100 * a + .5 | 0, i[2] = 100 * h + .5 | 0), i },
                    mt = function(t, e) { var i, o, n, s = t.match(ft) || [],
                            r = 0,
                            a = ""; if (!s.length) return t; for (i = 0; i < s.length; i++) o = s[i], r += (n = t.substr(r, t.indexOf(o, r) - r)).length + o.length, 3 === (o = pt(o, e)).length && o.push(1), a += n + (e ? "hsla(" + o[0] + "," + o[1] + "%," + o[2] + "%," + o[3] : "rgba(" + o.join(",")) + ")"; return a + t.substr(r) },
                    ft = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b"; for (l in dt) ft += "|" + l + "\\b";
                ft = new RegExp(ft + ")", "gi"), r.colorStringFilter = function(t) { var e, i = t[0] + " " + t[1];
                    ft.test(i) && (e = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), t[0] = mt(t[0], e), t[1] = mt(t[1], e)), ft.lastIndex = 0 }, e.defaultStringFilter || (e.defaultStringFilter = r.colorStringFilter); var yt = function(t, e, i, o) { if (null == t) return function(t) { return t }; var n, s = e ? (t.match(ft) || [""])[0] : "",
                            r = t.split(s).join("").match(v) || [],
                            a = t.substr(0, t.indexOf(r[0])),
                            h = ")" === t.charAt(t.length - 1) ? ")" : "",
                            l = -1 !== t.indexOf(" ") ? " " : ",",
                            c = r.length,
                            d = c > 0 ? r[0].replace(g, "") : ""; return c ? n = e ? function(t) { var e, u, p, m; if ("number" == typeof t) t += d;
                            else if (o && L.test(t)) { for (m = t.replace(L, "|").split("|"), p = 0; p < m.length; p++) m[p] = n(m[p]); return m.join(",") } if (e = (t.match(ft) || [s])[0], u = t.split(e).join("").match(v) || [], p = u.length, c > p--)
                                for (; ++p < c;) u[p] = i ? u[(p - 1) / 2 | 0] : r[p]; return a + u.join(l) + l + e + h + (-1 !== t.indexOf("inset") ? " inset" : "") } : function(t) { var e, s, u; if ("number" == typeof t) t += d;
                            else if (o && L.test(t)) { for (s = t.replace(L, "|").split("|"), u = 0; u < s.length; u++) s[u] = n(s[u]); return s.join(",") } if (e = t.match(v) || [], u = e.length, c > u--)
                                for (; ++u < c;) e[u] = i ? e[(u - 1) / 2 | 0] : r[u]; return a + e.join(l) + h } : function(t) { return t } },
                    bt = function(t) { return t = t.split(","),
                            function(e, i, o, n, s, r, a) { var h, l = (i + "").split(" "); for (a = {}, h = 0; h < 4; h++) a[t[h]] = l[h] = l[h] || l[(h - 1) / 2 >> 0]; return n.parse(e, a, s, r) } },
                    gt = (X._setPluginRatio = function(t) { this.plugin.setRatio(t); for (var e, i, o, n, s, r = this.data, a = r.proxy, h = r.firstMPT; h;) e = a[h.v], h.r ? e = h.r(e) : e < 1e-6 && e > -1e-6 && (e = 0), h.t[h.p] = e, h = h._next; if (r.autoRotate && (r.autoRotate.rotation = r.mod ? r.mod.call(this._tween, a.rotation, this.t, this._tween) : a.rotation), 1 === t || 0 === t)
                            for (h = r.firstMPT, s = 1 === t ? "e" : "b"; h;) { if ((i = h.t).type) { if (1 === i.type) { for (n = i.xs0 + i.s + i.xs1, o = 1; o < i.l; o++) n += i["xn" + o] + i["xs" + (o + 1)];
                                        i[s] = n } } else i[s] = i.s + i.xs0;
                                h = h._next } }, function(t, e, i, o, n) { this.t = t, this.p = e, this.v = i, this.r = n, o && (o._prev = this, this._next = o) }),
                    _t = (X._parseToProxy = function(t, e, i, o, n, s) { var r, a, h, l, c, d = o,
                            u = {},
                            p = {},
                            m = i._transform,
                            f = V; for (i._transform = null, V = e, o = c = i.parse(t, e, o, n), V = f, s && (i._transform = m, d && (d._prev = null, d._prev && (d._prev._next = null))); o && o !== d;) { if (o.type <= 1 && (a = o.p, p[a] = o.s + o.c, u[a] = o.s, s || (l = new gt(o, "s", a, l, o.r), o.c = 0), 1 === o.type))
                                for (r = o.l; --r > 0;) h = "xn" + r, p[a = o.p + "_" + h] = o.data[h], u[a] = o[h], s || (l = new gt(o, h, a, l, o.rxp[h]));
                            o = o._next } return { proxy: u, end: p, firstMPT: l, pt: c } }, X.CSSPropTween = function(t, e, o, n, r, a, h, l, c, d, u) { this.t = t, this.p = e, this.s = o, this.c = n, this.n = h || e, t instanceof _t || s.push(this.n), this.r = l ? "function" == typeof l ? l : Math.round : l, this.type = a || 0, c && (this.pr = c, i = !0), this.b = void 0 === d ? o : d, this.e = void 0 === u ? o + n : u, r && (this._next = r, r._prev = this) }),
                    vt = function(t, e, i, o, n, s) { var r = new _t(t, e, i, o - i, n, -1, s); return r.b = i, r.e = r.xs0 = o, r },
                    xt = r.parseComplex = function(t, e, i, o, n, s, a, h, l, d) { i = i || s || "", "function" == typeof o && (o = o(b, y)), a = new _t(t, e, 0, 0, a, d ? 2 : 1, null, !1, h, i, o), o += "", n && ft.test(o + i) && (o = [i, o], r.colorStringFilter(o), i = o[0], o = o[1]); var u, p, m, f, v, x, S, C, w, A, T, P, k, M = i.split(", ").join(",").split(" "),
                            E = o.split(", ").join(",").split(" "),
                            B = M.length,
                            I = !1 !== c; for (-1 === o.indexOf(",") && -1 === i.indexOf(",") || (-1 !== (o + i).indexOf("rgb") || -1 !== (o + i).indexOf("hsl") ? (M = M.join(" ").replace(L, ", ").split(" "), E = E.join(" ").replace(L, ", ").split(" ")) : (M = M.join(" ").split(",").join(", ").split(" "), E = E.join(" ").split(",").join(", ").split(" ")), B = M.length), B !== E.length && (B = (M = (s || "").split(" ")).length), a.plugin = l, a.setRatio = d, ft.lastIndex = 0, u = 0; u < B; u++)
                            if (f = M[u], v = E[u] + "", (C = parseFloat(f)) || 0 === C) a.appendXtra("", C, ht(v, C), v.replace(_, ""), !(!I || -1 === v.indexOf("px")) && Math.round, !0);
                            else if (n && ft.test(f)) P = ")" + ((P = v.indexOf(")") + 1) ? v.substr(P) : ""), k = -1 !== v.indexOf("hsl") && z, A = v, f = pt(f, k), v = pt(v, k), (w = f.length + v.length > 6) && !z && 0 === v[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(E[u]).join("transparent")) : (z || (w = !1), k ? a.appendXtra(A.substr(0, A.indexOf("hsl")) + (w ? "hsla(" : "hsl("), f[0], ht(v[0], f[0]), ",", !1, !0).appendXtra("", f[1], ht(v[1], f[1]), "%,", !1).appendXtra("", f[2], ht(v[2], f[2]), w ? "%," : "%" + P, !1) : a.appendXtra(A.substr(0, A.indexOf("rgb")) + (w ? "rgba(" : "rgb("), f[0], v[0] - f[0], ",", Math.round, !0).appendXtra("", f[1], v[1] - f[1], ",", Math.round).appendXtra("", f[2], v[2] - f[2], w ? "," : P, Math.round), w && (f = f.length < 4 ? 1 : f[3], a.appendXtra("", f, (v.length < 4 ? 1 : v[3]) - f, P, !1))), ft.lastIndex = 0;
                        else if (x = f.match(g)) { if (!(S = v.match(_)) || S.length !== x.length) return a; for (m = 0, p = 0; p < x.length; p++) T = x[p], A = f.indexOf(T, m), a.appendXtra(f.substr(m, A - m), Number(T), ht(S[p], T), "", !(!I || "px" !== f.substr(A + T.length, 2)) && Math.round, 0 === p), m = A + T.length;
                            a["xs" + a.l] += f.substr(m) } else a["xs" + a.l] += a.l || a["xs" + a.l] ? " " + v : v; if (-1 !== o.indexOf("=") && a.data) { for (P = a.xs0 + a.data.s, u = 1; u < a.l; u++) P += a["xs" + u] + a.data["xn" + u];
                            a.e = P + a["xs" + u] } return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a },
                    St = 9; for ((l = _t.prototype).l = l.pr = 0; --St > 0;) l["xn" + St] = 0, l["xs" + St] = "";
                l.xs0 = "", l._next = l._prev = l.xfirst = l.data = l.plugin = l.setRatio = l.rxp = null, l.appendXtra = function(t, e, i, o, n, s) { var r = this,
                        a = r.l; return r["xs" + a] += s && (a || r["xs" + a]) ? " " + t : t || "", i || 0 === a || r.plugin ? (r.l++, r.type = r.setRatio ? 2 : 1, r["xs" + r.l] = o || "", a > 0 ? (r.data["xn" + a] = e + i, r.rxp["xn" + a] = n, r["xn" + a] = e, r.plugin || (r.xfirst = new _t(r, "xn" + a, e, i, r.xfirst || r, 0, r.n, n, r.pr), r.xfirst.xs0 = 0), r) : (r.data = { s: e + i }, r.rxp = {}, r.s = e, r.c = i, r.r = n, r)) : (r["xs" + a] += e + (o || ""), r) }; var Ct = function(t, e) { e = e || {}, this.p = e.prefix ? Z(t) || t : t, h[t] = h[this.p] = this, this.format = e.formatter || yt(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.pr = e.priority || 0 },
                    wt = X._registerComplexSpecialProp = function(t, e, i) { "object" != typeof e && (e = { parser: i }); var o, n = t.split(","),
                            s = e.defaultValue; for (i = i || [s], o = 0; o < n.length; o++) e.prefix = 0 === o && e.prefix, e.defaultValue = i[o] || s, new Ct(n[o], e) },
                    At = X._registerPluginProp = function(t) { if (!h[t]) { var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
                            wt(t, { parser: function(t, i, o, n, s, r, l) { var c = a.com.greensock.plugins[e]; return c ? (c._cssRegister(), h[o].parse(t, i, o, n, s, r, l)) : (q(), s) } }) } };
                (l = Ct.prototype).parseComplex = function(t, e, i, o, n, s) { var r, a, h, l, c, d, u = this.keyword; if (this.multi && (L.test(i) || L.test(e) ? (a = e.replace(L, "|").split("|"), h = i.replace(L, "|").split("|")) : u && (a = [e], h = [i])), h) { for (l = h.length > a.length ? h.length : a.length, r = 0; r < l; r++) e = a[r] = a[r] || this.dflt, i = h[r] = h[r] || this.dflt, u && (c = e.indexOf(u)) !== (d = i.indexOf(u)) && (-1 === d ? a[r] = a[r].split(u).join("") : -1 === c && (a[r] += " " + u));
                        e = a.join(", "), i = h.join(", ") } return xt(t, this.p, e, i, this.clrs, this.dflt, o, this.pr, n, s) }, l.parse = function(t, e, i, o, s, r, a) { return this.parseComplex(t.style, this.format($(t, this.p, n, !1, this.dflt)), this.format(e), s, r) }, r.registerSpecialProp = function(t, e, i) { wt(t, { parser: function(t, o, n, s, r, a, h) { var l = new _t(t, n, 0, 0, r, 2, n, !1, i); return l.plugin = a, l.setRatio = e(t, o, s._tween, n), l }, priority: i }) }, r.useSVGTransformAttr = !0; var Tt, Pt = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                    kt = Z("transform"),
                    Mt = Y + "transform",
                    Et = Z("transformOrigin"),
                    Bt = null !== Z("perspective"),
                    It = X.Transform = function() { this.perspective = parseFloat(r.defaultTransformPerspective) || 0, this.force3D = !(!1 === r.defaultForce3D || !Bt) && (r.defaultForce3D || "auto") },
                    Dt = _gsScope.SVGElement,
                    Lt = function(t, e, i) { var o, n = U.createElementNS("http://www.w3.org/2000/svg", t),
                            s = /([a-z])([A-Z])/g; for (o in i) n.setAttributeNS(null, o.replace(s, "$1-$2").toLowerCase(), i[o]); return e.appendChild(n), n },
                    Ot = U.documentElement || {},
                    Rt = function() { var t, e, i, o = f || /Android/i.test(H) && !_gsScope.chrome; return U.createElementNS && !o && (t = Lt("svg", Ot), i = (e = Lt("rect", t, { width: 100, height: 50, x: 100 })).getBoundingClientRect().width, e.style[Et] = "50% 50%", e.style[kt] = "scaleX(0.5)", o = i === e.getBoundingClientRect().width && !(p && Bt), Ot.removeChild(t)), o }(),
                    Ft = function(t, e, i, o, n, s) { var a, h, l, c, d, u, p, m, f, y, b, g, _, v, x = t._gsTransform,
                            S = jt(t, !0);
                        x && (_ = x.xOrigin, v = x.yOrigin), (!o || (a = o.split(" ")).length < 2) && (0 === (p = t.getBBox()).x && 0 === p.y && p.width + p.height === 0 && (p = { x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0, y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0, width: 0, height: 0 }), a = [(-1 !== (e = at(e).split(" "))[0].indexOf("%") ? parseFloat(e[0]) / 100 * p.width : parseFloat(e[0])) + p.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * p.height : parseFloat(e[1])) + p.y]), i.xOrigin = c = parseFloat(a[0]), i.yOrigin = d = parseFloat(a[1]), o && S !== Nt && (u = S[0], p = S[1], m = S[2], f = S[3], y = S[4], b = S[5], (g = u * f - p * m) && (h = c * (f / g) + d * (-m / g) + (m * b - f * y) / g, l = c * (-p / g) + d * (u / g) - (u * b - p * y) / g, c = i.xOrigin = a[0] = h, d = i.yOrigin = a[1] = l)), x && (s && (i.xOffset = x.xOffset, i.yOffset = x.yOffset, x = i), n || !1 !== n && !1 !== r.defaultSmoothOrigin ? (h = c - _, l = d - v, x.xOffset += h * S[0] + l * S[2] - h, x.yOffset += h * S[1] + l * S[3] - l) : x.xOffset = x.yOffset = 0), s || t.setAttribute("data-svg-origin", a.join(" ")) },
                    Vt = function(t) { var e, i = N("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                            o = this.parentNode,
                            n = this.nextSibling,
                            s = this.style.cssText; if (Ot.appendChild(i), i.appendChild(this), this.style.display = "block", t) try { e = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Vt } catch (t) {} else this._originalGetBBox && (e = this._originalGetBBox()); return n ? o.insertBefore(this, n) : o.appendChild(this), Ot.removeChild(i), this.style.cssText = s, e },
                    Gt = function(t) { try { return t.getBBox() } catch (e) { return Vt.call(t, !0) } },
                    Ut = function(t) { return !(!Dt || !t.getCTM || t.parentNode && !t.ownerSVGElement || !Gt(t)) },
                    Nt = [1, 0, 0, 1, 0, 0],
                    jt = function(t, e) { var i, o, n, s, r, a, h = t._gsTransform || new It,
                            l = t.style; if (kt ? o = $(t, Mt, null, !0) : t.currentStyle && (o = (o = t.currentStyle.filter.match(I)) && 4 === o.length ? [o[0].substr(4), Number(o[2].substr(4)), Number(o[1].substr(4)), o[3].substr(4), h.x || 0, h.y || 0].join(",") : ""), i = !o || "none" === o || "matrix(1, 0, 0, 1, 0, 0)" === o, !kt || !(a = !Q(t) || "none" === Q(t).display) && t.parentNode || (a && (s = l.display, l.display = "block"), t.parentNode || (r = 1, Ot.appendChild(t)), i = !(o = $(t, Mt, null, !0)) || "none" === o || "matrix(1, 0, 0, 1, 0, 0)" === o, s ? l.display = s : a && Jt(l, "display"), r && Ot.removeChild(t)), (h.svg || t.getCTM && Ut(t)) && (i && -1 !== (l[kt] + "").indexOf("matrix") && (o = l[kt], i = 0), n = t.getAttribute("transform"), i && n && (o = "matrix(" + (n = t.transform.baseVal.consolidate().matrix).a + "," + n.b + "," + n.c + "," + n.d + "," + n.e + "," + n.f + ")", i = 0)), i) return Nt; for (n = (o || "").match(g) || [], St = n.length; --St > -1;) s = Number(n[St]), n[St] = (r = s - (s |= 0)) ? (1e5 * r + (r < 0 ? -.5 : .5) | 0) / 1e5 + s : s; return e && n.length > 6 ? [n[0], n[1], n[4], n[5], n[12], n[13]] : n },
                    Wt = X.getTransform = function(t, i, o, n) { if (t._gsTransform && o && !n) return t._gsTransform; var s, a, h, l, c, d, u = o ? t._gsTransform || new It : new It,
                            p = u.scaleX < 0,
                            m = Bt ? parseFloat($(t, Et, i, !1, "0 0 0").split(" ")[2]) || u.zOrigin || 0 : 0,
                            f = parseFloat(r.defaultTransformPerspective) || 0; if (u.svg = !(!t.getCTM || !Ut(t)), u.svg && (Ft(t, $(t, Et, i, !1, "50% 50%") + "", u, t.getAttribute("data-svg-origin")), Tt = r.useSVGTransformAttr || Rt), (s = jt(t)) !== Nt) { if (16 === s.length) { var y, b, g, _, v, x = s[0],
                                    S = s[1],
                                    C = s[2],
                                    w = s[3],
                                    A = s[4],
                                    T = s[5],
                                    P = s[6],
                                    k = s[7],
                                    M = s[8],
                                    E = s[9],
                                    B = s[10],
                                    I = s[12],
                                    D = s[13],
                                    L = s[14],
                                    O = s[11],
                                    R = Math.atan2(P, B);
                                u.zOrigin && (I = M * (L = -u.zOrigin) - s[12], D = E * L - s[13], L = B * L + u.zOrigin - s[14]), u.rotationX = R * F, R && (y = A * (_ = Math.cos(-R)) + M * (v = Math.sin(-R)), b = T * _ + E * v, g = P * _ + B * v, M = A * -v + M * _, E = T * -v + E * _, B = P * -v + B * _, O = k * -v + O * _, A = y, T = b, P = g), R = Math.atan2(-C, B), u.rotationY = R * F, R && (b = S * (_ = Math.cos(-R)) - E * (v = Math.sin(-R)), g = C * _ - B * v, E = S * v + E * _, B = C * v + B * _, O = w * v + O * _, x = y = x * _ - M * v, S = b, C = g), R = Math.atan2(S, x), u.rotation = R * F, R && (y = x * (_ = Math.cos(R)) + S * (v = Math.sin(R)), b = A * _ + T * v, g = M * _ + E * v, S = S * _ - x * v, T = T * _ - A * v, E = E * _ - M * v, x = y, A = b, M = g), u.rotationX && Math.abs(u.rotationX) + Math.abs(u.rotation) > 359.9 && (u.rotationX = u.rotation = 0, u.rotationY = 180 - u.rotationY), R = Math.atan2(A, T), u.scaleX = (1e5 * Math.sqrt(x * x + S * S + C * C) + .5 | 0) / 1e5, u.scaleY = (1e5 * Math.sqrt(T * T + P * P) + .5 | 0) / 1e5, u.scaleZ = (1e5 * Math.sqrt(M * M + E * E + B * B) + .5 | 0) / 1e5, x /= u.scaleX, A /= u.scaleY, S /= u.scaleX, T /= u.scaleY, Math.abs(R) > 2e-5 ? (u.skewX = R * F, A = 0, "simple" !== u.skewType && (u.scaleY *= 1 / Math.cos(R))) : u.skewX = 0, u.perspective = O ? 1 / (O < 0 ? -O : O) : 0, u.x = I, u.y = D, u.z = L, u.svg && (u.x -= u.xOrigin - (u.xOrigin * x - u.yOrigin * A), u.y -= u.yOrigin - (u.yOrigin * S - u.xOrigin * T)) } else if (!Bt || n || !s.length || u.x !== s[4] || u.y !== s[5] || !u.rotationX && !u.rotationY) { var V = s.length >= 6,
                                    G = V ? s[0] : 1,
                                    U = s[1] || 0,
                                    N = s[2] || 0,
                                    j = V ? s[3] : 1;
                                u.x = s[4] || 0, u.y = s[5] || 0, h = Math.sqrt(G * G + U * U), l = Math.sqrt(j * j + N * N), c = G || U ? Math.atan2(U, G) * F : u.rotation || 0, d = N || j ? Math.atan2(N, j) * F + c : u.skewX || 0, u.scaleX = h, u.scaleY = l, u.rotation = c, u.skewX = d, Bt && (u.rotationX = u.rotationY = u.z = 0, u.perspective = f, u.scaleZ = 1), u.svg && (u.x -= u.xOrigin - (u.xOrigin * G + u.yOrigin * N), u.y -= u.yOrigin - (u.xOrigin * U + u.yOrigin * j)) } Math.abs(u.skewX) > 90 && Math.abs(u.skewX) < 270 && (p ? (u.scaleX *= -1, u.skewX += u.rotation <= 0 ? 180 : -180, u.rotation += u.rotation <= 0 ? 180 : -180) : (u.scaleY *= -1, u.skewX += u.skewX <= 0 ? 180 : -180)), u.zOrigin = m; for (a in u) u[a] < 2e-5 && u[a] > -2e-5 && (u[a] = 0) } return o && (t._gsTransform = u, u.svg && (Tt && t.style[kt] ? e.delayedCall(.001, function() { Jt(t.style, kt) }) : !Tt && t.getAttribute("transform") && e.delayedCall(.001, function() { t.removeAttribute("transform") }))), u },
                    Xt = function(t) { var e, i, o = this.data,
                            n = -o.rotation * R,
                            s = n + o.skewX * R,
                            r = (Math.cos(n) * o.scaleX * 1e5 | 0) / 1e5,
                            a = (Math.sin(n) * o.scaleX * 1e5 | 0) / 1e5,
                            h = (Math.sin(s) * -o.scaleY * 1e5 | 0) / 1e5,
                            l = (Math.cos(s) * o.scaleY * 1e5 | 0) / 1e5,
                            c = this.t.style,
                            d = this.t.currentStyle; if (d) { i = a, a = -h, h = -i, e = d.filter, c.filter = ""; var u, p, m = this.t.offsetWidth,
                                y = this.t.offsetHeight,
                                b = "absolute" !== d.position,
                                g = "progid:DXImageTransform.Microsoft.Matrix(M11=" + r + ", M12=" + a + ", M21=" + h + ", M22=" + l,
                                _ = o.x + m * o.xPercent / 100,
                                v = o.y + y * o.yPercent / 100; if (null != o.ox && (_ += (u = (o.oxp ? m * o.ox * .01 : o.ox) - m / 2) - (u * r + (p = (o.oyp ? y * o.oy * .01 : o.oy) - y / 2) * a), v += p - (u * h + p * l)), g += b ? ", Dx=" + ((u = m / 2) - (u * r + (p = y / 2) * a) + _) + ", Dy=" + (p - (u * h + p * l) + v) + ")" : ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? c.filter = e.replace(D, g) : c.filter = g + " " + e, 0 !== t && 1 !== t || 1 === r && 0 === a && 0 === h && 1 === l && (b && -1 === g.indexOf("Dx=0, Dy=0") || C.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && c.removeAttribute("filter")), !b) { var x, w, A, T = f < 8 ? 1 : -1; for (u = o.ieOffsetX || 0, p = o.ieOffsetY || 0, o.ieOffsetX = Math.round((m - ((r < 0 ? -r : r) * m + (a < 0 ? -a : a) * y)) / 2 + _), o.ieOffsetY = Math.round((y - ((l < 0 ? -l : l) * y + (h < 0 ? -h : h) * m)) / 2 + v), St = 0; St < 4; St++) A = (i = -1 !== (x = d[w = st[St]]).indexOf("px") ? parseFloat(x) : tt(this.t, w, parseFloat(x), x.replace(S, "")) || 0) !== o[w] ? St < 2 ? -o.ieOffsetX : -o.ieOffsetY : St < 2 ? u - o.ieOffsetX : p - o.ieOffsetY, c[w] = (o[w] = Math.round(i - A * (0 === St || 2 === St ? 1 : T))) + "px" } } },
                    Ht = X.set3DTransformRatio = X.setTransformRatio = function(t) { var e, i, o, n, s, r, a, h, l, c, d, u, m, f, y, b, g, _, v, x, S, C = this.data,
                            w = this.t.style,
                            A = C.rotation,
                            T = C.rotationX,
                            P = C.rotationY,
                            k = C.scaleX,
                            M = C.scaleY,
                            E = C.scaleZ,
                            B = C.x,
                            I = C.y,
                            D = C.z,
                            L = C.svg,
                            O = C.perspective,
                            F = C.force3D,
                            V = C.skewY,
                            G = C.skewX; if (V && (G += V, A += V), !((1 !== t && 0 !== t || "auto" !== F || this.tween._totalTime !== this.tween._totalDuration && this.tween._totalTime) && F || D || O || P || T || 1 !== E) || Tt && L || !Bt) A || G || L ? (A *= R, x = G * R, S = 1e5, i = Math.cos(A) * k, s = Math.sin(A) * k, o = Math.sin(A - x) * -M, r = Math.cos(A - x) * M, x && "simple" === C.skewType && (e = Math.tan(x - V * R), o *= e = Math.sqrt(1 + e * e), r *= e, V && (e = Math.tan(V * R), i *= e = Math.sqrt(1 + e * e), s *= e)), L && (B += C.xOrigin - (C.xOrigin * i + C.yOrigin * o) + C.xOffset, I += C.yOrigin - (C.xOrigin * s + C.yOrigin * r) + C.yOffset, Tt && (C.xPercent || C.yPercent) && (y = this.t.getBBox(), B += .01 * C.xPercent * y.width, I += .01 * C.yPercent * y.height), B < (y = 1e-6) && B > -y && (B = 0), I < y && I > -y && (I = 0)), v = (i * S | 0) / S + "," + (s * S | 0) / S + "," + (o * S | 0) / S + "," + (r * S | 0) / S + "," + B + "," + I + ")", L && Tt ? this.t.setAttribute("transform", "matrix(" + v) : w[kt] = (C.xPercent || C.yPercent ? "translate(" + C.xPercent + "%," + C.yPercent + "%) matrix(" : "matrix(") + v) : w[kt] = (C.xPercent || C.yPercent ? "translate(" + C.xPercent + "%," + C.yPercent + "%) matrix(" : "matrix(") + k + ",0,0," + M + "," + B + "," + I + ")";
                        else { if (p && (k < (y = 1e-4) && k > -y && (k = E = 2e-5), M < y && M > -y && (M = E = 2e-5), !O || C.z || C.rotationX || C.rotationY || (O = 0)), A || G) A *= R, b = i = Math.cos(A), g = s = Math.sin(A), G && (A -= G * R, b = Math.cos(A), g = Math.sin(A), "simple" === C.skewType && (e = Math.tan((G - V) * R), b *= e = Math.sqrt(1 + e * e), g *= e, C.skewY && (e = Math.tan(V * R), i *= e = Math.sqrt(1 + e * e), s *= e))), o = -g, r = b;
                            else { if (!(P || T || 1 !== E || O || L)) return void(w[kt] = (C.xPercent || C.yPercent ? "translate(" + C.xPercent + "%," + C.yPercent + "%) translate3d(" : "translate3d(") + B + "px," + I + "px," + D + "px)" + (1 !== k || 1 !== M ? " scale(" + k + "," + M + ")" : ""));
                                i = r = 1, o = s = 0 } c = 1, n = a = h = l = d = u = 0, m = O ? -1 / O : 0, f = C.zOrigin, y = 1e-6, ",", "0", (A = P * R) && (b = Math.cos(A), h = -(g = Math.sin(A)), d = m * -g, n = i * g, a = s * g, c = b, m *= b, i *= b, s *= b), (A = T * R) && (e = o * (b = Math.cos(A)) + n * (g = Math.sin(A)), _ = r * b + a * g, l = c * g, u = m * g, n = o * -g + n * b, a = r * -g + a * b, c *= b, m *= b, o = e, r = _), 1 !== E && (n *= E, a *= E, c *= E, m *= E), 1 !== M && (o *= M, r *= M, l *= M, u *= M), 1 !== k && (i *= k, s *= k, h *= k, d *= k), (f || L) && (f && (B += n * -f, I += a * -f, D += c * -f + f), L && (B += C.xOrigin - (C.xOrigin * i + C.yOrigin * o) + C.xOffset, I += C.yOrigin - (C.xOrigin * s + C.yOrigin * r) + C.yOffset), B < y && B > -y && (B = "0"), I < y && I > -y && (I = "0"), D < y && D > -y && (D = 0)), v = C.xPercent || C.yPercent ? "translate(" + C.xPercent + "%," + C.yPercent + "%) matrix3d(" : "matrix3d(", v += (i < y && i > -y ? "0" : i) + "," + (s < y && s > -y ? "0" : s) + "," + (h < y && h > -y ? "0" : h), v += "," + (d < y && d > -y ? "0" : d) + "," + (o < y && o > -y ? "0" : o) + "," + (r < y && r > -y ? "0" : r), T || P || 1 !== E ? (v += "," + (l < y && l > -y ? "0" : l) + "," + (u < y && u > -y ? "0" : u) + "," + (n < y && n > -y ? "0" : n), v += "," + (a < y && a > -y ? "0" : a) + "," + (c < y && c > -y ? "0" : c) + "," + (m < y && m > -y ? "0" : m) + ",") : v += ",0,0,0,0,1,0,", v += B + "," + I + "," + D + "," + (O ? 1 + -D / O : 1) + ")", w[kt] = v } };
                (l = It.prototype).x = l.y = l.z = l.skewX = l.skewY = l.rotation = l.rotationX = l.rotationY = l.zOrigin = l.xPercent = l.yPercent = l.xOffset = l.yOffset = 0, l.scaleX = l.scaleY = l.scaleZ = 1, wt("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", { parser: function(t, e, i, o, s, a, h) { if (o._lastParsedTransform === h) return s;
                        o._lastParsedTransform = h; var l, c = h.scale && "function" == typeof h.scale ? h.scale : 0; "function" == typeof h[i] && (l = h[i], h[i] = e), c && (h.scale = c(b, t)); var d, u, p, m, f, g, _, v, x, S = t._gsTransform,
                            C = t.style,
                            w = Pt.length,
                            A = h,
                            T = {},
                            P = Wt(t, n, !0, A.parseTransform),
                            k = A.transform && ("function" == typeof A.transform ? A.transform(b, y) : A.transform); if (P.skewType = A.skewType || P.skewType || r.defaultSkewType, o._transform = P, k && "string" == typeof k && kt)(u = j.style)[kt] = k, u.display = "block", u.position = "absolute", -1 !== k.indexOf("%") && (u.width = $(t, "width"), u.height = $(t, "height")), U.body.appendChild(j), d = Wt(j, null, !1), "simple" === P.skewType && (d.scaleY *= Math.cos(d.skewX * R)), P.svg && (g = P.xOrigin, _ = P.yOrigin, d.x -= P.xOffset, d.y -= P.yOffset, (A.transformOrigin || A.svgOrigin) && (k = {}, Ft(t, at(A.transformOrigin), k, A.svgOrigin, A.smoothOrigin, !0), g = k.xOrigin, _ = k.yOrigin, d.x -= k.xOffset - P.xOffset, d.y -= k.yOffset - P.yOffset), (g || _) && (v = jt(j, !0), d.x -= g - (g * v[0] + _ * v[2]), d.y -= _ - (g * v[1] + _ * v[3]))), U.body.removeChild(j), d.perspective || (d.perspective = P.perspective), null != A.xPercent && (d.xPercent = lt(A.xPercent, P.xPercent)), null != A.yPercent && (d.yPercent = lt(A.yPercent, P.yPercent));
                        else if ("object" == typeof A) { if (d = { scaleX: lt(null != A.scaleX ? A.scaleX : A.scale, P.scaleX), scaleY: lt(null != A.scaleY ? A.scaleY : A.scale, P.scaleY), scaleZ: lt(A.scaleZ, P.scaleZ), x: lt(A.x, P.x), y: lt(A.y, P.y), z: lt(A.z, P.z), xPercent: lt(A.xPercent, P.xPercent), yPercent: lt(A.yPercent, P.yPercent), perspective: lt(A.transformPerspective, P.perspective) }, null != (f = A.directionalRotation))
                                if ("object" == typeof f)
                                    for (u in f) A[u] = f[u];
                                else A.rotation = f; "string" == typeof A.x && -1 !== A.x.indexOf("%") && (d.x = 0, d.xPercent = lt(A.x, P.xPercent)), "string" == typeof A.y && -1 !== A.y.indexOf("%") && (d.y = 0, d.yPercent = lt(A.y, P.yPercent)), d.rotation = ct("rotation" in A ? A.rotation : "shortRotation" in A ? A.shortRotation + "_short" : "rotationZ" in A ? A.rotationZ : P.rotation, P.rotation, "rotation", T), Bt && (d.rotationX = ct("rotationX" in A ? A.rotationX : "shortRotationX" in A ? A.shortRotationX + "_short" : P.rotationX || 0, P.rotationX, "rotationX", T), d.rotationY = ct("rotationY" in A ? A.rotationY : "shortRotationY" in A ? A.shortRotationY + "_short" : P.rotationY || 0, P.rotationY, "rotationY", T)), d.skewX = ct(A.skewX, P.skewX), d.skewY = ct(A.skewY, P.skewY) } for (Bt && null != A.force3D && (P.force3D = A.force3D, m = !0), (p = P.force3D || P.z || P.rotationX || P.rotationY || d.z || d.rotationX || d.rotationY || d.perspective) || null == A.scale || (d.scaleZ = 1); --w > -1;)((k = d[x = Pt[w]] - P[x]) > 1e-6 || k < -1e-6 || null != A[x] || null != V[x]) && (m = !0, s = new _t(P, x, P[x], k, s), x in T && (s.e = T[x]), s.xs0 = 0, s.plugin = a, o._overwriteProps.push(s.n)); return k = A.transformOrigin, P.svg && (k || A.svgOrigin) && (g = P.xOffset, _ = P.yOffset, Ft(t, at(k), d, A.svgOrigin, A.smoothOrigin), s = vt(P, "xOrigin", (S ? P : d).xOrigin, d.xOrigin, s, "transformOrigin"), s = vt(P, "yOrigin", (S ? P : d).yOrigin, d.yOrigin, s, "transformOrigin"), g === P.xOffset && _ === P.yOffset || (s = vt(P, "xOffset", S ? g : P.xOffset, P.xOffset, s, "transformOrigin"), s = vt(P, "yOffset", S ? _ : P.yOffset, P.yOffset, s, "transformOrigin")), k = "0px 0px"), (k || Bt && p && P.zOrigin) && (kt ? (m = !0, x = Et, k = (k || $(t, x, n, !1, "50% 50%")) + "", (s = new _t(C, x, 0, 0, s, -1, "transformOrigin")).b = C[x], s.plugin = a, Bt ? (u = P.zOrigin, k = k.split(" "), P.zOrigin = (k.length > 2 && (0 === u || "0px" !== k[2]) ? parseFloat(k[2]) : u) || 0, s.xs0 = s.e = k[0] + " " + (k[1] || "50%") + " 0px", (s = new _t(P, "zOrigin", 0, 0, s, -1, s.n)).b = u, s.xs0 = s.e = P.zOrigin) : s.xs0 = s.e = k) : at(k + "", P)), m && (o._transformType = P.svg && Tt || !p && 3 !== this._transformType ? 2 : 3), l && (h[i] = l), c && (h.scale = c), s }, prefix: !0 }), wt("boxShadow", { defaultValue: "0px 0px 0px 0px #999", prefix: !0, color: !0, multi: !0, keyword: "inset" }), wt("borderRadius", { defaultValue: "0px", parser: function(t, e, i, s, r, a) { e = this.format(e); var h, l, c, d, u, p, m, f, y, b, g, _, v, x, S, C, w = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                            A = t.style; for (y = parseFloat(t.offsetWidth), b = parseFloat(t.offsetHeight), h = e.split(" "), l = 0; l < w.length; l++) this.p.indexOf("border") && (w[l] = Z(w[l])), -1 !== (u = d = $(t, w[l], n, !1, "0px")).indexOf(" ") && (u = (d = u.split(" "))[0], d = d[1]), p = c = h[l], m = parseFloat(u), _ = u.substr((m + "").length), (v = "=" === p.charAt(1)) ? (f = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), f *= parseFloat(p), g = p.substr((f + "").length - (f < 0 ? 1 : 0)) || "") : (f = parseFloat(p), g = p.substr((f + "").length)), "" === g && (g = o[i] || _), g !== _ && (x = tt(t, "borderLeft", m, _), S = tt(t, "borderTop", m, _), "%" === g ? (u = x / y * 100 + "%", d = S / b * 100 + "%") : "em" === g ? (u = x / (C = tt(t, "borderLeft", 1, "em")) + "em", d = S / C + "em") : (u = x + "px", d = S + "px"), v && (p = parseFloat(u) + f + g, c = parseFloat(d) + f + g)), r = xt(A, w[l], u + " " + d, p + " " + c, !1, "0px", r); return r }, prefix: !0, formatter: yt("0px 0px 0px 0px", !1, !0) }), wt("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", { defaultValue: "0px", parser: function(t, e, i, o, s, r) { return xt(t.style, i, this.format($(t, i, n, !1, "0px 0px")), this.format(e), !1, "0px", s) }, prefix: !0, formatter: yt("0px 0px", !1, !0) }), wt("backgroundPosition", { defaultValue: "0 0", parser: function(t, e, i, o, s, r) { var a, h, l, c, d, u, p = "background-position",
                            m = n || Q(t, null),
                            y = this.format((m ? f ? m.getPropertyValue(p + "-x") + " " + m.getPropertyValue(p + "-y") : m.getPropertyValue(p) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                            b = this.format(e); if (-1 !== y.indexOf("%") != (-1 !== b.indexOf("%")) && b.split(",").length < 2 && (u = $(t, "backgroundImage").replace(M, "")) && "none" !== u) { for (a = y.split(" "), h = b.split(" "), W.setAttribute("src", u), l = 2; --l > -1;)(c = -1 !== (y = a[l]).indexOf("%")) !== (-1 !== h[l].indexOf("%")) && (d = 0 === l ? t.offsetWidth - W.width : t.offsetHeight - W.height, a[l] = c ? parseFloat(y) / 100 * d + "px" : parseFloat(y) / d * 100 + "%");
                            y = a.join(" ") } return this.parseComplex(t.style, y, b, s, r) }, formatter: at }), wt("backgroundSize", { defaultValue: "0 0", formatter: function(t) { return "co" === (t += "").substr(0, 2) ? t : at(-1 === t.indexOf(" ") ? t + " " + t : t) } }), wt("perspective", { defaultValue: "0px", prefix: !0 }), wt("perspectiveOrigin", { defaultValue: "50% 50%", prefix: !0 }), wt("transformStyle", { prefix: !0 }), wt("backfaceVisibility", { prefix: !0 }), wt("userSelect", { prefix: !0 }), wt("margin", { parser: bt("marginTop,marginRight,marginBottom,marginLeft") }), wt("padding", { parser: bt("paddingTop,paddingRight,paddingBottom,paddingLeft") }), wt("clip", { defaultValue: "rect(0px,0px,0px,0px)", parser: function(t, e, i, o, s, r) { var a, h, l; return f < 9 ? (h = t.currentStyle, l = f < 8 ? " " : ",", a = "rect(" + h.clipTop + l + h.clipRight + l + h.clipBottom + l + h.clipLeft + ")", e = this.format(e).split(",").join(l)) : (a = this.format($(t, this.p, n, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, a, e, s, r) } }), wt("textShadow", { defaultValue: "0px 0px 0px #999", color: !0, multi: !0 }), wt("autoRound,strictUnits", { parser: function(t, e, i, o, n) { return n } }), wt("border", { defaultValue: "0px solid #000", parser: function(t, e, i, o, s, r) { var a = $(t, "borderTopWidth", n, !1, "0px"),
                            h = this.format(e).split(" "),
                            l = h[0].replace(S, ""); return "px" !== l && (a = parseFloat(a) / tt(t, "borderTopWidth", 1, l) + l), this.parseComplex(t.style, this.format(a + " " + $(t, "borderTopStyle", n, !1, "solid") + " " + $(t, "borderTopColor", n, !1, "#000")), h.join(" "), s, r) }, color: !0, formatter: function(t) { var e = t.split(" "); return e[0] + " " + (e[1] || "solid") + " " + (t.match(ft) || ["#000"])[0] } }), wt("borderWidth", { parser: bt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth") }), wt("float,cssFloat,styleFloat", { parser: function(t, e, i, o, n, s) { var r = t.style,
                            a = "cssFloat" in r ? "cssFloat" : "styleFloat"; return new _t(r, a, 0, 0, n, -1, i, !1, 0, r[a], e) } }); var zt = function(t) { var e, i = this.t,
                        o = i.filter || $(this.data, "filter") || "",
                        n = this.s + this.c * t | 0;
                    100 === n && (-1 === o.indexOf("atrix(") && -1 === o.indexOf("radient(") && -1 === o.indexOf("oader(") ? (i.removeAttribute("filter"), e = !$(this.data, "filter")) : (i.filter = o.replace(A, ""), e = !0)), e || (this.xn1 && (i.filter = o = o || "alpha(opacity=" + n + ")"), -1 === o.indexOf("pacity") ? 0 === n && this.xn1 || (i.filter = o + " alpha(opacity=" + n + ")") : i.filter = o.replace(C, "opacity=" + n)) };
                wt("opacity,alpha,autoAlpha", { defaultValue: "1", parser: function(t, e, i, o, s, r) { var a = parseFloat($(t, "opacity", n, !1, "1")),
                            h = t.style,
                            l = "autoAlpha" === i; return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + a), l && 1 === a && "hidden" === $(t, "visibility", n) && 0 !== e && (a = 0), z ? s = new _t(h, "opacity", a, e - a, s) : ((s = new _t(h, "opacity", 100 * a, 100 * (e - a), s)).xn1 = l ? 1 : 0, h.zoom = 1, s.type = 2, s.b = "alpha(opacity=" + s.s + ")", s.e = "alpha(opacity=" + (s.s + s.c) + ")", s.data = t, s.plugin = r, s.setRatio = zt), l && ((s = new _t(h, "visibility", 0, 0, s, -1, null, !1, 0, 0 !== a ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit")).xs0 = "inherit", o._overwriteProps.push(s.n), o._overwriteProps.push(i)), s } }); var Jt = function(t, e) { e && (t.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), t.removeProperty(e.replace(P, "-$1").toLowerCase())) : t.removeAttribute(e)) },
                    qt = function(t) { if (this.t._gsClassPT = this, 1 === t || 0 === t) { this.t.setAttribute("class", 0 === t ? this.b : this.e); for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Jt(i, e.p), e = e._next;
                            1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null) } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e) };
                wt("className", { parser: function(t, e, o, s, r, a, h) { var l, c, d, u, p, m = t.getAttribute("class") || "",
                            f = t.style.cssText; if (r = s._classNamePT = new _t(t, o, 0, 0, r, 2), r.setRatio = qt, r.pr = -11, i = !0, r.b = m, c = it(t, n), d = t._gsClassPT) { for (u = {}, p = d.data; p;) u[p.p] = 1, p = p._next;
                            d.setRatio(1) } return t._gsClassPT = r, r.e = "=" !== e.charAt(1) ? e : m.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), t.setAttribute("class", r.e), l = ot(t, c, it(t), h, u), t.setAttribute("class", m), r.data = l.firstMPT, t.style.cssText = f, r = r.xfirst = s.parse(t, l.difs, r, a) } }); var Yt = function(t) { if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) { var e, i, o, n, s, r = this.t.style,
                            a = h.transform.parse; if ("all" === this.e) r.cssText = "", n = !0;
                        else
                            for (o = (e = this.e.split(" ").join("").split(",")).length; --o > -1;) i = e[o], h[i] && (h[i].parse === a ? n = !0 : i = "transformOrigin" === i ? Et : h[i].p), Jt(r, i);
                        n && (Jt(r, kt), (s = this.t._gsTransform) && (s.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform)) } }; for (wt("clearProps", { parser: function(t, e, o, n, s) { return s = new _t(t, o, 0, 0, s, 2), s.setRatio = Yt, s.e = e, s.pr = -10, s.data = n._tween, i = !0, s } }), l = "bezier,throwProps,physicsProps,physics2D".split(","), St = l.length; St--;) At(l[St]);
                (l = r.prototype)._firstPT = l._lastParsedTransform = l._transform = null, l._onInitTween = function(t, e, a, l) { if (!t.nodeType) return !1;
                    this._target = y = t, this._tween = a, this._vars = e, b = l, c = e.autoRound, i = !1, o = e.suffixMap || r.suffixMap, n = Q(t, ""), s = this._overwriteProps; var p, f, g, _, v, x, S, C, A, T = t.style; if (d && "" === T.zIndex && ("auto" !== (p = $(t, "zIndex", n)) && "" !== p || this._addLazySet(T, "zIndex", 0)), "string" == typeof e && (_ = T.cssText, p = it(t, n), T.cssText = _ + ";" + e, p = ot(t, p, it(t)).difs, !z && w.test(e) && (p.opacity = parseFloat(RegExp.$1)), e = p, T.cssText = _), e.className ? this._firstPT = f = h.className.parse(t, e.className, "className", this, null, null, e) : this._firstPT = f = this.parse(t, e, null), this._transformType) { for (A = 3 === this._transformType, kt ? u && (d = !0, "" === T.zIndex && ("auto" !== (S = $(t, "zIndex", n)) && "" !== S || this._addLazySet(T, "zIndex", 0)), m && this._addLazySet(T, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (A ? "visible" : "hidden"))) : T.zoom = 1, g = f; g && g._next;) g = g._next;
                        C = new _t(t, "transform", 0, 0, null, 2), this._linkCSSP(C, null, g), C.setRatio = kt ? Ht : Xt, C.data = this._transform || Wt(t, n, !0), C.tween = a, C.pr = -1, s.pop() } if (i) { for (; f;) { for (x = f._next, g = _; g && g.pr > f.pr;) g = g._next;
                            (f._prev = g ? g._prev : v) ? f._prev._next = f: _ = f, (f._next = g) ? g._prev = f : v = f, f = x } this._firstPT = _ } return !0 }, l.parse = function(t, e, i, s) { var r, a, l, d, u, p, m, f, g, _, v = t.style; for (r in e) { if ("function" == typeof(p = e[r]) && (p = p(b, y)), a = h[r]) i = a.parse(t, p, r, this, i, s, e);
                        else { if ("--" === r.substr(0, 2)) { this._tween._propLookup[r] = this._addTween.call(this._tween, t.style, "setProperty", Q(t).getPropertyValue(r) + "", p + "", r, !1, r); continue } u = $(t, r, n) + "", g = "string" == typeof p, "color" === r || "fill" === r || "stroke" === r || -1 !== r.indexOf("Color") || g && T.test(p) ? (g || (p = ((p = pt(p)).length > 3 ? "rgba(" : "rgb(") + p.join(",") + ")"), i = xt(v, r, u, p, !0, "transparent", i, 0, s)) : g && O.test(p) ? i = xt(v, r, u, p, !0, null, i, 0, s) : (m = (l = parseFloat(u)) || 0 === l ? u.substr((l + "").length) : "", "" !== u && "auto" !== u || ("width" === r || "height" === r ? (l = rt(t, r, n), m = "px") : "left" === r || "top" === r ? (l = et(t, r, n), m = "px") : (l = "opacity" !== r ? 0 : 1, m = "")), (_ = g && "=" === p.charAt(1)) ? (d = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), d *= parseFloat(p), f = p.replace(S, "")) : (d = parseFloat(p), f = g ? p.replace(S, "") : ""), "" === f && (f = r in o ? o[r] : m), p = d || 0 === d ? (_ ? d + l : d) + f : e[r], m !== f && ("" === f && "lineHeight" !== r || (d || 0 === d) && l && (l = tt(t, r, l, m), "%" === f ? (l /= tt(t, r, 100, "%") / 100, !0 !== e.strictUnits && (u = l + "%")) : "em" === f || "rem" === f || "vw" === f || "vh" === f ? l /= tt(t, r, 1, f) : "px" !== f && (d = tt(t, r, d, f), f = "px"), _ && (d || 0 === d) && (p = d + l + f))), _ && (d += l), !l && 0 !== l || !d && 0 !== d ? void 0 !== v[r] && (p || p + "" != "NaN" && null != p) ? (i = new _t(v, r, d || l || 0, 0, i, -1, r, !1, 0, u, p)).xs0 = "none" !== p || "display" !== r && -1 === r.indexOf("Style") ? p : u : q(e[r]) : (i = new _t(v, r, l, d - l, i, 0, r, !1 !== c && ("px" === f || "zIndex" === r), 0, u, p)).xs0 = f) } s && i && !i.plugin && (i.plugin = s) } return i }, l.setRatio = function(t) { var e, i, o, n = this._firstPT; if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                        if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || -1e-6 === this._tween._rawPrevTime)
                            for (; n;) { if (e = n.c * t + n.s, n.r ? e = n.r(e) : e < 1e-6 && e > -1e-6 && (e = 0), n.type)
                                    if (1 === n.type)
                                        if (2 === (o = n.l)) n.t[n.p] = n.xs0 + e + n.xs1 + n.xn1 + n.xs2;
                                        else if (3 === o) n.t[n.p] = n.xs0 + e + n.xs1 + n.xn1 + n.xs2 + n.xn2 + n.xs3;
                                else if (4 === o) n.t[n.p] = n.xs0 + e + n.xs1 + n.xn1 + n.xs2 + n.xn2 + n.xs3 + n.xn3 + n.xs4;
                                else if (5 === o) n.t[n.p] = n.xs0 + e + n.xs1 + n.xn1 + n.xs2 + n.xn2 + n.xs3 + n.xn3 + n.xs4 + n.xn4 + n.xs5;
                                else { for (i = n.xs0 + e + n.xs1, o = 1; o < n.l; o++) i += n["xn" + o] + n["xs" + (o + 1)];
                                    n.t[n.p] = i } else -1 === n.type ? n.t[n.p] = n.xs0 : n.setRatio && n.setRatio(t);
                                else n.t[n.p] = e + n.xs0;
                                n = n._next } else
                                for (; n;) 2 !== n.type ? n.t[n.p] = n.b : n.setRatio(t), n = n._next;
                        else
                            for (; n;) { if (2 !== n.type)
                                    if (n.r && -1 !== n.type)
                                        if (e = n.r(n.s + n.c), n.type) { if (1 === n.type) { for (o = n.l, i = n.xs0 + e + n.xs1, o = 1; o < n.l; o++) i += n["xn" + o] + n["xs" + (o + 1)];
                                                n.t[n.p] = i } } else n.t[n.p] = e + n.xs0;
                                else n.t[n.p] = n.e;
                                else n.setRatio(t);
                                n = n._next } }, l._enableTransforms = function(t) { this._transform = this._transform || Wt(this._target, n, !0), this._transformType = this._transform.svg && Tt || !t && 3 !== this._transformType ? 2 : 3 }; var Kt = function(t) { this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0) };
                l._addLazySet = function(t, e, i) { var o = this._firstPT = new _t(t, e, 0, 0, this._firstPT, 2);
                    o.e = i, o.setRatio = Kt, o.data = this }, l._linkCSSP = function(t, e, i, o) { return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, o = !0), i ? i._next = t : o || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t }, l._mod = function(t) { for (var e = this._firstPT; e;) "function" == typeof t[e.p] && (e.r = t[e.p]), e = e._next }, l._kill = function(e) { var i, o, n, s = e; if (e.autoAlpha || e.alpha) { s = {}; for (o in e) s[o] = e[o];
                        s.opacity = 1, s.autoAlpha && (s.visibility = 1) } for (e.className && (i = this._classNamePT) && ((n = i.xfirst) && n._prev ? this._linkCSSP(n._prev, i._next, n._prev._prev) : n === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, n._prev), this._classNamePT = null), i = this._firstPT; i;) i.plugin && i.plugin !== o && i.plugin._kill && (i.plugin._kill(e), o = i.plugin), i = i._next; return t.prototype._kill.call(this, s) }; var Zt = function(t, e, i) { var o, n, s, r; if (t.slice)
                        for (n = t.length; --n > -1;) Zt(t[n], e, i);
                    else
                        for (n = (o = t.childNodes).length; --n > -1;) r = (s = o[n]).type, s.style && (e.push(it(s)), i && i.push(s)), 1 !== r && 9 !== r && 11 !== r || !s.childNodes.length || Zt(s, e, i) }; return r.cascadeTo = function(t, i, o) { var n, s, r, a, h = e.to(t, i, o),
                        l = [h],
                        c = [],
                        d = [],
                        u = [],
                        p = e._internals.reservedProps; for (t = h._targets || h.target, Zt(t, c, u), h.render(i, !0, !0), Zt(t, d), h.render(0, !0, !0), h._enabled(!0), n = u.length; --n > -1;)
                        if ((s = ot(u[n], c[n], d[n])).firstMPT) { s = s.difs; for (r in o) p[r] && (s[r] = o[r]);
                            a = {}; for (r in s) a[r] = c[n][r];
                            l.push(e.fromTo(u[n], i, a, s)) } return l }, t.activate([r]), r }, !0),
            function() { var t = function(t) { var e = t < 1 ? Math.pow(10, (t + "").length - 2) : 1; return function(i) { return (Math.round(i / t) * t * e | 0) / e } },
                    e = function(t, e) { for (; t;) t.f || t.blob || (t.m = e || Math.round), t = t._next },
                    i = _gsScope._gsDefine.plugin({ propName: "roundProps", version: "1.7.0", priority: -1, API: 2, init: function(t, e, i) { return this._tween = i, !0 } }).prototype;
                i._onInitAllProps = function() { var i, o, n, s, r = this._tween,
                        a = r.vars.roundProps,
                        h = {},
                        l = r._propLookup.roundProps; if ("object" != typeof a || a.push)
                        for ("string" == typeof a && (a = a.split(",")), n = a.length; --n > -1;) h[a[n]] = Math.round;
                    else
                        for (s in a) h[s] = t(a[s]); for (s in h)
                        for (i = r._firstPT; i;) o = i._next, i.pg ? i.t._mod(h) : i.n === s && (2 === i.f && i.t ? e(i.t._firstPT, h[s]) : (this._add(i.t, s, i.s, i.c, h[s]), o && (o._prev = i._prev), i._prev ? i._prev._next = o : r._firstPT === i && (r._firstPT = o), i._next = i._prev = null, r._propLookup[s] = l)), i = o; return !1 }, i._add = function(t, e, i, o, n) { this._addTween(t, e, i, i + o, e, n || Math.round), this._overwriteProps.push(e) } }(), _gsScope._gsDefine.plugin({ propName: "attr", API: 2, version: "0.6.1", init: function(t, e, i, o) { var n, s; if ("function" != typeof t.setAttribute) return !1; for (n in e) "function" == typeof(s = e[n]) && (s = s(o, t)), this._addTween(t, "setAttribute", t.getAttribute(n) + "", s + "", n, !1, n), this._overwriteProps.push(n); return !0 } }), _gsScope._gsDefine.plugin({ propName: "directionalRotation", version: "0.3.1", API: 2, init: function(t, e, i, o) { "object" != typeof e && (e = { rotation: e }), this.finals = {}; var n, s, r, a, h, l, c = !0 === e.useRadians ? 2 * Math.PI : 360; for (n in e) "useRadians" !== n && ("function" == typeof(a = e[n]) && (a = a(o, t)), s = (l = (a + "").split("_"))[0], r = parseFloat("function" != typeof t[n] ? t[n] : t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]()), h = (a = this.finals[n] = "string" == typeof s && "=" === s.charAt(1) ? r + parseInt(s.charAt(0) + "1", 10) * Number(s.substr(2)) : Number(s) || 0) - r, l.length && (-1 !== (s = l.join("_")).indexOf("short") && (h %= c) !== h % (c / 2) && (h = h < 0 ? h + c : h - c), -1 !== s.indexOf("_cw") && h < 0 ? h = (h + 9999999999 * c) % c - (h / c | 0) * c : -1 !== s.indexOf("ccw") && h > 0 && (h = (h - 9999999999 * c) % c - (h / c | 0) * c)), (h > 1e-6 || h < -1e-6) && (this._addTween(t, n, r, r + h, n), this._overwriteProps.push(n))); return !0 }, set: function(t) { var e; if (1 !== t) this._super.setRatio.call(this, t);
                    else
                        for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next } })._autoCSS = !0, _gsScope._gsDefine("easing.Back", ["easing.Ease"], function(t) { var e, i, o, n, s = _gsScope.GreenSockGlobals || _gsScope,
                    r = s.com.greensock,
                    a = 2 * Math.PI,
                    h = Math.PI / 2,
                    l = r._class,
                    c = function(e, i) { var o = l("easing." + e, function() {}, !0),
                            n = o.prototype = new t; return n.constructor = o, n.getRatio = i, o },
                    d = t.register || function() {},
                    u = function(t, e, i, o, n) { var s = l("easing." + t, { easeOut: new e, easeIn: new i, easeInOut: new o }, !0); return d(s, t), s },
                    p = function(t, e, i) { this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t) },
                    m = function(e, i) { var o = l("easing." + e, function(t) { this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1 }, !0),
                            n = o.prototype = new t; return n.constructor = o, n.getRatio = i, n.config = function(t) { return new o(t) }, o },
                    f = u("Back", m("BackOut", function(t) { return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1 }), m("BackIn", function(t) { return t * t * ((this._p1 + 1) * t - this._p1) }), m("BackInOut", function(t) { return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2) })),
                    y = l("easing.SlowMo", function(t, e, i) { e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = !0 === i }, !0),
                    b = y.prototype = new t; return b.constructor = y, b.getRatio = function(t) { var e = t + (.5 - t) * this._p; return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 === t ? 0 : 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e }, y.ease = new y(.7, .7), b.config = y.config = function(t, e, i) { return new y(t, e, i) }, e = l("easing.SteppedEase", function(t, e) { t = t || 1, this._p1 = 1 / t, this._p2 = t + (e ? 0 : 1), this._p3 = e ? 1 : 0 }, !0), b = e.prototype = new t, b.constructor = e, b.getRatio = function(t) { return t < 0 ? t = 0 : t >= 1 && (t = .999999999), ((this._p2 * t | 0) + this._p3) * this._p1 }, b.config = e.config = function(t, i) { return new e(t, i) }, i = l("easing.ExpoScaleEase", function(t, e, i) { this._p1 = Math.log(e / t), this._p2 = e - t, this._p3 = t, this._ease = i }, !0), b = i.prototype = new t, b.constructor = i, b.getRatio = function(t) { return this._ease && (t = this._ease.getRatio(t)), (this._p3 * Math.exp(this._p1 * t) - this._p3) / this._p2 }, b.config = i.config = function(t, e, o) { return new i(t, e, o) }, o = l("easing.RoughEase", function(e) { for (var i, o, n, s, r, a, h = (e = e || {}).taper || "none", l = [], c = 0, d = 0 | (e.points || 20), u = d, m = !1 !== e.randomize, f = !0 === e.clamp, y = e.template instanceof t ? e.template : null, b = "number" == typeof e.strength ? .4 * e.strength : .4; --u > -1;) i = m ? Math.random() : 1 / d * u, o = y ? y.getRatio(i) : i, n = "none" === h ? b : "out" === h ? (s = 1 - i) * s * b : "in" === h ? i * i * b : i < .5 ? (s = 2 * i) * s * .5 * b : (s = 2 * (1 - i)) * s * .5 * b, m ? o += Math.random() * n - .5 * n : u % 2 ? o += .5 * n : o -= .5 * n, f && (o > 1 ? o = 1 : o < 0 && (o = 0)), l[c++] = { x: i, y: o }; for (l.sort(function(t, e) { return t.x - e.x }), a = new p(1, 1, null), u = d; --u > -1;) r = l[u], a = new p(r.x, r.y, a);
                    this._prev = new p(0, 0, 0 !== a.t ? a : a.next) }, !0), b = o.prototype = new t, b.constructor = o, b.getRatio = function(t) { var e = this._prev; if (t > e.t) { for (; e.next && t >= e.t;) e = e.next;
                        e = e.prev } else
                        for (; e.prev && t <= e.t;) e = e.prev; return this._prev = e, e.v + (t - e.t) / e.gap * e.c }, b.config = function(t) { return new o(t) }, o.ease = new o, u("Bounce", c("BounceOut", function(t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }), c("BounceIn", function(t) { return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375) }), c("BounceInOut", function(t) { var e = t < .5; return (t = e ? 1 - 2 * t : 2 * t - 1) < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5 })), u("Circ", c("CircOut", function(t) { return Math.sqrt(1 - (t -= 1) * t) }), c("CircIn", function(t) { return -(Math.sqrt(1 - t * t) - 1) }), c("CircInOut", function(t) { return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) })), n = function(e, i, o) { var n = l("easing." + e, function(t, e) { this._p1 = t >= 1 ? t : 1, this._p2 = (e || o) / (t < 1 ? t : 1), this._p3 = this._p2 / a * (Math.asin(1 / this._p1) || 0), this._p2 = a / this._p2 }, !0),
                        s = n.prototype = new t; return s.constructor = n, s.getRatio = i, s.config = function(t, e) { return new n(t, e) }, n }, u("Elastic", n("ElasticOut", function(t) { return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1 }, .3), n("ElasticIn", function(t) { return -this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) }, .3), n("ElasticInOut", function(t) { return (t *= 2) < 1 ? this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * -.5 : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1 }, .45)), u("Expo", c("ExpoOut", function(t) { return 1 - Math.pow(2, -10 * t) }), c("ExpoIn", function(t) { return Math.pow(2, 10 * (t - 1)) - .001 }), c("ExpoInOut", function(t) { return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1))) })), u("Sine", c("SineOut", function(t) { return Math.sin(t * h) }), c("SineIn", function(t) { return 1 - Math.cos(t * h) }), c("SineInOut", function(t) { return -.5 * (Math.cos(Math.PI * t) - 1) })), l("easing.EaseLookup", { find: function(e) { return t.map[e] } }, !0), d(s.SlowMo, "SlowMo", "ease,"), d(o, "RoughEase", "ease,"), d(e, "SteppedEase", "ease,"), f }, !0) }), _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
    function(t, e) { "use strict"; var i = {},
            o = t.document,
            n = t.GreenSockGlobals = t.GreenSockGlobals || t; if (n.TweenLite) return n.TweenLite; var s, r, a, h, l, c = function(t) { var e, i = t.split("."),
                    o = n; for (e = 0; e < i.length; e++) o[i[e]] = o = o[i[e]] || {}; return o },
            d = c("com.greensock"),
            u = function(t) { var e, i = [],
                    o = t.length; for (e = 0; e !== o; i.push(t[e++])); return i },
            p = function() {},
            m = function() { var t = Object.prototype.toString,
                    e = t.call([]); return function(i) { return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e) } }(),
            f = {},
            y = function(e, o, s, r) { this.sc = f[e] ? f[e].sc : [], f[e] = this, this.gsClass = null, this.func = s; var a = [];
                this.check = function(h) { for (var l, d, u, p, m = o.length, b = m; --m > -1;)(l = f[o[m]] || new y(o[m], [])).gsClass ? (a[m] = l.gsClass, b--) : h && l.sc.push(this); if (0 === b && s) { if (d = ("com.greensock." + e).split("."), u = d.pop(), p = c(d.join("."))[u] = this.gsClass = s.apply(s, a), r)
                            if (n[u] = i[u] = p, "undefined" != typeof module && module.exports)
                                if ("TweenMax" === e) { module.exports = i.TweenMax = p; for (m in i) p[m] = i[m] } else i.TweenMax && (i.TweenMax[u] = p);
                        else "function" == typeof define && define.amd && define((t.GreenSockAMDPath ? t.GreenSockAMDPath + "/" : "") + e.split(".").pop(), [], function() { return p }); for (m = 0; m < this.sc.length; m++) this.sc[m].check() } }, this.check(!0) },
            b = t._gsDefine = function(t, e, i, o) { return new y(t, e, i, o) },
            g = d._class = function(t, e, i) { return e = e || function() {}, b(t, [], function() { return e }, i), e };
        b.globals = n; var _ = [0, 0, 1, 1],
            v = g("easing.Ease", function(t, e, i, o) { this._func = t, this._type = i || 0, this._power = o || 0, this._params = e ? _.concat(e) : _ }, !0),
            x = v.map = {},
            S = v.register = function(t, e, i, o) { for (var n, s, r, a, h = e.split(","), l = h.length, c = (i || "easeIn,easeOut,easeInOut").split(","); --l > -1;)
                    for (s = h[l], n = o ? g("easing." + s, null, !0) : d.easing[s] || {}, r = c.length; --r > -1;) a = c[r], x[s + "." + a] = x[a + s] = n[a] = t.getRatio ? t : t[a] || new t }; for ((a = v.prototype)._calcEnd = !1, a.getRatio = function(t) { if (this._func) return this._params[0] = t, this._func.apply(null, this._params); var e = this._type,
                    i = this._power,
                    o = 1 === e ? 1 - t : 2 === e ? t : t < .5 ? 2 * t : 2 * (1 - t); return 1 === i ? o *= o : 2 === i ? o *= o * o : 3 === i ? o *= o * o * o : 4 === i && (o *= o * o * o * o), 1 === e ? 1 - o : 2 === e ? o : t < .5 ? o / 2 : 1 - o / 2 }, r = (s = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length; --r > -1;) a = s[r] + ",Power" + r, S(new v(null, null, 1, r), a, "easeOut", !0), S(new v(null, null, 2, r), a, "easeIn" + (0 === r ? ",easeNone" : "")), S(new v(null, null, 3, r), a, "easeInOut");
        x.linear = d.easing.Linear.easeIn, x.swing = d.easing.Quad.easeInOut; var C = g("events.EventDispatcher", function(t) { this._listeners = {}, this._eventTarget = t || this });
        (a = C.prototype).addEventListener = function(t, e, i, o, n) { n = n || 0; var s, r, a = this._listeners[t],
                c = 0; for (this !== h || l || h.wake(), null == a && (this._listeners[t] = a = []), r = a.length; --r > -1;)(s = a[r]).c === e && s.s === i ? a.splice(r, 1) : 0 === c && s.pr < n && (c = r + 1);
            a.splice(c, 0, { c: e, s: i, up: o, pr: n }) }, a.removeEventListener = function(t, e) { var i, o = this._listeners[t]; if (o)
                for (i = o.length; --i > -1;)
                    if (o[i].c === e) return void o.splice(i, 1) }, a.dispatchEvent = function(t) { var e, i, o, n = this._listeners[t]; if (n)
                for ((e = n.length) > 1 && (n = n.slice(0)), i = this._eventTarget; --e > -1;)(o = n[e]) && (o.up ? o.c.call(o.s || i, { type: t, target: i }) : o.c.call(o.s || i)) }; var w = t.requestAnimationFrame,
            A = t.cancelAnimationFrame,
            T = Date.now || function() { return (new Date).getTime() },
            P = T(); for (r = (s = ["ms", "moz", "webkit", "o"]).length; --r > -1 && !w;) w = t[s[r] + "RequestAnimationFrame"], A = t[s[r] + "CancelAnimationFrame"] || t[s[r] + "CancelRequestAnimationFrame"];
        g("Ticker", function(t, e) { var i, n, s, r, a, c = this,
                d = T(),
                u = !(!1 === e || !w) && "auto",
                m = 500,
                f = 33,
                y = function(t) { var e, o, h = T() - P;
                    h > m && (d += h - f), P += h, c.time = (P - d) / 1e3, e = c.time - a, (!i || e > 0 || !0 === t) && (c.frame++, a += e + (e >= r ? .004 : r - e), o = !0), !0 !== t && (s = n(y)), o && c.dispatchEvent("tick") };
            C.call(c), c.time = c.frame = 0, c.tick = function() { y(!0) }, c.lagSmoothing = function(t, e) { if (!arguments.length) return m < 1e10;
                m = t || 1e10, f = Math.min(e, m, 0) }, c.sleep = function() { null != s && (u && A ? A(s) : clearTimeout(s), n = p, s = null, c === h && (l = !1)) }, c.wake = function(t) { null !== s ? c.sleep() : t ? d += -P + (P = T()) : c.frame > 10 && (P = T() - m + 5), n = 0 === i ? p : u && w ? w : function(t) { return setTimeout(t, 1e3 * (a - c.time) + 1 | 0) }, c === h && (l = !0), y(2) }, c.fps = function(t) { if (!arguments.length) return i;
                r = 1 / ((i = t) || 60), a = this.time + r, c.wake() }, c.useRAF = function(t) { if (!arguments.length) return u;
                c.sleep(), u = t, c.fps(i) }, c.fps(t), setTimeout(function() { "auto" === u && c.frame < 5 && "hidden" !== (o || {}).visibilityState && c.useRAF(!1) }, 1500) }), (a = d.Ticker.prototype = new d.events.EventDispatcher).constructor = d.Ticker; var k = g("core.Animation", function(t, e) { if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !0 === e.immediateRender, this.data = e.data, this._reversed = !0 === e.reversed, q) { l || h.wake(); var i = this.vars.useFrames ? J : q;
                i.add(this, i._time), this.vars.paused && this.paused(!0) } });
        h = k.ticker = new d.Ticker, (a = k.prototype)._dirty = a._gc = a._initted = a._paused = !1, a._totalTime = a._time = 0, a._rawPrevTime = -1, a._next = a._last = a._onUpdate = a._timeline = a.timeline = null, a._paused = !1; var M = function() { l && T() - P > 2e3 && ("hidden" !== (o || {}).visibilityState || !h.lagSmoothing()) && h.wake(); var t = setTimeout(M, 2e3);
            t.unref && t.unref() };
        M(), a.play = function(t, e) { return null != t && this.seek(t, e), this.reversed(!1).paused(!1) }, a.pause = function(t, e) { return null != t && this.seek(t, e), this.paused(!0) }, a.resume = function(t, e) { return null != t && this.seek(t, e), this.paused(!1) }, a.seek = function(t, e) { return this.totalTime(Number(t), !1 !== e) }, a.restart = function(t, e) { return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, !1 !== e, !0) }, a.reverse = function(t, e) { return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1) }, a.render = function(t, e, i) {}, a.invalidate = function() { return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this }, a.isActive = function() { var t, e = this._timeline,
                i = this._startTime; return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - 1e-7 }, a._enabled = function(t, e) { return l || h.wake(), this._gc = !t, this._active = this.isActive(), !0 !== e && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1 }, a._kill = function(t, e) { return this._enabled(!1, !1) }, a.kill = function(t, e) { return this._kill(t, e), this }, a._uncache = function(t) { for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline; return this }, a._swapSelfInParams = function(t) { for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this); return i }, a._callback = function(t) { var e = this.vars,
                i = e[t],
                o = e[t + "Params"],
                n = e[t + "Scope"] || e.callbackScope || this; switch (o ? o.length : 0) {
                case 0:
                    i.call(n); break;
                case 1:
                    i.call(n, o[0]); break;
                case 2:
                    i.call(n, o[0], o[1]); break;
                default:
                    i.apply(n, o) } }, a.eventCallback = function(t, e, i, o) { if ("on" === (t || "").substr(0, 2)) { var n = this.vars; if (1 === arguments.length) return n[t];
                null == e ? delete n[t] : (n[t] = e, n[t + "Params"] = m(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, n[t + "Scope"] = o), "onUpdate" === t && (this._onUpdate = e) } return this }, a.delay = function(t) { return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay }, a.duration = function(t) { return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration) }, a.totalDuration = function(t) { return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration }, a.time = function(t, e) { return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time }, a.totalTime = function(t, e, i) { if (l || h.wake(), !arguments.length) return this._totalTime; if (this._timeline) { if (t < 0 && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) { this._dirty && this.totalDuration(); var o = this._totalDuration,
                        n = this._timeline; if (t > o && !i && (t = o), this._startTime = (this._paused ? this._pauseTime : n._time) - (this._reversed ? o - t : t) / this._timeScale, n._dirty || this._uncache(!1), n._timeline)
                        for (; n._timeline;) n._timeline._time !== (n._startTime + n._totalTime) / n._timeScale && n.totalTime(n._totalTime, !0), n = n._timeline } this._gc && this._enabled(!0, !1), this._totalTime === t && 0 !== this._duration || (L.length && K(), this.render(t, e, !1), L.length && K()) } return this }, a.progress = a.totalProgress = function(t, e) { var i = this.duration(); return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio }, a.startTime = function(t) { return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime }, a.endTime = function(t) { return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale }, a.timeScale = function(t) { if (!arguments.length) return this._timeScale; var e, i; for (t = t || 1e-10, this._timeline && this._timeline.smoothChildTiming && (i = (e = this._pauseTime) || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline; return this }, a.reversed = function(t) { return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed }, a.paused = function(t) { if (!arguments.length) return this._paused; var e, i, o = this._timeline; return t != this._paused && o && (l || t || h.wake(), i = (e = o.rawTime()) - this._pauseTime, !t && o.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = o.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this }; var E = g("core.SimpleTimeline", function(t) { k.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0 });
        (a = E.prototype = new k).constructor = E, a.kill()._gc = !1, a._first = a._last = a._recent = null, a._sortChildren = !1, a.add = a.insert = function(t, e, i, o) { var n, s; if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), n = this._last, this._sortChildren)
                for (s = t._startTime; n && n._startTime > s;) n = n._prev; return n ? (t._next = n._next, n._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = n, this._recent = t, this._timeline && this._uncache(!0), this }, a._remove = function(t, e) { return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this }, a.render = function(t, e, i) { var o, n = this._first; for (this._totalTime = this._time = this._rawPrevTime = t; n;) o = n._next, (n._active || t >= n._startTime && !n._paused && !n._gc) && (n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = o }, a.rawTime = function() { return l || h.wake(), this._totalTime }; var B = g("TweenLite", function(e, i, o) { if (k.call(this, i, o), this.render = B.prototype.render, null == e) throw "Cannot tween a null target.";
                this.target = e = "string" != typeof e ? e : B.selector(e) || e; var n, s, r, a = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType),
                    h = this.vars.overwrite; if (this._overwrite = h = null == h ? z[B.defaultOverwrite] : "number" == typeof h ? h >> 0 : z[h], (a || e instanceof Array || e.push && m(e)) && "number" != typeof e[0])
                    for (this._targets = r = u(e), this._propLookup = [], this._siblings = [], n = 0; n < r.length; n++)(s = r[n]) ? "string" != typeof s ? s.length && s !== t && s[0] && (s[0] === t || s[0].nodeType && s[0].style && !s.nodeType) ? (r.splice(n--, 1), this._targets = r = r.concat(u(s))) : (this._siblings[n] = Z(s, this, !1), 1 === h && this._siblings[n].length > 1 && $(s, this, null, 1, this._siblings[n])) : "string" == typeof(s = r[n--] = B.selector(s)) && r.splice(n + 1, 1) : r.splice(n--, 1);
                else this._propLookup = {}, this._siblings = Z(e, this, !1), 1 === h && this._siblings.length > 1 && $(e, this, null, 1, this._siblings);
                (this.vars.immediateRender || 0 === i && 0 === this._delay && !1 !== this.vars.immediateRender) && (this._time = -1e-10, this.render(Math.min(0, -this._delay))) }, !0),
            I = function(e) { return e && e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType) },
            D = function(t, e) { var i, o = {}; for (i in t) H[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!j[i] || j[i] && j[i]._autoCSS) || (o[i] = t[i], delete t[i]);
                t.css = o };
        (a = B.prototype = new k).constructor = B, a.kill()._gc = !1, a.ratio = 0, a._firstPT = a._targets = a._overwrittenProps = a._startAt = null, a._notifyPluginsOfEnabled = a._lazy = !1, B.version = "1.20.5", B.defaultEase = a._ease = new v(null, null, 1, 1), B.defaultOverwrite = "auto", B.ticker = h, B.autoSleep = 120, B.lagSmoothing = function(t, e) { h.lagSmoothing(t, e) }, B.selector = t.$ || t.jQuery || function(e) { var i = t.$ || t.jQuery; return i ? (B.selector = i, i(e)) : (o || (o = t.document), o ? o.querySelectorAll ? o.querySelectorAll(e) : o.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e) }; var L = [],
            O = {},
            R = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
            F = /[\+-]=-?[\.\d]/,
            V = function(t) { for (var e, i = this._firstPT; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m.call(this._tween, e, this._target || i.t, this._tween) : e < 1e-6 && e > -1e-6 && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next },
            G = function(t, e, i, o) { var n, s, r, a, h, l, c, d = [],
                    u = 0,
                    p = "",
                    m = 0; for (d.start = t, d.end = e, t = d[0] = t + "", e = d[1] = e + "", i && (i(d), t = d[0], e = d[1]), d.length = 0, n = t.match(R) || [], s = e.match(R) || [], o && (o._next = null, o.blob = 1, d._firstPT = d._applyPT = o), h = s.length, a = 0; a < h; a++) c = s[a], p += (l = e.substr(u, e.indexOf(c, u) - u)) || !a ? l : ",", u += l.length, m ? m = (m + 1) % 5 : "rgba(" === l.substr(-5) && (m = 1), c === n[a] || n.length <= a ? p += c : (p && (d.push(p), p = ""), r = parseFloat(n[a]), d.push(r), d._firstPT = { _next: d._firstPT, t: d, p: d.length - 1, s: r, c: ("=" === c.charAt(1) ? parseInt(c.charAt(0) + "1", 10) * parseFloat(c.substr(2)) : parseFloat(c) - r) || 0, f: 0, m: m && m < 4 ? Math.round : 0 }), u += c.length; return (p += e.substr(u)) && d.push(p), d.setRatio = V, F.test(e) && (d.end = null), d },
            U = function(t, e, i, o, n, s, r, a, h) { "function" == typeof o && (o = o(h || 0, t)); var l = typeof t[e],
                    c = "function" !== l ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                    d = "get" !== i ? i : c ? r ? t[c](r) : t[c]() : t[e],
                    u = "string" == typeof o && "=" === o.charAt(1),
                    p = { t: t, p: e, s: d, f: "function" === l, pg: 0, n: n || e, m: s ? "function" == typeof s ? s : Math.round : 0, pr: 0, c: u ? parseInt(o.charAt(0) + "1", 10) * parseFloat(o.substr(2)) : parseFloat(o) - d || 0 }; if (("number" != typeof d || "number" != typeof o && !u) && (r || isNaN(d) || !u && isNaN(o) || "boolean" == typeof d || "boolean" == typeof o ? (p.fp = r, p = { t: G(d, u ? parseFloat(p.s) + p.c + (p.s + "").replace(/[0-9\-\.]/g, "") : o, a || B.defaultStringFilter, p), p: "setRatio", s: 0, c: 1, f: 2, pg: 0, n: n || e, pr: 0, m: 0 }) : (p.s = parseFloat(d), u || (p.c = parseFloat(o) - p.s || 0))), p.c) return (p._next = this._firstPT) && (p._next._prev = p), this._firstPT = p, p },
            N = B._internals = { isArray: m, isSelector: I, lazyTweens: L, blobDif: G },
            j = B._plugins = {},
            W = N.tweenLookup = {},
            X = 0,
            H = N.reservedProps = { ease: 1, delay: 1, overwrite: 1, onComplete: 1, onCompleteParams: 1, onCompleteScope: 1, useFrames: 1, runBackwards: 1, startAt: 1, onUpdate: 1, onUpdateParams: 1, onUpdateScope: 1, onStart: 1, onStartParams: 1, onStartScope: 1, onReverseComplete: 1, onReverseCompleteParams: 1, onReverseCompleteScope: 1, onRepeat: 1, onRepeatParams: 1, onRepeatScope: 1, easeParams: 1, yoyo: 1, immediateRender: 1, repeat: 1, repeatDelay: 1, data: 1, paused: 1, reversed: 1, autoCSS: 1, lazy: 1, onOverwrite: 1, callbackScope: 1, stringFilter: 1, id: 1, yoyoEase: 1 },
            z = { none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, true: 1, false: 0 },
            J = k._rootFramesTimeline = new E,
            q = k._rootTimeline = new E,
            Y = 30,
            K = N.lazyRender = function() { var t, e = L.length; for (O = {}; --e > -1;)(t = L[e]) && !1 !== t._lazy && (t.render(t._lazy[0], t._lazy[1], !0), t._lazy = !1);
                L.length = 0 };
        q._startTime = h.time, J._startTime = h.frame, q._active = J._active = !0, setTimeout(K, 1), k._updateRoot = B.render = function() { var t, e, i; if (L.length && K(), q.render((h.time - q._startTime) * q._timeScale, !1, !1), J.render((h.frame - J._startTime) * J._timeScale, !1, !1), L.length && K(), h.frame >= Y) { Y = h.frame + (parseInt(B.autoSleep, 10) || 120); for (i in W) { for (t = (e = W[i].tweens).length; --t > -1;) e[t]._gc && e.splice(t, 1);
                    0 === e.length && delete W[i] } if ((!(i = q._first) || i._paused) && B.autoSleep && !J._first && 1 === h._listeners.tick.length) { for (; i && i._paused;) i = i._next;
                    i || h.sleep() } } }, h.addEventListener("tick", k._updateRoot); var Z = function(t, e, i) { var o, n, s = t._gsTweenID; if (W[s || (t._gsTweenID = s = "t" + X++)] || (W[s] = { target: t, tweens: [] }), e && (o = W[s].tweens, o[n = o.length] = e, i))
                    for (; --n > -1;) o[n] === e && o.splice(n, 1); return W[s].tweens },
            Q = function(t, e, i, o) { var n, s, r = t.vars.onOverwrite; return r && (n = r(t, e, i, o)), (r = B.onOverwrite) && (s = r(t, e, i, o)), !1 !== n && !1 !== s },
            $ = function(t, e, i, o, n) { var s, r, a, h; if (1 === o || o >= 4) { for (h = n.length, s = 0; s < h; s++)
                        if ((a = n[s]) !== e) a._gc || a._kill(null, t, e) && (r = !0);
                        else if (5 === o) break; return r } var l, c = e._startTime + 1e-10,
                    d = [],
                    u = 0,
                    p = 0 === e._duration; for (s = n.length; --s > -1;)(a = n[s]) === e || a._gc || a._paused || (a._timeline !== e._timeline ? (l = l || tt(e, 0, p), 0 === tt(a, l, p) && (d[u++] = a)) : a._startTime <= c && a._startTime + a.totalDuration() / a._timeScale > c && ((p || !a._initted) && c - a._startTime <= 2e-10 || (d[u++] = a))); for (s = u; --s > -1;)
                    if (a = d[s], 2 === o && a._kill(i, t, e) && (r = !0), 2 !== o || !a._firstPT && a._initted) { if (2 !== o && !Q(a, e)) continue;
                        a._enabled(!1, !1) && (r = !0) } return r },
            tt = function(t, e, i) { for (var o = t._timeline, n = o._timeScale, s = t._startTime; o._timeline;) { if (s += o._startTime, n *= o._timeScale, o._paused) return -100;
                    o = o._timeline } return (s /= n) > e ? s - e : i && s === e || !t._initted && s - e < 2e-10 ? 1e-10 : (s += t.totalDuration() / t._timeScale / n) > e + 1e-10 ? 0 : s - e - 1e-10 };
        a._init = function() { var t, e, i, o, n, s, r = this.vars,
                a = this._overwrittenProps,
                h = this._duration,
                l = !!r.immediateRender,
                c = r.ease; if (r.startAt) { this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), n = {}; for (o in r.startAt) n[o] = r.startAt[o]; if (n.data = "isStart", n.overwrite = !1, n.immediateRender = !0, n.lazy = l && !1 !== r.lazy, n.startAt = n.delay = null, n.onUpdate = r.onUpdate, n.onUpdateParams = r.onUpdateParams, n.onUpdateScope = r.onUpdateScope || r.callbackScope || this, this._startAt = B.to(this.target || {}, 0, n), l)
                    if (this._time > 0) this._startAt = null;
                    else if (0 !== h) return } else if (r.runBackwards && 0 !== h)
                if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                else { 0 !== this._time && (l = !1), i = {}; for (o in r) H[o] && "autoCSS" !== o || (i[o] = r[o]); if (i.overwrite = 0, i.data = "isFromStart", i.lazy = l && !1 !== r.lazy, i.immediateRender = l, this._startAt = B.to(this.target, 0, i), l) { if (0 === this._time) return } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null) } if (this._ease = c = c ? c instanceof v ? c : "function" == typeof c ? new v(c, r.easeParams) : x[c] || B.defaultEase : B.defaultEase, r.easeParams instanceof Array && c.config && (this._ease = c.config.apply(c, r.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                for (s = this._targets.length, t = 0; t < s; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], a ? a[t] : null, t) && (e = !0);
            else e = this._initProps(this.target, this._propLookup, this._siblings, a, 0); if (e && B._onPluginEvent("_onInitAllProps", this), a && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), r.runBackwards)
                for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
            this._onUpdate = r.onUpdate, this._initted = !0 }, a._initProps = function(e, i, o, n, s) { var r, a, h, l, c, d; if (null == e) return !1;
            O[e._gsTweenID] && K(), this.vars.css || e.style && e !== t && e.nodeType && j.css && !1 !== this.vars.autoCSS && D(this.vars, e); for (r in this.vars)
                if (d = this.vars[r], H[r]) d && (d instanceof Array || d.push && m(d)) && -1 !== d.join("").indexOf("{self}") && (this.vars[r] = d = this._swapSelfInParams(d, this));
                else if (j[r] && (l = new j[r])._onInitTween(e, this.vars[r], this, s)) { for (this._firstPT = c = { _next: this._firstPT, t: l, p: "setRatio", s: 0, c: 1, f: 1, n: r, pg: 1, pr: l._priority, m: 0 }, a = l._overwriteProps.length; --a > -1;) i[l._overwriteProps[a]] = this._firstPT;
                (l._priority || l._onInitAllProps) && (h = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0), c._next && (c._next._prev = c) } else i[r] = U.call(this, e, r, "get", d, r, 0, null, this.vars.stringFilter, s); return n && this._kill(n, e) ? this._initProps(e, i, o, n, s) : this._overwrite > 1 && this._firstPT && o.length > 1 && $(e, this, i, this._overwrite, o) ? (this._kill(i, e), this._initProps(e, i, o, n, s)) : (this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration) && (O[e._gsTweenID] = !0), h) }, a.render = function(t, e, i) { var o, n, s, r, a = this._time,
                h = this._duration,
                l = this._rawPrevTime; if (t >= h - 1e-7 && t >= 0) this._totalTime = this._time = h, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (o = !0, n = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === h && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (t = 0), (l < 0 || t <= 0 && t >= -1e-7 || 1e-10 === l && "isPause" !== this.data) && l !== t && (i = !0, l > 1e-10 && (n = "onReverseComplete")), this._rawPrevTime = r = !e || t || l === t ? t : 1e-10);
            else if (t < 1e-7) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== a || 0 === h && l > 0) && (n = "onReverseComplete", o = this._reversed), t < 0 && (this._active = !1, 0 === h && (this._initted || !this.vars.lazy || i) && (l >= 0 && (1e-10 !== l || "isPause" !== this.data) && (i = !0), this._rawPrevTime = r = !e || t || l === t ? t : 1e-10)), (!this._initted || this._startAt && this._startAt.progress()) && (i = !0);
            else if (this._totalTime = this._time = t, this._easeType) { var c = t / h,
                    d = this._easeType,
                    u = this._easePower;
                (1 === d || 3 === d && c >= .5) && (c = 1 - c), 3 === d && (c *= 2), 1 === u ? c *= c : 2 === u ? c *= c * c : 3 === u ? c *= c * c * c : 4 === u && (c *= c * c * c * c), this.ratio = 1 === d ? 1 - c : 2 === d ? c : t / h < .5 ? c / 2 : 1 - c / 2 } else this.ratio = this._ease.getRatio(t / h); if (this._time !== a || i) { if (!this._initted) { if (this._init(), !this._initted || this._gc) return; if (!i && this._firstPT && (!1 !== this.vars.lazy && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = a, this._rawPrevTime = l, L.push(this), void(this._lazy = [t, e]);
                    this._time && !o ? this.ratio = this._ease.getRatio(this._time / h) : o && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1)) } for (!1 !== this._lazy && (this._lazy = !1), this._active || !this._paused && this._time !== a && t >= 0 && (this._active = !0), 0 === a && (this._startAt && (t >= 0 ? this._startAt.render(t, !0, i) : n || (n = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== h || e || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s, s = s._next;
                this._onUpdate && (t < 0 && this._startAt && -1e-4 !== t && this._startAt.render(t, !0, i), e || (this._time !== a || o || i) && this._callback("onUpdate")), n && (this._gc && !i || (t < 0 && this._startAt && !this._onUpdate && -1e-4 !== t && this._startAt.render(t, !0, i), o && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !e && this.vars[n] && this._callback(n), 0 === h && 1e-10 === this._rawPrevTime && 1e-10 !== r && (this._rawPrevTime = 0))) } }, a._kill = function(t, e, i) { if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
            e = "string" != typeof e ? e || this._targets || this.target : B.selector(e) || e; var o, n, s, r, a, h, l, c, d, u = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline; if ((m(e) || I(e)) && "number" != typeof e[0])
                for (o = e.length; --o > -1;) this._kill(t, e[o], i) && (h = !0);
            else { if (this._targets) { for (o = this._targets.length; --o > -1;)
                        if (e === this._targets[o]) { a = this._propLookup[o] || {}, this._overwrittenProps = this._overwrittenProps || [], n = this._overwrittenProps[o] = t ? this._overwrittenProps[o] || {} : "all"; break } } else { if (e !== this.target) return !1;
                    a = this._propLookup, n = this._overwrittenProps = t ? this._overwrittenProps || {} : "all" } if (a) { if (l = t || a, c = t !== n && "all" !== n && t !== a && ("object" != typeof t || !t._tempKill), i && (B.onOverwrite || this.vars.onOverwrite)) { for (s in l) a[s] && (d || (d = []), d.push(s)); if ((d || !t) && !Q(this, i, e, d)) return !1 } for (s in l)(r = a[s]) && (u && (r.f ? r.t[r.p](r.s) : r.t[r.p] = r.s, h = !0), r.pg && r.t._kill(l) && (h = !0), r.pg && 0 !== r.t._overwriteProps.length || (r._prev ? r._prev._next = r._next : r === this._firstPT && (this._firstPT = r._next), r._next && (r._next._prev = r._prev), r._next = r._prev = null), delete a[s]), c && (n[s] = 1);!this._firstPT && this._initted && this._enabled(!1, !1) } } return h }, a.invalidate = function() { return this._notifyPluginsOfEnabled && B._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], k.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -1e-10, this.render(Math.min(0, -this._delay))), this }, a._enabled = function(t, e) { if (l || h.wake(), t && this._gc) { var i, o = this._targets; if (o)
                    for (i = o.length; --i > -1;) this._siblings[i] = Z(o[i], this, !0);
                else this._siblings = Z(this.target, this, !0) } return k.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && B._onPluginEvent(t ? "_onEnable" : "_onDisable", this) }, B.to = function(t, e, i) { return new B(t, e, i) }, B.from = function(t, e, i) { return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new B(t, e, i) }, B.fromTo = function(t, e, i, o) { return o.startAt = i, o.immediateRender = 0 != o.immediateRender && 0 != i.immediateRender, new B(t, e, o) }, B.delayedCall = function(t, e, i, o, n) { return new B(e, 0, { delay: t, onComplete: e, onCompleteParams: i, callbackScope: o, onReverseComplete: e, onReverseCompleteParams: i, immediateRender: !1, lazy: !1, useFrames: n, overwrite: 0 }) }, B.set = function(t, e) { return new B(t, 0, e) }, B.getTweensOf = function(t, e) { if (null == t) return [];
            t = "string" != typeof t ? t : B.selector(t) || t; var i, o, n, s; if ((m(t) || I(t)) && "number" != typeof t[0]) { for (i = t.length, o = []; --i > -1;) o = o.concat(B.getTweensOf(t[i], e)); for (i = o.length; --i > -1;)
                    for (s = o[i], n = i; --n > -1;) s === o[n] && o.splice(i, 1) } else if (t._gsTweenID)
                for (i = (o = Z(t).concat()).length; --i > -1;)(o[i]._gc || e && !o[i].isActive()) && o.splice(i, 1); return o || [] }, B.killTweensOf = B.killDelayedCallsTo = function(t, e, i) { "object" == typeof e && (i = e, e = !1); for (var o = B.getTweensOf(t, e), n = o.length; --n > -1;) o[n]._kill(i, t) }; var et = g("plugins.TweenPlugin", function(t, e) { this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = et.prototype }, !0); if (a = et.prototype, et.version = "1.19.0", et.API = 2, a._firstPT = null, a._addTween = U, a.setRatio = V, a._kill = function(t) { var e, i = this._overwriteProps,
                    o = this._firstPT; if (null != t[this._propName]) this._overwriteProps = [];
                else
                    for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1); for (; o;) null != t[o.n] && (o._next && (o._next._prev = o._prev), o._prev ? (o._prev._next = o._next, o._prev = null) : this._firstPT === o && (this._firstPT = o._next)), o = o._next; return !1 }, a._mod = a._roundProps = function(t) { for (var e, i = this._firstPT; i;)(e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")]) && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next }, B._onPluginEvent = function(t, e) { var i, o, n, s, r, a = e._firstPT; if ("_onInitAllProps" === t) { for (; a;) { for (r = a._next, o = n; o && o.pr > a.pr;) o = o._next;
                        (a._prev = o ? o._prev : s) ? a._prev._next = a: n = a, (a._next = o) ? o._prev = a : s = a, a = r } a = e._firstPT = n } for (; a;) a.pg && "function" == typeof a.t[t] && a.t[t]() && (i = !0), a = a._next; return i }, et.activate = function(t) { for (var e = t.length; --e > -1;) t[e].API === et.API && (j[(new t[e])._propName] = t[e]); return !0 }, b.plugin = function(t) { if (!(t && t.propName && t.init && t.API)) throw "illegal plugin definition."; var e, i = t.propName,
                    o = t.priority || 0,
                    n = t.overwriteProps,
                    s = { init: "_onInitTween", set: "setRatio", kill: "_kill", round: "_mod", mod: "_mod", initAll: "_onInitAllProps" },
                    r = g("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() { et.call(this, i, o), this._overwriteProps = n || [] }, !0 === t.global),
                    a = r.prototype = new et(i);
                a.constructor = r, r.API = t.API; for (e in s) "function" == typeof t[e] && (a[s[e]] = t[e]); return r.version = t.version, et.activate([r]), r }, s = t._gsQueue) { for (r = 0; r < s.length; r++) s[r](); for (a in f) f[a].func || t.console.log("GSAP encountered missing dependency: " + a) } l = !1 }("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window),
    function(t, e, i, o) { "use strict";

        function n(t, e, i) { return setTimeout(l(t, i), e) }

        function s(t, e, i) { return !!Array.isArray(t) && (r(t, i[e], i), !0) }

        function r(t, e, i) { var n; if (t)
                if (t.forEach) t.forEach(e, i);
                else if (t.length !== o)
                for (n = 0; n < t.length;) e.call(i, t[n], n, t), n++;
            else
                for (n in t) t.hasOwnProperty(n) && e.call(i, t[n], n, t) }

        function a(e, i, o) { var n = "DEPRECATED METHOD: " + i + "\n" + o + " AT \n"; return function() { var i = new Error("get-stack-trace"),
                    o = i && i.stack ? i.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
                    s = t.console && (t.console.warn || t.console.log); return s && s.call(t.console, n, o), e.apply(this, arguments) } }

        function h(t, e, i) { var o, n = e.prototype;
            (o = t.prototype = Object.create(n)).constructor = t, o._super = n, i && ct(o, i) }

        function l(t, e) { return function() { return t.apply(e, arguments) } }

        function c(t, e) { return typeof t == pt ? t.apply(e ? e[0] || o : o, e) : t }

        function d(t, e) { return t === o ? e : t }

        function u(t, e, i) { r(y(e), function(e) { t.addEventListener(e, i, !1) }) }

        function p(t, e, i) { r(y(e), function(e) { t.removeEventListener(e, i, !1) }) }

        function m(t, e) { for (; t;) { if (t == e) return !0;
                t = t.parentNode } return !1 }

        function f(t, e) { return t.indexOf(e) > -1 }

        function y(t) { return t.trim().split(/\s+/g) }

        function b(t, e, i) { if (t.indexOf && !i) return t.indexOf(e); for (var o = 0; o < t.length;) { if (i && t[o][i] == e || !i && t[o] === e) return o;
                o++ } return -1 }

        function g(t) { return Array.prototype.slice.call(t, 0) }

        function _(t, e, i) { for (var o = [], n = [], s = 0; s < t.length;) { var r = e ? t[s][e] : t[s];
                b(n, r) < 0 && o.push(t[s]), n[s] = r, s++ } return i && (o = e ? o.sort(function(t, i) { return t[e] > i[e] }) : o.sort()), o }

        function v(t, e) { for (var i, n, s = e[0].toUpperCase() + e.slice(1), r = 0; r < dt.length;) { if (i = dt[r], (n = i ? i + s : e) in t) return n;
                r++ } return o }

        function x() { return _t++ }

        function S(e) { var i = e.ownerDocument || e; return i.defaultView || i.parentWindow || t }

        function C(t, e) { var i = this;
            this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function(e) { c(t.options.enable, [t]) && i.handler(e) }, this.init() }

        function w(t) { var e = t.options.inputClass; return new(e || (St ? V : Ct ? N : xt ? W : F))(t, A) }

        function A(t, e, i) { var o = i.pointers.length,
                n = i.changedPointers.length,
                s = e & At && o - n == 0,
                r = e & (Pt | kt) && o - n == 0;
            i.isFirst = !!s, i.isFinal = !!r, s && (t.session = {}), i.eventType = e, T(t, i), t.emit("hammer.input", i), t.recognize(i), t.session.prevInput = i }

        function T(t, e) { var i = t.session,
                o = e.pointers,
                n = o.length;
            i.firstInput || (i.firstInput = M(e)), n > 1 && !i.firstMultiple ? i.firstMultiple = M(e) : 1 === n && (i.firstMultiple = !1); var s = i.firstInput,
                r = i.firstMultiple,
                a = r ? r.center : s.center,
                h = e.center = E(o);
            e.timeStamp = yt(), e.deltaTime = e.timeStamp - s.timeStamp, e.angle = L(a, h), e.distance = D(a, h), P(i, e), e.offsetDirection = I(e.deltaX, e.deltaY); var l = B(e.deltaTime, e.deltaX, e.deltaY);
            e.overallVelocityX = l.x, e.overallVelocityY = l.y, e.overallVelocity = ft(l.x) > ft(l.y) ? l.x : l.y, e.scale = r ? R(r.pointers, o) : 1, e.rotation = r ? O(r.pointers, o) : 0, e.maxPointers = i.prevInput ? e.pointers.length > i.prevInput.maxPointers ? e.pointers.length : i.prevInput.maxPointers : e.pointers.length, k(i, e); var c = t.element;
            m(e.srcEvent.target, c) && (c = e.srcEvent.target), e.target = c }

        function P(t, e) { var i = e.center,
                o = t.offsetDelta || {},
                n = t.prevDelta || {},
                s = t.prevInput || {};
            e.eventType !== At && s.eventType !== Pt || (n = t.prevDelta = { x: s.deltaX || 0, y: s.deltaY || 0 }, o = t.offsetDelta = { x: i.x, y: i.y }), e.deltaX = n.x + (i.x - o.x), e.deltaY = n.y + (i.y - o.y) }

        function k(t, e) { var i, n, s, r, a = t.lastInterval || e,
                h = e.timeStamp - a.timeStamp; if (e.eventType != kt && (h > wt || a.velocity === o)) { var l = e.deltaX - a.deltaX,
                    c = e.deltaY - a.deltaY,
                    d = B(h, l, c);
                n = d.x, s = d.y, i = ft(d.x) > ft(d.y) ? d.x : d.y, r = I(l, c), t.lastInterval = e } else i = a.velocity, n = a.velocityX, s = a.velocityY, r = a.direction;
            e.velocity = i, e.velocityX = n, e.velocityY = s, e.direction = r }

        function M(t) { for (var e = [], i = 0; i < t.pointers.length;) e[i] = { clientX: mt(t.pointers[i].clientX), clientY: mt(t.pointers[i].clientY) }, i++; return { timeStamp: yt(), pointers: e, center: E(e), deltaX: t.deltaX, deltaY: t.deltaY } }

        function E(t) { var e = t.length; if (1 === e) return { x: mt(t[0].clientX), y: mt(t[0].clientY) }; for (var i = 0, o = 0, n = 0; n < e;) i += t[n].clientX, o += t[n].clientY, n++; return { x: mt(i / e), y: mt(o / e) } }

        function B(t, e, i) { return { x: e / t || 0, y: i / t || 0 } }

        function I(t, e) { return t === e ? Mt : ft(t) >= ft(e) ? t < 0 ? Et : Bt : e < 0 ? It : Dt }

        function D(t, e, i) { i || (i = Ft); var o = e[i[0]] - t[i[0]],
                n = e[i[1]] - t[i[1]]; return Math.sqrt(o * o + n * n) }

        function L(t, e, i) { i || (i = Ft); var o = e[i[0]] - t[i[0]],
                n = e[i[1]] - t[i[1]]; return 180 * Math.atan2(n, o) / Math.PI }

        function O(t, e) { return L(e[1], e[0], Vt) + L(t[1], t[0], Vt) }

        function R(t, e) { return D(e[0], e[1], Vt) / D(t[0], t[1], Vt) }

        function F() { this.evEl = Ut, this.evWin = Nt, this.pressed = !1, C.apply(this, arguments) }

        function V() { this.evEl = Xt, this.evWin = Ht, C.apply(this, arguments), this.store = this.manager.session.pointerEvents = [] }

        function G() { this.evTarget = Jt, this.evWin = qt, this.started = !1, C.apply(this, arguments) }

        function U(t, e) { var i = g(t.touches),
                o = g(t.changedTouches); return e & (Pt | kt) && (i = _(i.concat(o), "identifier", !0)), [i, o] }

        function N() { this.evTarget = Kt, this.targetIds = {}, C.apply(this, arguments) }

        function j(t, e) { var i = g(t.touches),
                o = this.targetIds; if (e & (At | Tt) && 1 === i.length) return o[i[0].identifier] = !0, [i, i]; var n, s, r = g(t.changedTouches),
                a = [],
                h = this.target; if (s = i.filter(function(t) { return m(t.target, h) }), e === At)
                for (n = 0; n < s.length;) o[s[n].identifier] = !0, n++; for (n = 0; n < r.length;) o[r[n].identifier] && a.push(r[n]), e & (Pt | kt) && delete o[r[n].identifier], n++; return a.length ? [_(s.concat(a), "identifier", !0), a] : void 0 }

        function W() { C.apply(this, arguments); var t = l(this.handler, this);
            this.touch = new N(this.manager, t), this.mouse = new F(this.manager, t), this.primaryTouch = null, this.lastTouches = [] }

        function X(t, e) { t & At ? (this.primaryTouch = e.changedPointers[0].identifier, H.call(this, e)) : t & (Pt | kt) && H.call(this, e) }

        function H(t) { var e = t.changedPointers[0]; if (e.identifier === this.primaryTouch) { var i = { x: e.clientX, y: e.clientY };
                this.lastTouches.push(i); var o = this.lastTouches;
                setTimeout(function() { var t = o.indexOf(i);
                    t > -1 && o.splice(t, 1) }, Zt) } }

        function z(t) { for (var e = t.srcEvent.clientX, i = t.srcEvent.clientY, o = 0; o < this.lastTouches.length; o++) { var n = this.lastTouches[o],
                    s = Math.abs(e - n.x),
                    r = Math.abs(i - n.y); if (s <= Qt && r <= Qt) return !0 } return !1 }

        function J(t, e) { this.manager = t, this.set(e) }

        function q(t) { if (f(t, oe)) return oe; var e = f(t, ne),
                i = f(t, se); return e && i ? oe : e || i ? e ? ne : se : f(t, ie) ? ie : ee }

        function Y(t) { this.options = ct({}, this.defaults, t || {}), this.id = x(), this.manager = null, this.options.enable = d(this.options.enable, !0), this.state = ae, this.simultaneous = {}, this.requireFail = [] }

        function K(t) { return t & ue ? "cancel" : t & ce ? "end" : t & le ? "move" : t & he ? "start" : "" }

        function Z(t) { return t == Dt ? "down" : t == It ? "up" : t == Et ? "left" : t == Bt ? "right" : "" }

        function Q(t, e) { var i = e.manager; return i ? i.get(t) : t }

        function $() { Y.apply(this, arguments) }

        function tt() { $.apply(this, arguments), this.pX = null, this.pY = null }

        function et() { $.apply(this, arguments) }

        function it() { Y.apply(this, arguments), this._timer = null, this._input = null }

        function ot() { $.apply(this, arguments) }

        function nt() { $.apply(this, arguments) }

        function st() { Y.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0 }

        function rt(t, e) { return e = e || {}, e.recognizers = d(e.recognizers, rt.defaults.preset), new at(t, e) }

        function at(t, e) { this.options = ct({}, rt.defaults, e || {}), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = t, this.input = w(this), this.touchAction = new J(this, this.options.touchAction), ht(this, !0), r(this.options.recognizers, function(t) { var e = this.add(new t[0](t[1]));
                t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]) }, this) }

        function ht(t, e) { var i = t.element; if (i.style) { var o;
                r(t.options.cssProps, function(n, s) { o = v(i.style, s), e ? (t.oldCssProps[o] = i.style[o], i.style[o] = n) : i.style[o] = t.oldCssProps[o] || "" }), e || (t.oldCssProps = {}) } }

        function lt(t, i) { var o = e.createEvent("Event");
            o.initEvent(t, !0, !0), o.gesture = i, i.target.dispatchEvent(o) } var ct, dt = ["", "webkit", "Moz", "MS", "ms", "o"],
            ut = e.createElement("div"),
            pt = "function",
            mt = Math.round,
            ft = Math.abs,
            yt = Date.now;
        ct = "function" != typeof Object.assign ? function(t) { if (t === o || null === t) throw new TypeError("Cannot convert undefined or null to object"); for (var e = Object(t), i = 1; i < arguments.length; i++) { var n = arguments[i]; if (n !== o && null !== n)
                    for (var s in n) n.hasOwnProperty(s) && (e[s] = n[s]) } return e } : Object.assign; var bt = a(function(t, e, i) { for (var n = Object.keys(e), s = 0; s < n.length;)(!i || i && t[n[s]] === o) && (t[n[s]] = e[n[s]]), s++; return t }, "extend", "Use `assign`."),
            gt = a(function(t, e) { return bt(t, e, !0) }, "merge", "Use `assign`."),
            _t = 1,
            vt = /mobile|tablet|ip(ad|hone|od)|android/i,
            xt = "ontouchstart" in t,
            St = v(t, "PointerEvent") !== o,
            Ct = xt && vt.test(navigator.userAgent),
            wt = 25,
            At = 1,
            Tt = 2,
            Pt = 4,
            kt = 8,
            Mt = 1,
            Et = 2,
            Bt = 4,
            It = 8,
            Dt = 16,
            Lt = Et | Bt,
            Ot = It | Dt,
            Rt = Lt | Ot,
            Ft = ["x", "y"],
            Vt = ["clientX", "clientY"];
        C.prototype = { handler: function() {}, init: function() { this.evEl && u(this.element, this.evEl, this.domHandler), this.evTarget && u(this.target, this.evTarget, this.domHandler), this.evWin && u(S(this.element), this.evWin, this.domHandler) }, destroy: function() { this.evEl && p(this.element, this.evEl, this.domHandler), this.evTarget && p(this.target, this.evTarget, this.domHandler), this.evWin && p(S(this.element), this.evWin, this.domHandler) } }; var Gt = { mousedown: At, mousemove: Tt, mouseup: Pt },
            Ut = "mousedown",
            Nt = "mousemove mouseup";
        h(F, C, { handler: function(t) { var e = Gt[t.type];
                e & At && 0 === t.button && (this.pressed = !0), e & Tt && 1 !== t.which && (e = Pt), this.pressed && (e & Pt && (this.pressed = !1), this.callback(this.manager, e, { pointers: [t], changedPointers: [t], pointerType: "mouse", srcEvent: t })) } }); var jt = { pointerdown: At, pointermove: Tt, pointerup: Pt, pointercancel: kt, pointerout: kt },
            Wt = { 2: "touch", 3: "pen", 4: "mouse", 5: "kinect" },
            Xt = "pointerdown",
            Ht = "pointermove pointerup pointercancel";
        t.MSPointerEvent && !t.PointerEvent && (Xt = "MSPointerDown", Ht = "MSPointerMove MSPointerUp MSPointerCancel"), h(V, C, { handler: function(t) { var e = this.store,
                    i = !1,
                    o = t.type.toLowerCase().replace("ms", ""),
                    n = jt[o],
                    s = Wt[t.pointerType] || t.pointerType,
                    r = "touch" == s,
                    a = b(e, t.pointerId, "pointerId");
                n & At && (0 === t.button || r) ? a < 0 && (e.push(t), a = e.length - 1) : n & (Pt | kt) && (i = !0), a < 0 || (e[a] = t, this.callback(this.manager, n, { pointers: e, changedPointers: [t], pointerType: s, srcEvent: t }), i && e.splice(a, 1)) } }); var zt = { touchstart: At, touchmove: Tt, touchend: Pt, touchcancel: kt },
            Jt = "touchstart",
            qt = "touchstart touchmove touchend touchcancel";
        h(G, C, { handler: function(t) { var e = zt[t.type]; if (e === At && (this.started = !0), this.started) { var i = U.call(this, t, e);
                    e & (Pt | kt) && i[0].length - i[1].length == 0 && (this.started = !1), this.callback(this.manager, e, { pointers: i[0], changedPointers: i[1], pointerType: "touch", srcEvent: t }) } } }); var Yt = { touchstart: At, touchmove: Tt, touchend: Pt, touchcancel: kt },
            Kt = "touchstart touchmove touchend touchcancel";
        h(N, C, { handler: function(t) { var e = Yt[t.type],
                    i = j.call(this, t, e);
                i && this.callback(this.manager, e, { pointers: i[0], changedPointers: i[1], pointerType: "touch", srcEvent: t }) } }); var Zt = 2500,
            Qt = 25;
        h(W, C, { handler: function(t, e, i) { var o = "touch" == i.pointerType,
                    n = "mouse" == i.pointerType; if (!(n && i.sourceCapabilities && i.sourceCapabilities.firesTouchEvents)) { if (o) X.call(this, e, i);
                    else if (n && z.call(this, i)) return;
                    this.callback(t, e, i) } }, destroy: function() { this.touch.destroy(), this.mouse.destroy() } }); var $t = v(ut.style, "touchAction"),
            te = $t !== o,
            ee = "auto",
            ie = "manipulation",
            oe = "none",
            ne = "pan-x",
            se = "pan-y",
            re = function() { if (!te) return !1; var e = {},
                    i = t.CSS && t.CSS.supports; return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(o) { e[o] = !i || t.CSS.supports("touch-action", o) }), e }();
        J.prototype = { set: function(t) { "compute" == t && (t = this.compute()), te && this.manager.element.style && re[t] && (this.manager.element.style[$t] = t), this.actions = t.toLowerCase().trim() }, update: function() { this.set(this.manager.options.touchAction) }, compute: function() { var t = []; return r(this.manager.recognizers, function(e) { c(e.options.enable, [e]) && (t = t.concat(e.getTouchAction())) }), q(t.join(" ")) }, preventDefaults: function(t) { var e = t.srcEvent,
                    i = t.offsetDirection; if (this.manager.session.prevented) e.preventDefault();
                else { var o = this.actions,
                        n = f(o, oe) && !re[oe],
                        s = f(o, se) && !re[se],
                        r = f(o, ne) && !re[ne]; if (n) { var a = 1 === t.pointers.length,
                            h = t.distance < 2,
                            l = t.deltaTime < 250; if (a && h && l) return } if (!r || !s) return n || s && i & Lt || r && i & Ot ? this.preventSrc(e) : void 0 } }, preventSrc: function(t) { this.manager.session.prevented = !0, t.preventDefault() } }; var ae = 1,
            he = 2,
            le = 4,
            ce = 8,
            de = ce,
            ue = 16;
        Y.prototype = { defaults: {}, set: function(t) { return ct(this.options, t), this.manager && this.manager.touchAction.update(), this }, recognizeWith: function(t) { if (s(t, "recognizeWith", this)) return this; var e = this.simultaneous; return t = Q(t, this), e[t.id] || (e[t.id] = t, t.recognizeWith(this)), this }, dropRecognizeWith: function(t) { return s(t, "dropRecognizeWith", this) ? this : (t = Q(t, this), delete this.simultaneous[t.id], this) }, requireFailure: function(t) { if (s(t, "requireFailure", this)) return this; var e = this.requireFail; return t = Q(t, this), -1 === b(e, t) && (e.push(t), t.requireFailure(this)), this }, dropRequireFailure: function(t) { if (s(t, "dropRequireFailure", this)) return this;
                t = Q(t, this); var e = b(this.requireFail, t); return e > -1 && this.requireFail.splice(e, 1), this }, hasRequireFailures: function() { return this.requireFail.length > 0 }, canRecognizeWith: function(t) { return !!this.simultaneous[t.id] }, emit: function(t) {
                function e(e) { i.manager.emit(e, t) } var i = this,
                    o = this.state;
                o < ce && e(i.options.event + K(o)), e(i.options.event), t.additionalEvent && e(t.additionalEvent), o >= ce && e(i.options.event + K(o)) }, tryEmit: function(t) { if (this.canEmit()) return this.emit(t);
                this.state = 32 }, canEmit: function() { for (var t = 0; t < this.requireFail.length;) { if (!(this.requireFail[t].state & (32 | ae))) return !1;
                    t++ } return !0 }, recognize: function(t) { var e = ct({}, t); if (!c(this.options.enable, [this, e])) return this.reset(), void(this.state = 32);
                this.state & (de | ue | 32) && (this.state = ae), this.state = this.process(e), this.state & (he | le | ce | ue) && this.tryEmit(e) }, process: function(t) {}, getTouchAction: function() {}, reset: function() {} }, h($, Y, { defaults: { pointers: 1 }, attrTest: function(t) { var e = this.options.pointers; return 0 === e || t.pointers.length === e }, process: function(t) { var e = this.state,
                    i = t.eventType,
                    o = e & (he | le),
                    n = this.attrTest(t); return o && (i & kt || !n) ? e | ue : o || n ? i & Pt ? e | ce : e & he ? e | le : he : 32 } }), h(tt, $, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: Rt }, getTouchAction: function() { var t = this.options.direction,
                    e = []; return t & Lt && e.push(se), t & Ot && e.push(ne), e }, directionTest: function(t) { var e = this.options,
                    i = !0,
                    o = t.distance,
                    n = t.direction,
                    s = t.deltaX,
                    r = t.deltaY; return n & e.direction || (e.direction & Lt ? (n = 0 === s ? Mt : s < 0 ? Et : Bt, i = s != this.pX, o = Math.abs(t.deltaX)) : (n = 0 === r ? Mt : r < 0 ? It : Dt, i = r != this.pY, o = Math.abs(t.deltaY))), t.direction = n, i && o > e.threshold && n & e.direction }, attrTest: function(t) { return $.prototype.attrTest.call(this, t) && (this.state & he || !(this.state & he) && this.directionTest(t)) }, emit: function(t) { this.pX = t.deltaX, this.pY = t.deltaY; var e = Z(t.direction);
                e && (t.additionalEvent = this.options.event + e), this._super.emit.call(this, t) } }), h(et, $, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function() { return [oe] }, attrTest: function(t) { return this._super.attrTest.call(this, t) && (Math.abs(t.scale - 1) > this.options.threshold || this.state & he) }, emit: function(t) { if (1 !== t.scale) { var e = t.scale < 1 ? "in" : "out";
                    t.additionalEvent = this.options.event + e } this._super.emit.call(this, t) } }), h(it, Y, { defaults: { event: "press", pointers: 1, time: 251, threshold: 9 }, getTouchAction: function() { return [ee] }, process: function(t) { var e = this.options,
                    i = t.pointers.length === e.pointers,
                    o = t.distance < e.threshold,
                    s = t.deltaTime > e.time; if (this._input = t, !o || !i || t.eventType & (Pt | kt) && !s) this.reset();
                else if (t.eventType & At) this.reset(), this._timer = n(function() { this.state = de, this.tryEmit() }, e.time, this);
                else if (t.eventType & Pt) return de; return 32 }, reset: function() { clearTimeout(this._timer) }, emit: function(t) { this.state === de && (t && t.eventType & Pt ? this.manager.emit(this.options.event + "up", t) : (this._input.timeStamp = yt(), this.manager.emit(this.options.event, this._input))) } }), h(ot, $, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function() { return [oe] }, attrTest: function(t) { return this._super.attrTest.call(this, t) && (Math.abs(t.rotation) > this.options.threshold || this.state & he) } }), h(nt, $, { defaults: { event: "swipe", threshold: 10, velocity: .3, direction: Lt | Ot, pointers: 1 }, getTouchAction: function() { return tt.prototype.getTouchAction.call(this) }, attrTest: function(t) { var e, i = this.options.direction; return i & (Lt | Ot) ? e = t.overallVelocity : i & Lt ? e = t.overallVelocityX : i & Ot && (e = t.overallVelocityY), this._super.attrTest.call(this, t) && i & t.offsetDirection && t.distance > this.options.threshold && t.maxPointers == this.options.pointers && ft(e) > this.options.velocity && t.eventType & Pt }, emit: function(t) { var e = Z(t.offsetDirection);
                e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t) } }), h(st, Y, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10 }, getTouchAction: function() { return [ie] }, process: function(t) { var e = this.options,
                    i = t.pointers.length === e.pointers,
                    o = t.distance < e.threshold,
                    s = t.deltaTime < e.time; if (this.reset(), t.eventType & At && 0 === this.count) return this.failTimeout(); if (o && s && i) { if (t.eventType != Pt) return this.failTimeout(); var r = !this.pTime || t.timeStamp - this.pTime < e.interval,
                        a = !this.pCenter || D(this.pCenter, t.center) < e.posThreshold; if (this.pTime = t.timeStamp, this.pCenter = t.center, a && r ? this.count += 1 : this.count = 1, this._input = t, 0 === this.count % e.taps) return this.hasRequireFailures() ? (this._timer = n(function() { this.state = de, this.tryEmit() }, e.interval, this), he) : de } return 32 }, failTimeout: function() { return this._timer = n(function() { this.state = 32 }, this.options.interval, this), 32 }, reset: function() { clearTimeout(this._timer) }, emit: function() { this.state == de && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)) } }), rt.VERSION = "2.0.7", rt.defaults = { domEvents: !1, touchAction: "compute", enable: !0, inputTarget: null, inputClass: null, preset: [
                [ot, { enable: !1 }],
                [et, { enable: !1 },
                    ["rotate"]
                ],
                [nt, { direction: Lt }],
                [tt, { direction: Lt },
                    ["swipe"]
                ],
                [st],
                [st, { event: "doubletap", taps: 2 },
                    ["tap"]
                ],
                [it]
            ], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } };
        at.prototype = { set: function(t) { return ct(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this }, stop: function(t) { this.session.stopped = t ? 2 : 1 }, recognize: function(t) { var e = this.session; if (!e.stopped) { this.touchAction.preventDefaults(t); var i, o = this.recognizers,
                        n = e.curRecognizer;
                    (!n || n && n.state & de) && (n = e.curRecognizer = null); for (var s = 0; s < o.length;) i = o[s], 2 === e.stopped || n && i != n && !i.canRecognizeWith(n) ? i.reset() : i.recognize(t), !n && i.state & (he | le | ce) && (n = e.curRecognizer = i), s++ } }, get: function(t) { if (t instanceof Y) return t; for (var e = this.recognizers, i = 0; i < e.length; i++)
                    if (e[i].options.event == t) return e[i]; return null }, add: function(t) { if (s(t, "add", this)) return this; var e = this.get(t.options.event); return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t }, remove: function(t) { if (s(t, "remove", this)) return this; if (t = this.get(t)) { var e = this.recognizers,
                        i = b(e, t); - 1 !== i && (e.splice(i, 1), this.touchAction.update()) } return this }, on: function(t, e) { if (t !== o && e !== o) { var i = this.handlers; return r(y(t), function(t) { i[t] = i[t] || [], i[t].push(e) }), this } }, off: function(t, e) { if (t !== o) { var i = this.handlers; return r(y(t), function(t) { e ? i[t] && i[t].splice(b(i[t], e), 1) : delete i[t] }), this } }, emit: function(t, e) { this.options.domEvents && lt(t, e); var i = this.handlers[t] && this.handlers[t].slice(); if (i && i.length) { e.type = t, e.preventDefault = function() { e.srcEvent.preventDefault() }; for (var o = 0; o < i.length;) i[o](e), o++ } }, destroy: function() { this.element && ht(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null } }, ct(rt, { INPUT_START: At, INPUT_MOVE: Tt, INPUT_END: Pt, INPUT_CANCEL: kt, STATE_POSSIBLE: ae, STATE_BEGAN: he, STATE_CHANGED: le, STATE_ENDED: ce, STATE_RECOGNIZED: de, STATE_CANCELLED: ue, STATE_FAILED: 32, DIRECTION_NONE: Mt, DIRECTION_LEFT: Et, DIRECTION_RIGHT: Bt, DIRECTION_UP: It, DIRECTION_DOWN: Dt, DIRECTION_HORIZONTAL: Lt, DIRECTION_VERTICAL: Ot, DIRECTION_ALL: Rt, Manager: at, Input: C, TouchAction: J, TouchInput: N, MouseInput: F, PointerEventInput: V, TouchMouseInput: W, SingleTouchInput: G, Recognizer: Y, AttrRecognizer: $, Tap: st, Pan: tt, Swipe: nt, Pinch: et, Rotate: ot, Press: it, on: u, off: p, each: r, merge: gt, extend: bt, assign: ct, inherit: h, bindFn: l, prefixed: v }), (void 0 !== t ? t : "undefined" != typeof self ? self : {}).Hammer = rt, "function" == typeof define && define.amd ? define(function() { return rt }) : "undefined" != typeof module && module.exports ? module.exports = rt : t.Hammer = rt }(window, document),
    function() { "use strict"; var t = function() { this.init() };
        t.prototype = { init: function() { var t = this || e; return t._counter = 1e3, t._html5AudioPool = [], t.html5PoolSize = 10, t._codecs = {}, t._howls = [], t._muted = !1, t._volume = 1, t._canPlayEvent = "canplaythrough", t._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, t.masterGain = null, t.noAudio = !1, t.usingWebAudio = !0, t.autoSuspend = !0, t.ctx = null, t.autoUnlock = !0, t._setup(), t }, volume: function(t) { var i = this || e; if (t = parseFloat(t), i.ctx || l(), void 0 !== t && t >= 0 && t <= 1) { if (i._volume = t, i._muted) return i;
                    i.usingWebAudio && i.masterGain.gain.setValueAtTime(t, e.ctx.currentTime); for (var o = 0; o < i._howls.length; o++)
                        if (!i._howls[o]._webAudio)
                            for (var n = i._howls[o]._getSoundIds(), s = 0; s < n.length; s++) { var r = i._howls[o]._soundById(n[s]);
                                r && r._node && (r._node.volume = r._volume * t) }
                    return i } return i._volume }, mute: function(t) { var i = this || e;
                i.ctx || l(), i._muted = t, i.usingWebAudio && i.masterGain.gain.setValueAtTime(t ? 0 : i._volume, e.ctx.currentTime); for (var o = 0; o < i._howls.length; o++)
                    if (!i._howls[o]._webAudio)
                        for (var n = i._howls[o]._getSoundIds(), s = 0; s < n.length; s++) { var r = i._howls[o]._soundById(n[s]);
                            r && r._node && (r._node.muted = !!t || r._muted) }
                return i }, unload: function() { for (var t = this || e, i = t._howls.length - 1; i >= 0; i--) t._howls[i].unload(); return t.usingWebAudio && t.ctx && void 0 !== t.ctx.close && (t.ctx.close(), t.ctx = null, l()), t }, codecs: function(t) { return (this || e)._codecs[t.replace(/^x-/, "")] }, _setup: function() { var t = this || e; if (t.state = t.ctx ? t.ctx.state || "suspended" : "suspended", t._autoSuspend(), !t.usingWebAudio)
                    if ("undefined" != typeof Audio) try { void 0 === (i = new Audio).oncanplaythrough && (t._canPlayEvent = "canplay") } catch (e) { t.noAudio = !0 } else t.noAudio = !0; try { var i = new Audio;
                    i.muted && (t.noAudio = !0) } catch (t) {} return t.noAudio || t._setupCodecs(), t }, _setupCodecs: function() { var t = this || e,
                    i = null; try { i = "undefined" != typeof Audio ? new Audio : null } catch (e) { return t } if (!i || "function" != typeof i.canPlayType) return t; var o = i.canPlayType("audio/mpeg;").replace(/^no$/, ""),
                    n = t._navigator && t._navigator.userAgent.match(/OPR\/([0-6].)/g),
                    s = n && parseInt(n[0].split("/")[1], 10) < 33; return t._codecs = { mp3: !(s || !o && !i.canPlayType("audio/mp3;").replace(/^no$/, "")), mpeg: !!o, opus: !!i.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""), ogg: !!i.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), oga: !!i.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), wav: !!i.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""), aac: !!i.canPlayType("audio/aac;").replace(/^no$/, ""), caf: !!i.canPlayType("audio/x-caf;").replace(/^no$/, ""), m4a: !!(i.canPlayType("audio/x-m4a;") || i.canPlayType("audio/m4a;") || i.canPlayType("audio/aac;")).replace(/^no$/, ""), mp4: !!(i.canPlayType("audio/x-mp4;") || i.canPlayType("audio/mp4;") || i.canPlayType("audio/aac;")).replace(/^no$/, ""), weba: !!i.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""), webm: !!i.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""), dolby: !!i.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""), flac: !!(i.canPlayType("audio/x-flac;") || i.canPlayType("audio/flac;")).replace(/^no$/, "") }, t }, _unlockAudio: function() { var t = this || e; if (!t._audioUnlocked && t.ctx) { t._audioUnlocked = !1, t.autoUnlock = !1, t._mobileUnloaded || 44100 === t.ctx.sampleRate || (t._mobileUnloaded = !0, t.unload()), t._scratchBuffer = t.ctx.createBuffer(1, 1, 22050); var i = function(e) { for (n = 0; n < t.html5PoolSize; n++) try { var o = new Audio;
                            o._unlocked = !0, t._releaseHtml5Audio(o) } catch (e) { t.noAudio = !0 }
                        for (var n = 0; n < t._howls.length; n++)
                            if (!t._howls[n]._webAudio)
                                for (var s = t._howls[n]._getSoundIds(), r = 0; r < s.length; r++) { var a = t._howls[n]._soundById(s[r]);
                                    a && a._node && !a._node._unlocked && (a._node._unlocked = !0, a._node.load()) } t._autoResume(); var h = t.ctx.createBufferSource();
                        h.buffer = t._scratchBuffer, h.connect(t.ctx.destination), void 0 === h.start ? h.noteOn(0) : h.start(0), "function" == typeof t.ctx.resume && t.ctx.resume(), h.onended = function() { h.disconnect(0), t._audioUnlocked = !0, document.removeEventListener("touchstart", i, !0), document.removeEventListener("touchend", i, !0), document.removeEventListener("click", i, !0); for (var e = 0; e < t._howls.length; e++) t._howls[e]._emit("unlock") } }; return document.addEventListener("touchstart", i, !0), document.addEventListener("touchend", i, !0), document.addEventListener("click", i, !0), t } }, _obtainHtml5Audio: function() { var t = this || e; if (t._html5AudioPool.length) return t._html5AudioPool.pop(); var i = (new Audio).play(); return i && "undefined" != typeof Promise && (i instanceof Promise || "function" == typeof i.then) && i.catch(function() {}), new Audio }, _releaseHtml5Audio: function(t) { var i = this || e; return t._unlocked && i._html5AudioPool.push(t), i }, _autoSuspend: function() { var t = this; if (t.autoSuspend && t.ctx && void 0 !== t.ctx.suspend && e.usingWebAudio) { for (var i = 0; i < t._howls.length; i++)
                        if (t._howls[i]._webAudio)
                            for (var o = 0; o < t._howls[i]._sounds.length; o++)
                                if (!t._howls[i]._sounds[o]._paused) return t; return t._suspendTimer && clearTimeout(t._suspendTimer), t._suspendTimer = setTimeout(function() { t.autoSuspend && (t._suspendTimer = null, t.state = "suspending", t.ctx.suspend().then(function() { t.state = "suspended", t._resumeAfterSuspend && (delete t._resumeAfterSuspend, t._autoResume()) })) }, 3e4), t } }, _autoResume: function() { var t = this; if (t.ctx && void 0 !== t.ctx.resume && e.usingWebAudio) return "running" === t.state && t._suspendTimer ? (clearTimeout(t._suspendTimer), t._suspendTimer = null) : "suspended" === t.state ? (t.ctx.resume().then(function() { t.state = "running"; for (var e = 0; e < t._howls.length; e++) t._howls[e]._emit("resume") }), t._suspendTimer && (clearTimeout(t._suspendTimer), t._suspendTimer = null)) : "suspending" === t.state && (t._resumeAfterSuspend = !0), t } }; var e = new t,
            i = function(t) { var e = this;
                t.src && 0 !== t.src.length && e.init(t) };
        i.prototype = { init: function(t) { var i = this; return e.ctx || l(), i._autoplay = t.autoplay || !1, i._format = "string" != typeof t.format ? t.format : [t.format], i._html5 = t.html5 || !1, i._muted = t.mute || !1, i._loop = t.loop || !1, i._pool = t.pool || 5, i._preload = "boolean" != typeof t.preload || t.preload, i._rate = t.rate || 1, i._sprite = t.sprite || {}, i._src = "string" != typeof t.src ? t.src : [t.src], i._volume = void 0 !== t.volume ? t.volume : 1, i._xhrWithCredentials = t.xhrWithCredentials || !1, i._duration = 0, i._state = "unloaded", i._sounds = [], i._endTimers = {}, i._queue = [], i._playLock = !1, i._onend = t.onend ? [{ fn: t.onend }] : [], i._onfade = t.onfade ? [{ fn: t.onfade }] : [], i._onload = t.onload ? [{ fn: t.onload }] : [], i._onloaderror = t.onloaderror ? [{ fn: t.onloaderror }] : [], i._onplayerror = t.onplayerror ? [{ fn: t.onplayerror }] : [], i._onpause = t.onpause ? [{ fn: t.onpause }] : [], i._onplay = t.onplay ? [{ fn: t.onplay }] : [], i._onstop = t.onstop ? [{ fn: t.onstop }] : [], i._onmute = t.onmute ? [{ fn: t.onmute }] : [], i._onvolume = t.onvolume ? [{ fn: t.onvolume }] : [], i._onrate = t.onrate ? [{ fn: t.onrate }] : [], i._onseek = t.onseek ? [{ fn: t.onseek }] : [], i._onunlock = t.onunlock ? [{ fn: t.onunlock }] : [], i._onresume = [], i._webAudio = e.usingWebAudio && !i._html5, void 0 !== e.ctx && e.ctx && e.autoUnlock && e._unlockAudio(), e._howls.push(i), i._autoplay && i._queue.push({ event: "play", action: function() { i.play() } }), i._preload && i.load(), i }, load: function() { var t = this,
                    i = null; if (e.noAudio) t._emit("loaderror", null, "No audio support.");
                else { "string" == typeof t._src && (t._src = [t._src]); for (var n = 0; n < t._src.length; n++) { var r, a; if (t._format && t._format[n]) r = t._format[n];
                        else { if ("string" != typeof(a = t._src[n])) { t._emit("loaderror", null, "Non-string found in selected audio sources - ignoring."); continue }(r = /^data:audio\/([^;,]+);/i.exec(a)) || (r = /\.([^.]+)$/.exec(a.split("?", 1)[0])), r && (r = r[1].toLowerCase()) } if (r && e.codecs(r)) { i = t._src[n]; break } } if (i) return t._src = i, t._state = "loading", "https:" === window.location.protocol && "http:" === i.slice(0, 5) && (t._html5 = !0, t._webAudio = !1), new o(t), t._webAudio && s(t), t;
                    t._emit("loaderror", null, "No codec support for selected audio sources.") } }, play: function(t, i) { var o = this,
                    n = null; if ("number" == typeof t) n = t, t = null;
                else { if ("string" == typeof t && "loaded" === o._state && !o._sprite[t]) return null; if (void 0 === t && (t = "__default", !o._playLock)) { for (var s = 0, r = 0; r < o._sounds.length; r++) o._sounds[r]._paused && !o._sounds[r]._ended && (s++, n = o._sounds[r]._id);
                        1 === s ? t = null : n = null } } var a = n ? o._soundById(n) : o._inactiveSound(); if (!a) return null; if (n && !t && (t = a._sprite || "__default"), "loaded" !== o._state) { a._sprite = t, a._ended = !1; var h = a._id; return o._queue.push({ event: "play", action: function() { o.play(h) } }), h } if (n && !a._paused) return i || o._loadQueue("play"), a._id;
                o._webAudio && e._autoResume(); var l = Math.max(0, a._seek > 0 ? a._seek : o._sprite[t][0] / 1e3),
                    c = Math.max(0, (o._sprite[t][0] + o._sprite[t][1]) / 1e3 - l),
                    d = 1e3 * c / Math.abs(a._rate),
                    u = o._sprite[t][0] / 1e3,
                    p = (o._sprite[t][0] + o._sprite[t][1]) / 1e3,
                    m = !(!a._loop && !o._sprite[t][2]);
                a._sprite = t, a._ended = !1; var f = function() { a._paused = !1, a._seek = l, a._start = u, a._stop = p, a._loop = m }; if (!(l >= p)) { var y = a._node; if (o._webAudio) { var b = function() { o._playLock = !1, f(), o._refreshBuffer(a); var t = a._muted || o._muted ? 0 : a._volume;
                            y.gain.setValueAtTime(t, e.ctx.currentTime), a._playStart = e.ctx.currentTime, void 0 === y.bufferSource.start ? a._loop ? y.bufferSource.noteGrainOn(0, l, 86400) : y.bufferSource.noteGrainOn(0, l, c) : a._loop ? y.bufferSource.start(0, l, 86400) : y.bufferSource.start(0, l, c), d !== 1 / 0 && (o._endTimers[a._id] = setTimeout(o._ended.bind(o, a), d)), i || setTimeout(function() { o._emit("play", a._id), o._loadQueue() }, 0) }; "running" === e.state ? b() : (o._playLock = !0, o.once("resume", b), o._clearTimer(a._id)) } else { var g = function() { y.currentTime = l, y.muted = a._muted || o._muted || e._muted || y.muted, y.volume = a._volume * e.volume(), y.playbackRate = a._rate; try { var n = y.play(); if (n && "undefined" != typeof Promise && (n instanceof Promise || "function" == typeof n.then) ? (o._playLock = !0, f(), n.then(function() { o._playLock = !1, y._unlocked = !0, i || (o._emit("play", a._id), o._loadQueue()) }).catch(function() { o._playLock = !1, o._emit("playerror", a._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), a._ended = !0, a._paused = !0 })) : i || (o._playLock = !1, f(), o._emit("play", a._id), o._loadQueue()), y.playbackRate = a._rate, y.paused) return void o._emit("playerror", a._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."); "__default" !== t || a._loop ? o._endTimers[a._id] = setTimeout(o._ended.bind(o, a), d) : (o._endTimers[a._id] = function() { o._ended(a), y.removeEventListener("ended", o._endTimers[a._id], !1) }, y.addEventListener("ended", o._endTimers[a._id], !1)) } catch (t) { o._emit("playerror", a._id, t) } }; "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === y.src && (y.src = o._src, y.load()); var _ = window && window.ejecta || !y.readyState && e._navigator.isCocoonJS; if (y.readyState >= 3 || _) g();
                        else { o._playLock = !0; var v = function() { g(), y.removeEventListener(e._canPlayEvent, v, !1) };
                            y.addEventListener(e._canPlayEvent, v, !1), o._clearTimer(a._id) } } return a._id } o._ended(a) }, pause: function(t) { var e = this; if ("loaded" !== e._state || e._playLock) return e._queue.push({ event: "pause", action: function() { e.pause(t) } }), e; for (var i = e._getSoundIds(t), o = 0; o < i.length; o++) { e._clearTimer(i[o]); var n = e._soundById(i[o]); if (n && !n._paused && (n._seek = e.seek(i[o]), n._rateSeek = 0, n._paused = !0, e._stopFade(i[o]), n._node))
                        if (e._webAudio) { if (!n._node.bufferSource) continue;
                            void 0 === n._node.bufferSource.stop ? n._node.bufferSource.noteOff(0) : n._node.bufferSource.stop(0), e._cleanBuffer(n._node) } else isNaN(n._node.duration) && n._node.duration !== 1 / 0 || n._node.pause();
                    arguments[1] || e._emit("pause", n ? n._id : null) } return e }, stop: function(t, e) { var i = this; if ("loaded" !== i._state || i._playLock) return i._queue.push({ event: "stop", action: function() { i.stop(t) } }), i; for (var o = i._getSoundIds(t), n = 0; n < o.length; n++) { i._clearTimer(o[n]); var s = i._soundById(o[n]);
                    s && (s._seek = s._start || 0, s._rateSeek = 0, s._paused = !0, s._ended = !0, i._stopFade(o[n]), s._node && (i._webAudio ? s._node.bufferSource && (void 0 === s._node.bufferSource.stop ? s._node.bufferSource.noteOff(0) : s._node.bufferSource.stop(0), i._cleanBuffer(s._node)) : isNaN(s._node.duration) && s._node.duration !== 1 / 0 || (s._node.currentTime = s._start || 0, s._node.pause(), s._node.duration === 1 / 0 && i._clearSound(s._node))), e || i._emit("stop", s._id)) } return i }, mute: function(t, i) { var o = this; if ("loaded" !== o._state || o._playLock) return o._queue.push({ event: "mute", action: function() { o.mute(t, i) } }), o; if (void 0 === i) { if ("boolean" != typeof t) return o._muted;
                    o._muted = t } for (var n = o._getSoundIds(i), s = 0; s < n.length; s++) { var r = o._soundById(n[s]);
                    r && (r._muted = t, r._interval && o._stopFade(r._id), o._webAudio && r._node ? r._node.gain.setValueAtTime(t ? 0 : r._volume, e.ctx.currentTime) : r._node && (r._node.muted = !!e._muted || t), o._emit("mute", r._id)) } return o }, volume: function() { var t, i, o = this,
                    n = arguments; if (0 === n.length) return o._volume;
                1 === n.length || 2 === n.length && void 0 === n[1] ? o._getSoundIds().indexOf(n[0]) >= 0 ? i = parseInt(n[0], 10) : t = parseFloat(n[0]) : n.length >= 2 && (t = parseFloat(n[0]), i = parseInt(n[1], 10)); var s; if (!(void 0 !== t && t >= 0 && t <= 1)) return (s = i ? o._soundById(i) : o._sounds[0]) ? s._volume : 0; if ("loaded" !== o._state || o._playLock) return o._queue.push({ event: "volume", action: function() { o.volume.apply(o, n) } }), o;
                void 0 === i && (o._volume = t), i = o._getSoundIds(i); for (var r = 0; r < i.length; r++)(s = o._soundById(i[r])) && (s._volume = t, n[2] || o._stopFade(i[r]), o._webAudio && s._node && !s._muted ? s._node.gain.setValueAtTime(t, e.ctx.currentTime) : s._node && !s._muted && (s._node.volume = t * e.volume()), o._emit("volume", s._id)); return o }, fade: function(t, i, o, n) { var s = this; if ("loaded" !== s._state || s._playLock) return s._queue.push({ event: "fade", action: function() { s.fade(t, i, o, n) } }), s;
                t = parseFloat(t), i = parseFloat(i), o = parseFloat(o), s.volume(t, n); for (var r = s._getSoundIds(n), a = 0; a < r.length; a++) { var h = s._soundById(r[a]); if (h) { if (n || s._stopFade(r[a]), s._webAudio && !h._muted) { var l = e.ctx.currentTime,
                                c = l + o / 1e3;
                            h._volume = t, h._node.gain.setValueAtTime(t, l), h._node.gain.linearRampToValueAtTime(i, c) } s._startFadeInterval(h, t, i, o, r[a], void 0 === n) } } return s }, _startFadeInterval: function(t, e, i, o, n, s) { var r = this,
                    a = e,
                    h = i - e,
                    l = Math.abs(h / .01),
                    c = Math.max(4, l > 0 ? o / l : o),
                    d = Date.now();
                t._fadeTo = i, t._interval = setInterval(function() { var n = (Date.now() - d) / o;
                    d = Date.now(), a += h * n, a = Math.max(0, a), a = Math.min(1, a), a = Math.round(100 * a) / 100, r._webAudio ? t._volume = a : r.volume(a, t._id, !0), s && (r._volume = a), (i < e && a <= i || i > e && a >= i) && (clearInterval(t._interval), t._interval = null, t._fadeTo = null, r.volume(i, t._id), r._emit("fade", t._id)) }, c) }, _stopFade: function(t) { var i = this,
                    o = i._soundById(t); return o && o._interval && (i._webAudio && o._node.gain.cancelScheduledValues(e.ctx.currentTime), clearInterval(o._interval), o._interval = null, i.volume(o._fadeTo, t), o._fadeTo = null, i._emit("fade", t)), i }, loop: function() { var t, e, i, o = this,
                    n = arguments; if (0 === n.length) return o._loop; if (1 === n.length) { if ("boolean" != typeof n[0]) return !!(i = o._soundById(parseInt(n[0], 10))) && i._loop;
                    t = n[0], o._loop = t } else 2 === n.length && (t = n[0], e = parseInt(n[1], 10)); for (var s = o._getSoundIds(e), r = 0; r < s.length; r++)(i = o._soundById(s[r])) && (i._loop = t, o._webAudio && i._node && i._node.bufferSource && (i._node.bufferSource.loop = t, t && (i._node.bufferSource.loopStart = i._start || 0, i._node.bufferSource.loopEnd = i._stop))); return o }, rate: function() { var t, i, o = this,
                    n = arguments;
                0 === n.length ? i = o._sounds[0]._id : 1 === n.length ? o._getSoundIds().indexOf(n[0]) >= 0 ? i = parseInt(n[0], 10) : t = parseFloat(n[0]) : 2 === n.length && (t = parseFloat(n[0]), i = parseInt(n[1], 10)); var s; if ("number" != typeof t) return (s = o._soundById(i)) ? s._rate : o._rate; if ("loaded" !== o._state || o._playLock) return o._queue.push({ event: "rate", action: function() { o.rate.apply(o, n) } }), o;
                void 0 === i && (o._rate = t), i = o._getSoundIds(i); for (var r = 0; r < i.length; r++)
                    if (s = o._soundById(i[r])) { o.playing(i[r]) && (s._rateSeek = o.seek(i[r]), s._playStart = o._webAudio ? e.ctx.currentTime : s._playStart), s._rate = t, o._webAudio && s._node && s._node.bufferSource ? s._node.bufferSource.playbackRate.setValueAtTime(t, e.ctx.currentTime) : s._node && (s._node.playbackRate = t); var a = o.seek(i[r]),
                            h = 1e3 * ((o._sprite[s._sprite][0] + o._sprite[s._sprite][1]) / 1e3 - a) / Math.abs(s._rate);!o._endTimers[i[r]] && s._paused || (o._clearTimer(i[r]), o._endTimers[i[r]] = setTimeout(o._ended.bind(o, s), h)), o._emit("rate", s._id) } return o }, seek: function() { var t, i, o = this,
                    n = arguments; if (0 === n.length ? i = o._sounds[0]._id : 1 === n.length ? o._getSoundIds().indexOf(n[0]) >= 0 ? i = parseInt(n[0], 10) : o._sounds.length && (i = o._sounds[0]._id, t = parseFloat(n[0])) : 2 === n.length && (t = parseFloat(n[0]), i = parseInt(n[1], 10)), void 0 === i) return o; if ("loaded" !== o._state || o._playLock) return o._queue.push({ event: "seek", action: function() { o.seek.apply(o, n) } }), o; var s = o._soundById(i); if (s) { if (!("number" == typeof t && t >= 0)) { if (o._webAudio) { var r = o.playing(i) ? e.ctx.currentTime - s._playStart : 0,
                                a = s._rateSeek ? s._rateSeek - s._seek : 0; return s._seek + (a + r * Math.abs(s._rate)) } return s._node.currentTime } var h = o.playing(i);
                    h && o.pause(i, !0), s._seek = t, s._ended = !1, o._clearTimer(i), o._webAudio || !s._node || isNaN(s._node.duration) || (s._node.currentTime = t); var l = function() { o._emit("seek", i), h && o.play(i, !0) }; if (h && !o._webAudio) { var c = function() { o._playLock ? setTimeout(c, 0) : l() };
                        setTimeout(c, 0) } else l() } return o }, playing: function(t) { var e = this; if ("number" == typeof t) { var i = e._soundById(t); return !!i && !i._paused } for (var o = 0; o < e._sounds.length; o++)
                    if (!e._sounds[o]._paused) return !0; return !1 }, duration: function(t) { var e = this,
                    i = e._duration,
                    o = e._soundById(t); return o && (i = e._sprite[o._sprite][1] / 1e3), i }, state: function() { return this._state }, unload: function() { for (var t = this, i = t._sounds, o = 0; o < i.length; o++) i[o]._paused || t.stop(i[o]._id), t._webAudio || (t._clearSound(i[o]._node), i[o]._node.removeEventListener("error", i[o]._errorFn, !1), i[o]._node.removeEventListener(e._canPlayEvent, i[o]._loadFn, !1), e._releaseHtml5Audio(i[o]._node)), delete i[o]._node, t._clearTimer(i[o]._id); var s = e._howls.indexOf(t);
                s >= 0 && e._howls.splice(s, 1); var r = !0; for (o = 0; o < e._howls.length; o++)
                    if (e._howls[o]._src === t._src || t._src.indexOf(e._howls[o]._src) >= 0) { r = !1; break } return n && r && delete n[t._src], e.noAudio = !1, t._state = "unloaded", t._sounds = [], t = null, null }, on: function(t, e, i, o) { var n = this,
                    s = n["_on" + t]; return "function" == typeof e && s.push(o ? { id: i, fn: e, once: o } : { id: i, fn: e }), n }, off: function(t, e, i) { var o = this,
                    n = o["_on" + t],
                    s = 0; if ("number" == typeof e && (i = e, e = null), e || i)
                    for (s = 0; s < n.length; s++) { var r = i === n[s].id; if (e === n[s].fn && r || !e && r) { n.splice(s, 1); break } } else if (t) o["_on" + t] = [];
                    else { var a = Object.keys(o); for (s = 0; s < a.length; s++) 0 === a[s].indexOf("_on") && Array.isArray(o[a[s]]) && (o[a[s]] = []) } return o }, once: function(t, e, i) { var o = this; return o.on(t, e, i, 1), o }, _emit: function(t, e, i) { for (var o = this, n = o["_on" + t], s = n.length - 1; s >= 0; s--) n[s].id && n[s].id !== e && "load" !== t || (setTimeout(function(t) { t.call(this, e, i) }.bind(o, n[s].fn), 0), n[s].once && o.off(t, n[s].fn, n[s].id)); return o._loadQueue(t), o }, _loadQueue: function(t) { var e = this; if (e._queue.length > 0) { var i = e._queue[0];
                    i.event === t && (e._queue.shift(), e._loadQueue()), t || i.action() } return e }, _ended: function(t) { var i = this,
                    o = t._sprite; if (!i._webAudio && t._node && !t._node.paused && !t._node.ended && t._node.currentTime < t._stop) return setTimeout(i._ended.bind(i, t), 100), i; var n = !(!t._loop && !i._sprite[o][2]); if (i._emit("end", t._id), !i._webAudio && n && i.stop(t._id, !0).play(t._id), i._webAudio && n) { i._emit("play", t._id), t._seek = t._start || 0, t._rateSeek = 0, t._playStart = e.ctx.currentTime; var s = 1e3 * (t._stop - t._start) / Math.abs(t._rate);
                    i._endTimers[t._id] = setTimeout(i._ended.bind(i, t), s) } return i._webAudio && !n && (t._paused = !0, t._ended = !0, t._seek = t._start || 0, t._rateSeek = 0, i._clearTimer(t._id), i._cleanBuffer(t._node), e._autoSuspend()), i._webAudio || n || i.stop(t._id, !0), i }, _clearTimer: function(t) { var e = this; if (e._endTimers[t]) { if ("function" != typeof e._endTimers[t]) clearTimeout(e._endTimers[t]);
                    else { var i = e._soundById(t);
                        i && i._node && i._node.removeEventListener("ended", e._endTimers[t], !1) } delete e._endTimers[t] } return e }, _soundById: function(t) { for (var e = this, i = 0; i < e._sounds.length; i++)
                    if (t === e._sounds[i]._id) return e._sounds[i]; return null }, _inactiveSound: function() { var t = this;
                t._drain(); for (var e = 0; e < t._sounds.length; e++)
                    if (t._sounds[e]._ended) return t._sounds[e].reset(); return new o(t) }, _drain: function() { var t = this,
                    e = t._pool,
                    i = 0,
                    o = 0; if (!(t._sounds.length < e)) { for (o = 0; o < t._sounds.length; o++) t._sounds[o]._ended && i++; for (o = t._sounds.length - 1; o >= 0; o--) { if (i <= e) return;
                        t._sounds[o]._ended && (t._webAudio && t._sounds[o]._node && t._sounds[o]._node.disconnect(0), t._sounds.splice(o, 1), i--) } } }, _getSoundIds: function(t) { var e = this; if (void 0 === t) { for (var i = [], o = 0; o < e._sounds.length; o++) i.push(e._sounds[o]._id); return i } return [t] }, _refreshBuffer: function(t) { var i = this; return t._node.bufferSource = e.ctx.createBufferSource(), t._node.bufferSource.buffer = n[i._src], t._panner ? t._node.bufferSource.connect(t._panner) : t._node.bufferSource.connect(t._node), t._node.bufferSource.loop = t._loop, t._loop && (t._node.bufferSource.loopStart = t._start || 0, t._node.bufferSource.loopEnd = t._stop || 0), t._node.bufferSource.playbackRate.setValueAtTime(t._rate, e.ctx.currentTime), i }, _cleanBuffer: function(t) { var i = this,
                    o = e._navigator && e._navigator.vendor.indexOf("Apple") >= 0; if (e._scratchBuffer && t.bufferSource && (t.bufferSource.onended = null, t.bufferSource.disconnect(0), o)) try { t.bufferSource.buffer = e._scratchBuffer } catch (t) {}
                return t.bufferSource = null, i }, _clearSound: function(t) { /MSIE |Trident\//.test(e._navigator && e._navigator.userAgent) || (t.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") } }; var o = function(t) { this._parent = t, this.init() };
        o.prototype = { init: function() { var t = this,
                    i = t._parent; return t._muted = i._muted, t._loop = i._loop, t._volume = i._volume, t._rate = i._rate, t._seek = 0, t._paused = !0, t._ended = !0, t._sprite = "__default", t._id = ++e._counter, i._sounds.push(t), t.create(), t }, create: function() { var t = this,
                    i = t._parent,
                    o = e._muted || t._muted || t._parent._muted ? 0 : t._volume; return i._webAudio ? (t._node = void 0 === e.ctx.createGain ? e.ctx.createGainNode() : e.ctx.createGain(), t._node.gain.setValueAtTime(o, e.ctx.currentTime), t._node.paused = !0, t._node.connect(e.masterGain)) : (t._node = e._obtainHtml5Audio(), t._errorFn = t._errorListener.bind(t), t._node.addEventListener("error", t._errorFn, !1), t._loadFn = t._loadListener.bind(t), t._node.addEventListener(e._canPlayEvent, t._loadFn, !1), t._node.src = i._src, t._node.preload = "auto", t._node.volume = o * e.volume(), t._node.load()), t }, reset: function() { var t = this,
                    i = t._parent; return t._muted = i._muted, t._loop = i._loop, t._volume = i._volume, t._rate = i._rate, t._seek = 0, t._rateSeek = 0, t._paused = !0, t._ended = !0, t._sprite = "__default", t._id = ++e._counter, t }, _errorListener: function() { var t = this;
                t._parent._emit("loaderror", t._id, t._node.error ? t._node.error.code : 0), t._node.removeEventListener("error", t._errorFn, !1) }, _loadListener: function() { var t = this,
                    i = t._parent;
                i._duration = Math.ceil(10 * t._node.duration) / 10, 0 === Object.keys(i._sprite).length && (i._sprite = { __default: [0, 1e3 * i._duration] }), "loaded" !== i._state && (i._state = "loaded", i._emit("load"), i._loadQueue()), t._node.removeEventListener(e._canPlayEvent, t._loadFn, !1) } }; var n = {},
            s = function(t) { var e = t._src; if (n[e]) return t._duration = n[e].duration, void h(t); if (/^data:[^;]+;base64,/.test(e)) { for (var i = atob(e.split(",")[1]), o = new Uint8Array(i.length), s = 0; s < i.length; ++s) o[s] = i.charCodeAt(s);
                    a(o.buffer, t) } else { var l = new XMLHttpRequest;
                    l.open("GET", e, !0), l.withCredentials = t._xhrWithCredentials, l.responseType = "arraybuffer", l.onload = function() { var e = (l.status + "")[0]; "0" === e || "2" === e || "3" === e ? a(l.response, t) : t._emit("loaderror", null, "Failed loading audio file with status: " + l.status + ".") }, l.onerror = function() { t._webAudio && (t._html5 = !0, t._webAudio = !1, t._sounds = [], delete n[e], t.load()) }, r(l) } },
            r = function(t) { try { t.send() } catch (e) { t.onerror() } },
            a = function(t, i) { var o = function() { i._emit("loaderror", null, "Decoding audio data failed.") },
                    s = function(t) { t && i._sounds.length > 0 ? (n[i._src] = t, h(i, t)) : o() }; "undefined" != typeof Promise && 1 === e.ctx.decodeAudioData.length ? e.ctx.decodeAudioData(t).then(s).catch(o) : e.ctx.decodeAudioData(t, s, o) },
            h = function(t, e) { e && !t._duration && (t._duration = e.duration), 0 === Object.keys(t._sprite).length && (t._sprite = { __default: [0, 1e3 * t._duration] }), "loaded" !== t._state && (t._state = "loaded", t._emit("load"), t._loadQueue()) },
            l = function() { if (e.usingWebAudio) { try { "undefined" != typeof AudioContext ? e.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? e.ctx = new webkitAudioContext : e.usingWebAudio = !1 } catch (t) { e.usingWebAudio = !1 } e.ctx || (e.usingWebAudio = !1); var t = /iP(hone|od|ad)/.test(e._navigator && e._navigator.platform),
                        i = e._navigator && e._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                        o = i ? parseInt(i[1], 10) : null; if (t && o && o < 9) { var n = /safari/.test(e._navigator && e._navigator.userAgent.toLowerCase());
                        (e._navigator && e._navigator.standalone && !n || e._navigator && !e._navigator.standalone && !n) && (e.usingWebAudio = !1) } e.usingWebAudio && (e.masterGain = void 0 === e.ctx.createGain ? e.ctx.createGainNode() : e.ctx.createGain(), e.masterGain.gain.setValueAtTime(e._muted ? 0 : 1, e.ctx.currentTime), e.masterGain.connect(e.ctx.destination)), e._setup() } }; "function" == typeof define && define.amd && define([], function() { return { Howler: e, Howl: i } }), "undefined" != typeof exports && (exports.Howler = e, exports.Howl = i), "undefined" != typeof window ? (window.HowlerGlobal = t, window.Howler = e, window.Howl = i, window.Sound = o) : "undefined" != typeof global && (global.HowlerGlobal = t, global.Howler = e, global.Howl = i, global.Sound = o) }(),
    function() { "use strict";
        HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function(t) { var e = this; if (!e.ctx || !e.ctx.listener) return e; for (var i = e._howls.length - 1; i >= 0; i--) e._howls[i].stereo(t); return e }, HowlerGlobal.prototype.pos = function(t, e, i) { var o = this; return o.ctx && o.ctx.listener ? (e = "number" != typeof e ? o._pos[1] : e, i = "number" != typeof i ? o._pos[2] : i, "number" != typeof t ? o._pos : (o._pos = [t, e, i], void 0 !== o.ctx.listener.positionX ? (o.ctx.listener.positionX.setTargetAtTime(o._pos[0], Howler.ctx.currentTime, .1), o.ctx.listener.positionY.setTargetAtTime(o._pos[1], Howler.ctx.currentTime, .1), o.ctx.listener.positionZ.setTargetAtTime(o._pos[2], Howler.ctx.currentTime, .1)) : o.ctx.listener.setPosition(o._pos[0], o._pos[1], o._pos[2]), o)) : o }, HowlerGlobal.prototype.orientation = function(t, e, i, o, n, s) { var r = this; if (!r.ctx || !r.ctx.listener) return r; var a = r._orientation; return e = "number" != typeof e ? a[1] : e, i = "number" != typeof i ? a[2] : i, o = "number" != typeof o ? a[3] : o, n = "number" != typeof n ? a[4] : n, s = "number" != typeof s ? a[5] : s, "number" != typeof t ? a : (r._orientation = [t, e, i, o, n, s], void 0 !== r.ctx.listener.forwardX ? (r.ctx.listener.forwardX.setTargetAtTime(t, Howler.ctx.currentTime, .1), r.ctx.listener.forwardY.setTargetAtTime(e, Howler.ctx.currentTime, .1), r.ctx.listener.forwardZ.setTargetAtTime(i, Howler.ctx.currentTime, .1), r.ctx.listener.upX.setTargetAtTime(t, Howler.ctx.currentTime, .1), r.ctx.listener.upY.setTargetAtTime(e, Howler.ctx.currentTime, .1), r.ctx.listener.upZ.setTargetAtTime(i, Howler.ctx.currentTime, .1)) : r.ctx.listener.setOrientation(t, e, i, o, n, s), r) }, Howl.prototype.init = function(t) { return function(e) { var i = this; return i._orientation = e.orientation || [1, 0, 0], i._stereo = e.stereo || null, i._pos = e.pos || null, i._pannerAttr = { coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : 360, coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : 360, coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : 0, distanceModel: void 0 !== e.distanceModel ? e.distanceModel : "inverse", maxDistance: void 0 !== e.maxDistance ? e.maxDistance : 1e4, panningModel: void 0 !== e.panningModel ? e.panningModel : "HRTF", refDistance: void 0 !== e.refDistance ? e.refDistance : 1, rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : 1 }, i._onstereo = e.onstereo ? [{ fn: e.onstereo }] : [], i._onpos = e.onpos ? [{ fn: e.onpos }] : [], i._onorientation = e.onorientation ? [{ fn: e.onorientation }] : [], t.call(this, e) } }(Howl.prototype.init), Howl.prototype.stereo = function(e, i) { var o = this; if (!o._webAudio) return o; if ("loaded" !== o._state) return o._queue.push({ event: "stereo", action: function() { o.stereo(e, i) } }), o; var n = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo"; if (void 0 === i) { if ("number" != typeof e) return o._stereo;
                o._stereo = e, o._pos = [e, 0, 0] } for (var s = o._getSoundIds(i), r = 0; r < s.length; r++) { var a = o._soundById(s[r]); if (a) { if ("number" != typeof e) return a._stereo;
                    a._stereo = e, a._pos = [e, 0, 0], a._node && (a._pannerAttr.panningModel = "equalpower", a._panner && a._panner.pan || t(a, n), "spatial" === n ? void 0 !== a._panner.positionX ? (a._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), a._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), a._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : a._panner.setPosition(e, 0, 0) : a._panner.pan.setValueAtTime(e, Howler.ctx.currentTime)), o._emit("stereo", a._id) } } return o }, Howl.prototype.pos = function(e, i, o, n) { var s = this; if (!s._webAudio) return s; if ("loaded" !== s._state) return s._queue.push({ event: "pos", action: function() { s.pos(e, i, o, n) } }), s; if (i = "number" != typeof i ? 0 : i, o = "number" != typeof o ? -.5 : o, void 0 === n) { if ("number" != typeof e) return s._pos;
                s._pos = [e, i, o] } for (var r = s._getSoundIds(n), a = 0; a < r.length; a++) { var h = s._soundById(r[a]); if (h) { if ("number" != typeof e) return h._pos;
                    h._pos = [e, i, o], h._node && (h._panner && !h._panner.pan || t(h, "spatial"), void 0 !== h._panner.positionX ? (h._panner.positionX.setValueAtTime(e, Howler.ctx.currentTime), h._panner.positionY.setValueAtTime(i, Howler.ctx.currentTime), h._panner.positionZ.setValueAtTime(o, Howler.ctx.currentTime)) : h._panner.setPosition(e, i, o)), s._emit("pos", h._id) } } return s }, Howl.prototype.orientation = function(e, i, o, n) { var s = this; if (!s._webAudio) return s; if ("loaded" !== s._state) return s._queue.push({ event: "orientation", action: function() { s.orientation(e, i, o, n) } }), s; if (i = "number" != typeof i ? s._orientation[1] : i, o = "number" != typeof o ? s._orientation[2] : o, void 0 === n) { if ("number" != typeof e) return s._orientation;
                s._orientation = [e, i, o] } for (var r = s._getSoundIds(n), a = 0; a < r.length; a++) { var h = s._soundById(r[a]); if (h) { if ("number" != typeof e) return h._orientation;
                    h._orientation = [e, i, o], h._node && (h._panner || (h._pos || (h._pos = s._pos || [0, 0, -.5]), t(h, "spatial")), void 0 !== h._panner.orientationX ? (h._panner.orientationX.setValueAtTime(e, Howler.ctx.currentTime), h._panner.orientationY.setValueAtTime(i, Howler.ctx.currentTime), h._panner.orientationZ.setValueAtTime(o, Howler.ctx.currentTime)) : h._panner.setOrientation(e, i, o)), s._emit("orientation", h._id) } } return s }, Howl.prototype.pannerAttr = function() { var e, i, o, n = this,
                s = arguments; if (!n._webAudio) return n; if (0 === s.length) return n._pannerAttr; if (1 === s.length) { if ("object" != typeof s[0]) return (o = n._soundById(parseInt(s[0], 10))) ? o._pannerAttr : n._pannerAttr;
                e = s[0], void 0 === i && (e.pannerAttr || (e.pannerAttr = { coneInnerAngle: e.coneInnerAngle, coneOuterAngle: e.coneOuterAngle, coneOuterGain: e.coneOuterGain, distanceModel: e.distanceModel, maxDistance: e.maxDistance, refDistance: e.refDistance, rolloffFactor: e.rolloffFactor, panningModel: e.panningModel }), n._pannerAttr = { coneInnerAngle: void 0 !== e.pannerAttr.coneInnerAngle ? e.pannerAttr.coneInnerAngle : n._coneInnerAngle, coneOuterAngle: void 0 !== e.pannerAttr.coneOuterAngle ? e.pannerAttr.coneOuterAngle : n._coneOuterAngle, coneOuterGain: void 0 !== e.pannerAttr.coneOuterGain ? e.pannerAttr.coneOuterGain : n._coneOuterGain, distanceModel: void 0 !== e.pannerAttr.distanceModel ? e.pannerAttr.distanceModel : n._distanceModel, maxDistance: void 0 !== e.pannerAttr.maxDistance ? e.pannerAttr.maxDistance : n._maxDistance, refDistance: void 0 !== e.pannerAttr.refDistance ? e.pannerAttr.refDistance : n._refDistance, rolloffFactor: void 0 !== e.pannerAttr.rolloffFactor ? e.pannerAttr.rolloffFactor : n._rolloffFactor, panningModel: void 0 !== e.pannerAttr.panningModel ? e.pannerAttr.panningModel : n._panningModel }) } else 2 === s.length && (e = s[0], i = parseInt(s[1], 10)); for (var r = n._getSoundIds(i), a = 0; a < r.length; a++)
                if (o = n._soundById(r[a])) { var h = o._pannerAttr;
                    h = { coneInnerAngle: void 0 !== e.coneInnerAngle ? e.coneInnerAngle : h.coneInnerAngle, coneOuterAngle: void 0 !== e.coneOuterAngle ? e.coneOuterAngle : h.coneOuterAngle, coneOuterGain: void 0 !== e.coneOuterGain ? e.coneOuterGain : h.coneOuterGain, distanceModel: void 0 !== e.distanceModel ? e.distanceModel : h.distanceModel, maxDistance: void 0 !== e.maxDistance ? e.maxDistance : h.maxDistance, refDistance: void 0 !== e.refDistance ? e.refDistance : h.refDistance, rolloffFactor: void 0 !== e.rolloffFactor ? e.rolloffFactor : h.rolloffFactor, panningModel: void 0 !== e.panningModel ? e.panningModel : h.panningModel }; var l = o._panner;
                    l ? (l.coneInnerAngle = h.coneInnerAngle, l.coneOuterAngle = h.coneOuterAngle, l.coneOuterGain = h.coneOuterGain, l.distanceModel = h.distanceModel, l.maxDistance = h.maxDistance, l.refDistance = h.refDistance, l.rolloffFactor = h.rolloffFactor, l.panningModel = h.panningModel) : (o._pos || (o._pos = n._pos || [0, 0, -.5]), t(o, "spatial")) } return n }, Sound.prototype.init = function(t) { return function() { var e = this,
                    i = e._parent;
                e._orientation = i._orientation, e._stereo = i._stereo, e._pos = i._pos, e._pannerAttr = i._pannerAttr, t.call(this), e._stereo ? i.stereo(e._stereo) : e._pos && i.pos(e._pos[0], e._pos[1], e._pos[2], e._id) } }(Sound.prototype.init), Sound.prototype.reset = function(t) { return function() { var e = this,
                    i = e._parent; return e._orientation = i._orientation, e._stereo = i._stereo, e._pos = i._pos, e._pannerAttr = i._pannerAttr, e._stereo ? i.stereo(e._stereo) : e._pos ? i.pos(e._pos[0], e._pos[1], e._pos[2], e._id) : e._panner && (e._panner.disconnect(0), e._panner = void 0, i._refreshBuffer(e)), t.call(this) } }(Sound.prototype.reset); var t = function(t, e) { "spatial" === (e = e || "spatial") ? (t._panner = Howler.ctx.createPanner(), t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle, t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle, t._panner.coneOuterGain = t._pannerAttr.coneOuterGain, t._panner.distanceModel = t._pannerAttr.distanceModel, t._panner.maxDistance = t._pannerAttr.maxDistance, t._panner.refDistance = t._pannerAttr.refDistance, t._panner.rolloffFactor = t._pannerAttr.rolloffFactor, t._panner.panningModel = t._pannerAttr.panningModel, void 0 !== t._panner.positionX ? (t._panner.positionX.setValueAtTime(t._pos[0], Howler.ctx.currentTime), t._panner.positionY.setValueAtTime(t._pos[1], Howler.ctx.currentTime), t._panner.positionZ.setValueAtTime(t._pos[2], Howler.ctx.currentTime)) : t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]), void 0 !== t._panner.orientationX ? (t._panner.orientationX.setValueAtTime(t._orientation[0], Howler.ctx.currentTime), t._panner.orientationY.setValueAtTime(t._orientation[1], Howler.ctx.currentTime), t._panner.orientationZ.setValueAtTime(t._orientation[2], Howler.ctx.currentTime)) : t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2])) : (t._panner = Howler.ctx.createStereoPanner(), t._panner.pan.setValueAtTime(t._stereo, Howler.ctx.currentTime)), t._panner.connect(t._node), t._paused || t._parent.pause(t._id, !0).play(t._id, !0) } }(),
    function(t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.dat = {}) }(this, function(t) { "use strict";

        function e(t, e) { var i = t.__state.conversionName.toString(),
                o = Math.round(t.r),
                n = Math.round(t.g),
                s = Math.round(t.b),
                r = t.a,
                a = Math.round(t.h),
                h = t.s.toFixed(1),
                l = t.v.toFixed(1); if (e || "THREE_CHAR_HEX" === i || "SIX_CHAR_HEX" === i) { for (var c = t.hex.toString(16); c.length < 6;) c = "0" + c; return "#" + c } return "CSS_RGB" === i ? "rgb(" + o + "," + n + "," + s + ")" : "CSS_RGBA" === i ? "rgba(" + o + "," + n + "," + s + "," + r + ")" : "HEX" === i ? "0x" + t.hex.toString(16) : "RGB_ARRAY" === i ? "[" + o + "," + n + "," + s + "]" : "RGBA_ARRAY" === i ? "[" + o + "," + n + "," + s + "," + r + "]" : "RGB_OBJ" === i ? "{r:" + o + ",g:" + n + ",b:" + s + "}" : "RGBA_OBJ" === i ? "{r:" + o + ",g:" + n + ",b:" + s + ",a:" + r + "}" : "HSV_OBJ" === i ? "{h:" + a + ",s:" + h + ",v:" + l + "}" : "HSVA_OBJ" === i ? "{h:" + a + ",s:" + h + ",v:" + l + ",a:" + r + "}" : "unknown format" }

        function i(t, e, i) { Object.defineProperty(t, e, { get: function() { return "RGB" === this.__state.space ? this.__state[e] : (U.recalculateRGB(this, e, i), this.__state[e]) }, set: function(t) { "RGB" !== this.__state.space && (U.recalculateRGB(this, e, i), this.__state.space = "RGB"), this.__state[e] = t } }) }

        function o(t, e) { Object.defineProperty(t, e, { get: function() { return "HSV" === this.__state.space ? this.__state[e] : (U.recalculateHSV(this), this.__state[e]) }, set: function(t) { "HSV" !== this.__state.space && (U.recalculateHSV(this), this.__state.space = "HSV"), this.__state[e] = t } }) }

        function n(t) { if ("0" === t || P.isUndefined(t)) return 0; var e = t.match(X); return P.isNull(e) ? 0 : parseFloat(e[1]) }

        function s(t) { var e = t.toString(); return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0 }

        function r(t, e) { var i = Math.pow(10, e); return Math.round(t * i) / i }

        function a(t, e, i, o, n) { return o + (t - e) / (i - e) * (n - o) }

        function h(t, e, i, o) { t.style.background = "", P.each(tt, function(n) { t.style.cssText += "background: " + n + "linear-gradient(" + e + ", " + i + " 0%, " + o + " 100%); " }) }

        function l(t) { t.style.background = "", t.style.cssText += "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);", t.style.cssText += "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);", t.style.cssText += "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);" }

        function c(t, e, i) { var o = document.createElement("li"); return e && o.appendChild(e), i ? t.__ul.insertBefore(o, i) : t.__ul.appendChild(o), t.onResize(), o }

        function d(t) { H.unbind(window, "resize", t.__resizeHandler), t.saveToLocalStorageIfPossible && H.unbind(window, "unload", t.saveToLocalStorageIfPossible) }

        function u(t, e) { var i = t.__preset_select[t.__preset_select.selectedIndex];
            i.innerHTML = e ? i.value + "*" : i.value }

        function p(t, e, i) { if (i.__li = e, i.__gui = t, P.extend(i, { options: function(e) { if (arguments.length > 1) { var o = i.__li.nextElementSibling; return i.remove(), f(t, i.object, i.property, { before: o, factoryArgs: [P.toArray(arguments)] }) } if (P.isArray(e) || P.isObject(e)) { var n = i.__li.nextElementSibling; return i.remove(), f(t, i.object, i.property, { before: n, factoryArgs: [e] }) } }, name: function(t) { return i.__li.firstElementChild.firstElementChild.innerHTML = t, i }, listen: function() { return i.__gui.listen(i), i }, remove: function() { return i.__gui.remove(i), i } }), i instanceof Z) { var o = new K(i.object, i.property, { min: i.__min, max: i.__max, step: i.__step });
                P.each(["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"], function(t) { var e = i[t],
                        n = o[t];
                    i[t] = o[t] = function() { var t = Array.prototype.slice.call(arguments); return n.apply(o, t), e.apply(i, t) } }), H.addClass(e, "has-slider"), i.domElement.insertBefore(o.domElement, i.domElement.firstElementChild) } else if (i instanceof K) { var n = function(e) { if (P.isNumber(i.__min) && P.isNumber(i.__max)) { var o = i.__li.firstElementChild.firstElementChild.innerHTML,
                            n = i.__gui.__listening.indexOf(i) > -1;
                        i.remove(); var s = f(t, i.object, i.property, { before: i.__li.nextElementSibling, factoryArgs: [i.__min, i.__max, i.__step] }); return s.name(o), n && s.listen(), s } return e };
                i.min = P.compose(n, i.min), i.max = P.compose(n, i.max) } else i instanceof z ? (H.bind(e, "click", function() { H.fakeEvent(i.__checkbox, "click") }), H.bind(i.__checkbox, "click", function(t) { t.stopPropagation() })) : i instanceof Q ? (H.bind(e, "click", function() { H.fakeEvent(i.__button, "click") }), H.bind(e, "mouseover", function() { H.addClass(i.__button, "hover") }), H.bind(e, "mouseout", function() { H.removeClass(i.__button, "hover") })) : i instanceof $ && (H.addClass(e, "color"), i.updateDisplay = P.compose(function(t) { return e.style.borderLeftColor = i.__color.toString(), t }, i.updateDisplay), i.updateDisplay());
            i.setValue = P.compose(function(e) { return t.getRoot().__preset_select && i.isModified() && u(t.getRoot(), !0), e }, i.setValue) }

        function m(t, e) { var i = t.getRoot(),
                o = i.__rememberedObjects.indexOf(e.object); if (-1 !== o) { var n = i.__rememberedObjectIndecesToControllers[o]; if (void 0 === n && (n = {}, i.__rememberedObjectIndecesToControllers[o] = n), n[e.property] = e, i.load && i.load.remembered) { var s = i.load.remembered,
                        r = void 0; if (s[t.preset]) r = s[t.preset];
                    else { if (!s[rt]) return;
                        r = s[rt] } if (r[o] && void 0 !== r[o][e.property]) { var a = r[o][e.property];
                        e.initialValue = a, e.setValue(a) } } } }

        function f(t, e, i, o) { if (void 0 === e[i]) throw new Error('Object "' + e + '" has no property "' + i + '"'); var n = void 0; if (o.color) n = new $(e, i);
            else { var s = [e, i].concat(o.factoryArgs);
                n = it.apply(t, s) } o.before instanceof N && (o.before = o.before.__li), m(t, n), H.addClass(n.domElement, "c"); var r = document.createElement("span");
            H.addClass(r, "property-name"), r.innerHTML = n.property; var a = document.createElement("div");
            a.appendChild(r), a.appendChild(n.domElement); var h = c(t, a, o.before); return H.addClass(h, pt.CLASS_CONTROLLER_ROW), n instanceof $ ? H.addClass(h, "color") : H.addClass(h, L(n.getValue())), p(t, h, n), t.__controllers.push(n), n }

        function y(t, e) { return document.location.href + "." + e }

        function b(t, e, i) { var o = document.createElement("option");
            o.innerHTML = e, o.value = e, t.__preset_select.appendChild(o), i && (t.__preset_select.selectedIndex = t.__preset_select.length - 1) }

        function g(t, e) { e.style.display = t.useLocalStorage ? "block" : "none" }

        function _(t) { var e = t.__save_row = document.createElement("li");
            H.addClass(t.domElement, "has-save"), t.__ul.insertBefore(e, t.__ul.firstChild), H.addClass(e, "save-row"); var i = document.createElement("span");
            i.innerHTML = "&nbsp;", H.addClass(i, "button gears"); var o = document.createElement("span");
            o.innerHTML = "Save", H.addClass(o, "button"), H.addClass(o, "save"); var n = document.createElement("span");
            n.innerHTML = "New", H.addClass(n, "button"), H.addClass(n, "save-as"); var s = document.createElement("span");
            s.innerHTML = "Revert", H.addClass(s, "button"), H.addClass(s, "revert"); var r = t.__preset_select = document.createElement("select"); if (t.load && t.load.remembered ? P.each(t.load.remembered, function(e, i) { b(t, i, i === t.preset) }) : b(t, rt, !1), H.bind(r, "change", function() { for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].innerHTML = t.__preset_select[e].value;
                    t.preset = this.value }), e.appendChild(r), e.appendChild(i), e.appendChild(o), e.appendChild(n), e.appendChild(s), at) { var a = document.getElementById("dg-local-explain"),
                    h = document.getElementById("dg-local-storage");
                document.getElementById("dg-save-locally").style.display = "block", "true" === localStorage.getItem(y(t, "isLocal")) && h.setAttribute("checked", "checked"), g(t, a), H.bind(h, "change", function() { t.useLocalStorage = !t.useLocalStorage, g(t, a) }) } var l = document.getElementById("dg-new-constructor");
            H.bind(l, "keydown", function(t) {!t.metaKey || 67 !== t.which && 67 !== t.keyCode || ht.hide() }), H.bind(i, "click", function() { l.innerHTML = JSON.stringify(t.getSaveObject(), void 0, 2), ht.show(), l.focus(), l.select() }), H.bind(o, "click", function() { t.save() }), H.bind(n, "click", function() { var e = prompt("Enter a new preset name.");
                e && t.saveAs(e) }), H.bind(s, "click", function() { t.revert() }) }

        function v(t) {
            function e(e) { return e.preventDefault(), t.width += n - e.clientX, t.onResize(), n = e.clientX, !1 }

            function i() { H.removeClass(t.__closeButton, pt.CLASS_DRAG), H.unbind(window, "mousemove", e), H.unbind(window, "mouseup", i) }

            function o(o) { return o.preventDefault(), n = o.clientX, H.addClass(t.__closeButton, pt.CLASS_DRAG), H.bind(window, "mousemove", e), H.bind(window, "mouseup", i), !1 } var n = void 0;
            t.__resize_handle = document.createElement("div"), P.extend(t.__resize_handle.style, { width: "6px", marginLeft: "-3px", height: "200px", cursor: "ew-resize", position: "absolute" }), H.bind(t.__resize_handle, "mousedown", o), H.bind(t.__closeButton, "mousedown", o), t.domElement.insertBefore(t.__resize_handle, t.domElement.firstElementChild) }

        function x(t, e) { t.domElement.style.width = e + "px", t.__save_row && t.autoPlace && (t.__save_row.style.width = e + "px"), t.__closeButton && (t.__closeButton.style.width = e + "px") }

        function S(t, e) { var i = {}; return P.each(t.__rememberedObjects, function(o, n) { var s = {},
                    r = t.__rememberedObjectIndecesToControllers[n];
                P.each(r, function(t, i) { s[i] = e ? t.initialValue : t.getValue() }), i[n] = s }), i }

        function C(t) { for (var e = 0; e < t.__preset_select.length; e++) t.__preset_select[e].value === t.preset && (t.__preset_select.selectedIndex = e) }

        function w(t) { 0 !== t.length && ot.call(window, function() { w(t) }), P.each(t, function(t) { t.updateDisplay() }) } var A = Array.prototype.forEach,
            T = Array.prototype.slice,
            P = { BREAK: {}, extend: function(t) { return this.each(T.call(arguments, 1), function(e) {
                        (this.isObject(e) ? Object.keys(e) : []).forEach(function(i) { this.isUndefined(e[i]) || (t[i] = e[i]) }.bind(this)) }, this), t }, defaults: function(t) { return this.each(T.call(arguments, 1), function(e) {
                        (this.isObject(e) ? Object.keys(e) : []).forEach(function(i) { this.isUndefined(t[i]) && (t[i] = e[i]) }.bind(this)) }, this), t }, compose: function() { var t = T.call(arguments); return function() { for (var e = T.call(arguments), i = t.length - 1; i >= 0; i--) e = [t[i].apply(this, e)]; return e[0] } }, each: function(t, e, i) { if (t)
                        if (A && t.forEach && t.forEach === A) t.forEach(e, i);
                        else if (t.length === t.length + 0) { var o = void 0,
                            n = void 0; for (o = 0, n = t.length; o < n; o++)
                            if (o in t && e.call(i, t[o], o) === this.BREAK) return } else
                        for (var s in t)
                            if (e.call(i, t[s], s) === this.BREAK) return }, defer: function(t) { setTimeout(t, 0) }, debounce: function(t, e, i) { var o = void 0; return function() { var n = this,
                            s = arguments,
                            r = i || !o;
                        clearTimeout(o), o = setTimeout(function() { o = null, i || t.apply(n, s) }, e), r && t.apply(n, s) } }, toArray: function(t) { return t.toArray ? t.toArray() : T.call(t) }, isUndefined: function(t) { return void 0 === t }, isNull: function(t) { return null === t }, isNaN: function(t) {
                    function e(e) { return t.apply(this, arguments) } return e.toString = function() { return t.toString() }, e }(function(t) { return isNaN(t) }), isArray: Array.isArray || function(t) { return t.constructor === Array }, isObject: function(t) { return t === Object(t) }, isNumber: function(t) { return t === t + 0 }, isString: function(t) { return t === t + "" }, isBoolean: function(t) { return !1 === t || !0 === t }, isFunction: function(t) { return "[object Function]" === Object.prototype.toString.call(t) } },
            k = [{ litmus: P.isString, conversions: { THREE_CHAR_HEX: { read: function(t) { var e = t.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i); return null !== e && { space: "HEX", hex: parseInt("0x" + e[1].toString() + e[1].toString() + e[2].toString() + e[2].toString() + e[3].toString() + e[3].toString(), 0) } }, write: e }, SIX_CHAR_HEX: { read: function(t) { var e = t.match(/^#([A-F0-9]{6})$/i); return null !== e && { space: "HEX", hex: parseInt("0x" + e[1].toString(), 0) } }, write: e }, CSS_RGB: { read: function(t) { var e = t.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/); return null !== e && { space: "RGB", r: parseFloat(e[1]), g: parseFloat(e[2]), b: parseFloat(e[3]) } }, write: e }, CSS_RGBA: { read: function(t) { var e = t.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/); return null !== e && { space: "RGB", r: parseFloat(e[1]), g: parseFloat(e[2]), b: parseFloat(e[3]), a: parseFloat(e[4]) } }, write: e } } }, { litmus: P.isNumber, conversions: { HEX: { read: function(t) { return { space: "HEX", hex: t, conversionName: "HEX" } }, write: function(t) { return t.hex } } } }, { litmus: P.isArray, conversions: { RGB_ARRAY: { read: function(t) { return 3 === t.length && { space: "RGB", r: t[0], g: t[1], b: t[2] } }, write: function(t) { return [t.r, t.g, t.b] } }, RGBA_ARRAY: { read: function(t) { return 4 === t.length && { space: "RGB", r: t[0], g: t[1], b: t[2], a: t[3] } }, write: function(t) { return [t.r, t.g, t.b, t.a] } } } }, { litmus: P.isObject, conversions: { RGBA_OBJ: { read: function(t) { return !!(P.isNumber(t.r) && P.isNumber(t.g) && P.isNumber(t.b) && P.isNumber(t.a)) && { space: "RGB", r: t.r, g: t.g, b: t.b, a: t.a } }, write: function(t) { return { r: t.r, g: t.g, b: t.b, a: t.a } } }, RGB_OBJ: { read: function(t) { return !!(P.isNumber(t.r) && P.isNumber(t.g) && P.isNumber(t.b)) && { space: "RGB", r: t.r, g: t.g, b: t.b } }, write: function(t) { return { r: t.r, g: t.g, b: t.b } } }, HSVA_OBJ: { read: function(t) { return !!(P.isNumber(t.h) && P.isNumber(t.s) && P.isNumber(t.v) && P.isNumber(t.a)) && { space: "HSV", h: t.h, s: t.s, v: t.v, a: t.a } }, write: function(t) { return { h: t.h, s: t.s, v: t.v, a: t.a } } }, HSV_OBJ: { read: function(t) { return !!(P.isNumber(t.h) && P.isNumber(t.s) && P.isNumber(t.v)) && { space: "HSV", h: t.h, s: t.s, v: t.v } }, write: function(t) { return { h: t.h, s: t.s, v: t.v } } } } }],
            M = void 0,
            E = void 0,
            B = function() { E = !1; var t = arguments.length > 1 ? P.toArray(arguments) : arguments[0]; return P.each(k, function(e) { if (e.litmus(t)) return P.each(e.conversions, function(e, i) { if (M = e.read(t), !1 === E && !1 !== M) return E = M, M.conversionName = i, M.conversion = e, P.BREAK }), P.BREAK }), E },
            I = void 0,
            D = { hsv_to_rgb: function(t, e, i) { var o = Math.floor(t / 60) % 6,
                        n = t / 60 - Math.floor(t / 60),
                        s = i * (1 - e),
                        r = i * (1 - n * e),
                        a = i * (1 - (1 - n) * e),
                        h = [
                            [i, a, s],
                            [r, i, s],
                            [s, i, a],
                            [s, r, i],
                            [a, s, i],
                            [i, s, r]
                        ][o]; return { r: 255 * h[0], g: 255 * h[1], b: 255 * h[2] } }, rgb_to_hsv: function(t, e, i) { var o = Math.min(t, e, i),
                        n = Math.max(t, e, i),
                        s = n - o,
                        r = void 0,
                        a = void 0; return 0 === n ? { h: NaN, s: 0, v: 0 } : (a = s / n, r = t === n ? (e - i) / s : e === n ? 2 + (i - t) / s : 4 + (t - e) / s, (r /= 6) < 0 && (r += 1), { h: 360 * r, s: a, v: n / 255 }) }, rgb_to_hex: function(t, e, i) { var o = this.hex_with_component(0, 2, t); return o = this.hex_with_component(o, 1, e), o = this.hex_with_component(o, 0, i) }, component_from_hex: function(t, e) { return t >> 8 * e & 255 }, hex_with_component: function(t, e, i) { return i << (I = 8 * e) | t & ~(255 << I) } },
            L = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) { return typeof t } : function(t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t },
            O = function(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") },
            R = function() {
                function t(t, e) { for (var i = 0; i < e.length; i++) { var o = e[i];
                        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o) } } return function(e, i, o) { return i && t(e.prototype, i), o && t(e, o), e } }(),
            F = function t(e, i, o) { null === e && (e = Function.prototype); var n = Object.getOwnPropertyDescriptor(e, i); if (void 0 === n) { var s = Object.getPrototypeOf(e); return null === s ? void 0 : t(s, i, o) } if ("value" in n) return n.value; var r = n.get; return void 0 !== r ? r.call(o) : void 0 },
            V = function(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) },
            G = function(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e },
            U = function() {
                function t() { if (O(this, t), this.__state = B.apply(this, arguments), !1 === this.__state) throw new Error("Failed to interpret color arguments");
                    this.__state.a = this.__state.a || 1 } return R(t, [{ key: "toString", value: function() { return e(this) } }, { key: "toHexString", value: function() { return e(this, !0) } }, { key: "toOriginal", value: function() { return this.__state.conversion.write(this) } }]), t }();
        U.recalculateRGB = function(t, e, i) { if ("HEX" === t.__state.space) t.__state[e] = D.component_from_hex(t.__state.hex, i);
            else { if ("HSV" !== t.__state.space) throw new Error("Corrupted color state");
                P.extend(t.__state, D.hsv_to_rgb(t.__state.h, t.__state.s, t.__state.v)) } }, U.recalculateHSV = function(t) { var e = D.rgb_to_hsv(t.r, t.g, t.b);
            P.extend(t.__state, { s: e.s, v: e.v }), P.isNaN(e.h) ? P.isUndefined(t.__state.h) && (t.__state.h = 0) : t.__state.h = e.h }, U.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"], i(U.prototype, "r", 2), i(U.prototype, "g", 1), i(U.prototype, "b", 0), o(U.prototype, "h"), o(U.prototype, "s"), o(U.prototype, "v"), Object.defineProperty(U.prototype, "a", { get: function() { return this.__state.a }, set: function(t) { this.__state.a = t } }), Object.defineProperty(U.prototype, "hex", { get: function() { return "HEX" !== !this.__state.space && (this.__state.hex = D.rgb_to_hex(this.r, this.g, this.b)), this.__state.hex }, set: function(t) { this.__state.space = "HEX", this.__state.hex = t } }); var N = function() {
                function t(e, i) { O(this, t), this.initialValue = e[i], this.domElement = document.createElement("div"), this.object = e, this.property = i, this.__onChange = void 0, this.__onFinishChange = void 0 } return R(t, [{ key: "onChange", value: function(t) { return this.__onChange = t, this } }, { key: "onFinishChange", value: function(t) { return this.__onFinishChange = t, this } }, { key: "setValue", value: function(t) { return this.object[this.property] = t, this.__onChange && this.__onChange.call(this, t), this.updateDisplay(), this } }, { key: "getValue", value: function() { return this.object[this.property] } }, { key: "updateDisplay", value: function() { return this } }, { key: "isModified", value: function() { return this.initialValue !== this.getValue() } }]), t }(),
            j = { HTMLEvents: ["change"], MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"], KeyboardEvents: ["keydown"] },
            W = {};
        P.each(j, function(t, e) { P.each(t, function(t) { W[t] = e }) }); var X = /(\d+(\.\d+)?)px/,
            H = { makeSelectable: function(t, e) { void 0 !== t && void 0 !== t.style && (t.onselectstart = e ? function() { return !1 } : function() {}, t.style.MozUserSelect = e ? "auto" : "none", t.style.KhtmlUserSelect = e ? "auto" : "none", t.unselectable = e ? "on" : "off") }, makeFullscreen: function(t, e, i) { var o = i,
                        n = e;
                    P.isUndefined(n) && (n = !0), P.isUndefined(o) && (o = !0), t.style.position = "absolute", n && (t.style.left = 0, t.style.right = 0), o && (t.style.top = 0, t.style.bottom = 0) }, fakeEvent: function(t, e, i, o) { var n = i || {},
                        s = W[e]; if (!s) throw new Error("Event type " + e + " not supported."); var r = document.createEvent(s); switch (s) {
                        case "MouseEvents":
                            var a = n.x || n.clientX || 0,
                                h = n.y || n.clientY || 0;
                            r.initMouseEvent(e, n.bubbles || !1, n.cancelable || !0, window, n.clickCount || 1, 0, 0, a, h, !1, !1, !1, !1, 0, null); break;
                        case "KeyboardEvents":
                            var l = r.initKeyboardEvent || r.initKeyEvent;
                            P.defaults(n, { cancelable: !0, ctrlKey: !1, altKey: !1, shiftKey: !1, metaKey: !1, keyCode: void 0, charCode: void 0 }), l(e, n.bubbles || !1, n.cancelable, window, n.ctrlKey, n.altKey, n.shiftKey, n.metaKey, n.keyCode, n.charCode); break;
                        default:
                            r.initEvent(e, n.bubbles || !1, n.cancelable || !0) } P.defaults(r, o), t.dispatchEvent(r) }, bind: function(t, e, i, o) { var n = o || !1; return t.addEventListener ? t.addEventListener(e, i, n) : t.attachEvent && t.attachEvent("on" + e, i), H }, unbind: function(t, e, i, o) { var n = o || !1; return t.removeEventListener ? t.removeEventListener(e, i, n) : t.detachEvent && t.detachEvent("on" + e, i), H }, addClass: function(t, e) { if (void 0 === t.className) t.className = e;
                    else if (t.className !== e) { var i = t.className.split(/ +/); - 1 === i.indexOf(e) && (i.push(e), t.className = i.join(" ").replace(/^\s+/, "").replace(/\s+$/, "")) } return H }, removeClass: function(t, e) { if (e)
                        if (t.className === e) t.removeAttribute("class");
                        else { var i = t.className.split(/ +/),
                                o = i.indexOf(e); - 1 !== o && (i.splice(o, 1), t.className = i.join(" ")) } else t.className = void 0; return H }, hasClass: function(t, e) { return new RegExp("(?:^|\\s+)" + e + "(?:\\s+|$)").test(t.className) || !1 }, getWidth: function(t) { var e = getComputedStyle(t); return n(e["border-left-width"]) + n(e["border-right-width"]) + n(e["padding-left"]) + n(e["padding-right"]) + n(e.width) }, getHeight: function(t) { var e = getComputedStyle(t); return n(e["border-top-width"]) + n(e["border-bottom-width"]) + n(e["padding-top"]) + n(e["padding-bottom"]) + n(e.height) }, getOffset: function(t) { var e = t,
                        i = { left: 0, top: 0 }; if (e.offsetParent)
                        do { i.left += e.offsetLeft, i.top += e.offsetTop, e = e.offsetParent } while (e); return i }, isActive: function(t) { return t === document.activeElement && (t.type || t.href) } },
            z = function(t) {
                function e(t, i) { O(this, e); var o = G(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                        n = o; return o.__prev = o.getValue(), o.__checkbox = document.createElement("input"), o.__checkbox.setAttribute("type", "checkbox"), H.bind(o.__checkbox, "change", function() { n.setValue(!n.__prev) }, !1), o.domElement.appendChild(o.__checkbox), o.updateDisplay(), o } return V(e, N), R(e, [{ key: "setValue", value: function(t) { var i = F(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), this.__prev = this.getValue(), i } }, { key: "updateDisplay", value: function() { return !0 === this.getValue() ? (this.__checkbox.setAttribute("checked", "checked"), this.__checkbox.checked = !0, this.__prev = !0) : (this.__checkbox.checked = !1, this.__prev = !1), F(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this) } }]), e }(),
            J = function(t) {
                function e(t, i, o) { O(this, e); var n = G(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                        s = o,
                        r = n; if (n.__select = document.createElement("select"), P.isArray(s)) { var a = {};
                        P.each(s, function(t) { a[t] = t }), s = a } return P.each(s, function(t, e) { var i = document.createElement("option");
                        i.innerHTML = e, i.setAttribute("value", t), r.__select.appendChild(i) }), n.updateDisplay(), H.bind(n.__select, "change", function() { var t = this.options[this.selectedIndex].value;
                        r.setValue(t) }), n.domElement.appendChild(n.__select), n } return V(e, N), R(e, [{ key: "setValue", value: function(t) { var i = F(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, t); return this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()), i } }, { key: "updateDisplay", value: function() { return H.isActive(this.__select) ? this : (this.__select.value = this.getValue(), F(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this)) } }]), e }(),
            q = function(t) {
                function e(t, i) {
                    function o() { s.setValue(s.__input.value) } O(this, e); var n = G(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                        s = n; return n.__input = document.createElement("input"), n.__input.setAttribute("type", "text"), H.bind(n.__input, "keyup", o), H.bind(n.__input, "change", o), H.bind(n.__input, "blur", function() { s.__onFinishChange && s.__onFinishChange.call(s, s.getValue()) }), H.bind(n.__input, "keydown", function(t) { 13 === t.keyCode && this.blur() }), n.updateDisplay(), n.domElement.appendChild(n.__input), n } return V(e, N), R(e, [{ key: "updateDisplay", value: function() { return H.isActive(this.__input) || (this.__input.value = this.getValue()), F(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this) } }]), e }(),
            Y = function(t) {
                function e(t, i, o) { O(this, e); var n = G(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                        r = o || {}; return n.__min = r.min, n.__max = r.max, n.__step = r.step, P.isUndefined(n.__step) ? 0 === n.initialValue ? n.__impliedStep = 1 : n.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(n.initialValue)) / Math.LN10)) / 10 : n.__impliedStep = n.__step, n.__precision = s(n.__impliedStep), n } return V(e, N), R(e, [{ key: "setValue", value: function(t) { var i = t; return void 0 !== this.__min && i < this.__min ? i = this.__min : void 0 !== this.__max && i > this.__max && (i = this.__max), void 0 !== this.__step && i % this.__step != 0 && (i = Math.round(i / this.__step) * this.__step), F(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "setValue", this).call(this, i) } }, { key: "min", value: function(t) { return this.__min = t, this } }, { key: "max", value: function(t) { return this.__max = t, this } }, { key: "step", value: function(t) { return this.__step = t, this.__impliedStep = t, this.__precision = s(t), this } }]), e }(),
            K = function(t) {
                function e(t, i, o) {
                    function n() { h.__onFinishChange && h.__onFinishChange.call(h, h.getValue()) }

                    function s(t) { var e = l - t.clientY;
                        h.setValue(h.getValue() + e * h.__impliedStep), l = t.clientY }

                    function r() { H.unbind(window, "mousemove", s), H.unbind(window, "mouseup", r), n() } O(this, e); var a = G(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i, o));
                    a.__truncationSuspended = !1; var h = a,
                        l = void 0; return a.__input = document.createElement("input"), a.__input.setAttribute("type", "text"), H.bind(a.__input, "change", function() { var t = parseFloat(h.__input.value);
                        P.isNaN(t) || h.setValue(t) }), H.bind(a.__input, "blur", function() { n() }), H.bind(a.__input, "mousedown", function(t) { H.bind(window, "mousemove", s), H.bind(window, "mouseup", r), l = t.clientY }), H.bind(a.__input, "keydown", function(t) { 13 === t.keyCode && (h.__truncationSuspended = !0, this.blur(), h.__truncationSuspended = !1, n()) }), a.updateDisplay(), a.domElement.appendChild(a.__input), a } return V(e, Y), R(e, [{ key: "updateDisplay", value: function() { return this.__input.value = this.__truncationSuspended ? this.getValue() : r(this.getValue(), this.__precision), F(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this) } }]), e }(),
            Z = function(t) {
                function e(t, i, o, n, s) {
                    function r(t) { t.preventDefault(); var e = u.__background.getBoundingClientRect(); return u.setValue(a(t.clientX, e.left, e.right, u.__min, u.__max)), !1 }

                    function h() { H.unbind(window, "mousemove", r), H.unbind(window, "mouseup", h), u.__onFinishChange && u.__onFinishChange.call(u, u.getValue()) }

                    function l(t) { var e = t.touches[0].clientX,
                            i = u.__background.getBoundingClientRect();
                        u.setValue(a(e, i.left, i.right, u.__min, u.__max)) }

                    function c() { H.unbind(window, "touchmove", l), H.unbind(window, "touchend", c), u.__onFinishChange && u.__onFinishChange.call(u, u.getValue()) } O(this, e); var d = G(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i, { min: o, max: n, step: s })),
                        u = d; return d.__background = document.createElement("div"), d.__foreground = document.createElement("div"), H.bind(d.__background, "mousedown", function(t) { document.activeElement.blur(), H.bind(window, "mousemove", r), H.bind(window, "mouseup", h), r(t) }), H.bind(d.__background, "touchstart", function(t) { 1 === t.touches.length && (H.bind(window, "touchmove", l), H.bind(window, "touchend", c), l(t)) }), H.addClass(d.__background, "slider"), H.addClass(d.__foreground, "slider-fg"), d.updateDisplay(), d.__background.appendChild(d.__foreground), d.domElement.appendChild(d.__background), d } return V(e, Y), R(e, [{ key: "updateDisplay", value: function() { var t = (this.getValue() - this.__min) / (this.__max - this.__min); return this.__foreground.style.width = 100 * t + "%", F(e.prototype.__proto__ || Object.getPrototypeOf(e.prototype), "updateDisplay", this).call(this) } }]), e }(),
            Q = function(t) {
                function e(t, i, o) { O(this, e); var n = G(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i)),
                        s = n; return n.__button = document.createElement("div"), n.__button.innerHTML = void 0 === o ? "Fire" : o, H.bind(n.__button, "click", function(t) { return t.preventDefault(), s.fire(), !1 }), H.addClass(n.__button, "button"), n.domElement.appendChild(n.__button), n } return V(e, N), R(e, [{ key: "fire", value: function() { this.__onChange && this.__onChange.call(this), this.getValue().call(this.object), this.__onFinishChange && this.__onFinishChange.call(this, this.getValue()) } }]), e }(),
            $ = function(t) {
                function e(t, i) {
                    function o(t) { d(t), H.bind(window, "mousemove", d), H.bind(window, "touchmove", d), H.bind(window, "mouseup", s), H.bind(window, "touchend", s) }

                    function n(t) { u(t), H.bind(window, "mousemove", u), H.bind(window, "touchmove", u), H.bind(window, "mouseup", r), H.bind(window, "touchend", r) }

                    function s() { H.unbind(window, "mousemove", d), H.unbind(window, "touchmove", d), H.unbind(window, "mouseup", s), H.unbind(window, "touchend", s), c() }

                    function r() { H.unbind(window, "mousemove", u), H.unbind(window, "touchmove", u), H.unbind(window, "mouseup", r), H.unbind(window, "touchend", r), c() }

                    function a() { var t = B(this.value);!1 !== t ? (m.__color.__state = t, m.setValue(m.__color.toOriginal())) : this.value = m.__color.toString() }

                    function c() { m.__onFinishChange && m.__onFinishChange.call(m, m.__color.toOriginal()) }

                    function d(t) {-1 === t.type.indexOf("touch") && t.preventDefault(); var e = m.__saturation_field.getBoundingClientRect(),
                            i = t.touches && t.touches[0] || t,
                            o = i.clientX,
                            n = i.clientY,
                            s = (o - e.left) / (e.right - e.left),
                            r = 1 - (n - e.top) / (e.bottom - e.top); return r > 1 ? r = 1 : r < 0 && (r = 0), s > 1 ? s = 1 : s < 0 && (s = 0), m.__color.v = r, m.__color.s = s, m.setValue(m.__color.toOriginal()), !1 }

                    function u(t) {-1 === t.type.indexOf("touch") && t.preventDefault(); var e = m.__hue_field.getBoundingClientRect(),
                            i = 1 - ((t.touches && t.touches[0] || t).clientY - e.top) / (e.bottom - e.top); return i > 1 ? i = 1 : i < 0 && (i = 0), m.__color.h = 360 * i, m.setValue(m.__color.toOriginal()), !1 } O(this, e); var p = G(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, i));
                    p.__color = new U(p.getValue()), p.__temp = new U(0); var m = p;
                    p.domElement = document.createElement("div"), H.makeSelectable(p.domElement, !1), p.__selector = document.createElement("div"), p.__selector.className = "selector", p.__saturation_field = document.createElement("div"), p.__saturation_field.className = "saturation-field", p.__field_knob = document.createElement("div"), p.__field_knob.className = "field-knob", p.__field_knob_border = "2px solid ", p.__hue_knob = document.createElement("div"), p.__hue_knob.className = "hue-knob", p.__hue_field = document.createElement("div"), p.__hue_field.className = "hue-field", p.__input = document.createElement("input"), p.__input.type = "text", p.__input_textShadow = "0 1px 1px ", H.bind(p.__input, "keydown", function(t) { 13 === t.keyCode && a.call(this) }), H.bind(p.__input, "blur", a), H.bind(p.__selector, "mousedown", function() { H.addClass(this, "drag").bind(window, "mouseup", function() { H.removeClass(m.__selector, "drag") }) }), H.bind(p.__selector, "touchstart", function() { H.addClass(this, "drag").bind(window, "touchend", function() { H.removeClass(m.__selector, "drag") }) }); var f = document.createElement("div"); return P.extend(p.__selector.style, { width: "122px", height: "102px", padding: "3px", backgroundColor: "#222", boxShadow: "0px 1px 3px rgba(0,0,0,0.3)" }), P.extend(p.__field_knob.style, { position: "absolute", width: "12px", height: "12px", border: p.__field_knob_border + (p.__color.v < .5 ? "#fff" : "#000"), boxShadow: "0px 1px 3px rgba(0,0,0,0.5)", borderRadius: "12px", zIndex: 1 }), P.extend(p.__hue_knob.style, { position: "absolute", width: "15px", height: "2px", borderRight: "4px solid #fff", zIndex: 1 }), P.extend(p.__saturation_field.style, { width: "100px", height: "100px", border: "1px solid #555", marginRight: "3px", display: "inline-block", cursor: "pointer" }), P.extend(f.style, { width: "100%", height: "100%", background: "none" }), h(f, "top", "rgba(0,0,0,0)", "#000"), P.extend(p.__hue_field.style, { width: "15px", height: "100px", border: "1px solid #555", cursor: "ns-resize", position: "absolute", top: "3px", right: "3px" }), l(p.__hue_field), P.extend(p.__input.style, { outline: "none", textAlign: "center", color: "#fff", border: 0, fontWeight: "bold", textShadow: p.__input_textShadow + "rgba(0,0,0,0.7)" }), H.bind(p.__saturation_field, "mousedown", o), H.bind(p.__saturation_field, "touchstart", o), H.bind(p.__field_knob, "mousedown", o), H.bind(p.__field_knob, "touchstart", o), H.bind(p.__hue_field, "mousedown", n), H.bind(p.__hue_field, "touchstart", n), p.__saturation_field.appendChild(f), p.__selector.appendChild(p.__field_knob), p.__selector.appendChild(p.__saturation_field), p.__selector.appendChild(p.__hue_field), p.__hue_field.appendChild(p.__hue_knob), p.domElement.appendChild(p.__input), p.domElement.appendChild(p.__selector), p.updateDisplay(), p } return V(e, N), R(e, [{ key: "updateDisplay", value: function() { var t = B(this.getValue()); if (!1 !== t) { var e = !1;
                            P.each(U.COMPONENTS, function(i) { if (!P.isUndefined(t[i]) && !P.isUndefined(this.__color.__state[i]) && t[i] !== this.__color.__state[i]) return e = !0, {} }, this), e && P.extend(this.__color.__state, t) } P.extend(this.__temp.__state, this.__color.__state), this.__temp.a = 1; var i = this.__color.v < .5 || this.__color.s > .5 ? 255 : 0,
                            o = 255 - i;
                        P.extend(this.__field_knob.style, { marginLeft: 100 * this.__color.s - 7 + "px", marginTop: 100 * (1 - this.__color.v) - 7 + "px", backgroundColor: this.__temp.toHexString(), border: this.__field_knob_border + "rgb(" + i + "," + i + "," + i + ")" }), this.__hue_knob.style.marginTop = 100 * (1 - this.__color.h / 360) + "px", this.__temp.s = 1, this.__temp.v = 1, h(this.__saturation_field, "left", "#fff", this.__temp.toHexString()), this.__input.value = this.__color.toString(), P.extend(this.__input.style, { backgroundColor: this.__color.toHexString(), color: "rgb(" + i + "," + i + "," + i + ")", textShadow: this.__input_textShadow + "rgba(" + o + "," + o + "," + o + ",.7)" }) } }]), e }(),
            tt = ["-moz-", "-o-", "-webkit-", "-ms-", ""],
            et = { load: function(t, e) { var i = e || document,
                        o = i.createElement("link");
                    o.type = "text/css", o.rel = "stylesheet", o.href = t, i.getElementsByTagName("head")[0].appendChild(o) }, inject: function(t, e) { var i = e || document,
                        o = document.createElement("style");
                    o.type = "text/css", o.innerHTML = t; var n = i.getElementsByTagName("head")[0]; try { n.appendChild(o) } catch (t) {} } },
            it = function(t, e) { var i = t[e]; return P.isArray(arguments[2]) || P.isObject(arguments[2]) ? new J(t, e, arguments[2]) : P.isNumber(i) ? P.isNumber(arguments[2]) && P.isNumber(arguments[3]) ? P.isNumber(arguments[4]) ? new Z(t, e, arguments[2], arguments[3], arguments[4]) : new Z(t, e, arguments[2], arguments[3]) : P.isNumber(arguments[4]) ? new K(t, e, { min: arguments[2], max: arguments[3], step: arguments[4] }) : new K(t, e, { min: arguments[2], max: arguments[3] }) : P.isString(i) ? new q(t, e) : P.isFunction(i) ? new Q(t, e, "") : P.isBoolean(i) ? new z(t, e) : null },
            ot = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(t) { setTimeout(t, 1e3 / 60) },
            nt = function() {
                function t() { O(this, t), this.backgroundElement = document.createElement("div"), P.extend(this.backgroundElement.style, { backgroundColor: "rgba(0,0,0,0.8)", top: 0, left: 0, display: "none", zIndex: "1000", opacity: 0, WebkitTransition: "opacity 0.2s linear", transition: "opacity 0.2s linear" }), H.makeFullscreen(this.backgroundElement), this.backgroundElement.style.position = "fixed", this.domElement = document.createElement("div"), P.extend(this.domElement.style, { position: "fixed", display: "none", zIndex: "1001", opacity: 0, WebkitTransition: "-webkit-transform 0.2s ease-out, opacity 0.2s linear", transition: "transform 0.2s ease-out, opacity 0.2s linear" }), document.body.appendChild(this.backgroundElement), document.body.appendChild(this.domElement); var e = this;
                    H.bind(this.backgroundElement, "click", function() { e.hide() }) } return R(t, [{ key: "show", value: function() { var t = this;
                        this.backgroundElement.style.display = "block", this.domElement.style.display = "block", this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)", this.layout(), P.defer(function() { t.backgroundElement.style.opacity = 1, t.domElement.style.opacity = 1, t.domElement.style.webkitTransform = "scale(1)" }) } }, { key: "hide", value: function() { var t = this,
                            e = function e() { t.domElement.style.display = "none", t.backgroundElement.style.display = "none", H.unbind(t.domElement, "webkitTransitionEnd", e), H.unbind(t.domElement, "transitionend", e), H.unbind(t.domElement, "oTransitionEnd", e) };
                        H.bind(this.domElement, "webkitTransitionEnd", e), H.bind(this.domElement, "transitionend", e), H.bind(this.domElement, "oTransitionEnd", e), this.backgroundElement.style.opacity = 0, this.domElement.style.opacity = 0, this.domElement.style.webkitTransform = "scale(1.1)" } }, { key: "layout", value: function() { this.domElement.style.left = window.innerWidth / 2 - H.getWidth(this.domElement) / 2 + "px", this.domElement.style.top = window.innerHeight / 2 - H.getHeight(this.domElement) / 2 + "px" } }]), t }(),
            st = function(t) { if ("undefined" != typeof window) { var e = document.createElement("style"); return e.setAttribute("type", "text/css"), e.innerHTML = t, document.head.appendChild(e), t } }(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");
        et.inject(st); var rt = "Default",
            at = function() { try { return !!window.localStorage } catch (t) { return !1 } }(),
            ht = void 0,
            lt = !0,
            ct = void 0,
            dt = !1,
            ut = [],
            pt = function t(e) { var i = this,
                    o = e || {};
                this.domElement = document.createElement("div"), this.__ul = document.createElement("ul"), this.domElement.appendChild(this.__ul), H.addClass(this.domElement, "dg"), this.__folders = {}, this.__controllers = [], this.__rememberedObjects = [], this.__rememberedObjectIndecesToControllers = [], this.__listening = [], o = P.defaults(o, { closeOnTop: !1, autoPlace: !0, width: t.DEFAULT_WIDTH }), o = P.defaults(o, { resizable: o.autoPlace, hideable: o.autoPlace }), P.isUndefined(o.load) ? o.load = { preset: rt } : o.preset && (o.load.preset = o.preset), P.isUndefined(o.parent) && o.hideable && ut.push(this), o.resizable = P.isUndefined(o.parent) && o.resizable, o.autoPlace && P.isUndefined(o.scrollable) && (o.scrollable = !0); var n = at && "true" === localStorage.getItem(y(this, "isLocal")),
                    s = void 0,
                    r = void 0; if (Object.defineProperties(this, { parent: { get: function() { return o.parent } }, scrollable: { get: function() { return o.scrollable } }, autoPlace: { get: function() { return o.autoPlace } }, closeOnTop: { get: function() { return o.closeOnTop } }, preset: { get: function() { return i.parent ? i.getRoot().preset : o.load.preset }, set: function(t) { i.parent ? i.getRoot().preset = t : o.load.preset = t, C(this), i.revert() } }, width: { get: function() { return o.width }, set: function(t) { o.width = t, x(i, t) } }, name: { get: function() { return o.name }, set: function(t) { o.name = t, r && (r.innerHTML = o.name) } }, closed: { get: function() { return o.closed }, set: function(e) { o.closed = e, o.closed ? H.addClass(i.__ul, t.CLASS_CLOSED) : H.removeClass(i.__ul, t.CLASS_CLOSED), this.onResize(), i.__closeButton && (i.__closeButton.innerHTML = e ? t.TEXT_OPEN : t.TEXT_CLOSED) } }, load: { get: function() { return o.load } }, useLocalStorage: { get: function() { return n }, set: function(t) { at && (n = t, t ? H.bind(window, "unload", s) : H.unbind(window, "unload", s), localStorage.setItem(y(i, "isLocal"), t)) } } }), P.isUndefined(o.parent)) { if (this.closed = o.closed || !1, H.addClass(this.domElement, t.CLASS_MAIN), H.makeSelectable(this.domElement, !1), at && n) { i.useLocalStorage = !0; var a = localStorage.getItem(y(this, "gui"));
                        a && (o.load = JSON.parse(a)) } this.__closeButton = document.createElement("div"), this.__closeButton.innerHTML = t.TEXT_CLOSED, H.addClass(this.__closeButton, t.CLASS_CLOSE_BUTTON), o.closeOnTop ? (H.addClass(this.__closeButton, t.CLASS_CLOSE_TOP), this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0])) : (H.addClass(this.__closeButton, t.CLASS_CLOSE_BOTTOM), this.domElement.appendChild(this.__closeButton)), H.bind(this.__closeButton, "click", function() { i.closed = !i.closed }) } else { void 0 === o.closed && (o.closed = !0); var h = document.createTextNode(o.name);
                    H.addClass(h, "controller-name"), r = c(i, h), H.addClass(this.__ul, t.CLASS_CLOSED), H.addClass(r, "title"), H.bind(r, "click", function(t) { return t.preventDefault(), i.closed = !i.closed, !1 }), o.closed || (this.closed = !1) } o.autoPlace && (P.isUndefined(o.parent) && (lt && (ct = document.createElement("div"), H.addClass(ct, "dg"), H.addClass(ct, t.CLASS_AUTO_PLACE_CONTAINER), document.body.appendChild(ct), lt = !1), ct.appendChild(this.domElement), H.addClass(this.domElement, t.CLASS_AUTO_PLACE)), this.parent || x(i, o.width)), this.__resizeHandler = function() { i.onResizeDebounced() }, H.bind(window, "resize", this.__resizeHandler), H.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler), H.bind(this.__ul, "transitionend", this.__resizeHandler), H.bind(this.__ul, "oTransitionEnd", this.__resizeHandler), this.onResize(), o.resizable && v(this), s = function() { at && "true" === localStorage.getItem(y(i, "isLocal")) && localStorage.setItem(y(i, "gui"), JSON.stringify(i.getSaveObject())) }, this.saveToLocalStorageIfPossible = s, o.parent || function() { var t = i.getRoot();
                    t.width += 1, P.defer(function() { t.width -= 1 }) }() };
        pt.toggleHide = function() { dt = !dt, P.each(ut, function(t) { t.domElement.style.display = dt ? "none" : "" }) }, pt.CLASS_AUTO_PLACE = "a", pt.CLASS_AUTO_PLACE_CONTAINER = "ac", pt.CLASS_MAIN = "main", pt.CLASS_CONTROLLER_ROW = "cr", pt.CLASS_TOO_TALL = "taller-than-window", pt.CLASS_CLOSED = "closed", pt.CLASS_CLOSE_BUTTON = "close-button", pt.CLASS_CLOSE_TOP = "close-top", pt.CLASS_CLOSE_BOTTOM = "close-bottom", pt.CLASS_DRAG = "drag", pt.DEFAULT_WIDTH = 245, pt.TEXT_CLOSED = "Close Controls", pt.TEXT_OPEN = "Open Controls", pt._keydownHandler = function(t) { "text" === document.activeElement.type || 72 !== t.which && 72 !== t.keyCode || pt.toggleHide() }, H.bind(window, "keydown", pt._keydownHandler, !1), P.extend(pt.prototype, { add: function(t, e) { return f(this, t, e, { factoryArgs: Array.prototype.slice.call(arguments, 2) }) }, addColor: function(t, e) { return f(this, t, e, { color: !0 }) }, remove: function(t) { this.__ul.removeChild(t.__li), this.__controllers.splice(this.__controllers.indexOf(t), 1); var e = this;
                P.defer(function() { e.onResize() }) }, destroy: function() { if (this.parent) throw new Error("Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.");
                this.autoPlace && ct.removeChild(this.domElement); var t = this;
                P.each(this.__folders, function(e) { t.removeFolder(e) }), H.unbind(window, "keydown", pt._keydownHandler, !1), d(this) }, addFolder: function(t) { if (void 0 !== this.__folders[t]) throw new Error('You already have a folder in this GUI by the name "' + t + '"'); var e = { name: t, parent: this };
                e.autoPlace = this.autoPlace, this.load && this.load.folders && this.load.folders[t] && (e.closed = this.load.folders[t].closed, e.load = this.load.folders[t]); var i = new pt(e);
                this.__folders[t] = i; var o = c(this, i.domElement); return H.addClass(o, "folder"), i }, removeFolder: function(t) { this.__ul.removeChild(t.domElement.parentElement), delete this.__folders[t.name], this.load && this.load.folders && this.load.folders[t.name] && delete this.load.folders[t.name], d(t); var e = this;
                P.each(t.__folders, function(e) { t.removeFolder(e) }), P.defer(function() { e.onResize() }) }, open: function() { this.closed = !1 }, close: function() { this.closed = !0 }, hide: function() { this.domElement.style.display = "none" }, show: function() { this.domElement.style.display = "" }, onResize: function() { var t = this.getRoot(); if (t.scrollable) { var e = H.getOffset(t.__ul).top,
                        i = 0;
                    P.each(t.__ul.childNodes, function(e) { t.autoPlace && e === t.__save_row || (i += H.getHeight(e)) }), window.innerHeight - e - 20 < i ? (H.addClass(t.domElement, pt.CLASS_TOO_TALL), t.__ul.style.height = window.innerHeight - e - 20 + "px") : (H.removeClass(t.domElement, pt.CLASS_TOO_TALL), t.__ul.style.height = "auto") } t.__resize_handle && P.defer(function() { t.__resize_handle.style.height = t.__ul.offsetHeight + "px" }), t.__closeButton && (t.__closeButton.style.width = t.width + "px") }, onResizeDebounced: P.debounce(function() { this.onResize() }, 50), remember: function() { if (P.isUndefined(ht) && ((ht = new nt).domElement.innerHTML = '<div id="dg-save" class="dg dialogue">\n\n  Here\'s the new load parameter for your <code>GUI</code>\'s constructor:\n\n  <textarea id="dg-new-constructor"></textarea>\n\n  <div id="dg-save-locally">\n\n    <input id="dg-local-storage" type="checkbox"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id="dg-local-explain">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>\'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>'), this.parent) throw new Error("You can only call remember on a top level GUI."); var t = this;
                P.each(Array.prototype.slice.call(arguments), function(e) { 0 === t.__rememberedObjects.length && _(t), -1 === t.__rememberedObjects.indexOf(e) && t.__rememberedObjects.push(e) }), this.autoPlace && x(this, this.width) }, getRoot: function() { for (var t = this; t.parent;) t = t.parent; return t }, getSaveObject: function() { var t = this.load; return t.closed = this.closed, this.__rememberedObjects.length > 0 && (t.preset = this.preset, t.remembered || (t.remembered = {}), t.remembered[this.preset] = S(this)), t.folders = {}, P.each(this.__folders, function(e, i) { t.folders[i] = e.getSaveObject() }), t }, save: function() { this.load.remembered || (this.load.remembered = {}), this.load.remembered[this.preset] = S(this), u(this, !1), this.saveToLocalStorageIfPossible() }, saveAs: function(t) { this.load.remembered || (this.load.remembered = {}, this.load.remembered[rt] = S(this, !0)), this.load.remembered[t] = S(this), this.preset = t, b(this, t, !0), this.saveToLocalStorageIfPossible() }, revert: function(t) { P.each(this.__controllers, function(e) { this.getRoot().load.remembered ? m(t || this.getRoot(), e) : e.setValue(e.initialValue), e.__onFinishChange && e.__onFinishChange.call(e, e.getValue()) }, this), P.each(this.__folders, function(t) { t.revert(t) }), t || u(this.getRoot(), !1) }, listen: function(t) { var e = 0 === this.__listening.length;
                this.__listening.push(t), e && w(this.__listening) }, updateDisplay: function() { P.each(this.__controllers, function(t) { t.updateDisplay() }), P.each(this.__folders, function(t) { t.updateDisplay() }) } }); var mt = { Color: U, math: D, interpret: B },
            ft = { Controller: N, BooleanController: z, OptionController: J, StringController: q, NumberController: Y, NumberControllerBox: K, NumberControllerSlider: Z, FunctionController: Q, ColorController: $ },
            yt = { dom: H },
            bt = { GUI: pt },
            gt = pt,
            _t = { color: mt, controllers: ft, dom: yt, gui: bt, GUI: gt };
        t.color = mt, t.controllers = ft, t.dom = yt, t.gui = bt, t.GUI = gt, t.default = _t, Object.defineProperty(t, "__esModule", { value: !0 }) }),
    function(t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.StateMachine = e() : t.StateMachine = e() }(this, function() { return function(t) {
            function e(o) { if (i[o]) return i[o].exports; var n = i[o] = { i: o, l: !1, exports: {} }; return t[o].call(n.exports, n, n.exports, e), n.l = !0, n.exports } var i = {}; return e.m = t, e.c = i, e.i = function(t) { return t }, e.d = function(t, i, o) { e.o(t, i) || Object.defineProperty(t, i, { configurable: !1, enumerable: !0, get: o }) }, e.n = function(t) { var i = t && t.__esModule ? function() { return t.default } : function() { return t }; return e.d(i, "a", i), i }, e.o = function(t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, e.p = "", e(e.s = 5) }([function(t, e, i) { "use strict";
            t.exports = function(t, e) { var i, o, n; for (i = 1; i < arguments.length; i++) { o = arguments[i]; for (n in o) o.hasOwnProperty(n) && (t[n] = o[n]) } return t } }, function(t, e, i) { "use strict"; var o = i(0);
            t.exports = { build: function(t, e) { var i, n, s, r = e.plugins; for (i = 0, n = r.length; i < n; i++)(s = r[i]).methods && o(t, s.methods), s.properties && Object.defineProperties(t, s.properties) }, hook: function(t, e, i) { var o, n, s, r, a = t.config.plugins,
                        h = [t.context]; for (i && (h = h.concat(i)), o = 0, n = a.length; o < n; o++) r = a[o], (s = a[o][e]) && s.apply(r, h) } } }, function(t, e, i) { "use strict";

            function o(t) { if (0 === t.length) return t; var e, i, o = t.split(/[_-]/); if (1 === o.length && o[0][0].toLowerCase() === o[0][0]) return t; for (i = o[0].toLowerCase(), e = 1; e < o.length; e++) i = i + o[e].charAt(0).toUpperCase() + o[e].substring(1).toLowerCase(); return i } o.prepended = function(t, e) { return e = o(e), t + e[0].toUpperCase() + e.substring(1) }, t.exports = o }, function(t, e, i) { "use strict";

            function o(t, e) { t = t || {}, this.options = t, this.defaults = e.defaults, this.states = [], this.transitions = [], this.map = {}, this.lifecycle = this.configureLifecycle(), this.init = this.configureInitTransition(t.init), this.data = this.configureData(t.data), this.methods = this.configureMethods(t.methods), this.map[this.defaults.wildcard] = {}, this.configureTransitions(t.transitions || []), this.plugins = this.configurePlugins(t.plugins, e.plugin) } var n = i(0),
                s = i(2);
            n(o.prototype, { addState: function(t) { this.map[t] || (this.states.push(t), this.addStateLifecycleNames(t), this.map[t] = {}) }, addStateLifecycleNames: function(t) { this.lifecycle.onEnter[t] = s.prepended("onEnter", t), this.lifecycle.onLeave[t] = s.prepended("onLeave", t), this.lifecycle.on[t] = s.prepended("on", t) }, addTransition: function(t) { this.transitions.indexOf(t) < 0 && (this.transitions.push(t), this.addTransitionLifecycleNames(t)) }, addTransitionLifecycleNames: function(t) { this.lifecycle.onBefore[t] = s.prepended("onBefore", t), this.lifecycle.onAfter[t] = s.prepended("onAfter", t), this.lifecycle.on[t] = s.prepended("on", t) }, mapTransition: function(t) { var e = t.name,
                        i = t.from,
                        o = t.to; return this.addState(i), "function" != typeof o && this.addState(o), this.addTransition(e), this.map[i][e] = t, t }, configureLifecycle: function() { return { onBefore: { transition: "onBeforeTransition" }, onAfter: { transition: "onAfterTransition" }, onEnter: { state: "onEnterState" }, onLeave: { state: "onLeaveState" }, on: { transition: "onTransition" } } }, configureInitTransition: function(t) { return "string" == typeof t ? this.mapTransition(n({}, this.defaults.init, { to: t, active: !0 })) : "object" == typeof t ? this.mapTransition(n({}, this.defaults.init, t, { active: !0 })) : (this.addState(this.defaults.init.from), this.defaults.init) }, configureData: function(t) { return "function" == typeof t ? t : "object" == typeof t ? function() { return t } : function() { return {} } }, configureMethods: function(t) { return t || {} }, configurePlugins: function(t, e) { var i, o, n; for (i = 0, o = (t = t || []).length; i < o; i++) "function" == typeof(n = t[i]) && (t[i] = n = n()), n.configure && n.configure(this); return t }, configureTransitions: function(t) { var e, i, o, n, s, r = this.defaults.wildcard; for (i = 0; i < t.length; i++)
                        for (o = t[i], n = Array.isArray(o.from) ? o.from : [o.from || r], s = o.to || r, e = 0; e < n.length; e++) this.mapTransition({ name: o.name, from: n[e], to: s }) }, transitionFor: function(t, e) { var i = this.defaults.wildcard; return this.map[t][e] || this.map[i][e] }, transitionsFor: function(t) { var e = this.defaults.wildcard; return Object.keys(this.map[t]).concat(Object.keys(this.map[e])) }, allStates: function() { return this.states }, allTransitions: function() { return this.transitions } }), t.exports = o }, function(t, e, i) {
            function o(t, e) { this.context = t, this.config = e, this.state = e.init.from, this.observers = [t] } var n = i(0),
                s = i(6),
                r = i(1),
                a = [null, []];
            n(o.prototype, { init: function(t) { if (n(this.context, this.config.data.apply(this.context, t)), r.hook(this, "init"), this.config.init.active) return this.fire(this.config.init.name, []) }, is: function(t) { return Array.isArray(t) ? t.indexOf(this.state) >= 0 : this.state === t }, isPending: function() { return this.pending }, can: function(t) { return !this.isPending() && !!this.seek(t) }, cannot: function(t) { return !this.can(t) }, allStates: function() { return this.config.allStates() }, allTransitions: function() { return this.config.allTransitions() }, transitions: function() { return this.config.transitionsFor(this.state) }, seek: function(t, e) { var i = this.config.defaults.wildcard,
                        o = this.config.transitionFor(this.state, t),
                        n = o && o.to; return "function" == typeof n ? n.apply(this.context, e) : n === i ? this.state : n }, fire: function(t, e) { return this.transit(t, this.state, this.seek(t, e), e) }, transit: function(t, e, i, o) { var n = this.config.lifecycle,
                        s = this.config.options.observeUnchangedState || e !== i; return i ? this.isPending() ? this.context.onPendingTransition(t, e, i) : (this.config.addState(i), this.beginTransit(), o.unshift({ transition: t, from: e, to: i, fsm: this.context }), this.observeEvents([this.observersForEvent(n.onBefore.transition), this.observersForEvent(n.onBefore[t]), s ? this.observersForEvent(n.onLeave.state) : a, s ? this.observersForEvent(n.onLeave[e]) : a, this.observersForEvent(n.on.transition), s ? ["doTransit", [this]] : a, s ? this.observersForEvent(n.onEnter.state) : a, s ? this.observersForEvent(n.onEnter[i]) : a, s ? this.observersForEvent(n.on[i]) : a, this.observersForEvent(n.onAfter.transition), this.observersForEvent(n.onAfter[t]), this.observersForEvent(n.on[t])], o)) : this.context.onInvalidTransition(t, e, i) }, beginTransit: function() { this.pending = !0 }, endTransit: function(t) { return this.pending = !1, t }, failTransit: function(t) { throw this.pending = !1, t }, doTransit: function(t) { this.state = t.to }, observe: function(t) { if (2 === t.length) { var e = {};
                        e[t[0]] = t[1], this.observers.push(e) } else this.observers.push(t[0]) }, observersForEvent: function(t) { for (var e, i = 0, o = this.observers.length, n = []; i < o; i++)(e = this.observers[i])[t] && n.push(e); return [t, n, !0] }, observeEvents: function(t, e, i, o) { if (0 === t.length) return this.endTransit(void 0 === o || o); var n = t[0][0],
                        s = t[0][1],
                        a = t[0][2]; if (e[0].event = n, n && a && n !== i && r.hook(this, "lifecycle", e), 0 === s.length) return t.shift(), this.observeEvents(t, e, n, o); var h = s.shift(),
                        l = h[n].apply(h, e); return l && "function" == typeof l.then ? l.then(this.observeEvents.bind(this, t, e, n)).catch(this.failTransit.bind(this)) : !1 === l ? this.endTransit(!1) : this.observeEvents(t, e, n, l) }, onInvalidTransition: function(t, e, i) { throw new s("transition is invalid in current state", t, e, i, this.state) }, onPendingTransition: function(t, e, i) { throw new s("transition is invalid while previous transition is still in progress", t, e, i, this.state) } }), t.exports = o }, function(t, e, i) { "use strict";

            function o(t) { return n(this || {}, t) }

            function n(t, e) { return s(t, new l(e, o)), t._fsm(), t }

            function s(t, e) { if ("object" != typeof t || Array.isArray(t)) throw Error("StateMachine can only be applied to objects");
                h.build(t, e), Object.defineProperties(t, u), r(t, d), r(t, e.methods), e.allTransitions().forEach(function(e) { t[a(e)] = function() { return this._fsm.fire(e, [].slice.call(arguments)) } }), t._fsm = function() { this._fsm = new c(this, e), this._fsm.init(arguments) } } var r = i(0),
                a = i(2),
                h = i(1),
                l = i(3),
                c = i(4),
                d = { is: function(t) { return this._fsm.is(t) }, can: function(t) { return this._fsm.can(t) }, cannot: function(t) { return this._fsm.cannot(t) }, observe: function() { return this._fsm.observe(arguments) }, transitions: function() { return this._fsm.transitions() }, allTransitions: function() { return this._fsm.allTransitions() }, allStates: function() { return this._fsm.allStates() }, onInvalidTransition: function(t, e, i) { return this._fsm.onInvalidTransition(t, e, i) }, onPendingTransition: function(t, e, i) { return this._fsm.onPendingTransition(t, e, i) } },
                u = { state: { configurable: !1, enumerable: !0, get: function() { return this._fsm.state }, set: function(t) { throw Error("use transitions to change state") } } };
            o.version = "3.0.1", o.factory = function() { var t, e; "function" == typeof arguments[0] ? (t = arguments[0], e = arguments[1] || {}) : (t = function() { this._fsm.apply(this, arguments) }, e = arguments[0] || {}); var i = new l(e, o); return s(t.prototype, i), t.prototype._fsm.config = i, t }, o.apply = n, o.defaults = { wildcard: "*", init: { name: "init", from: "none" } }, t.exports = o }, function(t, e, i) { "use strict";
            t.exports = function(t, e, i, o, n) { this.message = t, this.transition = e, this.from = i, this.to = o, this.current = n } }]) }),
    function() {
        function t(t, e, i) { return t.call.apply(t.bind, arguments) }

        function e(t, e, i) { if (!t) throw Error(); if (2 < arguments.length) { var o = Array.prototype.slice.call(arguments, 2); return function() { var i = Array.prototype.slice.call(arguments); return Array.prototype.unshift.apply(i, o), t.apply(e, i) } } return function() { return t.apply(e, arguments) } }

        function i(o, n, s) { return (i = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? t : e).apply(null, arguments) }

        function o(t, e) { this.a = t, this.o = e || t, this.c = this.o.document }

        function n(t, e, i, o) { if (e = t.c.createElement(e), i)
                for (var n in i) i.hasOwnProperty(n) && ("style" == n ? e.style.cssText = i[n] : e.setAttribute(n, i[n])); return o && e.appendChild(t.c.createTextNode(o)), e }

        function s(t, e, i) {
            (t = t.c.getElementsByTagName(e)[0]) || (t = document.documentElement), t.insertBefore(i, t.lastChild) }

        function r(t) { t.parentNode && t.parentNode.removeChild(t) }

        function a(t, e, i) { e = e || [], i = i || []; for (var o = t.className.split(/\s+/), n = 0; n < e.length; n += 1) { for (var s = !1, r = 0; r < o.length; r += 1)
                    if (e[n] === o[r]) { s = !0; break } s || o.push(e[n]) } for (e = [], n = 0; n < o.length; n += 1) { for (s = !1, r = 0; r < i.length; r += 1)
                    if (o[n] === i[r]) { s = !0; break } s || e.push(o[n]) } t.className = e.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "") }

        function h(t, e) { for (var i = t.className.split(/\s+/), o = 0, n = i.length; o < n; o++)
                if (i[o] == e) return !0; return !1 }

        function l(t) { return t.o.location.hostname || t.a.location.hostname }

        function c(t, e, i) {
            function o() { l && r && a && (l(h), l = null) } e = n(t, "link", { rel: "stylesheet", href: e, media: "all" }); var r = !1,
                a = !0,
                h = null,
                l = i || null;
            et ? (e.onload = function() { r = !0, o() }, e.onerror = function() { r = !0, h = Error("Stylesheet failed to load"), o() }) : setTimeout(function() { r = !0, o() }, 0), s(t, "head", e) }

        function d(t, e, i, o) { var s = t.c.getElementsByTagName("head")[0]; if (s) { var r = n(t, "script", { src: e }),
                    a = !1; return r.onload = r.onreadystatechange = function() { a || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (a = !0, i && i(null), r.onload = r.onreadystatechange = null, "HEAD" == r.parentNode.tagName && s.removeChild(r)) }, s.appendChild(r), setTimeout(function() { a || (a = !0, i && i(Error("Script load timeout"))) }, o || 5e3), r } return null }

        function u() { this.a = 0, this.c = null }

        function p(t) { return t.a++,
                function() { t.a--, f(t) } }

        function m(t, e) { t.c = e, f(t) }

        function f(t) { 0 == t.a && t.c && (t.c(), t.c = null) }

        function y(t) { this.a = t || "-" }

        function b(t, e) { this.c = t, this.f = 4, this.a = "n"; var i = (e || "n4").match(/^([nio])([1-9])$/i);
            i && (this.a = i[1], this.f = parseInt(i[2], 10)) }

        function g(t) { return x(t) + " " + t.f + "00 300px " + _(t.c) }

        function _(t) { var e = [];
            t = t.split(/,\s*/); for (var i = 0; i < t.length; i++) { var o = t[i].replace(/['"]/g, ""); - 1 != o.indexOf(" ") || /^\d/.test(o) ? e.push("'" + o + "'") : e.push(o) } return e.join(",") }

        function v(t) { return t.a + t.f }

        function x(t) { var e = "normal"; return "o" === t.a ? e = "oblique" : "i" === t.a && (e = "italic"), e }

        function S(t) { var e = 4,
                i = "n",
                o = null; return t && ((o = t.match(/(normal|oblique|italic)/i)) && o[1] && (i = o[1].substr(0, 1).toLowerCase()), (o = t.match(/([1-9]00|normal|bold)/i)) && o[1] && (/bold/i.test(o[1]) ? e = 7 : /[1-9]00/.test(o[1]) && (e = parseInt(o[1].substr(0, 1), 10)))), i + e }

        function C(t, e) { this.c = t, this.f = t.o.document.documentElement, this.h = e, this.a = new y("-"), this.j = !1 !== e.events, this.g = !1 !== e.classes }

        function w(t) { t.g && a(t.f, [t.a.c("wf", "loading")]), T(t, "loading") }

        function A(t) { if (t.g) { var e = h(t.f, t.a.c("wf", "active")),
                    i = [],
                    o = [t.a.c("wf", "loading")];
                e || i.push(t.a.c("wf", "inactive")), a(t.f, i, o) } T(t, "inactive") }

        function T(t, e, i) { t.j && t.h[e] && (i ? t.h[e](i.c, v(i)) : t.h[e]()) }

        function P() { this.c = {} }

        function k(t, e, i) { var o, n = []; for (o in e)
                if (e.hasOwnProperty(o)) { var s = t.c[o];
                    s && n.push(s(e[o], i)) } return n }

        function M(t, e) { this.c = t, this.f = e, this.a = n(this.c, "span", { "aria-hidden": "true" }, this.f) }

        function E(t) { s(t.c, "body", t.a) }

        function B(t) { return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + _(t.c) + ";font-style:" + x(t) + ";font-weight:" + t.f + "00;" }

        function I(t, e, i, o, n, s) { this.g = t, this.j = e, this.a = o, this.c = i, this.f = n || 3e3, this.h = s || void 0 }

        function D(t, e, i, o, n, s, r) { this.v = t, this.B = e, this.c = i, this.a = o, this.s = r || "BESbswy", this.f = {}, this.w = n || 3e3, this.u = s || null, this.m = this.j = this.h = this.g = null, this.g = new M(this.c, this.s), this.h = new M(this.c, this.s), this.j = new M(this.c, this.s), this.m = new M(this.c, this.s), t = B(t = new b(this.a.c + ",serif", v(this.a))), this.g.a.style.cssText = t, t = B(t = new b(this.a.c + ",sans-serif", v(this.a))), this.h.a.style.cssText = t, t = B(t = new b("serif", v(this.a))), this.j.a.style.cssText = t, t = B(t = new b("sans-serif", v(this.a))), this.m.a.style.cssText = t, E(this.g), E(this.h), E(this.j), E(this.m) }

        function L() { if (null === ot) { var t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
                ot = !!t && (536 > parseInt(t[1], 10) || 536 === parseInt(t[1], 10) && 11 >= parseInt(t[2], 10)) } return ot }

        function O(t, e, i) { for (var o in it)
                if (it.hasOwnProperty(o) && e === t.f[it[o]] && i === t.f[it[o]]) return !0; return !1 }

        function R(t) { var e, i = t.g.a.offsetWidth,
                o = t.h.a.offsetWidth;
            (e = i === t.f.serif && o === t.f["sans-serif"]) || (e = L() && O(t, i, o)), e ? tt() - t.A >= t.w ? L() && O(t, i, o) && (null === t.u || t.u.hasOwnProperty(t.a.c)) ? V(t, t.v) : V(t, t.B) : F(t) : V(t, t.v) }

        function F(t) { setTimeout(i(function() { R(this) }, t), 50) }

        function V(t, e) { setTimeout(i(function() { r(this.g.a), r(this.h.a), r(this.j.a), r(this.m.a), e(this.a) }, t), 0) }

        function G(t, e, i) { this.c = t, this.a = e, this.f = 0, this.m = this.j = !1, this.s = i }

        function U(t) { 0 == --t.f && t.j && (t.m ? ((t = t.a).g && a(t.f, [t.a.c("wf", "active")], [t.a.c("wf", "loading"), t.a.c("wf", "inactive")]), T(t, "active")) : A(t.a)) }

        function N(t) { this.j = t, this.a = new P, this.h = 0, this.f = this.g = !0 }

        function j(t, e, o, n, s) { var r = 0 == --t.h;
            (t.f || t.g) && setTimeout(function() { var t = s || null,
                    h = n || null || {}; if (0 === o.length && r) A(e.a);
                else { e.f += o.length, r && (e.j = r); var l, c = []; for (l = 0; l < o.length; l++) { var d = o[l],
                            u = h[d.c],
                            p = e.a,
                            m = d; if (p.g && a(p.f, [p.a.c("wf", m.c, v(m).toString(), "loading")]), T(p, "fontloading", m), p = null, null === nt)
                            if (window.FontFace) { var m = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                                    f = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                                nt = m ? 42 < parseInt(m[1], 10) : !f } else nt = !1;
                        p = nt ? new I(i(e.g, e), i(e.h, e), e.c, d, e.s, u) : new D(i(e.g, e), i(e.h, e), e.c, d, e.s, t, u), c.push(p) } for (l = 0; l < c.length; l++) c[l].start() } }, 0) }

        function W(t, e, i) { var o = [],
                n = i.timeout;
            w(e); var o = k(t.a, i, t.c),
                s = new G(t.c, e, n); for (t.h = o.length, e = 0, i = o.length; e < i; e++) o[e].load(function(e, i, o) { j(t, s, e, i, o) }) }

        function X(t, e) { this.c = t, this.a = e }

        function H(t, e) { this.c = t, this.a = e }

        function z(t, e) { this.c = t || st, this.a = [], this.f = [], this.g = e || "" }

        function J(t, e) { for (var i = e.length, o = 0; o < i; o++) { var n = e[o].split(":");
                3 == n.length && t.f.push(n.pop()); var s = "";
                2 == n.length && "" != n[1] && (s = ":"), t.a.push(n.join(s)) } }

        function q(t) { if (0 == t.a.length) throw Error("No fonts to load!"); if (-1 != t.c.indexOf("kit=")) return t.c; for (var e = t.a.length, i = [], o = 0; o < e; o++) i.push(t.a[o].replace(/ /g, "+")); return e = t.c + "?family=" + i.join("%7C"), 0 < t.f.length && (e += "&subset=" + t.f.join(",")), 0 < t.g.length && (e += "&text=" + encodeURIComponent(t.g)), e }

        function Y(t) { this.f = t, this.a = [], this.c = {} }

        function K(t) { for (var e = t.f.length, i = 0; i < e; i++) { var o = t.f[i].split(":"),
                    n = o[0].replace(/\+/g, " "),
                    s = ["n4"]; if (2 <= o.length) { var r; if (r = [], a = o[1])
                        for (var a = a.split(","), h = a.length, l = 0; l < h; l++) { var c; if ((c = a[l]).match(/^[\w-]+$/))
                                if (null == (u = lt.exec(c.toLowerCase()))) c = "";
                                else { if (c = u[2], c = null == c || "" == c ? "n" : ht[c], null == (u = u[1]) || "" == u) u = "4";
                                    else var d = at[u],
                                        u = d || (isNaN(u) ? "4" : u.substr(0, 1));
                                    c = [c, u].join("") } else c = "";
                            c && r.push(c) } 0 < r.length && (s = r), 3 == o.length && (o = o[2], r = [], 0 < (o = o ? o.split(",") : r).length && (o = rt[o[0]]) && (t.c[n] = o)) } for (t.c[n] || (o = rt[n]) && (t.c[n] = o), o = 0; o < s.length; o += 1) t.a.push(new b(n, s[o])) } }

        function Z(t, e) { this.c = t, this.a = e }

        function Q(t, e) { this.c = t, this.a = e }

        function $(t, e) { this.c = t, this.f = e, this.a = [] } var tt = Date.now || function() { return +new Date },
            et = !!window.FontFace;
        y.prototype.c = function(t) { for (var e = [], i = 0; i < arguments.length; i++) e.push(arguments[i].replace(/[\W_]+/g, "").toLowerCase()); return e.join(this.a) }, I.prototype.start = function() { var t = this.c.o.document,
                e = this,
                i = tt(),
                o = new Promise(function(o, n) {
                    function s() { tt() - i >= e.f ? n() : t.fonts.load(g(e.a), e.h).then(function(t) { 1 <= t.length ? o() : setTimeout(s, 25) }, function() { n() }) } s() }),
                n = null,
                s = new Promise(function(t, i) { n = setTimeout(i, e.f) });
            Promise.race([s, o]).then(function() { n && (clearTimeout(n), n = null), e.g(e.a) }, function() { e.j(e.a) }) }; var it = { D: "serif", C: "sans-serif" },
            ot = null;
        D.prototype.start = function() { this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = tt(), R(this) }; var nt = null;
        G.prototype.g = function(t) { var e = this.a;
            e.g && a(e.f, [e.a.c("wf", t.c, v(t).toString(), "active")], [e.a.c("wf", t.c, v(t).toString(), "loading"), e.a.c("wf", t.c, v(t).toString(), "inactive")]), T(e, "fontactive", t), this.m = !0, U(this) }, G.prototype.h = function(t) { var e = this.a; if (e.g) { var i = h(e.f, e.a.c("wf", t.c, v(t).toString(), "active")),
                    o = [],
                    n = [e.a.c("wf", t.c, v(t).toString(), "loading")];
                i || o.push(e.a.c("wf", t.c, v(t).toString(), "inactive")), a(e.f, o, n) } T(e, "fontinactive", t), U(this) }, N.prototype.load = function(t) { this.c = new o(this.j, t.context || this.j), this.g = !1 !== t.events, this.f = !1 !== t.classes, W(this, new C(this.c, t), t) }, X.prototype.load = function(t) {
            function e() { if (s["__mti_fntLst" + o]) { var i, n = s["__mti_fntLst" + o](),
                        r = []; if (n)
                        for (var a = 0; a < n.length; a++) { var h = n[a].fontfamily;
                            void 0 != n[a].fontStyle && void 0 != n[a].fontWeight ? (i = n[a].fontStyle + n[a].fontWeight, r.push(new b(h, i))) : r.push(new b(h)) } t(r) } else setTimeout(function() { e() }, 50) } var i = this,
                o = i.a.projectId,
                n = i.a.version; if (o) { var s = i.c.o;
                d(this.c, (i.a.api || "https://fast.fonts.net/jsapi") + "/" + o + ".js" + (n ? "?v=" + n : ""), function(n) { n ? t([]) : (s["__MonotypeConfiguration__" + o] = function() { return i.a }, e()) }).id = "__MonotypeAPIScript__" + o } else t([]) }, H.prototype.load = function(t) { var e, i, o = this.a.urls || [],
                n = this.a.families || [],
                s = this.a.testStrings || {},
                r = new u; for (e = 0, i = o.length; e < i; e++) c(this.c, o[e], p(r)); var a = []; for (e = 0, i = n.length; e < i; e++)
                if ((o = n[e].split(":"))[1])
                    for (var h = o[1].split(","), l = 0; l < h.length; l += 1) a.push(new b(o[0], h[l]));
                else a.push(new b(o[0]));
            m(r, function() { t(a, s) }) }; var st = "https://fonts.googleapis.com/css",
            rt = { latin: "BESbswy", "latin-ext": "çöüğş", cyrillic: "йяЖ", greek: "αβΣ", khmer: "កខគ", Hanuman: "កខគ" },
            at = { thin: "1", extralight: "2", "extra-light": "2", ultralight: "2", "ultra-light": "2", light: "3", regular: "4", book: "4", medium: "5", "semi-bold": "6", semibold: "6", "demi-bold": "6", demibold: "6", bold: "7", "extra-bold": "8", extrabold: "8", "ultra-bold": "8", ultrabold: "8", black: "9", heavy: "9", l: "3", r: "4", b: "7" },
            ht = { i: "i", italic: "i", n: "n", normal: "n" },
            lt = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/,
            ct = { Arimo: !0, Cousine: !0, Tinos: !0 };
        Z.prototype.load = function(t) { var e = new u,
                i = this.c,
                o = new z(this.a.api, this.a.text),
                n = this.a.families;
            J(o, n); var s = new Y(n);
            K(s), c(i, q(o), p(e)), m(e, function() { t(s.a, s.c, ct) }) }, Q.prototype.load = function(t) { var e = this.a.id,
                i = this.c.o;
            e ? d(this.c, (this.a.api || "https://use.typekit.net") + "/" + e + ".js", function(e) { if (e) t([]);
                else if (i.Typekit && i.Typekit.config && i.Typekit.config.fn) { e = i.Typekit.config.fn; for (var o = [], n = 0; n < e.length; n += 2)
                        for (var s = e[n], r = e[n + 1], a = 0; a < r.length; a++) o.push(new b(s, r[a])); try { i.Typekit.load({ events: !1, classes: !1, async: !0 }) } catch (t) {} t(o) } }, 2e3) : t([]) }, $.prototype.load = function(t) { var e = this.f.id,
                i = this.c.o,
                o = this;
            e ? (i.__webfontfontdeckmodule__ || (i.__webfontfontdeckmodule__ = {}), i.__webfontfontdeckmodule__[e] = function(e, i) { for (var n = 0, s = i.fonts.length; n < s; ++n) { var r = i.fonts[n];
                    o.a.push(new b(r.name, S("font-weight:" + r.weight + ";font-style:" + r.style))) } t(o.a) }, d(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + l(this.c) + "/" + e + ".js", function(e) { e && t([]) })) : t([]) }; var dt = new N(window);
        dt.a.c.custom = function(t, e) { return new H(e, t) }, dt.a.c.fontdeck = function(t, e) { return new $(e, t) }, dt.a.c.monotype = function(t, e) { return new X(e, t) }, dt.a.c.typekit = function(t, e) { return new Q(e, t) }, dt.a.c.google = function(t, e) { return new Z(e, t) }; var ut = { load: i(dt.load, dt) }; "function" == typeof define && define.amd ? define(function() { return ut }) : "undefined" != typeof module && module.exports ? module.exports = ut : (window.WebFont = ut, window.WebFontConfig && dt.load(window.WebFontConfig)) }(),
    function(t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require("global/document"), require("global/window")) : "function" == typeof define && define.amd ? define(["global/document", "global/window"], e) : t.videojs = e(t.document, t.window) }(this, function(t, e) {
        function i(t, e) { t.prototype = Object.create(e.prototype), (t.prototype.constructor = t).__proto__ = e }

        function o(t, e) { return (o = Object.setPrototypeOf || function(t, e) { return t.__proto__ = e, t })(t, e) }

        function n(t, e, i) { return (n = function() { if ("undefined" == typeof Reflect || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if ("function" == typeof Proxy) return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], function() {})), !0 } catch (t) { return !1 } }() ? Reflect.construct : function(t, e, i) { var n = [null];
                n.push.apply(n, e); var s = new(Function.bind.apply(t, n)); return i && o(s, i.prototype), s }).apply(null, arguments) }

        function s(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t }

        function r(t, e) { return e || (e = t.slice(0)), t.raw = e, t }

        function a(t, e) { Qt(t).forEach(function(i) { return e(t[i], i) }) }

        function h(t) { for (var e = arguments.length, i = new Array(1 < e ? e - 1 : 0), o = 1; o < e; o++) i[o - 1] = arguments[o]; return Object.assign ? Object.assign.apply(Object, [t].concat(i)) : (i.forEach(function(e) { e && a(e, function(e, i) { t[i] = e }) }), t) }

        function l(t) { return !!t && "object" == typeof t }

        function c(t) { return l(t) && "[object Object]" === Zt.call(t) && t.constructor === Object }

        function d(t, i) { if (!t || !i) return ""; if ("function" != typeof e.getComputedStyle) return ""; var o = e.getComputedStyle(t); return o ? o[i] : "" }

        function u() { var t = r(["Setting attributes in the second argument of createEl()\n                has been deprecated. Use the third argument instead.\n                createEl(type, properties, attributes). Attempting to set ", " to ", "."]); return u = function() { return t }, t }

        function p(t) { return "string" == typeof t && /\S/.test(t) }

        function m(t) { if (/\s/.test(t)) throw new Error("class has illegal whitespace characters") }

        function f() { return t === e.document }

        function y(t) { return l(t) && 1 === t.nodeType }

        function b() { try { return e.parent !== e.self } catch (t) { return !0 } }

        function g(e) { return function(i, o) { if (!p(i)) return t[e](null);
                p(o) && (o = t.querySelector(o)); var n = y(o) ? o : t; return n[e] && n[e](i) } }

        function _(e, i, o, n) { void 0 === e && (e = "div"), void 0 === i && (i = {}), void 0 === o && (o = {}); var s = t.createElement(e); return Object.getOwnPropertyNames(i).forEach(function(t) { var e = i[t]; - 1 !== t.indexOf("aria-") || "role" === t || "type" === t ? (qt.warn(Kt(u(), t, e)), s.setAttribute(t, e)) : "textContent" === t ? v(s, e) : s[t] = e }), Object.getOwnPropertyNames(o).forEach(function(t) { s.setAttribute(t, o[t]) }), n && G(s, n), s }

        function v(t, e) { return void 0 === t.textContent ? t.innerText = e : t.textContent = e, t }

        function x(t, e) { e.firstChild ? e.insertBefore(t, e.firstChild) : e.appendChild(t) }

        function S(t, e) { return m(e), t.classList ? t.classList.contains(e) : (i = e, new RegExp("(^|\\s)" + i + "($|\\s)")).test(t.className); var i }

        function C(t, e) { return t.classList ? t.classList.add(e) : S(t, e) || (t.className = (t.className + " " + e).trim()), t }

        function w(t, e) { return t.classList ? t.classList.remove(e) : (m(e), t.className = t.className.split(/\s+/).filter(function(t) { return t !== e }).join(" ")), t }

        function A(t, e, i) { var o = S(t, e); if ("function" == typeof i && (i = i(t, e)), "boolean" != typeof i && (i = !o), i !== o) return i ? C(t, e) : w(t, e), t }

        function T(t, e) { Object.getOwnPropertyNames(e).forEach(function(i) { var o = e[i];
                null === o || void 0 === o || !1 === o ? t.removeAttribute(i) : t.setAttribute(i, !0 === o ? "" : o) }) }

        function P(t) { var e = {}; if (t && t.attributes && 0 < t.attributes.length)
                for (var i = t.attributes, o = i.length - 1; 0 <= o; o--) { var n = i[o].name,
                        s = i[o].value; "boolean" != typeof t[n] && -1 === ",autoplay,controls,playsinline,loop,muted,default,defaultMuted,".indexOf("," + n + ",") || (s = null !== s), e[n] = s }
            return e }

        function k(t, e) { return t.getAttribute(e) }

        function M(t, e, i) { t.setAttribute(e, i) }

        function E(t, e) { t.removeAttribute(e) }

        function B() { t.body.focus(), t.onselectstart = function() { return !1 } }

        function I() { t.onselectstart = function() { return !0 } }

        function D(t) { if (t && t.getBoundingClientRect && t.parentNode) { var e = t.getBoundingClientRect(),
                    i = {}; return ["bottom", "height", "left", "right", "top", "width"].forEach(function(t) { void 0 !== e[t] && (i[t] = e[t]) }), i.height || (i.height = parseFloat(d(t, "height"))), i.width || (i.width = parseFloat(d(t, "width"))), i } }

        function L(i) { var o; if (i.getBoundingClientRect && i.parentNode && (o = i.getBoundingClientRect()), !o) return { left: 0, top: 0 }; var n = t.documentElement,
                s = t.body,
                r = n.clientLeft || s.clientLeft || 0,
                a = e.pageXOffset || s.scrollLeft,
                h = o.left + a - r,
                l = n.clientTop || s.clientTop || 0,
                c = e.pageYOffset || s.scrollTop,
                d = o.top + c - l; return { left: Math.round(h), top: Math.round(d) } }

        function O(t, e) { var i = {},
                o = L(t),
                n = t.offsetWidth,
                s = t.offsetHeight,
                r = o.top,
                a = o.left,
                h = e.pageY,
                l = e.pageX; return e.changedTouches && (l = e.changedTouches[0].pageX, h = e.changedTouches[0].pageY), i.y = Math.max(0, Math.min(1, (r - h + s) / s)), i.x = Math.max(0, Math.min(1, (l - a) / n)), i }

        function R(t) { return l(t) && 3 === t.nodeType }

        function F(t) { for (; t.firstChild;) t.removeChild(t.firstChild); return t }

        function V(e) { return "function" == typeof e && (e = e()), (Array.isArray(e) ? e : [e]).map(function(e) { return "function" == typeof e && (e = e()), y(e) || R(e) ? e : "string" == typeof e && /\S/.test(e) ? t.createTextNode(e) : void 0 }).filter(function(t) { return t }) }

        function G(t, e) { return V(e).forEach(function(e) { return t.appendChild(e) }), t }

        function U(t, e) { return G(F(t), e) }

        function N(t) { return void 0 === t.button && void 0 === t.buttons || 0 === t.button && void 0 === t.buttons || 0 === t.button && 1 === t.buttons }

        function j() { return ie++ }

        function W(t) { var e = t[ne]; return e || (e = t[ne] = j()), oe[e] || (oe[e] = {}), oe[e] }

        function X(t) { var e = t[ne]; return !!e && !!Object.getOwnPropertyNames(oe[e]).length }

        function H(t) { var e = t[ne]; if (e) { delete oe[e]; try { delete t[ne] } catch (e) { t.removeAttribute ? t.removeAttribute(ne) : t[ne] = null } } }

        function z(t, e) { var i = W(t);
            0 === i.handlers[e].length && (delete i.handlers[e], t.removeEventListener ? t.removeEventListener(e, i.dispatcher, !1) : t.detachEvent && t.detachEvent("on" + e, i.dispatcher)), Object.getOwnPropertyNames(i.handlers).length <= 0 && (delete i.handlers, delete i.dispatcher, delete i.disabled), 0 === Object.getOwnPropertyNames(i).length && H(t) }

        function J(t, e, i, o) { i.forEach(function(i) { t(e, i, o) }) }

        function q(i) {
            function o() { return !0 }

            function n() { return !1 } if (!i || !i.isPropagationStopped) { var s = i || e.event; for (var r in i = {}, s) "layerX" !== r && "layerY" !== r && "keyLocation" !== r && "webkitMovementX" !== r && "webkitMovementY" !== r && ("returnValue" === r && s.preventDefault || (i[r] = s[r])); if (i.target || (i.target = i.srcElement || t), i.relatedTarget || (i.relatedTarget = i.fromElement === i.target ? i.toElement : i.fromElement), i.preventDefault = function() { s.preventDefault && s.preventDefault(), i.returnValue = !1, s.returnValue = !1, i.defaultPrevented = !0 }, i.defaultPrevented = !1, i.stopPropagation = function() { s.stopPropagation && s.stopPropagation(), i.cancelBubble = !0, s.cancelBubble = !0, i.isPropagationStopped = o }, i.isPropagationStopped = n, i.stopImmediatePropagation = function() { s.stopImmediatePropagation && s.stopImmediatePropagation(), i.isImmediatePropagationStopped = o, i.stopPropagation() }, i.isImmediatePropagationStopped = n, null !== i.clientX && void 0 !== i.clientX) { var a = t.documentElement,
                        h = t.body;
                    i.pageX = i.clientX + (a && a.scrollLeft || h && h.scrollLeft || 0) - (a && a.clientLeft || h && h.clientLeft || 0), i.pageY = i.clientY + (a && a.scrollTop || h && h.scrollTop || 0) - (a && a.clientTop || h && h.clientTop || 0) } i.which = i.charCode || i.keyCode, null !== i.button && void 0 !== i.button && (i.button = 1 & i.button ? 0 : 4 & i.button ? 1 : 2 & i.button ? 2 : 0) } return i }

        function Y(t, e, i) { if (Array.isArray(e)) return J(Y, t, e, i); var o = W(t); if (o.handlers || (o.handlers = {}), o.handlers[e] || (o.handlers[e] = []), i.guid || (i.guid = j()), o.handlers[e].push(i), o.dispatcher || (o.disabled = !1, o.dispatcher = function(e, i) { if (!o.disabled) { e = q(e); var n = o.handlers[e.type]; if (n)
                            for (var s = n.slice(0), r = 0, a = s.length; r < a && !e.isImmediatePropagationStopped(); r++) try { s[r].call(t, e, i) } catch (e) { qt.error(e) } } }), 1 === o.handlers[e].length)
                if (t.addEventListener) { var n = !1;
                    se && -1 < ae.indexOf(e) && (n = { passive: !0 }), t.addEventListener(e, o.dispatcher, n) } else t.attachEvent && t.attachEvent("on" + e, o.dispatcher) }

        function K(t, e, i) { if (X(t)) { var o = W(t); if (o.handlers) { if (Array.isArray(e)) return J(K, t, e, i); var n = function(t, e) { o.handlers[e] = [], z(t, e) }; if (void 0 !== e) { var s = o.handlers[e]; if (s)
                            if (i) { if (i.guid)
                                    for (var r = 0; r < s.length; r++) s[r].guid === i.guid && s.splice(r--, 1);
                                z(t, e) } else n(t, e) } else
                        for (var a in o.handlers) Object.prototype.hasOwnProperty.call(o.handlers || {}, a) && n(t, a) } } }

        function Z(t, e, i) { var o = X(t) ? W(t) : {},
                n = t.parentNode || t.ownerDocument; if ("string" == typeof e ? e = { type: e, target: t } : e.target || (e.target = t), e = q(e), o.dispatcher && o.dispatcher.call(t, e, i), n && !e.isPropagationStopped() && !0 === e.bubbles) Z.call(null, n, e, i);
            else if (!n && !e.defaultPrevented) { var s = W(e.target);
                e.target[e.type] && (s.disabled = !0, "function" == typeof e.target[e.type] && e.target[e.type](), s.disabled = !1) } return !e.defaultPrevented }

        function Q(t, e, i) { if (Array.isArray(e)) return J(Q, t, e, i); var o = function o() { K(t, e, o), i.apply(this, arguments) };
            o.guid = i.guid = i.guid || j(), Y(t, e, o) }

        function $(t, i) { i && (re = i), e.setTimeout(ce, t) }

        function tt(t, i) { void 0 === i && (i = {}); var o = i.eventBusKey; if (o) { if (!t[o].nodeName) throw new Error('The eventBusKey "' + o + '" does not refer to an element.');
                t.eventBusEl_ = t[o] } else t.eventBusEl_ = _("span", { className: "vjs-event-bus" }); return h(t, we), t.eventedCallbacks && t.eventedCallbacks.forEach(function(t) { t() }), t.on("dispose", function() { t.off(), e.setTimeout(function() { t.eventBusEl_ = null }, 0) }), t }

        function et(t, e) { return h(t, Ae), t.state = h({}, t.state, e), "function" == typeof t.handleStateChanged && be(t) && t.on("statechanged", t.handleStateChanged), t }

        function it(t) { return "string" != typeof t ? t : t.charAt(0).toUpperCase() + t.slice(1) }

        function ot() { for (var t = {}, e = arguments.length, i = new Array(e), o = 0; o < e; o++) i[o] = arguments[o]; return i.forEach(function(e) { e && a(e, function(e, i) { c(e) ? (c(t[i]) || (t[i] = {}), t[i] = ot(t[i], e)) : t[i] = e }) }), t }

        function nt(t, e, i, o) { return function(t, e, i) { if ("number" != typeof e || e < 0 || i < e) throw new Error("Failed to execute '" + t + "' on 'TimeRanges': The index provided (" + e + ") is non-numeric or out of bounds (0-" + i + ").") }(t, o, i.length - 1), i[o][e] }

        function st(t) { return void 0 === t || 0 === t.length ? { length: 0, start: function() { throw new Error("This TimeRanges object is empty") }, end: function() { throw new Error("This TimeRanges object is empty") } } : { length: t.length, start: nt.bind(null, "start", 0, t), end: nt.bind(null, "end", 1, t) } }

        function rt(t, e) { return Array.isArray(t) ? st(t) : void 0 === t || void 0 === e ? st() : st([
                [t, e]
            ]) }

        function at(t, e) { var i, o, n = 0; if (!e) return 0;
            t && t.length || (t = rt(0, 0)); for (var s = 0; s < t.length; s++) i = t.start(s), e < (o = t.end(s)) && (o = e), n += o - i; return n / e }

        function ht(t) { if (t instanceof ht) return t; "number" == typeof t ? this.code = t : "string" == typeof t ? this.message = t : l(t) && ("number" == typeof t.code && (this.code = t.code), h(this, t)), this.message || (this.message = ht.defaultMessages[this.code] || "") }

        function lt(t) { return null != t && "function" == typeof t.then }

        function ct(t) { lt(t) && t.then(null, function(t) {}) }

        function dt(t, e) { return t(e = { exports: {} }, e.exports), e.exports }

        function ut(t, e, i) { var o = t; return Mi(e) ? (i = e, "string" == typeof t && (o = { uri: t })) : o = ji(e, { uri: t }), o.callback = i, o }

        function pt(t, e, i) { return mt(e = ut(t, e, i)) }

        function mt(t) {
            function e(t) { return clearTimeout(h), t instanceof Error || (t = new Error("" + (t || "Unknown XMLHttpRequest Error"))), t.statusCode = 0, r(t, f) }

            function i() { if (!n) { var e;
                    clearTimeout(h), e = t.useXDR && void 0 === a.status ? 200 : 1223 === a.status ? 204 : a.status; var i = f,
                        o = null; return 0 !== e ? (i = { body: function() { var t = void 0; if (t = a.response ? a.response : a.responseText || function(t) { if ("document" === t.responseType) return t.responseXML; var e = t.responseXML && "parsererror" === t.responseXML.documentElement.nodeName; return "" !== t.responseType || e ? null : t.responseXML }(a), m) try { t = JSON.parse(t) } catch (t) {}
                            return t }(), statusCode: e, method: c, headers: {}, url: l, rawRequest: a }, a.getAllResponseHeaders && (i.headers = Ni(a.getAllResponseHeaders()))) : o = new Error("Internal XMLHttpRequest Error"), r(o, i, i.body) } } if (void 0 === t.callback) throw new Error("callback argument missing"); var o, n, s = !1,
                r = function(e, i, o) { s || (s = !0, t.callback(e, i, o)) },
                a = t.xhr || null;
            a || (a = t.cors || t.useXDR ? new pt.XDomainRequest : new pt.XMLHttpRequest); var h, l = a.url = t.uri || t.url,
                c = a.method = t.method || "GET",
                d = t.body || t.data,
                u = a.headers = t.headers || {},
                p = !!t.sync,
                m = !1,
                f = { body: void 0, headers: {}, statusCode: 0, method: c, url: l, rawRequest: a }; if ("json" in t && !1 !== t.json && (m = !0, u.accept || u.Accept || (u.Accept = "application/json"), "GET" !== c && "HEAD" !== c && (u["content-type"] || u["Content-Type"] || (u["Content-Type"] = "application/json"), d = JSON.stringify(!0 === t.json ? d : t.json))), a.onreadystatechange = function() { 4 === a.readyState && setTimeout(i, 0) }, a.onload = i, a.onerror = e, a.onprogress = function() {}, a.onabort = function() { n = !0 }, a.ontimeout = e, a.open(c, l, !p, t.username, t.password), p || (a.withCredentials = !!t.withCredentials), !p && 0 < t.timeout && (h = setTimeout(function() { if (!n) { n = !0, a.abort("timeout"); var t = new Error("XMLHttpRequest timeout");
                        t.code = "ETIMEDOUT", e(t) } }, t.timeout)), a.setRequestHeader)
                for (o in u) u.hasOwnProperty(o) && a.setRequestHeader(o, u[o]);
            else if (t.headers && ! function(t) { for (var e in t)
                        if (t.hasOwnProperty(e)) return !1; return !0 }(t.headers)) throw new Error("Headers cannot be set on an XDomainRequest object"); return "responseType" in t && (a.responseType = t.responseType), "beforeSend" in t && "function" == typeof t.beforeSend && t.beforeSend(a), a.send(d || null), a }

        function ft(t, e) { this.name = "ParsingError", this.code = t.code, this.message = e || t.message }

        function yt(t) {
            function e(t, e, i, o) { return 3600 * (0 | t) + 60 * (0 | e) + (0 | i) + (0 | o) / 1e3 } var i = t.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/); return i ? i[3] ? e(i[1], i[2], i[3].replace(":", ""), i[4]) : 59 < i[1] ? e(i[1], i[2], 0, i[4]) : e(0, i[1], i[2], i[4]) : null }

        function bt() { this.values = $i(null) }

        function gt(t, e, i, o) { var n = o ? t.split(o) : [t]; for (var s in n)
                if ("string" == typeof n[s]) { var r = n[s].split(i);
                    2 === r.length && e(r[0], r[1]) } }

        function _t(t, e, i) {
            function o() { var e = yt(t); if (null === e) throw new ft(ft.Errors.BadTimeStamp, "Malformed timestamp: " + h); return t = t.replace(/^[^\sa-zA-Z-]+/, ""), e }

            function n() { t = t.replace(/^\s+/, "") } var s, r, a, h = t; if (n(), e.startTime = o(), n(), "--\x3e" !== t.substr(0, 3)) throw new ft(ft.Errors.BadTimeStamp, "Malformed time stamp (time stamps must be separated by '--\x3e'): " + h);
            t = t.substr(3), n(), e.endTime = o(), n(), s = t, r = e, a = new bt, gt(s, function(t, e) { switch (t) {
                    case "region":
                        for (var o = i.length - 1; 0 <= o; o--)
                            if (i[o].id === e) { a.set(t, i[o].region); break } break;
                    case "vertical":
                        a.alt(t, e, ["rl", "lr"]); break;
                    case "line":
                        var n = e.split(","),
                            s = n[0];
                        a.integer(t, s), a.percent(t, s) && a.set("snapToLines", !1), a.alt(t, s, ["auto"]), 2 === n.length && a.alt("lineAlign", n[1], ["start", "middle", "end"]); break;
                    case "position":
                        n = e.split(","), a.percent(t, n[0]), 2 === n.length && a.alt("positionAlign", n[1], ["start", "middle", "end"]); break;
                    case "size":
                        a.percent(t, e); break;
                    case "align":
                        a.alt(t, e, ["start", "middle", "end", "left", "right"]) } }, /:/, /\s/), r.region = a.get("region", null), r.vertical = a.get("vertical", ""), r.line = a.get("line", "auto"), r.lineAlign = a.get("lineAlign", "start"), r.snapToLines = a.get("snapToLines", !0), r.size = a.get("size", 100), r.align = a.get("align", "middle"), r.position = a.get("position", { start: 0, left: 0, middle: 50, end: 100, right: 100 }, r.align), r.positionAlign = a.get("positionAlign", { start: "start", left: "start", middle: "middle", end: "end", right: "end" }, r.align) }

        function vt(t, e) {
            function i(t) { return to[t] } for (var o, n, s, r = t.document.createElement("div"), a = r, h = []; null !== (o = function() { if (!e) return null; var t, i = e.match(/^([^<]*)(<[^>]*>?)?/); return t = i[1] ? i[1] : i[2], e = e.substr(t.length), t }());)
                if ("<" !== o[0]) a.appendChild(t.document.createTextNode(function(t) { for (; d = t.match(/&(amp|lt|gt|lrm|rlm|nbsp);/);) t = t.replace(d[0], i); return t }(o)));
                else { if ("/" === o[1]) { h.length && h[h.length - 1] === o.substr(2).replace(">", "") && (h.pop(), a = a.parentNode); continue } var l, c = yt(o.substr(1, o.length - 2)); if (c) { l = t.document.createProcessingInstruction("timestamp", c), a.appendChild(l); continue } var d = o.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/); if (!d) continue; if (!(l = function(e, i) { var o = eo[e]; if (!o) return null; var n = t.document.createElement(o);
                            n.localName = o; var s = io[e]; return s && i && (n[s] = i.trim()), n }(d[1], d[3]))) continue; if (n = a, oo[(s = l).localName] && oo[s.localName] !== n.localName) continue;
                    d[2] && (l.className = d[2].substr(1).replace(".", " ")), h.push(d[1]), a.appendChild(l), a = l } return r }

        function xt(t) { for (var e = 0; e < no.length; e++) { var i = no[e]; if (t >= i[0] && t <= i[1]) return !0 } return !1 }

        function St() {}

        function Ct(t, e, i) { St.call(this), this.cue = e, this.cueDiv = vt(t, e.text); var o = { color: "rgba(255, 255, 255, 1)", backgroundColor: "rgba(0, 0, 0, 0.8)", position: "relative", left: 0, right: 0, top: 0, bottom: 0, display: "inline", writingMode: "" === e.vertical ? "horizontal-tb" : "lr" === e.vertical ? "vertical-lr" : "vertical-rl", unicodeBidi: "plaintext" };
            this.applyStyles(o, this.cueDiv), this.div = t.document.createElement("div"), o = { direction: function(t) {
                    function e(t, e) { for (var i = e.childNodes.length - 1; 0 <= i; i--) t.push(e.childNodes[i]) }

                    function i(t) { if (!t || !t.length) return null; var o = t.pop(),
                            n = o.textContent || o.innerText; if (n) { var s = n.match(/^.*(\n|\r)/); return s ? s[t.length = 0] : n } return "ruby" === o.tagName ? i(t) : o.childNodes ? (e(t, o), i(t)) : void 0 } var o = [],
                        n = ""; if (!t || !t.childNodes) return "ltr"; for (e(o, t); n = i(o);)
                        for (var s = 0; s < n.length; s++)
                            if (xt(n.charCodeAt(s))) return "rtl"; return "ltr" }(this.cueDiv), writingMode: "" === e.vertical ? "horizontal-tb" : "lr" === e.vertical ? "vertical-lr" : "vertical-rl", unicodeBidi: "plaintext", textAlign: "middle" === e.align ? "center" : e.align, font: i.font, whiteSpace: "pre-line", position: "absolute" }, this.applyStyles(o), this.div.appendChild(this.cueDiv); var n = 0; switch (e.positionAlign) {
                case "start":
                    n = e.position; break;
                case "middle":
                    n = e.position - e.size / 2; break;
                case "end":
                    n = e.position - e.size } "" === e.vertical ? this.applyStyles({ left: this.formatStyle(n, "%"), width: this.formatStyle(e.size, "%") }) : this.applyStyles({ top: this.formatStyle(n, "%"), height: this.formatStyle(e.size, "%") }), this.move = function(t) { this.applyStyles({ top: this.formatStyle(t.top, "px"), bottom: this.formatStyle(t.bottom, "px"), left: this.formatStyle(t.left, "px"), right: this.formatStyle(t.right, "px"), height: this.formatStyle(t.height, "px"), width: this.formatStyle(t.width, "px") }) } }

        function wt(t) { var e, i, o, n; if (t.div) { i = t.div.offsetHeight, o = t.div.offsetWidth, n = t.div.offsetTop; var s = (s = t.div.childNodes) && (s = s[0]) && s.getClientRects && s.getClientRects();
                t = t.div.getBoundingClientRect(), e = s ? Math.max(s[0] && s[0].height || 0, t.height / s.length) : 0 } this.left = t.left, this.right = t.right, this.top = t.top || n, this.height = t.height || i, this.bottom = t.bottom || n + (t.height || i), this.width = t.width || o, this.lineHeight = void 0 !== e ? e : t.lineHeight }

        function At(t, e, i, o) { var n = new wt(e),
                s = e.cue,
                r = function(t) { if ("number" == typeof t.line && (t.snapToLines || 0 <= t.line && t.line <= 100)) return t.line; if (!t.track || !t.track.textTrackList || !t.track.textTrackList.mediaElement) return -1; for (var e = t.track, i = e.textTrackList, o = 0, n = 0; n < i.length && i[n] !== e; n++) "showing" === i[n].mode && o++; return -1 * ++o }(s),
                a = []; if (s.snapToLines) { var h; switch (s.vertical) {
                    case "":
                        a = ["+y", "-y"], h = "height"; break;
                    case "rl":
                        a = ["+x", "-x"], h = "width"; break;
                    case "lr":
                        a = ["-x", "+x"], h = "width" } var l = n.lineHeight,
                    c = l * Math.round(r),
                    d = i[h] + l,
                    u = a[0];
                Math.abs(c) > d && (c = c < 0 ? -1 : 1, c *= Math.ceil(d / l) * l), r < 0 && (c += "" === s.vertical ? i.height : i.width, a = a.reverse()), n.move(u, c) } else { var p = n.lineHeight / i.height * 100; switch (s.lineAlign) {
                    case "middle":
                        r -= p / 2; break;
                    case "end":
                        r -= p } switch (s.vertical) {
                    case "":
                        e.applyStyles({ top: e.formatStyle(r, "%") }); break;
                    case "rl":
                        e.applyStyles({ left: e.formatStyle(r, "%") }); break;
                    case "lr":
                        e.applyStyles({ right: e.formatStyle(r, "%") }) } a = ["+y", "-x", "+x", "-y"], n = new wt(e) } var m = function(t, e) { for (var n, s = new wt(t), r = 1, a = 0; a < e.length; a++) { for (; t.overlapsOppositeAxis(i, e[a]) || t.within(i) && t.overlapsAny(o);) t.move(e[a]); if (t.within(i)) return t; var h = t.intersectPercentage(i);
                    h < r && (n = new wt(t), r = h), t = new wt(s) } return n || s }(n, a);
            e.move(m.toCSSCompatValues(i)) }

        function Tt() {}

        function Pt(t) { return "string" == typeof t && !!ao[t.toLowerCase()] && t.toLowerCase() }

        function kt(t, e, i) { this.hasBeenReset = !1; var o = "",
                n = !1,
                s = t,
                r = e,
                a = i,
                h = null,
                l = "",
                c = !0,
                d = "auto",
                u = "start",
                p = 50,
                m = "middle",
                f = 50,
                y = "middle";
            Object.defineProperties(this, { id: { enumerable: !0, get: function() { return o }, set: function(t) { o = "" + t } }, pauseOnExit: { enumerable: !0, get: function() { return n }, set: function(t) { n = !!t } }, startTime: { enumerable: !0, get: function() { return s }, set: function(t) { if ("number" != typeof t) throw new TypeError("Start time must be set to a number.");
                        s = t, this.hasBeenReset = !0 } }, endTime: { enumerable: !0, get: function() { return r }, set: function(t) { if ("number" != typeof t) throw new TypeError("End time must be set to a number.");
                        r = t, this.hasBeenReset = !0 } }, text: { enumerable: !0, get: function() { return a }, set: function(t) { a = "" + t, this.hasBeenReset = !0 } }, region: { enumerable: !0, get: function() { return h }, set: function(t) { h = t, this.hasBeenReset = !0 } }, vertical: { enumerable: !0, get: function() { return l }, set: function(t) { var e, i = "string" == typeof(e = t) && !!ro[e.toLowerCase()] && e.toLowerCase(); if (!1 === i) throw new SyntaxError("An invalid or illegal string was specified.");
                        l = i, this.hasBeenReset = !0 } }, snapToLines: { enumerable: !0, get: function() { return c }, set: function(t) { c = !!t, this.hasBeenReset = !0 } }, line: { enumerable: !0, get: function() { return d }, set: function(t) { if ("number" != typeof t && "auto" !== t) throw new SyntaxError("An invalid number or illegal string was specified.");
                        d = t, this.hasBeenReset = !0 } }, lineAlign: { enumerable: !0, get: function() { return u }, set: function(t) { var e = Pt(t); if (!e) throw new SyntaxError("An invalid or illegal string was specified.");
                        u = e, this.hasBeenReset = !0 } }, position: { enumerable: !0, get: function() { return p }, set: function(t) { if (t < 0 || 100 < t) throw new Error("Position must be between 0 and 100.");
                        p = t, this.hasBeenReset = !0 } }, positionAlign: { enumerable: !0, get: function() { return m }, set: function(t) { var e = Pt(t); if (!e) throw new SyntaxError("An invalid or illegal string was specified.");
                        m = e, this.hasBeenReset = !0 } }, size: { enumerable: !0, get: function() { return f }, set: function(t) { if (t < 0 || 100 < t) throw new Error("Size must be between 0 and 100.");
                        f = t, this.hasBeenReset = !0 } }, align: { enumerable: !0, get: function() { return y }, set: function(t) { var e = Pt(t); if (!e) throw new SyntaxError("An invalid or illegal string was specified.");
                        y = e, this.hasBeenReset = !0 } } }), this.displayState = void 0 }

        function Mt(t) { return "number" == typeof t && 0 <= t && t <= 100 }

        function Et(t, e, i) { t.setTimeout(function() { return function t(e, i, o, n, s, r) { void 0 === e && (e = {}), void 0 === i && (i = []), void 0 === s && (s = []), void 0 === r && (r = !1); var a = i,
                        l = a[0],
                        c = a.slice(1); if ("string" == typeof l) t(e, mo[l], o, n, s, r);
                    else if (l) { var d = Dt(n, l); if (!d.setSource) return s.push(d), t(e, c, o, n, s, r);
                        d.setSource(h({}, e), function(i, a) { if (i) return t(e, c, o, n, s, r);
                            s.push(d), t(a, e.type === a.type ? c : mo[a.type], o, n, s, r) }) } else c.length ? t(e, c, o, n, s, r) : r ? o(e, s) : t(e, mo["*"], o, n, s, !0) }(e, mo[e.type], i, t) }, 1) }

        function Bt(t, e, i, o) { void 0 === o && (o = null); var n = "call" + it(i),
                s = t.reduce(It(n), o),
                r = s === yo,
                a = r ? null : e[i](s); return function(t, e, i, o) { for (var n = t.length - 1; 0 <= n; n--) { var s = t[n];
                    s[e] && s[e](o, i) } }(t, i, a, r), a }

        function It(t) { return function(e, i) { return e === yo ? yo : i[t] ? i[t](e) : e } }

        function Dt(t, e) { var i = fo[t.id()],
                o = null; if (null == i) return o = e(t), fo[t.id()] = [
                [e, o]
            ], o; for (var n = 0; n < i.length; n++) { var s = i[n],
                    r = s[0],
                    a = s[1];
                r === e && (o = a) } return null === o && (o = e(t), i.push([e, o])), o }

        function Lt(t) { var e = xo(t.src); return !t.type && e && (t.type = e), t }

        function Ot(t, e) { var i; if (4 === t.length) i = t[1] + t[1] + t[2] + t[2] + t[3] + t[3];
            else { if (7 !== t.length) throw new Error("Invalid color code provided, " + t + "; must be formatted as e.g. #f0e or #f604e2.");
                i = t.slice(1) } return "rgba(" + parseInt(i.slice(0, 2), 16) + "," + parseInt(i.slice(2, 4), 16) + "," + parseInt(i.slice(4, 6), 16) + "," + e + ")" }

        function Rt(t, e, i) { try { t.style[e] = i } catch (t) { return } }

        function Ft(t, e) { return void 0 === e && (e = t), Lo(t, e) }

        function Vt(t, e) { if (e && (t = e(t)), t && "none" !== t) return t }

        function Gt() { var t = r(["Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\n            This may prevent text tracks from loading."]); return Gt = function() { return t }, t }

        function Ut() { var t = r(["\n        Using the tech directly can be dangerous. I hope you know what you're doing.\n        See https://github.com/videojs/video.js/issues/2617 for more info.\n      "]); return Ut = function() { return t }, t }

        function Nt(e, i, o) { var n = Nt.getPlayer(e); if (n) return i && qt.warn('Player "' + e + '" is already initialised. Options will not be applied.'), o && n.ready(o), n; var s = "string" == typeof e ? $t("#" + ps(e)) : e; if (!y(s)) throw new TypeError("The element or ID supplied is not valid. (videojs)");
            t.body.contains(s) || qt.warn("The element supplied is not included in the DOM"), i = i || {}, Nt.hooks("beforesetup").forEach(function(t) { var e = t(s, ot(i));
                l(e) && !Array.isArray(e) ? i = ot(i, e) : qt.error("please return an object in beforesetup hooks") }); var r = Te.getComponent("Player"); return n = new r(s, i, o), Nt.hooks("setup").forEach(function(t) { return t(n) }), n }

        function jt(t, e) { return function(i) { var o = this; if (!e) return new ac(t); if (ac && !i) { var n = Wt(e.toString().replace(/^function.+?{/, "").slice(0, -1)); return this[oc] = new ac(n),
                        function(t, e) { if (t && e) { var i = t.terminate;
                                t.objURL = e, t.terminate = function() { t.objURL && rc.revokeObjectURL(t.objURL), i.call(t) } } }(this[oc], n), this[oc] } var s = { postMessage: function(t) { o.onmessage && setTimeout(function() { o.onmessage({ data: t, target: s }) }) } };
                e.call(s), this.postMessage = function(t) { setTimeout(function() { s.onmessage({ data: t, target: o }) }) }, this.isThisThread = !0 } }

        function Wt(t) { try { return rc.createObjectURL(new Blob([t], { type: nc })) } catch (i) { var e = new sc; return e.append(t), rc.createObjectURL(e.getBlob(type)) } }

        function Xt() {} t = t && t.hasOwnProperty("default") ? t.default : t, e = e && e.hasOwnProperty("default") ? e.default : e; var Ht = "7.4.1",
            zt = [],
            Jt = function(t, i) { return function(o, n, s) { var r = i.levels[n],
                        a = new RegExp("^(" + r + ")$"); if ("log" !== o && s.unshift(o.toUpperCase() + ":"), s.unshift(t + ":"), zt && zt.push([].concat(s)), e.console) { var h = e.console[o];
                        h || "debug" !== o || (h = e.console.info || e.console.log), h && r && a.test(o) && h[Array.isArray(s) ? "apply" : "call"](e.console, s) } } },
            qt = function t(e) { var i, o = "info",
                    n = function() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        i("log", o, e) }; return i = Jt(e, n), n.createLogger = function(i) { return t(e + ": " + i) }, n.levels = { all: "debug|log|warn|error", off: "", debug: "debug|log|warn|error", info: "log|warn|error", warn: "warn|error", error: "error", DEFAULT: o }, n.level = function(t) { if ("string" == typeof t) { if (!n.levels.hasOwnProperty(t)) throw new Error('"' + t + '" in not a valid log level');
                        o = t } return o }, (n.history = function() { return zt ? [].concat(zt) : [] }).filter = function(t) { return (zt || []).filter(function(e) { return new RegExp(".*" + t + ".*").test(e[0]) }) }, n.history.clear = function() { zt && (zt.length = 0) }, n.history.disable = function() { null !== zt && (zt.length = 0, zt = null) }, n.history.enable = function() { null === zt && (zt = []) }, n.error = function() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]; return i("error", o, e) }, n.warn = function() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]; return i("warn", o, e) }, n.debug = function() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n]; return i("debug", o, e) }, n }("VIDEOJS"),
            Yt = qt.createLogger,
            Kt = function(t) { for (var e = "", i = 0; i < arguments.length; i++) e += t[i].replace(/\n\r?\s*/g, "") + (arguments[i + 1] || ""); return e },
            Zt = Object.prototype.toString,
            Qt = function(t) { return l(t) ? Object.keys(t) : [] },
            $t = g("querySelector"),
            te = g("querySelectorAll"),
            ee = Object.freeze({ isReal: f, isEl: y, isInFrame: b, createEl: _, textContent: v, prependTo: x, hasClass: S, addClass: C, removeClass: w, toggleClass: A, setAttributes: T, getAttributes: P, getAttribute: k, setAttribute: M, removeAttribute: E, blockTextSelection: B, unblockTextSelection: I, getBoundingClientRect: D, findPosition: L, getPointerPosition: O, isTextNode: R, emptyEl: F, normalizeContent: V, appendContent: G, insertContent: U, isSingleLeftClick: N, $: $t, $$: te }),
            ie = 1,
            oe = {},
            ne = "vdata" + (new Date).getTime(),
            se = !1;! function() { try { var t = Object.defineProperty({}, "passive", { get: function() { se = !0 } });
                e.addEventListener("test", null, t), e.removeEventListener("test", null, t) } catch (t) {} }(); var re, ae = ["touchstart", "touchmove"],
            he = Object.freeze({ fixEvent: q, on: Y, off: K, trigger: Z, one: Q }),
            le = !1,
            ce = function() { if (f() && !1 !== re.options.autoSetup) { var e = Array.prototype.slice.call(t.getElementsByTagName("video")),
                        i = Array.prototype.slice.call(t.getElementsByTagName("audio")),
                        o = Array.prototype.slice.call(t.getElementsByTagName("video-js")),
                        n = e.concat(i, o); if (n && 0 < n.length)
                        for (var s = 0, r = n.length; s < r; s++) { var a = n[s]; if (!a || !a.getAttribute) { $(1); break } void 0 === a.player && null !== a.getAttribute("data-setup") && re(a) } else le || $(1) } };
        f() && "complete" === t.readyState ? le = !0 : Q(e, "load", function() { le = !0 }); var de, ue = function(e) { var i = t.createElement("style"); return i.className = e, i },
            pe = function(t, e) { t.styleSheet ? t.styleSheet.cssText = e : t.textContent = e },
            me = function(t, e, i) { e.guid || (e.guid = j()); var o = function() { return e.apply(t, arguments) }; return o.guid = i ? i + "_" + e.guid : e.guid, o },
            fe = function(t, e) { var i = Date.now(); return function() { var o = Date.now();
                    e <= o - i && (t.apply(void 0, arguments), i = o) } },
            ye = function() {};
        ye.prototype.allowedEvents_ = {}, ye.prototype.addEventListener = ye.prototype.on = function(t, e) { var i = this.addEventListener;
            this.addEventListener = function() {}, Y(this, t, e), this.addEventListener = i }, ye.prototype.removeEventListener = ye.prototype.off = function(t, e) { K(this, t, e) }, ye.prototype.one = function(t, e) { var i = this.addEventListener;
            this.addEventListener = function() {}, Q(this, t, e), this.addEventListener = i }, ye.prototype.dispatchEvent = ye.prototype.trigger = function(t) { var e = t.type || t; "string" == typeof t && (t = { type: e }), t = q(t), this.allowedEvents_[e] && this["on" + e] && this["on" + e](t), Z(this, t) }, ye.prototype.queueTrigger = function(t) { var i = this;
            de || (de = new Map); var o = t.type || t,
                n = de.get(this);
            n || (n = new Map, de.set(this, n)); var s = n.get(o);
            n.delete(o), e.clearTimeout(s); var r = e.setTimeout(function() { 0 === n.size && (n = null, de.delete(i)), i.trigger(t) }, 0);
            n.set(o, r) }; var be = function(t) { return t instanceof ye || !!t.eventBusEl_ && ["on", "one", "off", "trigger"].every(function(e) { return "function" == typeof t[e] }) },
            ge = function(t) { return "string" == typeof t && /\S/.test(t) || Array.isArray(t) && !!t.length },
            _e = function(t) { if (!t.nodeName && !be(t)) throw new Error("Invalid target; must be a DOM node or evented object.") },
            ve = function(t) { if (!ge(t)) throw new Error("Invalid event type; must be a non-empty string or array.") },
            xe = function(t) { if ("function" != typeof t) throw new Error("Invalid listener; must be a function.") },
            Se = function(t, e) { var i, o, n, s = e.length < 3 || e[0] === t || e[0] === t.eventBusEl_; return n = s ? (i = t.eventBusEl_, 3 <= e.length && e.shift(), o = e[0], e[1]) : (i = e[0], o = e[1], e[2]), _e(i), ve(o), xe(n), { isTargetingSelf: s, target: i, type: o, listener: n = me(t, n) } },
            Ce = function(t, e, i, o) { _e(t), t.nodeName ? he[e](t, i, o) : t[e](i, o) },
            we = { on: function() { for (var t = this, e = arguments.length, i = new Array(e), o = 0; o < e; o++) i[o] = arguments[o]; var n = Se(this, i),
                        s = n.isTargetingSelf,
                        r = n.target,
                        a = n.type,
                        h = n.listener; if (Ce(r, "on", a, h), !s) { var l = function() { return t.off(r, a, h) };
                        l.guid = h.guid; var c = function() { return t.off("dispose", l) };
                        c.guid = h.guid, Ce(this, "on", "dispose", l), Ce(r, "on", "dispose", c) } }, one: function() { for (var t = this, e = arguments.length, i = new Array(e), o = 0; o < e; o++) i[o] = arguments[o]; var n = Se(this, i),
                        s = n.isTargetingSelf,
                        r = n.target,
                        a = n.type,
                        h = n.listener; if (s) Ce(r, "one", a, h);
                    else { var l = function e() { t.off(r, a, e); for (var i = arguments.length, o = new Array(i), n = 0; n < i; n++) o[n] = arguments[n];
                            h.apply(null, o) };
                        l.guid = h.guid, Ce(r, "one", a, l) } }, off: function(t, e, i) { if (!t || ge(t)) K(this.eventBusEl_, t, e);
                    else { var o = t,
                            n = e;
                        _e(o), ve(n), xe(i), i = me(this, i), this.off("dispose", i), o.nodeName ? (K(o, n, i), K(o, "dispose", i)) : be(o) && (o.off(n, i), o.off("dispose", i)) } }, trigger: function(t, e) { return Z(this.eventBusEl_, t, e) } },
            Ae = { state: {}, setState: function(t) { var e, i = this; return "function" == typeof t && (t = t()), a(t, function(t, o) { i.state[o] !== t && ((e = e || {})[o] = { from: i.state[o], to: t }), i.state[o] = t }), e && be(this) && this.trigger({ changes: e, type: "statechanged" }), e } },
            Te = function() {
                function t(t, e, i) { if (!t && this.play ? this.player_ = t = this : this.player_ = t, this.options_ = ot({}, this.options_), e = this.options_ = ot(this.options_, e), this.id_ = e.id || e.el && e.el.id, !this.id_) { var o = t && t.id && t.id() || "no_player";
                        this.id_ = o + "_component_" + j() } this.name_ = e.name || null, e.el ? this.el_ = e.el : !1 !== e.createEl && (this.el_ = this.createEl()), !1 !== e.evented && tt(this, { eventBusKey: this.el_ ? "el_" : null }), et(this, this.constructor.defaultState), this.children_ = [], this.childIndex_ = {}, !(this.childNameIndex_ = {}) !== e.initChildren && this.initChildren(), this.ready(i), !1 !== e.reportTouchActivity && this.enableTouchActivity() } var i = t.prototype; return i.dispose = function() { if (this.trigger({ type: "dispose", bubbles: !1 }), this.children_)
                        for (var t = this.children_.length - 1; 0 <= t; t--) this.children_[t].dispose && this.children_[t].dispose();
                    this.children_ = null, this.childIndex_ = null, this.childNameIndex_ = null, this.el_ && (this.el_.parentNode && this.el_.parentNode.removeChild(this.el_), H(this.el_), this.el_ = null), this.player_ = null }, i.player = function() { return this.player_ }, i.options = function(t) { return qt.warn("this.options() has been deprecated and will be moved to the constructor in 6.0"), t && (this.options_ = ot(this.options_, t)), this.options_ }, i.el = function() { return this.el_ }, i.createEl = function(t, e, i) { return _(t, e, i) }, i.localize = function(t, e, i) { void 0 === i && (i = t); var o = this.player_.language && this.player_.language(),
                        n = this.player_.languages && this.player_.languages(),
                        s = n && n[o],
                        r = o && o.split("-")[0],
                        a = n && n[r],
                        h = i; return s && s[t] ? h = s[t] : a && a[t] && (h = a[t]), e && (h = h.replace(/\{(\d+)\}/g, function(t, i) { var o = e[i - 1],
                            n = o; return void 0 === o && (n = t), n })), h }, i.contentEl = function() { return this.contentEl_ || this.el_ }, i.id = function() { return this.id_ }, i.name = function() { return this.name_ }, i.children = function() { return this.children_ }, i.getChildById = function(t) { return this.childIndex_[t] }, i.getChild = function(t) { if (t) return t = it(t), this.childNameIndex_[t] }, i.addChild = function(e, i, o) { var n, s; if (void 0 === i && (i = {}), void 0 === o && (o = this.children_.length), "string" == typeof e) { s = it(e); var r = i.componentClass || s;
                        i.name = s; var a = t.getComponent(r); if (!a) throw new Error("Component " + r + " does not exist"); if ("function" != typeof a) return null;
                        n = new a(this.player_ || this, i) } else n = e; if (this.children_.splice(o, 0, n), "function" == typeof n.id && (this.childIndex_[n.id()] = n), (s = s || n.name && it(n.name())) && (this.childNameIndex_[s] = n), "function" == typeof n.el && n.el()) { var h = this.contentEl().children[o] || null;
                        this.contentEl().insertBefore(n.el(), h) } return n }, i.removeChild = function(t) { if ("string" == typeof t && (t = this.getChild(t)), t && this.children_) { for (var e = !1, i = this.children_.length - 1; 0 <= i; i--)
                            if (this.children_[i] === t) { e = !0, this.children_.splice(i, 1); break } if (e) { this.childIndex_[t.id()] = null, this.childNameIndex_[t.name()] = null; var o = t.el();
                            o && o.parentNode === this.contentEl() && this.contentEl().removeChild(t.el()) } } }, i.initChildren = function() { var e = this,
                        i = this.options_.children; if (i) { var o, n = this.options_,
                            s = t.getComponent("Tech");
                        (o = Array.isArray(i) ? i : Object.keys(i)).concat(Object.keys(this.options_).filter(function(t) { return !o.some(function(e) { return "string" == typeof e ? t === e : t === e.name }) })).map(function(t) { var o, n; return n = "string" == typeof t ? i[o = t] || e.options_[o] || {} : (o = t.name, t), { name: o, opts: n } }).filter(function(e) { var i = t.getComponent(e.opts.componentClass || it(e.name)); return i && !s.isTech(i) }).forEach(function(t) { var i = t.name,
                                o = t.opts; if (void 0 !== n[i] && (o = n[i]), !1 !== o) {!0 === o && (o = {}), o.playerOptions = e.options_.playerOptions; var s = e.addChild(i, o);
                                s && (e[i] = s) } }) } }, i.buildCSSClass = function() { return "" }, i.ready = function(t, e) { if (void 0 === e && (e = !1), t) return this.isReady_ ? void(e ? t.call(this) : this.setTimeout(t, 1)) : (this.readyQueue_ = this.readyQueue_ || [], void this.readyQueue_.push(t)) }, i.triggerReady = function() { this.isReady_ = !0, this.setTimeout(function() { var t = this.readyQueue_;
                        this.readyQueue_ = [], t && 0 < t.length && t.forEach(function(t) { t.call(this) }, this), this.trigger("ready") }, 1) }, i.$ = function(t, e) { return $t(t, e || this.contentEl()) }, i.$$ = function(t, e) { return te(t, e || this.contentEl()) }, i.hasClass = function(t) { return S(this.el_, t) }, i.addClass = function(t) { C(this.el_, t) }, i.removeClass = function(t) { w(this.el_, t) }, i.toggleClass = function(t, e) { A(this.el_, t, e) }, i.show = function() { this.removeClass("vjs-hidden") }, i.hide = function() { this.addClass("vjs-hidden") }, i.lockShowing = function() { this.addClass("vjs-lock-showing") }, i.unlockShowing = function() { this.removeClass("vjs-lock-showing") }, i.getAttribute = function(t) { return k(this.el_, t) }, i.setAttribute = function(t, e) { M(this.el_, t, e) }, i.removeAttribute = function(t) { E(this.el_, t) }, i.width = function(t, e) { return this.dimension("width", t, e) }, i.height = function(t, e) { return this.dimension("height", t, e) }, i.dimensions = function(t, e) { this.width(t, !0), this.height(e) }, i.dimension = function(t, e, i) { if (void 0 !== e) return null !== e && e == e || (e = 0), -1 !== ("" + e).indexOf("%") || -1 !== ("" + e).indexOf("px") ? this.el_.style[t] = e : this.el_.style[t] = "auto" === e ? "" : e + "px", void(i || this.trigger("componentresize")); if (!this.el_) return 0; var o = this.el_.style[t],
                        n = o.indexOf("px"); return -1 !== n ? parseInt(o.slice(0, n), 10) : parseInt(this.el_["offset" + it(t)], 10) }, i.currentDimension = function(t) { var i = 0; if ("width" !== t && "height" !== t) throw new Error("currentDimension only accepts width or height value"); if ("function" == typeof e.getComputedStyle) { var o = e.getComputedStyle(this.el_);
                        i = o.getPropertyValue(t) || o[t] } if (0 === (i = parseFloat(i))) { var n = "offset" + it(t);
                        i = this.el_[n] } return i }, i.currentDimensions = function() { return { width: this.currentDimension("width"), height: this.currentDimension("height") } }, i.currentWidth = function() { return this.currentDimension("width") }, i.currentHeight = function() { return this.currentDimension("height") }, i.focus = function() { this.el_.focus() }, i.blur = function() { this.el_.blur() }, i.emitTapEvents = function() { var t, e = 0,
                        i = null;
                    this.on("touchstart", function(o) { 1 === o.touches.length && (i = { pageX: o.touches[0].pageX, pageY: o.touches[0].pageY }, e = (new Date).getTime(), t = !0) }), this.on("touchmove", function(e) { if (1 < e.touches.length) t = !1;
                        else if (i) { var o = e.touches[0].pageX - i.pageX,
                                n = e.touches[0].pageY - i.pageY;
                            10 < Math.sqrt(o * o + n * n) && (t = !1) } }); var o = function() { t = !1 };
                    this.on("touchleave", o), this.on("touchcancel", o), this.on("touchend", function(o) {!(i = null) === t && (new Date).getTime() - e < 200 && (o.preventDefault(), this.trigger("tap")) }) }, i.enableTouchActivity = function() { if (this.player() && this.player().reportUserActivity) { var t, e = me(this.player(), this.player().reportUserActivity);
                        this.on("touchstart", function() { e(), this.clearInterval(t), t = this.setInterval(e, 250) }); var i = function(i) { e(), this.clearInterval(t) };
                        this.on("touchmove", e), this.on("touchend", i), this.on("touchcancel", i) } }, i.setTimeout = function(t, i) { var o, n, s = this; return t = me(this, t), o = e.setTimeout(function() { s.off("dispose", n), t() }, i), (n = function() { return s.clearTimeout(o) }).guid = "vjs-timeout-" + o, this.on("dispose", n), o }, i.clearTimeout = function(t) { e.clearTimeout(t); var i = function() {}; return i.guid = "vjs-timeout-" + t, this.off("dispose", i), t }, i.setInterval = function(t, i) { var o = this;
                    t = me(this, t); var n = e.setInterval(t, i),
                        s = function() { return o.clearInterval(n) }; return s.guid = "vjs-interval-" + n, this.on("dispose", s), n }, i.clearInterval = function(t) { e.clearInterval(t); var i = function() {}; return i.guid = "vjs-interval-" + t, this.off("dispose", i), t }, i.requestAnimationFrame = function(t) { var i, o, n = this; return this.supportsRaf_ ? (t = me(this, t), i = e.requestAnimationFrame(function() { n.off("dispose", o), t() }), (o = function() { return n.cancelAnimationFrame(i) }).guid = "vjs-raf-" + i, this.on("dispose", o), i) : this.setTimeout(t, 1e3 / 60) }, i.cancelAnimationFrame = function(t) { if (this.supportsRaf_) { e.cancelAnimationFrame(t); var i = function() {}; return i.guid = "vjs-raf-" + t, this.off("dispose", i), t } return this.clearTimeout(t) }, t.registerComponent = function(e, i) { if ("string" != typeof e || !e) throw new Error('Illegal component name, "' + e + '"; must be a non-empty string.'); var o, n = t.getComponent("Tech"),
                        s = n && n.isTech(i),
                        r = t === i || t.prototype.isPrototypeOf(i.prototype); if (s || !r) throw o = s ? "techs must be registered using Tech.registerTech()" : "must be a Component subclass", new Error('Illegal component, "' + e + '"; ' + o + ".");
                    e = it(e), t.components_ || (t.components_ = {}); var a = t.getComponent("Player"); if ("Player" === e && a && a.players) { var h = a.players,
                            l = Object.keys(h); if (h && 0 < l.length && l.map(function(t) { return h[t] }).every(Boolean)) throw new Error("Can not register Player component after player has been created.") } return t.components_[e] = i }, t.getComponent = function(e) { if (e) return e = it(e), t.components_ && t.components_[e] ? t.components_[e] : void 0 }, t }();
        Te.prototype.supportsRaf_ = "function" == typeof e.requestAnimationFrame && "function" == typeof e.cancelAnimationFrame, Te.registerComponent("Component", Te); for (var Pe, ke, Me, Ee, Be, Ie = e.navigator && e.navigator.userAgent || "", De = /AppleWebKit\/([\d.]+)/i.exec(Ie), Le = De ? parseFloat(De.pop()) : null, Oe = /iPad/i.test(Ie), Re = /iPhone/i.test(Ie) && !Oe, Fe = /iPod/i.test(Ie), Ve = Re || Oe || Fe, Ge = (Pe = Ie.match(/OS (\d+)_/i)) && Pe[1] ? Pe[1] : null, Ue = /Android/i.test(Ie), Ne = function() { var t = Ie.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i); if (!t) return null; var e = t[1] && parseFloat(t[1]),
                    i = t[2] && parseFloat(t[2]); return e && i ? parseFloat(t[1] + "." + t[2]) : e || null }(), je = Ue && Ne < 5 && Le < 537, We = /Firefox/i.test(Ie), Xe = /Edge/i.test(Ie), He = !Xe && (/Chrome/i.test(Ie) || /CriOS/i.test(Ie)), ze = (ke = Ie.match(/(Chrome|CriOS)\/(\d+)/)) && ke[2] ? parseFloat(ke[2]) : null, Je = (Me = /MSIE\s(\d+)\.\d/.exec(Ie), !(Ee = Me && parseFloat(Me[1])) && /Trident\/7.0/i.test(Ie) && /rv:11.0/.test(Ie) && (Ee = 11), Ee), qe = /Safari/i.test(Ie) && !He && !Ue && !Xe, Ye = (qe || Ve) && !He, Ke = (f() && ("ontouchstart" in e || e.navigator.maxTouchPoints || e.DocumentTouch && e.document instanceof e.DocumentTouch)), Ze = Object.freeze({ IS_IPAD: Oe, IS_IPHONE: Re, IS_IPOD: Fe, IS_IOS: Ve, IOS_VERSION: Ge, IS_ANDROID: Ue, ANDROID_VERSION: Ne, IS_NATIVE_ANDROID: je, IS_FIREFOX: We, IS_EDGE: Xe, IS_CHROME: He, CHROME_VERSION: ze, IE_VERSION: Je, IS_SAFARI: qe, IS_ANY_SAFARI: Ye, TOUCH_ENABLED: Ke }), Qe = {}, $e = [
                ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
                ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"],
                ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"],
                ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"],
                ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
            ], ti = $e[0], ei = 0; ei < $e.length; ei++)
            if ($e[ei][1] in t) { Be = $e[ei]; break } if (Be)
            for (var ii = 0; ii < Be.length; ii++) Qe[ti[ii]] = Be[ii];
        ht.prototype.code = 0, ht.prototype.message = "", ht.prototype.status = null, ht.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"], ht.defaultMessages = { 1: "You aborted the media playback", 2: "A network error caused the media download to fail part-way.", 3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.", 4: "The media could not be loaded, either because the server or network failed or because the format is not supported.", 5: "The media is encrypted and we do not have the keys to decrypt it." }; for (var oi = 0; oi < ht.errorTypes.length; oi++) ht[ht.errorTypes[oi]] = oi, ht.prototype[ht.errorTypes[oi]] = oi; var ni = function(t, e) { var i, o = null; try { i = JSON.parse(t, e) } catch (t) { o = t } return [o, i] },
            si = function(t) { return ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce(function(e, i, o) { return t[i] && (e[i] = t[i]), e }, { cues: t.cues && Array.prototype.map.call(t.cues, function(t) { return { startTime: t.startTime, endTime: t.endTime, text: t.text, id: t.id } }) }) },
            ri = function(t) { var e = t.$$("track"),
                    i = Array.prototype.map.call(e, function(t) { return t.track }); return Array.prototype.map.call(e, function(t) { var e = si(t.track); return t.src && (e.src = t.src), e }).concat(Array.prototype.filter.call(t.textTracks(), function(t) { return -1 === i.indexOf(t) }).map(si)) },
            ai = function(t, e) { return t.forEach(function(t) { var i = e.addRemoteTextTrack(t).track;!t.src && t.cues && t.cues.forEach(function(t) { return i.addCue(t) }) }), e.textTracks() },
            hi = "vjs-modal-dialog",
            li = function(o) {
                function n(t, e) { var i; return (i = o.call(this, t, e) || this).opened_ = i.hasBeenOpened_ = i.hasBeenFilled_ = !1, i.closeable(!i.options_.uncloseable), i.content(i.options_.content), i.contentEl_ = _("div", { className: hi + "-content" }, { role: "document" }), i.descEl_ = _("p", { className: hi + "-description vjs-control-text", id: i.el().getAttribute("aria-describedby") }), v(i.descEl_, i.description()), i.el_.appendChild(i.descEl_), i.el_.appendChild(i.contentEl_), i } i(n, o); var s = n.prototype; return s.createEl = function() { return o.prototype.createEl.call(this, "div", { className: this.buildCSSClass(), tabIndex: -1 }, { "aria-describedby": this.id() + "_description", "aria-hidden": "true", "aria-label": this.label(), role: "dialog" }) }, s.dispose = function() { this.contentEl_ = null, this.descEl_ = null, this.previouslyActiveEl_ = null, o.prototype.dispose.call(this) }, s.buildCSSClass = function() { return hi + " vjs-hidden " + o.prototype.buildCSSClass.call(this) }, s.handleKeyPress = function(t) { 27 === t.which && this.closeable() && this.close() }, s.label = function() { return this.localize(this.options_.label || "Modal Window") }, s.description = function() { var t = this.options_.description || this.localize("This is a modal window."); return this.closeable() && (t += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.")), t }, s.open = function() { if (!this.opened_) { var t = this.player();
                        this.trigger("beforemodalopen"), this.opened_ = !0, (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) && this.fill(), this.wasPlaying_ = !t.paused(), this.options_.pauseOnOpen && this.wasPlaying_ && t.pause(), this.closeable() && this.on(this.el_.ownerDocument, "keydown", me(this, this.handleKeyPress)), this.hadControls_ = t.controls(), t.controls(!1), this.show(), this.conditionalFocus_(), this.el().setAttribute("aria-hidden", "false"), this.trigger("modalopen"), this.hasBeenOpened_ = !0 } }, s.opened = function(t) { return "boolean" == typeof t && this[t ? "open" : "close"](), this.opened_ }, s.close = function() { if (this.opened_) { var t = this.player();
                        this.trigger("beforemodalclose"), this.opened_ = !1, this.wasPlaying_ && this.options_.pauseOnOpen && t.play(), this.closeable() && this.off(this.el_.ownerDocument, "keydown", me(this, this.handleKeyPress)), this.hadControls_ && t.controls(!0), this.hide(), this.el().setAttribute("aria-hidden", "true"), this.trigger("modalclose"), this.conditionalBlur_(), this.options_.temporary && this.dispose() } }, s.closeable = function(t) { if ("boolean" == typeof t) { var e = this.closeable_ = !!t,
                            i = this.getChild("closeButton"); if (e && !i) { var o = this.contentEl_;
                            this.contentEl_ = this.el_, i = this.addChild("closeButton", { controlText: "Close Modal Dialog" }), this.contentEl_ = o, this.on(i, "close", this.close) }!e && i && (this.off(i, "close", this.close), this.removeChild(i), i.dispose()) } return this.closeable_ }, s.fill = function() { this.fillWith(this.content()) }, s.fillWith = function(t) { var e = this.contentEl(),
                        i = e.parentNode,
                        o = e.nextSibling;
                    this.trigger("beforemodalfill"), this.hasBeenFilled_ = !0, i.removeChild(e), this.empty(), U(e, t), this.trigger("modalfill"), o ? i.insertBefore(e, o) : i.appendChild(e); var n = this.getChild("closeButton");
                    n && i.appendChild(n.el_) }, s.empty = function() { this.trigger("beforemodalempty"), F(this.contentEl()), this.trigger("modalempty") }, s.content = function(t) { return void 0 !== t && (this.content_ = t), this.content_ }, s.conditionalFocus_ = function() { var e = t.activeElement,
                        i = this.player_.el_;
                    this.previouslyActiveEl_ = null, (i.contains(e) || i === e) && (this.previouslyActiveEl_ = e, this.focus(), this.on(t, "keydown", this.handleKeyDown)) }, s.conditionalBlur_ = function() { this.previouslyActiveEl_ && (this.previouslyActiveEl_.focus(), this.previouslyActiveEl_ = null), this.off(t, "keydown", this.handleKeyDown) }, s.handleKeyDown = function(e) { if (9 === e.which) { for (var i, o = this.focusableEls_(), n = this.el_.querySelector(":focus"), s = 0; s < o.length; s++)
                            if (n === o[s]) { i = s; break } t.activeElement === this.el_ && (i = 0), e.shiftKey && 0 === i ? (o[o.length - 1].focus(), e.preventDefault()) : e.shiftKey || i !== o.length - 1 || (o[0].focus(), e.preventDefault()) } }, s.focusableEls_ = function() { var t = this.el_.querySelectorAll("*"); return Array.prototype.filter.call(t, function(t) { return (t instanceof e.HTMLAnchorElement || t instanceof e.HTMLAreaElement) && t.hasAttribute("href") || (t instanceof e.HTMLInputElement || t instanceof e.HTMLSelectElement || t instanceof e.HTMLTextAreaElement || t instanceof e.HTMLButtonElement) && !t.hasAttribute("disabled") || t instanceof e.HTMLIFrameElement || t instanceof e.HTMLObjectElement || t instanceof e.HTMLEmbedElement || t.hasAttribute("tabindex") && -1 !== t.getAttribute("tabindex") || t.hasAttribute("contenteditable") }) }, n }(Te);
        li.prototype.options_ = { pauseOnOpen: !0, temporary: !0 }, Te.registerComponent("ModalDialog", li); var ci = function(t) {
            function e(e) { var i;
                void 0 === e && (e = []), (i = t.call(this) || this).tracks_ = [], Object.defineProperty(s(s(i)), "length", { get: function() { return this.tracks_.length } }); for (var o = 0; o < e.length; o++) i.addTrack(e[o]); return i } i(e, t); var o = e.prototype; return o.addTrack = function(t) { var e = this.tracks_.length; "" + e in this || Object.defineProperty(this, e, { get: function() { return this.tracks_[e] } }), -1 === this.tracks_.indexOf(t) && (this.tracks_.push(t), this.trigger({ track: t, type: "addtrack" })) }, o.removeTrack = function(t) { for (var e, i = 0, o = this.length; i < o; i++)
                    if (this[i] === t) {
                        (e = this[i]).off && e.off(), this.tracks_.splice(i, 1); break } e && this.trigger({ track: e, type: "removetrack" }) }, o.getTrackById = function(t) { for (var e = null, i = 0, o = this.length; i < o; i++) { var n = this[i]; if (n.id === t) { e = n; break } } return e }, e }(ye); for (var di in ci.prototype.allowedEvents_ = { change: "change", addtrack: "addtrack", removetrack: "removetrack" }, ci.prototype.allowedEvents_) ci.prototype["on" + di] = null; var ui = function(t, e) { for (var i = 0; i < t.length; i++) Object.keys(t[i]).length && e.id !== t[i].id && (t[i].enabled = !1) },
            pi = function(t) {
                function e(e) { var i;
                    void 0 === e && (e = []); for (var o = e.length - 1; 0 <= o; o--)
                        if (e[o].enabled) { ui(e, e[o]); break } return (i = t.call(this, e) || this).changing_ = !1, i } return i(e, t), e.prototype.addTrack = function(e) { var i = this;
                    e.enabled && ui(this, e), t.prototype.addTrack.call(this, e), e.addEventListener && e.addEventListener("enabledchange", function() { i.changing_ || (i.changing_ = !0, ui(i, e), i.changing_ = !1, i.trigger("change")) }) }, e }(ci),
            mi = function(t, e) { for (var i = 0; i < t.length; i++) Object.keys(t[i]).length && e.id !== t[i].id && (t[i].selected = !1) },
            fi = function(t) {
                function e(e) { var i;
                    void 0 === e && (e = []); for (var o = e.length - 1; 0 <= o; o--)
                        if (e[o].selected) { mi(e, e[o]); break } return (i = t.call(this, e) || this).changing_ = !1, Object.defineProperty(s(s(i)), "selectedIndex", { get: function() { for (var t = 0; t < this.length; t++)
                                if (this[t].selected) return t; return -1 }, set: function() {} }), i } return i(e, t), e.prototype.addTrack = function(e) { var i = this;
                    e.selected && mi(this, e), t.prototype.addTrack.call(this, e), e.addEventListener && e.addEventListener("selectedchange", function() { i.changing_ || (i.changing_ = !0, mi(i, e), i.changing_ = !1, i.trigger("change")) }) }, e }(ci),
            yi = function(t) {
                function e() { return t.apply(this, arguments) || this } return i(e, t), e.prototype.addTrack = function(e) { t.prototype.addTrack.call(this, e), e.addEventListener("modechange", me(this, function() { this.queueTrigger("change") })), -1 === ["metadata", "chapters"].indexOf(e.kind) && e.addEventListener("modechange", me(this, function() { this.trigger("selectedlanguagechange") })) }, e }(ci),
            bi = function() {
                function t(t) { void 0 === t && (t = []), this.trackElements_ = [], Object.defineProperty(this, "length", { get: function() { return this.trackElements_.length } }); for (var e = 0, i = t.length; e < i; e++) this.addTrackElement_(t[e]) } var e = t.prototype; return e.addTrackElement_ = function(t) { var e = this.trackElements_.length; "" + e in this || Object.defineProperty(this, e, { get: function() { return this.trackElements_[e] } }), -1 === this.trackElements_.indexOf(t) && this.trackElements_.push(t) }, e.getTrackElementByTrack_ = function(t) { for (var e, i = 0, o = this.trackElements_.length; i < o; i++)
                        if (t === this.trackElements_[i].track) { e = this.trackElements_[i]; break } return e }, e.removeTrackElement_ = function(t) { for (var e = 0, i = this.trackElements_.length; e < i; e++)
                        if (t === this.trackElements_[e]) { this.trackElements_.splice(e, 1); break } }, t }(),
            gi = function() {
                function t(e) { t.prototype.setCues_.call(this, e), Object.defineProperty(this, "length", { get: function() { return this.length_ } }) } var e = t.prototype; return e.setCues_ = function(t) { var e = this.length || 0,
                        i = 0,
                        o = t.length;
                    this.cues_ = t, this.length_ = t.length; if (e < o)
                        for (i = e; i < o; i++)(function(t) { "" + t in this || Object.defineProperty(this, "" + t, { get: function() { return this.cues_[t] } }) }).call(this, i) }, e.getCueById = function(t) { for (var e = null, i = 0, o = this.length; i < o; i++) { var n = this[i]; if (n.id === t) { e = n; break } } return e }, t }(),
            _i = { alternative: "alternative", captions: "captions", main: "main", sign: "sign", subtitles: "subtitles", commentary: "commentary" },
            vi = { alternative: "alternative", descriptions: "descriptions", main: "main", "main-desc": "main-desc", translation: "translation", commentary: "commentary" },
            xi = { subtitles: "subtitles", captions: "captions", descriptions: "descriptions", chapters: "chapters", metadata: "metadata" },
            Si = { disabled: "disabled", hidden: "hidden", showing: "showing" },
            Ci = function(t) {
                function e(e) { var i;
                    void 0 === e && (e = {}), i = t.call(this) || this; var o = { id: e.id || "vjs_track_" + j(), kind: e.kind || "", label: e.label || "", language: e.language || "" }; for (var n in o) ! function(t) { Object.defineProperty(s(s(i)), t, { get: function() { return o[t] }, set: function() {} }) }(n); return i } return i(e, t), e }(ye),
            wi = function(i) { var o = ["protocol", "hostname", "port", "pathname", "search", "hash", "host"],
                    n = t.createElement("a");
                n.href = i; var s, r = "" === n.host && "file:" !== n.protocol;
                r && ((s = t.createElement("div")).innerHTML = '<a href="' + i + '"></a>', n = s.firstChild, s.setAttribute("style", "display:none; position:absolute;"), t.body.appendChild(s)); for (var a = {}, h = 0; h < o.length; h++) a[o[h]] = n[o[h]]; return "http:" === a.protocol && (a.host = a.host.replace(/:80$/, "")), "https:" === a.protocol && (a.host = a.host.replace(/:443$/, "")), a.protocol || (a.protocol = e.location.protocol), r && t.body.removeChild(s), a },
            Ai = function(e) { if (!e.match(/^https?:\/\//)) { var i = t.createElement("div");
                    i.innerHTML = '<a href="' + e + '">x</a>', e = i.firstChild.href } return e },
            Ti = function(t) { if ("string" == typeof t) { var e = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/i.exec(t); if (e) return e.pop().toLowerCase() } return "" },
            Pi = function(t) { var i = e.location,
                    o = wi(t); return (":" === o.protocol ? i.protocol : o.protocol) + o.host !== i.protocol + i.host },
            ki = Object.freeze({ parseUrl: wi, getAbsoluteURL: Ai, getFileExtension: Ti, isCrossOrigin: Pi }),
            Mi = function(t) { var e = Ei.call(t); return "[object Function]" === e || "function" == typeof t && "[object RegExp]" !== e || "undefined" != typeof window && (t === window.setTimeout || t === window.alert || t === window.confirm || t === window.prompt) },
            Ei = Object.prototype.toString; "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self; var Bi = dt(function(t, e) {
                (e = t.exports = function(t) { return t.replace(/^\s*|\s*$/g, "") }).left = function(t) { return t.replace(/^\s*/, "") }, e.right = function(t) { return t.replace(/\s*$/, "") } }),
            Ii = (Bi.left, Bi.right, Function.prototype.toString),
            Di = /^\s*class\b/,
            Li = function(t) { try { var e = Ii.call(t); return Di.test(e) } catch (t) { return !1 } },
            Oi = Object.prototype.toString,
            Ri = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag,
            Fi = function(t) { if (!t) return !1; if ("function" != typeof t && "object" != typeof t) return !1; if ("function" == typeof t && !t.prototype) return !0; if (Ri) return function(t) { try { return !Li(t) && (Ii.call(t), !0) } catch (t) { return !1 } }(t); if (Li(t)) return !1; var e = Oi.call(t); return "[object Function]" === e || "[object GeneratorFunction]" === e },
            Vi = Object.prototype.toString,
            Gi = Object.prototype.hasOwnProperty,
            Ui = function(t, e, i) { if (!Fi(e)) throw new TypeError("iterator must be a function"); var o;
                3 <= arguments.length && (o = i), "[object Array]" === Vi.call(t) ? function(t, e, i) { for (var o = 0, n = t.length; o < n; o++) Gi.call(t, o) && (null == i ? e(t[o], o, t) : e.call(i, t[o], o, t)) }(t, e, o) : "string" == typeof t ? function(t, e, i) { for (var o = 0, n = t.length; o < n; o++) null == i ? e(t.charAt(o), o, t) : e.call(i, t.charAt(o), o, t) }(t, e, o) : function(t, e, i) { for (var o in t) Gi.call(t, o) && (null == i ? e(t[o], o, t) : e.call(i, t[o], o, t)) }(t, e, o) },
            Ni = function(t) { if (!t) return {}; var e = {}; return Ui(Bi(t).split("\n"), function(t) { var i, o = t.indexOf(":"),
                        n = Bi(t.slice(0, o)).toLowerCase(),
                        s = Bi(t.slice(o + 1));
                    void 0 === e[n] ? e[n] = s : (i = e[n], "[object Array]" === Object.prototype.toString.call(i) ? e[n].push(s) : e[n] = [e[n], s]) }), e },
            ji = function() { for (var t = {}, e = 0; e < arguments.length; e++) { var i = arguments[e]; for (var o in i) Wi.call(i, o) && (t[o] = i[o]) } return t },
            Wi = Object.prototype.hasOwnProperty,
            Xi = pt;
        pt.XMLHttpRequest = e.XMLHttpRequest || function() {}, pt.XDomainRequest = "withCredentials" in new pt.XMLHttpRequest ? pt.XMLHttpRequest : e.XDomainRequest,
            function(t, e) { for (var i = 0; i < t.length; i++) e(t[i]) }(["get", "put", "post", "patch", "head", "delete"], function(t) { pt["delete" === t ? "del" : t] = function(e, i, o) { return (i = ut(e, i, o)).method = t.toUpperCase(), mt(i) } }); var Hi = function(t, i) { var o = new e.WebVTT.Parser(e, e.vttjs, e.WebVTT.StringDecoder()),
                    n = [];
                o.oncue = function(t) { i.addCue(t) }, o.onparsingerror = function(t) { n.push(t) }, o.onflush = function() { i.trigger({ type: "loadeddata", target: i }) }, o.parse(t), 0 < n.length && (e.console && e.console.groupCollapsed && e.console.groupCollapsed("Text Track parsing errors for " + i.src), n.forEach(function(t) { return qt.error(t) }), e.console && e.console.groupEnd && e.console.groupEnd()), o.flush() },
            zi = function(t) {
                function o(i) { var o; if (void 0 === i && (i = {}), !i.tech) throw new Error("A tech was not provided."); var n = ot(i, { kind: xi[i.kind] || "subtitles", language: i.language || i.srclang || "" }),
                        r = Si[n.mode] || "disabled",
                        a = n.default; "metadata" !== n.kind && "chapters" !== n.kind || (r = "hidden"), (o = t.call(this, n) || this).tech_ = n.tech, o.cues_ = [], o.activeCues_ = []; var h = new gi(o.cues_),
                        l = new gi(o.activeCues_),
                        c = !1,
                        d = me(s(s(o)), function() { this.activeCues = this.activeCues, c && (this.trigger("cuechange"), c = !1) }); return "disabled" !== r && o.tech_.ready(function() { o.tech_.on("timeupdate", d) }, !0), Object.defineProperties(s(s(o)), { default: { get: function() { return a }, set: function() {} }, mode: { get: function() { return r }, set: function(t) { var e = this;
                                Si[t] && ("disabled" !== (r = t) ? this.tech_.ready(function() { e.tech_.on("timeupdate", d) }, !0) : this.tech_.off("timeupdate", d), this.trigger("modechange")) } }, cues: { get: function() { return this.loaded_ ? h : null }, set: function() {} }, activeCues: { get: function() { if (!this.loaded_) return null; if (0 === this.cues.length) return l; for (var t = this.tech_.currentTime(), e = [], i = 0, o = this.cues.length; i < o; i++) { var n = this.cues[i];
                                    n.startTime <= t && n.endTime >= t ? e.push(n) : n.startTime === n.endTime && n.startTime <= t && n.startTime + .5 >= t && e.push(n) } if (c = !1, e.length !== this.activeCues_.length) c = !0;
                                else
                                    for (var s = 0; s < e.length; s++) - 1 === this.activeCues_.indexOf(e[s]) && (c = !0); return this.activeCues_ = e, l.setCues_(this.activeCues_), l }, set: function() {} } }), n.src ? (o.src = n.src, function(t, i) { var o = { uri: t },
                            n = Pi(t);
                        n && (o.cors = n), Xi(o, me(this, function(t, o, n) { if (t) return qt.error(t, o); if (i.loaded_ = !0, "function" != typeof e.WebVTT) { if (i.tech_) { var s = function() { return Hi(n, i) };
                                    i.tech_.on("vttjsloaded", s), i.tech_.on("vttjserror", function() { qt.error("vttjs failed to load, stopping trying to process " + i.src), i.tech_.off("vttjsloaded", s) }) } } else Hi(n, i) })) }(n.src, s(s(o)))) : o.loaded_ = !0, o } i(o, t); var n = o.prototype; return n.addCue = function(t) { var i = t; if (e.vttjs && !(t instanceof e.vttjs.VTTCue)) { for (var o in i = new e.vttjs.VTTCue(t.startTime, t.endTime, t.text), t) o in i || (i[o] = t[o]);
                        i.id = t.id, i.originalCue_ = t } for (var n = this.tech_.textTracks(), s = 0; s < n.length; s++) n[s] !== this && n[s].removeCue(i);
                    this.cues_.push(i), this.cues.setCues_(this.cues_) }, n.removeCue = function(t) { for (var e = this.cues_.length; e--;) { var i = this.cues_[e]; if (i === t || i.originalCue_ && i.originalCue_ === t) { this.cues_.splice(e, 1), this.cues.setCues_(this.cues_); break } } }, o }(Ci);
        zi.prototype.allowedEvents_ = { cuechange: "cuechange" }; var Ji = function(t) {
                function e(e) { var i;
                    void 0 === e && (e = {}); var o = ot(e, { kind: vi[e.kind] || "" });
                    i = t.call(this, o) || this; var n = !1; return Object.defineProperty(s(s(i)), "enabled", { get: function() { return n }, set: function(t) { "boolean" == typeof t && t !== n && (n = t, this.trigger("enabledchange")) } }), o.enabled && (i.enabled = o.enabled), i.loaded_ = !0, i } return i(e, t), e }(Ci),
            qi = function(t) {
                function e(e) { var i;
                    void 0 === e && (e = {}); var o = ot(e, { kind: _i[e.kind] || "" });
                    i = t.call(this, o) || this; var n = !1; return Object.defineProperty(s(s(i)), "selected", { get: function() { return n }, set: function(t) { "boolean" == typeof t && t !== n && (n = t, this.trigger("selectedchange")) } }), o.selected && (i.selected = o.selected), i } return i(e, t), e }(Ci),
            Yi = function(t) {
                function e(e) { var i, o;
                    void 0 === e && (e = {}), i = t.call(this) || this; var n = new zi(e); return i.kind = n.kind, i.src = n.src, i.srclang = n.language, i.label = n.label, i.default = n.default, Object.defineProperties(s(s(i)), { readyState: { get: function() { return o } }, track: { get: function() { return n } } }), o = 0, n.addEventListener("loadeddata", function() { o = 2, i.trigger({ type: "load", target: s(s(i)) }) }), i } return i(e, t), e }(ye);
        Yi.prototype.allowedEvents_ = { load: "load" }, Yi.NONE = 0, Yi.LOADING = 1, Yi.LOADED = 2, Yi.ERROR = 3; var Ki = { audio: { ListClass: pi, TrackClass: Ji, capitalName: "Audio" }, video: { ListClass: fi, TrackClass: qi, capitalName: "Video" }, text: { ListClass: yi, TrackClass: zi, capitalName: "Text" } };
        Object.keys(Ki).forEach(function(t) { Ki[t].getterName = t + "Tracks", Ki[t].privateName = t + "Tracks_" }); var Zi = { remoteText: { ListClass: yi, TrackClass: zi, capitalName: "RemoteText", getterName: "remoteTextTracks", privateName: "remoteTextTracks_" }, remoteTextEl: { ListClass: bi, TrackClass: Yi, capitalName: "RemoteTextTrackEls", getterName: "remoteTextTrackEls", privateName: "remoteTextTrackEls_" } },
            Qi = ot(Ki, Zi);
        Zi.names = Object.keys(Zi), Ki.names = Object.keys(Ki), Qi.names = [].concat(Zi.names).concat(Ki.names); var $i = Object.create || function() {
            function t() {} return function(e) { if (1 !== arguments.length) throw new Error("Object.create shim only accepts one parameter."); return t.prototype = e, new t } }();
        ((ft.prototype = $i(Error.prototype)).constructor = ft).Errors = { BadSignature: { code: 0, message: "Malformed WebVTT signature." }, BadTimeStamp: { code: 1, message: "Malformed time stamp." } }, bt.prototype = { set: function(t, e) { this.get(t) || "" === e || (this.values[t] = e) }, get: function(t, e, i) { return i ? this.has(t) ? this.values[t] : e[i] : this.has(t) ? this.values[t] : e }, has: function(t) { return t in this.values }, alt: function(t, e, i) { for (var o = 0; o < i.length; ++o)
                    if (e === i[o]) { this.set(t, e); break } }, integer: function(t, e) { /^-?\d+$/.test(e) && this.set(t, parseInt(e, 10)) }, percent: function(t, e) { return !!(e.match(/^([\d]{1,3})(\.[\d]*)?%$/) && 0 <= (e = parseFloat(e)) && e <= 100) && (this.set(t, e), !0) } }; var to = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&lrm;": "‎", "&rlm;": "‏", "&nbsp;": " " },
            eo = { c: "span", i: "i", b: "b", u: "u", ruby: "ruby", rt: "rt", v: "span", lang: "span" },
            io = { v: "title", lang: "lang" },
            oo = { rt: "ruby" },
            no = [
                [1470, 1470],
                [1472, 1472],
                [1475, 1475],
                [1478, 1478],
                [1488, 1514],
                [1520, 1524],
                [1544, 1544],
                [1547, 1547],
                [1549, 1549],
                [1563, 1563],
                [1566, 1610],
                [1645, 1647],
                [1649, 1749],
                [1765, 1766],
                [1774, 1775],
                [1786, 1805],
                [1807, 1808],
                [1810, 1839],
                [1869, 1957],
                [1969, 1969],
                [1984, 2026],
                [2036, 2037],
                [2042, 2042],
                [2048, 2069],
                [2074, 2074],
                [2084, 2084],
                [2088, 2088],
                [2096, 2110],
                [2112, 2136],
                [2142, 2142],
                [2208, 2208],
                [2210, 2220],
                [8207, 8207],
                [64285, 64285],
                [64287, 64296],
                [64298, 64310],
                [64312, 64316],
                [64318, 64318],
                [64320, 64321],
                [64323, 64324],
                [64326, 64449],
                [64467, 64829],
                [64848, 64911],
                [64914, 64967],
                [65008, 65020],
                [65136, 65140],
                [65142, 65276],
                [67584, 67589],
                [67592, 67592],
                [67594, 67637],
                [67639, 67640],
                [67644, 67644],
                [67647, 67669],
                [67671, 67679],
                [67840, 67867],
                [67872, 67897],
                [67903, 67903],
                [67968, 68023],
                [68030, 68031],
                [68096, 68096],
                [68112, 68115],
                [68117, 68119],
                [68121, 68147],
                [68160, 68167],
                [68176, 68184],
                [68192, 68223],
                [68352, 68405],
                [68416, 68437],
                [68440, 68466],
                [68472, 68479],
                [68608, 68680],
                [126464, 126467],
                [126469, 126495],
                [126497, 126498],
                [126500, 126500],
                [126503, 126503],
                [126505, 126514],
                [126516, 126519],
                [126521, 126521],
                [126523, 126523],
                [126530, 126530],
                [126535, 126535],
                [126537, 126537],
                [126539, 126539],
                [126541, 126543],
                [126545, 126546],
                [126548, 126548],
                [126551, 126551],
                [126553, 126553],
                [126555, 126555],
                [126557, 126557],
                [126559, 126559],
                [126561, 126562],
                [126564, 126564],
                [126567, 126570],
                [126572, 126578],
                [126580, 126583],
                [126585, 126588],
                [126590, 126590],
                [126592, 126601],
                [126603, 126619],
                [126625, 126627],
                [126629, 126633],
                [126635, 126651],
                [1114109, 1114109]
            ];
        St.prototype.applyStyles = function(t, e) { for (var i in e = e || this.div, t) t.hasOwnProperty(i) && (e.style[i] = t[i]) }, St.prototype.formatStyle = function(t, e) { return 0 === t ? 0 : t + e }, (Ct.prototype = $i(St.prototype)).constructor = Ct, wt.prototype.move = function(t, e) { switch (e = void 0 !== e ? e : this.lineHeight, t) {
                case "+x":
                    this.left += e, this.right += e; break;
                case "-x":
                    this.left -= e, this.right -= e; break;
                case "+y":
                    this.top += e, this.bottom += e; break;
                case "-y":
                    this.top -= e, this.bottom -= e } }, wt.prototype.overlaps = function(t) { return this.left < t.right && this.right > t.left && this.top < t.bottom && this.bottom > t.top }, wt.prototype.overlapsAny = function(t) { for (var e = 0; e < t.length; e++)
                if (this.overlaps(t[e])) return !0; return !1 }, wt.prototype.within = function(t) { return this.top >= t.top && this.bottom <= t.bottom && this.left >= t.left && this.right <= t.right }, wt.prototype.overlapsOppositeAxis = function(t, e) { switch (e) {
                case "+x":
                    return this.left < t.left;
                case "-x":
                    return this.right > t.right;
                case "+y":
                    return this.top < t.top;
                case "-y":
                    return this.bottom > t.bottom } }, wt.prototype.intersectPercentage = function(t) { return Math.max(0, Math.min(this.right, t.right) - Math.max(this.left, t.left)) * Math.max(0, Math.min(this.bottom, t.bottom) - Math.max(this.top, t.top)) / (this.height * this.width) }, wt.prototype.toCSSCompatValues = function(t) { return { top: this.top - t.top, bottom: t.bottom - this.bottom, left: this.left - t.left, right: t.right - this.right, height: this.height, width: this.width } }, wt.getSimpleBoxPosition = function(t) { var e = t.div ? t.div.offsetHeight : t.tagName ? t.offsetHeight : 0,
                i = t.div ? t.div.offsetWidth : t.tagName ? t.offsetWidth : 0,
                o = t.div ? t.div.offsetTop : t.tagName ? t.offsetTop : 0; return { left: (t = t.div ? t.div.getBoundingClientRect() : t.tagName ? t.getBoundingClientRect() : t).left, right: t.right, top: t.top || o, height: t.height || e, bottom: t.bottom || o + (t.height || e), width: t.width || i } }, Tt.StringDecoder = function() { return { decode: function(t) { if (!t) return ""; if ("string" != typeof t) throw new Error("Error - expected string data."); return decodeURIComponent(encodeURIComponent(t)) } } }, Tt.convertCueToDOMTree = function(t, e) { return t && e ? vt(t, e) : null }, Tt.processCues = function(t, e, i) { if (!t || !e || !i) return null; for (; i.firstChild;) i.removeChild(i.firstChild); var o = t.document.createElement("div"); if (o.style.position = "absolute", o.style.left = "0", o.style.right = "0", o.style.top = "0", o.style.bottom = "0", o.style.margin = "1.5%", i.appendChild(o), function(t) { for (var e = 0; e < t.length; e++)
                        if (t[e].hasBeenReset || !t[e].displayState) return !0; return !1 }(e)) { var n = [],
                    s = wt.getSimpleBoxPosition(o),
                    r = { font: Math.round(.05 * s.height * 100) / 100 + "px sans-serif" };! function() { for (var i, a, h = 0; h < e.length; h++) a = e[h], i = new Ct(t, a, r), o.appendChild(i.div), At(0, i, s, n), a.displayState = i.div, n.push(wt.getSimpleBoxPosition(i)) }() } else
                for (var a = 0; a < e.length; a++) o.appendChild(e[a].displayState) }, (Tt.Parser = function(t, e, i) { i || (i = e, e = {}), e || (e = {}), this.window = t, this.vttjs = e, this.state = "INITIAL", this.buffer = "", this.decoder = i || new TextDecoder("utf8"), this.regionList = [] }).prototype = { reportOrThrowError: function(t) { if (!(t instanceof ft)) throw t;
                this.onparsingerror && this.onparsingerror(t) }, parse: function(t) {
                function e() { for (var t = i.buffer, e = 0; e < t.length && "\r" !== t[e] && "\n" !== t[e];) ++e; var o = t.substr(0, e); return "\r" === t[e] && ++e, "\n" === t[e] && ++e, i.buffer = t.substr(e), o } var i = this;
                t && (i.buffer += i.decoder.decode(t, { stream: !0 })); try { var o; if ("INITIAL" === i.state) { if (!/\r\n|\n/.test(i.buffer)) return this; var n = (o = e()).match(/^WEBVTT([ \t].*)?$/); if (!n || !n[0]) throw new ft(ft.Errors.BadSignature);
                        i.state = "HEADER" } for (var s = !1; i.buffer;) { if (!/\r\n|\n/.test(i.buffer)) return this; switch (s ? s = !1 : o = e(), i.state) {
                            case "HEADER":
                                /:/.test(o) ? function(t) { t.match(/X-TIMESTAMP-MAP/) ? gt(t, function(t, e) { switch (t) {
                                            case "X-TIMESTAMP-MAP":
                                                o = e, n = new bt, gt(o, function(t, e) { switch (t) {
                                                        case "MPEGT":
                                                            n.integer(t + "S", e); break;
                                                        case "LOCA":
                                                            n.set(t + "L", yt(e)) } }, /[^\d]:/, /,/), i.ontimestampmap && i.ontimestampmap({ MPEGTS: n.get("MPEGTS"), LOCAL: n.get("LOCAL") }) } var o, n }, /=/) : gt(t, function(t, e) { switch (t) {
                                            case "Region":
                                                ! function(t) { var e = new bt; if (gt(t, function(t, i) { switch (t) {
                                                                case "id":
                                                                    e.set(t, i); break;
                                                                case "width":
                                                                    e.percent(t, i); break;
                                                                case "lines":
                                                                    e.integer(t, i); break;
                                                                case "regionanchor":
                                                                case "viewportanchor":
                                                                    var o = i.split(","); if (2 !== o.length) break; var n = new bt; if (n.percent("x", o[0]), n.percent("y", o[1]), !n.has("x") || !n.has("y")) break;
                                                                    e.set(t + "X", n.get("x")), e.set(t + "Y", n.get("y")); break;
                                                                case "scroll":
                                                                    e.alt(t, i, ["up"]) } }, /=/, /\s/), e.has("id")) { var o = new(i.vttjs.VTTRegion || i.window.VTTRegion);
                                                        o.width = e.get("width", 100), o.lines = e.get("lines", 3), o.regionAnchorX = e.get("regionanchorX", 0), o.regionAnchorY = e.get("regionanchorY", 100), o.viewportAnchorX = e.get("viewportanchorX", 0), o.viewportAnchorY = e.get("viewportanchorY", 100), o.scroll = e.get("scroll", ""), i.onregion && i.onregion(o), i.regionList.push({ id: e.get("id"), region: o }) } }(e) } }, /:/) }(o) : o || (i.state = "ID"); continue;
                            case "NOTE":
                                o || (i.state = "ID"); continue;
                            case "ID":
                                if (/^NOTE($|[ \t])/.test(o)) { i.state = "NOTE"; break } if (!o) continue; if (i.cue = new(i.vttjs.VTTCue || i.window.VTTCue)(0, 0, ""), i.state = "CUE", -1 === o.indexOf("--\x3e")) { i.cue.id = o; continue }
                            case "CUE":
                                try { _t(o, i.cue, i.regionList) } catch (t) { i.reportOrThrowError(t), i.cue = null, i.state = "BADCUE"; continue } i.state = "CUETEXT"; continue;
                            case "CUETEXT":
                                var r = -1 !== o.indexOf("--\x3e"); if (!o || r && (s = !0)) { i.oncue && i.oncue(i.cue), i.cue = null, i.state = "ID"; continue } i.cue.text && (i.cue.text += "\n"), i.cue.text += o; continue;
                            case "BADCUE":
                                o || (i.state = "ID"); continue } } } catch (t) { i.reportOrThrowError(t), "CUETEXT" === i.state && i.cue && i.oncue && i.oncue(i.cue), i.cue = null, i.state = "INITIAL" === i.state ? "BADWEBVTT" : "BADCUE" } return this }, flush: function() { var t = this; try { if (t.buffer += t.decoder.decode(), (t.cue || "HEADER" === t.state) && (t.buffer += "\n\n", t.parse()), "INITIAL" === t.state) throw new ft(ft.Errors.BadSignature) } catch (e) { t.reportOrThrowError(e) } return t.onflush && t.onflush(), this } }; var so = Tt,
            ro = { "": 1, lr: 1, rl: 1 },
            ao = { start: 1, middle: 1, end: 1, left: 1, right: 1 };
        kt.prototype.getCueAsHTML = function() { return WebVTT.convertCueToDOMTree(window, this.text) }; var ho = kt,
            lo = { "": !0, up: !0 },
            co = function() { var t = 100,
                    e = 3,
                    i = 0,
                    o = 100,
                    n = 0,
                    s = 100,
                    r = "";
                Object.defineProperties(this, { width: { enumerable: !0, get: function() { return t }, set: function(e) { if (!Mt(e)) throw new Error("Width must be between 0 and 100.");
                            t = e } }, lines: { enumerable: !0, get: function() { return e }, set: function(t) { if ("number" != typeof t) throw new TypeError("Lines must be set to a number.");
                            e = t } }, regionAnchorY: { enumerable: !0, get: function() { return o }, set: function(t) { if (!Mt(t)) throw new Error("RegionAnchorX must be between 0 and 100.");
                            o = t } }, regionAnchorX: { enumerable: !0, get: function() { return i }, set: function(t) { if (!Mt(t)) throw new Error("RegionAnchorY must be between 0 and 100.");
                            i = t } }, viewportAnchorY: { enumerable: !0, get: function() { return s }, set: function(t) { if (!Mt(t)) throw new Error("ViewportAnchorY must be between 0 and 100.");
                            s = t } }, viewportAnchorX: { enumerable: !0, get: function() { return n }, set: function(t) { if (!Mt(t)) throw new Error("ViewportAnchorX must be between 0 and 100.");
                            n = t } }, scroll: { enumerable: !0, get: function() { return r }, set: function(t) { var e, i = "string" == typeof(e = t) && !!lo[e.toLowerCase()] && e.toLowerCase(); if (!1 === i) throw new SyntaxError("An invalid or illegal string was specified.");
                            r = i } } }) },
            uo = dt(function(t) { var i = t.exports = { WebVTT: so, VTTCue: ho, VTTRegion: co };
                e.vttjs = i, e.WebVTT = i.WebVTT; var o = i.VTTCue,
                    n = i.VTTRegion,
                    s = e.VTTCue,
                    r = e.VTTRegion;
                i.shim = function() { e.VTTCue = o, e.VTTRegion = n }, i.restore = function() { e.VTTCue = s, e.VTTRegion = r }, e.VTTCue || i.shim() });
        uo.WebVTT, uo.VTTCue, uo.VTTRegion; var po = function(o) {
            function n(t, e) { var i; return void 0 === t && (t = {}), void 0 === e && (e = function() {}), t.reportTouchActivity = !1, (i = o.call(this, null, t, e) || this).hasStarted_ = !1, i.on("playing", function() { this.hasStarted_ = !0 }), i.on("loadstart", function() { this.hasStarted_ = !1 }), Qi.names.forEach(function(e) { var o = Qi[e];
                    t && t[o.getterName] && (i[o.privateName] = t[o.getterName]) }), i.featuresProgressEvents || i.manualProgressOn(), i.featuresTimeupdateEvents || i.manualTimeUpdatesOn(), ["Text", "Audio", "Video"].forEach(function(e) {!1 === t["native" + e + "Tracks"] && (i["featuresNative" + e + "Tracks"] = !1) }), !1 === t.nativeCaptions || !1 === t.nativeTextTracks ? i.featuresNativeTextTracks = !1 : !0 !== t.nativeCaptions && !0 !== t.nativeTextTracks || (i.featuresNativeTextTracks = !0), i.featuresNativeTextTracks || i.emulateTextTracks(), i.autoRemoteTextTracks_ = new Qi.text.ListClass, i.initTrackListeners(), t.nativeControlsForTouch || i.emitTapEvents(), i.constructor && (i.name_ = i.constructor.name || "Unknown Tech"), i } i(n, o); var s = n.prototype; return s.triggerSourceset = function(t) { var e = this;
                this.isReady_ || this.one("ready", function() { return e.setTimeout(function() { return e.triggerSourceset(t) }, 1) }), this.trigger({ src: t, type: "sourceset" }) }, s.manualProgressOn = function() { this.on("durationchange", this.onDurationChange), this.manualProgress = !0, this.one("ready", this.trackProgress) }, s.manualProgressOff = function() { this.manualProgress = !1, this.stopTrackingProgress(), this.off("durationchange", this.onDurationChange) }, s.trackProgress = function(t) { this.stopTrackingProgress(), this.progressInterval = this.setInterval(me(this, function() { var t = this.bufferedPercent();
                    this.bufferedPercent_ !== t && this.trigger("progress"), 1 === (this.bufferedPercent_ = t) && this.stopTrackingProgress() }), 500) }, s.onDurationChange = function(t) { this.duration_ = this.duration() }, s.buffered = function() { return rt(0, 0) }, s.bufferedPercent = function() { return at(this.buffered(), this.duration_) }, s.stopTrackingProgress = function() { this.clearInterval(this.progressInterval) }, s.manualTimeUpdatesOn = function() { this.manualTimeUpdates = !0, this.on("play", this.trackCurrentTime), this.on("pause", this.stopTrackingCurrentTime) }, s.manualTimeUpdatesOff = function() { this.manualTimeUpdates = !1, this.stopTrackingCurrentTime(), this.off("play", this.trackCurrentTime), this.off("pause", this.stopTrackingCurrentTime) }, s.trackCurrentTime = function() { this.currentTimeInterval && this.stopTrackingCurrentTime(), this.currentTimeInterval = this.setInterval(function() { this.trigger({ type: "timeupdate", target: this, manuallyTriggered: !0 }) }, 250) }, s.stopTrackingCurrentTime = function() { this.clearInterval(this.currentTimeInterval), this.trigger({ type: "timeupdate", target: this, manuallyTriggered: !0 }) }, s.dispose = function() { this.clearTracks(Ki.names), this.manualProgress && this.manualProgressOff(), this.manualTimeUpdates && this.manualTimeUpdatesOff(), o.prototype.dispose.call(this) }, s.clearTracks = function(t) { var e = this;
                (t = [].concat(t)).forEach(function(t) { for (var i = e[t + "Tracks"]() || [], o = i.length; o--;) { var n = i[o]; "text" === t && e.removeRemoteTextTrack(n), i.removeTrack(n) } }) }, s.cleanupAutoTextTracks = function() { for (var t = this.autoRemoteTextTracks_ || [], e = t.length; e--;) { var i = t[e];
                    this.removeRemoteTextTrack(i) } }, s.reset = function() {}, s.error = function(t) { return void 0 !== t && (this.error_ = new ht(t), this.trigger("error")), this.error_ }, s.played = function() { return this.hasStarted_ ? rt(0, 0) : rt() }, s.setCurrentTime = function() { this.manualTimeUpdates && this.trigger({ type: "timeupdate", target: this, manuallyTriggered: !0 }) }, s.initTrackListeners = function() { var t = this;
                Ki.names.forEach(function(e) { var i = Ki[e],
                        o = function() { t.trigger(e + "trackchange") },
                        n = t[i.getterName]();
                    n.addEventListener("removetrack", o), n.addEventListener("addtrack", o), t.on("dispose", function() { n.removeEventListener("removetrack", o), n.removeEventListener("addtrack", o) }) }) }, s.addWebVttScript_ = function() { var i = this; if (!e.WebVTT)
                    if (t.body.contains(this.el())) { if (!this.options_["vtt.js"] && c(uo) && 0 < Object.keys(uo).length) return void this.trigger("vttjsloaded"); var o = t.createElement("script");
                        o.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js", o.onload = function() { i.trigger("vttjsloaded") }, o.onerror = function() { i.trigger("vttjserror") }, this.on("dispose", function() { o.onload = null, o.onerror = null }), e.WebVTT = !0, this.el().parentNode.appendChild(o) } else this.ready(this.addWebVttScript_) }, s.emulateTextTracks = function() { var t = this,
                    e = this.textTracks(),
                    i = this.remoteTextTracks(),
                    o = function(t) { return e.addTrack(t.track) },
                    n = function(t) { return e.removeTrack(t.track) };
                i.on("addtrack", o), i.on("removetrack", n), this.addWebVttScript_(); var s = function() { return t.trigger("texttrackchange") },
                    r = function() { s(); for (var t = 0; t < e.length; t++) { var i = e[t];
                            i.removeEventListener("cuechange", s), "showing" === i.mode && i.addEventListener("cuechange", s) } };
                r(), e.addEventListener("change", r), e.addEventListener("addtrack", r), e.addEventListener("removetrack", r), this.on("dispose", function() { i.off("addtrack", o), i.off("removetrack", n), e.removeEventListener("change", r), e.removeEventListener("addtrack", r), e.removeEventListener("removetrack", r); for (var t = 0; t < e.length; t++) e[t].removeEventListener("cuechange", s) }) }, s.addTextTrack = function(t, e, i) { if (!t) throw new Error("TextTrack kind is required but was not provided"); return function(t, e, i, o, n) { void 0 === n && (n = {}); var s = t.textTracks();
                    n.kind = e, i && (n.label = i), o && (n.language = o), n.tech = t; var r = new Qi.text.TrackClass(n); return s.addTrack(r), r }(this, t, e, i) }, s.createRemoteTextTrack = function(t) { var e = ot(t, { tech: this }); return new Zi.remoteTextEl.TrackClass(e) }, s.addRemoteTextTrack = function(t, e) { var i = this;
                void 0 === t && (t = {}); var o = this.createRemoteTextTrack(t); return !0 !== e && !1 !== e && (qt.warn('Calling addRemoteTextTrack without explicitly setting the "manualCleanup" parameter to `true` is deprecated and default to `false` in future version of video.js'), e = !0), this.remoteTextTrackEls().addTrackElement_(o), this.remoteTextTracks().addTrack(o.track), !0 !== e && this.ready(function() { return i.autoRemoteTextTracks_.addTrack(o.track) }), o }, s.removeRemoteTextTrack = function(t) { var e = this.remoteTextTrackEls().getTrackElementByTrack_(t);
                this.remoteTextTrackEls().removeTrackElement_(e), this.remoteTextTracks().removeTrack(t), this.autoRemoteTextTracks_.removeTrack(t) }, s.getVideoPlaybackQuality = function() { return {} }, s.setPoster = function() {}, s.playsinline = function() {}, s.setPlaysinline = function() {}, s.overrideNativeAudioTracks = function() {}, s.overrideNativeVideoTracks = function() {}, s.canPlayType = function() { return "" }, n.canPlayType = function() { return "" }, n.canPlaySource = function(t, e) { return n.canPlayType(t.type) }, n.isTech = function(t) { return t.prototype instanceof n || t instanceof n || t === n }, n.registerTech = function(t, e) { if (n.techs_ || (n.techs_ = {}), !n.isTech(e)) throw new Error("Tech " + t + " must be a Tech"); if (!n.canPlayType) throw new Error("Techs must have a static canPlayType method on them"); if (!n.canPlaySource) throw new Error("Techs must have a static canPlaySource method on them"); return t = it(t), n.techs_[t] = e, "Tech" !== t && n.defaultTechOrder_.push(t), e }, n.getTech = function(t) { if (t) return t = it(t), n.techs_ && n.techs_[t] ? n.techs_[t] : e && e.videojs && e.videojs[t] ? (qt.warn("The " + t + " tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)"), e.videojs[t]) : void 0 }, n }(Te);
        Qi.names.forEach(function(t) { var e = Qi[t];
            po.prototype[e.getterName] = function() { return this[e.privateName] = this[e.privateName] || new e.ListClass, this[e.privateName] } }), po.prototype.featuresVolumeControl = !0, po.prototype.featuresMuteControl = !0, po.prototype.featuresFullscreenResize = !1, po.prototype.featuresPlaybackRate = !1, po.prototype.featuresProgressEvents = !1, po.prototype.featuresSourceset = !1, po.prototype.featuresTimeupdateEvents = !1, po.prototype.featuresNativeTextTracks = !1, po.withSourceHandlers = function(t) { t.registerSourceHandler = function(e, i) { var o = t.sourceHandlers;
                o || (o = t.sourceHandlers = []), void 0 === i && (i = o.length), o.splice(i, 0, e) }, t.canPlayType = function(e) { for (var i, o = t.sourceHandlers || [], n = 0; n < o.length; n++)
                    if (i = o[n].canPlayType(e)) return i; return "" }, t.selectSourceHandler = function(e, i) { for (var o = t.sourceHandlers || [], n = 0; n < o.length; n++)
                    if (o[n].canHandleSource(e, i)) return o[n]; return null }, t.canPlaySource = function(e, i) { var o = t.selectSourceHandler(e, i); return o ? o.canHandleSource(e, i) : "" }, ["seekable", "seeking", "duration"].forEach(function(t) { var e = this[t]; "function" == typeof e && (this[t] = function() { return this.sourceHandler_ && this.sourceHandler_[t] ? this.sourceHandler_[t].apply(this.sourceHandler_, arguments) : e.apply(this, arguments) }) }, t.prototype), t.prototype.setSource = function(e) { var i = t.selectSourceHandler(e, this.options_);
                i || (t.nativeSourceHandler ? i = t.nativeSourceHandler : qt.error("No source handler found for the current source.")), this.disposeSourceHandler(), this.off("dispose", this.disposeSourceHandler), i !== t.nativeSourceHandler && (this.currentSource_ = e), this.sourceHandler_ = i.handleSource(e, this, this.options_), this.on("dispose", this.disposeSourceHandler) }, t.prototype.disposeSourceHandler = function() { this.currentSource_ && (this.clearTracks(["audio", "video"]), this.currentSource_ = null), this.cleanupAutoTextTracks(), this.sourceHandler_ && (this.sourceHandler_.dispose && this.sourceHandler_.dispose(), this.sourceHandler_ = null) } }, Te.registerComponent("Tech", po), po.registerTech("Tech", po), po.defaultTechOrder_ = []; var mo = {},
            fo = {},
            yo = {},
            bo = { buffered: 1, currentTime: 1, duration: 1, seekable: 1, played: 1, paused: 1 },
            go = { setCurrentTime: 1 },
            _o = { play: 1, pause: 1 },
            vo = { opus: "video/ogg", ogv: "video/ogg", mp4: "video/mp4", mov: "video/mp4", m4v: "video/mp4", mkv: "video/x-matroska", mp3: "audio/mpeg", aac: "audio/aac", oga: "audio/ogg", m3u8: "application/x-mpegURL" },
            xo = function(t) { void 0 === t && (t = ""); var e = Ti(t); return vo[e.toLowerCase()] || "" },
            So = function(t) {
                function e(e, i, o) { var n, s = ot({ createEl: !1 }, i); if (n = t.call(this, e, s, o) || this, i.playerOptions.sources && 0 !== i.playerOptions.sources.length) e.src(i.playerOptions.sources);
                    else
                        for (var r = 0, a = i.playerOptions.techOrder; r < a.length; r++) { var h = it(a[r]),
                                l = po.getTech(h); if (h || (l = Te.getComponent(h)), l && l.isSupported()) { e.loadTech_(h); break } }
                    return n } return i(e, t), e }(Te);
        Te.registerComponent("MediaLoader", So); var Co = function(e) {
            function o(t, i) { var o; return (o = e.call(this, t, i) || this).emitTapEvents(), o.enable(), o } i(o, e); var n = o.prototype; return n.createEl = function(t, i, o) { void 0 === t && (t = "div"), void 0 === i && (i = {}), void 0 === o && (o = {}), i = h({ innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>', className: this.buildCSSClass(), tabIndex: 0 }, i), "button" === t && qt.error("Creating a ClickableComponent with an HTML element of " + t + " is not supported; use a Button instead."), o = h({ role: "button" }, o), this.tabIndex_ = i.tabIndex; var n = e.prototype.createEl.call(this, t, i, o); return this.createControlTextEl(n), n }, n.dispose = function() { this.controlTextEl_ = null, e.prototype.dispose.call(this) }, n.createControlTextEl = function(t) { return this.controlTextEl_ = _("span", { className: "vjs-control-text" }, { "aria-live": "polite" }), t && t.appendChild(this.controlTextEl_), this.controlText(this.controlText_, t), this.controlTextEl_ }, n.controlText = function(t, e) { if (void 0 === e && (e = this.el()), void 0 === t) return this.controlText_ || "Need Text"; var i = this.localize(t);
                this.controlText_ = t, v(this.controlTextEl_, i), this.nonIconControl || e.setAttribute("title", i) }, n.buildCSSClass = function() { return "vjs-control vjs-button " + e.prototype.buildCSSClass.call(this) }, n.enable = function() { this.enabled_ || (this.enabled_ = !0, this.removeClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "false"), void 0 !== this.tabIndex_ && this.el_.setAttribute("tabIndex", this.tabIndex_), this.on(["tap", "click"], this.handleClick), this.on("focus", this.handleFocus), this.on("blur", this.handleBlur)) }, n.disable = function() { this.enabled_ = !1, this.addClass("vjs-disabled"), this.el_.setAttribute("aria-disabled", "true"), void 0 !== this.tabIndex_ && this.el_.removeAttribute("tabIndex"), this.off(["tap", "click"], this.handleClick), this.off("focus", this.handleFocus), this.off("blur", this.handleBlur) }, n.handleClick = function(t) {}, n.handleFocus = function(e) { Y(t, "keydown", me(this, this.handleKeyPress)) }, n.handleKeyPress = function(t) { 32 === t.which || 13 === t.which ? (t.preventDefault(), this.trigger("click")) : e.prototype.handleKeyPress && e.prototype.handleKeyPress.call(this, t) }, n.handleBlur = function(e) { K(t, "keydown", me(this, this.handleKeyPress)) }, o }(Te);
        Te.registerComponent("ClickableComponent", Co); var wo = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).update(), e.on("posterchange", me(s(s(o)), o.update)), o } i(e, t); var o = e.prototype; return o.dispose = function() { this.player().off("posterchange", this.update), t.prototype.dispose.call(this) }, o.createEl = function() { return _("div", { className: "vjs-poster", tabIndex: -1 }) }, o.update = function(t) { var e = this.player().poster();
                this.setSrc(e), e ? this.show() : this.hide() }, o.setSrc = function(t) { var e = "";
                t && (e = 'url("' + t + '")'), this.el_.style.backgroundImage = e }, o.handleClick = function(t) { this.player_.controls() && (this.player_.paused() ? ct(this.player_.play()) : this.player_.pause()) }, e }(Co);
        Te.registerComponent("PosterImage", wo); var Ao = "#222",
            To = { monospace: "monospace", sansSerif: "sans-serif", serif: "serif", monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace', monospaceSerif: '"Courier New", monospace', proportionalSansSerif: "sans-serif", proportionalSerif: "serif", casual: '"Comic Sans MS", Impact, fantasy', script: '"Monotype Corsiva", cursive', smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif' },
            Po = function(t) {
                function o(i, o, n) { var r;
                    r = t.call(this, i, o, n) || this; var a = me(s(s(r)), r.updateDisplay); return i.on("loadstart", me(s(s(r)), r.toggleDisplay)), i.on("texttrackchange", a), i.on("loadedmetadata", me(s(s(r)), r.preselectTrack)), i.ready(me(s(s(r)), function() { if (i.tech_ && i.tech_.featuresNativeTextTracks) this.hide();
                        else { i.on("fullscreenchange", a), i.on("playerresize", a), e.addEventListener("orientationchange", a), i.on("dispose", function() { return e.removeEventListener("orientationchange", a) }); for (var t = this.options_.playerOptions.tracks || [], o = 0; o < t.length; o++) this.player_.addRemoteTextTrack(t[o], !0);
                            this.preselectTrack() } })), r } i(o, t); var n = o.prototype; return n.preselectTrack = function() { for (var t, e, i, o = { captions: 1, subtitles: 1 }, n = this.player_.textTracks(), s = this.player_.cache_.selectedLanguage, r = 0; r < n.length; r++) { var a = n[r];
                        s && s.enabled && s.language && s.language === a.language && a.kind in o ? a.kind === s.kind ? i = a : i || (i = a) : s && !s.enabled ? e = t = i = null : a.default && ("descriptions" !== a.kind || t ? a.kind in o && !e && (e = a) : t = a) } i ? i.mode = "showing" : e ? e.mode = "showing" : t && (t.mode = "showing") }, n.toggleDisplay = function() { this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks ? this.hide() : this.show() }, n.createEl = function() { return t.prototype.createEl.call(this, "div", { className: "vjs-text-track-display" }, { "aria-live": "off", "aria-atomic": "true" }) }, n.clearDisplay = function() { "function" == typeof e.WebVTT && e.WebVTT.processCues(e, [], this.el_) }, n.updateDisplay = function() { var t = this.player_.textTracks();
                    this.clearDisplay(); for (var e = null, i = null, o = t.length; o--;) { var n = t[o]; "showing" === n.mode && ("descriptions" === n.kind ? e = n : i = n) } i ? ("off" !== this.getAttribute("aria-live") && this.setAttribute("aria-live", "off"), this.updateForTrack(i)) : e && ("assertive" !== this.getAttribute("aria-live") && this.setAttribute("aria-live", "assertive"), this.updateForTrack(e)) }, n.updateForTrack = function(t) { if ("function" == typeof e.WebVTT && t.activeCues) { for (var i = [], o = 0; o < t.activeCues.length; o++) i.push(t.activeCues[o]); if (e.WebVTT.processCues(e, i, this.el_), this.player_.textTrackSettings)
                            for (var n = this.player_.textTrackSettings.getValues(), s = i.length; s--;) { var r = i[s]; if (r) { var a = r.displayState; if (n.color && (a.firstChild.style.color = n.color), n.textOpacity && Rt(a.firstChild, "color", Ot(n.color || "#fff", n.textOpacity)), n.backgroundColor && (a.firstChild.style.backgroundColor = n.backgroundColor), n.backgroundOpacity && Rt(a.firstChild, "backgroundColor", Ot(n.backgroundColor || "#000", n.backgroundOpacity)), n.windowColor && (n.windowOpacity ? Rt(a, "backgroundColor", Ot(n.windowColor, n.windowOpacity)) : a.style.backgroundColor = n.windowColor), n.edgeStyle && ("dropshadow" === n.edgeStyle ? a.firstChild.style.textShadow = "2px 2px 3px #222, 2px 2px 4px #222, 2px 2px 5px " + Ao : "raised" === n.edgeStyle ? a.firstChild.style.textShadow = "1px 1px #222, 2px 2px #222, 3px 3px " + Ao : "depressed" === n.edgeStyle ? a.firstChild.style.textShadow = "1px 1px #ccc, 0 1px #ccc, -1px -1px #222, 0 -1px " + Ao : "uniform" === n.edgeStyle && (a.firstChild.style.textShadow = "0 0 4px #222, 0 0 4px #222, 0 0 4px #222, 0 0 4px " + Ao)), n.fontPercent && 1 !== n.fontPercent) { var h = e.parseFloat(a.style.fontSize);
                                        a.style.fontSize = h * n.fontPercent + "px", a.style.height = "auto", a.style.top = "auto", a.style.bottom = "2px" } n.fontFamily && "default" !== n.fontFamily && ("small-caps" === n.fontFamily ? a.firstChild.style.fontVariant = "small-caps" : a.firstChild.style.fontFamily = To[n.fontFamily]) } } } }, o }(Te);
        Te.registerComponent("TextTrackDisplay", Po); var ko = function(t) {
            function e() { return t.apply(this, arguments) || this } return i(e, t), e.prototype.createEl = function() { var e = this.player_.isAudio(),
                    i = this.localize(e ? "Audio Player" : "Video Player"),
                    o = _("span", { className: "vjs-control-text", innerHTML: this.localize("{1} is loading.", [i]) }),
                    n = t.prototype.createEl.call(this, "div", { className: "vjs-loading-spinner", dir: "ltr" }); return n.appendChild(o), n }, e }(Te);
        Te.registerComponent("LoadingSpinner", ko); var Mo = function(t) {
            function e() { return t.apply(this, arguments) || this } i(e, t); var o = e.prototype; return o.createEl = function(t, e, i) { void 0 === e && (e = {}), void 0 === i && (i = {}), e = h({ innerHTML: '<span aria-hidden="true" class="vjs-icon-placeholder"></span>', className: this.buildCSSClass() }, e), i = h({ type: "button" }, i); var o = Te.prototype.createEl.call(this, "button", e, i); return this.createControlTextEl(o), o }, o.addChild = function(t, e) { void 0 === e && (e = {}); var i = this.constructor.name; return qt.warn("Adding an actionable (user controllable) child to a Button (" + i + ") is not supported; use a ClickableComponent instead."), Te.prototype.addChild.call(this, t, e) }, o.enable = function() { t.prototype.enable.call(this), this.el_.removeAttribute("disabled") }, o.disable = function() { t.prototype.disable.call(this), this.el_.setAttribute("disabled", "disabled") }, o.handleKeyPress = function(e) { 32 !== e.which && 13 !== e.which && t.prototype.handleKeyPress.call(this, e) }, e }(Co);
        Te.registerComponent("Button", Mo); var Eo = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).mouseused_ = !1, o.on("mousedown", o.handleMouseDown), o } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-big-play-button" }, o.handleClick = function(t) { var e = this.player_.play(); if (this.mouseused_ && t.clientX && t.clientY) ct(e);
                else { var i = this.player_.getChild("controlBar"),
                        o = i && i.getChild("playToggle"); if (o) { var n = function() { return o.focus() };
                        lt(e) ? e.then(n, function() {}) : this.setTimeout(n, 1) } else this.player_.focus() } }, o.handleKeyPress = function(e) { this.mouseused_ = !1, t.prototype.handleKeyPress.call(this, e) }, o.handleMouseDown = function(t) { this.mouseused_ = !0 }, e }(Mo);
        Eo.prototype.controlText_ = "Play Video", Te.registerComponent("BigPlayButton", Eo); var Bo = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).controlText(i && i.controlText || o.localize("Close")), o } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-close-button " + t.prototype.buildCSSClass.call(this) }, o.handleClick = function(t) { this.trigger({ type: "close", bubbles: !1 }) }, e }(Mo);
        Te.registerComponent("CloseButton", Bo); var Io = function(t) {
            function e(e, i) { var o; return void 0 === i && (i = {}), o = t.call(this, e, i) || this, i.replay = void 0 === i.replay || i.replay, o.on(e, "play", o.handlePlay), o.on(e, "pause", o.handlePause), i.replay && o.on(e, "ended", o.handleEnded), o } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-play-control " + t.prototype.buildCSSClass.call(this) }, o.handleClick = function(t) { this.player_.paused() ? this.player_.play() : this.player_.pause() }, o.handleSeeked = function(t) { this.removeClass("vjs-ended"), this.player_.paused() ? this.handlePause(t) : this.handlePlay(t) }, o.handlePlay = function(t) { this.removeClass("vjs-ended"), this.removeClass("vjs-paused"), this.addClass("vjs-playing"), this.controlText("Pause") }, o.handlePause = function(t) { this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.controlText("Play") }, o.handleEnded = function(t) { this.removeClass("vjs-playing"), this.addClass("vjs-ended"), this.controlText("Replay"), this.one(this.player_, "seeked", this.handleSeeked) }, e }(Mo);
        Io.prototype.controlText_ = "Play", Te.registerComponent("PlayToggle", Io); var Do = function(t, e) { t = t < 0 ? 0 : t; var i = Math.floor(t % 60),
                    o = Math.floor(t / 60 % 60),
                    n = Math.floor(t / 3600),
                    s = Math.floor(e / 60 % 60),
                    r = Math.floor(e / 3600); return (isNaN(t) || t === 1 / 0) && (n = o = i = "-"), (n = 0 < n || 0 < r ? n + ":" : "") + (o = ((n || 10 <= s) && o < 10 ? "0" + o : o) + ":") + (i = i < 10 ? "0" + i : i) },
            Lo = Do,
            Oo = function(e) {
                function o(t, i) { var o; return (o = e.call(this, t, i) || this).throttledUpdateContent = fe(me(s(s(o)), o.updateContent), 25), o.on(t, "timeupdate", o.throttledUpdateContent), o } i(o, e); var n = o.prototype; return n.createEl = function(t) { var i = this.buildCSSClass(),
                        o = e.prototype.createEl.call(this, "div", { className: i + " vjs-time-control vjs-control", innerHTML: '<span class="vjs-control-text" role="presentation">' + this.localize(this.labelText_) + " </span>" }); return this.contentEl_ = _("span", { className: i + "-display" }, { "aria-live": "off", role: "presentation" }), this.updateTextNode_(), o.appendChild(this.contentEl_), o }, n.dispose = function() { this.contentEl_ = null, this.textNode_ = null, e.prototype.dispose.call(this) }, n.updateTextNode_ = function() { if (this.contentEl_) { for (; this.contentEl_.firstChild;) this.contentEl_.removeChild(this.contentEl_.firstChild);
                        this.textNode_ = t.createTextNode(this.formattedTime_ || this.formatTime_(0)), this.contentEl_.appendChild(this.textNode_) } }, n.formatTime_ = function(t) { return Ft(t) }, n.updateFormattedTime_ = function(t) { var e = this.formatTime_(t);
                    e !== this.formattedTime_ && (this.formattedTime_ = e, this.requestAnimationFrame(this.updateTextNode_)) }, n.updateContent = function(t) {}, o }(Te);
        Oo.prototype.labelText_ = "Time", Oo.prototype.controlText_ = "Time", Te.registerComponent("TimeDisplay", Oo); var Ro = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).on(e, "ended", o.handleEnded), o } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-current-time" }, o.updateContent = function(t) { var e = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
                this.updateFormattedTime_(e) }, o.handleEnded = function(t) { this.player_.duration() && this.updateFormattedTime_(this.player_.duration()) }, e }(Oo);
        Ro.prototype.labelText_ = "Current Time", Ro.prototype.controlText_ = "Current Time", Te.registerComponent("CurrentTimeDisplay", Ro); var Fo = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).on(e, "durationchange", o.updateContent), o.on(e, "loadstart", o.updateContent), o.on(e, "loadedmetadata", o.throttledUpdateContent), o } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-duration" }, o.updateContent = function(t) { var e = this.player_.duration();
                this.duration_ !== e && (this.duration_ = e, this.updateFormattedTime_(e)) }, e }(Oo);
        Fo.prototype.labelText_ = "Duration", Fo.prototype.controlText_ = "Duration", Te.registerComponent("DurationDisplay", Fo); var Vo = function(t) {
            function e() { return t.apply(this, arguments) || this } return i(e, t), e.prototype.createEl = function() { return t.prototype.createEl.call(this, "div", { className: "vjs-time-control vjs-time-divider", innerHTML: "<div><span>/</span></div>" }, { "aria-hidden": !0 }) }, e }(Te);
        Te.registerComponent("TimeDivider", Vo); var Go = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).on(e, "durationchange", o.throttledUpdateContent), o.on(e, "ended", o.handleEnded), o } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-remaining-time" }, o.formatTime_ = function(e) { return "-" + t.prototype.formatTime_.call(this, e) }, o.updateContent = function(t) { this.player_.duration() && (this.player_.remainingTimeDisplay ? this.updateFormattedTime_(this.player_.remainingTimeDisplay()) : this.updateFormattedTime_(this.player_.remainingTime())) }, o.handleEnded = function(t) { this.player_.duration() && this.updateFormattedTime_(0) }, e }(Oo);
        Go.prototype.labelText_ = "Remaining Time", Go.prototype.controlText_ = "Remaining Time", Te.registerComponent("RemainingTimeDisplay", Go); var Uo = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).updateShowing(), o.on(o.player(), "durationchange", o.updateShowing), o } i(e, t); var o = e.prototype; return o.createEl = function() { var e = t.prototype.createEl.call(this, "div", { className: "vjs-live-control vjs-control" }); return this.contentEl_ = _("div", { className: "vjs-live-display", innerHTML: '<span class="vjs-control-text">' + this.localize("Stream Type") + " </span>" + this.localize("LIVE") }, { "aria-live": "off" }), e.appendChild(this.contentEl_), e }, o.dispose = function() { this.contentEl_ = null, t.prototype.dispose.call(this) }, o.updateShowing = function(t) { this.player().duration() === 1 / 0 ? this.show() : this.hide() }, e }(Te);
        Te.registerComponent("LiveDisplay", Uo); var No = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).updateLiveEdgeStatus(), o.player_.liveTracker && o.on(o.player_.liveTracker, "liveedgechange", o.updateLiveEdgeStatus), o } i(e, t); var o = e.prototype; return o.createEl = function() { var e = t.prototype.createEl.call(this, "button", { className: "vjs-seek-to-live-control vjs-control" }); return this.textEl_ = _("span", { className: "vjs-seek-to-live-text", innerHTML: this.localize("LIVE") }, { "aria-hidden": "true" }), e.appendChild(this.textEl_), e }, o.updateLiveEdgeStatus = function(t) {!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge() ? (this.setAttribute("aria-disabled", !0), this.addClass("vjs-at-live-edge"), this.controlText("Seek to live, currently playing live")) : (this.setAttribute("aria-disabled", !1), this.removeClass("vjs-at-live-edge"), this.controlText("Seek to live, currently behind live")) }, o.handleClick = function() { this.player_.liveTracker.seekToLiveEdge() }, o.dispose = function() { this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatus), this.textEl_ = null, t.prototype.dispose.call(this) }, e }(Mo);
        No.prototype.controlText_ = "Seek to live, currently playing live", Te.registerComponent("SeekToLive", No); var jo = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).bar = o.getChild(o.options_.barName), o.vertical(!!o.options_.vertical), o.enable(), o } i(e, t); var o = e.prototype; return o.enabled = function() { return this.enabled_ }, o.enable = function() { this.enabled() || (this.on("mousedown", this.handleMouseDown), this.on("touchstart", this.handleMouseDown), this.on("focus", this.handleFocus), this.on("blur", this.handleBlur), this.on("click", this.handleClick), this.on(this.player_, "controlsvisible", this.update), this.playerEvent && this.on(this.player_, this.playerEvent, this.update), this.removeClass("disabled"), this.setAttribute("tabindex", 0), this.enabled_ = !0) }, o.disable = function() { if (this.enabled()) { var t = this.bar.el_.ownerDocument;
                    this.off("mousedown", this.handleMouseDown), this.off("touchstart", this.handleMouseDown), this.off("focus", this.handleFocus), this.off("blur", this.handleBlur), this.off("click", this.handleClick), this.off(this.player_, "controlsvisible", this.update), this.off(t, "mousemove", this.handleMouseMove), this.off(t, "mouseup", this.handleMouseUp), this.off(t, "touchmove", this.handleMouseMove), this.off(t, "touchend", this.handleMouseUp), this.removeAttribute("tabindex"), this.addClass("disabled"), this.playerEvent && this.off(this.player_, this.playerEvent, this.update), this.enabled_ = !1 } }, o.createEl = function(e, i, o) { return void 0 === i && (i = {}), void 0 === o && (o = {}), i.className = i.className + " vjs-slider", i = h({ tabIndex: 0 }, i), o = h({ role: "slider", "aria-valuenow": 0, "aria-valuemin": 0, "aria-valuemax": 100, tabIndex: 0 }, o), t.prototype.createEl.call(this, e, i, o) }, o.handleMouseDown = function(t) { var e = this.bar.el_.ownerDocument; "mousedown" === t.type && t.preventDefault(), "touchstart" !== t.type || He || t.preventDefault(), B(), this.addClass("vjs-sliding"), this.trigger("slideractive"), this.on(e, "mousemove", this.handleMouseMove), this.on(e, "mouseup", this.handleMouseUp), this.on(e, "touchmove", this.handleMouseMove), this.on(e, "touchend", this.handleMouseUp), this.handleMouseMove(t) }, o.handleMouseMove = function(t) {}, o.handleMouseUp = function() { var t = this.bar.el_.ownerDocument;
                I(), this.removeClass("vjs-sliding"), this.trigger("sliderinactive"), this.off(t, "mousemove", this.handleMouseMove), this.off(t, "mouseup", this.handleMouseUp), this.off(t, "touchmove", this.handleMouseMove), this.off(t, "touchend", this.handleMouseUp), this.update() }, o.update = function() { if (this.el_) { var t = this.getPercent(),
                        e = this.bar; if (e) {
                        ("number" != typeof t || t != t || t < 0 || t === 1 / 0) && (t = 0); var i = (100 * t).toFixed(2) + "%",
                            o = e.el().style; return this.vertical() ? o.height = i : o.width = i, t } } }, o.calculateDistance = function(t) { var e = O(this.el_, t); return this.vertical() ? e.y : e.x }, o.handleFocus = function() { this.on(this.bar.el_.ownerDocument, "keydown", this.handleKeyPress) }, o.handleKeyPress = function(t) { 37 === t.which || 40 === t.which ? (t.preventDefault(), this.stepBack()) : 38 !== t.which && 39 !== t.which || (t.preventDefault(), this.stepForward()) }, o.handleBlur = function() { this.off(this.bar.el_.ownerDocument, "keydown", this.handleKeyPress) }, o.handleClick = function(t) { t.stopImmediatePropagation(), t.preventDefault() }, o.vertical = function(t) { if (void 0 === t) return this.vertical_ || !1;
                this.vertical_ = !!t, this.vertical_ ? this.addClass("vjs-slider-vertical") : this.addClass("vjs-slider-horizontal") }, e }(Te);
        Te.registerComponent("Slider", jo); var Wo = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).partEls_ = [], o.on(e, "progress", o.update), o } i(e, t); var o = e.prototype; return o.createEl = function() { return t.prototype.createEl.call(this, "div", { className: "vjs-load-progress", innerHTML: '<span class="vjs-control-text"><span>' + this.localize("Loaded") + '</span>: <span class="vjs-control-text-loaded-percentage">0%</span></span>' }) }, o.dispose = function() { this.partEls_ = null, t.prototype.dispose.call(this) }, o.update = function(t) { var e = this.player_.liveTracker,
                    i = this.player_.buffered(),
                    o = e && e.isLive() ? e.seekableEnd() : this.player_.duration(),
                    n = this.player_.bufferedEnd(),
                    s = this.partEls_,
                    r = this.$(".vjs-control-text-loaded-percentage"),
                    a = function(t, e, i) { var o = t / e || 0; return o = 100 * (1 <= o ? 1 : o), i && (o = o.toFixed(2)), o + "%" };
                this.el_.style.width = a(n, o), v(r, a(n, o, !0)); for (var h = 0; h < i.length; h++) { var l = i.start(h),
                        c = i.end(h),
                        d = s[h];
                    d || (d = this.el_.appendChild(_()), s[h] = d), d.style.left = a(l, n), d.style.width = a(c - l, n) } for (var u = s.length; u > i.length; u--) this.el_.removeChild(s[u - 1]);
                s.length = i.length }, e }(Te);
        Te.registerComponent("LoadProgressBar", Wo); var Xo = function(t) {
            function e() { return t.apply(this, arguments) || this } i(e, t); var o = e.prototype; return o.createEl = function() { return t.prototype.createEl.call(this, "div", { className: "vjs-time-tooltip" }, { "aria-hidden": "true" }) }, o.update = function(t, e, i) { var o = D(this.el_),
                    n = D(this.player_.el()),
                    s = t.width * e; if (n && o) { var r = t.left - n.left + s,
                        a = t.width - s + (n.right - t.right),
                        h = o.width / 2;
                    r < h ? h += h - r : a < h && (h = a), h < 0 ? h = 0 : h > o.width && (h = o.width), this.el_.style.right = "-" + h + "px", v(this.el_, i) } }, o.updateTime = function(t, e, i, o) { var n = this;
                this.rafId_ && this.cancelAnimationFrame(this.rafId_), this.rafId_ = this.requestAnimationFrame(function() { var s, r = n.player_.duration(); if (n.player_.liveTracker && n.player_.liveTracker.isLive()) { var a = n.player_.liveTracker.liveWindow(),
                            h = a - e * a;
                        s = (h < 1 ? "" : "-") + Ft(h, a) } else s = Ft(i, r);
                    n.update(t, e, s), o && o() }) }, e }(Te);
        Te.registerComponent("TimeTooltip", Xo); var Ho = function(t) {
            function e() { return t.apply(this, arguments) || this } i(e, t); var o = e.prototype; return o.createEl = function() { return t.prototype.createEl.call(this, "div", { className: "vjs-play-progress vjs-slider-bar" }, { "aria-hidden": "true" }) }, o.update = function(t, e) { var i = this.getChild("timeTooltip"); if (i) { var o = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
                    i.updateTime(t, e, o) } }, e }(Te);
        Ho.prototype.options_ = { children: [] }, Ve || Ue || Ho.prototype.options_.children.push("timeTooltip"), Te.registerComponent("PlayProgressBar", Ho); var zo = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).update = fe(me(s(s(o)), o.update), 25), o } i(e, t); var o = e.prototype; return o.createEl = function() { return t.prototype.createEl.call(this, "div", { className: "vjs-mouse-display" }) }, o.update = function(t, e) { var i = this,
                    o = e * this.player_.duration();
                this.getChild("timeTooltip").updateTime(t, e, o, function() { i.el_.style.left = t.width * e + "px" }) }, e }(Te);
        zo.prototype.options_ = { children: ["timeTooltip"] }, Te.registerComponent("MouseTimeDisplay", zo); var Jo = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).setEventHandlers_(), o } i(e, t); var o = e.prototype; return o.setEventHandlers_ = function() { var t = this;
                this.update = fe(me(this, this.update), 30), this.on(this.player_, "timeupdate", this.update), this.on(this.player_, "ended", this.handleEnded), this.on(this.player_, "durationchange", this.update), this.player_.liveTracker && this.on(this.player_.liveTracker, "liveedgechange", this.update), this.updateInterval = null, this.on(this.player_, ["playing"], function() { t.clearInterval(t.updateInterval), t.updateInterval = t.setInterval(function() { t.requestAnimationFrame(function() { t.update() }) }, 30) }), this.on(this.player_, ["ended", "pause", "waiting"], function(e) { t.player_.liveTracker && t.player_.liveTracker.isLive() && "ended" !== e.type || t.clearInterval(t.updateInterval) }), this.on(this.player_, ["timeupdate", "ended"], this.update) }, o.createEl = function() { return t.prototype.createEl.call(this, "div", { className: "vjs-progress-holder" }, { "aria-label": this.localize("Progress Bar") }) }, o.update_ = function(t, e) { var i = this.player_.liveTracker,
                    o = this.player_.duration();
                i && i.isLive() && (o = this.player_.liveTracker.liveCurrentTime()), i && i.seekableEnd() === 1 / 0 ? this.disable() : this.enable(), this.el_.setAttribute("aria-valuenow", (100 * e).toFixed(2)), this.el_.setAttribute("aria-valuetext", this.localize("progress bar timing: currentTime={1} duration={2}", [Ft(t, o), Ft(o, o)], "{1} of {2}")), this.bar.update(D(this.el_), e) }, o.update = function(e) { var i = t.prototype.update.call(this); return this.update_(this.getCurrentTime_(), i), i }, o.getCurrentTime_ = function() { return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime() }, o.handleEnded = function(t) { this.update_(this.player_.duration(), 1) }, o.getPercent = function() { var t, e = this.getCurrentTime_(),
                    i = this.player_.liveTracker; return i && i.isLive() ? (t = (e - i.seekableStart()) / i.liveWindow(), i.atLiveEdge() && (t = 1)) : t = e / this.player_.duration(), 1 <= t ? 1 : t || 0 }, o.handleMouseDown = function(e) { N(e) && (e.stopPropagation(), this.player_.scrubbing(!0), this.videoWasPlaying = !this.player_.paused(), this.player_.pause(), t.prototype.handleMouseDown.call(this, e)) }, o.handleMouseMove = function(t) { if (N(t)) { var e, i = this.calculateDistance(t),
                        o = this.player_.liveTracker; if (o && o.isLive()) { var n = o.seekableStart(),
                            s = o.liveCurrentTime(); if (s <= (e = n + i * o.liveWindow()) && (e = s), e <= n && (e = n + .1), e === 1 / 0) return } else(e = i * this.player_.duration()) === this.player_.duration() && (e -= .1);
                    this.player_.currentTime(e) } }, o.enable = function() { t.prototype.enable.call(this); var e = this.getChild("mouseTimeDisplay");
                e && e.show() }, o.disable = function() { t.prototype.disable.call(this); var e = this.getChild("mouseTimeDisplay");
                e && e.hide() }, o.handleMouseUp = function(e) { t.prototype.handleMouseUp.call(this, e), e && e.stopPropagation(), this.player_.scrubbing(!1), this.player_.trigger({ type: "timeupdate", target: this, manuallyTriggered: !0 }), this.videoWasPlaying && ct(this.player_.play()) }, o.stepForward = function() { this.player_.currentTime(this.player_.currentTime() + 5) }, o.stepBack = function() { this.player_.currentTime(this.player_.currentTime() - 5) }, o.handleAction = function(t) { this.player_.paused() ? this.player_.play() : this.player_.pause() }, o.handleKeyPress = function(e) { 32 === e.which || 13 === e.which ? (e.preventDefault(), this.handleAction(e)) : t.prototype.handleKeyPress && t.prototype.handleKeyPress.call(this, e) }, e }(jo);
        Jo.prototype.options_ = { children: ["loadProgressBar", "playProgressBar"], barName: "playProgressBar" }, Ve || Ue || Jo.prototype.options_.children.splice(1, 0, "mouseTimeDisplay"), Jo.prototype.playerEvent = "timeupdate", Te.registerComponent("SeekBar", Jo); var qo = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).handleMouseMove = fe(me(s(s(o)), o.handleMouseMove), 25), o.throttledHandleMouseSeek = fe(me(s(s(o)), o.handleMouseSeek), 25), o.enable(), o } i(e, t); var o = e.prototype; return o.createEl = function() { return t.prototype.createEl.call(this, "div", { className: "vjs-progress-control vjs-control" }) }, o.handleMouseMove = function(t) { var e = this.getChild("seekBar"); if (e) { var i = e.getChild("mouseTimeDisplay"),
                        o = e.el(),
                        n = D(o),
                        s = O(o, t).x;
                    1 < s ? s = 1 : s < 0 && (s = 0), i && i.update(n, s) } }, o.handleMouseSeek = function(t) { var e = this.getChild("seekBar");
                e && e.handleMouseMove(t) }, o.enabled = function() { return this.enabled_ }, o.disable = function() { this.children().forEach(function(t) { return t.disable && t.disable() }), this.enabled() && (this.off(["mousedown", "touchstart"], this.handleMouseDown), this.off(this.el_, "mousemove", this.handleMouseMove), this.handleMouseUp(), this.addClass("disabled"), this.enabled_ = !1) }, o.enable = function() { this.children().forEach(function(t) { return t.enable && t.enable() }), this.enabled() || (this.on(["mousedown", "touchstart"], this.handleMouseDown), this.on(this.el_, "mousemove", this.handleMouseMove), this.removeClass("disabled"), this.enabled_ = !0) }, o.handleMouseDown = function(t) { var e = this.el_.ownerDocument,
                    i = this.getChild("seekBar");
                i && i.handleMouseDown(t), this.on(e, "mousemove", this.throttledHandleMouseSeek), this.on(e, "touchmove", this.throttledHandleMouseSeek), this.on(e, "mouseup", this.handleMouseUp), this.on(e, "touchend", this.handleMouseUp) }, o.handleMouseUp = function(t) { var e = this.el_.ownerDocument,
                    i = this.getChild("seekBar");
                i && i.handleMouseUp(t), this.off(e, "mousemove", this.throttledHandleMouseSeek), this.off(e, "touchmove", this.throttledHandleMouseSeek), this.off(e, "mouseup", this.handleMouseUp), this.off(e, "touchend", this.handleMouseUp) }, e }(Te);
        qo.prototype.options_ = { children: ["seekBar"] }, Te.registerComponent("ProgressControl", qo); var Yo = function(e) {
            function o(i, o) { var n; return (n = e.call(this, i, o) || this).on(i, "fullscreenchange", n.handleFullscreenChange), !1 === t[Qe.fullscreenEnabled] && n.disable(), n } i(o, e); var n = o.prototype; return n.buildCSSClass = function() { return "vjs-fullscreen-control " + e.prototype.buildCSSClass.call(this) }, n.handleFullscreenChange = function(t) { this.player_.isFullscreen() ? this.controlText("Non-Fullscreen") : this.controlText("Fullscreen") }, n.handleClick = function(t) { this.player_.isFullscreen() ? this.player_.exitFullscreen() : this.player_.requestFullscreen() }, o }(Mo);
        Yo.prototype.controlText_ = "Fullscreen", Te.registerComponent("FullscreenToggle", Yo); var Ko = function(t) {
            function e() { return t.apply(this, arguments) || this } return i(e, t), e.prototype.createEl = function() { return t.prototype.createEl.call(this, "div", { className: "vjs-volume-level", innerHTML: '<span class="vjs-control-text"></span>' }) }, e }(Te);
        Te.registerComponent("VolumeLevel", Ko); var Zo = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).on("slideractive", o.updateLastVolume_), o.on(e, "volumechange", o.updateARIAAttributes), e.ready(function() { return o.updateARIAAttributes() }), o } i(e, t); var o = e.prototype; return o.createEl = function() { return t.prototype.createEl.call(this, "div", { className: "vjs-volume-bar vjs-slider-bar" }, { "aria-label": this.localize("Volume Level"), "aria-live": "polite" }) }, o.handleMouseDown = function(e) { N(e) && t.prototype.handleMouseDown.call(this, e) }, o.handleMouseMove = function(t) { N(t) && (this.checkMuted(), this.player_.volume(this.calculateDistance(t))) }, o.checkMuted = function() { this.player_.muted() && this.player_.muted(!1) }, o.getPercent = function() { return this.player_.muted() ? 0 : this.player_.volume() }, o.stepForward = function() { this.checkMuted(), this.player_.volume(this.player_.volume() + .1) }, o.stepBack = function() { this.checkMuted(), this.player_.volume(this.player_.volume() - .1) }, o.updateARIAAttributes = function(t) { var e = this.player_.muted() ? 0 : this.volumeAsPercentage_();
                this.el_.setAttribute("aria-valuenow", e), this.el_.setAttribute("aria-valuetext", e + "%") }, o.volumeAsPercentage_ = function() { return Math.round(100 * this.player_.volume()) }, o.updateLastVolume_ = function() { var t = this,
                    e = this.player_.volume();
                this.one("sliderinactive", function() { 0 === t.player_.volume() && t.player_.lastVolume_(e) }) }, e }(jo);
        Zo.prototype.options_ = { children: ["volumeLevel"], barName: "volumeLevel" }, Zo.prototype.playerEvent = "volumechange", Te.registerComponent("VolumeBar", Zo); var Qo = function(t) {
            function e(e, i) { var o, n, r; return void 0 === i && (i = {}), i.vertical = i.vertical || !1, (void 0 === i.volumeBar || c(i.volumeBar)) && (i.volumeBar = i.volumeBar || {}, i.volumeBar.vertical = i.vertical), o = t.call(this, e, i) || this, n = s(s(o)), (r = e).tech_ && !r.tech_.featuresVolumeControl && n.addClass("vjs-hidden"), n.on(r, "loadstart", function() { r.tech_.featuresVolumeControl ? n.removeClass("vjs-hidden") : n.addClass("vjs-hidden") }), o.throttledHandleMouseMove = fe(me(s(s(o)), o.handleMouseMove), 25), o.on("mousedown", o.handleMouseDown), o.on("touchstart", o.handleMouseDown), o.on(o.volumeBar, ["focus", "slideractive"], function() { o.volumeBar.addClass("vjs-slider-active"), o.addClass("vjs-slider-active"), o.trigger("slideractive") }), o.on(o.volumeBar, ["blur", "sliderinactive"], function() { o.volumeBar.removeClass("vjs-slider-active"), o.removeClass("vjs-slider-active"), o.trigger("sliderinactive") }), o } i(e, t); var o = e.prototype; return o.createEl = function() { var e = "vjs-volume-horizontal"; return this.options_.vertical && (e = "vjs-volume-vertical"), t.prototype.createEl.call(this, "div", { className: "vjs-volume-control vjs-control " + e }) }, o.handleMouseDown = function(t) { var e = this.el_.ownerDocument;
                this.on(e, "mousemove", this.throttledHandleMouseMove), this.on(e, "touchmove", this.throttledHandleMouseMove), this.on(e, "mouseup", this.handleMouseUp), this.on(e, "touchend", this.handleMouseUp) }, o.handleMouseUp = function(t) { var e = this.el_.ownerDocument;
                this.off(e, "mousemove", this.throttledHandleMouseMove), this.off(e, "touchmove", this.throttledHandleMouseMove), this.off(e, "mouseup", this.handleMouseUp), this.off(e, "touchend", this.handleMouseUp) }, o.handleMouseMove = function(t) { this.volumeBar.handleMouseMove(t) }, e }(Te);
        Qo.prototype.options_ = { children: ["volumeBar"] }, Te.registerComponent("VolumeControl", Qo); var $o = function(t) {
            function e(e, i) { var o, n, r; return o = t.call(this, e, i) || this, n = s(s(o)), (r = e).tech_ && !r.tech_.featuresMuteControl && n.addClass("vjs-hidden"), n.on(r, "loadstart", function() { r.tech_.featuresMuteControl ? n.removeClass("vjs-hidden") : n.addClass("vjs-hidden") }), o.on(e, ["loadstart", "volumechange"], o.update), o } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-mute-control " + t.prototype.buildCSSClass.call(this) }, o.handleClick = function(t) { var e = this.player_.volume(),
                    i = this.player_.lastVolume_(); if (0 === e) { var o = i < .1 ? .1 : i;
                    this.player_.volume(o), this.player_.muted(!1) } else this.player_.muted(!this.player_.muted()) }, o.update = function(t) { this.updateIcon_(), this.updateControlText_() }, o.updateIcon_ = function() { var t = this.player_.volume(),
                    e = 3;
                Ve && this.player_.muted(this.player_.tech_.el_.muted), 0 === t || this.player_.muted() ? e = 0 : t < .33 ? e = 1 : t < .67 && (e = 2); for (var i = 0; i < 4; i++) w(this.el_, "vjs-vol-" + i);
                C(this.el_, "vjs-vol-" + e) }, o.updateControlText_ = function() { var t = this.player_.muted() || 0 === this.player_.volume() ? "Unmute" : "Mute";
                this.controlText() !== t && this.controlText(t) }, e }(Mo);
        $o.prototype.controlText_ = "Mute", Te.registerComponent("MuteToggle", $o); var tn = function(t) {
            function e(e, i) { var o; return void 0 === i && (i = {}), void 0 !== i.inline ? i.inline = i.inline : i.inline = !0, (void 0 === i.volumeControl || c(i.volumeControl)) && (i.volumeControl = i.volumeControl || {}, i.volumeControl.vertical = !i.inline), (o = t.call(this, e, i) || this).on(e, ["loadstart"], o.volumePanelState_), o.on(o.volumeControl, ["slideractive"], o.sliderActive_), o.on(o.volumeControl, ["sliderinactive"], o.sliderInactive_), o } i(e, t); var o = e.prototype; return o.sliderActive_ = function() { this.addClass("vjs-slider-active") }, o.sliderInactive_ = function() { this.removeClass("vjs-slider-active") }, o.volumePanelState_ = function() { this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-hidden"), this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-mute-toggle-only") }, o.createEl = function() { var e = "vjs-volume-panel-horizontal"; return this.options_.inline || (e = "vjs-volume-panel-vertical"), t.prototype.createEl.call(this, "div", { className: "vjs-volume-panel vjs-control " + e }) }, e }(Te);
        tn.prototype.options_ = { children: ["muteToggle", "volumeControl"] }, Te.registerComponent("VolumePanel", tn); var en = function(e) {
            function o(t, i) { var o; return o = e.call(this, t, i) || this, i && (o.menuButton_ = i.menuButton), o.focusedChild_ = -1, o.on("keydown", o.handleKeyPress), o } i(o, e); var n = o.prototype; return n.addItem = function(t) { this.addChild(t), t.on("blur", me(this, this.handleBlur)), t.on(["tap", "click"], me(this, function(e) { this.menuButton_ && (this.menuButton_.unpressButton(), "CaptionSettingsMenuItem" !== t.name() && this.menuButton_.focus()) })) }, n.createEl = function() { var t = this.options_.contentElType || "ul";
                this.contentEl_ = _(t, { className: "vjs-menu-content" }), this.contentEl_.setAttribute("role", "menu"); var i = e.prototype.createEl.call(this, "div", { append: this.contentEl_, className: "vjs-menu" }); return i.appendChild(this.contentEl_), Y(i, "click", function(t) { t.preventDefault(), t.stopImmediatePropagation() }), i }, n.dispose = function() { this.contentEl_ = null, e.prototype.dispose.call(this) }, n.handleBlur = function(e) { var i = e.relatedTarget || t.activeElement; if (!this.children().some(function(t) { return t.el() === i })) { var o = this.menuButton_;
                    o && o.buttonPressed_ && i !== o.el().firstChild && o.unpressButton() } }, n.handleKeyPress = function(t) { 37 === t.which || 40 === t.which ? (t.preventDefault(), this.stepForward()) : 38 !== t.which && 39 !== t.which || (t.preventDefault(), this.stepBack()) }, n.stepForward = function() { var t = 0;
                void 0 !== this.focusedChild_ && (t = this.focusedChild_ + 1), this.focus(t) }, n.stepBack = function() { var t = 0;
                void 0 !== this.focusedChild_ && (t = this.focusedChild_ - 1), this.focus(t) }, n.focus = function(t) { void 0 === t && (t = 0); var e = this.children().slice();
                e.length && e[0].className && /vjs-menu-title/.test(e[0].className) && e.shift(), 0 < e.length && (t < 0 ? t = 0 : t >= e.length && (t = e.length - 1), e[this.focusedChild_ = t].el_.focus()) }, o }(Te);
        Te.registerComponent("Menu", en); var on = function(e) {
            function o(t, i) { var o;
                void 0 === i && (i = {}), (o = e.call(this, t, i) || this).menuButton_ = new Mo(t, i), o.menuButton_.controlText(o.controlText_), o.menuButton_.el_.setAttribute("aria-haspopup", "true"); var n = Mo.prototype.buildCSSClass(); return o.menuButton_.el_.className = o.buildCSSClass() + " " + n, o.menuButton_.removeClass("vjs-control"), o.addChild(o.menuButton_), o.update(), o.enabled_ = !0, o.on(o.menuButton_, "tap", o.handleClick), o.on(o.menuButton_, "click", o.handleClick), o.on(o.menuButton_, "focus", o.handleFocus), o.on(o.menuButton_, "blur", o.handleBlur), o.on(o.menuButton_, "mouseenter", function() { o.menu.show() }), o.on("keydown", o.handleSubmenuKeyPress), o } i(o, e); var n = o.prototype; return n.update = function() { var t = this.createMenu();
                this.menu && (this.menu.dispose(), this.removeChild(this.menu)), this.menu = t, this.addChild(t), this.buttonPressed_ = !1, this.menuButton_.el_.setAttribute("aria-expanded", "false"), this.items && this.items.length <= this.hideThreshold_ ? this.hide() : this.show() }, n.createMenu = function() { var t = new en(this.player_, { menuButton: this }); if (this.hideThreshold_ = 0, this.options_.title) { var e = _("li", { className: "vjs-menu-title", innerHTML: it(this.options_.title), tabIndex: -1 });
                    this.hideThreshold_ += 1, t.children_.unshift(e), x(e, t.contentEl()) } if (this.items = this.createItems(), this.items)
                    for (var i = 0; i < this.items.length; i++) t.addItem(this.items[i]); return t }, n.createItems = function() {}, n.createEl = function() { return e.prototype.createEl.call(this, "div", { className: this.buildWrapperCSSClass() }, {}) }, n.buildWrapperCSSClass = function() { var t = "vjs-menu-button"; return !0 === this.options_.inline ? t += "-inline" : t += "-popup", "vjs-menu-button " + t + " " + Mo.prototype.buildCSSClass() + " " + e.prototype.buildCSSClass.call(this) }, n.buildCSSClass = function() { var t = "vjs-menu-button"; return !0 === this.options_.inline ? t += "-inline" : t += "-popup", "vjs-menu-button " + t + " " + e.prototype.buildCSSClass.call(this) }, n.controlText = function(t, e) { return void 0 === e && (e = this.menuButton_.el()), this.menuButton_.controlText(t, e) }, n.handleClick = function(t) { this.buttonPressed_ ? this.unpressButton() : this.pressButton() }, n.focus = function() { this.menuButton_.focus() }, n.blur = function() { this.menuButton_.blur() }, n.handleFocus = function() { Y(t, "keydown", me(this, this.handleKeyPress)) }, n.handleBlur = function() { K(t, "keydown", me(this, this.handleKeyPress)) }, n.handleKeyPress = function(t) { 27 === t.which || 9 === t.which ? (this.buttonPressed_ && this.unpressButton(), 9 !== t.which && (t.preventDefault(), this.menuButton_.el_.focus())) : 13 !== t.which && 38 !== t.which && 40 !== t.which || this.buttonPressed_ || (this.pressButton(), t.preventDefault()) }, n.handleSubmenuKeyPress = function(t) { 27 !== t.which && 9 !== t.which || (this.buttonPressed_ && this.unpressButton(), 9 !== t.which && (t.preventDefault(), this.menuButton_.el_.focus())) }, n.pressButton = function() { if (this.enabled_) { if (this.buttonPressed_ = !0, this.menu.show(), this.menu.lockShowing(), this.menuButton_.el_.setAttribute("aria-expanded", "true"), Ve && b()) return;
                    this.menu.focus() } }, n.unpressButton = function() { this.enabled_ && (this.buttonPressed_ = !1, this.menu.unlockShowing(), this.menu.hide(), this.menuButton_.el_.setAttribute("aria-expanded", "false")) }, n.disable = function() { this.unpressButton(), this.enabled_ = !1, this.addClass("vjs-disabled"), this.menuButton_.disable() }, n.enable = function() { this.enabled_ = !0, this.removeClass("vjs-disabled"), this.menuButton_.enable() }, o }(Te);
        Te.registerComponent("MenuButton", on); var nn = function(t) {
            function e(e, i) { var o, n = i.tracks; if ((o = t.call(this, e, i) || this).items.length <= 1 && o.hide(), !n) return s(o); var r = me(s(s(o)), o.update); return n.addEventListener("removetrack", r), n.addEventListener("addtrack", r), o.player_.on("ready", r), o.player_.on("dispose", function() { n.removeEventListener("removetrack", r), n.removeEventListener("addtrack", r) }), o } return i(e, t), e }(on);
        Te.registerComponent("TrackButton", nn); var sn = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).selectable = i.selectable, o.isSelected_ = i.selected || !1, o.multiSelectable = i.multiSelectable, o.selected(o.isSelected_), o.selectable ? o.multiSelectable ? o.el_.setAttribute("role", "menuitemcheckbox") : o.el_.setAttribute("role", "menuitemradio") : o.el_.setAttribute("role", "menuitem"), o } i(e, t); var o = e.prototype; return o.createEl = function(e, i, o) { return this.nonIconControl = !0, t.prototype.createEl.call(this, "li", h({ className: "vjs-menu-item", innerHTML: '<span class="vjs-menu-item-text">' + this.localize(this.options_.label) + "</span>", tabIndex: -1 }, i), o) }, o.handleClick = function(t) { this.selected(!0) }, o.selected = function(t) { this.selectable && (this.isSelected_ = t ? (this.addClass("vjs-selected"), this.el_.setAttribute("aria-checked", "true"), this.controlText(", selected"), !0) : (this.removeClass("vjs-selected"), this.el_.setAttribute("aria-checked", "false"), this.controlText(""), !1)) }, e }(Co);
        Te.registerComponent("MenuItem", sn); var rn = function(o) {
            function n(i, n) { var r, a = n.track,
                    h = i.textTracks();
                n.label = a.label || a.language || "Unknown", n.selected = "showing" === a.mode, (r = o.call(this, i, n) || this).track = a; var l, c = function() { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                        r.handleTracksChange.apply(s(s(r)), e) },
                    d = function() { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                        r.handleSelectedLanguageChange.apply(s(s(r)), e) }; return i.on(["loadstart", "texttrackchange"], c), h.addEventListener("change", c), h.addEventListener("selectedlanguagechange", d), r.on("dispose", function() { i.off(["loadstart", "texttrackchange"], c), h.removeEventListener("change", c), h.removeEventListener("selectedlanguagechange", d) }), void 0 === h.onchange && r.on(["tap", "click"], function() { if ("object" != typeof e.Event) try { l = new e.Event("change") } catch (t) {} l || (l = t.createEvent("Event")).initEvent("change", !0, !0), h.dispatchEvent(l) }), r.handleTracksChange(), r } i(n, o); var r = n.prototype; return r.handleClick = function(t) { var e = this.track.kind,
                    i = this.track.kinds,
                    n = this.player_.textTracks(); if (i || (i = [e]), o.prototype.handleClick.call(this, t), n)
                    for (var s = 0; s < n.length; s++) { var r = n[s];
                        r === this.track && -1 < i.indexOf(r.kind) ? "showing" !== r.mode && (r.mode = "showing") : "disabled" !== r.mode && (r.mode = "disabled") } }, r.handleTracksChange = function(t) { var e = "showing" === this.track.mode;
                e !== this.isSelected_ && this.selected(e) }, r.handleSelectedLanguageChange = function(t) { if ("showing" === this.track.mode) { var e = this.player_.cache_.selectedLanguage; if (e && e.enabled && e.language === this.track.language && e.kind !== this.track.kind) return;
                    this.player_.cache_.selectedLanguage = { enabled: !0, language: this.track.language, kind: this.track.kind } } }, r.dispose = function() { this.track = null, o.prototype.dispose.call(this) }, n }(sn);
        Te.registerComponent("TextTrackMenuItem", rn); var an = function(t) {
            function e(e, i) { return i.track = { player: e, kind: i.kind, kinds: i.kinds, default: !1, mode: "disabled" }, i.kinds || (i.kinds = [i.kind]), i.label ? i.track.label = i.label : i.track.label = i.kinds.join(" and ") + " off", i.selectable = !0, i.multiSelectable = !1, t.call(this, e, i) || this } i(e, t); var o = e.prototype; return o.handleTracksChange = function(t) { for (var e = this.player().textTracks(), i = !0, o = 0, n = e.length; o < n; o++) { var s = e[o]; if (-1 < this.options_.kinds.indexOf(s.kind) && "showing" === s.mode) { i = !1; break } } i !== this.isSelected_ && this.selected(i) }, o.handleSelectedLanguageChange = function(t) { for (var e = this.player().textTracks(), i = !0, o = 0, n = e.length; o < n; o++) { var s = e[o]; if (-1 < ["captions", "descriptions", "subtitles"].indexOf(s.kind) && "showing" === s.mode) { i = !1; break } } i && (this.player_.cache_.selectedLanguage = { enabled: !1 }) }, e }(rn);
        Te.registerComponent("OffTextTrackMenuItem", an); var hn = function(t) {
            function e(e, i) { return void 0 === i && (i = {}), i.tracks = e.textTracks(), t.call(this, e, i) || this } return i(e, t), e.prototype.createItems = function(t, e) { var i;
                void 0 === t && (t = []), void 0 === e && (e = rn), this.label_ && (i = this.label_ + " off"), t.push(new an(this.player_, { kinds: this.kinds_, kind: this.kind_, label: i })), this.hideThreshold_ += 1; var o = this.player_.textTracks();
                Array.isArray(this.kinds_) || (this.kinds_ = [this.kind_]); for (var n = 0; n < o.length; n++) { var s = o[n]; if (-1 < this.kinds_.indexOf(s.kind)) { var r = new e(this.player_, { track: s, selectable: !0, multiSelectable: !1 });
                        r.addClass("vjs-" + s.kind + "-menu-item"), t.push(r) } } return t }, e }(nn);
        Te.registerComponent("TextTrackButton", hn); var ln = function(t) {
            function e(e, i) { var o, n = i.track,
                    r = i.cue,
                    a = e.currentTime(); return i.selectable = !0, i.multiSelectable = !1, i.label = r.text, i.selected = r.startTime <= a && a < r.endTime, (o = t.call(this, e, i) || this).track = n, o.cue = r, n.addEventListener("cuechange", me(s(s(o)), o.update)), o } i(e, t); var o = e.prototype; return o.handleClick = function(e) { t.prototype.handleClick.call(this), this.player_.currentTime(this.cue.startTime), this.update(this.cue.startTime) }, o.update = function(t) { var e = this.cue,
                    i = this.player_.currentTime();
                this.selected(e.startTime <= i && i < e.endTime) }, e }(sn);
        Te.registerComponent("ChaptersTrackMenuItem", ln); var cn = function(t) {
            function e(e, i, o) { return t.call(this, e, i, o) || this } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-chapters-button " + t.prototype.buildCSSClass.call(this) }, o.buildWrapperCSSClass = function() { return "vjs-chapters-button " + t.prototype.buildWrapperCSSClass.call(this) }, o.update = function(e) { this.track_ && (!e || "addtrack" !== e.type && "removetrack" !== e.type) || this.setTrack(this.findChaptersTrack()), t.prototype.update.call(this) }, o.setTrack = function(t) { if (this.track_ !== t) { if (this.updateHandler_ || (this.updateHandler_ = this.update.bind(this)), this.track_) { var e = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                        e && e.removeEventListener("load", this.updateHandler_), this.track_ = null } if (this.track_ = t, this.track_) { this.track_.mode = "hidden"; var i = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                        i && i.addEventListener("load", this.updateHandler_) } } }, o.findChaptersTrack = function() { for (var t = this.player_.textTracks() || [], e = t.length - 1; 0 <= e; e--) { var i = t[e]; if (i.kind === this.kind_) return i } }, o.getMenuCaption = function() { return this.track_ && this.track_.label ? this.track_.label : this.localize(it(this.kind_)) }, o.createMenu = function() { return this.options_.title = this.getMenuCaption(), t.prototype.createMenu.call(this) }, o.createItems = function() { var t = []; if (!this.track_) return t; var e = this.track_.cues; if (!e) return t; for (var i = 0, o = e.length; i < o; i++) { var n = e[i],
                        s = new ln(this.player_, { track: this.track_, cue: n });
                    t.push(s) } return t }, e }(hn);
        cn.prototype.kind_ = "chapters", cn.prototype.controlText_ = "Chapters", Te.registerComponent("ChaptersButton", cn); var dn = function(t) {
            function e(e, i, o) { var n;
                n = t.call(this, e, i, o) || this; var r = e.textTracks(),
                    a = me(s(s(n)), n.handleTracksChange); return r.addEventListener("change", a), n.on("dispose", function() { r.removeEventListener("change", a) }), n } i(e, t); var o = e.prototype; return o.handleTracksChange = function(t) { for (var e = this.player().textTracks(), i = !1, o = 0, n = e.length; o < n; o++) { var s = e[o]; if (s.kind !== this.kind_ && "showing" === s.mode) { i = !0; break } } i ? this.disable() : this.enable() }, o.buildCSSClass = function() { return "vjs-descriptions-button " + t.prototype.buildCSSClass.call(this) }, o.buildWrapperCSSClass = function() { return "vjs-descriptions-button " + t.prototype.buildWrapperCSSClass.call(this) }, e }(hn);
        dn.prototype.kind_ = "descriptions", dn.prototype.controlText_ = "Descriptions", Te.registerComponent("DescriptionsButton", dn); var un = function(t) {
            function e(e, i, o) { return t.call(this, e, i, o) || this } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-subtitles-button " + t.prototype.buildCSSClass.call(this) }, o.buildWrapperCSSClass = function() { return "vjs-subtitles-button " + t.prototype.buildWrapperCSSClass.call(this) }, e }(hn);
        un.prototype.kind_ = "subtitles", un.prototype.controlText_ = "Subtitles", Te.registerComponent("SubtitlesButton", un); var pn = function(t) {
            function e(e, i) { var o; return i.track = { player: e, kind: i.kind, label: i.kind + " settings", selectable: !1, default: !1, mode: "disabled" }, i.selectable = !1, i.name = "CaptionSettingsMenuItem", (o = t.call(this, e, i) || this).addClass("vjs-texttrack-settings"), o.controlText(", opens " + i.kind + " settings dialog"), o } return i(e, t), e.prototype.handleClick = function(t) { this.player().getChild("textTrackSettings").open() }, e }(rn);
        Te.registerComponent("CaptionSettingsMenuItem", pn); var mn = function(t) {
            function e(e, i, o) { return t.call(this, e, i, o) || this } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-captions-button " + t.prototype.buildCSSClass.call(this) }, o.buildWrapperCSSClass = function() { return "vjs-captions-button " + t.prototype.buildWrapperCSSClass.call(this) }, o.createItems = function() { var e = []; return this.player().tech_ && this.player().tech_.featuresNativeTextTracks || !this.player().getChild("textTrackSettings") || (e.push(new pn(this.player_, { kind: this.kind_ })), this.hideThreshold_ += 1), t.prototype.createItems.call(this, e) }, e }(hn);
        mn.prototype.kind_ = "captions", mn.prototype.controlText_ = "Captions", Te.registerComponent("CaptionsButton", mn); var fn = function(t) {
            function e() { return t.apply(this, arguments) || this } return i(e, t), e.prototype.createEl = function(e, i, o) { var n = '<span class="vjs-menu-item-text">' + this.localize(this.options_.label); return "captions" === this.options_.track.kind && (n += '\n        <span aria-hidden="true" class="vjs-icon-placeholder"></span>\n        <span class="vjs-control-text"> ' + this.localize("Captions") + "</span>\n      "), n += "</span>", t.prototype.createEl.call(this, e, h({ innerHTML: n }, i), o) }, e }(rn);
        Te.registerComponent("SubsCapsMenuItem", fn); var yn = function(t) {
            function e(e, i) { var o; return void 0 === i && (i = {}), (o = t.call(this, e, i) || this).label_ = "subtitles", -1 < ["en", "en-us", "en-ca", "fr-ca"].indexOf(o.player_.language_) && (o.label_ = "captions"), o.menuButton_.controlText(it(o.label_)), o } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-subs-caps-button " + t.prototype.buildCSSClass.call(this) }, o.buildWrapperCSSClass = function() { return "vjs-subs-caps-button " + t.prototype.buildWrapperCSSClass.call(this) }, o.createItems = function() { var e = []; return this.player().tech_ && this.player().tech_.featuresNativeTextTracks || !this.player().getChild("textTrackSettings") || (e.push(new pn(this.player_, { kind: this.label_ })), this.hideThreshold_ += 1), e = t.prototype.createItems.call(this, e, fn) }, e }(hn);
        yn.prototype.kinds_ = ["captions", "subtitles"], yn.prototype.controlText_ = "Subtitles", Te.registerComponent("SubsCapsButton", yn); var bn = function(t) {
            function e(e, i) { var o, n = i.track,
                    r = e.audioTracks();
                i.label = n.label || n.language || "Unknown", i.selected = n.enabled, (o = t.call(this, e, i) || this).track = n, o.addClass("vjs-" + n.kind + "-menu-item"); var a = function() { for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
                    o.handleTracksChange.apply(s(s(o)), e) }; return r.addEventListener("change", a), o.on("dispose", function() { r.removeEventListener("change", a) }), o } i(e, t); var o = e.prototype; return o.createEl = function(e, i, o) { var n = '<span class="vjs-menu-item-text">' + this.localize(this.options_.label); return "main-desc" === this.options_.track.kind && (n += '\n        <span aria-hidden="true" class="vjs-icon-placeholder"></span>\n        <span class="vjs-control-text"> ' + this.localize("Descriptions") + "</span>\n      "), n += "</span>", t.prototype.createEl.call(this, e, h({ innerHTML: n }, i), o) }, o.handleClick = function(e) { var i = this.player_.audioTracks();
                t.prototype.handleClick.call(this, e); for (var o = 0; o < i.length; o++) { var n = i[o];
                    n.enabled = n === this.track } }, o.handleTracksChange = function(t) { this.selected(this.track.enabled) }, e }(sn);
        Te.registerComponent("AudioTrackMenuItem", bn); var gn = function(t) {
            function e(e, i) { return void 0 === i && (i = {}), i.tracks = e.audioTracks(), t.call(this, e, i) || this } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-audio-button " + t.prototype.buildCSSClass.call(this) }, o.buildWrapperCSSClass = function() { return "vjs-audio-button " + t.prototype.buildWrapperCSSClass.call(this) }, o.createItems = function(t) { void 0 === t && (t = []), this.hideThreshold_ = 1; for (var e = this.player_.audioTracks(), i = 0; i < e.length; i++) { var o = e[i];
                    t.push(new bn(this.player_, { track: o, selectable: !0, multiSelectable: !1 })) } return t }, e }(nn);
        gn.prototype.controlText_ = "Audio Track", Te.registerComponent("AudioTrackButton", gn); var _n = function(t) {
            function e(e, i) { var o, n = i.rate,
                    s = parseFloat(n, 10); return i.label = n, i.selected = 1 === s, i.selectable = !0, i.multiSelectable = !1, (o = t.call(this, e, i) || this).label = n, o.rate = s, o.on(e, "ratechange", o.update), o } i(e, t); var o = e.prototype; return o.handleClick = function(e) { t.prototype.handleClick.call(this), this.player().playbackRate(this.rate) }, o.update = function(t) { this.selected(this.player().playbackRate() === this.rate) }, e }(sn);
        _n.prototype.contentElType = "button", Te.registerComponent("PlaybackRateMenuItem", _n); var vn = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).updateVisibility(), o.updateLabel(), o.on(e, "loadstart", o.updateVisibility), o.on(e, "ratechange", o.updateLabel), o } i(e, t); var o = e.prototype; return o.createEl = function() { var e = t.prototype.createEl.call(this); return this.labelEl_ = _("div", { className: "vjs-playback-rate-value", innerHTML: "1x" }), e.appendChild(this.labelEl_), e }, o.dispose = function() { this.labelEl_ = null, t.prototype.dispose.call(this) }, o.buildCSSClass = function() { return "vjs-playback-rate " + t.prototype.buildCSSClass.call(this) }, o.buildWrapperCSSClass = function() { return "vjs-playback-rate " + t.prototype.buildWrapperCSSClass.call(this) }, o.createMenu = function() { var t = new en(this.player()),
                    e = this.playbackRates(); if (e)
                    for (var i = e.length - 1; 0 <= i; i--) t.addChild(new _n(this.player(), { rate: e[i] + "x" })); return t }, o.updateARIAAttributes = function() { this.el().setAttribute("aria-valuenow", this.player().playbackRate()) }, o.handleClick = function(t) { for (var e = this.player().playbackRate(), i = this.playbackRates(), o = i[0], n = 0; n < i.length; n++)
                    if (i[n] > e) { o = i[n]; break } this.player().playbackRate(o) }, o.playbackRates = function() { return this.options_.playbackRates || this.options_.playerOptions && this.options_.playerOptions.playbackRates }, o.playbackRateSupported = function() { return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && 0 < this.playbackRates().length }, o.updateVisibility = function(t) { this.playbackRateSupported() ? this.removeClass("vjs-hidden") : this.addClass("vjs-hidden") }, o.updateLabel = function(t) { this.playbackRateSupported() && (this.labelEl_.innerHTML = this.player().playbackRate() + "x") }, e }(on);
        vn.prototype.controlText_ = "Playback Rate", Te.registerComponent("PlaybackRateMenuButton", vn); var xn = function(t) {
            function e() { return t.apply(this, arguments) || this } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-spacer " + t.prototype.buildCSSClass.call(this) }, o.createEl = function() { return t.prototype.createEl.call(this, "div", { className: this.buildCSSClass() }) }, e }(Te);
        Te.registerComponent("Spacer", xn); var Sn = function(t) {
            function e() { return t.apply(this, arguments) || this } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-custom-control-spacer " + t.prototype.buildCSSClass.call(this) }, o.createEl = function() { var e = t.prototype.createEl.call(this, { className: this.buildCSSClass() }); return e.innerHTML = " ", e }, e }(xn);
        Te.registerComponent("CustomControlSpacer", Sn); var Cn = function(t) {
            function e() { return t.apply(this, arguments) || this } return i(e, t), e.prototype.createEl = function() { return t.prototype.createEl.call(this, "div", { className: "vjs-control-bar", dir: "ltr" }) }, e }(Te);
        Cn.prototype.options_ = { children: ["playToggle", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "fullscreenToggle"] }, Te.registerComponent("ControlBar", Cn); var wn = function(t) {
            function e(e, i) { var o; return (o = t.call(this, e, i) || this).on(e, "error", o.open), o } i(e, t); var o = e.prototype; return o.buildCSSClass = function() { return "vjs-error-display " + t.prototype.buildCSSClass.call(this) }, o.content = function() { var t = this.player().error(); return t ? this.localize(t.message) : "" }, e }(li);
        wn.prototype.options_ = ot(li.prototype.options_, { pauseOnOpen: !1, fillAlways: !0, temporary: !1, uncloseable: !0 }), Te.registerComponent("ErrorDisplay", wn); var An = "vjs-text-track-settings",
            Tn = ["#000", "Black"],
            Pn = ["#00F", "Blue"],
            kn = ["#0FF", "Cyan"],
            Mn = ["#0F0", "Green"],
            En = ["#F0F", "Magenta"],
            Bn = ["#F00", "Red"],
            In = ["#FFF", "White"],
            Dn = ["#FF0", "Yellow"],
            Ln = ["1", "Opaque"],
            On = ["0.5", "Semi-Transparent"],
            Rn = ["0", "Transparent"],
            Fn = { backgroundColor: { selector: ".vjs-bg-color > select", id: "captions-background-color-%s", label: "Color", options: [Tn, In, Bn, Mn, Pn, Dn, En, kn] }, backgroundOpacity: { selector: ".vjs-bg-opacity > select", id: "captions-background-opacity-%s", label: "Transparency", options: [Ln, On, Rn] }, color: { selector: ".vjs-fg-color > select", id: "captions-foreground-color-%s", label: "Color", options: [In, Tn, Bn, Mn, Pn, Dn, En, kn] }, edgeStyle: { selector: ".vjs-edge-style > select", id: "%s", label: "Text Edge Style", options: [
                        ["none", "None"],
                        ["raised", "Raised"],
                        ["depressed", "Depressed"],
                        ["uniform", "Uniform"],
                        ["dropshadow", "Dropshadow"]
                    ] }, fontFamily: { selector: ".vjs-font-family > select", id: "captions-font-family-%s", label: "Font Family", options: [
                        ["proportionalSansSerif", "Proportional Sans-Serif"],
                        ["monospaceSansSerif", "Monospace Sans-Serif"],
                        ["proportionalSerif", "Proportional Serif"],
                        ["monospaceSerif", "Monospace Serif"],
                        ["casual", "Casual"],
                        ["script", "Script"],
                        ["small-caps", "Small Caps"]
                    ] }, fontPercent: { selector: ".vjs-font-percent > select", id: "captions-font-size-%s", label: "Font Size", options: [
                        ["0.50", "50%"],
                        ["0.75", "75%"],
                        ["1.00", "100%"],
                        ["1.25", "125%"],
                        ["1.50", "150%"],
                        ["1.75", "175%"],
                        ["2.00", "200%"],
                        ["3.00", "300%"],
                        ["4.00", "400%"]
                    ], default: 2, parser: function(t) { return "1.00" === t ? null : Number(t) } }, textOpacity: { selector: ".vjs-text-opacity > select", id: "captions-foreground-opacity-%s", label: "Transparency", options: [Ln, On] }, windowColor: { selector: ".vjs-window-color > select", id: "captions-window-color-%s", label: "Color" }, windowOpacity: { selector: ".vjs-window-opacity > select", id: "captions-window-opacity-%s", label: "Transparency", options: [Rn, On, Ln] } };
        Fn.windowColor.options = Fn.backgroundColor.options; var Vn = function(o) {
            function n(t, e) { var i; return e.temporary = !1, (i = o.call(this, t, e) || this).updateDisplay = me(s(s(i)), i.updateDisplay), i.fill(), i.hasBeenOpened_ = i.hasBeenFilled_ = !0, i.endDialog = _("p", { className: "vjs-control-text", textContent: i.localize("End of dialog window.") }), i.el().appendChild(i.endDialog), i.setDefaults(), void 0 === e.persistTextTrackSettings && (i.options_.persistTextTrackSettings = i.options_.playerOptions.persistTextTrackSettings), i.on(i.$(".vjs-done-button"), "click", function() { i.saveSettings(), i.close() }), i.on(i.$(".vjs-default-button"), "click", function() { i.setDefaults(), i.updateDisplay() }), a(Fn, function(t) { i.on(i.$(t.selector), "change", i.updateDisplay) }), i.options_.persistTextTrackSettings && i.restoreSettings(), i } i(n, o); var r = n.prototype; return r.dispose = function() { this.endDialog = null, o.prototype.dispose.call(this) }, r.createElSelect_ = function(t, e, i) { var o = this;
                void 0 === e && (e = ""), void 0 === i && (i = "label"); var n = Fn[t],
                    s = n.id.replace("%s", this.id_),
                    r = [e, s].join(" ").trim(); return ["<" + i + ' id="' + s + '" class="' + ("label" === i ? "vjs-label" : "") + '">', this.localize(n.label), "</" + i + ">", '<select aria-labelledby="' + r + '">'].concat(n.options.map(function(t) { var e = s + "-" + t[1].replace(/\W+/g, ""); return ['<option id="' + e + '" value="' + t[0] + '" ', 'aria-labelledby="' + r + " " + e + '">', o.localize(t[1]), "</option>"].join("") })).concat("</select>").join("") }, r.createElFgColor_ = function() { var t = "captions-text-legend-" + this.id_; return ['<fieldset class="vjs-fg-color vjs-track-setting">', '<legend id="' + t + '">', this.localize("Text"), "</legend>", this.createElSelect_("color", t), '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_("textOpacity", t), "</span>", "</fieldset>"].join("") }, r.createElBgColor_ = function() { var t = "captions-background-" + this.id_; return ['<fieldset class="vjs-bg-color vjs-track-setting">', '<legend id="' + t + '">', this.localize("Background"), "</legend>", this.createElSelect_("backgroundColor", t), '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_("backgroundOpacity", t), "</span>", "</fieldset>"].join("") }, r.createElWinColor_ = function() { var t = "captions-window-" + this.id_; return ['<fieldset class="vjs-window-color vjs-track-setting">', '<legend id="' + t + '">', this.localize("Window"), "</legend>", this.createElSelect_("windowColor", t), '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_("windowOpacity", t), "</span>", "</fieldset>"].join("") }, r.createElColors_ = function() { return _("div", { className: "vjs-track-settings-colors", innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join("") }) }, r.createElFont_ = function() { return _("div", { className: "vjs-track-settings-font", innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_("fontPercent", "", "legend"), "</fieldset>", '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_("edgeStyle", "", "legend"), "</fieldset>", '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_("fontFamily", "", "legend"), "</fieldset>"].join("") }) }, r.createElControls_ = function() { var t = this.localize("restore all settings to the default values"); return _("div", { className: "vjs-track-settings-controls", innerHTML: ['<button type="button" class="vjs-default-button" title="' + t + '">', this.localize("Reset"), '<span class="vjs-control-text"> ' + t + "</span>", "</button>", '<button type="button" class="vjs-done-button">' + this.localize("Done") + "</button>"].join("") }) }, r.content = function() { return [this.createElColors_(), this.createElFont_(), this.createElControls_()] }, r.label = function() { return this.localize("Caption Settings Dialog") }, r.description = function() { return this.localize("Beginning of dialog window. Escape will cancel and close the window.") }, r.buildCSSClass = function() { return o.prototype.buildCSSClass.call(this) + " vjs-text-track-settings" }, r.getValues = function() { var t, e, i, o = this; return e = function(t, e, i) { var n, s, r = (n = o.$(e.selector), s = e.parser, Vt(n.options[n.options.selectedIndex].value, s)); return void 0 !== r && (t[i] = r), t }, void 0 === (i = {}) && (i = 0), Qt(t = Fn).reduce(function(i, o) { return e(i, t[o], o) }, i) }, r.setValues = function(t) { var e = this;
                a(Fn, function(i, o) {! function(t, e, i) { if (e)
                            for (var o = 0; o < t.options.length; o++)
                                if (Vt(t.options[o].value, i) === e) { t.selectedIndex = o; break } }(e.$(i.selector), t[o], i.parser) }) }, r.setDefaults = function() { var t = this;
                a(Fn, function(e) { var i = e.hasOwnProperty("default") ? e.default : 0;
                    t.$(e.selector).selectedIndex = i }) }, r.restoreSettings = function() { var t; try { t = JSON.parse(e.localStorage.getItem(An)) } catch (t) { qt.warn(t) } t && this.setValues(t) }, r.saveSettings = function() { if (this.options_.persistTextTrackSettings) { var t = this.getValues(); try { Object.keys(t).length ? e.localStorage.setItem(An, JSON.stringify(t)) : e.localStorage.removeItem(An) } catch (t) { qt.warn(t) } } }, r.updateDisplay = function() { var t = this.player_.getChild("textTrackDisplay");
                t && t.updateDisplay() }, r.conditionalBlur_ = function() { this.previouslyActiveEl_ = null, this.off(t, "keydown", this.handleKeyDown); var e = this.player_.controlBar,
                    i = e && e.subsCapsButton,
                    o = e && e.captionsButton;
                i ? i.focus() : o && o.focus() }, n }(li);
        Te.registerComponent("TextTrackSettings", Vn); var Gn = function(t) {
            function o(i, o) { var n, r = o.ResizeObserver || e.ResizeObserver;
                null === o.ResizeObserver && (r = !1); var a = ot({ createEl: !r, reportTouchActivity: !1 }, o); return (n = t.call(this, i, a) || this).ResizeObserver = o.ResizeObserver || e.ResizeObserver, n.loadListener_ = null, n.resizeObserver_ = null, n.debouncedHandler_ = function(t, i, o, n) { var s;
                    void 0 === n && (n = e); var r = function() { var e = this,
                            i = arguments,
                            o = function() { o = s = null, t.apply(e, i) };!s && !1 && t.apply(e, i), n.clearTimeout(s), s = n.setTimeout(o, 100) }; return r.cancel = function() { n.clearTimeout(s), s = null }, r }(function() { n.resizeHandler() }, 0, 0, s(s(n))), r ? (n.resizeObserver_ = new n.ResizeObserver(n.debouncedHandler_), n.resizeObserver_.observe(i.el())) : (n.loadListener_ = function() { n.el_ && n.el_.contentWindow && Y(n.el_.contentWindow, "resize", n.debouncedHandler_) }, n.one("load", n.loadListener_)), n } i(o, t); var n = o.prototype; return n.createEl = function() { return t.prototype.createEl.call(this, "iframe", { className: "vjs-resize-manager" }) }, n.resizeHandler = function() { this.player_ && this.player_.trigger && this.player_.trigger("playerresize") }, n.dispose = function() { this.debouncedHandler_ && this.debouncedHandler_.cancel(), this.resizeObserver_ && (this.player_.el() && this.resizeObserver_.unobserve(this.player_.el()), this.resizeObserver_.disconnect()), this.el_ && this.el_.contentWindow && K(this.el_.contentWindow, "resize", this.debouncedHandler_), this.loadListener_ && this.off("load", this.loadListener_), this.ResizeObserver = null, this.resizeObserver = null, this.debouncedHandler_ = null, this.loadListener_ = null }, o }(Te);
        Te.registerComponent("ResizeManager", Gn); var Un = function(t) {
            function e(e, i) { var o, n = ot({ createEl: !1 }, i); return (o = t.call(this, e, n) || this).reset_(), o.on(o.player_, "durationchange", o.handleDurationchange), o } i(e, t); var o = e.prototype; return o.isBehind_ = function() { if (!this.timeupdateSeen_) return !1; var t = this.liveCurrentTime(),
                    e = this.player_.currentTime(),
                    i = this.seekableIncrement_; return t !== 1 / 0 && e <= t - (2 * i + .07) }, o.trackLive_ = function() { this.pastSeekEnd_ = this.pastSeekEnd_; var t = this.player_.seekable(); if (t && t.length) { var e = this.seekableEnd();
                    e !== this.lastSeekEnd_ && (this.lastSeekEnd_ && (this.seekableIncrement_ = Math.abs(e - this.lastSeekEnd_)), this.pastSeekEnd_ = 0, this.lastSeekEnd_ = e, this.trigger("seekableendchange")), this.pastSeekEnd_ = this.pastSeekEnd() + .03, this.isBehind_() !== this.behindLiveEdge() && (this.behindLiveEdge_ = this.isBehind_(), this.trigger("liveedgechange")) } }, o.handleDurationchange = function() { this.player_.duration() === 1 / 0 ? this.startTracking() : this.stopTracking() }, o.startTracking = function() { var t = this;
                this.isTracking() || (this.trackingInterval_ = this.setInterval(this.trackLive_, 30), this.trackLive_(), this.on(this.player_, "play", this.trackLive_), this.on(this.player_, "pause", this.trackLive_), this.one(this.player_, "play", this.handlePlay), this.timeupdateSeen_ || (this.handleTimeupdate = function() { t.timeupdateSeen_ = !0, t.handleTimeupdate = null }, this.one(this.player_, "timeupdate", this.handleTimeupdate))) }, o.handlePlay = function() { this.one(this.player_, "timeupdate", this.seekToLiveEdge) }, o.reset_ = function() { this.pastSeekEnd_ = 0, this.lastSeekEnd_ = null, this.behindLiveEdge_ = null, this.timeupdateSeen_ = !1, this.clearInterval(this.trackingInterval_), this.trackingInterval_ = null, this.seekableIncrement_ = 12, this.off(this.player_, "play", this.trackLive_), this.off(this.player_, "pause", this.trackLive_), this.off(this.player_, "play", this.handlePlay), this.off(this.player_, "timeupdate", this.seekToLiveEdge), this.handleTimeupdate && (this.off(this.player_, "timeupdate", this.handleTimeupdate), this.handleTimeupdate = null) }, o.stopTracking = function() { this.isTracking() && this.reset_() }, o.seekableEnd = function() { for (var t = this.player_.seekable(), e = [], i = t ? t.length : 0; i--;) e.push(t.end(i)); return e.length ? e.sort()[e.length - 1] : 1 / 0 }, o.seekableStart = function() { for (var t = this.player_.seekable(), e = [], i = t ? t.length : 0; i--;) e.push(t.start(i)); return e.length ? e.sort()[0] : 0 }, o.liveWindow = function() { var t = this.liveCurrentTime(); return t === 1 / 0 ? 1 / 0 : t - this.seekableStart() }, o.isLive = function() { return this.isTracking() }, o.atLiveEdge = function() { return !this.behindLiveEdge() }, o.liveCurrentTime = function() { return this.pastSeekEnd() + this.seekableEnd() }, o.pastSeekEnd = function() { return this.pastSeekEnd_ }, o.behindLiveEdge = function() { return this.behindLiveEdge_ }, o.isTracking = function() { return "number" == typeof this.trackingInterval_ }, o.seekToLiveEdge = function() { this.atLiveEdge() || (this.player_.currentTime(this.liveCurrentTime()), this.player_.paused() && this.player_.play()) }, o.dispose = function() { this.stopTracking(), t.prototype.dispose.call(this) }, e }(Te);
        Te.registerComponent("LiveTracker", Un); var Nn = function(t) { var e = t.el(); if (e.hasAttribute("src")) return t.triggerSourceset(e.src), !0; var i = t.$$("source"),
                    o = [],
                    n = ""; if (!i.length) return !1; for (var s = 0; s < i.length; s++) { var r = i[s].src;
                    r && -1 === o.indexOf(r) && o.push(r) } return !!o.length && (1 === o.length && (n = o[0]), t.triggerSourceset(n), !0) },
            jn = Object.defineProperty({}, "innerHTML", { get: function() { return this.cloneNode(!0).innerHTML }, set: function(i) { var o = t.createElement(this.nodeName.toLowerCase());
                    o.innerHTML = i; for (var n = t.createDocumentFragment(); o.childNodes.length;) n.appendChild(o.childNodes[0]); return this.innerText = "", e.Element.prototype.appendChild.call(this, n), this.innerHTML } }),
            Wn = function(t, e) { for (var i = {}, o = 0; o < t.length && !((i = Object.getOwnPropertyDescriptor(t[o], e)) && i.set && i.get); o++); return i.enumerable = !0, i.configurable = !0, i },
            Xn = function(t) { var i = t.el(); if (!i.resetSourceWatch_) { var o = {},
                        n = Wn([t.el(), e.HTMLMediaElement.prototype, e.Element.prototype, jn], "innerHTML"),
                        s = function(e) { return function() { for (var o = arguments.length, n = new Array(o), s = 0; s < o; s++) n[s] = arguments[s]; var r = e.apply(i, n); return Nn(t), r } };
                    ["append", "appendChild", "insertAdjacentHTML"].forEach(function(t) { i[t] && (o[t] = i[t], i[t] = s(o[t])) }), Object.defineProperty(i, "innerHTML", ot(n, { set: s(n.set) })), i.resetSourceWatch_ = function() { i.resetSourceWatch_ = null, Object.keys(o).forEach(function(t) { i[t] = o[t] }), Object.defineProperty(i, "innerHTML", n) }, t.one("sourceset", i.resetSourceWatch_) } },
            Hn = Object.defineProperty({}, "src", { get: function() { return this.hasAttribute("src") ? Ai(e.Element.prototype.getAttribute.call(this, "src")) : "" }, set: function(t) { return e.Element.prototype.setAttribute.call(this, "src", t), t } }),
            zn = function(t) { if (t.featuresSourceset) { var i = t.el(); if (!i.resetSourceset_) { var o = Wn([t.el(), e.HTMLMediaElement.prototype, Hn], "src"),
                            n = i.setAttribute,
                            s = i.load;
                        Object.defineProperty(i, "src", ot(o, { set: function(e) { var n = o.set.call(i, e); return t.triggerSourceset(i.src), n } })), i.setAttribute = function(e, o) { var s = n.call(i, e, o); return /src/i.test(e) && t.triggerSourceset(i.src), s }, i.load = function() { var e = s.call(i); return Nn(t) || (t.triggerSourceset(""), Xn(t)), e }, i.currentSrc ? t.triggerSourceset(i.currentSrc) : Nn(t) || Xn(t), i.resetSourceset_ = function() { i.resetSourceset_ = null, i.load = s, i.setAttribute = n, Object.defineProperty(i, "src", o), i.resetSourceWatch_ && i.resetSourceWatch_() } } } },
            Jn = function(o) {
                function n(t, e) { var i;
                    i = o.call(this, t, e) || this; var n = t.source,
                        s = !1; if (n && (i.el_.currentSrc !== n.src || t.tag && 3 === t.tag.initNetworkState_) ? i.setSource(n) : i.handleLateInit_(i.el_), t.enableSourceset && i.setupSourcesetHandling_(), i.el_.hasChildNodes()) { for (var r = i.el_.childNodes, a = r.length, h = []; a--;) { var l = r[a]; "track" === l.nodeName.toLowerCase() && (i.featuresNativeTextTracks ? (i.remoteTextTrackEls().addTrackElement_(l), i.remoteTextTracks().addTrack(l.track), i.textTracks().addTrack(l.track), s || i.el_.hasAttribute("crossorigin") || !Pi(l.src) || (s = !0)) : h.push(l)) } for (var c = 0; c < h.length; c++) i.el_.removeChild(h[c]) } return i.proxyNativeTracks_(), i.featuresNativeTextTracks && s && qt.warn(Kt(Gt())), i.restoreMetadataTracksInIOSNativePlayer_(), (Ke || Re || je) && !0 === t.nativeControlsForTouch && i.setControls(!0), i.proxyWebkitFullscreen_(), i.triggerReady(), i } i(n, o); var s = n.prototype; return s.dispose = function() { this.el_ && this.el_.resetSourceset_ && this.el_.resetSourceset_(), n.disposeMediaElement(this.el_), this.options_ = null, o.prototype.dispose.call(this) }, s.setupSourcesetHandling_ = function() { zn(this) }, s.restoreMetadataTracksInIOSNativePlayer_ = function() { var t, e = this.textTracks(),
                        i = function() { t = []; for (var i = 0; i < e.length; i++) { var o = e[i]; "metadata" === o.kind && t.push({ track: o, storedMode: o.mode }) } };
                    i(), e.addEventListener("change", i), this.on("dispose", function() { return e.removeEventListener("change", i) }); var o = function i() { for (var o = 0; o < t.length; o++) { var n = t[o]; "disabled" === n.track.mode && n.track.mode !== n.storedMode && (n.track.mode = n.storedMode) } e.removeEventListener("change", i) };
                    this.on("webkitbeginfullscreen", function() { e.removeEventListener("change", i), e.removeEventListener("change", o), e.addEventListener("change", o) }), this.on("webkitendfullscreen", function() { e.removeEventListener("change", i), e.addEventListener("change", i), e.removeEventListener("change", o) }) }, s.overrideNative_ = function(t, e) { var i = this; if (e === this["featuresNative" + t + "Tracks"]) { var o = t.toLowerCase();
                        this[o + "TracksListeners_"] && Object.keys(this[o + "TracksListeners_"]).forEach(function(t) { i.el()[o + "Tracks"].removeEventListener(t, i[o + "TracksListeners_"][t]) }), this["featuresNative" + t + "Tracks"] = !e, this[o + "TracksListeners_"] = null, this.proxyNativeTracksForType_(o) } }, s.overrideNativeAudioTracks = function(t) { this.overrideNative_("Audio", t) }, s.overrideNativeVideoTracks = function(t) { this.overrideNative_("Video", t) }, s.proxyNativeTracksForType_ = function(t) { var e = this,
                        i = Ki[t],
                        o = this.el()[i.getterName],
                        n = this[i.getterName](); if (this["featuresNative" + i.capitalName + "Tracks"] && o && o.addEventListener) { var s = { change: function(t) { n.trigger({ type: "change", target: n, currentTarget: n, srcElement: n }) }, addtrack: function(t) { n.addTrack(t.track) }, removetrack: function(t) { n.removeTrack(t.track) } },
                            r = function() { for (var t = [], e = 0; e < n.length; e++) { for (var i = !1, s = 0; s < o.length; s++)
                                        if (o[s] === n[e]) { i = !0; break } i || t.push(n[e]) } for (; t.length;) n.removeTrack(t.shift()) };
                        this[i.getterName + "Listeners_"] = s, Object.keys(s).forEach(function(t) { var i = s[t];
                            o.addEventListener(t, i), e.on("dispose", function(e) { return o.removeEventListener(t, i) }) }), this.on("loadstart", r), this.on("dispose", function(t) { return e.off("loadstart", r) }) } }, s.proxyNativeTracks_ = function() { var t = this;
                    Ki.names.forEach(function(e) { t.proxyNativeTracksForType_(e) }) }, s.createEl = function() { var e = this.options_.tag; if (!e || !this.options_.playerElIngest && !this.movingMediaElementInDOM) { if (e) { var i = e.cloneNode(!0);
                            e.parentNode && e.parentNode.insertBefore(i, e), n.disposeMediaElement(e), e = i } else { e = t.createElement("video"); var o = ot({}, this.options_.tag && P(this.options_.tag));
                            Ke && !0 === this.options_.nativeControlsForTouch || delete o.controls, T(e, h(o, { id: this.options_.techId, class: "vjs-tech" })) } e.playerId = this.options_.playerId } void 0 !== this.options_.preload && M(e, "preload", this.options_.preload); for (var s = ["loop", "muted", "playsinline", "autoplay"], r = 0; r < s.length; r++) { var a = s[r],
                            l = this.options_[a];
                        void 0 !== l && (l ? M(e, a, a) : E(e, a), e[a] = l) } return e }, s.handleLateInit_ = function(t) { if (0 !== t.networkState && 3 !== t.networkState) { if (0 === t.readyState) { var e = !1,
                                i = function() { e = !0 };
                            this.on("loadstart", i); var o = function() { e || this.trigger("loadstart") }; return this.on("loadedmetadata", o), void this.ready(function() { this.off("loadstart", i), this.off("loadedmetadata", o), e || this.trigger("loadstart") }) } var n = ["loadstart"];
                        n.push("loadedmetadata"), 2 <= t.readyState && n.push("loadeddata"), 3 <= t.readyState && n.push("canplay"), 4 <= t.readyState && n.push("canplaythrough"), this.ready(function() { n.forEach(function(t) { this.trigger(t) }, this) }) } }, s.setCurrentTime = function(t) { try { this.el_.currentTime = t } catch (t) { qt(t, "Video is not ready. (Video.js)") } }, s.duration = function() { var t = this; return this.el_.duration === 1 / 0 && Ue && He && 0 === this.el_.currentTime ? (this.on("timeupdate", function e() { 0 < t.el_.currentTime && (t.el_.duration === 1 / 0 && t.trigger("durationchange"), t.off("timeupdate", e)) }), NaN) : this.el_.duration || NaN }, s.width = function() { return this.el_.offsetWidth }, s.height = function() { return this.el_.offsetHeight }, s.proxyWebkitFullscreen_ = function() { var t = this; if ("webkitDisplayingFullscreen" in this.el_) { var e = function() { this.trigger("fullscreenchange", { isFullscreen: !1 }) },
                            i = function() { "webkitPresentationMode" in this.el_ && "picture-in-picture" !== this.el_.webkitPresentationMode && (this.one("webkitendfullscreen", e), this.trigger("fullscreenchange", { isFullscreen: !0 })) };
                        this.on("webkitbeginfullscreen", i), this.on("dispose", function() { t.off("webkitbeginfullscreen", i), t.off("webkitendfullscreen", e) }) } }, s.supportsFullScreen = function() { if ("function" == typeof this.el_.webkitEnterFullScreen) { var t = e.navigator && e.navigator.userAgent || ""; if (/Android/.test(t) || !/Chrome|Mac OS X 10.5/.test(t)) return !0 } return !1 }, s.enterFullScreen = function() { var t = this.el_;
                    t.paused && t.networkState <= t.HAVE_METADATA ? (this.el_.play(), this.setTimeout(function() { t.pause(), t.webkitEnterFullScreen() }, 0)) : t.webkitEnterFullScreen() }, s.exitFullScreen = function() { this.el_.webkitExitFullScreen() }, s.src = function(t) { if (void 0 === t) return this.el_.src;
                    this.setSrc(t) }, s.reset = function() { n.resetMediaElement(this.el_) }, s.currentSrc = function() { return this.currentSource_ ? this.currentSource_.src : this.el_.currentSrc }, s.setControls = function(t) { this.el_.controls = !!t }, s.addTextTrack = function(t, e, i) { return this.featuresNativeTextTracks ? this.el_.addTextTrack(t, e, i) : o.prototype.addTextTrack.call(this, t, e, i) }, s.createRemoteTextTrack = function(e) { if (!this.featuresNativeTextTracks) return o.prototype.createRemoteTextTrack.call(this, e); var i = t.createElement("track"); return e.kind && (i.kind = e.kind), e.label && (i.label = e.label), (e.language || e.srclang) && (i.srclang = e.language || e.srclang), e.default && (i.default = e.default), e.id && (i.id = e.id), e.src && (i.src = e.src), i }, s.addRemoteTextTrack = function(t, e) { var i = o.prototype.addRemoteTextTrack.call(this, t, e); return this.featuresNativeTextTracks && this.el().appendChild(i), i }, s.removeRemoteTextTrack = function(t) { if (o.prototype.removeRemoteTextTrack.call(this, t), this.featuresNativeTextTracks)
                        for (var e = this.$$("track"), i = e.length; i--;) t !== e[i] && t !== e[i].track || this.el().removeChild(e[i]) }, s.getVideoPlaybackQuality = function() { if ("function" == typeof this.el().getVideoPlaybackQuality) return this.el().getVideoPlaybackQuality(); var t = {}; return void 0 !== this.el().webkitDroppedFrameCount && void 0 !== this.el().webkitDecodedFrameCount && (t.droppedVideoFrames = this.el().webkitDroppedFrameCount, t.totalVideoFrames = this.el().webkitDecodedFrameCount), e.performance && "function" == typeof e.performance.now ? t.creationTime = e.performance.now() : e.performance && e.performance.timing && "number" == typeof e.performance.timing.navigationStart && (t.creationTime = e.Date.now() - e.performance.timing.navigationStart), t }, n }(po); if (f()) { Jn.TEST_VID = t.createElement("video"); var qn = t.createElement("track");
            qn.kind = "captions", qn.srclang = "en", qn.label = "English", Jn.TEST_VID.appendChild(qn) } Jn.isSupported = function() { try { Jn.TEST_VID.volume = .5 } catch (t) { return !1 } return !(!Jn.TEST_VID || !Jn.TEST_VID.canPlayType) }, Jn.canPlayType = function(t) { return Jn.TEST_VID.canPlayType(t) }, Jn.canPlaySource = function(t, e) { return Jn.canPlayType(t.type) }, Jn.canControlVolume = function() { try { var t = Jn.TEST_VID.volume; return Jn.TEST_VID.volume = t / 2 + .1, t !== Jn.TEST_VID.volume } catch (t) { return !1 } }, Jn.canMuteVolume = function() { try { var t = Jn.TEST_VID.muted; return Jn.TEST_VID.muted = !t, Jn.TEST_VID.muted ? M(Jn.TEST_VID, "muted", "muted") : E(Jn.TEST_VID, "muted"), t !== Jn.TEST_VID.muted } catch (t) { return !1 } }, Jn.canControlPlaybackRate = function() { if (Ue && He && ze < 58) return !1; try { var t = Jn.TEST_VID.playbackRate; return Jn.TEST_VID.playbackRate = t / 2 + .1, t !== Jn.TEST_VID.playbackRate } catch (t) { return !1 } }, Jn.canOverrideAttributes = function() { try { var e = function() {};
                Object.defineProperty(t.createElement("video"), "src", { get: e, set: e }), Object.defineProperty(t.createElement("audio"), "src", { get: e, set: e }), Object.defineProperty(t.createElement("video"), "innerHTML", { get: e, set: e }), Object.defineProperty(t.createElement("audio"), "innerHTML", { get: e, set: e }) } catch (e) { return !1 } return !0 }, Jn.supportsNativeTextTracks = function() { return Ye || Ve && He }, Jn.supportsNativeVideoTracks = function() { return !(!Jn.TEST_VID || !Jn.TEST_VID.videoTracks) }, Jn.supportsNativeAudioTracks = function() { return !(!Jn.TEST_VID || !Jn.TEST_VID.audioTracks) }, Jn.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"], Jn.prototype.featuresVolumeControl = Jn.canControlVolume(), Jn.prototype.featuresMuteControl = Jn.canMuteVolume(), Jn.prototype.featuresPlaybackRate = Jn.canControlPlaybackRate(), Jn.prototype.featuresSourceset = Jn.canOverrideAttributes(), Jn.prototype.movingMediaElementInDOM = !Ve, Jn.prototype.featuresFullscreenResize = !0, Jn.prototype.featuresProgressEvents = !0, Jn.prototype.featuresTimeupdateEvents = !0, Jn.prototype.featuresNativeTextTracks = Jn.supportsNativeTextTracks(), Jn.prototype.featuresNativeVideoTracks = Jn.supportsNativeVideoTracks(), Jn.prototype.featuresNativeAudioTracks = Jn.supportsNativeAudioTracks(); var Yn = Jn.TEST_VID && Jn.TEST_VID.constructor.prototype.canPlayType,
            Kn = /^application\/(?:x-|vnd\.apple\.)mpegurl/i;
        Jn.patchCanPlayType = function() { 4 <= Ne && !We && !He && (Jn.TEST_VID.constructor.prototype.canPlayType = function(t) { return t && Kn.test(t) ? "maybe" : Yn.call(this, t) }) }, Jn.unpatchCanPlayType = function() { var t = Jn.TEST_VID.constructor.prototype.canPlayType; return Jn.TEST_VID.constructor.prototype.canPlayType = Yn, t }, Jn.patchCanPlayType(), Jn.disposeMediaElement = function(t) { if (t) { for (t.parentNode && t.parentNode.removeChild(t); t.hasChildNodes();) t.removeChild(t.firstChild);
                t.removeAttribute("src"), "function" == typeof t.load && function() { try { t.load() } catch (t) {} }() } }, Jn.resetMediaElement = function(t) { if (t) { for (var e = t.querySelectorAll("source"), i = e.length; i--;) t.removeChild(e[i]);
                t.removeAttribute("src"), "function" == typeof t.load && function() { try { t.load() } catch (t) {} }() } }, ["muted", "defaultMuted", "autoplay", "controls", "loop", "playsinline"].forEach(function(t) { Jn.prototype[t] = function() { return this.el_[t] || this.el_.hasAttribute(t) } }), ["muted", "defaultMuted", "autoplay", "loop", "playsinline"].forEach(function(t) { Jn.prototype["set" + it(t)] = function(e) {
                (this.el_[t] = e) ? this.el_.setAttribute(t, t): this.el_.removeAttribute(t) } }), ["paused", "currentTime", "buffered", "volume", "poster", "preload", "error", "seeking", "seekable", "ended", "playbackRate", "defaultPlaybackRate", "played", "networkState", "readyState", "videoWidth", "videoHeight"].forEach(function(t) { Jn.prototype[t] = function() { return this.el_[t] } }), ["volume", "src", "poster", "preload", "playbackRate", "defaultPlaybackRate"].forEach(function(t) { Jn.prototype["set" + it(t)] = function(e) { this.el_[t] = e } }), ["pause", "load", "play"].forEach(function(t) { Jn.prototype[t] = function() { return this.el_[t]() } }), po.withSourceHandlers(Jn), Jn.nativeSourceHandler = {}, Jn.nativeSourceHandler.canPlayType = function(t) { try { return Jn.TEST_VID.canPlayType(t) } catch (t) { return "" } }, Jn.nativeSourceHandler.canHandleSource = function(t, e) { if (t.type) return Jn.nativeSourceHandler.canPlayType(t.type); if (t.src) { var i = Ti(t.src); return Jn.nativeSourceHandler.canPlayType("video/" + i) } return "" }, Jn.nativeSourceHandler.handleSource = function(t, e, i) { e.setSrc(t.src) }, Jn.nativeSourceHandler.dispose = function() {}, Jn.registerSourceHandler(Jn.nativeSourceHandler), po.registerTech("Html5", Jn); var Zn = ["progress", "abort", "suspend", "emptied", "stalled", "loadedmetadata", "loadeddata", "timeupdate", "resize", "volumechange", "texttrackchange"],
            Qn = { canplay: "CanPlay", canplaythrough: "CanPlayThrough", playing: "Playing", seeked: "Seeked" },
            $n = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"],
            ts = {};
        $n.forEach(function(t) { var e = "x" === t.charAt(0) ? "x-" + t.substring(1) : t;
            ts[t] = "vjs-layout-" + e }); var es = { tiny: 210, xsmall: 320, small: 425, medium: 768, large: 1440, xlarge: 2560, huge: 1 / 0 },
            is = function(o) {
                function n(t, e, i) { var r; if (t.id = t.id || e.id || "vjs_video_" + j(), (e = h(n.getTagSettings(t), e)).initChildren = !1, e.createEl = !1, e.evented = !1, e.reportTouchActivity = !1, !e.language)
                        if ("function" == typeof t.closest) { var a = t.closest("[lang]");
                            a && a.getAttribute && (e.language = a.getAttribute("lang")) } else
                            for (var l = t; l && 1 === l.nodeType;) { if (P(l).hasOwnProperty("lang")) { e.language = l.getAttribute("lang"); break } l = l.parentNode }
                    if ((r = o.call(this, null, e, i) || this).log = Yt(r.id_), r.isPosterFromTech_ = !1, r.queuedCallbacks_ = [], r.isReady_ = !1, r.hasStarted_ = !1, r.userActive_ = !1, !r.options_ || !r.options_.techOrder || !r.options_.techOrder.length) throw new Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?"); if (r.tag = t, r.tagAttributes = t && P(t), r.language(r.options_.language), e.languages) { var c = {};
                        Object.getOwnPropertyNames(e.languages).forEach(function(t) { c[t.toLowerCase()] = e.languages[t] }), r.languages_ = c } else r.languages_ = n.prototype.options_.languages;
                    r.cache_ = {}, r.poster_ = e.poster || "", r.controls_ = !!e.controls, r.cache_.lastVolume = 1, t.controls = !1, t.removeAttribute("controls"), t.hasAttribute("autoplay") ? r.options_.autoplay = !0 : r.autoplay(r.options_.autoplay), r.scrubbing_ = !1, r.el_ = r.createEl(), r.cache_.lastPlaybackRate = r.defaultPlaybackRate(), tt(s(s(r)), { eventBusKey: "el_" }), r.fluid_ && r.on("playerreset", r.updateStyleEl_); var d = ot(r.options_); if (e.plugins) { var u = e.plugins;
                        Object.keys(u).forEach(function(t) { if ("function" != typeof this[t]) throw new Error('plugin "' + t + '" does not exist');
                            this[t](u[t]) }, s(s(r))) } r.options_.playerOptions = d, r.middleware_ = [], r.initChildren(), r.isAudio("audio" === t.nodeName.toLowerCase()), r.controls() ? r.addClass("vjs-controls-enabled") : r.addClass("vjs-controls-disabled"), r.el_.setAttribute("role", "region"), r.isAudio() ? r.el_.setAttribute("aria-label", r.localize("Audio Player")) : r.el_.setAttribute("aria-label", r.localize("Video Player")), r.isAudio() && r.addClass("vjs-audio"), r.flexNotSupported_() && r.addClass("vjs-no-flex"), Ve || r.addClass("vjs-workinghover"), n.players[r.id_] = s(s(r)); var p = Ht.split(".")[0]; return r.addClass("vjs-v" + p), r.userActive(!0), r.reportUserActivity(), r.one("play", r.listenForUserActivity_), r.on("fullscreenchange", r.handleFullscreenChange_), r.on("stageclick", r.handleStageClick_), r.breakpoints(r.options_.breakpoints), r.responsive(r.options_.responsive), r.changingSrc_ = !1, r.playWaitingForReady_ = !1, r.playOnLoadstart_ = null, r } i(n, o); var r = n.prototype; return r.dispose = function() { this.trigger("dispose"), this.off("dispose"), this.styleEl_ && this.styleEl_.parentNode && (this.styleEl_.parentNode.removeChild(this.styleEl_), this.styleEl_ = null), n.players[this.id_] = null, this.tag && this.tag.player && (this.tag.player = null), this.el_ && this.el_.player && (this.el_.player = null), this.tech_ && (this.tech_.dispose(), this.isPosterFromTech_ = !1, this.poster_ = ""), this.playerElIngest_ && (this.playerElIngest_ = null), this.tag && (this.tag = null), fo[this.id()] = null, o.prototype.dispose.call(this) }, r.createEl = function() { var i, n = this.tag,
                        s = this.playerElIngest_ = n.parentNode && n.parentNode.hasAttribute && n.parentNode.hasAttribute("data-vjs-player"),
                        r = "video-js" === this.tag.tagName.toLowerCase();
                    s ? i = this.el_ = n.parentNode : r || (i = this.el_ = o.prototype.createEl.call(this, "div")); var a = P(n); if (r) { for (i = this.el_ = n, n = this.tag = t.createElement("video"); i.children.length;) n.appendChild(i.firstChild);
                        S(i, "video-js") || C(i, "video-js"), i.appendChild(n), s = this.playerElIngest_ = i, Object.keys(i).forEach(function(t) { n[t] = i[t] }) } if (n.setAttribute("tabindex", "-1"), a.tabindex = "-1", Je && (n.setAttribute("role", "application"), a.role = "application"), n.removeAttribute("width"), n.removeAttribute("height"), "width" in a && delete a.width, "height" in a && delete a.height, Object.getOwnPropertyNames(a).forEach(function(t) { r && "class" === t || i.setAttribute(t, a[t]), r && n.setAttribute(t, a[t]) }), n.playerId = n.id, n.id += "_html5_api", n.className = "vjs-tech", n.player = i.player = this, this.addClass("vjs-paused"), !0 !== e.VIDEOJS_NO_DYNAMIC_STYLE) { this.styleEl_ = ue("vjs-styles-dimensions"); var h = $t(".vjs-styles-defaults"),
                            l = $t("head");
                        l.insertBefore(this.styleEl_, h ? h.nextSibling : l.firstChild) } this.fill_ = !1, this.fluid_ = !1, this.width(this.options_.width), this.height(this.options_.height), this.fill(this.options_.fill), this.fluid(this.options_.fluid), this.aspectRatio(this.options_.aspectRatio); for (var c = n.getElementsByTagName("a"), d = 0; d < c.length; d++) { var u = c.item(d);
                        C(u, "vjs-hidden"), u.setAttribute("hidden", "hidden") } return n.initNetworkState_ = n.networkState, n.parentNode && !s && n.parentNode.insertBefore(i, n), x(n, i), this.children_.unshift(n), this.el_.setAttribute("lang", this.language_), this.el_ = i }, r.width = function(t) { return this.dimension("width", t) }, r.height = function(t) { return this.dimension("height", t) }, r.dimension = function(t, e) { var i = t + "_"; if (void 0 === e) return this[i] || 0; if ("" === e) return this[i] = void 0, void this.updateStyleEl_(); var o = parseFloat(e);
                    isNaN(o) ? qt.error('Improper value "' + e + '" supplied for for ' + t) : (this[i] = o, this.updateStyleEl_()) }, r.fluid = function(t) { if (void 0 === t) return !!this.fluid_; var e, i;
                    this.fluid_ = !!t, be(this) && this.off("playerreset", this.updateStyleEl_), t ? (this.addClass("vjs-fluid"), this.fill(!1), be(e = function() { this.on("playerreset", this.updateStyleEl_) }) ? i() : (e.eventedCallbacks || (e.eventedCallbacks = []), e.eventedCallbacks.push(i))) : this.removeClass("vjs-fluid"), this.updateStyleEl_() }, r.fill = function(t) { if (void 0 === t) return !!this.fill_;
                    this.fill_ = !!t, t ? (this.addClass("vjs-fill"), this.fluid(!1)) : this.removeClass("vjs-fill") }, r.aspectRatio = function(t) { if (void 0 === t) return this.aspectRatio_; if (!/^\d+\:\d+$/.test(t)) throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
                    this.aspectRatio_ = t, this.fluid(!0), this.updateStyleEl_() }, r.updateStyleEl_ = function() { if (!0 !== e.VIDEOJS_NO_DYNAMIC_STYLE) { var t, i, o, n = (void 0 !== this.aspectRatio_ && "auto" !== this.aspectRatio_ ? this.aspectRatio_ : 0 < this.videoWidth() ? this.videoWidth() + ":" + this.videoHeight() : "16:9").split(":"),
                            s = n[1] / n[0];
                        t = void 0 !== this.width_ ? this.width_ : void 0 !== this.height_ ? this.height_ / s : this.videoWidth() || 300, i = void 0 !== this.height_ ? this.height_ : t * s, o = /^[^a-zA-Z]/.test(this.id()) ? "dimensions-" + this.id() : this.id() + "-dimensions", this.addClass(o), pe(this.styleEl_, "\n      ." + o + " {\n        width: " + t + "px;\n        height: " + i + "px;\n      }\n\n      ." + o + ".vjs-fluid {\n        padding-top: " + 100 * s + "%;\n      }\n    ") } else { var r = "number" == typeof this.width_ ? this.width_ : this.options_.width,
                            a = "number" == typeof this.height_ ? this.height_ : this.options_.height,
                            h = this.tech_ && this.tech_.el();
                        h && (0 <= r && (h.width = r), 0 <= a && (h.height = a)) } }, r.loadTech_ = function(t, e) { var i = this;
                    this.tech_ && this.unloadTech_(); var o = it(t),
                        n = t.charAt(0).toLowerCase() + t.slice(1); "Html5" !== o && this.tag && (po.getTech("Html5").disposeMediaElement(this.tag), this.tag.player = null, this.tag = null), this.techName_ = o, this.isReady_ = !1; var s = { source: e, autoplay: "string" != typeof this.autoplay() && this.autoplay(), nativeControlsForTouch: this.options_.nativeControlsForTouch, playerId: this.id(), techId: this.id() + "_" + n + "_api", playsinline: this.options_.playsinline, preload: this.options_.preload, loop: this.options_.loop, muted: this.options_.muted, poster: this.poster(), language: this.language(), playerElIngest: this.playerElIngest_ || !1, "vtt.js": this.options_["vtt.js"], canOverridePoster: !!this.options_.techCanOverridePoster, enableSourceset: this.options_.enableSourceset };
                    Qi.names.forEach(function(t) { var e = Qi[t];
                        s[e.getterName] = i[e.privateName] }), h(s, this.options_[o]), h(s, this.options_[n]), h(s, this.options_[t.toLowerCase()]), this.tag && (s.tag = this.tag), e && e.src === this.cache_.src && 0 < this.cache_.currentTime && (s.startTime = this.cache_.currentTime); var r = po.getTech(t); if (!r) throw new Error("No Tech named '" + o + "' exists! '" + o + "' should be registered using videojs.registerTech()'");
                    this.tech_ = new r(s), this.tech_.ready(me(this, this.handleTechReady_), !0), ai(this.textTracksJson_ || [], this.tech_), Zn.forEach(function(t) { i.on(i.tech_, t, i["handleTech" + it(t) + "_"]) }), Object.keys(Qn).forEach(function(t) { i.on(i.tech_, t, function(e) { 0 === i.tech_.playbackRate() && i.tech_.seeking() ? i.queuedCallbacks_.push({ callback: i["handleTech" + Qn[t] + "_"].bind(i), event: e }) : i["handleTech" + Qn[t] + "_"](e) }) }), this.on(this.tech_, "loadstart", this.handleTechLoadStart_), this.on(this.tech_, "sourceset", this.handleTechSourceset_), this.on(this.tech_, "waiting", this.handleTechWaiting_), this.on(this.tech_, "ended", this.handleTechEnded_), this.on(this.tech_, "seeking", this.handleTechSeeking_), this.on(this.tech_, "play", this.handleTechPlay_), this.on(this.tech_, "firstplay", this.handleTechFirstPlay_), this.on(this.tech_, "pause", this.handleTechPause_), this.on(this.tech_, "durationchange", this.handleTechDurationChange_), this.on(this.tech_, "fullscreenchange", this.handleTechFullscreenChange_), this.on(this.tech_, "error", this.handleTechError_), this.on(this.tech_, "loadedmetadata", this.updateStyleEl_), this.on(this.tech_, "posterchange", this.handleTechPosterChange_), this.on(this.tech_, "textdata", this.handleTechTextData_), this.on(this.tech_, "ratechange", this.handleTechRateChange_), this.usingNativeControls(this.techGet_("controls")), this.controls() && !this.usingNativeControls() && this.addTechControlsListeners_(), this.tech_.el().parentNode === this.el() || "Html5" === o && this.tag || x(this.tech_.el(), this.el()), this.tag && (this.tag.player = null, this.tag = null) }, r.unloadTech_ = function() { var t = this;
                    Qi.names.forEach(function(e) { var i = Qi[e];
                        t[i.privateName] = t[i.getterName]() }), this.textTracksJson_ = ri(this.tech_), this.isReady_ = !1, this.tech_.dispose(), this.tech_ = !1, this.isPosterFromTech_ && (this.poster_ = "", this.trigger("posterchange")), this.isPosterFromTech_ = !1 }, r.tech = function(t) { return void 0 === t && qt.warn(Kt(Ut())), this.tech_ }, r.addTechControlsListeners_ = function() { this.removeTechControlsListeners_(), this.on(this.tech_, "mousedown", this.handleTechClick_), this.on(this.tech_, "dblclick", this.handleTechDoubleClick_), this.on(this.tech_, "touchstart", this.handleTechTouchStart_), this.on(this.tech_, "touchmove", this.handleTechTouchMove_), this.on(this.tech_, "touchend", this.handleTechTouchEnd_), this.on(this.tech_, "tap", this.handleTechTap_) }, r.removeTechControlsListeners_ = function() { this.off(this.tech_, "tap", this.handleTechTap_), this.off(this.tech_, "touchstart", this.handleTechTouchStart_), this.off(this.tech_, "touchmove", this.handleTechTouchMove_), this.off(this.tech_, "touchend", this.handleTechTouchEnd_), this.off(this.tech_, "mousedown", this.handleTechClick_), this.off(this.tech_, "dblclick", this.handleTechDoubleClick_) }, r.handleTechReady_ = function() { this.triggerReady(), this.cache_.volume && this.techCall_("setVolume", this.cache_.volume), this.handleTechPosterChange_(), this.handleTechDurationChange_() }, r.handleTechLoadStart_ = function() { this.removeClass("vjs-ended"), this.removeClass("vjs-seeking"), this.error(null), this.handleTechDurationChange_(), this.paused() ? (this.hasStarted(!1), this.trigger("loadstart")) : (this.trigger("loadstart"), this.trigger("firstplay")), this.manualAutoplay_(this.autoplay()) }, r.manualAutoplay_ = function(t) { var e = this; if (this.tech_ && "string" == typeof t) { var i, o = function() { var t = e.muted();
                            e.muted(!0); var i = e.play(); if (i && i.then && i.catch) return i.catch(function(i) { e.muted(t) }) }; if ("any" === t ? (i = this.play()) && i.then && i.catch && i.catch(function() { return o() }) : i = "muted" === t ? o() : this.play(), i && i.then && i.catch) return i.then(function() { e.trigger({ type: "autoplay-success", autoplay: t }) }).catch(function(i) { e.trigger({ type: "autoplay-failure", autoplay: t }) }) } }, r.updateSourceCaches_ = function(t) { void 0 === t && (t = ""); var e = t,
                        i = ""; "string" != typeof e && (e = t.src, i = t.type), this.cache_.source = this.cache_.source || {}, this.cache_.sources = this.cache_.sources || [], e && !i && (i = function(t, e) { if (!e) return ""; if (t.cache_.source.src === e && t.cache_.source.type) return t.cache_.source.type; var i = t.cache_.sources.filter(function(t) { return t.src === e }); if (i.length) return i[0].type; for (var o = t.$$("source"), n = 0; n < o.length; n++) { var s = o[n]; if (s.type && s.src && s.src === e) return s.type } return xo(e) }(this, e)), this.cache_.source = ot({}, t, { src: e, type: i }); for (var o = this.cache_.sources.filter(function(t) { return t.src && t.src === e }), n = [], s = this.$$("source"), r = [], a = 0; a < s.length; a++) { var h = P(s[a]);
                        n.push(h), h.src && h.src === e && r.push(h.src) } r.length && !o.length ? this.cache_.sources = n : o.length || (this.cache_.sources = [this.cache_.source]), this.cache_.src = e }, r.handleTechSourceset_ = function(t) { var e = this; if (!this.changingSrc_) { var i = function(t) { return e.updateSourceCaches_(t) },
                            o = this.currentSource().src,
                            n = t.src;
                        o && !/^blob:/.test(o) && /^blob:/.test(n) && (!this.lastSource_ || this.lastSource_.tech !== n && this.lastSource_.player !== o) && (i = function() {}), i(n), t.src || this.tech_.one(["sourceset", "loadstart"], function t(i) { if ("sourceset" !== i.type) { var o = e.techGet("currentSrc");
                                e.lastSource_.tech = o, e.updateSourceCaches_(o) } e.tech_.off(["sourceset", "loadstart"], t) }) } this.lastSource_ = { player: this.currentSource().src, tech: t.src }, this.trigger({ src: t.src, type: "sourceset" }) }, r.hasStarted = function(t) { if (void 0 === t) return this.hasStarted_;
                    t !== this.hasStarted_ && (this.hasStarted_ = t, this.hasStarted_ ? (this.addClass("vjs-has-started"), this.trigger("firstplay")) : this.removeClass("vjs-has-started")) }, r.handleTechPlay_ = function() { this.removeClass("vjs-ended"), this.removeClass("vjs-paused"), this.addClass("vjs-playing"), this.hasStarted(!0), this.trigger("play") }, r.handleTechRateChange_ = function() { 0 < this.tech_.playbackRate() && 0 === this.cache_.lastPlaybackRate && (this.queuedCallbacks_.forEach(function(t) { return t.callback(t.event) }), this.queuedCallbacks_ = []), this.cache_.lastPlaybackRate = this.tech_.playbackRate(), this.trigger("ratechange") }, r.handleTechWaiting_ = function() { var t = this;
                    this.addClass("vjs-waiting"), this.trigger("waiting"); var e = this.currentTime();
                    this.on("timeupdate", function i() { e !== t.currentTime() && (t.removeClass("vjs-waiting"), t.off("timeupdate", i)) }) }, r.handleTechCanPlay_ = function() { this.removeClass("vjs-waiting"), this.trigger("canplay") }, r.handleTechCanPlayThrough_ = function() { this.removeClass("vjs-waiting"), this.trigger("canplaythrough") }, r.handleTechPlaying_ = function() { this.removeClass("vjs-waiting"), this.trigger("playing") }, r.handleTechSeeking_ = function() { this.addClass("vjs-seeking"), this.trigger("seeking") }, r.handleTechSeeked_ = function() { this.removeClass("vjs-seeking"), this.trigger("seeked") }, r.handleTechFirstPlay_ = function() { this.options_.starttime && (qt.warn("Passing the `starttime` option to the player will be deprecated in 6.0"), this.currentTime(this.options_.starttime)), this.addClass("vjs-has-started"), this.trigger("firstplay") }, r.handleTechPause_ = function() { this.removeClass("vjs-playing"), this.addClass("vjs-paused"), this.trigger("pause") }, r.handleTechEnded_ = function() { this.addClass("vjs-ended"), this.options_.loop ? (this.currentTime(0), this.play()) : this.paused() || this.pause(), this.trigger("ended") }, r.handleTechDurationChange_ = function() { this.duration(this.techGet_("duration")) }, r.handleTechClick_ = function(t) { N(t) && this.controls_ && (this.paused() ? ct(this.play()) : this.pause()) }, r.handleTechDoubleClick_ = function(t) { this.controls_ && (Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), function(e) { return e.contains(t.target) }) || (this.isFullscreen() ? this.exitFullscreen() : this.requestFullscreen())) }, r.handleTechTap_ = function() { this.userActive(!this.userActive()) }, r.handleTechTouchStart_ = function() { this.userWasActive = this.userActive() }, r.handleTechTouchMove_ = function() { this.userWasActive && this.reportUserActivity() }, r.handleTechTouchEnd_ = function(t) { t.preventDefault() }, r.handleFullscreenChange_ = function() { this.isFullscreen() ? this.addClass("vjs-fullscreen") : this.removeClass("vjs-fullscreen") }, r.handleStageClick_ = function() { this.reportUserActivity() }, r.handleTechFullscreenChange_ = function(t, e) { e && this.isFullscreen(e.isFullscreen), this.trigger("fullscreenchange") }, r.handleTechError_ = function() { var t = this.tech_.error();
                    this.error(t) }, r.handleTechTextData_ = function() { var t = null;
                    1 < arguments.length && (t = arguments[1]), this.trigger("textdata", t) }, r.getCache = function() { return this.cache_ }, r.techCall_ = function(t, e) { this.ready(function() { if (t in go) return i = this.middleware_, o = this.tech_, s = e, o[n = t](i.reduce(It(n), s)); if (t in _o) return Bt(this.middleware_, this.tech_, t, e); var i, o, n, s; try { this.tech_ && this.tech_[t](e) } catch (i) { throw qt(i), i } }, !0) }, r.techGet_ = function(t) { if (this.tech_ && this.tech_.isReady_) { if (t in bo) return e = this.middleware_, i = this.tech_, o = t, e.reduceRight(It(o), i[o]()); if (t in _o) return Bt(this.middleware_, this.tech_, t); var e, i, o; try { return this.tech_[t]() } catch (e) { if (void 0 === this.tech_[t]) throw qt("Video.js: " + t + " method not defined for " + this.techName_ + " playback technology.", e), e; if ("TypeError" === e.name) throw qt("Video.js: " + t + " unavailable on " + this.techName_ + " playback technology element.", e), this.tech_.isReady_ = !1, e; throw qt(e), e } } }, r.play = function() { var t = this,
                        i = this.options_.Promise || e.Promise; return i ? new i(function(e) { t.play_(e) }) : this.play_() }, r.play_ = function(t) { var e = this; if (void 0 === t && (t = ct), this.playOnLoadstart_ && this.off("loadstart", this.playOnLoadstart_), this.isReady_) { if (!this.changingSrc_ && (this.src() || this.currentSrc())) return void t(this.techGet_("play"));
                        this.playOnLoadstart_ = function() { e.playOnLoadstart_ = null, t(e.play()) }, this.one("loadstart", this.playOnLoadstart_) } else { if (this.playWaitingForReady_) return;
                        this.playWaitingForReady_ = !0, this.ready(function() { e.playWaitingForReady_ = !1, t(e.play()) }) } }, r.pause = function() { this.techCall_("pause") }, r.paused = function() { return !1 !== this.techGet_("paused") }, r.played = function() { return this.techGet_("played") || rt(0, 0) }, r.scrubbing = function(t) { if (void 0 === t) return this.scrubbing_;
                    this.scrubbing_ = !!t, t ? this.addClass("vjs-scrubbing") : this.removeClass("vjs-scrubbing") }, r.currentTime = function(t) { return void 0 !== t ? (t < 0 && (t = 0), void this.techCall_("setCurrentTime", t)) : (this.cache_.currentTime = this.techGet_("currentTime") || 0, this.cache_.currentTime) }, r.duration = function(t) { if (void 0 === t) return void 0 !== this.cache_.duration ? this.cache_.duration : NaN;
                    (t = parseFloat(t)) < 0 && (t = 1 / 0), t !== this.cache_.duration && ((this.cache_.duration = t) === 1 / 0 ? (this.addClass("vjs-live"), this.options_.liveui && this.player_.liveTracker && this.addClass("vjs-liveui")) : (this.removeClass("vjs-live"), this.removeClass("vjs-liveui")), isNaN(t) || this.trigger("durationchange")) }, r.remainingTime = function() { return this.duration() - this.currentTime() }, r.remainingTimeDisplay = function() { return Math.floor(this.duration()) - Math.floor(this.currentTime()) }, r.buffered = function() { var t = this.techGet_("buffered"); return t && t.length || (t = rt(0, 0)), t }, r.bufferedPercent = function() { return at(this.buffered(), this.duration()) }, r.bufferedEnd = function() { var t = this.buffered(),
                        e = this.duration(),
                        i = t.end(t.length - 1); return e < i && (i = e), i }, r.volume = function(t) { var e; return void 0 !== t ? (e = Math.max(0, Math.min(1, parseFloat(t))), this.cache_.volume = e, this.techCall_("setVolume", e), void(0 < e && this.lastVolume_(e))) : (e = parseFloat(this.techGet_("volume")), isNaN(e) ? 1 : e) }, r.muted = function(t) { if (void 0 === t) return this.techGet_("muted") || !1;
                    this.techCall_("setMuted", t) }, r.defaultMuted = function(t) { return void 0 !== t ? this.techCall_("setDefaultMuted", t) : this.techGet_("defaultMuted") || !1 }, r.lastVolume_ = function(t) { if (void 0 === t || 0 === t) return this.cache_.lastVolume;
                    this.cache_.lastVolume = t }, r.supportsFullScreen = function() { return this.techGet_("supportsFullScreen") || !1 }, r.isFullscreen = function(t) { if (void 0 === t) return !!this.isFullscreen_;
                    this.isFullscreen_ = !!t }, r.requestFullscreen = function() { var e = Qe;
                    this.isFullscreen(!0), e.requestFullscreen ? (Y(t, e.fullscreenchange, me(this, function i(o) { this.isFullscreen(t[e.fullscreenElement]), !1 === this.isFullscreen() && K(t, e.fullscreenchange, i), this.trigger("fullscreenchange") })), this.el_[e.requestFullscreen]()) : this.tech_.supportsFullScreen() ? this.techCall_("enterFullScreen") : (this.enterFullWindow(), this.trigger("fullscreenchange")) }, r.exitFullscreen = function() { var e = Qe;
                    this.isFullscreen(!1), e.requestFullscreen ? t[e.exitFullscreen]() : this.tech_.supportsFullScreen() ? this.techCall_("exitFullScreen") : (this.exitFullWindow(), this.trigger("fullscreenchange")) }, r.enterFullWindow = function() { this.isFullWindow = !0, this.docOrigOverflow = t.documentElement.style.overflow, Y(t, "keydown", me(this, this.fullWindowOnEscKey)), t.documentElement.style.overflow = "hidden", C(t.body, "vjs-full-window"), this.trigger("enterFullWindow") }, r.fullWindowOnEscKey = function(t) { 27 === t.keyCode && (!0 === this.isFullscreen() ? this.exitFullscreen() : this.exitFullWindow()) }, r.exitFullWindow = function() { this.isFullWindow = !1, K(t, "keydown", this.fullWindowOnEscKey), t.documentElement.style.overflow = this.docOrigOverflow, w(t.body, "vjs-full-window"), this.trigger("exitFullWindow") }, r.canPlayType = function(t) { for (var e, i = 0, o = this.options_.techOrder; i < o.length; i++) { var n = o[i],
                            s = po.getTech(n); if (s || (s = Te.getComponent(n)), s) { if (s.isSupported() && (e = s.canPlayType(t))) return e } else qt.error('The "' + n + '" tech is undefined. Skipped browser support check for that tech.') } return "" }, r.selectSource = function(t) { var e, i = this,
                        o = this.options_.techOrder.map(function(t) { return [t, po.getTech(t)] }).filter(function(t) { var e = t[0],
                                i = t[1]; return i ? i.isSupported() : (qt.error('The "' + e + '" tech is undefined. Skipped browser support check for that tech.'), !1) }),
                        n = function(t, e, i) { var o; return t.some(function(t) { return e.some(function(e) { if (o = i(t, e)) return !0 }) }), o },
                        s = function(t, e) { var o = t[0]; if (t[1].canPlaySource(e, i.options_[o.toLowerCase()])) return { source: e, tech: o } }; return (this.options_.sourceOrder ? n(t, o, (e = s, function(t, i) { return e(i, t) })) : n(o, t, s)) || !1 }, r.src = function(t) { var e = this; if (void 0 === t) return this.cache_.src || ""; var i = function t(e) { if (Array.isArray(e)) { var i = [];
                            e.forEach(function(e) { e = t(e), Array.isArray(e) ? i = i.concat(e) : l(e) && i.push(e) }), e = i } else e = "string" == typeof e && e.trim() ? [Lt({ src: e })] : l(e) && "string" == typeof e.src && e.src && e.src.trim() ? [Lt(e)] : []; return e }(t);
                    i.length ? (this.changingSrc_ = !0, this.cache_.sources = i, this.updateSourceCaches_(i[0]), Et(this, i[0], function(t, o) { var n, s; if (e.middleware_ = o, e.cache_.sources = i, e.updateSourceCaches_(t), e.src_(t)) return 1 < i.length ? e.src(i.slice(1)) : (e.changingSrc_ = !1, e.setTimeout(function() { this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) }) }, 0), void e.triggerReady());
                        n = o, s = e.tech_, n.forEach(function(t) { return t.setTech && t.setTech(s) }) })) : this.setTimeout(function() { this.error({ code: 4, message: this.localize(this.options_.notSupportedMessage) }) }, 0) }, r.src_ = function(t) { var e, i, o = this,
                        n = this.selectSource([t]); return !n || (e = n.tech, i = this.techName_, it(e) !== it(i) ? (this.changingSrc_ = !0, this.loadTech_(n.tech, n.source), this.tech_.ready(function() { o.changingSrc_ = !1 })) : this.ready(function() { this.tech_.constructor.prototype.hasOwnProperty("setSource") ? this.techCall_("setSource", t) : this.techCall_("src", t.src), this.changingSrc_ = !1 }, !0), !1) }, r.load = function() { this.techCall_("load") }, r.reset = function() { this.tech_ && this.tech_.clearTracks("text"), this.loadTech_(this.options_.techOrder[0], null), this.techCall_("reset"), be(this) && this.trigger("playerreset") }, r.currentSources = function() { var t = this.currentSource(),
                        e = []; return 0 !== Object.keys(t).length && e.push(t), this.cache_.sources || e }, r.currentSource = function() { return this.cache_.source || {} }, r.currentSrc = function() { return this.currentSource() && this.currentSource().src || "" }, r.currentType = function() { return this.currentSource() && this.currentSource().type || "" }, r.preload = function(t) { return void 0 !== t ? (this.techCall_("setPreload", t), void(this.options_.preload = t)) : this.techGet_("preload") }, r.autoplay = function(t) { if (void 0 === t) return this.options_.autoplay || !1; var e; "string" == typeof t && /(any|play|muted)/.test(t) ? (this.options_.autoplay = t, this.manualAutoplay_(t), e = !1) : this.options_.autoplay = !!t, e = e || this.options_.autoplay, this.tech_ && this.techCall_("setAutoplay", e) }, r.playsinline = function(t) { return void 0 !== t ? (this.techCall_("setPlaysinline", t), this.options_.playsinline = t, this) : this.techGet_("playsinline") }, r.loop = function(t) { return void 0 !== t ? (this.techCall_("setLoop", t), void(this.options_.loop = t)) : this.techGet_("loop") }, r.poster = function(t) { if (void 0 === t) return this.poster_;
                    t || (t = ""), t !== this.poster_ && (this.poster_ = t, this.techCall_("setPoster", t), this.isPosterFromTech_ = !1, this.trigger("posterchange")) }, r.handleTechPosterChange_ = function() { if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) { var t = this.tech_.poster() || "";
                        t !== this.poster_ && (this.poster_ = t, this.isPosterFromTech_ = !0, this.trigger("posterchange")) } }, r.controls = function(t) { if (void 0 === t) return !!this.controls_;
                    t = !!t, this.controls_ !== t && (this.controls_ = t, this.usingNativeControls() && this.techCall_("setControls", t), this.controls_ ? (this.removeClass("vjs-controls-disabled"), this.addClass("vjs-controls-enabled"), this.trigger("controlsenabled"), this.usingNativeControls() || this.addTechControlsListeners_()) : (this.removeClass("vjs-controls-enabled"), this.addClass("vjs-controls-disabled"), this.trigger("controlsdisabled"), this.usingNativeControls() || this.removeTechControlsListeners_())) }, r.usingNativeControls = function(t) { if (void 0 === t) return !!this.usingNativeControls_;
                    t = !!t, this.usingNativeControls_ !== t && (this.usingNativeControls_ = t, this.usingNativeControls_ ? (this.addClass("vjs-using-native-controls"), this.trigger("usingnativecontrols")) : (this.removeClass("vjs-using-native-controls"), this.trigger("usingcustomcontrols"))) }, r.error = function(t) { return void 0 === t ? this.error_ || null : null === t ? (this.error_ = t, this.removeClass("vjs-error"), void(this.errorDisplay && this.errorDisplay.close())) : (this.error_ = new ht(t), this.addClass("vjs-error"), qt.error("(CODE:" + this.error_.code + " " + ht.errorTypes[this.error_.code] + ")", this.error_.message, this.error_), void this.trigger("error")) }, r.reportUserActivity = function(t) { this.userActivity_ = !0 }, r.userActive = function(t) { if (void 0 === t) return this.userActive_; if ((t = !!t) !== this.userActive_) { if (this.userActive_ = t, this.userActive_) return this.userActivity_ = !0, this.removeClass("vjs-user-inactive"), this.addClass("vjs-user-active"), void this.trigger("useractive");
                        this.tech_ && this.tech_.one("mousemove", function(t) { t.stopPropagation(), t.preventDefault() }), this.userActivity_ = !1, this.removeClass("vjs-user-active"), this.addClass("vjs-user-inactive"), this.trigger("userinactive") } }, r.listenForUserActivity_ = function() { var t, e, i, o, n = me(this, this.reportUserActivity);
                    this.on("mousedown", function() { n(), this.clearInterval(t), t = this.setInterval(n, 250) }), this.on("mousemove", function(t) { t.screenX === e && t.screenY === i || (e = t.screenX, i = t.screenY, n()) }), this.on("mouseup", function(e) { n(), this.clearInterval(t) }), this.on("keydown", n), this.on("keyup", n), this.setInterval(function() { if (this.userActivity_) { this.userActivity_ = !1, this.userActive(!0), this.clearTimeout(o); var t = this.options_.inactivityTimeout;
                            t <= 0 || (o = this.setTimeout(function() { this.userActivity_ || this.userActive(!1) }, t)) } }, 250) }, r.playbackRate = function(t) { if (void 0 === t) return this.tech_ && this.tech_.featuresPlaybackRate ? this.cache_.lastPlaybackRate || this.techGet_("playbackRate") : 1;
                    this.techCall_("setPlaybackRate", t) }, r.defaultPlaybackRate = function(t) { return void 0 !== t ? this.techCall_("setDefaultPlaybackRate", t) : this.tech_ && this.tech_.featuresPlaybackRate ? this.techGet_("defaultPlaybackRate") : 1 }, r.isAudio = function(t) { if (void 0 === t) return !!this.isAudio_;
                    this.isAudio_ = !!t }, r.addTextTrack = function(t, e, i) { if (this.tech_) return this.tech_.addTextTrack(t, e, i) }, r.addRemoteTextTrack = function(t, e) { if (this.tech_) return this.tech_.addRemoteTextTrack(t, e) }, r.removeRemoteTextTrack = function(t) { void 0 === t && (t = {}); var e = t.track; if (e || (e = t), this.tech_) return this.tech_.removeRemoteTextTrack(e) }, r.getVideoPlaybackQuality = function() { return this.techGet_("getVideoPlaybackQuality") }, r.videoWidth = function() { return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0 }, r.videoHeight = function() { return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0 }, r.language = function(t) { if (void 0 === t) return this.language_;
                    this.language_ = String(t).toLowerCase() }, r.languages = function() { return ot(n.prototype.options_.languages, this.languages_) }, r.toJSON = function() { var t = ot(this.options_),
                        e = t.tracks;
                    t.tracks = []; for (var i = 0; i < e.length; i++) { var o = e[i];
                        (o = ot(o)).player = void 0, t.tracks[i] = o } return t }, r.createModal = function(t, e) { var i = this;
                    (e = e || {}).content = t || ""; var o = new li(this, e); return this.addChild(o), o.on("dispose", function() { i.removeChild(o) }), o.open(), o }, r.updateCurrentBreakpoint_ = function() { if (this.responsive())
                        for (var t = this.currentBreakpoint(), e = this.currentWidth(), i = 0; i < $n.length; i++) { var o = $n[i]; if (e <= this.breakpoints_[o]) { if (t === o) return;
                                t && this.removeClass(ts[t]), this.addClass(ts[o]), this.breakpoint_ = o; break } } }, r.removeCurrentBreakpoint_ = function() { var t = this.currentBreakpointClass();
                    this.breakpoint_ = "", t && this.removeClass(t) }, r.breakpoints = function(t) { return void 0 === t || (this.breakpoint_ = "", this.breakpoints_ = h({}, es, t), this.updateCurrentBreakpoint_()), h(this.breakpoints_) }, r.responsive = function(t) { return void 0 === t ? this.responsive_ : (t = Boolean(t)) !== this.responsive_ ? ((this.responsive_ = t) ? (this.on("playerresize", this.updateCurrentBreakpoint_), this.updateCurrentBreakpoint_()) : (this.off("playerresize", this.updateCurrentBreakpoint_), this.removeCurrentBreakpoint_()), t) : void 0 }, r.currentBreakpoint = function() { return this.breakpoint_ }, r.currentBreakpointClass = function() { return ts[this.breakpoint_] || "" }, n.getTagSettings = function(t) { var e = { sources: [], tracks: [] },
                        i = P(t),
                        o = i["data-setup"]; if (S(t, "vjs-fill") && (i.fill = !0), S(t, "vjs-fluid") && (i.fluid = !0), null !== o) { var n = ni(o || "{}"),
                            s = n[0],
                            r = n[1];
                        s && qt.error(s), h(i, r) } if (h(e, i), t.hasChildNodes())
                        for (var a = t.childNodes, l = 0, c = a.length; l < c; l++) { var d = a[l],
                                u = d.nodeName.toLowerCase(); "source" === u ? e.sources.push(P(d)) : "track" === u && e.tracks.push(P(d)) }
                    return e }, r.flexNotSupported_ = function() { var e = t.createElement("i"); return !("flexBasis" in e.style || "webkitFlexBasis" in e.style || "mozFlexBasis" in e.style || "msFlexBasis" in e.style || "msFlexOrder" in e.style) }, n }(Te);
        Qi.names.forEach(function(t) { var e = Qi[t];
            is.prototype[e.getterName] = function() { return this.tech_ ? this.tech_[e.getterName]() : (this[e.privateName] = this[e.privateName] || new e.ListClass, this[e.privateName]) } }), is.players = {}; var os = e.navigator;
        is.prototype.options_ = { techOrder: po.defaultTechOrder_, html5: {}, flash: {}, inactivityTimeout: 2e3, playbackRates: [], liveui: !1, children: ["mediaLoader", "posterImage", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager"], language: os && (os.languages && os.languages[0] || os.userLanguage || os.language) || "en", languages: {}, notSupportedMessage: "No compatible source was found for this media.", breakpoints: {}, responsive: !1 }, ["ended", "seeking", "seekable", "networkState", "readyState"].forEach(function(t) { is.prototype[t] = function() { return this.techGet_(t) } }), Zn.forEach(function(t) { is.prototype["handleTech" + it(t) + "_"] = function() { return this.trigger(t) } }), Te.registerComponent("Player", is); var ns = "plugin",
            ss = "activePlugins_",
            rs = {},
            as = function(t) { return rs.hasOwnProperty(t) },
            hs = function(t) { return as(t) ? rs[t] : void 0 },
            ls = function(t, e) { t[ss] = t[ss] || {}, t[ss][e] = !0 },
            cs = function(t, e, i) { var o = (i ? "before" : "") + "pluginsetup";
                t.trigger(o, e), t.trigger(o + ":" + e.name, e) },
            ds = function(t, e) { return e.prototype.name = t,
                    function() { cs(this, { name: t, plugin: e, instance: null }, !0); for (var i = arguments.length, o = new Array(i), s = 0; s < i; s++) o[s] = arguments[s]; var r = n(e, [this].concat(o)); return this[t] = function() { return r }, cs(this, r.getEventHash()), r } },
            us = function() {
                function t(e) { if (this.constructor === t) throw new Error("Plugin must be sub-classed; not directly instantiated.");
                    this.player = e, tt(this), delete this.trigger, et(this, this.constructor.defaultState), ls(e, this.name), this.dispose = me(this, this.dispose), e.on("dispose", this.dispose) } var e = t.prototype; return e.version = function() { return this.constructor.VERSION }, e.getEventHash = function(t) { return void 0 === t && (t = {}), t.name = this.name, t.plugin = this.constructor, t.instance = this, t }, e.trigger = function(t, e) { return void 0 === e && (e = {}), Z(this.eventBusEl_, t, this.getEventHash(e)) }, e.handleStateChanged = function(t) {}, e.dispose = function() { var t = this.name,
                        e = this.player;
                    this.trigger("dispose"), this.off(), e.off("dispose", this.dispose), e[ss][t] = !1, this.player = this.state = null, e[t] = ds(t, rs[t]) }, t.isBasic = function(e) { var i = "string" == typeof e ? hs(e) : e; return "function" == typeof i && !t.prototype.isPrototypeOf(i.prototype) }, t.registerPlugin = function(e, i) { if ("string" != typeof e) throw new Error('Illegal plugin name, "' + e + '", must be a string, was ' + typeof e + "."); if (as(e)) qt.warn('A plugin named "' + e + '" already exists. You may want to avoid re-registering plugins!');
                    else if (is.prototype.hasOwnProperty(e)) throw new Error('Illegal plugin name, "' + e + '", cannot share a name with an existing player method!'); if ("function" != typeof i) throw new Error('Illegal plugin for "' + e + '", must be a function, was ' + typeof i + "."); var o, n, s; return rs[e] = i, e !== ns && (t.isBasic(i) ? is.prototype[e] = (o = e, n = i, s = function() { cs(this, { name: o, plugin: n, instance: null }, !0); var t = n.apply(this, arguments); return ls(this, o), cs(this, { name: o, plugin: n, instance: t }), t }, Object.keys(n).forEach(function(t) { s[t] = n[t] }), s) : is.prototype[e] = ds(e, i)), i }, t.deregisterPlugin = function(t) { if (t === ns) throw new Error("Cannot de-register base plugin.");
                    as(t) && (delete rs[t], delete is.prototype[t]) }, t.getPlugins = function(t) { var e; return void 0 === t && (t = Object.keys(rs)), t.forEach(function(t) { var i = hs(t);
                        i && ((e = e || {})[t] = i) }), e }, t.getPluginVersion = function(t) { var e = hs(t); return e && e.VERSION || "" }, t }();
        us.getPlugin = hs, us.BASE_PLUGIN_NAME = ns, us.registerPlugin(ns, us), is.prototype.usingPlugin = function(t) { return !!this[ss] && !0 === this[ss][t] }, is.prototype.hasPlugin = function(t) { return !!as(t) }; var ps = function(t) { return 0 === t.indexOf("#") ? t.slice(1) : t }; if (Nt.hooks_ = {}, Nt.hooks = function(t, e) { return Nt.hooks_[t] = Nt.hooks_[t] || [], e && (Nt.hooks_[t] = Nt.hooks_[t].concat(e)), Nt.hooks_[t] }, Nt.hook = function(t, e) { Nt.hooks(t, e) }, Nt.hookOnce = function(t, e) { Nt.hooks(t, [].concat(e).map(function(e) { return function i() { return Nt.removeHook(t, i), e.apply(void 0, arguments) } })) }, Nt.removeHook = function(t, e) { var i = Nt.hooks(t).indexOf(e); return !(i <= -1 || (Nt.hooks_[t] = Nt.hooks_[t].slice(), Nt.hooks_[t].splice(i, 1), 0)) }, !0 !== e.VIDEOJS_NO_DYNAMIC_STYLE && f()) { var ms = $t(".vjs-styles-defaults"); if (!ms) { ms = ue("vjs-styles-defaults"); var fs = $t("head");
                fs && fs.insertBefore(ms, fs.firstChild), pe(ms, "\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid {\n        padding-top: 56.25%\n      }\n    ") } } $(1, Nt), Nt.VERSION = Ht, Nt.options = is.prototype.options_, Nt.getPlayers = function() { return is.players }, Nt.getPlayer = function(t) { var e, i = is.players; if ("string" == typeof t) { var o = ps(t),
                    n = i[o]; if (n) return n;
                e = $t("#" + o) } else e = t; if (y(e)) { var s = e,
                    r = s.player,
                    a = s.playerId; if (r || i[a]) return r || i[a] } }, Nt.getAllPlayers = function() { return Object.keys(is.players).map(function(t) { return is.players[t] }).filter(Boolean) }, Nt.players = is.players, Nt.getComponent = Te.getComponent, Nt.registerComponent = function(t, e) { po.isTech(e) && qt.warn("The " + t + " tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)"), Te.registerComponent.call(Te, t, e) }, Nt.getTech = po.getTech, Nt.registerTech = po.registerTech, Nt.use = function(t, e) { mo[t] = mo[t] || [], mo[t].push(e) }, Object.defineProperty(Nt, "middleware", { value: {}, writeable: !1, enumerable: !0 }), Object.defineProperty(Nt.middleware, "TERMINATOR", { value: yo, writeable: !1, enumerable: !0 }), Nt.browser = Ze, Nt.TOUCH_ENABLED = Ke, Nt.extend = function(t, e) { void 0 === e && (e = {}); var i = function() { t.apply(this, arguments) },
                o = {}; for (var n in "object" == typeof e ? (e.constructor !== Object.prototype.constructor && (i = e.constructor), o = e) : "function" == typeof e && (i = e),
                    function(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                        t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (t.super_ = e) }(i, t), o) o.hasOwnProperty(n) && (i.prototype[n] = o[n]); return i }, Nt.mergeOptions = ot, Nt.bind = me, Nt.registerPlugin = us.registerPlugin, Nt.deregisterPlugin = us.deregisterPlugin, Nt.plugin = function(t, e) { return qt.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead"), us.registerPlugin(t, e) }, Nt.getPlugins = us.getPlugins, Nt.getPlugin = us.getPlugin, Nt.getPluginVersion = us.getPluginVersion, Nt.addLanguage = function(t, e) { var i; return t = ("" + t).toLowerCase(), Nt.options.languages = ot(Nt.options.languages, ((i = {})[t] = e, i)), Nt.options.languages[t] }, Nt.log = qt, Nt.createLogger = Yt, Nt.createTimeRange = Nt.createTimeRanges = rt, Nt.formatTime = Ft, Nt.setFormatTime = function(t) { Lo = t }, Nt.resetFormatTime = function() { Lo = Do }, Nt.parseUrl = wi, Nt.isCrossOrigin = Pi, Nt.EventTarget = ye, Nt.on = Y, Nt.one = Q, Nt.off = K, Nt.trigger = Z, Nt.xhr = Xi, Nt.TextTrack = zi, Nt.AudioTrack = Ji, Nt.VideoTrack = qi, ["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach(function(t) { Nt[t] = function() { return qt.warn("videojs." + t + "() is deprecated; use videojs.dom." + t + "() instead"), ee[t].apply(null, arguments) } }), Nt.computedStyle = d, Nt.dom = ee, Nt.url = ki; var ys = dt(function(t, e) { var i, o, n, s, r;
                i = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/\?#]*\/)*.*?)??(;.*?)?(\?.*?)?(#.*?)?$/, o = /^([^\/?#]*)(.*)$/, n = /(?:\/|^)\.(?=\/)/g, s = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g, r = { buildAbsoluteURL: function(t, e, i) { if (i = i || {}, t = t.trim(), !(e = e.trim())) { if (!i.alwaysNormalize) return t; var n = r.parseURL(t); if (!n) throw new Error("Error trying to parse base URL."); return n.path = r.normalizePath(n.path), r.buildURLFromParts(n) } var s = r.parseURL(e); if (!s) throw new Error("Error trying to parse relative URL."); if (s.scheme) return i.alwaysNormalize ? (s.path = r.normalizePath(s.path), r.buildURLFromParts(s)) : e; var a = r.parseURL(t); if (!a) throw new Error("Error trying to parse base URL."); if (!a.netLoc && a.path && "/" !== a.path[0]) { var h = o.exec(a.path);
                            a.netLoc = h[1], a.path = h[2] } a.netLoc && !a.path && (a.path = "/"); var l = { scheme: a.scheme, netLoc: s.netLoc, path: null, params: s.params, query: s.query, fragment: s.fragment }; if (!s.netLoc && (l.netLoc = a.netLoc, "/" !== s.path[0]))
                            if (s.path) { var c = a.path,
                                    d = c.substring(0, c.lastIndexOf("/") + 1) + s.path;
                                l.path = r.normalizePath(d) } else l.path = a.path, s.params || (l.params = a.params, s.query || (l.query = a.query)); return null === l.path && (l.path = i.alwaysNormalize ? r.normalizePath(s.path) : s.path), r.buildURLFromParts(l) }, parseURL: function(t) { var e = i.exec(t); return e ? { scheme: e[1] || "", netLoc: e[2] || "", path: e[3] || "", params: e[4] || "", query: e[5] || "", fragment: e[6] || "" } : null }, normalizePath: function(t) { for (t = t.split("").reverse().join("").replace(n, ""); t.length !== (t = t.replace(s, "")).length;); return t.split("").reverse().join("") }, buildURLFromParts: function(t) { return t.scheme + t.netLoc + t.path + t.params + t.query + t.fragment } }, t.exports = r }),
            bs = function(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") },
            gs = Object.assign || function(t) { for (var e = 1; e < arguments.length; e++) { var i = arguments[e]; for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]) } return t },
            _s = function(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) },
            vs = function(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e },
            xs = function() {
                function t() { bs(this, t), this.listeners = {} } return t.prototype.on = function(t, e) { this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push(e) }, t.prototype.off = function(t, e) { if (!this.listeners[t]) return !1; var i = this.listeners[t].indexOf(e); return this.listeners[t].splice(i, 1), -1 < i }, t.prototype.trigger = function(t) { var e = this.listeners[t],
                        i = void 0,
                        o = void 0,
                        n = void 0; if (e)
                        if (2 === arguments.length)
                            for (o = e.length, i = 0; i < o; ++i) e[i].call(this, arguments[1]);
                        else
                            for (n = Array.prototype.slice.call(arguments, 1), o = e.length, i = 0; i < o; ++i) e[i].apply(this, n) }, t.prototype.dispose = function() { this.listeners = {} }, t.prototype.pipe = function(t) { this.on("data", function(e) { t.push(e) }) }, t }(),
            Ss = function(t) {
                function e() { bs(this, e); var i = vs(this, t.call(this)); return i.buffer = "", i } return _s(e, t), e.prototype.push = function(t) { var e = void 0; for (this.buffer += t, e = this.buffer.indexOf("\n"); - 1 < e; e = this.buffer.indexOf("\n")) this.trigger("data", this.buffer.substring(0, e)), this.buffer = this.buffer.substring(e + 1) }, e }(xs),
            Cs = function(t) { for (var e = t.split(new RegExp('(?:^|,)((?:[^=]*)=(?:"[^"]*"|[^,]*))')), i = {}, o = e.length, n = void 0; o--;) "" !== e[o] && ((n = /([^=]*)=(.*)/.exec(e[o]).slice(1))[0] = n[0].replace(/^\s+|\s+$/g, ""), n[1] = n[1].replace(/^\s+|\s+$/g, ""), n[1] = n[1].replace(/^['"](.*)['"]$/g, "$1"), i[n[0]] = n[1]); return i },
            ws = function(t) {
                function e() { bs(this, e); var i = vs(this, t.call(this)); return i.customParsers = [], i } return _s(e, t), e.prototype.push = function(t) { var e = void 0,
                        i = void 0; if (0 !== (t = t.replace(/^[\u0000\s]+|[\u0000\s]+$/g, "")).length)
                        if ("#" === t[0]) { for (var o = 0; o < this.customParsers.length; o++)
                                if (this.customParsers[o].call(this, t)) return; if (0 === t.indexOf("#EXT"))
                                if (t = t.replace("\r", ""), e = /^#EXTM3U/.exec(t)) this.trigger("data", { type: "tag", tagType: "m3u" });
                                else { if (e = /^#EXTINF:?([0-9\.]*)?,?(.*)?$/.exec(t)) return i = { type: "tag", tagType: "inf" }, e[1] && (i.duration = parseFloat(e[1])), e[2] && (i.title = e[2]), void this.trigger("data", i); if (e = /^#EXT-X-TARGETDURATION:?([0-9.]*)?/.exec(t)) return i = { type: "tag", tagType: "targetduration" }, e[1] && (i.duration = parseInt(e[1], 10)), void this.trigger("data", i); if (e = /^#ZEN-TOTAL-DURATION:?([0-9.]*)?/.exec(t)) return i = { type: "tag", tagType: "totalduration" }, e[1] && (i.duration = parseInt(e[1], 10)), void this.trigger("data", i); if (e = /^#EXT-X-VERSION:?([0-9.]*)?/.exec(t)) return i = { type: "tag", tagType: "version" }, e[1] && (i.version = parseInt(e[1], 10)), void this.trigger("data", i); if (e = /^#EXT-X-MEDIA-SEQUENCE:?(\-?[0-9.]*)?/.exec(t)) return i = { type: "tag", tagType: "media-sequence" }, e[1] && (i.number = parseInt(e[1], 10)), void this.trigger("data", i); if (e = /^#EXT-X-DISCONTINUITY-SEQUENCE:?(\-?[0-9.]*)?/.exec(t)) return i = { type: "tag", tagType: "discontinuity-sequence" }, e[1] && (i.number = parseInt(e[1], 10)), void this.trigger("data", i); if (e = /^#EXT-X-PLAYLIST-TYPE:?(.*)?$/.exec(t)) return i = { type: "tag", tagType: "playlist-type" }, e[1] && (i.playlistType = e[1]), void this.trigger("data", i); if (e = /^#EXT-X-BYTERANGE:?([0-9.]*)?@?([0-9.]*)?/.exec(t)) return i = { type: "tag", tagType: "byterange" }, e[1] && (i.length = parseInt(e[1], 10)), e[2] && (i.offset = parseInt(e[2], 10)), void this.trigger("data", i); if (e = /^#EXT-X-ALLOW-CACHE:?(YES|NO)?/.exec(t)) return i = { type: "tag", tagType: "allow-cache" }, e[1] && (i.allowed = !/NO/.test(e[1])), void this.trigger("data", i); if (e = /^#EXT-X-MAP:?(.*)$/.exec(t)) { if (i = { type: "tag", tagType: "map" }, e[1]) { var n = Cs(e[1]); if (n.URI && (i.uri = n.URI), n.BYTERANGE) { var s = n.BYTERANGE.split("@"),
                                                    r = s[0],
                                                    a = s[1];
                                                i.byterange = {}, r && (i.byterange.length = parseInt(r, 10)), a && (i.byterange.offset = parseInt(a, 10)) } } this.trigger("data", i) } else if (e = /^#EXT-X-STREAM-INF:?(.*)$/.exec(t)) { if (i = { type: "tag", tagType: "stream-inf" }, e[1]) { if (i.attributes = Cs(e[1]), i.attributes.RESOLUTION) { var h = i.attributes.RESOLUTION.split("x"),
                                                    l = {};
                                                h[0] && (l.width = parseInt(h[0], 10)), h[1] && (l.height = parseInt(h[1], 10)), i.attributes.RESOLUTION = l } i.attributes.BANDWIDTH && (i.attributes.BANDWIDTH = parseInt(i.attributes.BANDWIDTH, 10)), i.attributes["PROGRAM-ID"] && (i.attributes["PROGRAM-ID"] = parseInt(i.attributes["PROGRAM-ID"], 10)) } this.trigger("data", i) } else { if (e = /^#EXT-X-MEDIA:?(.*)$/.exec(t)) return i = { type: "tag", tagType: "media" }, e[1] && (i.attributes = Cs(e[1])), void this.trigger("data", i); if (e = /^#EXT-X-ENDLIST/.exec(t)) this.trigger("data", { type: "tag", tagType: "endlist" });
                                        else if (e = /^#EXT-X-DISCONTINUITY/.exec(t)) this.trigger("data", { type: "tag", tagType: "discontinuity" });
                                        else { if (e = /^#EXT-X-PROGRAM-DATE-TIME:?(.*)$/.exec(t)) return i = { type: "tag", tagType: "program-date-time" }, e[1] && (i.dateTimeString = e[1], i.dateTimeObject = new Date(e[1])), void this.trigger("data", i); if (e = /^#EXT-X-KEY:?(.*)$/.exec(t)) return i = { type: "tag", tagType: "key" }, e[1] && (i.attributes = Cs(e[1]), i.attributes.IV && ("0x" === i.attributes.IV.substring(0, 2).toLowerCase() && (i.attributes.IV = i.attributes.IV.substring(2)), i.attributes.IV = i.attributes.IV.match(/.{8}/g), i.attributes.IV[0] = parseInt(i.attributes.IV[0], 16), i.attributes.IV[1] = parseInt(i.attributes.IV[1], 16), i.attributes.IV[2] = parseInt(i.attributes.IV[2], 16), i.attributes.IV[3] = parseInt(i.attributes.IV[3], 16), i.attributes.IV = new Uint32Array(i.attributes.IV))), void this.trigger("data", i); if (e = /^#EXT-X-START:?(.*)$/.exec(t)) return i = { type: "tag", tagType: "start" }, e[1] && (i.attributes = Cs(e[1]), i.attributes["TIME-OFFSET"] = parseFloat(i.attributes["TIME-OFFSET"]), i.attributes.PRECISE = /YES/.test(i.attributes.PRECISE)), void this.trigger("data", i); if (e = /^#EXT-X-CUE-OUT-CONT:?(.*)?$/.exec(t)) return i = { type: "tag", tagType: "cue-out-cont" }, e[1] ? i.data = e[1] : i.data = "", void this.trigger("data", i); if (e = /^#EXT-X-CUE-OUT:?(.*)?$/.exec(t)) return i = { type: "tag", tagType: "cue-out" }, e[1] ? i.data = e[1] : i.data = "", void this.trigger("data", i); if (e = /^#EXT-X-CUE-IN:?(.*)?$/.exec(t)) return i = { type: "tag", tagType: "cue-in" }, e[1] ? i.data = e[1] : i.data = "", void this.trigger("data", i);
                                            this.trigger("data", { type: "tag", data: t.slice(4) }) } } } else this.trigger("data", { type: "comment", text: t.slice(1) }) } else this.trigger("data", { type: "uri", uri: t }) }, e.prototype.addParser = function(t) { var e = this,
                        i = t.expression,
                        o = t.customType,
                        n = t.dataParser,
                        s = t.segment; "function" != typeof n && (n = function(t) { return t }), this.customParsers.push(function(t) { if (i.exec(t)) return e.trigger("data", { type: "custom", data: n(t), customType: o, segment: s }), !0 }) }, e }(xs),
            As = function(t) {
                function e() { bs(this, e); var i = vs(this, t.call(this));
                    i.lineStream = new Ss, i.parseStream = new ws, i.lineStream.pipe(i.parseStream); var o = i,
                        n = [],
                        s = {},
                        r = void 0,
                        a = void 0,
                        h = { AUDIO: {}, VIDEO: {}, "CLOSED-CAPTIONS": {}, SUBTITLES: {} },
                        l = 0; return i.manifest = { allowCache: !0, discontinuityStarts: [], segments: [] }, i.parseStream.on("data", function(t) { var e = void 0,
                            i = void 0;
                        ({ tag: function() {
                                (({ "allow-cache": function() { this.manifest.allowCache = t.allowed, "allowed" in t || (this.trigger("info", { message: "defaulting allowCache to YES" }), this.manifest.allowCache = !0) }, byterange: function() { var e = {}; "length" in t && ((s.byterange = e).length = t.length, "offset" in t || (this.trigger("info", { message: "defaulting offset to zero" }), t.offset = 0)), "offset" in t && ((s.byterange = e).offset = t.offset) }, endlist: function() { this.manifest.endList = !0 }, inf: function() { "mediaSequence" in this.manifest || (this.manifest.mediaSequence = 0, this.trigger("info", { message: "defaulting media sequence to zero" })), "discontinuitySequence" in this.manifest || (this.manifest.discontinuitySequence = 0, this.trigger("info", { message: "defaulting discontinuity sequence to zero" })), 0 < t.duration && (s.duration = t.duration), 0 === t.duration && (s.duration = .01, this.trigger("info", { message: "updating zero segment duration to a small value" })), this.manifest.segments = n }, key: function() { t.attributes ? "NONE" !== t.attributes.METHOD ? t.attributes.URI ? (t.attributes.METHOD || this.trigger("warn", { message: "defaulting key method to AES-128" }), a = { method: t.attributes.METHOD || "AES-128", uri: t.attributes.URI }, void 0 !== t.attributes.IV && (a.iv = t.attributes.IV)) : this.trigger("warn", { message: "ignoring key declaration without URI" }) : a = null : this.trigger("warn", { message: "ignoring key declaration without attribute list" }) }, "media-sequence": function() { isFinite(t.number) ? this.manifest.mediaSequence = t.number : this.trigger("warn", { message: "ignoring invalid media sequence: " + t.number }) }, "discontinuity-sequence": function() { isFinite(t.number) ? (this.manifest.discontinuitySequence = t.number, l = t.number) : this.trigger("warn", { message: "ignoring invalid discontinuity sequence: " + t.number }) }, "playlist-type": function() { /VOD|EVENT/.test(t.playlistType) ? this.manifest.playlistType = t.playlistType : this.trigger("warn", { message: "ignoring unknown playlist type: " + t.playlist }) }, map: function() { r = {}, t.uri && (r.uri = t.uri), t.byterange && (r.byterange = t.byterange) }, "stream-inf": function() { this.manifest.playlists = n, this.manifest.mediaGroups = this.manifest.mediaGroups || h, t.attributes ? (s.attributes || (s.attributes = {}), gs(s.attributes, t.attributes)) : this.trigger("warn", { message: "ignoring empty stream-inf attributes" }) }, media: function() { if (this.manifest.mediaGroups = this.manifest.mediaGroups || h, t.attributes && t.attributes.TYPE && t.attributes["GROUP-ID"] && t.attributes.NAME) { var o = this.manifest.mediaGroups[t.attributes.TYPE];
                                            o[t.attributes["GROUP-ID"]] = o[t.attributes["GROUP-ID"]] || {}, e = o[t.attributes["GROUP-ID"]], (i = { default: /yes/i.test(t.attributes.DEFAULT) }).default ? i.autoselect = !0 : i.autoselect = /yes/i.test(t.attributes.AUTOSELECT), t.attributes.LANGUAGE && (i.language = t.attributes.LANGUAGE), t.attributes.URI && (i.uri = t.attributes.URI), t.attributes["INSTREAM-ID"] && (i.instreamId = t.attributes["INSTREAM-ID"]), t.attributes.CHARACTERISTICS && (i.characteristics = t.attributes.CHARACTERISTICS), t.attributes.FORCED && (i.forced = /yes/i.test(t.attributes.FORCED)), e[t.attributes.NAME] = i } else this.trigger("warn", { message: "ignoring incomplete or missing media group" }) }, discontinuity: function() { l += 1, s.discontinuity = !0, this.manifest.discontinuityStarts.push(n.length) }, "program-date-time": function() { void 0 === this.manifest.dateTimeString && (this.manifest.dateTimeString = t.dateTimeString, this.manifest.dateTimeObject = t.dateTimeObject), s.dateTimeString = t.dateTimeString, s.dateTimeObject = t.dateTimeObject }, targetduration: function() {!isFinite(t.duration) || t.duration < 0 ? this.trigger("warn", { message: "ignoring invalid target duration: " + t.duration }) : this.manifest.targetDuration = t.duration }, totalduration: function() {!isFinite(t.duration) || t.duration < 0 ? this.trigger("warn", { message: "ignoring invalid total duration: " + t.duration }) : this.manifest.totalDuration = t.duration }, start: function() { t.attributes && !isNaN(t.attributes["TIME-OFFSET"]) ? this.manifest.start = { timeOffset: t.attributes["TIME-OFFSET"], precise: t.attributes.PRECISE } : this.trigger("warn", { message: "ignoring start declaration without appropriate attribute list" }) }, "cue-out": function() { s.cueOut = t.data }, "cue-out-cont": function() { s.cueOutCont = t.data }, "cue-in": function() { s.cueIn = t.data } })[t.tagType] || function() {}).call(o) }, uri: function() { s.uri = t.uri, n.push(s), !this.manifest.targetDuration || "duration" in s || (this.trigger("warn", { message: "defaulting segment duration to the target duration" }), s.duration = this.manifest.targetDuration), a && (s.key = a), s.timeline = l, r && (s.map = r), s = {} }, comment: function() {}, custom: function() { t.segment ? (s.custom = s.custom || {}, s.custom[t.customType] = t.data) : (this.manifest.custom = this.manifest.custom || {}, this.manifest.custom[t.customType] = t.data) } })[t.type].call(o) }), i } return _s(e, t), e.prototype.push = function(t) { this.lineStream.push(t) }, e.prototype.end = function() { this.lineStream.push("\n") }, e.prototype.addParser = function(t) { this.parseStream.addParser(t) }, e }(xs),
            Ts = function(t) { return !!t && "object" == typeof t },
            Ps = function t() { for (var e = arguments.length, i = new Array(e), o = 0; o < e; o++) i[o] = arguments[o]; return i.reduce(function(e, i) { return Object.keys(i).forEach(function(o) { Array.isArray(e[o]) && Array.isArray(i[o]) ? e[o] = e[o].concat(i[o]) : Ts(e[o]) && Ts(i[o]) ? e[o] = t(e[o], i[o]) : e[o] = i[o] }), e }, {}) },
            ks = function(t) { return t.reduce(function(t, e) { return t.concat(e) }, []) },
            Ms = function(t) { if (!t.length) return []; for (var e = [], i = 0; i < t.length; i++) e.push(t[i]); return e },
            Es = function(t) { var e; return (e = t.reduce(function(t, e) { var i, o = e.attributes.id + (e.attributes.lang || ""); return t[o] ? (e.segments[0].discontinuity = !0, (i = t[o].segments).push.apply(i, e.segments), e.attributes.contentProtection && (t[o].attributes.contentProtection = e.attributes.contentProtection)) : t[o] = e, t }, {}), Object.keys(e).map(function(t) { return e[t] })).map(function(t) { var e, i; return t.discontinuityStarts = (e = t.segments, i = "discontinuity", e.reduce(function(t, e, o) { return e[i] && t.push(o), t }, [])), t }) },
            Bs = function(t) { var e, i = t.attributes,
                    o = t.segments,
                    n = { attributes: (e = { NAME: i.id, AUDIO: "audio", SUBTITLES: "subs", RESOLUTION: { width: i.width, height: i.height }, CODECS: i.codecs, BANDWIDTH: i.bandwidth }, e["PROGRAM-ID"] = 1, e), uri: "", endList: "static" === (i.type || "static"), timeline: i.periodIndex, resolvedUri: "", targetDuration: i.duration, segments: o, mediaSequence: o.length ? o[0].number : 1 }; return i.contentProtection && (n.contentProtection = i.contentProtection), n }; "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self && self; var Is, Ds, Ls, Os, Rs, Fs, Vs = (function(t, e) { var i, o, n, s, r;
                i = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/\?#]*\/)*.*?)??(;.*?)?(\?.*?)?(#.*?)?$/, o = /^([^\/?#]*)(.*)$/, n = /(?:\/|^)\.(?=\/)/g, s = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g, r = { buildAbsoluteURL: function(t, e, i) { if (i = i || {}, t = t.trim(), !(e = e.trim())) { if (!i.alwaysNormalize) return t; var n = r.parseURL(t); if (!n) throw new Error("Error trying to parse base URL."); return n.path = r.normalizePath(n.path), r.buildURLFromParts(n) } var s = r.parseURL(e); if (!s) throw new Error("Error trying to parse relative URL."); if (s.scheme) return i.alwaysNormalize ? (s.path = r.normalizePath(s.path), r.buildURLFromParts(s)) : e; var a = r.parseURL(t); if (!a) throw new Error("Error trying to parse base URL."); if (!a.netLoc && a.path && "/" !== a.path[0]) { var h = o.exec(a.path);
                            a.netLoc = h[1], a.path = h[2] } a.netLoc && !a.path && (a.path = "/"); var l = { scheme: a.scheme, netLoc: s.netLoc, path: null, params: s.params, query: s.query, fragment: s.fragment }; if (!s.netLoc && (l.netLoc = a.netLoc, "/" !== s.path[0]))
                            if (s.path) { var c = a.path,
                                    d = c.substring(0, c.lastIndexOf("/") + 1) + s.path;
                                l.path = r.normalizePath(d) } else l.path = a.path, s.params || (l.params = a.params, s.query || (l.query = a.query)); return null === l.path && (l.path = i.alwaysNormalize ? r.normalizePath(s.path) : s.path), r.buildURLFromParts(l) }, parseURL: function(t) { var e = i.exec(t); return e ? { scheme: e[1] || "", netLoc: e[2] || "", path: e[3] || "", params: e[4] || "", query: e[5] || "", fragment: e[6] || "" } : null }, normalizePath: function(t) { for (t = t.split("").reverse().join("").replace(n, ""); t.length !== (t = t.replace(s, "")).length;); return t.split("").reverse().join("") }, buildURLFromParts: function(t) { return t.scheme + t.netLoc + t.path + t.params + t.query + t.fragment } }, t.exports = r }(Is = { exports: {} }), Is.exports),
            Gs = function(t, i) { return /^[a-z]+:/i.test(i) ? i : (/\/\//i.test(t) || (t = Vs.buildAbsoluteURL(e.location.href, t)), Vs.buildAbsoluteURL(t, i)) },
            Us = function(t) { var e = t.baseUrl,
                    i = void 0 === e ? "" : e,
                    o = t.source,
                    n = void 0 === o ? "" : o,
                    s = t.range,
                    r = void 0 === s ? "" : s,
                    a = { uri: n, resolvedUri: Gs(i || "", n) }; if (r) { var h = r.split("-"),
                        l = parseInt(h[0], 10),
                        c = parseInt(h[1], 10);
                    a.byterange = { length: c - l, offset: l } } return a },
            Ns = function(t, e) { for (var i, o, n, s, r, a, h, l, c, d, u, p, m = t.type, f = void 0 === m ? "static" : m, y = t.minimumUpdatePeriod, b = void 0 === y ? 0 : y, g = t.media, _ = void 0 === g ? "" : g, v = t.sourceDuration, x = t.timescale, S = void 0 === x ? 1 : x, C = t.startNumber, w = void 0 === C ? 1 : C, A = t.periodIndex, T = [], P = -1, k = 0; k < e.length; k++) { var M = e[k],
                        E = M.d,
                        B = M.r || 0,
                        I = M.t || 0;
                    P < 0 && (P = I), I && P < I && (P = I); var D = void 0; if (B < 0) { var L = k + 1;
                        D = L === e.length ? "dynamic" === f && 0 < b && 0 < _.indexOf("$Number$") ? (o = P, n = E, s = (i = t).NOW, r = i.clientOffset, a = i.availabilityStartTime, h = i.timescale, l = void 0 === h ? 1 : h, c = i.start, d = void 0 === c ? 0 : c, u = i.minimumUpdatePeriod, p = (s + r) / 1e3 + (void 0 === u ? 0 : u) - (a + d), Math.ceil((p * l - o) / n)) : (v * S - P) / E : (e[L].t - P) / E } else D = B + 1; for (var O = w + T.length + D, R = w + T.length; R < O;) T.push({ number: R, duration: E / S, time: P, timeline: A }), P += E, R++ } return T },
            js = { static: function(t) { var e = t.duration,
                        i = t.timescale,
                        o = void 0 === i ? 1 : i,
                        n = t.sourceDuration; return { start: 0, end: Math.ceil(n / (e / o)) } }, dynamic: function(t) { var e = t.NOW,
                        i = t.clientOffset,
                        o = t.availabilityStartTime,
                        n = t.timescale,
                        s = void 0 === n ? 1 : n,
                        r = t.duration,
                        a = t.start,
                        h = void 0 === a ? 0 : a,
                        l = t.minimumUpdatePeriod,
                        c = void 0 === l ? 0 : l,
                        d = t.timeShiftBufferDepth,
                        u = void 0 === d ? 1 / 0 : d,
                        p = (e + i) / 1e3,
                        m = o + h,
                        f = p + c - m,
                        y = Math.ceil(f * s / r),
                        b = Math.floor((p - m - u) * s / r),
                        g = Math.floor((p - m) * s / r); return { start: Math.max(0, b), end: Math.min(y, g) } } },
            Ws = function(t) { var e, i = t.type,
                    o = void 0 === i ? "static" : i,
                    n = t.duration,
                    s = t.timescale,
                    r = void 0 === s ? 1 : s,
                    a = t.sourceDuration,
                    h = js[o](t),
                    l = function(t, e) { for (var i = [], o = h.start; o < e; o++) i.push(o); return i }(0, h.end).map((e = t, function(t, i) { var o = e.duration,
                            n = e.timescale,
                            s = void 0 === n ? 1 : n,
                            r = e.periodIndex,
                            a = e.startNumber; return { number: (void 0 === a ? 1 : a) + t, duration: o / s, timeline: r, time: i * o } })); if ("static" === o) { var c = l.length - 1;
                    l[c].duration = a - n / r * c } return l },
            Xs = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g,
            Hs = function(t, e) { return t.replace(Xs, (i = e, function(t, e, o, n) { if ("$$" === t) return "$"; if (void 0 === i[e]) return t; var s = "" + i[e]; return "RepresentationID" === e ? s : (n = o ? parseInt(n, 10) : 1) <= s.length ? s : "" + new Array(n - s.length + 1).join("0") + s })); var i },
            zs = function(t, e) { var i, o, n = { RepresentationID: t.id, Bandwidth: t.bandwidth || 0 },
                    s = t.initialization,
                    r = void 0 === s ? { sourceURL: "", range: "" } : s,
                    a = Us({ baseUrl: t.baseUrl, source: Hs(r.sourceURL, n), range: r.range }); return (o = e, (i = t).duration || o ? i.duration ? Ws(i) : Ns(i, o) : [{ number: i.startNumber || 1, duration: i.sourceDuration, time: 0, timeline: i.periodIndex }]).map(function(e) { n.Number = e.number, n.Time = e.time; var i = Hs(t.media || "", n); return { uri: i, timeline: e.timeline, duration: e.duration, resolvedUri: Gs(t.baseUrl || "", i), map: a, number: e.number } }) },
            Js = function(t, e) { var i = t.duration,
                    o = t.segmentUrls,
                    n = void 0 === o ? [] : o; if (!i && !e || i && e) throw new Error("SEGMENT_TIME_UNSPECIFIED"); var s, r = n.map(function(e) { return o = e, n = (i = t).baseUrl, s = i.initialization, a = Us({ baseUrl: n, source: (r = void 0 === s ? {} : s).sourceURL, range: r.range }), (h = Us({ baseUrl: n, source: o.media, range: o.mediaRange })).map = a, h; var i, o, n, s, r, a, h }); return i && (s = Ws(t)), e && (s = Ns(t, e)), s.map(function(t, e) { if (r[e]) { var i = r[e]; return i.timeline = t.timeline, i.duration = t.duration, i.number = t.number, i } }).filter(function(t) { return t }) },
            qs = function(t) { var e = t.baseUrl,
                    i = t.initialization,
                    o = void 0 === i ? {} : i,
                    n = t.sourceDuration,
                    s = t.timescale,
                    r = void 0 === s ? 1 : s,
                    a = t.indexRange,
                    h = void 0 === a ? "" : a,
                    l = t.duration; if (!e) throw new Error("NO_BASE_URL"); var c = Us({ baseUrl: e, source: o.sourceURL, range: o.range }),
                    d = Us({ baseUrl: e, source: e, range: h }); if (d.map = c, l) { var u = Ws(t);
                    u.length && (d.duration = u[0].duration, d.timeline = u[0].timeline) } else n && (d.duration = n / r, d.timeline = 0); return d.number = 0, [d] },
            Ys = function(t) { var e, i, o = t.attributes,
                    n = t.segmentInfo; if (n.template ? (i = zs, e = Ps(o, n.template)) : n.base ? (i = qs, e = Ps(o, n.base)) : n.list && (i = Js, e = Ps(o, n.list)), !i) return { attributes: o }; var s = i(e, n.timeline); if (e.duration) { var r = e,
                        a = r.duration,
                        h = r.timescale,
                        l = void 0 === h ? 1 : h;
                    e.duration = a / l } else s.length ? e.duration = s.reduce(function(t, e) { return Math.max(t, Math.ceil(e.duration)) }, 0) : e.duration = 0; return { attributes: e, segments: s } },
            Ks = function(t, e) { return Ms(t.childNodes).filter(function(t) { return t.tagName === e }) },
            Zs = function(t) { return t.textContent.trim() },
            Qs = function(t) { var e = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/.exec(t); if (!e) return 0; var i = e.slice(1),
                    o = i[0],
                    n = i[1],
                    s = i[2],
                    r = i[3],
                    a = i[4],
                    h = i[5]; return 31536e3 * parseFloat(o || 0) + 2592e3 * parseFloat(n || 0) + 86400 * parseFloat(s || 0) + 3600 * parseFloat(r || 0) + 60 * parseFloat(a || 0) + parseFloat(h || 0) },
            $s = { mediaPresentationDuration: function(t) { return Qs(t) }, availabilityStartTime: function(t) { return /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/.test(e = t) && (e += "Z"), Date.parse(e) / 1e3; var e }, minimumUpdatePeriod: function(t) { return Qs(t) }, timeShiftBufferDepth: function(t) { return Qs(t) }, start: function(t) { return Qs(t) }, width: function(t) { return parseInt(t, 10) }, height: function(t) { return parseInt(t, 10) }, bandwidth: function(t) { return parseInt(t, 10) }, startNumber: function(t) { return parseInt(t, 10) }, timescale: function(t) { return parseInt(t, 10) }, duration: function(t) { var e = parseInt(t, 10); return isNaN(e) ? Qs(t) : e }, d: function(t) { return parseInt(t, 10) }, t: function(t) { return parseInt(t, 10) }, r: function(t) { return parseInt(t, 10) }, DEFAULT: function(t) { return t } },
            tr = function(t) { return t && t.attributes ? Ms(t.attributes).reduce(function(t, e) { var i = $s[e.name] || $s.DEFAULT; return t[e.name] = i(e.value), t }, {}) : {} },
            er = { "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey", "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha", "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready", "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime" },
            ir = function(t, e) { return e.length ? ks(t.map(function(t) { return e.map(function(e) { return Gs(t, Zs(e)) }) })) : t },
            or = function(t) { var e = Ks(t, "SegmentTemplate")[0],
                    i = Ks(t, "SegmentList")[0],
                    o = i && Ks(i, "SegmentURL").map(function(t) { return Ps({ tag: "SegmentURL" }, tr(t)) }),
                    n = Ks(t, "SegmentBase")[0],
                    s = i || e,
                    r = s && Ks(s, "SegmentTimeline")[0],
                    a = i || n || e,
                    h = a && Ks(a, "Initialization")[0],
                    l = e && tr(e);
                l && h ? l.initialization = h && tr(h) : l && l.initialization && (l.initialization = { sourceURL: l.initialization }); var c = { template: l, timeline: r && Ks(r, "S").map(function(t) { return tr(t) }), list: i && Ps(tr(i), { segmentUrls: o, initialization: tr(h) }), base: n && Ps(tr(n), { initialization: tr(h) }) }; return Object.keys(c).forEach(function(t) { c[t] || delete c[t] }), c },
            nr = function(t) { return t.reduce(function(t, i) { var o = tr(i),
                        n = er[o.schemeIdUri]; if (n) { t[n] = { attributes: o }; var s = Ks(i, "cenc:pssh")[0]; if (s) { var r = Zs(s),
                                a = r && function(t) { for (var i = e.atob(t), o = new Uint8Array(i.length), n = 0; n < i.length; n++) o[n] = i.charCodeAt(n); return o }(r);
                            t[n].pssh = a } } return t }, {}) },
            sr = function(t, e, i) { return function(o) { var n = tr(o),
                        s = ir(e, Ks(o, "BaseURL")),
                        r = Ks(o, "Role")[0],
                        a = { role: tr(r) },
                        h = Ps(t, n, a),
                        l = nr(Ks(o, "ContentProtection"));
                    Object.keys(l).length && (h = Ps(h, { contentProtection: l })); var c, d, u, p = or(o),
                        m = Ks(o, "Representation"),
                        f = Ps(i, p); return ks(m.map((c = h, d = s, u = f, function(t) { var e = Ks(t, "BaseURL"),
                            i = ir(d, e),
                            o = Ps(c, tr(t)),
                            n = or(t); return i.map(function(t) { return { segmentInfo: Ps(u, n), attributes: Ps(o, { baseUrl: t }) } }) }))) } },
            rr = function(t, i) { void 0 === i && (i = {}); var o = i,
                    n = o.manifestUri,
                    s = void 0 === n ? "" : n,
                    r = o.NOW,
                    a = void 0 === r ? Date.now() : r,
                    h = o.clientOffset,
                    l = void 0 === h ? 0 : h,
                    c = Ks(t, "Period"); if (!c.length) throw new Error("INVALID_NUMBER_OF_PERIOD"); var d, u, p = tr(t),
                    m = ir([s], Ks(t, "BaseURL")); return p.sourceDuration = p.mediaPresentationDuration || 0, p.NOW = a, p.clientOffset = l, ks(c.map((d = p, u = m, function(t, i) { var o = ir(u, Ks(t, "BaseURL")),
                        n = tr(t),
                        s = parseInt(n.id, 10),
                        r = e.isNaN(s) ? i : s,
                        a = Ps(d, { periodIndex: r }),
                        h = Ks(t, "AdaptationSet"),
                        l = or(t); return ks(h.map(sr(a, o, l))) }))) },
            ar = function(t) { if ("" === t) throw new Error("DASH_EMPTY_MANIFEST"); var i = (new e.DOMParser).parseFromString(t, "application/xml"),
                    o = i && "MPD" === i.documentElement.tagName ? i.documentElement : null; if (!o || o && 0 < o.getElementsByTagName("parsererror").length) throw new Error("DASH_INVALID_XML"); return o },
            hr = function(t, e) { return function(t) { var e; if (!t.length) return {}; var i = t[0].attributes,
                        o = i.sourceDuration,
                        n = i.minimumUpdatePeriod,
                        s = void 0 === n ? 0 : n,
                        r = Es(t.filter(function(t) { var e = t.attributes; return "video/mp4" === e.mimeType || "video" === e.contentType })).map(Bs),
                        a = Es(t.filter(function(t) { var e = t.attributes; return "audio/mp4" === e.mimeType || "audio" === e.contentType })),
                        h = t.filter(function(t) { var e = t.attributes; return "text/vtt" === e.mimeType || "text" === e.contentType }),
                        l = { allowCache: !0, discontinuityStarts: [], segments: [], endList: !0, mediaGroups: (e = { AUDIO: {}, VIDEO: {} }, e["CLOSED-CAPTIONS"] = {}, e.SUBTITLES = {}, e), uri: "", duration: o, playlists: r, minimumUpdatePeriod: 1e3 * s }; return a.length && (l.mediaGroups.AUDIO.audio = a.reduce(function(t, e) { var i, o, n, s, r, a = e.attributes.role && e.attributes.role.value || "main",
                            h = e.attributes.lang || "",
                            l = "main"; return h && (l = e.attributes.lang + " (" + a + ")"), t[l] && t[l].playlists[0].attributes.BANDWIDTH > e.attributes.bandwidth || (t[l] = { language: h, autoselect: !0, default: "main" === a, playlists: [(i = e, n = i.attributes, s = i.segments, r = { attributes: (o = { NAME: n.id, BANDWIDTH: n.bandwidth, CODECS: n.codecs }, o["PROGRAM-ID"] = 1, o), uri: "", endList: "static" === (n.type || "static"), timeline: n.periodIndex, resolvedUri: "", targetDuration: n.duration, segments: s, mediaSequence: s.length ? s[0].number : 1 }, n.contentProtection && (r.contentProtection = n.contentProtection), r)], uri: "" }), t }, {})), h.length && (l.mediaGroups.SUBTITLES.subs = h.reduce(function(t, e) { var i, o, n, s, r = e.attributes.lang || "text"; return t[r] || (t[r] = { language: r, default: !1, autoselect: !1, playlists: [(i = e, n = i.attributes, void 0 === (s = i.segments) && (s = [{ uri: n.baseUrl, timeline: n.periodIndex, resolvedUri: n.baseUrl || "", duration: n.sourceDuration, number: 0 }], n.duration = n.sourceDuration), { attributes: (o = { NAME: n.id, BANDWIDTH: n.bandwidth }, o["PROGRAM-ID"] = 1, o), uri: "", endList: "static" === (n.type || "static"), timeline: n.periodIndex, resolvedUri: n.baseUrl || "", targetDuration: n.duration, segments: s, mediaSequence: s.length ? s[0].number : 1 })], uri: "" }), t }, {})), l }(rr(ar(t), e).map(Ys)) },
            lr = function(t) { return function(t) { var e = Ks(t, "UTCTiming")[0]; if (!e) return null; var i = tr(e); switch (i.schemeIdUri) {
                        case "urn:mpeg:dash:utc:http-head:2014":
                        case "urn:mpeg:dash:utc:http-head:2012":
                            i.method = "HEAD"; break;
                        case "urn:mpeg:dash:utc:http-xsdate:2014":
                        case "urn:mpeg:dash:utc:http-iso:2014":
                        case "urn:mpeg:dash:utc:http-xsdate:2012":
                        case "urn:mpeg:dash:utc:http-iso:2012":
                            i.method = "GET"; break;
                        case "urn:mpeg:dash:utc:direct:2014":
                        case "urn:mpeg:dash:utc:direct:2012":
                            i.method = "DIRECT", i.value = Date.parse(i.value); break;
                        case "urn:mpeg:dash:utc:http-ntp:2014":
                        case "urn:mpeg:dash:utc:ntp:2014":
                        case "urn:mpeg:dash:utc:sntp:2014":
                        default:
                            throw new Error("UNSUPPORTED_UTC_TIMING_SCHEME") } return i }(ar(t)) },
            cr = function(t) { return t >>> 0 };
        Os = function(t) { return Ds(t, ["moov", "trak"]).reduce(function(t, e) { var i, o, n, s, r; return (i = Ds(e, ["tkhd"])[0]) ? (o = i[0], s = cr(i[n = 0 === o ? 12 : 20] << 24 | i[n + 1] << 16 | i[n + 2] << 8 | i[n + 3]), (r = Ds(e, ["mdia", "mdhd"])[0]) ? (n = 0 === (o = r[0]) ? 12 : 20, t[s] = cr(r[n] << 24 | r[n + 1] << 16 | r[n + 2] << 8 | r[n + 3]), t) : null) : null }, {}) }, Rs = function(t, e) { var i, o, n; return i = Ds(e, ["moof", "traf"]), o = [].concat.apply([], i.map(function(e) { return Ds(e, ["tfhd"]).map(function(i) { var o, n; return o = cr(i[4] << 24 | i[5] << 16 | i[6] << 8 | i[7]), n = t[o] || 9e4, (Ds(e, ["tfdt"]).map(function(t) { var e, i; return e = t[0], i = cr(t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7]), 1 === e && (i *= Math.pow(2, 32), i += cr(t[8] << 24 | t[9] << 16 | t[10] << 8 | t[11])), i })[0] || 1 / 0) / n }) })), n = Math.min.apply(null, o), isFinite(n) ? n : 0 }, Fs = function(t) { var e = []; return Ds(t, ["moov", "trak"]).forEach(function(t) { var i = Ds(t, ["mdia", "hdlr"]),
                    o = Ds(t, ["tkhd"]);
                i.forEach(function(t, i) { var n, s, r = Ls(t.subarray(8, 12)),
                        a = o[i]; "vide" === r && (s = 0 === (n = new DataView(a.buffer, a.byteOffset, a.byteLength)).getUint8(0) ? n.getUint32(12) : n.getUint32(20), e.push(s)) }) }), e }; var dr, ur, pr, mr, fr, yr, br, gr, _r, vr, xr, Sr, Cr, wr, Ar, Tr, Pr, kr, Mr, Er, Br, Ir, Dr, Lr, Or, Rr, Fr, Vr, Gr, Ur, Nr, jr, Wr, Xr, Hr, zr, Jr, qr, Yr, Kr, Zr = { findBox: Ds = function(t, e) { var i, o, n, s, r, a = []; if (!e.length) return null; for (i = 0; i < t.byteLength;) o = cr(t[i] << 24 | t[i + 1] << 16 | t[i + 2] << 8 | t[i + 3]), n = Ls(t.subarray(i + 4, i + 8)), s = 1 < o ? i + o : t.byteLength, n === e[0] && (1 === e.length ? a.push(t.subarray(i + 8, s)) : (r = Ds(t.subarray(i + 8, s), e.slice(1))).length && (a = a.concat(r))), i = s; return a }, parseType: Ls = function(t) { var e = ""; return e += String.fromCharCode(t[0]), e += String.fromCharCode(t[1]), e += String.fromCharCode(t[2]), e += String.fromCharCode(t[3]) }, timescale: Os, startTime: Rs, videoTrackIds: Fs },
            Qr = Math.pow(2, 32) - 1;! function() { var t; if (Ir = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], mvex: [], mvhd: [], sdtp: [], smhd: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], styp: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [] }, "undefined" != typeof Uint8Array) { for (t in Ir) Ir.hasOwnProperty(t) && (Ir[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);
                Dr = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]), Or = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]), Lr = new Uint8Array([0, 0, 0, 1]), Rr = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), Fr = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]), Vr = { video: Rr, audio: Fr }, Nr = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), Ur = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), jr = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), Wr = jr, Xr = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Hr = jr, Gr = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]) } }(), dr = function(t) { var e, i, o = [],
                n = 0; for (e = 1; e < arguments.length; e++) o.push(arguments[e]); for (e = o.length; e--;) n += o[e].byteLength; for (i = new Uint8Array(n + 8), new DataView(i.buffer, i.byteOffset, i.byteLength).setUint32(0, i.byteLength), i.set(t, 4), e = 0, n = 8; e < o.length; e++) i.set(o[e], n), n += o[e].byteLength; return i }, ur = function() { return dr(Ir.dinf, dr(Ir.dref, Nr)) }, pr = function(t) { return dr(Ir.esds, new Uint8Array([0, 0, 0, 0, 3, 25, 0, 0, 0, 4, 17, 64, 21, 0, 6, 0, 0, 0, 218, 192, 0, 0, 218, 192, 5, 2, t.audioobjecttype << 3 | t.samplingfrequencyindex >>> 1, t.samplingfrequencyindex << 7 | t.channelcount << 3, 6, 1, 2])) }, Ar = function(t) { return dr(Ir.hdlr, Vr[t]) }, wr = function(t) { var e = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 1, 95, 144, t.duration >>> 24 & 255, t.duration >>> 16 & 255, t.duration >>> 8 & 255, 255 & t.duration, 85, 196, 0, 0]); return t.samplerate && (e[12] = t.samplerate >>> 24 & 255, e[13] = t.samplerate >>> 16 & 255, e[14] = t.samplerate >>> 8 & 255, e[15] = 255 & t.samplerate), dr(Ir.mdhd, e) }, Cr = function(t) { return dr(Ir.mdia, wr(t), Ar(t.type), yr(t)) }, fr = function(t) { return dr(Ir.mfhd, new Uint8Array([0, 0, 0, 0, (4278190080 & t) >> 24, (16711680 & t) >> 16, (65280 & t) >> 8, 255 & t])) }, yr = function(t) { return dr(Ir.minf, "video" === t.type ? dr(Ir.vmhd, Gr) : dr(Ir.smhd, Ur), ur(), Pr(t)) }, br = function(t, e) { for (var i = [], o = e.length; o--;) i[o] = Mr(e[o]); return dr.apply(null, [Ir.moof, fr(t)].concat(i)) }, gr = function(t) { for (var e = t.length, i = []; e--;) i[e] = xr(t[e]); return dr.apply(null, [Ir.moov, vr(4294967295)].concat(i).concat(_r(t))) }, _r = function(t) { for (var e = t.length, i = []; e--;) i[e] = Er(t[e]); return dr.apply(null, [Ir.mvex].concat(i)) }, vr = function(t) { var e = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 95, 144, (4278190080 & t) >> 24, (16711680 & t) >> 16, (65280 & t) >> 8, 255 & t, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]); return dr(Ir.mvhd, e) }, Tr = function(t) { var e, i, o = t.samples || [],
                n = new Uint8Array(4 + o.length); for (i = 0; i < o.length; i++) e = o[i].flags, n[i + 4] = e.dependsOn << 4 | e.isDependedOn << 2 | e.hasRedundancy; return dr(Ir.sdtp, n) }, Pr = function(t) { return dr(Ir.stbl, kr(t), dr(Ir.stts, Hr), dr(Ir.stsc, Wr), dr(Ir.stsz, Xr), dr(Ir.stco, jr)) }, kr = function(t) { return dr(Ir.stsd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), "video" === t.type ? zr(t) : Jr(t)) }, zr = function(t) { var e, i = t.sps || [],
                o = t.pps || [],
                n = [],
                s = []; for (e = 0; e < i.length; e++) n.push((65280 & i[e].byteLength) >>> 8), n.push(255 & i[e].byteLength), n = n.concat(Array.prototype.slice.call(i[e])); for (e = 0; e < o.length; e++) s.push((65280 & o[e].byteLength) >>> 8), s.push(255 & o[e].byteLength), s = s.concat(Array.prototype.slice.call(o[e])); return dr(Ir.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & t.width) >> 8, 255 & t.width, (65280 & t.height) >> 8, 255 & t.height, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 19, 118, 105, 100, 101, 111, 106, 115, 45, 99, 111, 110, 116, 114, 105, 98, 45, 104, 108, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), dr(Ir.avcC, new Uint8Array([1, t.profileIdc, t.profileCompatibility, t.levelIdc, 255].concat([i.length]).concat(n).concat([o.length]).concat(s))), dr(Ir.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192]))) }, Jr = function(t) { return dr(Ir.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & t.channelcount) >> 8, 255 & t.channelcount, (65280 & t.samplesize) >> 8, 255 & t.samplesize, 0, 0, 0, 0, (65280 & t.samplerate) >> 8, 255 & t.samplerate, 0, 0]), pr(t)) }, Sr = function(t) { var e = new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, (4278190080 & t.id) >> 24, (16711680 & t.id) >> 16, (65280 & t.id) >> 8, 255 & t.id, 0, 0, 0, 0, (4278190080 & t.duration) >> 24, (16711680 & t.duration) >> 16, (65280 & t.duration) >> 8, 255 & t.duration, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, (65280 & t.width) >> 8, 255 & t.width, 0, 0, (65280 & t.height) >> 8, 255 & t.height, 0, 0]); return dr(Ir.tkhd, e) }, Mr = function(t) { var e, i, o, n, s, r; return e = dr(Ir.tfhd, new Uint8Array([0, 0, 0, 58, (4278190080 & t.id) >> 24, (16711680 & t.id) >> 16, (65280 & t.id) >> 8, 255 & t.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])), s = Math.floor(t.baseMediaDecodeTime / (Qr + 1)), r = Math.floor(t.baseMediaDecodeTime % (Qr + 1)), i = dr(Ir.tfdt, new Uint8Array([1, 0, 0, 0, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r])), "audio" === t.type ? (o = Br(t, 92), dr(Ir.traf, e, i, o)) : (n = Tr(t), o = Br(t, n.length + 92), dr(Ir.traf, e, i, o, n)) }, xr = function(t) { return t.duration = t.duration || 4294967295, dr(Ir.trak, Sr(t), Cr(t)) }, Er = function(t) { var e = new Uint8Array([0, 0, 0, 0, (4278190080 & t.id) >> 24, (16711680 & t.id) >> 16, (65280 & t.id) >> 8, 255 & t.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]); return "video" !== t.type && (e[e.length - 1] = 0), dr(Ir.trex, e) }, Kr = function(t, e) { var i = 0,
                o = 0,
                n = 0,
                s = 0; return t.length && (void 0 !== t[0].duration && (i = 1), void 0 !== t[0].size && (o = 2), void 0 !== t[0].flags && (n = 4), void 0 !== t[0].compositionTimeOffset && (s = 8)), [0, 0, i | o | n | s, 1, (4278190080 & t.length) >>> 24, (16711680 & t.length) >>> 16, (65280 & t.length) >>> 8, 255 & t.length, (4278190080 & e) >>> 24, (16711680 & e) >>> 16, (65280 & e) >>> 8, 255 & e] }, Yr = function(t, e) { var i, o, n, s; for (e += 20 + 16 * (o = t.samples || []).length, i = Kr(o, e), s = 0; s < o.length; s++) n = o[s], i = i.concat([(4278190080 & n.duration) >>> 24, (16711680 & n.duration) >>> 16, (65280 & n.duration) >>> 8, 255 & n.duration, (4278190080 & n.size) >>> 24, (16711680 & n.size) >>> 16, (65280 & n.size) >>> 8, 255 & n.size, n.flags.isLeading << 2 | n.flags.dependsOn, n.flags.isDependedOn << 6 | n.flags.hasRedundancy << 4 | n.flags.paddingValue << 1 | n.flags.isNonSyncSample, 61440 & n.flags.degradationPriority, 15 & n.flags.degradationPriority, (4278190080 & n.compositionTimeOffset) >>> 24, (16711680 & n.compositionTimeOffset) >>> 16, (65280 & n.compositionTimeOffset) >>> 8, 255 & n.compositionTimeOffset]); return dr(Ir.trun, new Uint8Array(i)) }, qr = function(t, e) { var i, o, n, s; for (e += 20 + 8 * (o = t.samples || []).length, i = Kr(o, e), s = 0; s < o.length; s++) n = o[s], i = i.concat([(4278190080 & n.duration) >>> 24, (16711680 & n.duration) >>> 16, (65280 & n.duration) >>> 8, 255 & n.duration, (4278190080 & n.size) >>> 24, (16711680 & n.size) >>> 16, (65280 & n.size) >>> 8, 255 & n.size]); return dr(Ir.trun, new Uint8Array(i)) }, Br = function(t, e) { return "audio" === t.type ? qr(t, e) : Yr(t, e) }; var $r = { ftyp: mr = function() { return dr(Ir.ftyp, Dr, Lr, Dr, Or) }, mdat: function(t) { return dr(Ir.mdat, t) }, moof: br, moov: gr, initSegment: function(t) { var e, i = mr(),
                        o = gr(t); return (e = new Uint8Array(i.byteLength + o.byteLength)).set(i), e.set(o, i.byteLength), e } },
            ta = function() { this.init = function() { var t = {};
                    this.on = function(e, i) { t[e] || (t[e] = []), t[e] = t[e].concat(i) }, this.off = function(e, i) { var o; return !!t[e] && (o = t[e].indexOf(i), t[e] = t[e].slice(), t[e].splice(o, 1), -1 < o) }, this.trigger = function(e) { var i, o, n, s; if (i = t[e])
                            if (2 === arguments.length)
                                for (n = i.length, o = 0; o < n; ++o) i[o].call(this, arguments[1]);
                            else { for (s = [], o = arguments.length, o = 1; o < arguments.length; ++o) s.push(arguments[o]); for (n = i.length, o = 0; o < n; ++o) i[o].apply(this, s) } }, this.dispose = function() { t = {} } } };
        ta.prototype.pipe = function(t) { return this.on("data", function(e) { t.push(e) }), this.on("done", function(e) { t.flush(e) }), t }, ta.prototype.push = function(t) { this.trigger("data", t) }, ta.prototype.flush = function(t) { this.trigger("done", t) }; var ea, ia, oa, na, sa, ra, aa, ha = ta,
            la = function(t) { var e, i, o = [],
                    n = []; for (e = o.byteLength = 0; e < t.length; e++) "access_unit_delimiter_rbsp" === (i = t[e]).nalUnitType ? (o.length && (o.duration = i.dts - o.dts, n.push(o)), (o = [i]).byteLength = i.data.byteLength, o.pts = i.pts, o.dts = i.dts) : ("slice_layer_without_partitioning_rbsp_idr" === i.nalUnitType && (o.keyFrame = !0), o.duration = i.dts - o.dts, o.byteLength += i.data.byteLength, o.push(i)); return n.length && (!o.duration || o.duration <= 0) && (o.duration = n[n.length - 1].duration), n.push(o), n },
            ca = function(t) { var e, i, o = [],
                    n = []; for (o.byteLength = 0, o.nalCount = 0, o.duration = 0, o.pts = t[0].pts, o.dts = t[0].dts, n.byteLength = 0, n.nalCount = 0, n.duration = 0, n.pts = t[0].pts, n.dts = t[0].dts, e = 0; e < t.length; e++)(i = t[e]).keyFrame ? (o.length && (n.push(o), n.byteLength += o.byteLength, n.nalCount += o.nalCount, n.duration += o.duration), (o = [i]).nalCount = i.length, o.byteLength = i.byteLength, o.pts = i.pts, o.dts = i.dts, o.duration = i.duration) : (o.duration += i.duration, o.nalCount += i.length, o.byteLength += i.byteLength, o.push(i)); return n.length && o.duration <= 0 && (o.duration = n[n.length - 1].duration), n.byteLength += o.byteLength, n.nalCount += o.nalCount, n.duration += o.duration, n.push(o), n },
            da = function(t) { var e; return !t[0][0].keyFrame && 1 < t.length && (e = t.shift(), t.byteLength -= e.byteLength, t.nalCount -= e.nalCount, t[0][0].dts = e.dts, t[0][0].pts = e.pts, t[0][0].duration += e.duration), t },
            ua = function(t, e) { var i, o, n, s, r, a, h, l = e || 0,
                    c = []; for (i = 0; i < t.length; i++)
                    for (s = t[i], o = 0; o < s.length; o++) r = s[o], a = r, h = void 0, (h = { size: 0, flags: { isLeading: 0, dependsOn: 1, isDependedOn: 0, hasRedundancy: 0, degradationPriority: 0, isNonSyncSample: 1 } }).dataOffset = l, h.compositionTimeOffset = a.pts - a.dts, h.duration = a.duration, h.size = 4 * a.length, h.size += a.byteLength, a.keyFrame && (h.flags.dependsOn = 2, h.flags.isNonSyncSample = 0), l += (n = h).size, c.push(n); return c },
            pa = function(t) { var e, i, o, n, s, r, a = 0,
                    h = t.byteLength,
                    l = t.nalCount,
                    c = new Uint8Array(h + 4 * l),
                    d = new DataView(c.buffer); for (e = 0; e < t.length; e++)
                    for (n = t[e], i = 0; i < n.length; i++)
                        for (s = n[i], o = 0; o < s.length; o++) r = s[o], d.setUint32(a, r.data.byteLength), a += 4, c.set(r.data, a), a += r.data.byteLength; return c },
            ma = [33, 16, 5, 32, 164, 27],
            fa = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252],
            ya = function(t) { for (var e = []; t--;) e.push(0); return e },
            ba = { 96e3: [ma, [227, 64], ya(154), [56]], 88200: [ma, [231], ya(170), [56]], 64e3: [ma, [248, 192], ya(240), [56]], 48e3: [ma, [255, 192], ya(268), [55, 148, 128], ya(54), [112]], 44100: [ma, [255, 192], ya(268), [55, 163, 128], ya(84), [112]], 32e3: [ma, [255, 192], ya(268), [55, 234], ya(226), [112]], 24e3: [ma, [255, 192], ya(268), [55, 255, 128], ya(268), [111, 112], ya(126), [224]], 16e3: [ma, [255, 192], ya(268), [55, 255, 128], ya(268), [111, 255], ya(269), [223, 108], ya(195), [1, 192]], 12e3: [fa, ya(268), [3, 127, 248], ya(268), [6, 255, 240], ya(268), [13, 255, 224], ya(268), [27, 253, 128], ya(259), [56]], 11025: [fa, ya(268), [3, 127, 248], ya(268), [6, 255, 240], ya(268), [13, 255, 224], ya(268), [27, 255, 192], ya(268), [55, 175, 128], ya(108), [112]], 8e3: [fa, ya(268), [3, 121, 16], ya(47), [7]] },
            ga = (ea = ba, Object.keys(ea).reduce(function(t, e) { return t[e] = new Uint8Array(ea[e].reduce(function(t, e) { return t.concat(e) }, [])), t }, {}));
        ra = function(t, e) { return ia(sa(t, e)) }, aa = function(t, e) { return oa(na(t), e) }, ia = function(t) { return 9e4 * t }, oa = function(t, e) { return t * e }, na = function(t) { return t / 9e4 }, sa = function(t, e) { return t / e }; var _a = ra,
            va = aa,
            xa = function(t, e, i, o) { var n, s, r, a, h = 0,
                    l = 0,
                    c = 0; if (e.length && (n = _a(t.baseMediaDecodeTime, t.samplerate), s = Math.ceil(9e4 / (t.samplerate / 1024)), i && o && (h = n - Math.max(i, o), c = (l = Math.floor(h / s)) * s), !(l < 1 || 45e3 < c))) { for ((r = ga[t.samplerate]) || (r = e[0].data), a = 0; a < l; a++) e.splice(a, 0, { data: r });
                    t.baseMediaDecodeTime -= Math.floor(va(c, t.samplerate)) } },
            Sa = function(t, e, i) { return e.minSegmentDts >= i ? t : (e.minSegmentDts = 1 / 0, t.filter(function(t) { return t.dts >= i && (e.minSegmentDts = Math.min(e.minSegmentDts, t.dts), e.minSegmentPts = e.minSegmentDts, !0) })) },
            Ca = function(t) { var e, i, o = []; for (e = 0; e < t.length; e++) i = t[e], o.push({ size: i.data.byteLength, duration: 1024 }); return o },
            wa = function(t) { var e, i, o = 0,
                    n = new Uint8Array(function(t) { var e, i = 0; for (e = 0; e < t.length; e++) i += t[e].data.byteLength; return i }(t)); for (e = 0; e < t.length; e++) i = t[e], n.set(i.data, o), o += i.data.byteLength; return n },
            Aa = function(t) { delete t.minSegmentDts, delete t.maxSegmentDts, delete t.minSegmentPts, delete t.maxSegmentPts },
            Ta = function(t, e) { var i, o = t.minSegmentDts; return e || (o -= t.timelineStartInfo.dts), i = t.timelineStartInfo.baseMediaDecodeTime, i += o, i = Math.max(0, i), "audio" === t.type && (i *= t.samplerate / 9e4, i = Math.floor(i)), i },
            Pa = function(t, e) { "number" == typeof e.pts && (void 0 === t.timelineStartInfo.pts && (t.timelineStartInfo.pts = e.pts), void 0 === t.minSegmentPts ? t.minSegmentPts = e.pts : t.minSegmentPts = Math.min(t.minSegmentPts, e.pts), void 0 === t.maxSegmentPts ? t.maxSegmentPts = e.pts : t.maxSegmentPts = Math.max(t.maxSegmentPts, e.pts)), "number" == typeof e.dts && (void 0 === t.timelineStartInfo.dts && (t.timelineStartInfo.dts = e.dts), void 0 === t.minSegmentDts ? t.minSegmentDts = e.dts : t.minSegmentDts = Math.min(t.minSegmentDts, e.dts), void 0 === t.maxSegmentDts ? t.maxSegmentDts = e.dts : t.maxSegmentDts = Math.max(t.maxSegmentDts, e.dts)) },
            ka = function(t) { for (var e = 0, i = { payloadType: -1, payloadSize: 0 }, o = 0, n = 0; e < t.byteLength && 128 !== t[e];) { for (; 255 === t[e];) o += 255, e++; for (o += t[e++]; 255 === t[e];) n += 255, e++; if (n += t[e++], !i.payload && 4 === o) { i.payloadType = o, i.payloadSize = n, i.payload = t.subarray(e, e + n); break } e += n, n = o = 0 } return i },
            Ma = function(t) { return 181 !== t.payload[0] ? null : 49 != (t.payload[1] << 8 | t.payload[2]) ? null : "GA94" !== String.fromCharCode(t.payload[3], t.payload[4], t.payload[5], t.payload[6]) ? null : 3 !== t.payload[7] ? null : t.payload.subarray(8, t.payload.length - 1) },
            Ea = function(t, e) { var i, o, n, s, r = []; if (!(64 & e[0])) return r; for (o = 31 & e[0], i = 0; i < o; i++) s = { type: 3 & e[2 + (n = 3 * i)], pts: t }, 4 & e[n + 2] && (s.ccData = e[n + 3] << 8 | e[n + 4], r.push(s)); return r },
            Ba = function t() { t.prototype.init.call(this), this.captionPackets_ = [], this.ccStreams_ = [new Ra(0, 0), new Ra(0, 1), new Ra(1, 0), new Ra(1, 1)], this.reset(), this.ccStreams_.forEach(function(t) { t.on("data", this.trigger.bind(this, "data")), t.on("done", this.trigger.bind(this, "done")) }, this) };
        (Ba.prototype = new ha).push = function(t) { var e, i, o; if ("sei_rbsp" === t.nalUnitType && 4 === (e = ka(t.escapedRBSP)).payloadType && (i = Ma(e)))
                if (t.dts < this.latestDts_) this.ignoreNextEqualDts_ = !0;
                else { if (t.dts === this.latestDts_ && this.ignoreNextEqualDts_) return void(--this.numSameDts_ || (this.ignoreNextEqualDts_ = !1));
                    o = Ea(t.pts, i), this.captionPackets_ = this.captionPackets_.concat(o), this.latestDts_ !== t.dts && (this.numSameDts_ = 0), this.numSameDts_++, this.latestDts_ = t.dts } }, Ba.prototype.flush = function() { this.captionPackets_.length ? (this.captionPackets_.forEach(function(t, e) { t.presortIndex = e }), this.captionPackets_.sort(function(t, e) { return t.pts === e.pts ? t.presortIndex - e.presortIndex : t.pts - e.pts }), this.captionPackets_.forEach(function(t) { t.type < 2 && this.dispatchCea608Packet(t) }, this), this.captionPackets_.length = 0, this.ccStreams_.forEach(function(t) { t.flush() }, this)) : this.ccStreams_.forEach(function(t) { t.flush() }, this) }, Ba.prototype.reset = function() { this.latestDts_ = null, this.ignoreNextEqualDts_ = !1, this.numSameDts_ = 0, this.activeCea608Channel_ = [null, null], this.ccStreams_.forEach(function(t) { t.reset() }) }, Ba.prototype.dispatchCea608Packet = function(t) { this.setsChannel1Active(t) ? this.activeCea608Channel_[t.type] = 0 : this.setsChannel2Active(t) && (this.activeCea608Channel_[t.type] = 1), null !== this.activeCea608Channel_[t.type] && this.ccStreams_[(t.type << 1) + this.activeCea608Channel_[t.type]].push(t) }, Ba.prototype.setsChannel1Active = function(t) { return 4096 == (30720 & t.ccData) }, Ba.prototype.setsChannel2Active = function(t) { return 6144 == (30720 & t.ccData) }; var Ia = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 304: 174, 305: 176, 306: 189, 307: 191, 308: 8482, 309: 162, 310: 163, 311: 9834, 312: 224, 313: 160, 314: 232, 315: 226, 316: 234, 317: 238, 318: 244, 319: 251, 544: 193, 545: 201, 546: 211, 547: 218, 548: 220, 549: 252, 550: 8216, 551: 161, 552: 42, 553: 39, 554: 8212, 555: 169, 556: 8480, 557: 8226, 558: 8220, 559: 8221, 560: 192, 561: 194, 562: 199, 563: 200, 564: 202, 565: 203, 566: 235, 567: 206, 568: 207, 569: 239, 570: 212, 571: 217, 572: 249, 573: 219, 574: 171, 575: 187, 800: 195, 801: 227, 802: 205, 803: 204, 804: 236, 805: 210, 806: 242, 807: 213, 808: 245, 809: 123, 810: 125, 811: 92, 812: 94, 813: 95, 814: 124, 815: 126, 816: 196, 817: 228, 818: 214, 819: 246, 820: 223, 821: 165, 822: 164, 823: 9474, 824: 197, 825: 229, 826: 216, 827: 248, 828: 9484, 829: 9488, 830: 9492, 831: 9496 },
            Da = function(t) { return null === t ? "" : (t = Ia[t] || t, String.fromCharCode(t)) },
            La = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152],
            Oa = function() { for (var t = [], e = 15; e--;) t.push(""); return t },
            Ra = function t(e, i) { t.prototype.init.call(this), this.field_ = e || 0, this.dataChannel_ = i || 0, this.name_ = "CC" + (1 + (this.field_ << 1 | this.dataChannel_)), this.setConstants(), this.reset(), this.push = function(t) { var e, i, o, n, s; if ((e = 32639 & t.ccData) !== this.lastControlCode_) { if (4096 == (61440 & e) ? this.lastControlCode_ = e : e !== this.PADDING_ && (this.lastControlCode_ = null), o = e >>> 8, n = 255 & e, e !== this.PADDING_)
                            if (e === this.RESUME_CAPTION_LOADING_) this.mode_ = "popOn";
                            else if (e === this.END_OF_CAPTION_) this.mode_ = "popOn", this.clearFormatting(t.pts), this.flushDisplayed(t.pts), i = this.displayed_, this.displayed_ = this.nonDisplayed_, this.nonDisplayed_ = i, this.startPts_ = t.pts;
                        else if (e === this.ROLL_UP_2_ROWS_) this.rollUpRows_ = 2, this.setRollUp(t.pts);
                        else if (e === this.ROLL_UP_3_ROWS_) this.rollUpRows_ = 3, this.setRollUp(t.pts);
                        else if (e === this.ROLL_UP_4_ROWS_) this.rollUpRows_ = 4, this.setRollUp(t.pts);
                        else if (e === this.CARRIAGE_RETURN_) this.clearFormatting(t.pts), this.flushDisplayed(t.pts), this.shiftRowsUp_(), this.startPts_ = t.pts;
                        else if (e === this.BACKSPACE_) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
                        else if (e === this.ERASE_DISPLAYED_MEMORY_) this.flushDisplayed(t.pts), this.displayed_ = Oa();
                        else if (e === this.ERASE_NON_DISPLAYED_MEMORY_) this.nonDisplayed_ = Oa();
                        else if (e === this.RESUME_DIRECT_CAPTIONING_) "paintOn" !== this.mode_ && (this.flushDisplayed(t.pts), this.displayed_ = Oa()), this.mode_ = "paintOn", this.startPts_ = t.pts;
                        else if (this.isSpecialCharacter(o, n)) s = Da((o = (3 & o) << 8) | n), this[this.mode_](t.pts, s), this.column_++;
                        else if (this.isExtCharacter(o, n)) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1), s = Da((o = (3 & o) << 8) | n), this[this.mode_](t.pts, s), this.column_++;
                        else if (this.isMidRowCode(o, n)) this.clearFormatting(t.pts), this[this.mode_](t.pts, " "), this.column_++, 14 == (14 & n) && this.addFormatting(t.pts, ["i"]), 1 == (1 & n) && this.addFormatting(t.pts, ["u"]);
                        else if (this.isOffsetControlCode(o, n)) this.column_ += 3 & n;
                        else if (this.isPAC(o, n)) { var r = La.indexOf(7968 & e); "rollUp" === this.mode_ && (r - this.rollUpRows_ + 1 < 0 && (r = this.rollUpRows_ - 1), this.setRollUp(t.pts, r)), r !== this.row_ && (this.clearFormatting(t.pts), this.row_ = r), 1 & n && -1 === this.formatting_.indexOf("u") && this.addFormatting(t.pts, ["u"]), 16 == (16 & e) && (this.column_ = 4 * ((14 & e) >> 1)), this.isColorPAC(n) && 14 == (14 & n) && this.addFormatting(t.pts, ["i"]) } else this.isNormalChar(o) && (0 === n && (n = null), s = Da(o), s += Da(n), this[this.mode_](t.pts, s), this.column_ += s.length) } else this.lastControlCode_ = null } };
        Ra.prototype = new ha, Ra.prototype.flushDisplayed = function(t) { var e = this.displayed_.map(function(t) { try { return t.trim() } catch (t) { return "" } }).join("\n").replace(/^\n+|\n+$/g, "");
            e.length && this.trigger("data", { startPts: this.startPts_, endPts: t, text: e, stream: this.name_ }) }, Ra.prototype.reset = function() { this.mode_ = "popOn", this.topRow_ = 0, this.startPts_ = 0, this.displayed_ = Oa(), this.nonDisplayed_ = Oa(), this.lastControlCode_ = null, this.column_ = 0, this.row_ = 14, this.rollUpRows_ = 2, this.formatting_ = [] }, Ra.prototype.setConstants = function() { 0 === this.dataChannel_ ? (this.BASE_ = 16, this.EXT_ = 17, this.CONTROL_ = (20 | this.field_) << 8, this.OFFSET_ = 23) : 1 === this.dataChannel_ && (this.BASE_ = 24, this.EXT_ = 25, this.CONTROL_ = (28 | this.field_) << 8, this.OFFSET_ = 31), this.PADDING_ = 0, this.RESUME_CAPTION_LOADING_ = 32 | this.CONTROL_, this.END_OF_CAPTION_ = 47 | this.CONTROL_, this.ROLL_UP_2_ROWS_ = 37 | this.CONTROL_, this.ROLL_UP_3_ROWS_ = 38 | this.CONTROL_, this.ROLL_UP_4_ROWS_ = 39 | this.CONTROL_, this.CARRIAGE_RETURN_ = 45 | this.CONTROL_, this.RESUME_DIRECT_CAPTIONING_ = 41 | this.CONTROL_, this.BACKSPACE_ = 33 | this.CONTROL_, this.ERASE_DISPLAYED_MEMORY_ = 44 | this.CONTROL_, this.ERASE_NON_DISPLAYED_MEMORY_ = 46 | this.CONTROL_ }, Ra.prototype.isSpecialCharacter = function(t, e) { return t === this.EXT_ && 48 <= e && e <= 63 }, Ra.prototype.isExtCharacter = function(t, e) { return (t === this.EXT_ + 1 || t === this.EXT_ + 2) && 32 <= e && e <= 63 }, Ra.prototype.isMidRowCode = function(t, e) { return t === this.EXT_ && 32 <= e && e <= 47 }, Ra.prototype.isOffsetControlCode = function(t, e) { return t === this.OFFSET_ && 33 <= e && e <= 35 }, Ra.prototype.isPAC = function(t, e) { return t >= this.BASE_ && t < this.BASE_ + 8 && 64 <= e && e <= 127 }, Ra.prototype.isColorPAC = function(t) { return 64 <= t && t <= 79 || 96 <= t && t <= 127 }, Ra.prototype.isNormalChar = function(t) { return 32 <= t && t <= 127 }, Ra.prototype.setRollUp = function(t, e) { if ("rollUp" !== this.mode_ && (this.row_ = 14, this.mode_ = "rollUp", this.flushDisplayed(t), this.nonDisplayed_ = Oa(), this.displayed_ = Oa()), void 0 !== e && e !== this.row_)
                for (var i = 0; i < this.rollUpRows_; i++) this.displayed_[e - i] = this.displayed_[this.row_ - i], this.displayed_[this.row_ - i] = "";
            void 0 === e && (e = this.row_), this.topRow_ = e - this.rollUpRows_ + 1 }, Ra.prototype.addFormatting = function(t, e) { this.formatting_ = this.formatting_.concat(e); var i = e.reduce(function(t, e) { return t + "<" + e + ">" }, "");
            this[this.mode_](t, i) }, Ra.prototype.clearFormatting = function(t) { if (this.formatting_.length) { var e = this.formatting_.reverse().reduce(function(t, e) { return t + "</" + e + ">" }, "");
                this.formatting_ = [], this[this.mode_](t, e) } }, Ra.prototype.popOn = function(t, e) { var i = this.nonDisplayed_[this.row_];
            i += e, this.nonDisplayed_[this.row_] = i }, Ra.prototype.rollUp = function(t, e) { var i = this.displayed_[this.row_];
            i += e, this.displayed_[this.row_] = i }, Ra.prototype.shiftRowsUp_ = function() { var t; for (t = 0; t < this.topRow_; t++) this.displayed_[t] = ""; for (t = this.row_ + 1; t < 15; t++) this.displayed_[t] = ""; for (t = this.topRow_; t < this.row_; t++) this.displayed_[t] = this.displayed_[t + 1];
            this.displayed_[this.row_] = "" }, Ra.prototype.paintOn = function(t, e) { var i = this.displayed_[this.row_];
            i += e, this.displayed_[this.row_] = i }; var Fa = { CaptionStream: Ba, Cea608Stream: Ra },
            Va = { H264_STREAM_TYPE: 27, ADTS_STREAM_TYPE: 15, METADATA_STREAM_TYPE: 21 },
            Ga = function(t, e) { var i = 1; for (e < t && (i = -1); 4294967296 < Math.abs(e - t);) t += 8589934592 * i; return t },
            Ua = function t(e) { var i, o;
                t.prototype.init.call(this), this.type_ = e, this.push = function(t) { t.type === this.type_ && (void 0 === o && (o = t.dts), t.dts = Ga(t.dts, o), t.pts = Ga(t.pts, o), i = t.dts, this.trigger("data", t)) }, this.flush = function() { o = i, this.trigger("done") }, this.discontinuity = function() { i = o = void 0 } };
        Ua.prototype = new ha; var Na, ja = Ua,
            Wa = Ga,
            Xa = function(t, e, i) { var o, n = ""; for (o = e; o < i; o++) n += "%" + ("00" + t[o].toString(16)).slice(-2); return n },
            Ha = function(t, e, i) { return decodeURIComponent(Xa(t, e, i)) },
            za = function(t) { return t[0] << 21 | t[1] << 14 | t[2] << 7 | t[3] },
            Ja = { TXXX: function(t) { var e; if (3 === t.data[0]) { for (e = 1; e < t.data.length; e++)
                            if (0 === t.data[e]) { t.description = Ha(t.data, 1, e), t.value = Ha(t.data, e + 1, t.data.length).replace(/\0*$/, ""); break } t.data = t.value } }, WXXX: function(t) { var e; if (3 === t.data[0])
                        for (e = 1; e < t.data.length; e++)
                            if (0 === t.data[e]) { t.description = Ha(t.data, 1, e), t.url = Ha(t.data, e + 1, t.data.length); break } }, PRIV: function(t) { var e, i; for (e = 0; e < t.data.length; e++)
                        if (0 === t.data[e]) { t.owner = (i = t.data, unescape(Xa(i, 0, e))); break } t.privateData = t.data.subarray(e + 1), t.data = t.privateData } };
        (Na = function(t) { var e, i = { debug: !(!t || !t.debug), descriptor: t && t.descriptor },
                o = 0,
                n = [],
                s = 0; if (Na.prototype.init.call(this), this.dispatchType = Va.METADATA_STREAM_TYPE.toString(16), i.descriptor)
                for (e = 0; e < i.descriptor.length; e++) this.dispatchType += ("00" + i.descriptor[e].toString(16)).slice(-2);
            this.push = function(t) { var e, r, a, h, l; if ("timed-metadata" === t.type)
                    if (t.dataAlignmentIndicator && (s = 0, n.length = 0), 0 === n.length && (t.data.length < 10 || t.data[0] !== "I".charCodeAt(0) || t.data[1] !== "D".charCodeAt(0) || t.data[2] !== "3".charCodeAt(0))) i.debug;
                    else if (n.push(t), s += t.data.byteLength, 1 === n.length && (o = za(t.data.subarray(6, 10)), o += 10), !(s < o)) { for (e = { data: new Uint8Array(o), frames: [], pts: n[0].pts, dts: n[0].dts }, l = 0; l < o;) e.data.set(n[0].data.subarray(0, o - l), l), l += n[0].data.byteLength, s -= n[0].data.byteLength, n.shift();
                    r = 10, 64 & e.data[5] && (r += 4, r += za(e.data.subarray(10, 14)), o -= za(e.data.subarray(16, 20)));
                    do { if ((a = za(e.data.subarray(r + 4, r + 8))) < 1) return; if ((h = { id: String.fromCharCode(e.data[r], e.data[r + 1], e.data[r + 2], e.data[r + 3]), data: e.data.subarray(r + 10, r + a + 10) }).key = h.id, Ja[h.id] && (Ja[h.id](h), "com.apple.streaming.transportStreamTimestamp" === h.owner)) { var c = h.data,
                                d = (1 & c[3]) << 30 | c[4] << 22 | c[5] << 14 | c[6] << 6 | c[7] >>> 2;
                            d *= 4, d += 3 & c[7], h.timeStamp = d, void 0 === e.pts && void 0 === e.dts && (e.pts = h.timeStamp, e.dts = h.timeStamp), this.trigger("timestamp", h) } e.frames.push(h), r += 10, r += a } while (r < o);
                    this.trigger("data", e) } } }).prototype = new ha; var qa, Ya, Ka, Za = Na,
            Qa = ja;
        (qa = function() { var t = new Uint8Array(188),
                e = 0;
            qa.prototype.init.call(this), this.push = function(i) { var o, n = 0,
                    s = 188; for (e ? ((o = new Uint8Array(i.byteLength + e)).set(t.subarray(0, e)), o.set(i, e), e = 0) : o = i; s < o.byteLength;) 71 !== o[n] || 71 !== o[s] ? (n++, s++) : (this.trigger("data", o.subarray(n, s)), n += 188, s += 188);
                n < o.byteLength && (t.set(o.subarray(n), 0), e = o.byteLength - n) }, this.flush = function() { 188 === e && 71 === t[0] && (this.trigger("data", t), e = 0), this.trigger("done") } }).prototype = new ha, (Ya = function() { var t, e, i, o;
            Ya.prototype.init.call(this), (o = this).packetsWaitingForPmt = [], this.programMapTable = void 0, t = function(t, o) { var n = 0;
                o.payloadUnitStartIndicator && (n += t[n] + 1), "pat" === o.type ? e(t.subarray(n), o) : i(t.subarray(n), o) }, e = function(t, e) { e.section_number = t[7], e.last_section_number = t[8], o.pmtPid = (31 & t[10]) << 8 | t[11], e.pmtPid = o.pmtPid }, i = function(t, e) { var i, n; if (1 & t[5]) { for (o.programMapTable = { video: null, audio: null, "timed-metadata": {} }, i = 3 + ((15 & t[1]) << 8 | t[2]) - 4, n = 12 + ((15 & t[10]) << 8 | t[11]); n < i;) { var s = t[n],
                            r = (31 & t[n + 1]) << 8 | t[n + 2];
                        s === Va.H264_STREAM_TYPE && null === o.programMapTable.video ? o.programMapTable.video = r : s === Va.ADTS_STREAM_TYPE && null === o.programMapTable.audio ? o.programMapTable.audio = r : s === Va.METADATA_STREAM_TYPE && (o.programMapTable["timed-metadata"][r] = s), n += 5 + ((15 & t[n + 3]) << 8 | t[n + 4]) } e.programMapTable = o.programMapTable } }, this.push = function(e) { var i = {},
                    o = 4; if (i.payloadUnitStartIndicator = !!(64 & e[1]), i.pid = 31 & e[1], i.pid <<= 8, i.pid |= e[2], 1 < (48 & e[3]) >>> 4 && (o += e[o] + 1), 0 === i.pid) i.type = "pat", t(e.subarray(o), i), this.trigger("data", i);
                else if (i.pid === this.pmtPid)
                    for (i.type = "pmt", t(e.subarray(o), i), this.trigger("data", i); this.packetsWaitingForPmt.length;) this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
                else void 0 === this.programMapTable ? this.packetsWaitingForPmt.push([e, o, i]) : this.processPes_(e, o, i) }, this.processPes_ = function(t, e, i) { i.pid === this.programMapTable.video ? i.streamType = Va.H264_STREAM_TYPE : i.pid === this.programMapTable.audio ? i.streamType = Va.ADTS_STREAM_TYPE : i.streamType = this.programMapTable["timed-metadata"][i.pid], i.type = "pes", i.data = t.subarray(e), this.trigger("data", i) } }).prototype = new ha, Ya.STREAM_TYPES = { h264: 27, adts: 15 }, (Ka = function() { var t = this,
                e = { data: [], size: 0 },
                i = { data: [], size: 0 },
                o = { data: [], size: 0 },
                n = function(e, i, o) { var n, s, r = new Uint8Array(e.size),
                        a = { type: i },
                        h = 0,
                        l = 0; if (e.data.length && !(e.size < 9)) { for (a.trackId = e.data[0].pid, h = 0; h < e.data.length; h++) s = e.data[h], r.set(s.data, l), l += s.data.byteLength; var c, d, u;
                        c = r, (d = a).packetLength = 6 + (c[4] << 8 | c[5]), d.dataAlignmentIndicator = 0 != (4 & c[6]), 192 & (u = c[7]) && (d.pts = (14 & c[9]) << 27 | (255 & c[10]) << 20 | (254 & c[11]) << 12 | (255 & c[12]) << 5 | (254 & c[13]) >>> 3, d.pts *= 4, d.pts += (6 & c[13]) >>> 1, d.dts = d.pts, 64 & u && (d.dts = (14 & c[14]) << 27 | (255 & c[15]) << 20 | (254 & c[16]) << 12 | (255 & c[17]) << 5 | (254 & c[18]) >>> 3, d.dts *= 4, d.dts += (6 & c[18]) >>> 1)), d.data = c.subarray(9 + c[8]), n = "video" === i || a.packetLength <= e.size, (o || n) && (e.size = 0, e.data.length = 0), n && t.trigger("data", a) } };
            Ka.prototype.init.call(this), this.push = function(s) {
                ({ pat: function() {}, pes: function() { var t, r; switch (s.streamType) {
                            case Va.H264_STREAM_TYPE:
                            case Va.H264_STREAM_TYPE:
                                t = e, r = "video"; break;
                            case Va.ADTS_STREAM_TYPE:
                                t = i, r = "audio"; break;
                            case Va.METADATA_STREAM_TYPE:
                                t = o, r = "timed-metadata"; break;
                            default:
                                return } s.payloadUnitStartIndicator && n(t, r, !0), t.data.push(s), t.size += s.data.byteLength }, pmt: function() { var e = { type: "metadata", tracks: [] },
                            i = s.programMapTable;
                        null !== i.video && e.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +i.video, codec: "avc", type: "video" }), null !== i.audio && e.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +i.audio, codec: "adts", type: "audio" }), t.trigger("data", e) } })[s.type]() }, this.flush = function() { n(e, "video"), n(i, "audio"), n(o, "timed-metadata"), this.trigger("done") } }).prototype = new ha; var $a = { PAT_PID: 0, MP2T_PACKET_LENGTH: 188, TransportPacketStream: qa, TransportParseStream: Ya, ElementaryStream: Ka, TimestampRolloverStream: Qa, CaptionStream: Fa.CaptionStream, Cea608Stream: Fa.Cea608Stream, MetadataStream: Za }; for (var th in Va) Va.hasOwnProperty(th) && ($a[th] = Va[th]); var eh, ih = $a,
            oh = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
        (eh = function() { var t;
            eh.prototype.init.call(this), this.push = function(e) { var i, o, n, s, r, a, h = 0,
                    l = 0; if ("audio" === e.type)
                    for (t ? (s = t, (t = new Uint8Array(s.byteLength + e.data.byteLength)).set(s), t.set(e.data, s.byteLength)) : t = e.data; h + 5 < t.length;)
                        if (255 === t[h] && 240 == (246 & t[h + 1])) { if (o = 2 * (1 & ~t[h + 1]), i = (3 & t[h + 3]) << 11 | t[h + 4] << 3 | (224 & t[h + 5]) >> 5, a = 9e4 * (r = 1024 * (1 + (3 & t[h + 6]))) / oh[(60 & t[h + 2]) >>> 2], n = h + i, t.byteLength < n) return; if (this.trigger("data", { pts: e.pts + l * a, dts: e.dts + l * a, sampleCount: r, audioobjecttype: 1 + (t[h + 2] >>> 6 & 3), channelcount: (1 & t[h + 2]) << 2 | (192 & t[h + 3]) >>> 6, samplerate: oh[(60 & t[h + 2]) >>> 2], samplingfrequencyindex: (60 & t[h + 2]) >>> 2, samplesize: 16, data: t.subarray(h + 7 + o, n) }), t.byteLength === n) return void(t = void 0);
                            l++, t = t.subarray(n) } else h++ }, this.flush = function() { this.trigger("done") } }).prototype = new ha; var nh, sh, rh, ah = eh,
            hh = function(t) { var e = t.byteLength,
                    i = 0,
                    o = 0;
                this.length = function() { return 8 * e }, this.bitsAvailable = function() { return 8 * e + o }, this.loadWord = function() { var n = t.byteLength - e,
                        s = new Uint8Array(4),
                        r = Math.min(4, e); if (0 === r) throw new Error("no bytes available");
                    s.set(t.subarray(n, n + r)), i = new DataView(s.buffer).getUint32(0), o = 8 * r, e -= r }, this.skipBits = function(t) { var n;
                    t < o || (t -= o, t -= 8 * (n = Math.floor(t / 8)), e -= n, this.loadWord()), i <<= t, o -= t }, this.readBits = function(t) { var n = Math.min(o, t),
                        s = i >>> 32 - n; return 0 < (o -= n) ? i <<= n : 0 < e && this.loadWord(), 0 < (n = t - n) ? s << n | this.readBits(n) : s }, this.skipLeadingZeros = function() { var t; for (t = 0; t < o; ++t)
                        if (0 != (i & 2147483648 >>> t)) return i <<= t, o -= t, t; return this.loadWord(), t + this.skipLeadingZeros() }, this.skipUnsignedExpGolomb = function() { this.skipBits(1 + this.skipLeadingZeros()) }, this.skipExpGolomb = function() { this.skipBits(1 + this.skipLeadingZeros()) }, this.readUnsignedExpGolomb = function() { var t = this.skipLeadingZeros(); return this.readBits(t + 1) - 1 }, this.readExpGolomb = function() { var t = this.readUnsignedExpGolomb(); return 1 & t ? 1 + t >>> 1 : -1 * (t >>> 1) }, this.readBoolean = function() { return 1 === this.readBits(1) }, this.readUnsignedByte = function() { return this.readBits(8) }, this.loadWord() };
        (sh = function() { var t, e, i = 0;
            sh.prototype.init.call(this), this.push = function(o) { var n; for (e = e ? ((n = new Uint8Array(e.byteLength + o.data.byteLength)).set(e), n.set(o.data, e.byteLength), n) : o.data; i < e.byteLength - 3; i++)
                    if (1 === e[i + 2]) { t = i + 5; break } for (; t < e.byteLength;) switch (e[t]) {
                    case 0:
                        if (0 !== e[t - 1]) { t += 2; break } if (0 !== e[t - 2]) { t++; break } for (i + 3 !== t - 2 && this.trigger("data", e.subarray(i + 3, t - 2)); 1 !== e[++t] && t < e.length;);
                        i = t - 2, t += 3; break;
                    case 1:
                        if (0 !== e[t - 1] || 0 !== e[t - 2]) { t += 3; break } this.trigger("data", e.subarray(i + 3, t - 2)), i = t - 2, t += 3; break;
                    default:
                        t += 3 } e = e.subarray(i), t -= i, i = 0 }, this.flush = function() { e && 3 < e.byteLength && this.trigger("data", e.subarray(i + 3)), e = null, i = 0, this.trigger("done") } }).prototype = new ha, rh = { 100: !0, 110: !0, 122: !0, 244: !0, 44: !0, 83: !0, 86: !0, 118: !0, 128: !0, 138: !0, 139: !0, 134: !0 }, (nh = function() { var t, e, i, o, n, s, r, a = new sh;
            nh.prototype.init.call(this), (t = this).push = function(t) { "video" === t.type && (e = t.trackId, i = t.pts, o = t.dts, a.push(t)) }, a.on("data", function(r) { var a = { trackId: e, pts: i, dts: o, data: r }; switch (31 & r[0]) {
                    case 5:
                        a.nalUnitType = "slice_layer_without_partitioning_rbsp_idr"; break;
                    case 6:
                        a.nalUnitType = "sei_rbsp", a.escapedRBSP = n(r.subarray(1)); break;
                    case 7:
                        a.nalUnitType = "seq_parameter_set_rbsp", a.escapedRBSP = n(r.subarray(1)), a.config = s(a.escapedRBSP); break;
                    case 8:
                        a.nalUnitType = "pic_parameter_set_rbsp"; break;
                    case 9:
                        a.nalUnitType = "access_unit_delimiter_rbsp" } t.trigger("data", a) }), a.on("done", function() { t.trigger("done") }), this.flush = function() { a.flush() }, r = function(t, e) { var i, o = 8,
                    n = 8; for (i = 0; i < t; i++) 0 !== n && (n = (o + e.readExpGolomb() + 256) % 256), o = 0 === n ? o : n }, n = function(t) { for (var e, i, o = t.byteLength, n = [], s = 1; s < o - 2;) 0 === t[s] && 0 === t[s + 1] && 3 === t[s + 2] ? (n.push(s + 2), s += 2) : s++; if (0 === n.length) return t;
                e = o - n.length, i = new Uint8Array(e); var r = 0; for (s = 0; s < e; r++, s++) r === n[0] && (r++, n.shift()), i[s] = t[r]; return i }, s = function(t) { var e, i, o, n, s, a, h, l, c, d, u, p, m, f = 0,
                    y = 0,
                    b = 0,
                    g = 0,
                    _ = 1; if (i = (e = new hh(t)).readUnsignedByte(), n = e.readUnsignedByte(), o = e.readUnsignedByte(), e.skipUnsignedExpGolomb(), rh[i] && (3 === (s = e.readUnsignedExpGolomb()) && e.skipBits(1), e.skipUnsignedExpGolomb(), e.skipUnsignedExpGolomb(), e.skipBits(1), e.readBoolean()))
                    for (u = 3 !== s ? 8 : 12, m = 0; m < u; m++) e.readBoolean() && r(m < 6 ? 16 : 64, e); if (e.skipUnsignedExpGolomb(), 0 === (a = e.readUnsignedExpGolomb())) e.readUnsignedExpGolomb();
                else if (1 === a)
                    for (e.skipBits(1), e.skipExpGolomb(), e.skipExpGolomb(), h = e.readUnsignedExpGolomb(), m = 0; m < h; m++) e.skipExpGolomb(); if (e.skipUnsignedExpGolomb(), e.skipBits(1), l = e.readUnsignedExpGolomb(), c = e.readUnsignedExpGolomb(), 0 === (d = e.readBits(1)) && e.skipBits(1), e.skipBits(1), e.readBoolean() && (f = e.readUnsignedExpGolomb(), y = e.readUnsignedExpGolomb(), b = e.readUnsignedExpGolomb(), g = e.readUnsignedExpGolomb()), e.readBoolean() && e.readBoolean()) { switch (e.readUnsignedByte()) {
                        case 1:
                            p = [1, 1]; break;
                        case 2:
                            p = [12, 11]; break;
                        case 3:
                            p = [10, 11]; break;
                        case 4:
                            p = [16, 11]; break;
                        case 5:
                            p = [40, 33]; break;
                        case 6:
                            p = [24, 11]; break;
                        case 7:
                            p = [20, 11]; break;
                        case 8:
                            p = [32, 11]; break;
                        case 9:
                            p = [80, 33]; break;
                        case 10:
                            p = [18, 11]; break;
                        case 11:
                            p = [15, 11]; break;
                        case 12:
                            p = [64, 33]; break;
                        case 13:
                            p = [160, 99]; break;
                        case 14:
                            p = [4, 3]; break;
                        case 15:
                            p = [3, 2]; break;
                        case 16:
                            p = [2, 1]; break;
                        case 255:
                            p = [e.readUnsignedByte() << 8 | e.readUnsignedByte(), e.readUnsignedByte() << 8 | e.readUnsignedByte()] } p && (_ = p[0] / p[1]) } return { profileIdc: i, levelIdc: o, profileCompatibility: n, width: Math.ceil((16 * (l + 1) - 2 * f - 2 * y) * _), height: (2 - d) * (c + 1) * 16 - 2 * b - 2 * g } } }).prototype = new ha; var lh, ch = { H264Stream: nh, NalByteStream: sh },
            dh = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350],
            uh = function(t) { return t[0] << 21 | t[1] << 14 | t[2] << 7 | t[3] },
            ph = { isLikelyAacData: function(t) { return t[0] === "I".charCodeAt(0) && t[1] === "D".charCodeAt(0) && t[2] === "3".charCodeAt(0) }, parseId3TagSize: function(t, e) { var i = t[e + 6] << 21 | t[e + 7] << 14 | t[e + 8] << 7 | t[e + 9]; return (16 & t[e + 5]) >> 4 ? i + 20 : i + 10 }, parseAdtsSize: function(t, e) { var i = (224 & t[e + 5]) >> 5,
                        o = t[e + 4] << 3; return 6144 & t[e + 3] | o | i }, parseType: function(t, e) { return t[e] === "I".charCodeAt(0) && t[e + 1] === "D".charCodeAt(0) && t[e + 2] === "3".charCodeAt(0) ? "timed-metadata" : !0 & t[e] && 240 == (240 & t[e + 1]) ? "audio" : null }, parseSampleRate: function(t) { for (var e = 0; e + 5 < t.length;) { if (255 === t[e] && 240 == (246 & t[e + 1])) return dh[(60 & t[e + 2]) >>> 2];
                        e++ } return null }, parseAacTimestamp: function(t) { var e, i, o;
                    e = 10, 64 & t[5] && (e += 4, e += uh(t.subarray(10, 14)));
                    do { if ((i = uh(t.subarray(e + 4, e + 8))) < 1) return null; if ("PRIV" === String.fromCharCode(t[e], t[e + 1], t[e + 2], t[e + 3])) { o = t.subarray(e + 10, e + i + 10); for (var n = 0; n < o.byteLength; n++)
                                if (0 === o[n]) { if ("com.apple.streaming.transportStreamTimestamp" !== unescape(function(t, e, i) { var o, n = ""; for (o = 0; o < i; o++) n += "%" + ("00" + t[o].toString(16)).slice(-2); return n }(o, 0, n))) break; var s = o.subarray(n + 1),
                                        r = (1 & s[3]) << 30 | s[4] << 22 | s[5] << 14 | s[6] << 6 | s[7] >>> 2; return r *= 4, r += 3 & s[7] } } e += 10, e += i } while (e < t.byteLength); return null } };
        (lh = function() { var t = new Uint8Array,
                e = 0;
            lh.prototype.init.call(this), this.setTimestamp = function(t) { e = t }, this.push = function(i) { var o, n, s, r, a = 0,
                    h = 0; for (t.length ? (r = t.length, (t = new Uint8Array(i.byteLength + r)).set(t.subarray(0, r)), t.set(i, r)) : t = i; 3 <= t.length - h;)
                    if (t[h] !== "I".charCodeAt(0) || t[h + 1] !== "D".charCodeAt(0) || t[h + 2] !== "3".charCodeAt(0))
                        if (255 != (255 & t[h]) || 240 != (240 & t[h + 1])) h++;
                        else { if (t.length - h < 7) break; if (h + (a = ph.parseAdtsSize(t, h)) > t.length) break;
                            s = { type: "audio", data: t.subarray(h, h + a), pts: e, dts: e }, this.trigger("data", s), h += a } else { if (t.length - h < 10) break; if (h + (a = ph.parseId3TagSize(t, h)) > t.length) break;
                    n = { type: "timed-metadata", data: t.subarray(h, h + a) }, this.trigger("data", n), h += a } o = t.length - h, t = 0 < o ? t.subarray(h) : new Uint8Array } }).prototype = new ha; var mh, fh, yh, bh, gh = lh,
            _h = ch.H264Stream,
            vh = ph.isLikelyAacData,
            xh = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"],
            Sh = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility"],
            Ch = function(t, e) { var i; if (t.length !== e.length) return !1; for (i = 0; i < t.length; i++)
                    if (t[i] !== e[i]) return !1; return !0 };
        (fh = function(t, e) { var i = [],
                o = 0,
                n = 0,
                s = 0,
                r = 1 / 0;
            e = e || {}, fh.prototype.init.call(this), this.push = function(e) { Pa(t, e), t && xh.forEach(function(i) { t[i] = e[i] }), i.push(e) }, this.setEarliestDts = function(e) { n = e - t.timelineStartInfo.baseMediaDecodeTime }, this.setVideoBaseMediaDecodeTime = function(t) { r = t }, this.setAudioAppendStart = function(t) { s = t }, this.flush = function() { var a, h, l, c;
                0 !== i.length && (a = Sa(i, t, n), t.baseMediaDecodeTime = Ta(t, e.keepOriginalTimestamps), xa(t, a, s, r), t.samples = Ca(a), l = $r.mdat(wa(a)), i = [], h = $r.moof(o, [t]), c = new Uint8Array(h.byteLength + l.byteLength), o++, c.set(h), c.set(l, h.byteLength), Aa(t), this.trigger("data", { track: t, boxes: c })), this.trigger("done", "AudioSegmentStream") } }).prototype = new ha, (mh = function(t, e) { var i, o, n = 0,
                s = [],
                r = [];
            e = e || {}, mh.prototype.init.call(this), delete t.minPTS, this.gopCache_ = [], this.push = function(e) { Pa(t, e), "seq_parameter_set_rbsp" !== e.nalUnitType || i || (i = e.config, t.sps = [e.data], Sh.forEach(function(e) { t[e] = i[e] }, this)), "pic_parameter_set_rbsp" !== e.nalUnitType || o || (o = e.data, t.pps = [e.data]), s.push(e) }, this.flush = function() { for (var i, o, a, h, l, c; s.length && "access_unit_delimiter_rbsp" !== s[0].nalUnitType;) s.shift(); if (0 === s.length) return this.resetStream_(), void this.trigger("done", "VideoSegmentStream"); if (i = la(s), (a = ca(i))[0][0].keyFrame || ((o = this.getGopForFusion_(s[0], t)) ? (a.unshift(o), a.byteLength += o.byteLength, a.nalCount += o.nalCount, a.pts = o.pts, a.dts = o.dts, a.duration += o.duration) : a = da(a)), r.length) { var d; if (!(d = e.alignGopsAtEnd ? this.alignGopsAtEnd_(a) : this.alignGopsAtStart_(a))) return this.gopCache_.unshift({ gop: a.pop(), pps: t.pps, sps: t.sps }), this.gopCache_.length = Math.min(6, this.gopCache_.length), s = [], this.resetStream_(), void this.trigger("done", "VideoSegmentStream");
                    Aa(t), a = d } Pa(t, a), t.samples = ua(a), l = $r.mdat(pa(a)), t.baseMediaDecodeTime = Ta(t, e.keepOriginalTimestamps), this.trigger("processedGopsInfo", a.map(function(t) { return { pts: t.pts, dts: t.dts, byteLength: t.byteLength } })), this.gopCache_.unshift({ gop: a.pop(), pps: t.pps, sps: t.sps }), this.gopCache_.length = Math.min(6, this.gopCache_.length), s = [], this.trigger("baseMediaDecodeTime", t.baseMediaDecodeTime), this.trigger("timelineStartInfo", t.timelineStartInfo), h = $r.moof(n, [t]), c = new Uint8Array(h.byteLength + l.byteLength), n++, c.set(h), c.set(l, h.byteLength), this.trigger("data", { track: t, boxes: c }), this.resetStream_(), this.trigger("done", "VideoSegmentStream") }, this.resetStream_ = function() { Aa(t), o = i = void 0 }, this.getGopForFusion_ = function(e) { var i, o, n, s, r, a = 1 / 0; for (r = 0; r < this.gopCache_.length; r++) n = (s = this.gopCache_[r]).gop, t.pps && Ch(t.pps[0], s.pps[0]) && t.sps && Ch(t.sps[0], s.sps[0]) && (n.dts < t.timelineStartInfo.dts || -1e4 <= (i = e.dts - n.dts - n.duration) && i <= 45e3 && (!o || i < a) && (o = s, a = i)); return o ? o.gop : null }, this.alignGopsAtStart_ = function(t) { var e, i, o, n, s, a, h, l; for (s = t.byteLength, a = t.nalCount, h = t.duration, e = i = 0; e < r.length && i < t.length && (o = r[e], n = t[i], o.pts !== n.pts);) n.pts > o.pts ? e++ : (i++, s -= n.byteLength, a -= n.nalCount, h -= n.duration); return 0 === i ? t : i === t.length ? null : ((l = t.slice(i)).byteLength = s, l.duration = h, l.nalCount = a, l.pts = l[0].pts, l.dts = l[0].dts, l) }, this.alignGopsAtEnd_ = function(t) { var e, i, o, n, s, a, h; for (e = r.length - 1, i = t.length - 1, s = null, a = !1; 0 <= e && 0 <= i;) { if (o = r[e], n = t[i], o.pts === n.pts) { a = !0; break } o.pts > n.pts ? e-- : (e === r.length - 1 && (s = i), i--) } if (!a && null === s) return null; if (0 === (h = a ? i : s)) return t; var l = t.slice(h),
                    c = l.reduce(function(t, e) { return t.byteLength += e.byteLength, t.duration += e.duration, t.nalCount += e.nalCount, t }, { byteLength: 0, duration: 0, nalCount: 0 }); return l.byteLength = c.byteLength, l.duration = c.duration, l.nalCount = c.nalCount, l.pts = l[0].pts, l.dts = l[0].dts, l }, this.alignGopsWith = function(t) { r = t } }).prototype = new ha, (bh = function(t, e) { this.numberOfTracks = 0, this.metadataStream = e, void 0 !== (t = t || {}).remux ? this.remuxTracks = !!t.remux : this.remuxTracks = !0, "boolean" == typeof t.keepOriginalTimestamps && (this.keepOriginalTimestamps = t.keepOriginalTimestamps), this.pendingTracks = [], this.videoTrack = null, this.pendingBoxes = [], this.pendingCaptions = [], this.pendingMetadata = [], this.pendingBytes = 0, this.emittedTracks = 0, bh.prototype.init.call(this), this.push = function(t) { return t.text ? this.pendingCaptions.push(t) : t.frames ? this.pendingMetadata.push(t) : (this.pendingTracks.push(t.track), this.pendingBoxes.push(t.boxes), this.pendingBytes += t.boxes.byteLength, "video" === t.track.type && (this.videoTrack = t.track), void("audio" === t.track.type && (this.audioTrack = t.track))) } }).prototype = new ha, bh.prototype.flush = function(t) { var e, i, o, n, s = 0,
                r = { captions: [], captionStreams: {}, metadata: [], info: {} },
                a = 0; if (this.pendingTracks.length < this.numberOfTracks) { if ("VideoSegmentStream" !== t && "AudioSegmentStream" !== t) return; if (this.remuxTracks) return; if (0 === this.pendingTracks.length) return void(++this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0)) } for (this.videoTrack ? (a = this.videoTrack.timelineStartInfo.pts, Sh.forEach(function(t) { r.info[t] = this.videoTrack[t] }, this)) : this.audioTrack && (a = this.audioTrack.timelineStartInfo.pts, xh.forEach(function(t) { r.info[t] = this.audioTrack[t] }, this)), 1 === this.pendingTracks.length ? r.type = this.pendingTracks[0].type : r.type = "combined", this.emittedTracks += this.pendingTracks.length, o = $r.initSegment(this.pendingTracks), r.initSegment = new Uint8Array(o.byteLength), r.initSegment.set(o), r.data = new Uint8Array(this.pendingBytes), n = 0; n < this.pendingBoxes.length; n++) r.data.set(this.pendingBoxes[n], s), s += this.pendingBoxes[n].byteLength; for (n = 0; n < this.pendingCaptions.length; n++)(e = this.pendingCaptions[n]).startTime = e.startPts, this.keepOriginalTimestamps || (e.startTime -= a), e.startTime /= 9e4, e.endTime = e.endPts, this.keepOriginalTimestamps || (e.endTime -= a), e.endTime /= 9e4, r.captionStreams[e.stream] = !0, r.captions.push(e); for (n = 0; n < this.pendingMetadata.length; n++)(i = this.pendingMetadata[n]).cueTime = i.pts, this.keepOriginalTimestamps || (i.cueTime -= a), i.cueTime /= 9e4, r.metadata.push(i);
            r.metadata.dispatchType = this.metadataStream.dispatchType, this.pendingTracks.length = 0, this.videoTrack = null, this.pendingBoxes.length = 0, this.pendingCaptions.length = 0, this.pendingBytes = 0, this.pendingMetadata.length = 0, this.trigger("data", r), this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0) }, (yh = function(t) { var e, i, o = this,
                n = !0;
            yh.prototype.init.call(this), t = t || {}, this.baseMediaDecodeTime = t.baseMediaDecodeTime || 0, this.transmuxPipeline_ = {}, this.setupAacPipeline = function() { var e = {};
                (this.transmuxPipeline_ = e).type = "aac", e.metadataStream = new ih.MetadataStream, e.aacStream = new gh, e.audioTimestampRolloverStream = new ih.TimestampRolloverStream("audio"), e.timedMetadataTimestampRolloverStream = new ih.TimestampRolloverStream("timed-metadata"), e.adtsStream = new ah, e.coalesceStream = new bh(t, e.metadataStream), e.headOfPipeline = e.aacStream, e.aacStream.pipe(e.audioTimestampRolloverStream).pipe(e.adtsStream), e.aacStream.pipe(e.timedMetadataTimestampRolloverStream).pipe(e.metadataStream).pipe(e.coalesceStream), e.metadataStream.on("timestamp", function(t) { e.aacStream.setTimestamp(t.timeStamp) }), e.aacStream.on("data", function(n) { "timed-metadata" !== n.type || e.audioSegmentStream || (i = i || { timelineStartInfo: { baseMediaDecodeTime: o.baseMediaDecodeTime }, codec: "adts", type: "audio" }, e.coalesceStream.numberOfTracks++, e.audioSegmentStream = new fh(i, t), e.adtsStream.pipe(e.audioSegmentStream).pipe(e.coalesceStream)) }), e.coalesceStream.on("data", this.trigger.bind(this, "data")), e.coalesceStream.on("done", this.trigger.bind(this, "done")) }, this.setupTsPipeline = function() { var n = {};
                (this.transmuxPipeline_ = n).type = "ts", n.metadataStream = new ih.MetadataStream, n.packetStream = new ih.TransportPacketStream, n.parseStream = new ih.TransportParseStream, n.elementaryStream = new ih.ElementaryStream, n.videoTimestampRolloverStream = new ih.TimestampRolloverStream("video"), n.audioTimestampRolloverStream = new ih.TimestampRolloverStream("audio"), n.timedMetadataTimestampRolloverStream = new ih.TimestampRolloverStream("timed-metadata"), n.adtsStream = new ah, n.h264Stream = new _h, n.captionStream = new ih.CaptionStream, n.coalesceStream = new bh(t, n.metadataStream), n.headOfPipeline = n.packetStream, n.packetStream.pipe(n.parseStream).pipe(n.elementaryStream), n.elementaryStream.pipe(n.videoTimestampRolloverStream).pipe(n.h264Stream), n.elementaryStream.pipe(n.audioTimestampRolloverStream).pipe(n.adtsStream), n.elementaryStream.pipe(n.timedMetadataTimestampRolloverStream).pipe(n.metadataStream).pipe(n.coalesceStream), n.h264Stream.pipe(n.captionStream).pipe(n.coalesceStream), n.elementaryStream.on("data", function(s) { var r; if ("metadata" === s.type) { for (r = s.tracks.length; r--;) e || "video" !== s.tracks[r].type ? i || "audio" !== s.tracks[r].type || ((i = s.tracks[r]).timelineStartInfo.baseMediaDecodeTime = o.baseMediaDecodeTime) : (e = s.tracks[r]).timelineStartInfo.baseMediaDecodeTime = o.baseMediaDecodeTime;
                        e && !n.videoSegmentStream && (n.coalesceStream.numberOfTracks++, n.videoSegmentStream = new mh(e, t), n.videoSegmentStream.on("timelineStartInfo", function(t) { i && (i.timelineStartInfo = t, n.audioSegmentStream.setEarliestDts(t.dts)) }), n.videoSegmentStream.on("processedGopsInfo", o.trigger.bind(o, "gopInfo")), n.videoSegmentStream.on("baseMediaDecodeTime", function(t) { i && n.audioSegmentStream.setVideoBaseMediaDecodeTime(t) }), n.h264Stream.pipe(n.videoSegmentStream).pipe(n.coalesceStream)), i && !n.audioSegmentStream && (n.coalesceStream.numberOfTracks++, n.audioSegmentStream = new fh(i, t), n.adtsStream.pipe(n.audioSegmentStream).pipe(n.coalesceStream)) } }), n.coalesceStream.on("data", this.trigger.bind(this, "data")), n.coalesceStream.on("done", this.trigger.bind(this, "done")) }, this.setBaseMediaDecodeTime = function(o) { var n = this.transmuxPipeline_;
                t.keepOriginalTimestamps || (this.baseMediaDecodeTime = o), i && (i.timelineStartInfo.dts = void 0, i.timelineStartInfo.pts = void 0, Aa(i), t.keepOriginalTimestamps || (i.timelineStartInfo.baseMediaDecodeTime = o), n.audioTimestampRolloverStream && n.audioTimestampRolloverStream.discontinuity()), e && (n.videoSegmentStream && (n.videoSegmentStream.gopCache_ = [], n.videoTimestampRolloverStream.discontinuity()), e.timelineStartInfo.dts = void 0, e.timelineStartInfo.pts = void 0, Aa(e), n.captionStream.reset(), t.keepOriginalTimestamps || (e.timelineStartInfo.baseMediaDecodeTime = o)), n.timedMetadataTimestampRolloverStream && n.timedMetadataTimestampRolloverStream.discontinuity() }, this.setAudioAppendStart = function(t) { i && this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(t) }, this.alignGopsWith = function(t) { e && this.transmuxPipeline_.videoSegmentStream && this.transmuxPipeline_.videoSegmentStream.alignGopsWith(t) }, this.push = function(t) { if (n) { var e = vh(t);
                    e && "aac" !== this.transmuxPipeline_.type ? this.setupAacPipeline() : e || "ts" === this.transmuxPipeline_.type || this.setupTsPipeline(), n = !1 } this.transmuxPipeline_.headOfPipeline.push(t) }, this.flush = function() { n = !0, this.transmuxPipeline_.headOfPipeline.flush() }, this.resetCaptions = function() { this.transmuxPipeline_.captionStream && this.transmuxPipeline_.captionStream.reset() } }).prototype = new ha; var wh, Ah, Th = { Transmuxer: yh, VideoSegmentStream: mh, AudioSegmentStream: fh, AUDIO_PROPERTIES: xh, VIDEO_PROPERTIES: Sh },
            Ph = Zr.parseType,
            kh = function(t) { return new Date(1e3 * t - 20828448e5) },
            Mh = function(t) { return { isLeading: (12 & t[0]) >>> 2, dependsOn: 3 & t[0], isDependedOn: (192 & t[1]) >>> 6, hasRedundancy: (48 & t[1]) >>> 4, paddingValue: (14 & t[1]) >>> 1, isNonSyncSample: 1 & t[1], degradationPriority: t[2] << 8 | t[3] } },
            Eh = { avc1: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength); return { dataReferenceIndex: e.getUint16(6), width: e.getUint16(24), height: e.getUint16(26), horizresolution: e.getUint16(28) + e.getUint16(30) / 16, vertresolution: e.getUint16(32) + e.getUint16(34) / 16, frameCount: e.getUint16(40), depth: e.getUint16(74), config: wh(t.subarray(78, t.byteLength)) } }, avcC: function(t) { var e, i, o, n, s = new DataView(t.buffer, t.byteOffset, t.byteLength),
                        r = { configurationVersion: t[0], avcProfileIndication: t[1], profileCompatibility: t[2], avcLevelIndication: t[3], lengthSizeMinusOne: 3 & t[4], sps: [], pps: [] },
                        a = 31 & t[5]; for (o = 6, n = 0; n < a; n++) i = s.getUint16(o), o += 2, r.sps.push(new Uint8Array(t.subarray(o, o + i))), o += i; for (e = t[o], o++, n = 0; n < e; n++) i = s.getUint16(o), o += 2, r.pps.push(new Uint8Array(t.subarray(o, o + i))), o += i; return r }, btrt: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength); return { bufferSizeDB: e.getUint32(0), maxBitrate: e.getUint32(4), avgBitrate: e.getUint32(8) } }, esds: function(t) { return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), esId: t[6] << 8 | t[7], streamPriority: 31 & t[8], decoderConfig: { objectProfileIndication: t[11], streamType: t[12] >>> 2 & 63, bufferSize: t[13] << 16 | t[14] << 8 | t[15], maxBitrate: t[16] << 24 | t[17] << 16 | t[18] << 8 | t[19], avgBitrate: t[20] << 24 | t[21] << 16 | t[22] << 8 | t[23], decoderConfigDescriptor: { tag: t[24], length: t[25], audioObjectType: t[26] >>> 3 & 31, samplingFrequencyIndex: (7 & t[26]) << 1 | t[27] >>> 7 & 1, channelConfiguration: t[27] >>> 3 & 15 } } } }, ftyp: function(t) { for (var e = new DataView(t.buffer, t.byteOffset, t.byteLength), i = { majorBrand: Ph(t.subarray(0, 4)), minorVersion: e.getUint32(4), compatibleBrands: [] }, o = 8; o < t.byteLength;) i.compatibleBrands.push(Ph(t.subarray(o, o + 4))), o += 4; return i }, dinf: function(t) { return { boxes: wh(t) } }, dref: function(t) { return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), dataReferences: wh(t.subarray(8)) } }, hdlr: function(t) { var e = { version: new DataView(t.buffer, t.byteOffset, t.byteLength).getUint8(0), flags: new Uint8Array(t.subarray(1, 4)), handlerType: Ph(t.subarray(8, 12)), name: "" },
                        i = 8; for (i = 24; i < t.byteLength; i++) { if (0 === t[i]) { i++; break } e.name += String.fromCharCode(t[i]) } return e.name = decodeURIComponent(escape(e.name)), e }, mdat: function(t) { return { byteLength: t.byteLength, nals: function(t) { var e, i, o = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                n = []; for (e = 0; e + 4 < t.length; e += i)
                                if (i = o.getUint32(e), e += 4, i <= 0) n.push("<span style='color:red;'>MALFORMED DATA</span>");
                                else switch (31 & t[e]) {
                                    case 1:
                                        n.push("slice_layer_without_partitioning_rbsp"); break;
                                    case 5:
                                        n.push("slice_layer_without_partitioning_rbsp_idr"); break;
                                    case 6:
                                        n.push("sei_rbsp"); break;
                                    case 7:
                                        n.push("seq_parameter_set_rbsp"); break;
                                    case 8:
                                        n.push("pic_parameter_set_rbsp"); break;
                                    case 9:
                                        n.push("access_unit_delimiter_rbsp"); break;
                                    default:
                                        n.push("UNKNOWN NAL - " + t[e] & 31) }
                            return n }(t) } }, mdhd: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                        o = 4,
                        n = { version: i.getUint8(0), flags: new Uint8Array(t.subarray(1, 4)), language: "" }; return 1 === n.version ? (o += 4, n.creationTime = kh(i.getUint32(o)), o += 8, n.modificationTime = kh(i.getUint32(o)), o += 4, n.timescale = i.getUint32(o), o += 8) : (n.creationTime = kh(i.getUint32(o)), o += 4, n.modificationTime = kh(i.getUint32(o)), o += 4, n.timescale = i.getUint32(o), o += 4), n.duration = i.getUint32(o), o += 4, e = i.getUint16(o), n.language += String.fromCharCode(96 + (e >> 10)), n.language += String.fromCharCode(96 + ((992 & e) >> 5)), n.language += String.fromCharCode(96 + (31 & e)), n }, mdia: function(t) { return { boxes: wh(t) } }, mfhd: function(t) { return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), sequenceNumber: t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7] } }, minf: function(t) { return { boxes: wh(t) } }, mp4a: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength),
                        i = { dataReferenceIndex: e.getUint16(6), channelcount: e.getUint16(16), samplesize: e.getUint16(18), samplerate: e.getUint16(24) + e.getUint16(26) / 65536 }; return 28 < t.byteLength && (i.streamDescriptor = wh(t.subarray(28))[0]), i }, moof: function(t) { return { boxes: wh(t) } }, moov: function(t) { return { boxes: wh(t) } }, mvex: function(t) { return { boxes: wh(t) } }, mvhd: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength),
                        i = 4,
                        o = { version: e.getUint8(0), flags: new Uint8Array(t.subarray(1, 4)) }; return 1 === o.version ? (i += 4, o.creationTime = kh(e.getUint32(i)), i += 8, o.modificationTime = kh(e.getUint32(i)), i += 4, o.timescale = e.getUint32(i), i += 8) : (o.creationTime = kh(e.getUint32(i)), i += 4, o.modificationTime = kh(e.getUint32(i)), i += 4, o.timescale = e.getUint32(i), i += 4), o.duration = e.getUint32(i), i += 4, o.rate = e.getUint16(i) + e.getUint16(i + 2) / 16, i += 4, o.volume = e.getUint8(i) + e.getUint8(i + 1) / 8, i += 2, i += 2, i += 8, o.matrix = new Uint32Array(t.subarray(i, i + 36)), i += 36, i += 24, o.nextTrackId = e.getUint32(i), o }, pdin: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength); return { version: e.getUint8(0), flags: new Uint8Array(t.subarray(1, 4)), rate: e.getUint32(4), initialDelay: e.getUint32(8) } }, sdtp: function(t) { var e, i = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), samples: [] }; for (e = 4; e < t.byteLength; e++) i.samples.push({ dependsOn: (48 & t[e]) >> 4, isDependedOn: (12 & t[e]) >> 2, hasRedundancy: 3 & t[e] }); return i }, sidx: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                        o = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), references: [], referenceId: i.getUint32(4), timescale: i.getUint32(8), earliestPresentationTime: i.getUint32(12), firstOffset: i.getUint32(16) },
                        n = i.getUint16(22); for (e = 24; n; e += 12, n--) o.references.push({ referenceType: (128 & t[e]) >>> 7, referencedSize: 2147483647 & i.getUint32(e), subsegmentDuration: i.getUint32(e + 4), startsWithSap: !!(128 & t[e + 8]), sapType: (112 & t[e + 8]) >>> 4, sapDeltaTime: 268435455 & i.getUint32(e + 8) }); return o }, smhd: function(t) { return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), balance: t[4] + t[5] / 256 } }, stbl: function(t) { return { boxes: wh(t) } }, stco: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                        o = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), chunkOffsets: [] },
                        n = i.getUint32(4); for (e = 8; n; e += 4, n--) o.chunkOffsets.push(i.getUint32(e)); return o }, stsc: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                        o = i.getUint32(4),
                        n = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), sampleToChunks: [] }; for (e = 8; o; e += 12, o--) n.sampleToChunks.push({ firstChunk: i.getUint32(e), samplesPerChunk: i.getUint32(e + 4), sampleDescriptionIndex: i.getUint32(e + 8) }); return n }, stsd: function(t) { return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), sampleDescriptions: wh(t.subarray(8)) } }, stsz: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                        o = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), sampleSize: i.getUint32(4), entries: [] }; for (e = 12; e < t.byteLength; e += 4) o.entries.push(i.getUint32(e)); return o }, stts: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                        o = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), timeToSamples: [] },
                        n = i.getUint32(4); for (e = 8; n; e += 8, n--) o.timeToSamples.push({ sampleCount: i.getUint32(e), sampleDelta: i.getUint32(e + 4) }); return o }, styp: function(t) { return Eh.ftyp(t) }, tfdt: function(t) { var e = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), baseMediaDecodeTime: t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7] }; return 1 === e.version && (e.baseMediaDecodeTime *= Math.pow(2, 32), e.baseMediaDecodeTime += t[8] << 24 | t[9] << 16 | t[10] << 8 | t[11]), e }, tfhd: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                        o = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), trackId: i.getUint32(4) },
                        n = 1 & o.flags[2],
                        s = 2 & o.flags[2],
                        r = 8 & o.flags[2],
                        a = 16 & o.flags[2],
                        h = 32 & o.flags[2],
                        l = 65536 & o.flags[0],
                        c = 131072 & o.flags[0]; return e = 8, n && (e += 4, o.baseDataOffset = i.getUint32(12), e += 4), s && (o.sampleDescriptionIndex = i.getUint32(e), e += 4), r && (o.defaultSampleDuration = i.getUint32(e), e += 4), a && (o.defaultSampleSize = i.getUint32(e), e += 4), h && (o.defaultSampleFlags = i.getUint32(e)), l && (o.durationIsEmpty = !0), !n && c && (o.baseDataOffsetIsMoof = !0), o }, tkhd: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength),
                        i = 4,
                        o = { version: e.getUint8(0), flags: new Uint8Array(t.subarray(1, 4)) }; return 1 === o.version ? (i += 4, o.creationTime = kh(e.getUint32(i)), i += 8, o.modificationTime = kh(e.getUint32(i)), i += 4, o.trackId = e.getUint32(i), i += 4, i += 8) : (o.creationTime = kh(e.getUint32(i)), i += 4, o.modificationTime = kh(e.getUint32(i)), i += 4, o.trackId = e.getUint32(i), i += 4, i += 4), o.duration = e.getUint32(i), i += 4, i += 8, o.layer = e.getUint16(i), i += 2, o.alternateGroup = e.getUint16(i), i += 2, o.volume = e.getUint8(i) + e.getUint8(i + 1) / 8, i += 2, i += 2, o.matrix = new Uint32Array(t.subarray(i, i + 36)), i += 36, o.width = e.getUint16(i) + e.getUint16(i + 2) / 16, i += 4, o.height = e.getUint16(i) + e.getUint16(i + 2) / 16, o }, traf: function(t) { return { boxes: wh(t) } }, trak: function(t) { return { boxes: wh(t) } }, trex: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength); return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), trackId: e.getUint32(4), defaultSampleDescriptionIndex: e.getUint32(8), defaultSampleDuration: e.getUint32(12), defaultSampleSize: e.getUint32(16), sampleDependsOn: 3 & t[20], sampleIsDependedOn: (192 & t[21]) >> 6, sampleHasRedundancy: (48 & t[21]) >> 4, samplePaddingValue: (14 & t[21]) >> 1, sampleIsDifferenceSample: !!(1 & t[21]), sampleDegradationPriority: e.getUint16(22) } }, trun: function(t) { var e, i = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), samples: [] },
                        o = new DataView(t.buffer, t.byteOffset, t.byteLength),
                        n = 1 & i.flags[2],
                        s = 4 & i.flags[2],
                        r = 1 & i.flags[1],
                        a = 2 & i.flags[1],
                        h = 4 & i.flags[1],
                        l = 8 & i.flags[1],
                        c = o.getUint32(4),
                        d = 8; for (n && (i.dataOffset = o.getInt32(d), d += 4), s && c && (e = { flags: Mh(t.subarray(d, d + 4)) }, d += 4, r && (e.duration = o.getUint32(d), d += 4), a && (e.size = o.getUint32(d), d += 4), l && (e.compositionTimeOffset = o.getUint32(d), d += 4), i.samples.push(e), c--); c--;) e = {}, r && (e.duration = o.getUint32(d), d += 4), a && (e.size = o.getUint32(d), d += 4), h && (e.flags = Mh(t.subarray(d, d + 4)), d += 4), l && (e.compositionTimeOffset = o.getUint32(d), d += 4), i.samples.push(e); return i }, "url ": function(t) { return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)) } }, vmhd: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength); return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), graphicsmode: e.getUint16(4), opcolor: new Uint16Array([e.getUint16(6), e.getUint16(8), e.getUint16(10)]) } } },
            Bh = { inspect: wh = function(t) { for (var e, i, o, n, s, r = 0, a = [], h = new ArrayBuffer(t.length), l = new Uint8Array(h), c = 0; c < t.length; ++c) l[c] = t[c]; for (e = new DataView(h); r < t.byteLength;) i = e.getUint32(r), o = Ph(t.subarray(r + 4, r + 8)), n = 1 < i ? r + i : t.byteLength, (s = (Eh[o] || function(t) { return { data: t } })(t.subarray(r + 8, n))).size = i, s.type = o, a.push(s), r = n; return a }, textify: Ah = function(t, e) { var i; return e = e || 0, i = new Array(2 * e + 1).join(" "), t.map(function(t, o) { return i + t.type + "\n" + Object.keys(t).filter(function(t) { return "type" !== t && "boxes" !== t }).map(function(e) { var o = i + "  " + e + ": ",
                                n = t[e]; if (n instanceof Uint8Array || n instanceof Uint32Array) { var s = Array.prototype.slice.call(new Uint8Array(n.buffer, n.byteOffset, n.byteLength)).map(function(t) { return " " + ("00" + t.toString(16)).slice(-2) }).join("").match(/.{1,24}/g); return s ? 1 === s.length ? o + "<" + s.join("").slice(1) + ">" : o + "<\n" + s.map(function(t) { return i + "  " + t }).join("\n") + "\n" + i + "  >" : o + "<>" } return o + JSON.stringify(n, null, 2).split("\n").map(function(t, e) { return 0 === e ? t : i + "  " + t }).join("\n") }).join("\n") + (t.boxes ? "\n" + Ah(t.boxes, e + 1) : "") }).join("\n") }, parseTfdt: Eh.tfdt, parseHdlr: Eh.hdlr, parseTfhd: Eh.tfhd, parseTrun: Eh.trun },
            Ih = function(t) { for (var e, i, o = t.byteLength, n = [], s = 1; s < o - 2;) 0 === t[s] && 0 === t[s + 1] && 3 === t[s + 2] ? (n.push(s + 2), s += 2) : s++; if (0 === n.length) return t;
                e = o - n.length, i = new Uint8Array(e); var r = 0; for (s = 0; s < e; r++, s++) r === n[0] && (r++, n.shift()), i[s] = t[r]; return i },
            Dh = Fa.CaptionStream,
            Lh = function(t, e) { for (var i = t, o = 0; o < e.length; o++) { var n = e[o]; if (i < n.size) return n;
                    i -= n.size } return null },
            Oh = function(t, e) { var i = Zr.findBox(t, ["moof", "traf"]),
                    o = {},
                    n = []; return Zr.findBox(t, ["mdat"]).forEach(function(t, e) { var o = i[e];
                    n.push({ mdat: t, traf: o }) }), n.forEach(function(t) { var i, n, s, r, a, h, l, c, d = t.mdat,
                        u = t.traf,
                        p = Zr.findBox(u, ["tfhd"]),
                        m = Bh.parseTfhd(p[0]),
                        f = m.trackId,
                        y = Zr.findBox(u, ["tfdt"]),
                        b = 0 < y.length ? Bh.parseTfdt(y[0]).baseMediaDecodeTime : 0,
                        g = Zr.findBox(u, ["trun"]);
                    e === f && 0 < g.length && (n = g, r = b, a = (s = m).defaultSampleDuration || 0, h = s.defaultSampleSize || 0, l = s.trackId, c = [], n.forEach(function(t) { var e = Bh.parseTrun(t).samples;
                        e.forEach(function(t) { void 0 === t.duration && (t.duration = a), void 0 === t.size && (t.size = h), t.trackId = l, t.dts = r, void 0 === t.compositionTimeOffset && (t.compositionTimeOffset = 0), t.pts = r + t.compositionTimeOffset, r += t.duration }), c = c.concat(e) }), i = function(t, e, i) { var o, n, s, r, a = new DataView(t.buffer, t.byteOffset, t.byteLength),
                            h = []; for (n = 0; n + 4 < t.length; n += s)
                            if (s = a.getUint32(n), n += 4, !(s <= 0)) switch (31 & t[n]) {
                                case 6:
                                    var l = t.subarray(n + 1, n + 1 + s),
                                        c = Lh(n, e);
                                    o = { nalUnitType: "sei_rbsp", size: s, data: l, escapedRBSP: Ih(l), trackId: i }, c ? (o.pts = c.pts, o.dts = c.dts, r = c) : (o.pts = r.pts, o.dts = r.dts), h.push(o) }
                        return h }(d, c, f), o[f] || (o[f] = []), o[f] = o[f].concat(i)) }), o },
            Rh = { generator: $r, probe: Zr, Transmuxer: Th.Transmuxer, AudioSegmentStream: Th.AudioSegmentStream, VideoSegmentStream: Th.VideoSegmentStream, CaptionParser: function() { var t, e, i, o, n, s = !1;
                    this.isInitialized = function() { return s }, this.init = function() { t = new Dh, s = !0, t.on("data", function(t) { t.startTime = t.startPts / o, t.endTime = t.endPts / o, n.captions.push(t), n.captionStreams[t.stream] = !0 }) }, this.isNewInit = function(t, e) { return !(t && 0 === t.length || e && "object" == typeof e && 0 === Object.keys(e).length || i === t[0] && o === e[i]) }, this.parse = function(t, s, r) { var a, h, l, c; if (!this.isInitialized()) return null; if (!s || !r) return null; if (this.isNewInit(s, r)) i = s[0], o = r[i];
                        else if (!i || !o) return e.push(t), null; for (; 0 < e.length;) { var d = e.shift();
                            this.parse(d, s, r) } return h = t, c = o, null !== (a = (l = i) ? { seiNals: Oh(h, l)[l], timescale: c } : null) && a.seiNals ? (this.pushNals(a.seiNals), this.flushStream(), n) : null }, this.pushNals = function(e) { if (!this.isInitialized() || !e || 0 === e.length) return null;
                        e.forEach(function(e) { t.push(e) }) }, this.flushStream = function() { if (!this.isInitialized()) return null;
                        t.flush() }, this.clearParsedCaptions = function() { n.captions = [], n.captionStreams = {} }, this.resetCaptionStream = function() { if (!this.isInitialized()) return null;
                        t.reset() }, this.clearAllCaptions = function() { this.clearParsedCaptions(), this.resetCaptionStream() }, this.reset = function() { e = [], o = i = null, n ? this.clearParsedCaptions() : n = { captions: [], captionStreams: {} }, this.resetCaptionStream() }, this.reset() } }.CaptionParser,
            Fh = function(t) { var e = 31 & t[1]; return e <<= 8, e |= t[2] },
            Vh = function(t) { return !!(64 & t[1]) },
            Gh = function(t) { var e = 0; return 1 < (48 & t[3]) >>> 4 && (e += t[4] + 1), e },
            Uh = function(t) { switch (t) {
                    case 5:
                        return "slice_layer_without_partitioning_rbsp_idr";
                    case 6:
                        return "sei_rbsp";
                    case 7:
                        return "seq_parameter_set_rbsp";
                    case 8:
                        return "pic_parameter_set_rbsp";
                    case 9:
                        return "access_unit_delimiter_rbsp";
                    default:
                        return null } },
            Nh = { parseType: function(t, e) { var i = Fh(t); return 0 === i ? "pat" : i === e ? "pmt" : e ? "pes" : null }, parsePat: function(t) { var e = Vh(t),
                        i = 4 + Gh(t); return e && (i += t[i] + 1), (31 & t[i + 10]) << 8 | t[i + 11] }, parsePmt: function(t) { var e = {},
                        i = Vh(t),
                        o = 4 + Gh(t); if (i && (o += t[o] + 1), 1 & t[o + 5]) { var n;
                        n = 3 + ((15 & t[o + 1]) << 8 | t[o + 2]) - 4; for (var s = 12 + ((15 & t[o + 10]) << 8 | t[o + 11]); s < n;) { var r = o + s;
                            e[(31 & t[r + 1]) << 8 | t[r + 2]] = t[r], s += 5 + ((15 & t[r + 3]) << 8 | t[r + 4]) } return e } }, parsePayloadUnitStartIndicator: Vh, parsePesType: function(t, e) { switch (e[Fh(t)]) {
                        case Va.H264_STREAM_TYPE:
                            return "video";
                        case Va.ADTS_STREAM_TYPE:
                            return "audio";
                        case Va.METADATA_STREAM_TYPE:
                            return "timed-metadata";
                        default:
                            return null } }, parsePesTime: function(t) { if (!Vh(t)) return null; var e = 4 + Gh(t); if (e >= t.byteLength) return null; var i, o = null; return 192 & (i = t[e + 7]) && ((o = {}).pts = (14 & t[e + 9]) << 27 | (255 & t[e + 10]) << 20 | (254 & t[e + 11]) << 12 | (255 & t[e + 12]) << 5 | (254 & t[e + 13]) >>> 3, o.pts *= 4, o.pts += (6 & t[e + 13]) >>> 1, o.dts = o.pts, 64 & i && (o.dts = (14 & t[e + 14]) << 27 | (255 & t[e + 15]) << 20 | (254 & t[e + 16]) << 12 | (255 & t[e + 17]) << 5 | (254 & t[e + 18]) >>> 3, o.dts *= 4, o.dts += (6 & t[e + 18]) >>> 1)), o }, videoPacketContainsKeyFrame: function(t) { for (var e = 4 + Gh(t), i = t.subarray(e), o = 0, n = 0, s = !1; n < i.byteLength - 3; n++)
                        if (1 === i[n + 2]) { o = n + 5; break } for (; o < i.byteLength;) switch (i[o]) {
                        case 0:
                            if (0 !== i[o - 1]) { o += 2; break } if (0 !== i[o - 2]) { o++; break } for (n + 3 !== o - 2 && "slice_layer_without_partitioning_rbsp_idr" === Uh(31 & i[n + 3]) && (s = !0); 1 !== i[++o] && o < i.length;);
                            n = o - 2, o += 3; break;
                        case 1:
                            if (0 !== i[o - 1] || 0 !== i[o - 2]) { o += 3; break } "slice_layer_without_partitioning_rbsp_idr" === Uh(31 & i[n + 3]) && (s = !0), n = o - 2, o += 3; break;
                        default:
                            o += 3 }
                    return i = i.subarray(n), o -= n, n = 0, i && 3 < i.byteLength && "slice_layer_without_partitioning_rbsp_idr" === Uh(31 & i[n + 3]) && (s = !0), s } },
            jh = Wa,
            Wh = {};
        Wh.ts = Nh, Wh.aac = ph; var Xh = 188,
            Hh = function(t, e, i) { for (var o, n, s, r, a = 0, h = Xh, l = !1; h <= t.byteLength;)
                    if (71 !== t[a] || 71 !== t[h] && h !== t.byteLength) a++, h++;
                    else { switch (o = t.subarray(a, h), Wh.ts.parseType(o, e.pid)) {
                            case "pes":
                                n = Wh.ts.parsePesType(o, e.table), s = Wh.ts.parsePayloadUnitStartIndicator(o), "audio" === n && s && (r = Wh.ts.parsePesTime(o)) && (r.type = "audio", i.audio.push(r), l = !0) } if (l) break;
                        a += Xh, h += Xh } for (a = (h = t.byteLength) - Xh, l = !1; 0 <= a;)
                    if (71 !== t[a] || 71 !== t[h] && h !== t.byteLength) a--, h--;
                    else { switch (o = t.subarray(a, h), Wh.ts.parseType(o, e.pid)) {
                            case "pes":
                                n = Wh.ts.parsePesType(o, e.table), s = Wh.ts.parsePayloadUnitStartIndicator(o), "audio" === n && s && (r = Wh.ts.parsePesTime(o)) && (r.type = "audio", i.audio.push(r), l = !0) } if (l) break;
                        a -= Xh, h -= Xh } },
            zh = function(t, e, i) { for (var o, n, s, r, a, h, l, c = 0, d = Xh, u = !1, p = { data: [], size: 0 }; d < t.byteLength;)
                    if (71 !== t[c] || 71 !== t[d]) c++, d++;
                    else { switch (o = t.subarray(c, d), Wh.ts.parseType(o, e.pid)) {
                            case "pes":
                                if (n = Wh.ts.parsePesType(o, e.table), s = Wh.ts.parsePayloadUnitStartIndicator(o), "video" === n && (s && !u && (r = Wh.ts.parsePesTime(o)) && (r.type = "video", i.video.push(r), u = !0), !i.firstKeyFrame)) { if (s && 0 !== p.size) { for (a = new Uint8Array(p.size), h = 0; p.data.length;) l = p.data.shift(), a.set(l, h), h += l.byteLength;
                                        Wh.ts.videoPacketContainsKeyFrame(a) && (i.firstKeyFrame = Wh.ts.parsePesTime(a), i.firstKeyFrame.type = "video"), p.size = 0 } p.data.push(o), p.size += o.byteLength } } if (u && i.firstKeyFrame) break;
                        c += Xh, d += Xh } for (c = (d = t.byteLength) - Xh, u = !1; 0 <= c;)
                    if (71 !== t[c] || 71 !== t[d]) c--, d--;
                    else { switch (o = t.subarray(c, d), Wh.ts.parseType(o, e.pid)) {
                            case "pes":
                                n = Wh.ts.parsePesType(o, e.table), s = Wh.ts.parsePayloadUnitStartIndicator(o), "video" === n && s && (r = Wh.ts.parsePesTime(o)) && (r.type = "video", i.video.push(r), u = !0) } if (u) break;
                        c -= Xh, d -= Xh } },
            Jh = function(t) { var e = { pid: null, table: null },
                    i = {}; for (var o in function(t, e) { for (var i, o = 0, n = Xh; n < t.byteLength;)
                            if (71 !== t[o] || 71 !== t[n]) o++, n++;
                            else { switch (i = t.subarray(o, n), Wh.ts.parseType(i, e.pid)) {
                                    case "pat":
                                        e.pid || (e.pid = Wh.ts.parsePat(i)); break;
                                    case "pmt":
                                        e.table || (e.table = Wh.ts.parsePmt(i)) } if (e.pid && e.table) return;
                                o += Xh, n += Xh } }(t, e), e.table)
                    if (e.table.hasOwnProperty(o)) switch (e.table[o]) {
                        case Va.H264_STREAM_TYPE:
                            i.video = [], zh(t, e, i), 0 === i.video.length && delete i.video; break;
                        case Va.ADTS_STREAM_TYPE:
                            i.audio = [], Hh(t, e, i), 0 === i.audio.length && delete i.audio }
                return i },
            qh = function(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") },
            Yh = function() {
                function t(t, e) { for (var i = 0; i < e.length; i++) { var o = e[i];
                        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o) } } return function(e, i, o) { return i && t(e.prototype, i), o && t(e, o), e } }(),
            Kh = null,
            Zh = function() {
                function t(e) { qh(this, t), Kh || (Kh = function() { var t = [
                                [
                                    [],
                                    [],
                                    [],
                                    [],
                                    []
                                ],
                                [
                                    [],
                                    [],
                                    [],
                                    [],
                                    []
                                ]
                            ],
                            e = t[0],
                            i = t[1],
                            o = e[4],
                            n = i[4],
                            s = void 0,
                            r = void 0,
                            a = void 0,
                            h = [],
                            l = [],
                            c = void 0,
                            d = void 0,
                            u = void 0,
                            p = void 0,
                            m = void 0; for (s = 0; s < 256; s++) l[(h[s] = s << 1 ^ 283 * (s >> 7)) ^ s] = s; for (r = a = 0; !o[r]; r ^= c || 1, a = l[a] || 1)
                            for (u = (u = a ^ a << 1 ^ a << 2 ^ a << 3 ^ a << 4) >> 8 ^ 255 & u ^ 99, m = 16843009 * h[d = h[c = h[n[o[r] = u] = r]]] ^ 65537 * d ^ 257 * c ^ 16843008 * r, p = 257 * h[u] ^ 16843008 * u, s = 0; s < 4; s++) e[s][r] = p = p << 24 ^ p >>> 8, i[s][u] = m = m << 24 ^ m >>> 8; for (s = 0; s < 5; s++) e[s] = e[s].slice(0), i[s] = i[s].slice(0); return t }()), this._tables = [
                        [Kh[0][0].slice(), Kh[0][1].slice(), Kh[0][2].slice(), Kh[0][3].slice(), Kh[0][4].slice()],
                        [Kh[1][0].slice(), Kh[1][1].slice(), Kh[1][2].slice(), Kh[1][3].slice(), Kh[1][4].slice()]
                    ]; var i = void 0,
                        o = void 0,
                        n = void 0,
                        s = void 0,
                        r = void 0,
                        a = this._tables[0][4],
                        h = this._tables[1],
                        l = e.length,
                        c = 1; if (4 !== l && 6 !== l && 8 !== l) throw new Error("Invalid aes key size"); for (s = e.slice(0), r = [], this._key = [s, r], i = l; i < 4 * l + 28; i++) n = s[i - 1], (i % l == 0 || 8 === l && i % l == 4) && (n = a[n >>> 24] << 24 ^ a[n >> 16 & 255] << 16 ^ a[n >> 8 & 255] << 8 ^ a[255 & n], i % l == 0 && (n = n << 8 ^ n >>> 24 ^ c << 24, c = c << 1 ^ 283 * (c >> 7))), s[i] = s[i - l] ^ n; for (o = 0; i; o++, i--) n = s[3 & o ? i : i - 4], r[o] = i <= 4 || o < 4 ? n : h[0][a[n >>> 24]] ^ h[1][a[n >> 16 & 255]] ^ h[2][a[n >> 8 & 255]] ^ h[3][a[255 & n]] } return t.prototype.decrypt = function(t, e, i, o, n, s) { var r = this._key[1],
                        a = t ^ r[0],
                        h = o ^ r[1],
                        l = i ^ r[2],
                        c = e ^ r[3],
                        d = void 0,
                        u = void 0,
                        p = void 0,
                        m = r.length / 4 - 2,
                        f = void 0,
                        y = 4,
                        b = this._tables[1],
                        g = b[0],
                        _ = b[1],
                        v = b[2],
                        x = b[3],
                        S = b[4]; for (f = 0; f < m; f++) d = g[a >>> 24] ^ _[h >> 16 & 255] ^ v[l >> 8 & 255] ^ x[255 & c] ^ r[y], u = g[h >>> 24] ^ _[l >> 16 & 255] ^ v[c >> 8 & 255] ^ x[255 & a] ^ r[y + 1], p = g[l >>> 24] ^ _[c >> 16 & 255] ^ v[a >> 8 & 255] ^ x[255 & h] ^ r[y + 2], c = g[c >>> 24] ^ _[a >> 16 & 255] ^ v[h >> 8 & 255] ^ x[255 & l] ^ r[y + 3], y += 4, a = d, h = u, l = p; for (f = 0; f < 4; f++) n[(3 & -f) + s] = S[a >>> 24] << 24 ^ S[h >> 16 & 255] << 16 ^ S[l >> 8 & 255] << 8 ^ S[255 & c] ^ r[y++], d = a, a = h, h = l, l = c, c = d }, t }(),
            Qh = function() {
                function t() { qh(this, t), this.listeners = {} } return t.prototype.on = function(t, e) { this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push(e) }, t.prototype.off = function(t, e) { if (!this.listeners[t]) return !1; var i = this.listeners[t].indexOf(e); return this.listeners[t].splice(i, 1), -1 < i }, t.prototype.trigger = function(t) { var e = this.listeners[t]; if (e)
                        if (2 === arguments.length)
                            for (var i = e.length, o = 0; o < i; ++o) e[o].call(this, arguments[1]);
                        else
                            for (var n = Array.prototype.slice.call(arguments, 1), s = e.length, r = 0; r < s; ++r) e[r].apply(this, n) }, t.prototype.dispose = function() { this.listeners = {} }, t.prototype.pipe = function(t) { this.on("data", function(e) { t.push(e) }) }, t }(),
            $h = function(t) {
                function e() { qh(this, e); var i = function(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, t.call(this, Qh)); return i.jobs = [], i.delay = 1, i.timeout_ = null, i } return function(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                    t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, t), e.prototype.processJob_ = function() { this.jobs.shift()(), this.jobs.length ? this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay) : this.timeout_ = null }, e.prototype.push = function(t) { this.jobs.push(t), this.timeout_ || (this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay)) }, e }(Qh),
            tl = function(t) { return t << 24 | (65280 & t) << 8 | (16711680 & t) >> 8 | t >>> 24 },
            el = function(t, e, i) { var o = new Int32Array(t.buffer, t.byteOffset, t.byteLength >> 2),
                    n = new Zh(Array.prototype.slice.call(e)),
                    s = new Uint8Array(t.byteLength),
                    r = new Int32Array(s.buffer),
                    a = void 0,
                    h = void 0,
                    l = void 0,
                    c = void 0,
                    d = void 0,
                    u = void 0,
                    p = void 0,
                    m = void 0,
                    f = void 0; for (a = i[0], h = i[1], l = i[2], c = i[3], f = 0; f < o.length; f += 4) d = tl(o[f]), u = tl(o[f + 1]), p = tl(o[f + 2]), m = tl(o[f + 3]), n.decrypt(d, u, p, m, r, f), r[f] = tl(r[f] ^ a), r[f + 1] = tl(r[f + 1] ^ h), r[f + 2] = tl(r[f + 2] ^ l), r[f + 3] = tl(r[f + 3] ^ c), a = d, h = u, l = p, c = m; return s },
            il = function() {
                function t(e, i, o, n) { qh(this, t); var s = t.STEP,
                        r = new Int32Array(e.buffer),
                        a = new Uint8Array(e.byteLength),
                        h = 0; for (this.asyncStream_ = new $h, this.asyncStream_.push(this.decryptChunk_(r.subarray(h, h + s), i, o, a)), h = s; h < r.length; h += s) o = new Uint32Array([tl(r[h - 4]), tl(r[h - 3]), tl(r[h - 2]), tl(r[h - 1])]), this.asyncStream_.push(this.decryptChunk_(r.subarray(h, h + s), i, o, a));
                    this.asyncStream_.push(function() { var t;
                        n(null, (t = a).subarray(0, t.byteLength - t[t.byteLength - 1])) }) } return t.prototype.decryptChunk_ = function(t, e, i, o) { return function() { var n = el(t, e, i);
                        o.set(n, t.byteOffset) } }, Yh(t, null, [{ key: "STEP", get: function() { return 32e3 } }]), t }(),
            ol = function(t, i) { return /^[a-z]+:/i.test(i) ? i : (/\/\//i.test(t) || (t = ys.buildAbsoluteURL(e.location.href, t)), ys.buildAbsoluteURL(t, i)) },
            nl = function(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") },
            sl = function() {
                function t(t, e) { for (var i = 0; i < e.length; i++) { var o = e[i];
                        o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o) } } return function(e, i, o) { return i && t(e.prototype, i), o && t(e, o), e } }(),
            rl = function(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) },
            al = function(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e },
            hl = function(t, e) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return function(t, e) { var i = [],
                        o = !0,
                        n = !1,
                        s = void 0; try { for (var r, a = t[Symbol.iterator](); !(o = (r = a.next()).done) && (i.push(r.value), !e || i.length !== e); o = !0); } catch (t) { n = !0, s = t } finally { try {!o && a.return && a.return() } finally { if (n) throw s } } return i }(t, e); throw new TypeError("Invalid attempt to destructure non-iterable instance") },
            ll = Nt.mergeOptions,
            cl = Nt.EventTarget,
            dl = Nt.log,
            ul = function(t, e) {
                ["AUDIO", "SUBTITLES"].forEach(function(i) { for (var o in t.mediaGroups[i])
                        for (var n in t.mediaGroups[i][o]) { var s = t.mediaGroups[i][o][n];
                            e(s, i, o, n) } }) },
            pl = function(t, e) { var i = ll(t, {}),
                    o = i.playlists[e.uri]; if (!o) return null; if (o.segments && e.segments && o.segments.length === e.segments.length && o.mediaSequence === e.mediaSequence) return null; var n = ll(o, e);
                o.segments && (n.segments = function(t, e, i) { var o = e.slice();
                    i = i || 0; for (var n = Math.min(t.length, e.length + i), s = i; s < n; s++) o[s - i] = ll(t[s], o[s - i]); return o }(o.segments, e.segments, e.mediaSequence - o.mediaSequence)), n.segments.forEach(function(t) { var e, i;
                    e = t, i = n.resolvedUri, e.resolvedUri || (e.resolvedUri = ol(i, e.uri)), e.key && !e.key.resolvedUri && (e.key.resolvedUri = ol(i, e.key.uri)), e.map && !e.map.resolvedUri && (e.map.resolvedUri = ol(i, e.map.uri)) }); for (var s = 0; s < i.playlists.length; s++) i.playlists[s].uri === e.uri && (i.playlists[s] = n); return i.playlists[e.uri] = n, i },
            ml = function(t) { for (var e = t.playlists.length; e--;) { var i = t.playlists[e];
                    (t.playlists[i.uri] = i).resolvedUri = ol(t.uri, i.uri), i.id = e, i.attributes || (i.attributes = {}, dl.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.")) } },
            fl = function(t) { ul(t, function(e) { e.uri && (e.resolvedUri = ol(t.uri, e.uri)) }) },
            yl = function(t, e) { var i = t.segments[t.segments.length - 1]; return e && i && i.duration ? 1e3 * i.duration : 500 * (t.targetDuration || 10) },
            bl = function(t) {
                function i(t, e, o) { nl(this, i); var n = al(this, (i.__proto__ || Object.getPrototypeOf(i)).call(this)); if (n.srcUrl = t, n.hls_ = e, n.withCredentials = o, !n.srcUrl) throw new Error("A non-empty playlist URL is required"); return n.state = "HAVE_NOTHING", n.on("mediaupdatetimeout", function() { "HAVE_METADATA" === n.state && (n.state = "HAVE_CURRENT_METADATA", n.request = n.hls_.xhr({ uri: ol(n.master.uri, n.media().uri), withCredentials: n.withCredentials }, function(t, e) { if (n.request) return t ? n.playlistRequestError(n.request, n.media().uri, "HAVE_METADATA") : void n.haveMetadata(n.request, n.media().uri) })) }), n } return rl(i, cl), sl(i, [{ key: "playlistRequestError", value: function(t, e, i) { this.request = null, i && (this.state = i), this.error = { playlist: this.master.playlists[e], status: t.status, message: "HLS playlist request error at URL: " + e, responseText: t.responseText, code: 500 <= t.status ? 4 : 2 }, this.trigger("error") } }, { key: "haveMetadata", value: function(t, i) { var o = this;
                        this.request = null, this.state = "HAVE_METADATA"; var n = new As;
                        n.push(t.responseText), n.end(), n.manifest.uri = i, n.manifest.attributes = n.manifest.attributes || {}; var s = pl(this.master, n.manifest);
                        this.targetDuration = n.manifest.targetDuration, s ? (this.master = s, this.media_ = this.master.playlists[n.manifest.uri]) : this.trigger("playlistunchanged"), this.media().endList || (e.clearTimeout(this.mediaUpdateTimeout), this.mediaUpdateTimeout = e.setTimeout(function() { o.trigger("mediaupdatetimeout") }, yl(this.media(), !!s))), this.trigger("loadedplaylist") } }, { key: "dispose", value: function() { this.stopRequest(), e.clearTimeout(this.mediaUpdateTimeout) } }, { key: "stopRequest", value: function() { if (this.request) { var t = this.request;
                            this.request = null, t.onreadystatechange = null, t.abort() } } }, { key: "media", value: function(t) { var e = this; if (!t) return this.media_; if ("HAVE_NOTHING" === this.state) throw new Error("Cannot switch media playlist from " + this.state); var i = this.state; if ("string" == typeof t) { if (!this.master.playlists[t]) throw new Error("Unknown playlist URI: " + t);
                            t = this.master.playlists[t] } var o = !this.media_ || t.uri !== this.media_.uri; if (this.master.playlists[t.uri].endList) return this.request && (this.request.onreadystatechange = null, this.request.abort(), this.request = null), this.state = "HAVE_METADATA", this.media_ = t, void(o && (this.trigger("mediachanging"), this.trigger("mediachange"))); if (o) { if (this.state = "SWITCHING_MEDIA", this.request) { if (ol(this.master.uri, t.uri) === this.request.url) return;
                                this.request.onreadystatechange = null, this.request.abort(), this.request = null } this.media_ && this.trigger("mediachanging"), this.request = this.hls_.xhr({ uri: ol(this.master.uri, t.uri), withCredentials: this.withCredentials }, function(o, n) { if (e.request) { if (o) return e.playlistRequestError(e.request, t.uri, i);
                                    e.haveMetadata(n, t.uri), "HAVE_MASTER" === i ? e.trigger("loadedmetadata") : e.trigger("mediachange") } }) } } }, { key: "pause", value: function() { this.stopRequest(), e.clearTimeout(this.mediaUpdateTimeout), "HAVE_NOTHING" === this.state && (this.started = !1), "SWITCHING_MEDIA" === this.state ? this.media_ ? this.state = "HAVE_METADATA" : this.state = "HAVE_MASTER" : "HAVE_CURRENT_METADATA" === this.state && (this.state = "HAVE_METADATA") } }, { key: "load", value: function(t) { var i = this;
                        e.clearTimeout(this.mediaUpdateTimeout); var o = this.media(); if (t) { var n = o ? o.targetDuration / 2 * 1e3 : 5e3;
                            this.mediaUpdateTimeout = e.setTimeout(function() { return i.load() }, n) } else this.started ? o && !o.endList ? this.trigger("mediaupdatetimeout") : this.trigger("loadedplaylist") : this.start() } }, { key: "start", value: function() { var t = this;
                        this.started = !0, this.request = this.hls_.xhr({ uri: this.srcUrl, withCredentials: this.withCredentials }, function(i, o) { if (t.request) { if (t.request = null, i) return t.error = { status: o.status, message: "HLS playlist request error at URL: " + t.srcUrl, responseText: o.responseText, code: 2 }, "HAVE_NOTHING" === t.state && (t.started = !1), t.trigger("error"); var n = new As; return n.push(o.responseText), n.end(), t.state = "HAVE_MASTER", n.manifest.uri = t.srcUrl, n.manifest.playlists ? (t.master = n.manifest, ml(t.master), fl(t.master), t.trigger("loadedplaylist"), void(t.request || t.media(n.manifest.playlists[0]))) : (t.master = { mediaGroups: { AUDIO: {}, VIDEO: {}, "CLOSED-CAPTIONS": {}, SUBTITLES: {} }, uri: e.location.href, playlists: [{ uri: t.srcUrl, id: 0 }] }, t.master.playlists[t.srcUrl] = t.master.playlists[0], t.master.playlists[0].resolvedUri = t.srcUrl, t.master.playlists[0].attributes = t.master.playlists[0].attributes || {}, t.haveMetadata(o, t.srcUrl), t.trigger("loadedmetadata")) } }) } }]), i }(),
            gl = Nt.createTimeRange,
            _l = function(t, e, i) { var o, n; return void 0 === e && (e = t.mediaSequence + t.segments.length), e < t.mediaSequence ? 0 : (o = function(t, e) { var i = 0,
                        o = e - t.mediaSequence,
                        n = t.segments[o]; if (n) { if (void 0 !== n.start) return { result: n.start, precise: !0 }; if (void 0 !== n.end) return { result: n.end - n.duration, precise: !0 } } for (; o--;) { if (void 0 !== (n = t.segments[o]).end) return { result: i + n.end, precise: !0 }; if (i += n.duration, void 0 !== n.start) return { result: i + n.start, precise: !0 } } return { result: i, precise: !1 } }(t, e)).precise ? o.result : (n = function(t, e) { for (var i = 0, o = void 0, n = e - t.mediaSequence; n < t.segments.length; n++) { if (void 0 !== (o = t.segments[n]).start) return { result: o.start - i, precise: !0 }; if (i += o.duration, void 0 !== o.end) return { result: o.end - i, precise: !0 } } return { result: -1, precise: !1 } }(t, e)).precise ? n.result : o.result + i },
            vl = function(t, i, o) { if (!t) return 0; if ("number" != typeof o && (o = 0), void 0 === i) { if (t.totalDuration) return t.totalDuration; if (!t.endList) return e.Infinity } return _l(t, i, o) },
            xl = function(t, e, i) { var o = 0; if (i < e) { var n = [i, e];
                    e = n[0], i = n[1] } if (e < 0) { for (var s = e; s < Math.min(0, i); s++) o += t.targetDuration;
                    e = 0 } for (var r = e; r < i; r++) o += t.segments[r].duration; return o },
            Sl = function(t) { if (!t.segments.length) return 0; for (var e = t.segments.length - 1, i = t.segments[e].duration || t.targetDuration, o = i + 2 * t.targetDuration; e-- && !(o <= (i += t.segments[e].duration));); return Math.max(0, e) },
            Cl = function(t, e, i) { if (!t || !t.segments) return null; if (t.endList) return vl(t); if (null === e) return null;
                e = e || 0; var o = i ? Sl(t) : t.segments.length; return _l(t, t.mediaSequence + o, e) },
            wl = function(t) { return t - Math.floor(t) == 0 },
            Al = function(t, e) { if (wl(e)) return e + .1 * t; for (var i = e.toString().split(".")[1].length, o = 1; o <= i; o++) { var n = Math.pow(10, o),
                        s = e * n; if (wl(s) || o === i) return (s + t) / n } },
            Tl = Al.bind(null, 1),
            Pl = Al.bind(null, -1),
            kl = function(t) { return t.excludeUntil && t.excludeUntil > Date.now() },
            Ml = function(t) { return t.excludeUntil && t.excludeUntil === 1 / 0 },
            El = function(t) { var e = kl(t); return !t.disabled && !e },
            Bl = function(t, e) { return e.attributes && e.attributes[t] },
            Il = function(t, e) { if (1 === t.playlists.length) return !0; var i = e.attributes.BANDWIDTH || Number.MAX_VALUE; return 0 === t.playlists.filter(function(t) { return !!El(t) && (t.attributes.BANDWIDTH || 0) < i }).length },
            Dl = { duration: vl, seekable: function(t, e) { var i = e || 0,
                        o = Cl(t, e, !0); return null === o ? gl() : gl(i, o) }, safeLiveIndex: Sl, getMediaInfoForTime: function(t, e, i, o) { var n = void 0,
                        s = void 0,
                        r = t.segments.length,
                        a = e - o; if (a < 0) { if (0 < i)
                            for (n = i - 1; 0 <= n; n--)
                                if (s = t.segments[n], 0 < (a += Pl(s.duration))) return { mediaIndex: n, startTime: o - xl(t, i, n) }; return { mediaIndex: 0, startTime: e } } if (i < 0) { for (n = i; n < 0; n++)
                            if ((a -= t.targetDuration) < 0) return { mediaIndex: 0, startTime: e };
                        i = 0 } for (n = i; n < r; n++)
                        if (s = t.segments[n], (a -= Tl(s.duration)) < 0) return { mediaIndex: n, startTime: o + xl(t, i, n) }; return { mediaIndex: r - 1, startTime: e } }, isEnabled: El, isDisabled: function(t) { return t.disabled }, isBlacklisted: kl, isIncompatible: Ml, playlistEnd: Cl, isAes: function(t) { for (var e = 0; e < t.segments.length; e++)
                        if (t.segments[e].key) return !0; return !1 }, isFmp4: function(t) { for (var e = 0; e < t.segments.length; e++)
                        if (t.segments[e].map) return !0; return !1 }, hasAttribute: Bl, estimateSegmentRequestTime: function(t, e, i) { var o = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0; return Bl("BANDWIDTH", i) ? (t * i.attributes.BANDWIDTH - 8 * o) / e : NaN }, isLowestEnabledRendition: Il },
            Ll = Nt.xhr,
            Ol = Nt.mergeOptions,
            Rl = function() { return function t(e, i) { e = Ol({ timeout: 45e3 }, e); var o = t.beforeRequest || Nt.Hls.xhr.beforeRequest; if (o && "function" == typeof o) { var n = o(e);
                        n && (e = n) } var s = Ll(e, function(t, e) { var o = s.response;!t && o && (s.responseTime = Date.now(), s.roundTripTime = s.responseTime - s.requestTime, s.bytesReceived = o.byteLength || o.length, s.bandwidth || (s.bandwidth = Math.floor(s.bytesReceived / s.roundTripTime * 8 * 1e3))), e.headers && (s.responseHeaders = e.headers), t && "ETIMEDOUT" === t.code && (s.timedout = !0), t || s.aborted || 200 === e.statusCode || 206 === e.statusCode || 0 === e.statusCode || (t = new Error("XHR Failed with a response of: " + (s && (o || s.responseText)))), i(t, s) }),
                        r = s.abort; return s.abort = function() { return s.aborted = !0, r.apply(s, arguments) }, s.uri = e.uri, s.requestTime = Date.now(), s } },
            Fl = function(t, e) { var i = t.toString(16); return "00".substring(0, 2 - i.length) + i + (e % 2 ? " " : "") },
            Vl = function(t) { return 32 <= t && t < 126 ? String.fromCharCode(t) : "." },
            Gl = function(t) { var e = {}; return Object.keys(t).forEach(function(i) { var o = t[i];
                    ArrayBuffer.isView(o) ? e[i] = { bytes: o.buffer, byteOffset: o.byteOffset, byteLength: o.byteLength } : e[i] = o }), e },
            Ul = function(t) { var e = t.byterange || { length: 1 / 0, offset: 0 }; return [e.length, e.offset, t.resolvedUri].join(",") },
            Nl = function(t) { for (var e = Array.prototype.slice.call(t), i = "", o = 0; o < e.length / 16; o++) i += e.slice(16 * o, 16 * o + 16).map(Fl).join("") + " " + e.slice(16 * o, 16 * o + 16).map(Vl).join("") + "\n"; return i },
            jl = Object.freeze({ createTransferableMessage: Gl, initSegmentId: Ul, hexDump: Nl, tagDump: function(t) { var e = t.bytes; return Nl(e) }, textRanges: function(t) { var e, i, o = "",
                        n = void 0; for (n = 0; n < t.length; n++) o += (i = n, (e = t).start(i) + "-" + e.end(i) + " "); return o } }),
            Wl = function(t, e, i, o) { var n = void 0; if ("stream" === e) { n = new Date(1e3 * o + i.getTime()); var s = t.toISOString(),
                        r = i.toISOString(),
                        a = n.toISOString(); return r <= s && s <= a } if ("player" === e) return n = o + i, i <= t && t <= n },
            Xl = function(t, e, i) { if (!i.segments || 0 === i.segments.length) return null; if ("player" !== e && "stream" !== e) return null; for (var o = 0, n = 0; n < i.segments.length; n++) { var s = i.segments[n],
                        r = o + s.duration,
                        a = void 0,
                        h = void 0;
                    h = "player" === e ? (a = s.start, o) : (a = s.dateTimeObject, s.dateTimeObject); var l = void 0 !== s.start && void 0 !== s.end && Wl(t, e, a, s.end - s.start),
                        c = Wl(t, e, h, s.duration); if (l) return { segment: s, estimatedStart: h, type: "accurate" }; if (c) return { segment: s, estimatedStart: h, type: "estimate" };
                    o = r } return null },
            Hl = function(t) { var e = t.playlist,
                    i = t.time,
                    o = void 0 === i ? void 0 : i,
                    n = t.callback; if (!n) throw new Error("getStreamTime: callback must be provided"); if (!e || void 0 === o) return n({ message: "getStreamTime: playlist and time must be provided" }); var s = Xl(o, "player", e); if (!s) return n({ message: "valid streamTime was not found" }); if ("estimate" === s.type) return n({ message: "Accurate streamTime could not be determined. Please seek to e.seekTime and try again", seekTime: s.estimatedStart }); var r = { mediaSeconds: o }; return s.segment.dateTimeObject && (r.programDateTime = s.segment.dateTimeObject.toISOString()), n(null, r) },
            zl = function t(e) { var i = e.streamTime,
                    o = e.playlist,
                    n = e.retryCount,
                    s = void 0 === n ? 2 : n,
                    r = e.seekTo,
                    a = e.pauseAfterSeek,
                    h = void 0 === a || a,
                    l = e.tech,
                    c = e.callback; if (!c) throw new Error("seekToStreamTime: callback must be provided"); if (void 0 === i || !o || !r) return c({ message: "seekToStreamTime: streamTime, seekTo and playlist must be provided" }); if (!o.endList && !l.hasStarted_) return c({ message: "player must be playing a live stream to start buffering" }); if (! function(t) { if (!t.segments || 0 === t.segments.length) return !1; for (var e = 0; e < t.segments.length; e++)
                            if (!t.segments[e].dateTimeObject) return !1; return !0 }(o)) return c({ message: "programDateTime tags must be provided in the manifest " + o.resolvedUri }); var d = function(t, e) { var i = void 0; try { i = new Date(t) } catch (t) { return null } return Xl(i, "stream", e) }(i, o); if (!d) return c({ message: i + " was not found in the stream" }); if ("estimate" === d.type) return 0 === s ? c({ message: i + " is not buffered yet. Try again" }) : t({ streamTime: i, playlist: o, retryCount: s - 1, seekTo: r, pauseAfterSeek: h, tech: l, callback: c }); var u = d.segment,
                    p = function(t, e) { var i = void 0,
                            o = void 0; try { i = new Date(t), o = new Date(e) } catch (t) {} var n = i.getTime(); return (o.getTime() - n) / 1e3 }(u.dateTimeObject, i),
                    m = u.start + p;
                l.one("seeked", function() { return c(null, l.currentTime()) }), h && l.pause(), r(m) },
            Jl = 1 / 30,
            ql = function(t, e) { var i = [],
                    o = void 0; if (t && t.length)
                    for (o = 0; o < t.length; o++) e(t.start(o), t.end(o)) && i.push([t.start(o), t.end(o)]); return Nt.createTimeRanges(i) },
            Yl = function(t, e) { return ql(t, function(t, i) { return t - Jl <= e && e <= i + Jl }) },
            Kl = function(t, e) { return ql(t, function(t) { return e <= t - Jl }) },
            Zl = function(t) { var e = []; if (!t || !t.length) return ""; for (var i = 0; i < t.length; i++) e.push(t.start(i) + " => " + t.end(i)); return e.join(", ") },
            Ql = function(t) { for (var e = [], i = 0; i < t.length; i++) e.push({ start: t.start(i), end: t.end(i) }); return e },
            $l = function(t, e, i) { var o = void 0,
                    n = void 0; if (i && i.cues)
                    for (o = i.cues.length; o--;)(n = i.cues[o]).startTime <= e && n.endTime >= t && i.removeCue(n) },
            tc = function(t) { return isNaN(t) || Math.abs(t) === 1 / 0 ? Number.MAX_VALUE : t },
            ec = function(t, i, o) { var n = e.WebKitDataCue || e.VTTCue; if (i && i.forEach(function(t) { var e = t.stream;
                        this.inbandTextTracks_[e].addCue(new n(t.startTime + this.timestampOffset, t.endTime + this.timestampOffset, t.text)) }, t), o) { var s = tc(t.mediaSource_.duration); if (o.forEach(function(t) { var e = t.cueTime + this.timestampOffset;
                            t.frames.forEach(function(t) { var i, o = new n(e, e, t.value || t.url || t.data || "");
                                o.frame = t, o.value = t, i = o, Object.defineProperties(i.frame, { id: { get: function() { return Nt.log.warn("cue.frame.id is deprecated. Use cue.value.key instead."), i.value.key } }, value: { get: function() { return Nt.log.warn("cue.frame.value is deprecated. Use cue.value.data instead."), i.value.data } }, privateData: { get: function() { return Nt.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead."), i.value.data } } }), this.metadataTrack_.addCue(o) }, this) }, t), t.metadataTrack_ && t.metadataTrack_.cues && t.metadataTrack_.cues.length) { for (var r = t.metadataTrack_.cues, a = [], h = 0; h < r.length; h++) r[h] && a.push(r[h]); var l = a.reduce(function(t, e) { var i = t[e.startTime] || []; return i.push(e), t[e.startTime] = i, t }, {}),
                            c = Object.keys(l).sort(function(t, e) { return Number(t) - Number(e) });
                        c.forEach(function(t, e) { var i = l[t],
                                o = Number(c[e + 1]) || s;
                            i.forEach(function(t) { t.endTime = o }) }) } } },
            ic = "undefined" != typeof window ? window : {},
            oc = "undefined" == typeof Symbol ? "__target" : Symbol(),
            nc = "application/javascript",
            sc = ic.BlobBuilder || ic.WebKitBlobBuilder || ic.MozBlobBuilder || ic.MSBlobBuilder,
            rc = ic.URL || ic.webkitURL || rc && rc.msURL,
            ac = ic.Worker; if (ac) { var hc, lc = Wt("self.onmessage = function () {}"),
                cc = new Uint8Array(1); try {
                (hc = new ac(lc)).postMessage(cc, [cc.buffer]) } catch (Jt) { ac = null } finally { rc.revokeObjectURL(lc), hc && hc.terminate() } } var dc = new jt("./transmuxer-worker.worker.js", function(t, e) { var i = this;! function() { var t, e, o, n, s, r, a, h, l, c, d, u, p, m, f, y, b, g, _, v, x, S, C, w, A, T, P, k, M, E, B, I, D, L, O, R, F, V, G, U, N = Math.pow(2, 32) - 1;! function() { var t; if (S = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], mvex: [], mvhd: [], sdtp: [], smhd: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], styp: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [] }, "undefined" != typeof Uint8Array) { for (t in S) S.hasOwnProperty(t) && (S[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]);
                            C = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]), A = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]), w = new Uint8Array([0, 0, 0, 1]), T = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]), P = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]), k = { video: T, audio: P }, B = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]), E = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), I = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), D = I, L = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), O = I, M = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]) } }(), t = function(t) { var e, i, o = [],
                            n = 0; for (e = 1; e < arguments.length; e++) o.push(arguments[e]); for (e = o.length; e--;) n += o[e].byteLength; for (i = new Uint8Array(n + 8), new DataView(i.buffer, i.byteOffset, i.byteLength).setUint32(0, i.byteLength), i.set(t, 4), e = 0, n = 8; e < o.length; e++) i.set(o[e], n), n += o[e].byteLength; return i }, e = function() { return t(S.dinf, t(S.dref, B)) }, o = function(e) { return t(S.esds, new Uint8Array([0, 0, 0, 0, 3, 25, 0, 0, 0, 4, 17, 64, 21, 0, 6, 0, 0, 0, 218, 192, 0, 0, 218, 192, 5, 2, e.audioobjecttype << 3 | e.samplingfrequencyindex >>> 1, e.samplingfrequencyindex << 7 | e.channelcount << 3, 6, 1, 2])) }, f = function(e) { return t(S.hdlr, k[e]) }, m = function(e) { var i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 1, 95, 144, e.duration >>> 24 & 255, e.duration >>> 16 & 255, e.duration >>> 8 & 255, 255 & e.duration, 85, 196, 0, 0]); return e.samplerate && (i[12] = e.samplerate >>> 24 & 255, i[13] = e.samplerate >>> 16 & 255, i[14] = e.samplerate >>> 8 & 255, i[15] = 255 & e.samplerate), t(S.mdhd, i) }, p = function(e) { return t(S.mdia, m(e), f(e.type), r(e)) }, s = function(e) { return t(S.mfhd, new Uint8Array([0, 0, 0, 0, (4278190080 & e) >> 24, (16711680 & e) >> 16, (65280 & e) >> 8, 255 & e])) }, r = function(i) { return t(S.minf, "video" === i.type ? t(S.vmhd, M) : t(S.smhd, E), e(), b(i)) }, a = function(e, i) { for (var o = [], n = i.length; n--;) o[n] = _(i[n]); return t.apply(null, [S.moof, s(e)].concat(o)) }, h = function(e) { for (var i = e.length, o = []; i--;) o[i] = d(e[i]); return t.apply(null, [S.moov, c(4294967295)].concat(o).concat(l(e))) }, l = function(e) { for (var i = e.length, o = []; i--;) o[i] = v(e[i]); return t.apply(null, [S.mvex].concat(o)) }, c = function(e) { var i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 95, 144, (4278190080 & e) >> 24, (16711680 & e) >> 16, (65280 & e) >> 8, 255 & e, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]); return t(S.mvhd, i) }, y = function(e) { var i, o, n = e.samples || [],
                            s = new Uint8Array(4 + n.length); for (o = 0; o < n.length; o++) i = n[o].flags, s[o + 4] = i.dependsOn << 4 | i.isDependedOn << 2 | i.hasRedundancy; return t(S.sdtp, s) }, b = function(e) { return t(S.stbl, g(e), t(S.stts, O), t(S.stsc, D), t(S.stsz, L), t(S.stco, I)) }, g = function(e) { return t(S.stsd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), "video" === e.type ? R(e) : F(e)) }, R = function(e) { var i, o = e.sps || [],
                            n = e.pps || [],
                            s = [],
                            r = []; for (i = 0; i < o.length; i++) s.push((65280 & o[i].byteLength) >>> 8), s.push(255 & o[i].byteLength), s = s.concat(Array.prototype.slice.call(o[i])); for (i = 0; i < n.length; i++) r.push((65280 & n[i].byteLength) >>> 8), r.push(255 & n[i].byteLength), r = r.concat(Array.prototype.slice.call(n[i])); return t(S.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & e.width) >> 8, 255 & e.width, (65280 & e.height) >> 8, 255 & e.height, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 19, 118, 105, 100, 101, 111, 106, 115, 45, 99, 111, 110, 116, 114, 105, 98, 45, 104, 108, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), t(S.avcC, new Uint8Array([1, e.profileIdc, e.profileCompatibility, e.levelIdc, 255].concat([o.length]).concat(s).concat([n.length]).concat(r))), t(S.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192]))) }, F = function(e) { return t(S.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, (65280 & e.channelcount) >> 8, 255 & e.channelcount, (65280 & e.samplesize) >> 8, 255 & e.samplesize, 0, 0, 0, 0, (65280 & e.samplerate) >> 8, 255 & e.samplerate, 0, 0]), o(e)) }, u = function(e) { var i = new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 0, (4278190080 & e.duration) >> 24, (16711680 & e.duration) >> 16, (65280 & e.duration) >> 8, 255 & e.duration, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, (65280 & e.width) >> 8, 255 & e.width, 0, 0, (65280 & e.height) >> 8, 255 & e.height, 0, 0]); return t(S.tkhd, i) }, _ = function(e) { var i, o, n, s, r, a; return i = t(S.tfhd, new Uint8Array([0, 0, 0, 58, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])), r = Math.floor(e.baseMediaDecodeTime / (N + 1)), a = Math.floor(e.baseMediaDecodeTime % (N + 1)), o = t(S.tfdt, new Uint8Array([1, 0, 0, 0, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r, a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, 255 & a])), "audio" === e.type ? (n = x(e, 92), t(S.traf, i, o, n)) : (s = y(e), n = x(e, s.length + 92), t(S.traf, i, o, n, s)) }, d = function(e) { return e.duration = e.duration || 4294967295, t(S.trak, u(e), p(e)) }, v = function(e) { var i = new Uint8Array([0, 0, 0, 0, (4278190080 & e.id) >> 24, (16711680 & e.id) >> 16, (65280 & e.id) >> 8, 255 & e.id, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]); return "video" !== e.type && (i[i.length - 1] = 0), t(S.trex, i) }, U = function(t, e) { var i = 0,
                            o = 0,
                            n = 0,
                            s = 0; return t.length && (void 0 !== t[0].duration && (i = 1), void 0 !== t[0].size && (o = 2), void 0 !== t[0].flags && (n = 4), void 0 !== t[0].compositionTimeOffset && (s = 8)), [0, 0, i | o | n | s, 1, (4278190080 & t.length) >>> 24, (16711680 & t.length) >>> 16, (65280 & t.length) >>> 8, 255 & t.length, (4278190080 & e) >>> 24, (16711680 & e) >>> 16, (65280 & e) >>> 8, 255 & e] }, G = function(e, i) { var o, n, s, r; for (i += 20 + 16 * (n = e.samples || []).length, o = U(n, i), r = 0; r < n.length; r++) s = n[r], o = o.concat([(4278190080 & s.duration) >>> 24, (16711680 & s.duration) >>> 16, (65280 & s.duration) >>> 8, 255 & s.duration, (4278190080 & s.size) >>> 24, (16711680 & s.size) >>> 16, (65280 & s.size) >>> 8, 255 & s.size, s.flags.isLeading << 2 | s.flags.dependsOn, s.flags.isDependedOn << 6 | s.flags.hasRedundancy << 4 | s.flags.paddingValue << 1 | s.flags.isNonSyncSample, 61440 & s.flags.degradationPriority, 15 & s.flags.degradationPriority, (4278190080 & s.compositionTimeOffset) >>> 24, (16711680 & s.compositionTimeOffset) >>> 16, (65280 & s.compositionTimeOffset) >>> 8, 255 & s.compositionTimeOffset]); return t(S.trun, new Uint8Array(o)) }, V = function(e, i) { var o, n, s, r; for (i += 20 + 8 * (n = e.samples || []).length, o = U(n, i), r = 0; r < n.length; r++) s = n[r], o = o.concat([(4278190080 & s.duration) >>> 24, (16711680 & s.duration) >>> 16, (65280 & s.duration) >>> 8, 255 & s.duration, (4278190080 & s.size) >>> 24, (16711680 & s.size) >>> 16, (65280 & s.size) >>> 8, 255 & s.size]); return t(S.trun, new Uint8Array(o)) }, x = function(t, e) { return "audio" === t.type ? V(t, e) : G(t, e) }; var j, W, X, H, z, J = { ftyp: n = function() { return t(S.ftyp, C, w, C, A) }, mdat: function(e) { return t(S.mdat, e) }, moof: a, moov: h, initSegment: function(t) { var e, i = n(),
                                    o = h(t); return (e = new Uint8Array(i.byteLength + o.byteLength)).set(i), e.set(o, i.byteLength), e } },
                        q = function(t) { return t >>> 0 };
                    X = function(t) { return j(t, ["moov", "trak"]).reduce(function(t, e) { var i, o, n, s, r; return (i = j(e, ["tkhd"])[0]) ? (o = i[0], s = q(i[n = 0 === o ? 12 : 20] << 24 | i[n + 1] << 16 | i[n + 2] << 8 | i[n + 3]), (r = j(e, ["mdia", "mdhd"])[0]) ? (n = 0 === (o = r[0]) ? 12 : 20, t[s] = q(r[n] << 24 | r[n + 1] << 16 | r[n + 2] << 8 | r[n + 3]), t) : null) : null }, {}) }, H = function(t, e) { var i, o, n; return i = j(e, ["moof", "traf"]), o = [].concat.apply([], i.map(function(e) { return j(e, ["tfhd"]).map(function(i) { var o, n; return o = q(i[4] << 24 | i[5] << 16 | i[6] << 8 | i[7]), n = t[o] || 9e4, (j(e, ["tfdt"]).map(function(t) { var e, i; return e = t[0], i = q(t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7]), 1 === e && (i *= Math.pow(2, 32), i += q(t[8] << 24 | t[9] << 16 | t[10] << 8 | t[11])), i })[0] || 1 / 0) / n }) })), n = Math.min.apply(null, o), isFinite(n) ? n : 0 }, z = function(t) { var e = []; return j(t, ["moov", "trak"]).forEach(function(t) { var i = j(t, ["mdia", "hdlr"]),
                                o = j(t, ["tkhd"]);
                            i.forEach(function(t, i) { var n, s, r = W(t.subarray(8, 12)),
                                    a = o[i]; "vide" === r && (s = 0 === (n = new DataView(a.buffer, a.byteOffset, a.byteLength)).getUint8(0) ? n.getUint32(12) : n.getUint32(20), e.push(s)) }) }), e }; var Y = { findBox: j = function(t, e) { var i, o, n, s, r, a = []; if (!e.length) return null; for (i = 0; i < t.byteLength;) o = q(t[i] << 24 | t[i + 1] << 16 | t[i + 2] << 8 | t[i + 3]), n = W(t.subarray(i + 4, i + 8)), s = 1 < o ? i + o : t.byteLength, n === e[0] && (1 === e.length ? a.push(t.subarray(i + 8, s)) : (r = j(t.subarray(i + 8, s), e.slice(1))).length && (a = a.concat(r))), i = s; return a }, parseType: W = function(t) { var e = ""; return e += String.fromCharCode(t[0]), e += String.fromCharCode(t[1]), e += String.fromCharCode(t[2]), e += String.fromCharCode(t[3]) }, timescale: X, startTime: H, videoTrackIds: z },
                        K = function() { this.init = function() { var t = {};
                                this.on = function(e, i) { t[e] || (t[e] = []), t[e] = t[e].concat(i) }, this.off = function(e, i) { var o; return !!t[e] && (o = t[e].indexOf(i), t[e] = t[e].slice(), t[e].splice(o, 1), -1 < o) }, this.trigger = function(e) { var i, o, n, s; if (i = t[e])
                                        if (2 === arguments.length)
                                            for (n = i.length, o = 0; o < n; ++o) i[o].call(this, arguments[1]);
                                        else { for (s = [], o = arguments.length, o = 1; o < arguments.length; ++o) s.push(arguments[o]); for (n = i.length, o = 0; o < n; ++o) i[o].apply(this, s) } }, this.dispose = function() { t = {} } } };
                    K.prototype.pipe = function(t) { return this.on("data", function(e) { t.push(e) }), this.on("done", function(e) { t.flush(e) }), t }, K.prototype.push = function(t) { this.trigger("data", t) }, K.prototype.flush = function(t) { this.trigger("done", t) }; var Z, Q, $, tt, et, it, ot, nt = K,
                        st = function(t) { var e, i, o = [],
                                n = []; for (e = o.byteLength = 0; e < t.length; e++) "access_unit_delimiter_rbsp" === (i = t[e]).nalUnitType ? (o.length && (o.duration = i.dts - o.dts, n.push(o)), (o = [i]).byteLength = i.data.byteLength, o.pts = i.pts, o.dts = i.dts) : ("slice_layer_without_partitioning_rbsp_idr" === i.nalUnitType && (o.keyFrame = !0), o.duration = i.dts - o.dts, o.byteLength += i.data.byteLength, o.push(i)); return n.length && (!o.duration || o.duration <= 0) && (o.duration = n[n.length - 1].duration), n.push(o), n },
                        rt = function(t) { var e, i, o = [],
                                n = []; for (o.byteLength = 0, o.nalCount = 0, o.duration = 0, o.pts = t[0].pts, o.dts = t[0].dts, n.byteLength = 0, n.nalCount = 0, n.duration = 0, n.pts = t[0].pts, n.dts = t[0].dts, e = 0; e < t.length; e++)(i = t[e]).keyFrame ? (o.length && (n.push(o), n.byteLength += o.byteLength, n.nalCount += o.nalCount, n.duration += o.duration), (o = [i]).nalCount = i.length, o.byteLength = i.byteLength, o.pts = i.pts, o.dts = i.dts, o.duration = i.duration) : (o.duration += i.duration, o.nalCount += i.length, o.byteLength += i.byteLength, o.push(i)); return n.length && o.duration <= 0 && (o.duration = n[n.length - 1].duration), n.byteLength += o.byteLength, n.nalCount += o.nalCount, n.duration += o.duration, n.push(o), n },
                        at = function(t) { var e; return !t[0][0].keyFrame && 1 < t.length && (e = t.shift(), t.byteLength -= e.byteLength, t.nalCount -= e.nalCount, t[0][0].dts = e.dts, t[0][0].pts = e.pts, t[0][0].duration += e.duration), t },
                        ht = function(t, e) { var i, o, n, s, r, a, h, l = e || 0,
                                c = []; for (i = 0; i < t.length; i++)
                                for (s = t[i], o = 0; o < s.length; o++) r = s[o], a = r, h = void 0, (h = { size: 0, flags: { isLeading: 0, dependsOn: 1, isDependedOn: 0, hasRedundancy: 0, degradationPriority: 0, isNonSyncSample: 1 } }).dataOffset = l, h.compositionTimeOffset = a.pts - a.dts, h.duration = a.duration, h.size = 4 * a.length, h.size += a.byteLength, a.keyFrame && (h.flags.dependsOn = 2, h.flags.isNonSyncSample = 0), l += (n = h).size, c.push(n); return c },
                        lt = function(t) { var e, i, o, n, s, r, a = 0,
                                h = t.byteLength,
                                l = t.nalCount,
                                c = new Uint8Array(h + 4 * l),
                                d = new DataView(c.buffer); for (e = 0; e < t.length; e++)
                                for (n = t[e], i = 0; i < n.length; i++)
                                    for (s = n[i], o = 0; o < s.length; o++) r = s[o], d.setUint32(a, r.data.byteLength), a += 4, c.set(r.data, a), a += r.data.byteLength; return c },
                        ct = [33, 16, 5, 32, 164, 27],
                        dt = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252],
                        ut = function(t) { for (var e = []; t--;) e.push(0); return e },
                        pt = { 96e3: [ct, [227, 64], ut(154), [56]], 88200: [ct, [231], ut(170), [56]], 64e3: [ct, [248, 192], ut(240), [56]], 48e3: [ct, [255, 192], ut(268), [55, 148, 128], ut(54), [112]], 44100: [ct, [255, 192], ut(268), [55, 163, 128], ut(84), [112]], 32e3: [ct, [255, 192], ut(268), [55, 234], ut(226), [112]], 24e3: [ct, [255, 192], ut(268), [55, 255, 128], ut(268), [111, 112], ut(126), [224]], 16e3: [ct, [255, 192], ut(268), [55, 255, 128], ut(268), [111, 255], ut(269), [223, 108], ut(195), [1, 192]], 12e3: [dt, ut(268), [3, 127, 248], ut(268), [6, 255, 240], ut(268), [13, 255, 224], ut(268), [27, 253, 128], ut(259), [56]], 11025: [dt, ut(268), [3, 127, 248], ut(268), [6, 255, 240], ut(268), [13, 255, 224], ut(268), [27, 255, 192], ut(268), [55, 175, 128], ut(108), [112]], 8e3: [dt, ut(268), [3, 121, 16], ut(47), [7]] },
                        mt = (Z = pt, Object.keys(Z).reduce(function(t, e) { return t[e] = new Uint8Array(Z[e].reduce(function(t, e) { return t.concat(e) }, [])), t }, {}));
                    it = function(t, e) { return Q(et(t, e)) }, ot = function(t, e) { return $(tt(t), e) }, Q = function(t) { return 9e4 * t }, $ = function(t, e) { return t * e }, tt = function(t) { return t / 9e4 }, et = function(t, e) { return t / e }; var ft = it,
                        yt = ot,
                        bt = function(t, e, i, o) { var n, s, r, a, h = 0,
                                l = 0,
                                c = 0; if (e.length && (n = ft(t.baseMediaDecodeTime, t.samplerate), s = Math.ceil(9e4 / (t.samplerate / 1024)), i && o && (h = n - Math.max(i, o), c = (l = Math.floor(h / s)) * s), !(l < 1 || 45e3 < c))) { for ((r = mt[t.samplerate]) || (r = e[0].data), a = 0; a < l; a++) e.splice(a, 0, { data: r });
                                t.baseMediaDecodeTime -= Math.floor(yt(c, t.samplerate)) } },
                        gt = function(t, e, i) { return e.minSegmentDts >= i ? t : (e.minSegmentDts = 1 / 0, t.filter(function(t) { return t.dts >= i && (e.minSegmentDts = Math.min(e.minSegmentDts, t.dts), e.minSegmentPts = e.minSegmentDts, !0) })) },
                        _t = function(t) { var e, i, o = []; for (e = 0; e < t.length; e++) i = t[e], o.push({ size: i.data.byteLength, duration: 1024 }); return o },
                        vt = function(t) { var e, i, o = 0,
                                n = new Uint8Array(function(t) { var e, i = 0; for (e = 0; e < t.length; e++) i += t[e].data.byteLength; return i }(t)); for (e = 0; e < t.length; e++) i = t[e], n.set(i.data, o), o += i.data.byteLength; return n },
                        xt = function(t) { delete t.minSegmentDts, delete t.maxSegmentDts, delete t.minSegmentPts, delete t.maxSegmentPts },
                        St = function(t, e) { var i, o = t.minSegmentDts; return e || (o -= t.timelineStartInfo.dts), i = t.timelineStartInfo.baseMediaDecodeTime, i += o, i = Math.max(0, i), "audio" === t.type && (i *= t.samplerate / 9e4, i = Math.floor(i)), i },
                        Ct = function(t, e) { "number" == typeof e.pts && (void 0 === t.timelineStartInfo.pts && (t.timelineStartInfo.pts = e.pts), void 0 === t.minSegmentPts ? t.minSegmentPts = e.pts : t.minSegmentPts = Math.min(t.minSegmentPts, e.pts), void 0 === t.maxSegmentPts ? t.maxSegmentPts = e.pts : t.maxSegmentPts = Math.max(t.maxSegmentPts, e.pts)), "number" == typeof e.dts && (void 0 === t.timelineStartInfo.dts && (t.timelineStartInfo.dts = e.dts), void 0 === t.minSegmentDts ? t.minSegmentDts = e.dts : t.minSegmentDts = Math.min(t.minSegmentDts, e.dts), void 0 === t.maxSegmentDts ? t.maxSegmentDts = e.dts : t.maxSegmentDts = Math.max(t.maxSegmentDts, e.dts)) },
                        wt = function(t) { for (var e = 0, i = { payloadType: -1, payloadSize: 0 }, o = 0, n = 0; e < t.byteLength && 128 !== t[e];) { for (; 255 === t[e];) o += 255, e++; for (o += t[e++]; 255 === t[e];) n += 255, e++; if (n += t[e++], !i.payload && 4 === o) { i.payloadType = o, i.payloadSize = n, i.payload = t.subarray(e, e + n); break } e += n, n = o = 0 } return i },
                        At = function(t) { return 181 !== t.payload[0] ? null : 49 != (t.payload[1] << 8 | t.payload[2]) ? null : "GA94" !== String.fromCharCode(t.payload[3], t.payload[4], t.payload[5], t.payload[6]) ? null : 3 !== t.payload[7] ? null : t.payload.subarray(8, t.payload.length - 1) },
                        Tt = function(t, e) { var i, o, n, s, r = []; if (!(64 & e[0])) return r; for (o = 31 & e[0], i = 0; i < o; i++) s = { type: 3 & e[2 + (n = 3 * i)], pts: t }, 4 & e[n + 2] && (s.ccData = e[n + 3] << 8 | e[n + 4], r.push(s)); return r },
                        Pt = function t() { t.prototype.init.call(this), this.captionPackets_ = [], this.ccStreams_ = [new It(0, 0), new It(0, 1), new It(1, 0), new It(1, 1)], this.reset(), this.ccStreams_.forEach(function(t) { t.on("data", this.trigger.bind(this, "data")), t.on("done", this.trigger.bind(this, "done")) }, this) };
                    (Pt.prototype = new nt).push = function(t) { var e, i, o; if ("sei_rbsp" === t.nalUnitType && 4 === (e = wt(t.escapedRBSP)).payloadType && (i = At(e)))
                            if (t.dts < this.latestDts_) this.ignoreNextEqualDts_ = !0;
                            else { if (t.dts === this.latestDts_ && this.ignoreNextEqualDts_) return void(--this.numSameDts_ || (this.ignoreNextEqualDts_ = !1));
                                o = Tt(t.pts, i), this.captionPackets_ = this.captionPackets_.concat(o), this.latestDts_ !== t.dts && (this.numSameDts_ = 0), this.numSameDts_++, this.latestDts_ = t.dts } }, Pt.prototype.flush = function() { this.captionPackets_.length ? (this.captionPackets_.forEach(function(t, e) { t.presortIndex = e }), this.captionPackets_.sort(function(t, e) { return t.pts === e.pts ? t.presortIndex - e.presortIndex : t.pts - e.pts }), this.captionPackets_.forEach(function(t) { t.type < 2 && this.dispatchCea608Packet(t) }, this), this.captionPackets_.length = 0, this.ccStreams_.forEach(function(t) { t.flush() }, this)) : this.ccStreams_.forEach(function(t) { t.flush() }, this) }, Pt.prototype.reset = function() { this.latestDts_ = null, this.ignoreNextEqualDts_ = !1, this.numSameDts_ = 0, this.activeCea608Channel_ = [null, null], this.ccStreams_.forEach(function(t) { t.reset() }) }, Pt.prototype.dispatchCea608Packet = function(t) { this.setsChannel1Active(t) ? this.activeCea608Channel_[t.type] = 0 : this.setsChannel2Active(t) && (this.activeCea608Channel_[t.type] = 1), null !== this.activeCea608Channel_[t.type] && this.ccStreams_[(t.type << 1) + this.activeCea608Channel_[t.type]].push(t) }, Pt.prototype.setsChannel1Active = function(t) { return 4096 == (30720 & t.ccData) }, Pt.prototype.setsChannel2Active = function(t) { return 6144 == (30720 & t.ccData) }; var kt = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 304: 174, 305: 176, 306: 189, 307: 191, 308: 8482, 309: 162, 310: 163, 311: 9834, 312: 224, 313: 160, 314: 232, 315: 226, 316: 234, 317: 238, 318: 244, 319: 251, 544: 193, 545: 201, 546: 211, 547: 218, 548: 220, 549: 252, 550: 8216, 551: 161, 552: 42, 553: 39, 554: 8212, 555: 169, 556: 8480, 557: 8226, 558: 8220, 559: 8221, 560: 192, 561: 194, 562: 199, 563: 200, 564: 202, 565: 203, 566: 235, 567: 206, 568: 207, 569: 239, 570: 212, 571: 217, 572: 249, 573: 219, 574: 171, 575: 187, 800: 195, 801: 227, 802: 205, 803: 204, 804: 236, 805: 210, 806: 242, 807: 213, 808: 245, 809: 123, 810: 125, 811: 92, 812: 94, 813: 95, 814: 124, 815: 126, 816: 196, 817: 228, 818: 214, 819: 246, 820: 223, 821: 165, 822: 164, 823: 9474, 824: 197, 825: 229, 826: 216, 827: 248, 828: 9484, 829: 9488, 830: 9492, 831: 9496 },
                        Mt = function(t) { return null === t ? "" : (t = kt[t] || t, String.fromCharCode(t)) },
                        Et = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152],
                        Bt = function() { for (var t = [], e = 15; e--;) t.push(""); return t },
                        It = function t(e, i) { t.prototype.init.call(this), this.field_ = e || 0, this.dataChannel_ = i || 0, this.name_ = "CC" + (1 + (this.field_ << 1 | this.dataChannel_)), this.setConstants(), this.reset(), this.push = function(t) { var e, i, o, n, s; if ((e = 32639 & t.ccData) !== this.lastControlCode_) { if (4096 == (61440 & e) ? this.lastControlCode_ = e : e !== this.PADDING_ && (this.lastControlCode_ = null), o = e >>> 8, n = 255 & e, e !== this.PADDING_)
                                        if (e === this.RESUME_CAPTION_LOADING_) this.mode_ = "popOn";
                                        else if (e === this.END_OF_CAPTION_) this.mode_ = "popOn", this.clearFormatting(t.pts), this.flushDisplayed(t.pts), i = this.displayed_, this.displayed_ = this.nonDisplayed_, this.nonDisplayed_ = i, this.startPts_ = t.pts;
                                    else if (e === this.ROLL_UP_2_ROWS_) this.rollUpRows_ = 2, this.setRollUp(t.pts);
                                    else if (e === this.ROLL_UP_3_ROWS_) this.rollUpRows_ = 3, this.setRollUp(t.pts);
                                    else if (e === this.ROLL_UP_4_ROWS_) this.rollUpRows_ = 4, this.setRollUp(t.pts);
                                    else if (e === this.CARRIAGE_RETURN_) this.clearFormatting(t.pts), this.flushDisplayed(t.pts), this.shiftRowsUp_(), this.startPts_ = t.pts;
                                    else if (e === this.BACKSPACE_) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
                                    else if (e === this.ERASE_DISPLAYED_MEMORY_) this.flushDisplayed(t.pts), this.displayed_ = Bt();
                                    else if (e === this.ERASE_NON_DISPLAYED_MEMORY_) this.nonDisplayed_ = Bt();
                                    else if (e === this.RESUME_DIRECT_CAPTIONING_) "paintOn" !== this.mode_ && (this.flushDisplayed(t.pts), this.displayed_ = Bt()), this.mode_ = "paintOn", this.startPts_ = t.pts;
                                    else if (this.isSpecialCharacter(o, n)) s = Mt((o = (3 & o) << 8) | n), this[this.mode_](t.pts, s), this.column_++;
                                    else if (this.isExtCharacter(o, n)) "popOn" === this.mode_ ? this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1) : this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1), s = Mt((o = (3 & o) << 8) | n), this[this.mode_](t.pts, s), this.column_++;
                                    else if (this.isMidRowCode(o, n)) this.clearFormatting(t.pts), this[this.mode_](t.pts, " "), this.column_++, 14 == (14 & n) && this.addFormatting(t.pts, ["i"]), 1 == (1 & n) && this.addFormatting(t.pts, ["u"]);
                                    else if (this.isOffsetControlCode(o, n)) this.column_ += 3 & n;
                                    else if (this.isPAC(o, n)) { var r = Et.indexOf(7968 & e); "rollUp" === this.mode_ && (r - this.rollUpRows_ + 1 < 0 && (r = this.rollUpRows_ - 1), this.setRollUp(t.pts, r)), r !== this.row_ && (this.clearFormatting(t.pts), this.row_ = r), 1 & n && -1 === this.formatting_.indexOf("u") && this.addFormatting(t.pts, ["u"]), 16 == (16 & e) && (this.column_ = 4 * ((14 & e) >> 1)), this.isColorPAC(n) && 14 == (14 & n) && this.addFormatting(t.pts, ["i"]) } else this.isNormalChar(o) && (0 === n && (n = null), s = Mt(o), s += Mt(n), this[this.mode_](t.pts, s), this.column_ += s.length) } else this.lastControlCode_ = null } };
                    It.prototype = new nt, It.prototype.flushDisplayed = function(t) { var e = this.displayed_.map(function(t) { try { return t.trim() } catch (t) { return "" } }).join("\n").replace(/^\n+|\n+$/g, "");
                        e.length && this.trigger("data", { startPts: this.startPts_, endPts: t, text: e, stream: this.name_ }) }, It.prototype.reset = function() { this.mode_ = "popOn", this.topRow_ = 0, this.startPts_ = 0, this.displayed_ = Bt(), this.nonDisplayed_ = Bt(), this.lastControlCode_ = null, this.column_ = 0, this.row_ = 14, this.rollUpRows_ = 2, this.formatting_ = [] }, It.prototype.setConstants = function() { 0 === this.dataChannel_ ? (this.BASE_ = 16, this.EXT_ = 17, this.CONTROL_ = (20 | this.field_) << 8, this.OFFSET_ = 23) : 1 === this.dataChannel_ && (this.BASE_ = 24, this.EXT_ = 25, this.CONTROL_ = (28 | this.field_) << 8, this.OFFSET_ = 31), this.PADDING_ = 0, this.RESUME_CAPTION_LOADING_ = 32 | this.CONTROL_, this.END_OF_CAPTION_ = 47 | this.CONTROL_, this.ROLL_UP_2_ROWS_ = 37 | this.CONTROL_, this.ROLL_UP_3_ROWS_ = 38 | this.CONTROL_, this.ROLL_UP_4_ROWS_ = 39 | this.CONTROL_, this.CARRIAGE_RETURN_ = 45 | this.CONTROL_, this.RESUME_DIRECT_CAPTIONING_ = 41 | this.CONTROL_, this.BACKSPACE_ = 33 | this.CONTROL_, this.ERASE_DISPLAYED_MEMORY_ = 44 | this.CONTROL_, this.ERASE_NON_DISPLAYED_MEMORY_ = 46 | this.CONTROL_ }, It.prototype.isSpecialCharacter = function(t, e) { return t === this.EXT_ && 48 <= e && e <= 63 }, It.prototype.isExtCharacter = function(t, e) { return (t === this.EXT_ + 1 || t === this.EXT_ + 2) && 32 <= e && e <= 63 }, It.prototype.isMidRowCode = function(t, e) { return t === this.EXT_ && 32 <= e && e <= 47 }, It.prototype.isOffsetControlCode = function(t, e) { return t === this.OFFSET_ && 33 <= e && e <= 35 }, It.prototype.isPAC = function(t, e) { return t >= this.BASE_ && t < this.BASE_ + 8 && 64 <= e && e <= 127 }, It.prototype.isColorPAC = function(t) { return 64 <= t && t <= 79 || 96 <= t && t <= 127 }, It.prototype.isNormalChar = function(t) { return 32 <= t && t <= 127 }, It.prototype.setRollUp = function(t, e) { if ("rollUp" !== this.mode_ && (this.row_ = 14, this.mode_ = "rollUp", this.flushDisplayed(t), this.nonDisplayed_ = Bt(), this.displayed_ = Bt()), void 0 !== e && e !== this.row_)
                            for (var i = 0; i < this.rollUpRows_; i++) this.displayed_[e - i] = this.displayed_[this.row_ - i], this.displayed_[this.row_ - i] = "";
                        void 0 === e && (e = this.row_), this.topRow_ = e - this.rollUpRows_ + 1 }, It.prototype.addFormatting = function(t, e) { this.formatting_ = this.formatting_.concat(e); var i = e.reduce(function(t, e) { return t + "<" + e + ">" }, "");
                        this[this.mode_](t, i) }, It.prototype.clearFormatting = function(t) { if (this.formatting_.length) { var e = this.formatting_.reverse().reduce(function(t, e) { return t + "</" + e + ">" }, "");
                            this.formatting_ = [], this[this.mode_](t, e) } }, It.prototype.popOn = function(t, e) { var i = this.nonDisplayed_[this.row_];
                        i += e, this.nonDisplayed_[this.row_] = i }, It.prototype.rollUp = function(t, e) { var i = this.displayed_[this.row_];
                        i += e, this.displayed_[this.row_] = i }, It.prototype.shiftRowsUp_ = function() { var t; for (t = 0; t < this.topRow_; t++) this.displayed_[t] = ""; for (t = this.row_ + 1; t < 15; t++) this.displayed_[t] = ""; for (t = this.topRow_; t < this.row_; t++) this.displayed_[t] = this.displayed_[t + 1];
                        this.displayed_[this.row_] = "" }, It.prototype.paintOn = function(t, e) { var i = this.displayed_[this.row_];
                        i += e, this.displayed_[this.row_] = i }; var Dt = { CaptionStream: Pt, Cea608Stream: It },
                        Lt = { H264_STREAM_TYPE: 27, ADTS_STREAM_TYPE: 15, METADATA_STREAM_TYPE: 21 },
                        Ot = function(t, e) { var i = 1; for (e < t && (i = -1); 4294967296 < Math.abs(e - t);) t += 8589934592 * i; return t },
                        Rt = function t(e) { var i, o;
                            t.prototype.init.call(this), this.type_ = e, this.push = function(t) { t.type === this.type_ && (void 0 === o && (o = t.dts), t.dts = Ot(t.dts, o), t.pts = Ot(t.pts, o), i = t.dts, this.trigger("data", t)) }, this.flush = function() { o = i, this.trigger("done") }, this.discontinuity = function() { i = o = void 0 } };
                    Rt.prototype = new nt; var Ft, Vt = Rt,
                        Gt = function(t, e, i) { var o, n = ""; for (o = e; o < i; o++) n += "%" + ("00" + t[o].toString(16)).slice(-2); return n },
                        Ut = function(t, e, i) { return decodeURIComponent(Gt(t, e, i)) },
                        Nt = function(t) { return t[0] << 21 | t[1] << 14 | t[2] << 7 | t[3] },
                        jt = { TXXX: function(t) { var e; if (3 === t.data[0]) { for (e = 1; e < t.data.length; e++)
                                        if (0 === t.data[e]) { t.description = Ut(t.data, 1, e), t.value = Ut(t.data, e + 1, t.data.length).replace(/\0*$/, ""); break } t.data = t.value } }, WXXX: function(t) { var e; if (3 === t.data[0])
                                    for (e = 1; e < t.data.length; e++)
                                        if (0 === t.data[e]) { t.description = Ut(t.data, 1, e), t.url = Ut(t.data, e + 1, t.data.length); break } }, PRIV: function(t) { var e, i; for (e = 0; e < t.data.length; e++)
                                    if (0 === t.data[e]) { t.owner = (i = t.data, unescape(Gt(i, 0, e))); break } t.privateData = t.data.subarray(e + 1), t.data = t.privateData } };
                    (Ft = function(t) { var e, i = { debug: !(!t || !t.debug), descriptor: t && t.descriptor },
                            o = 0,
                            n = [],
                            s = 0; if (Ft.prototype.init.call(this), this.dispatchType = Lt.METADATA_STREAM_TYPE.toString(16), i.descriptor)
                            for (e = 0; e < i.descriptor.length; e++) this.dispatchType += ("00" + i.descriptor[e].toString(16)).slice(-2);
                        this.push = function(t) { var e, r, a, h, l; if ("timed-metadata" === t.type)
                                if (t.dataAlignmentIndicator && (s = 0, n.length = 0), 0 === n.length && (t.data.length < 10 || t.data[0] !== "I".charCodeAt(0) || t.data[1] !== "D".charCodeAt(0) || t.data[2] !== "3".charCodeAt(0))) i.debug;
                                else if (n.push(t), s += t.data.byteLength, 1 === n.length && (o = Nt(t.data.subarray(6, 10)), o += 10), !(s < o)) { for (e = { data: new Uint8Array(o), frames: [], pts: n[0].pts, dts: n[0].dts }, l = 0; l < o;) e.data.set(n[0].data.subarray(0, o - l), l), l += n[0].data.byteLength, s -= n[0].data.byteLength, n.shift();
                                r = 10, 64 & e.data[5] && (r += 4, r += Nt(e.data.subarray(10, 14)), o -= Nt(e.data.subarray(16, 20)));
                                do { if ((a = Nt(e.data.subarray(r + 4, r + 8))) < 1) return; if ((h = { id: String.fromCharCode(e.data[r], e.data[r + 1], e.data[r + 2], e.data[r + 3]), data: e.data.subarray(r + 10, r + a + 10) }).key = h.id, jt[h.id] && (jt[h.id](h), "com.apple.streaming.transportStreamTimestamp" === h.owner)) { var c = h.data,
                                            d = (1 & c[3]) << 30 | c[4] << 22 | c[5] << 14 | c[6] << 6 | c[7] >>> 2;
                                        d *= 4, d += 3 & c[7], h.timeStamp = d, void 0 === e.pts && void 0 === e.dts && (e.pts = h.timeStamp, e.dts = h.timeStamp), this.trigger("timestamp", h) } e.frames.push(h), r += 10, r += a } while (r < o);
                                this.trigger("data", e) } } }).prototype = new nt; var Wt, Xt, Ht, zt = Ft,
                        Jt = Vt;
                    (Wt = function() { var t = new Uint8Array(188),
                            e = 0;
                        Wt.prototype.init.call(this), this.push = function(i) { var o, n = 0,
                                s = 188; for (e ? ((o = new Uint8Array(i.byteLength + e)).set(t.subarray(0, e)), o.set(i, e), e = 0) : o = i; s < o.byteLength;) 71 !== o[n] || 71 !== o[s] ? (n++, s++) : (this.trigger("data", o.subarray(n, s)), n += 188, s += 188);
                            n < o.byteLength && (t.set(o.subarray(n), 0), e = o.byteLength - n) }, this.flush = function() { 188 === e && 71 === t[0] && (this.trigger("data", t), e = 0), this.trigger("done") } }).prototype = new nt, (Xt = function() { var t, e, i, o;
                        Xt.prototype.init.call(this), (o = this).packetsWaitingForPmt = [], this.programMapTable = void 0, t = function(t, o) { var n = 0;
                            o.payloadUnitStartIndicator && (n += t[n] + 1), "pat" === o.type ? e(t.subarray(n), o) : i(t.subarray(n), o) }, e = function(t, e) { e.section_number = t[7], e.last_section_number = t[8], o.pmtPid = (31 & t[10]) << 8 | t[11], e.pmtPid = o.pmtPid }, i = function(t, e) { var i, n; if (1 & t[5]) { for (o.programMapTable = { video: null, audio: null, "timed-metadata": {} }, i = 3 + ((15 & t[1]) << 8 | t[2]) - 4, n = 12 + ((15 & t[10]) << 8 | t[11]); n < i;) { var s = t[n],
                                        r = (31 & t[n + 1]) << 8 | t[n + 2];
                                    s === Lt.H264_STREAM_TYPE && null === o.programMapTable.video ? o.programMapTable.video = r : s === Lt.ADTS_STREAM_TYPE && null === o.programMapTable.audio ? o.programMapTable.audio = r : s === Lt.METADATA_STREAM_TYPE && (o.programMapTable["timed-metadata"][r] = s), n += 5 + ((15 & t[n + 3]) << 8 | t[n + 4]) } e.programMapTable = o.programMapTable } }, this.push = function(e) { var i = {},
                                o = 4; if (i.payloadUnitStartIndicator = !!(64 & e[1]), i.pid = 31 & e[1], i.pid <<= 8, i.pid |= e[2], 1 < (48 & e[3]) >>> 4 && (o += e[o] + 1), 0 === i.pid) i.type = "pat", t(e.subarray(o), i), this.trigger("data", i);
                            else if (i.pid === this.pmtPid)
                                for (i.type = "pmt", t(e.subarray(o), i), this.trigger("data", i); this.packetsWaitingForPmt.length;) this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
                            else void 0 === this.programMapTable ? this.packetsWaitingForPmt.push([e, o, i]) : this.processPes_(e, o, i) }, this.processPes_ = function(t, e, i) { i.pid === this.programMapTable.video ? i.streamType = Lt.H264_STREAM_TYPE : i.pid === this.programMapTable.audio ? i.streamType = Lt.ADTS_STREAM_TYPE : i.streamType = this.programMapTable["timed-metadata"][i.pid], i.type = "pes", i.data = t.subarray(e), this.trigger("data", i) } }).prototype = new nt, Xt.STREAM_TYPES = { h264: 27, adts: 15 }, (Ht = function() { var t = this,
                            e = { data: [], size: 0 },
                            i = { data: [], size: 0 },
                            o = { data: [], size: 0 },
                            n = function(e, i, o) { var n, s, r = new Uint8Array(e.size),
                                    a = { type: i },
                                    h = 0,
                                    l = 0; if (e.data.length && !(e.size < 9)) { for (a.trackId = e.data[0].pid, h = 0; h < e.data.length; h++) s = e.data[h], r.set(s.data, l), l += s.data.byteLength; var c, d, u;
                                    c = r, (d = a).packetLength = 6 + (c[4] << 8 | c[5]), d.dataAlignmentIndicator = 0 != (4 & c[6]), 192 & (u = c[7]) && (d.pts = (14 & c[9]) << 27 | (255 & c[10]) << 20 | (254 & c[11]) << 12 | (255 & c[12]) << 5 | (254 & c[13]) >>> 3, d.pts *= 4, d.pts += (6 & c[13]) >>> 1, d.dts = d.pts, 64 & u && (d.dts = (14 & c[14]) << 27 | (255 & c[15]) << 20 | (254 & c[16]) << 12 | (255 & c[17]) << 5 | (254 & c[18]) >>> 3, d.dts *= 4, d.dts += (6 & c[18]) >>> 1)), d.data = c.subarray(9 + c[8]), n = "video" === i || a.packetLength <= e.size, (o || n) && (e.size = 0, e.data.length = 0), n && t.trigger("data", a) } };
                        Ht.prototype.init.call(this), this.push = function(s) {
                            ({ pat: function() {}, pes: function() { var t, r; switch (s.streamType) {
                                        case Lt.H264_STREAM_TYPE:
                                        case Lt.H264_STREAM_TYPE:
                                            t = e, r = "video"; break;
                                        case Lt.ADTS_STREAM_TYPE:
                                            t = i, r = "audio"; break;
                                        case Lt.METADATA_STREAM_TYPE:
                                            t = o, r = "timed-metadata"; break;
                                        default:
                                            return } s.payloadUnitStartIndicator && n(t, r, !0), t.data.push(s), t.size += s.data.byteLength }, pmt: function() { var e = { type: "metadata", tracks: [] },
                                        i = s.programMapTable;
                                    null !== i.video && e.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +i.video, codec: "avc", type: "video" }), null !== i.audio && e.tracks.push({ timelineStartInfo: { baseMediaDecodeTime: 0 }, id: +i.audio, codec: "adts", type: "audio" }), t.trigger("data", e) } })[s.type]() }, this.flush = function() { n(e, "video"), n(i, "audio"), n(o, "timed-metadata"), this.trigger("done") } }).prototype = new nt; var qt = { PAT_PID: 0, MP2T_PACKET_LENGTH: 188, TransportPacketStream: Wt, TransportParseStream: Xt, ElementaryStream: Ht, TimestampRolloverStream: Jt, CaptionStream: Dt.CaptionStream, Cea608Stream: Dt.Cea608Stream, MetadataStream: zt }; for (var Yt in Lt) Lt.hasOwnProperty(Yt) && (qt[Yt] = Lt[Yt]); var Kt, Zt = qt,
                        Qt = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
                    (Kt = function() { var t;
                        Kt.prototype.init.call(this), this.push = function(e) { var i, o, n, s, r, a, h = 0,
                                l = 0; if ("audio" === e.type)
                                for (t ? (s = t, (t = new Uint8Array(s.byteLength + e.data.byteLength)).set(s), t.set(e.data, s.byteLength)) : t = e.data; h + 5 < t.length;)
                                    if (255 === t[h] && 240 == (246 & t[h + 1])) { if (o = 2 * (1 & ~t[h + 1]), i = (3 & t[h + 3]) << 11 | t[h + 4] << 3 | (224 & t[h + 5]) >> 5, a = 9e4 * (r = 1024 * (1 + (3 & t[h + 6]))) / Qt[(60 & t[h + 2]) >>> 2], n = h + i, t.byteLength < n) return; if (this.trigger("data", { pts: e.pts + l * a, dts: e.dts + l * a, sampleCount: r, audioobjecttype: 1 + (t[h + 2] >>> 6 & 3), channelcount: (1 & t[h + 2]) << 2 | (192 & t[h + 3]) >>> 6, samplerate: Qt[(60 & t[h + 2]) >>> 2], samplingfrequencyindex: (60 & t[h + 2]) >>> 2, samplesize: 16, data: t.subarray(h + 7 + o, n) }), t.byteLength === n) return void(t = void 0);
                                        l++, t = t.subarray(n) } else h++ }, this.flush = function() { this.trigger("done") } }).prototype = new nt; var $t, te, ee, ie = Kt,
                        oe = function(t) { var e = t.byteLength,
                                i = 0,
                                o = 0;
                            this.length = function() { return 8 * e }, this.bitsAvailable = function() { return 8 * e + o }, this.loadWord = function() { var n = t.byteLength - e,
                                    s = new Uint8Array(4),
                                    r = Math.min(4, e); if (0 === r) throw new Error("no bytes available");
                                s.set(t.subarray(n, n + r)), i = new DataView(s.buffer).getUint32(0), o = 8 * r, e -= r }, this.skipBits = function(t) { var n;
                                t < o || (t -= o, t -= 8 * (n = Math.floor(t / 8)), e -= n, this.loadWord()), i <<= t, o -= t }, this.readBits = function(t) { var n = Math.min(o, t),
                                    s = i >>> 32 - n; return 0 < (o -= n) ? i <<= n : 0 < e && this.loadWord(), 0 < (n = t - n) ? s << n | this.readBits(n) : s }, this.skipLeadingZeros = function() { var t; for (t = 0; t < o; ++t)
                                    if (0 != (i & 2147483648 >>> t)) return i <<= t, o -= t, t; return this.loadWord(), t + this.skipLeadingZeros() }, this.skipUnsignedExpGolomb = function() { this.skipBits(1 + this.skipLeadingZeros()) }, this.skipExpGolomb = function() { this.skipBits(1 + this.skipLeadingZeros()) }, this.readUnsignedExpGolomb = function() { var t = this.skipLeadingZeros(); return this.readBits(t + 1) - 1 }, this.readExpGolomb = function() { var t = this.readUnsignedExpGolomb(); return 1 & t ? 1 + t >>> 1 : -1 * (t >>> 1) }, this.readBoolean = function() { return 1 === this.readBits(1) }, this.readUnsignedByte = function() { return this.readBits(8) }, this.loadWord() };
                    (te = function() { var t, e, i = 0;
                        te.prototype.init.call(this), this.push = function(o) { var n; for (e = e ? ((n = new Uint8Array(e.byteLength + o.data.byteLength)).set(e), n.set(o.data, e.byteLength), n) : o.data; i < e.byteLength - 3; i++)
                                if (1 === e[i + 2]) { t = i + 5; break } for (; t < e.byteLength;) switch (e[t]) {
                                case 0:
                                    if (0 !== e[t - 1]) { t += 2; break } if (0 !== e[t - 2]) { t++; break } for (i + 3 !== t - 2 && this.trigger("data", e.subarray(i + 3, t - 2)); 1 !== e[++t] && t < e.length;);
                                    i = t - 2, t += 3; break;
                                case 1:
                                    if (0 !== e[t - 1] || 0 !== e[t - 2]) { t += 3; break } this.trigger("data", e.subarray(i + 3, t - 2)), i = t - 2, t += 3; break;
                                default:
                                    t += 3 } e = e.subarray(i), t -= i, i = 0 }, this.flush = function() { e && 3 < e.byteLength && this.trigger("data", e.subarray(i + 3)), e = null, i = 0, this.trigger("done") } }).prototype = new nt, ee = { 100: !0, 110: !0, 122: !0, 244: !0, 44: !0, 83: !0, 86: !0, 118: !0, 128: !0, 138: !0, 139: !0, 134: !0 }, ($t = function() { var t, e, i, o, n, s, r, a = new te;
                        $t.prototype.init.call(this), (t = this).push = function(t) { "video" === t.type && (e = t.trackId, i = t.pts, o = t.dts, a.push(t)) }, a.on("data", function(r) { var a = { trackId: e, pts: i, dts: o, data: r }; switch (31 & r[0]) {
                                case 5:
                                    a.nalUnitType = "slice_layer_without_partitioning_rbsp_idr"; break;
                                case 6:
                                    a.nalUnitType = "sei_rbsp", a.escapedRBSP = n(r.subarray(1)); break;
                                case 7:
                                    a.nalUnitType = "seq_parameter_set_rbsp", a.escapedRBSP = n(r.subarray(1)), a.config = s(a.escapedRBSP); break;
                                case 8:
                                    a.nalUnitType = "pic_parameter_set_rbsp"; break;
                                case 9:
                                    a.nalUnitType = "access_unit_delimiter_rbsp" } t.trigger("data", a) }), a.on("done", function() { t.trigger("done") }), this.flush = function() { a.flush() }, r = function(t, e) { var i, o = 8,
                                n = 8; for (i = 0; i < t; i++) 0 !== n && (n = (o + e.readExpGolomb() + 256) % 256), o = 0 === n ? o : n }, n = function(t) { for (var e, i, o = t.byteLength, n = [], s = 1; s < o - 2;) 0 === t[s] && 0 === t[s + 1] && 3 === t[s + 2] ? (n.push(s + 2), s += 2) : s++; if (0 === n.length) return t;
                            e = o - n.length, i = new Uint8Array(e); var r = 0; for (s = 0; s < e; r++, s++) r === n[0] && (r++, n.shift()), i[s] = t[r]; return i }, s = function(t) { var e, i, o, n, s, a, h, l, c, d, u, p, m, f = 0,
                                y = 0,
                                b = 0,
                                g = 0,
                                _ = 1; if (i = (e = new oe(t)).readUnsignedByte(), n = e.readUnsignedByte(), o = e.readUnsignedByte(), e.skipUnsignedExpGolomb(), ee[i] && (3 === (s = e.readUnsignedExpGolomb()) && e.skipBits(1), e.skipUnsignedExpGolomb(), e.skipUnsignedExpGolomb(), e.skipBits(1), e.readBoolean()))
                                for (u = 3 !== s ? 8 : 12, m = 0; m < u; m++) e.readBoolean() && r(m < 6 ? 16 : 64, e); if (e.skipUnsignedExpGolomb(), 0 === (a = e.readUnsignedExpGolomb())) e.readUnsignedExpGolomb();
                            else if (1 === a)
                                for (e.skipBits(1), e.skipExpGolomb(), e.skipExpGolomb(), h = e.readUnsignedExpGolomb(), m = 0; m < h; m++) e.skipExpGolomb(); if (e.skipUnsignedExpGolomb(), e.skipBits(1), l = e.readUnsignedExpGolomb(), c = e.readUnsignedExpGolomb(), 0 === (d = e.readBits(1)) && e.skipBits(1), e.skipBits(1), e.readBoolean() && (f = e.readUnsignedExpGolomb(), y = e.readUnsignedExpGolomb(), b = e.readUnsignedExpGolomb(), g = e.readUnsignedExpGolomb()), e.readBoolean() && e.readBoolean()) { switch (e.readUnsignedByte()) {
                                    case 1:
                                        p = [1, 1]; break;
                                    case 2:
                                        p = [12, 11]; break;
                                    case 3:
                                        p = [10, 11]; break;
                                    case 4:
                                        p = [16, 11]; break;
                                    case 5:
                                        p = [40, 33]; break;
                                    case 6:
                                        p = [24, 11]; break;
                                    case 7:
                                        p = [20, 11]; break;
                                    case 8:
                                        p = [32, 11]; break;
                                    case 9:
                                        p = [80, 33]; break;
                                    case 10:
                                        p = [18, 11]; break;
                                    case 11:
                                        p = [15, 11]; break;
                                    case 12:
                                        p = [64, 33]; break;
                                    case 13:
                                        p = [160, 99]; break;
                                    case 14:
                                        p = [4, 3]; break;
                                    case 15:
                                        p = [3, 2]; break;
                                    case 16:
                                        p = [2, 1]; break;
                                    case 255:
                                        p = [e.readUnsignedByte() << 8 | e.readUnsignedByte(), e.readUnsignedByte() << 8 | e.readUnsignedByte()] } p && (_ = p[0] / p[1]) } return { profileIdc: i, levelIdc: o, profileCompatibility: n, width: Math.ceil((16 * (l + 1) - 2 * f - 2 * y) * _), height: (2 - d) * (c + 1) * 16 - 2 * b - 2 * g } } }).prototype = new nt; var ne, se = { H264Stream: $t, NalByteStream: te },
                        re = function(t, e) { var i = t[e + 6] << 21 | t[e + 7] << 14 | t[e + 8] << 7 | t[e + 9]; return (16 & t[e + 5]) >> 4 ? i + 20 : i + 10 },
                        ae = function(t, e) { var i = (224 & t[e + 5]) >> 5,
                                o = t[e + 4] << 3; return 6144 & t[e + 3] | o | i };
                    (ne = function() { var t = new Uint8Array,
                            e = 0;
                        ne.prototype.init.call(this), this.setTimestamp = function(t) { e = t }, this.push = function(i) { var o, n, s, r, a = 0,
                                h = 0; for (t.length ? (r = t.length, (t = new Uint8Array(i.byteLength + r)).set(t.subarray(0, r)), t.set(i, r)) : t = i; 3 <= t.length - h;)
                                if (t[h] !== "I".charCodeAt(0) || t[h + 1] !== "D".charCodeAt(0) || t[h + 2] !== "3".charCodeAt(0))
                                    if (255 != (255 & t[h]) || 240 != (240 & t[h + 1])) h++;
                                    else { if (t.length - h < 7) break; if (h + (a = ae(t, h)) > t.length) break;
                                        s = { type: "audio", data: t.subarray(h, h + a), pts: e, dts: e }, this.trigger("data", s), h += a } else { if (t.length - h < 10) break; if (h + (a = re(t, h)) > t.length) break;
                                n = { type: "timed-metadata", data: t.subarray(h, h + a) }, this.trigger("data", n), h += a } o = t.length - h, t = 0 < o ? t.subarray(h) : new Uint8Array } }).prototype = new nt; var he, le, ce, de, ue = ne,
                        pe = se.H264Stream,
                        me = function(t) { return t[0] === "I".charCodeAt(0) && t[1] === "D".charCodeAt(0) && t[2] === "3".charCodeAt(0) },
                        fe = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"],
                        ye = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility"],
                        be = function(t, e) { var i; if (t.length !== e.length) return !1; for (i = 0; i < t.length; i++)
                                if (t[i] !== e[i]) return !1; return !0 };
                    (le = function(t, e) { var i = [],
                            o = 0,
                            n = 0,
                            s = 0,
                            r = 1 / 0;
                        e = e || {}, le.prototype.init.call(this), this.push = function(e) { Ct(t, e), t && fe.forEach(function(i) { t[i] = e[i] }), i.push(e) }, this.setEarliestDts = function(e) { n = e - t.timelineStartInfo.baseMediaDecodeTime }, this.setVideoBaseMediaDecodeTime = function(t) { r = t }, this.setAudioAppendStart = function(t) { s = t }, this.flush = function() { var a, h, l, c;
                            0 !== i.length && (a = gt(i, t, n), t.baseMediaDecodeTime = St(t, e.keepOriginalTimestamps), bt(t, a, s, r), t.samples = _t(a), l = J.mdat(vt(a)), i = [], h = J.moof(o, [t]), c = new Uint8Array(h.byteLength + l.byteLength), o++, c.set(h), c.set(l, h.byteLength), xt(t), this.trigger("data", { track: t, boxes: c })), this.trigger("done", "AudioSegmentStream") } }).prototype = new nt, (he = function(t, e) { var i, o, n = 0,
                            s = [],
                            r = [];
                        e = e || {}, he.prototype.init.call(this), delete t.minPTS, this.gopCache_ = [], this.push = function(e) { Ct(t, e), "seq_parameter_set_rbsp" !== e.nalUnitType || i || (i = e.config, t.sps = [e.data], ye.forEach(function(e) { t[e] = i[e] }, this)), "pic_parameter_set_rbsp" !== e.nalUnitType || o || (o = e.data, t.pps = [e.data]), s.push(e) }, this.flush = function() { for (var i, o, a, h, l, c; s.length && "access_unit_delimiter_rbsp" !== s[0].nalUnitType;) s.shift(); if (0 === s.length) return this.resetStream_(), void this.trigger("done", "VideoSegmentStream"); if (i = st(s), (a = rt(i))[0][0].keyFrame || ((o = this.getGopForFusion_(s[0], t)) ? (a.unshift(o), a.byteLength += o.byteLength, a.nalCount += o.nalCount, a.pts = o.pts, a.dts = o.dts, a.duration += o.duration) : a = at(a)), r.length) { var d; if (!(d = e.alignGopsAtEnd ? this.alignGopsAtEnd_(a) : this.alignGopsAtStart_(a))) return this.gopCache_.unshift({ gop: a.pop(), pps: t.pps, sps: t.sps }), this.gopCache_.length = Math.min(6, this.gopCache_.length), s = [], this.resetStream_(), void this.trigger("done", "VideoSegmentStream");
                                xt(t), a = d } Ct(t, a), t.samples = ht(a), l = J.mdat(lt(a)), t.baseMediaDecodeTime = St(t, e.keepOriginalTimestamps), this.trigger("processedGopsInfo", a.map(function(t) { return { pts: t.pts, dts: t.dts, byteLength: t.byteLength } })), this.gopCache_.unshift({ gop: a.pop(), pps: t.pps, sps: t.sps }), this.gopCache_.length = Math.min(6, this.gopCache_.length), s = [], this.trigger("baseMediaDecodeTime", t.baseMediaDecodeTime), this.trigger("timelineStartInfo", t.timelineStartInfo), h = J.moof(n, [t]), c = new Uint8Array(h.byteLength + l.byteLength), n++, c.set(h), c.set(l, h.byteLength), this.trigger("data", { track: t, boxes: c }), this.resetStream_(), this.trigger("done", "VideoSegmentStream") }, this.resetStream_ = function() { xt(t), o = i = void 0 }, this.getGopForFusion_ = function(e) { var i, o, n, s, r, a = 1 / 0; for (r = 0; r < this.gopCache_.length; r++) n = (s = this.gopCache_[r]).gop, t.pps && be(t.pps[0], s.pps[0]) && t.sps && be(t.sps[0], s.sps[0]) && (n.dts < t.timelineStartInfo.dts || -1e4 <= (i = e.dts - n.dts - n.duration) && i <= 45e3 && (!o || i < a) && (o = s, a = i)); return o ? o.gop : null }, this.alignGopsAtStart_ = function(t) { var e, i, o, n, s, a, h, l; for (s = t.byteLength, a = t.nalCount, h = t.duration, e = i = 0; e < r.length && i < t.length && (o = r[e], n = t[i], o.pts !== n.pts);) n.pts > o.pts ? e++ : (i++, s -= n.byteLength, a -= n.nalCount, h -= n.duration); return 0 === i ? t : i === t.length ? null : ((l = t.slice(i)).byteLength = s, l.duration = h, l.nalCount = a, l.pts = l[0].pts, l.dts = l[0].dts, l) }, this.alignGopsAtEnd_ = function(t) { var e, i, o, n, s, a, h; for (e = r.length - 1, i = t.length - 1, s = null, a = !1; 0 <= e && 0 <= i;) { if (o = r[e], n = t[i], o.pts === n.pts) { a = !0; break } o.pts > n.pts ? e-- : (e === r.length - 1 && (s = i), i--) } if (!a && null === s) return null; if (0 === (h = a ? i : s)) return t; var l = t.slice(h),
                                c = l.reduce(function(t, e) { return t.byteLength += e.byteLength, t.duration += e.duration, t.nalCount += e.nalCount, t }, { byteLength: 0, duration: 0, nalCount: 0 }); return l.byteLength = c.byteLength, l.duration = c.duration, l.nalCount = c.nalCount, l.pts = l[0].pts, l.dts = l[0].dts, l }, this.alignGopsWith = function(t) { r = t } }).prototype = new nt, (de = function(t, e) { this.numberOfTracks = 0, this.metadataStream = e, void 0 !== (t = t || {}).remux ? this.remuxTracks = !!t.remux : this.remuxTracks = !0, "boolean" == typeof t.keepOriginalTimestamps && (this.keepOriginalTimestamps = t.keepOriginalTimestamps), this.pendingTracks = [], this.videoTrack = null, this.pendingBoxes = [], this.pendingCaptions = [], this.pendingMetadata = [], this.pendingBytes = 0, this.emittedTracks = 0, de.prototype.init.call(this), this.push = function(t) { return t.text ? this.pendingCaptions.push(t) : t.frames ? this.pendingMetadata.push(t) : (this.pendingTracks.push(t.track), this.pendingBoxes.push(t.boxes), this.pendingBytes += t.boxes.byteLength, "video" === t.track.type && (this.videoTrack = t.track), void("audio" === t.track.type && (this.audioTrack = t.track))) } }).prototype = new nt, de.prototype.flush = function(t) { var e, i, o, n, s = 0,
                            r = { captions: [], captionStreams: {}, metadata: [], info: {} },
                            a = 0; if (this.pendingTracks.length < this.numberOfTracks) { if ("VideoSegmentStream" !== t && "AudioSegmentStream" !== t) return; if (this.remuxTracks) return; if (0 === this.pendingTracks.length) return void(++this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0)) } for (this.videoTrack ? (a = this.videoTrack.timelineStartInfo.pts, ye.forEach(function(t) { r.info[t] = this.videoTrack[t] }, this)) : this.audioTrack && (a = this.audioTrack.timelineStartInfo.pts, fe.forEach(function(t) { r.info[t] = this.audioTrack[t] }, this)), 1 === this.pendingTracks.length ? r.type = this.pendingTracks[0].type : r.type = "combined", this.emittedTracks += this.pendingTracks.length, o = J.initSegment(this.pendingTracks), r.initSegment = new Uint8Array(o.byteLength), r.initSegment.set(o), r.data = new Uint8Array(this.pendingBytes), n = 0; n < this.pendingBoxes.length; n++) r.data.set(this.pendingBoxes[n], s), s += this.pendingBoxes[n].byteLength; for (n = 0; n < this.pendingCaptions.length; n++)(e = this.pendingCaptions[n]).startTime = e.startPts, this.keepOriginalTimestamps || (e.startTime -= a), e.startTime /= 9e4, e.endTime = e.endPts, this.keepOriginalTimestamps || (e.endTime -= a), e.endTime /= 9e4, r.captionStreams[e.stream] = !0, r.captions.push(e); for (n = 0; n < this.pendingMetadata.length; n++)(i = this.pendingMetadata[n]).cueTime = i.pts, this.keepOriginalTimestamps || (i.cueTime -= a), i.cueTime /= 9e4, r.metadata.push(i);
                        r.metadata.dispatchType = this.metadataStream.dispatchType, this.pendingTracks.length = 0, this.videoTrack = null, this.pendingBoxes.length = 0, this.pendingCaptions.length = 0, this.pendingBytes = 0, this.pendingMetadata.length = 0, this.trigger("data", r), this.emittedTracks >= this.numberOfTracks && (this.trigger("done"), this.emittedTracks = 0) }, (ce = function(t) { var e, i, o = this,
                            n = !0;
                        ce.prototype.init.call(this), t = t || {}, this.baseMediaDecodeTime = t.baseMediaDecodeTime || 0, this.transmuxPipeline_ = {}, this.setupAacPipeline = function() { var e = {};
                            (this.transmuxPipeline_ = e).type = "aac", e.metadataStream = new Zt.MetadataStream, e.aacStream = new ue, e.audioTimestampRolloverStream = new Zt.TimestampRolloverStream("audio"), e.timedMetadataTimestampRolloverStream = new Zt.TimestampRolloverStream("timed-metadata"), e.adtsStream = new ie, e.coalesceStream = new de(t, e.metadataStream), e.headOfPipeline = e.aacStream, e.aacStream.pipe(e.audioTimestampRolloverStream).pipe(e.adtsStream), e.aacStream.pipe(e.timedMetadataTimestampRolloverStream).pipe(e.metadataStream).pipe(e.coalesceStream), e.metadataStream.on("timestamp", function(t) { e.aacStream.setTimestamp(t.timeStamp) }), e.aacStream.on("data", function(n) { "timed-metadata" !== n.type || e.audioSegmentStream || (i = i || { timelineStartInfo: { baseMediaDecodeTime: o.baseMediaDecodeTime }, codec: "adts", type: "audio" }, e.coalesceStream.numberOfTracks++, e.audioSegmentStream = new le(i, t), e.adtsStream.pipe(e.audioSegmentStream).pipe(e.coalesceStream)) }), e.coalesceStream.on("data", this.trigger.bind(this, "data")), e.coalesceStream.on("done", this.trigger.bind(this, "done")) }, this.setupTsPipeline = function() { var n = {};
                            (this.transmuxPipeline_ = n).type = "ts", n.metadataStream = new Zt.MetadataStream, n.packetStream = new Zt.TransportPacketStream, n.parseStream = new Zt.TransportParseStream, n.elementaryStream = new Zt.ElementaryStream, n.videoTimestampRolloverStream = new Zt.TimestampRolloverStream("video"), n.audioTimestampRolloverStream = new Zt.TimestampRolloverStream("audio"), n.timedMetadataTimestampRolloverStream = new Zt.TimestampRolloverStream("timed-metadata"), n.adtsStream = new ie, n.h264Stream = new pe, n.captionStream = new Zt.CaptionStream, n.coalesceStream = new de(t, n.metadataStream), n.headOfPipeline = n.packetStream, n.packetStream.pipe(n.parseStream).pipe(n.elementaryStream), n.elementaryStream.pipe(n.videoTimestampRolloverStream).pipe(n.h264Stream), n.elementaryStream.pipe(n.audioTimestampRolloverStream).pipe(n.adtsStream), n.elementaryStream.pipe(n.timedMetadataTimestampRolloverStream).pipe(n.metadataStream).pipe(n.coalesceStream), n.h264Stream.pipe(n.captionStream).pipe(n.coalesceStream), n.elementaryStream.on("data", function(s) { var r; if ("metadata" === s.type) { for (r = s.tracks.length; r--;) e || "video" !== s.tracks[r].type ? i || "audio" !== s.tracks[r].type || ((i = s.tracks[r]).timelineStartInfo.baseMediaDecodeTime = o.baseMediaDecodeTime) : (e = s.tracks[r]).timelineStartInfo.baseMediaDecodeTime = o.baseMediaDecodeTime;
                                    e && !n.videoSegmentStream && (n.coalesceStream.numberOfTracks++, n.videoSegmentStream = new he(e, t), n.videoSegmentStream.on("timelineStartInfo", function(t) { i && (i.timelineStartInfo = t, n.audioSegmentStream.setEarliestDts(t.dts)) }), n.videoSegmentStream.on("processedGopsInfo", o.trigger.bind(o, "gopInfo")), n.videoSegmentStream.on("baseMediaDecodeTime", function(t) { i && n.audioSegmentStream.setVideoBaseMediaDecodeTime(t) }), n.h264Stream.pipe(n.videoSegmentStream).pipe(n.coalesceStream)), i && !n.audioSegmentStream && (n.coalesceStream.numberOfTracks++, n.audioSegmentStream = new le(i, t), n.adtsStream.pipe(n.audioSegmentStream).pipe(n.coalesceStream)) } }), n.coalesceStream.on("data", this.trigger.bind(this, "data")), n.coalesceStream.on("done", this.trigger.bind(this, "done")) }, this.setBaseMediaDecodeTime = function(o) { var n = this.transmuxPipeline_;
                            t.keepOriginalTimestamps || (this.baseMediaDecodeTime = o), i && (i.timelineStartInfo.dts = void 0, i.timelineStartInfo.pts = void 0, xt(i), t.keepOriginalTimestamps || (i.timelineStartInfo.baseMediaDecodeTime = o), n.audioTimestampRolloverStream && n.audioTimestampRolloverStream.discontinuity()), e && (n.videoSegmentStream && (n.videoSegmentStream.gopCache_ = [], n.videoTimestampRolloverStream.discontinuity()), e.timelineStartInfo.dts = void 0, e.timelineStartInfo.pts = void 0, xt(e), n.captionStream.reset(), t.keepOriginalTimestamps || (e.timelineStartInfo.baseMediaDecodeTime = o)), n.timedMetadataTimestampRolloverStream && n.timedMetadataTimestampRolloverStream.discontinuity() }, this.setAudioAppendStart = function(t) { i && this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(t) }, this.alignGopsWith = function(t) { e && this.transmuxPipeline_.videoSegmentStream && this.transmuxPipeline_.videoSegmentStream.alignGopsWith(t) }, this.push = function(t) { if (n) { var e = me(t);
                                e && "aac" !== this.transmuxPipeline_.type ? this.setupAacPipeline() : e || "ts" === this.transmuxPipeline_.type || this.setupTsPipeline(), n = !1 } this.transmuxPipeline_.headOfPipeline.push(t) }, this.flush = function() { n = !0, this.transmuxPipeline_.headOfPipeline.flush() }, this.resetCaptions = function() { this.transmuxPipeline_.captionStream && this.transmuxPipeline_.captionStream.reset() } }).prototype = new nt; var ge, _e, ve = { Transmuxer: ce, VideoSegmentStream: he, AudioSegmentStream: le, AUDIO_PROPERTIES: fe, VIDEO_PROPERTIES: ye },
                        xe = Y.parseType,
                        Se = function(t) { return new Date(1e3 * t - 20828448e5) },
                        Ce = function(t) { return { isLeading: (12 & t[0]) >>> 2, dependsOn: 3 & t[0], isDependedOn: (192 & t[1]) >>> 6, hasRedundancy: (48 & t[1]) >>> 4, paddingValue: (14 & t[1]) >>> 1, isNonSyncSample: 1 & t[1], degradationPriority: t[2] << 8 | t[3] } },
                        we = { avc1: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength); return { dataReferenceIndex: e.getUint16(6), width: e.getUint16(24), height: e.getUint16(26), horizresolution: e.getUint16(28) + e.getUint16(30) / 16, vertresolution: e.getUint16(32) + e.getUint16(34) / 16, frameCount: e.getUint16(40), depth: e.getUint16(74), config: ge(t.subarray(78, t.byteLength)) } }, avcC: function(t) { var e, i, o, n, s = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                    r = { configurationVersion: t[0], avcProfileIndication: t[1], profileCompatibility: t[2], avcLevelIndication: t[3], lengthSizeMinusOne: 3 & t[4], sps: [], pps: [] },
                                    a = 31 & t[5]; for (o = 6, n = 0; n < a; n++) i = s.getUint16(o), o += 2, r.sps.push(new Uint8Array(t.subarray(o, o + i))), o += i; for (e = t[o], o++, n = 0; n < e; n++) i = s.getUint16(o), o += 2, r.pps.push(new Uint8Array(t.subarray(o, o + i))), o += i; return r }, btrt: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength); return { bufferSizeDB: e.getUint32(0), maxBitrate: e.getUint32(4), avgBitrate: e.getUint32(8) } }, esds: function(t) { return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), esId: t[6] << 8 | t[7], streamPriority: 31 & t[8], decoderConfig: { objectProfileIndication: t[11], streamType: t[12] >>> 2 & 63, bufferSize: t[13] << 16 | t[14] << 8 | t[15], maxBitrate: t[16] << 24 | t[17] << 16 | t[18] << 8 | t[19], avgBitrate: t[20] << 24 | t[21] << 16 | t[22] << 8 | t[23], decoderConfigDescriptor: { tag: t[24], length: t[25], audioObjectType: t[26] >>> 3 & 31, samplingFrequencyIndex: (7 & t[26]) << 1 | t[27] >>> 7 & 1, channelConfiguration: t[27] >>> 3 & 15 } } } }, ftyp: function(t) { for (var e = new DataView(t.buffer, t.byteOffset, t.byteLength), i = { majorBrand: xe(t.subarray(0, 4)), minorVersion: e.getUint32(4), compatibleBrands: [] }, o = 8; o < t.byteLength;) i.compatibleBrands.push(xe(t.subarray(o, o + 4))), o += 4; return i }, dinf: function(t) { return { boxes: ge(t) } }, dref: function(t) { return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), dataReferences: ge(t.subarray(8)) } }, hdlr: function(t) { var e = { version: new DataView(t.buffer, t.byteOffset, t.byteLength).getUint8(0), flags: new Uint8Array(t.subarray(1, 4)), handlerType: xe(t.subarray(8, 12)), name: "" },
                                    i = 8; for (i = 24; i < t.byteLength; i++) { if (0 === t[i]) { i++; break } e.name += String.fromCharCode(t[i]) } return e.name = decodeURIComponent(escape(e.name)), e }, mdat: function(t) { return { byteLength: t.byteLength, nals: function(t) { var e, i, o = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                            n = []; for (e = 0; e + 4 < t.length; e += i)
                                            if (i = o.getUint32(e), e += 4, i <= 0) n.push("<span style='color:red;'>MALFORMED DATA</span>");
                                            else switch (31 & t[e]) {
                                                case 1:
                                                    n.push("slice_layer_without_partitioning_rbsp"); break;
                                                case 5:
                                                    n.push("slice_layer_without_partitioning_rbsp_idr"); break;
                                                case 6:
                                                    n.push("sei_rbsp"); break;
                                                case 7:
                                                    n.push("seq_parameter_set_rbsp"); break;
                                                case 8:
                                                    n.push("pic_parameter_set_rbsp"); break;
                                                case 9:
                                                    n.push("access_unit_delimiter_rbsp"); break;
                                                default:
                                                    n.push("UNKNOWN NAL - " + t[e] & 31) }
                                        return n }(t) } }, mdhd: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                    o = 4,
                                    n = { version: i.getUint8(0), flags: new Uint8Array(t.subarray(1, 4)), language: "" }; return 1 === n.version ? (o += 4, n.creationTime = Se(i.getUint32(o)), o += 8, n.modificationTime = Se(i.getUint32(o)), o += 4, n.timescale = i.getUint32(o), o += 8) : (n.creationTime = Se(i.getUint32(o)), o += 4, n.modificationTime = Se(i.getUint32(o)), o += 4, n.timescale = i.getUint32(o), o += 4), n.duration = i.getUint32(o), o += 4, e = i.getUint16(o), n.language += String.fromCharCode(96 + (e >> 10)), n.language += String.fromCharCode(96 + ((992 & e) >> 5)), n.language += String.fromCharCode(96 + (31 & e)), n }, mdia: function(t) { return { boxes: ge(t) } }, mfhd: function(t) { return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), sequenceNumber: t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7] } }, minf: function(t) { return { boxes: ge(t) } }, mp4a: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                    i = { dataReferenceIndex: e.getUint16(6), channelcount: e.getUint16(16), samplesize: e.getUint16(18), samplerate: e.getUint16(24) + e.getUint16(26) / 65536 }; return 28 < t.byteLength && (i.streamDescriptor = ge(t.subarray(28))[0]), i }, moof: function(t) { return { boxes: ge(t) } }, moov: function(t) { return { boxes: ge(t) } }, mvex: function(t) { return { boxes: ge(t) } }, mvhd: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                    i = 4,
                                    o = { version: e.getUint8(0), flags: new Uint8Array(t.subarray(1, 4)) }; return 1 === o.version ? (i += 4, o.creationTime = Se(e.getUint32(i)), i += 8, o.modificationTime = Se(e.getUint32(i)), i += 4, o.timescale = e.getUint32(i), i += 8) : (o.creationTime = Se(e.getUint32(i)), i += 4, o.modificationTime = Se(e.getUint32(i)), i += 4, o.timescale = e.getUint32(i), i += 4), o.duration = e.getUint32(i), i += 4, o.rate = e.getUint16(i) + e.getUint16(i + 2) / 16, i += 4, o.volume = e.getUint8(i) + e.getUint8(i + 1) / 8, i += 2, i += 2, i += 8, o.matrix = new Uint32Array(t.subarray(i, i + 36)), i += 36, i += 24, o.nextTrackId = e.getUint32(i), o }, pdin: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength); return { version: e.getUint8(0), flags: new Uint8Array(t.subarray(1, 4)), rate: e.getUint32(4), initialDelay: e.getUint32(8) } }, sdtp: function(t) { var e, i = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), samples: [] }; for (e = 4; e < t.byteLength; e++) i.samples.push({ dependsOn: (48 & t[e]) >> 4, isDependedOn: (12 & t[e]) >> 2, hasRedundancy: 3 & t[e] }); return i }, sidx: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                    o = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), references: [], referenceId: i.getUint32(4), timescale: i.getUint32(8), earliestPresentationTime: i.getUint32(12), firstOffset: i.getUint32(16) },
                                    n = i.getUint16(22); for (e = 24; n; e += 12, n--) o.references.push({ referenceType: (128 & t[e]) >>> 7, referencedSize: 2147483647 & i.getUint32(e), subsegmentDuration: i.getUint32(e + 4), startsWithSap: !!(128 & t[e + 8]), sapType: (112 & t[e + 8]) >>> 4, sapDeltaTime: 268435455 & i.getUint32(e + 8) }); return o }, smhd: function(t) { return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), balance: t[4] + t[5] / 256 } }, stbl: function(t) { return { boxes: ge(t) } }, stco: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                    o = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), chunkOffsets: [] },
                                    n = i.getUint32(4); for (e = 8; n; e += 4, n--) o.chunkOffsets.push(i.getUint32(e)); return o }, stsc: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                    o = i.getUint32(4),
                                    n = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), sampleToChunks: [] }; for (e = 8; o; e += 12, o--) n.sampleToChunks.push({ firstChunk: i.getUint32(e), samplesPerChunk: i.getUint32(e + 4), sampleDescriptionIndex: i.getUint32(e + 8) }); return n }, stsd: function(t) { return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), sampleDescriptions: ge(t.subarray(8)) } }, stsz: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                    o = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), sampleSize: i.getUint32(4), entries: [] }; for (e = 12; e < t.byteLength; e += 4) o.entries.push(i.getUint32(e)); return o }, stts: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                    o = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), timeToSamples: [] },
                                    n = i.getUint32(4); for (e = 8; n; e += 8, n--) o.timeToSamples.push({ sampleCount: i.getUint32(e), sampleDelta: i.getUint32(e + 4) }); return o }, styp: function(t) { return we.ftyp(t) }, tfdt: function(t) { var e = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), baseMediaDecodeTime: t[4] << 24 | t[5] << 16 | t[6] << 8 | t[7] }; return 1 === e.version && (e.baseMediaDecodeTime *= Math.pow(2, 32), e.baseMediaDecodeTime += t[8] << 24 | t[9] << 16 | t[10] << 8 | t[11]), e }, tfhd: function(t) { var e, i = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                    o = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), trackId: i.getUint32(4) },
                                    n = 1 & o.flags[2],
                                    s = 2 & o.flags[2],
                                    r = 8 & o.flags[2],
                                    a = 16 & o.flags[2],
                                    h = 32 & o.flags[2],
                                    l = 65536 & o.flags[0],
                                    c = 131072 & o.flags[0]; return e = 8, n && (e += 4, o.baseDataOffset = i.getUint32(12), e += 4), s && (o.sampleDescriptionIndex = i.getUint32(e), e += 4), r && (o.defaultSampleDuration = i.getUint32(e), e += 4), a && (o.defaultSampleSize = i.getUint32(e), e += 4), h && (o.defaultSampleFlags = i.getUint32(e)), l && (o.durationIsEmpty = !0), !n && c && (o.baseDataOffsetIsMoof = !0), o }, tkhd: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                    i = 4,
                                    o = { version: e.getUint8(0), flags: new Uint8Array(t.subarray(1, 4)) }; return 1 === o.version ? (i += 4, o.creationTime = Se(e.getUint32(i)), i += 8, o.modificationTime = Se(e.getUint32(i)), i += 4, o.trackId = e.getUint32(i), i += 4, i += 8) : (o.creationTime = Se(e.getUint32(i)), i += 4, o.modificationTime = Se(e.getUint32(i)), i += 4, o.trackId = e.getUint32(i), i += 4, i += 4), o.duration = e.getUint32(i), i += 4, i += 8, o.layer = e.getUint16(i), i += 2, o.alternateGroup = e.getUint16(i), i += 2, o.volume = e.getUint8(i) + e.getUint8(i + 1) / 8, i += 2, i += 2, o.matrix = new Uint32Array(t.subarray(i, i + 36)), i += 36, o.width = e.getUint16(i) + e.getUint16(i + 2) / 16, i += 4, o.height = e.getUint16(i) + e.getUint16(i + 2) / 16, o }, traf: function(t) { return { boxes: ge(t) } }, trak: function(t) { return { boxes: ge(t) } }, trex: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength); return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), trackId: e.getUint32(4), defaultSampleDescriptionIndex: e.getUint32(8), defaultSampleDuration: e.getUint32(12), defaultSampleSize: e.getUint32(16), sampleDependsOn: 3 & t[20], sampleIsDependedOn: (192 & t[21]) >> 6, sampleHasRedundancy: (48 & t[21]) >> 4, samplePaddingValue: (14 & t[21]) >> 1, sampleIsDifferenceSample: !!(1 & t[21]), sampleDegradationPriority: e.getUint16(22) } }, trun: function(t) { var e, i = { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), samples: [] },
                                    o = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                    n = 1 & i.flags[2],
                                    s = 4 & i.flags[2],
                                    r = 1 & i.flags[1],
                                    a = 2 & i.flags[1],
                                    h = 4 & i.flags[1],
                                    l = 8 & i.flags[1],
                                    c = o.getUint32(4),
                                    d = 8; for (n && (i.dataOffset = o.getInt32(d), d += 4), s && c && (e = { flags: Ce(t.subarray(d, d + 4)) }, d += 4, r && (e.duration = o.getUint32(d), d += 4), a && (e.size = o.getUint32(d), d += 4), l && (e.compositionTimeOffset = o.getUint32(d), d += 4), i.samples.push(e), c--); c--;) e = {}, r && (e.duration = o.getUint32(d), d += 4), a && (e.size = o.getUint32(d), d += 4), h && (e.flags = Ce(t.subarray(d, d + 4)), d += 4), l && (e.compositionTimeOffset = o.getUint32(d), d += 4), i.samples.push(e); return i }, "url ": function(t) { return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)) } }, vmhd: function(t) { var e = new DataView(t.buffer, t.byteOffset, t.byteLength); return { version: t[0], flags: new Uint8Array(t.subarray(1, 4)), graphicsmode: e.getUint16(4), opcolor: new Uint16Array([e.getUint16(6), e.getUint16(8), e.getUint16(10)]) } } },
                        Ae = { inspect: ge = function(t) { for (var e, i, o, n, s, r = 0, a = [], h = new ArrayBuffer(t.length), l = new Uint8Array(h), c = 0; c < t.length; ++c) l[c] = t[c]; for (e = new DataView(h); r < t.byteLength;) i = e.getUint32(r), o = xe(t.subarray(r + 4, r + 8)), n = 1 < i ? r + i : t.byteLength, (s = (we[o] || function(t) { return { data: t } })(t.subarray(r + 8, n))).size = i, s.type = o, a.push(s), r = n; return a }, textify: _e = function(t, e) { var i; return e = e || 0, i = new Array(2 * e + 1).join(" "), t.map(function(t, o) { return i + t.type + "\n" + Object.keys(t).filter(function(t) { return "type" !== t && "boxes" !== t }).map(function(e) { var o = i + "  " + e + ": ",
                                            n = t[e]; if (n instanceof Uint8Array || n instanceof Uint32Array) { var s = Array.prototype.slice.call(new Uint8Array(n.buffer, n.byteOffset, n.byteLength)).map(function(t) { return " " + ("00" + t.toString(16)).slice(-2) }).join("").match(/.{1,24}/g); return s ? 1 === s.length ? o + "<" + s.join("").slice(1) + ">" : o + "<\n" + s.map(function(t) { return i + "  " + t }).join("\n") + "\n" + i + "  >" : o + "<>" } return o + JSON.stringify(n, null, 2).split("\n").map(function(t, e) { return 0 === e ? t : i + "  " + t }).join("\n") }).join("\n") + (t.boxes ? "\n" + _e(t.boxes, e + 1) : "") }).join("\n") }, parseTfdt: we.tfdt, parseHdlr: we.hdlr, parseTfhd: we.tfhd, parseTrun: we.trun },
                        Te = function(t) { for (var e, i, o = t.byteLength, n = [], s = 1; s < o - 2;) 0 === t[s] && 0 === t[s + 1] && 3 === t[s + 2] ? (n.push(s + 2), s += 2) : s++; if (0 === n.length) return t;
                            e = o - n.length, i = new Uint8Array(e); var r = 0; for (s = 0; s < e; r++, s++) r === n[0] && (r++, n.shift()), i[s] = t[r]; return i },
                        Pe = Dt.CaptionStream,
                        ke = function(t, e) { for (var i = t, o = 0; o < e.length; o++) { var n = e[o]; if (i < n.size) return n;
                                i -= n.size } return null },
                        Me = function(t, e) { var i = Y.findBox(t, ["moof", "traf"]),
                                o = {},
                                n = []; return Y.findBox(t, ["mdat"]).forEach(function(t, e) { var o = i[e];
                                n.push({ mdat: t, traf: o }) }), n.forEach(function(t) { var i, n, s, r, a, h, l, c, d = t.mdat,
                                    u = t.traf,
                                    p = Y.findBox(u, ["tfhd"]),
                                    m = Ae.parseTfhd(p[0]),
                                    f = m.trackId,
                                    y = Y.findBox(u, ["tfdt"]),
                                    b = 0 < y.length ? Ae.parseTfdt(y[0]).baseMediaDecodeTime : 0,
                                    g = Y.findBox(u, ["trun"]);
                                e === f && 0 < g.length && (n = g, r = b, a = (s = m).defaultSampleDuration || 0, h = s.defaultSampleSize || 0, l = s.trackId, c = [], n.forEach(function(t) { var e = Ae.parseTrun(t).samples;
                                    e.forEach(function(t) { void 0 === t.duration && (t.duration = a), void 0 === t.size && (t.size = h), t.trackId = l, t.dts = r, void 0 === t.compositionTimeOffset && (t.compositionTimeOffset = 0), t.pts = r + t.compositionTimeOffset, r += t.duration }), c = c.concat(e) }), i = function(t, e, i) { var o, n, s, r, a = new DataView(t.buffer, t.byteOffset, t.byteLength),
                                        h = []; for (n = 0; n + 4 < t.length; n += s)
                                        if (s = a.getUint32(n), n += 4, !(s <= 0)) switch (31 & t[n]) {
                                            case 6:
                                                var l = t.subarray(n + 1, n + 1 + s),
                                                    c = ke(n, e);
                                                o = { nalUnitType: "sei_rbsp", size: s, data: l, escapedRBSP: Te(l), trackId: i }, c ? (o.pts = c.pts, o.dts = c.dts, r = c) : (o.pts = r.pts, o.dts = r.dts), h.push(o) }
                                    return h }(d, c, f), o[f] || (o[f] = []), o[f] = o[f].concat(i)) }), o },
                        Ee = { generator: J, probe: Y, Transmuxer: ve.Transmuxer, AudioSegmentStream: ve.AudioSegmentStream, VideoSegmentStream: ve.VideoSegmentStream, CaptionParser: function() { var t, e, i, o, n, s = !1;
                                this.isInitialized = function() { return s }, this.init = function() { t = new Pe, s = !0, t.on("data", function(t) { t.startTime = t.startPts / o, t.endTime = t.endPts / o, n.captions.push(t), n.captionStreams[t.stream] = !0 }) }, this.isNewInit = function(t, e) { return !(t && 0 === t.length || e && "object" == typeof e && 0 === Object.keys(e).length || i === t[0] && o === e[i]) }, this.parse = function(t, s, r) { var a, h, l, c; if (!this.isInitialized()) return null; if (!s || !r) return null; if (this.isNewInit(s, r)) i = s[0], o = r[i];
                                    else if (!i || !o) return e.push(t), null; for (; 0 < e.length;) { var d = e.shift();
                                        this.parse(d, s, r) } return h = t, c = o, null !== (a = (l = i) ? { seiNals: Me(h, l)[l], timescale: c } : null) && a.seiNals ? (this.pushNals(a.seiNals), this.flushStream(), n) : null }, this.pushNals = function(e) { if (!this.isInitialized() || !e || 0 === e.length) return null;
                                    e.forEach(function(e) { t.push(e) }) }, this.flushStream = function() { if (!this.isInitialized()) return null;
                                    t.flush() }, this.clearParsedCaptions = function() { n.captions = [], n.captionStreams = {} }, this.resetCaptionStream = function() { if (!this.isInitialized()) return null;
                                    t.reset() }, this.clearAllCaptions = function() { this.clearParsedCaptions(), this.resetCaptionStream() }, this.reset = function() { e = [], o = i = null, n ? this.clearParsedCaptions() : n = { captions: [], captionStreams: {} }, this.resetCaptionStream() }, this.reset() } },
                        Be = function() {
                            function t(t, e) { for (var i = 0; i < e.length; i++) { var o = e[i];
                                    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o) } } return function(e, i, o) { return i && t(e.prototype, i), o && t(e, o), e } }(),
                        Ie = function() {
                            function t(e, i) {! function(e, i) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") }(this), this.options = i || {}, this.self = e, this.init() } return Be(t, [{ key: "init", value: function() { var t, e;
                                    this.transmuxer && this.transmuxer.dispose(), this.transmuxer = new Ee.Transmuxer(this.options), t = this.self, (e = this.transmuxer).on("data", function(e) { var i = e.initSegment;
                                        e.initSegment = { data: i.buffer, byteOffset: i.byteOffset, byteLength: i.byteLength }; var o = e.data;
                                        e.data = o.buffer, t.postMessage({ action: "data", segment: e, byteOffset: o.byteOffset, byteLength: o.byteLength }, [e.data]) }), e.captionStream && e.captionStream.on("data", function(e) { t.postMessage({ action: "caption", data: e }) }), e.on("done", function(e) { t.postMessage({ action: "done" }) }), e.on("gopInfo", function(e) { t.postMessage({ action: "gopInfo", gopInfo: e }) }) } }, { key: "push", value: function(t) { var e = new Uint8Array(t.data, t.byteOffset, t.byteLength);
                                    this.transmuxer.push(e) } }, { key: "reset", value: function() { this.init() } }, { key: "setTimestampOffset", value: function(t) { var e = t.timestampOffset || 0;
                                    this.transmuxer.setBaseMediaDecodeTime(Math.round(9e4 * e)) } }, { key: "setAudioAppendStart", value: function(t) { this.transmuxer.setAudioAppendStart(Math.ceil(9e4 * t.appendStart)) } }, { key: "flush", value: function(t) { this.transmuxer.flush() } }, { key: "resetCaptions", value: function() { this.transmuxer.resetCaptions() } }, { key: "alignGopsWith", value: function(t) { this.transmuxer.alignGopsWith(t.gopsToAlignWith.slice()) } }]), t }();
                    new function(t) { t.onmessage = function(e) { "init" === e.data.action && e.data.options ? this.messageHandlers = new Ie(t, e.data.options) : (this.messageHandlers || (this.messageHandlers = new Ie(t)), e.data && e.data.action && "init" !== e.data.action && this.messageHandlers[e.data.action] && this.messageHandlers[e.data.action](e.data)) } }(i) }() }),
            uc = { videoCodec: "avc1", videoObjectTypeIndicator: ".4d400d", audioProfile: "2" },
            pc = function(t) { return t.map(function(t) { return t.replace(/avc1\.(\d+)\.(\d+)/i, function(t, e, i) { return "avc1." + ("00" + Number(e).toString(16)).slice(-2) + "00" + ("00" + Number(i).toString(16)).slice(-2) }) }) },
            mc = function() { var t, e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : "",
                    i = { codecCount: 0 }; return i.codecCount = e.split(",").length, i.codecCount = i.codecCount || 2, (t = /(^|\s|,)+(avc[13])([^ ,]*)/i.exec(e)) && (i.videoCodec = t[2], i.videoObjectTypeIndicator = t[3]), i.audioProfile = /(^|\s|,)+mp4a.[0-9A-Fa-f]+\.([0-9A-Fa-f]+)/i.exec(e), i.audioProfile = i.audioProfile && i.audioProfile[2], i },
            fc = function(t, e, i) { return t + "/" + e + '; codecs="' + i.filter(function(t) { return !!t }).join(", ") + '"' },
            yc = function(t, e) { var i, o, n = (i = e).segments && i.segments.length && i.segments[0].map ? "mp4" : "mp2t",
                    s = (o = e.attributes || {}).CODECS ? mc(o.CODECS) : uc,
                    r = e.attributes || {},
                    a = !0,
                    h = !1; if (!e) return []; if (t.mediaGroups.AUDIO && r.AUDIO) { var l = t.mediaGroups.AUDIO[r.AUDIO]; if (l)
                        for (var c in a = !(h = !0), l)
                            if (!l[c].uri && !l[c].playlists) { a = !0; break } } h && !s.audioProfile && (a || (s.audioProfile = function(t, e) { if (!t.mediaGroups.AUDIO || !e) return null; var i = t.mediaGroups.AUDIO[e]; if (!i) return null; for (var o in i) { var n = i[o]; if (n.default && n.playlists) return mc(n.playlists[0].attributes.CODECS).audioProfile } return null }(t, r.AUDIO)), s.audioProfile || (Nt.log.warn("Multiple audio tracks present but no audio codec string is specified. Attempting to use the default audio codec (mp4a.40.2)"), s.audioProfile = uc.audioProfile)); var d = {};
                s.videoCodec && (d.video = "" + s.videoCodec + s.videoObjectTypeIndicator), s.audioProfile && (d.audio = "mp4a.40." + s.audioProfile); var u = fc("audio", n, [d.audio]),
                    p = fc("video", n, [d.video]),
                    m = fc("video", n, [d.video, d.audio]); return h ? !a && d.video ? [p, u] : a || d.video ? [m, u] : [u, u] : d.video ? [m] : [u] },
            bc = function(t) { return /mp4a\.\d+.\d+/i.test(t) },
            gc = function(t) { return /avc1\.[\da-f]+/i.test(t) },
            _c = function(t) {
                function e(t, i) { nl(this, e); var o = al(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this, Nt.EventTarget));
                    o.timestampOffset_ = 0, o.pendingBuffers_ = [], o.bufferUpdating_ = !1, o.mediaSource_ = t, o.codecs_ = i, o.audioCodec_ = null, o.videoCodec_ = null, o.audioDisabled_ = !1, o.appendAudioInitSegment_ = !0, o.gopBuffer_ = [], o.timeMapping_ = 0, o.safeAppend_ = 11 <= Nt.browser.IE_VERSION; var n = { remux: !1, alignGopsAtEnd: o.safeAppend_ }; return o.codecs_.forEach(function(t) { bc(t) ? o.audioCodec_ = t : gc(t) && (o.videoCodec_ = t) }), o.transmuxer_ = new dc, o.transmuxer_.postMessage({ action: "init", options: n }), o.transmuxer_.onmessage = function(t) { return "data" === t.data.action ? o.data_(t) : "done" === t.data.action ? o.done_(t) : "gopInfo" === t.data.action ? o.appendGopInfo_(t) : void 0 }, Object.defineProperty(o, "timestampOffset", { get: function() { return this.timestampOffset_ }, set: function(t) { "number" == typeof t && 0 <= t && (this.timestampOffset_ = t, this.appendAudioInitSegment_ = !0, this.gopBuffer_.length = 0, this.timeMapping_ = 0, this.transmuxer_.postMessage({ action: "setTimestampOffset", timestampOffset: t })) } }), Object.defineProperty(o, "appendWindowStart", { get: function() { return (this.videoBuffer_ || this.audioBuffer_).appendWindowStart }, set: function(t) { this.videoBuffer_ && (this.videoBuffer_.appendWindowStart = t), this.audioBuffer_ && (this.audioBuffer_.appendWindowStart = t) } }), Object.defineProperty(o, "updating", { get: function() { return !!(this.bufferUpdating_ || !this.audioDisabled_ && this.audioBuffer_ && this.audioBuffer_.updating || this.videoBuffer_ && this.videoBuffer_.updating) } }), Object.defineProperty(o, "buffered", { get: function() { return function(t, e, i) { var o = null,
                                    n = null,
                                    s = 0,
                                    r = [],
                                    a = []; if (!t && !e) return Nt.createTimeRange(); if (!t) return e.buffered; if (!e) return t.buffered; if (i) return t.buffered; if (0 === t.buffered.length && 0 === e.buffered.length) return Nt.createTimeRange(); for (var h = t.buffered, l = e.buffered, c = h.length; c--;) r.push({ time: h.start(c), type: "start" }), r.push({ time: h.end(c), type: "end" }); for (c = l.length; c--;) r.push({ time: l.start(c), type: "start" }), r.push({ time: l.end(c), type: "end" }); for (r.sort(function(t, e) { return t.time - e.time }), c = 0; c < r.length; c++) "start" === r[c].type ? 2 == ++s && (o = r[c].time) : "end" === r[c].type && 1 == --s && (n = r[c].time), null !== o && null !== n && (a.push([o, n]), n = o = null); return Nt.createTimeRanges(a) }(this.videoBuffer_, this.audioBuffer_, this.audioDisabled_) } }), o } return rl(e, Nt.EventTarget), sl(e, [{ key: "data_", value: function(t) { var e = t.data.segment;
                        e.data = new Uint8Array(e.data, t.data.byteOffset, t.data.byteLength), e.initSegment = new Uint8Array(e.initSegment.data, e.initSegment.byteOffset, e.initSegment.byteLength),
                            function(t, e, i) { var o = e.player_; if (i.captions && i.captions.length)
                                    for (var n in t.inbandTextTracks_ || (t.inbandTextTracks_ = {}), i.captionStreams)
                                        if (!t.inbandTextTracks_[n]) { o.tech_.trigger({ type: "usage", name: "hls-608" }); var s = o.textTracks().getTrackById(n);
                                            t.inbandTextTracks_[n] = s || o.addRemoteTextTrack({ kind: "captions", id: n, label: n }, !1).track } i.metadata && i.metadata.length && !t.metadataTrack_ && (t.metadataTrack_ = o.addRemoteTextTrack({ kind: "metadata", label: "Timed Metadata" }, !1).track, t.metadataTrack_.inBandMetadataTrackDispatchType = i.metadata.dispatchType) }(this, this.mediaSource_, e), this.pendingBuffers_.push(e) } }, { key: "done_", value: function(t) { "closed" !== this.mediaSource_.readyState ? this.processPendingSegments_() : this.pendingBuffers_.length = 0 } }, { key: "createRealSourceBuffers_", value: function() { var t = this,
                            e = ["audio", "video"];
                        e.forEach(function(i) { if (t[i + "Codec_"] && !t[i + "Buffer_"]) { var o = null; if (t.mediaSource_[i + "Buffer_"])(o = t.mediaSource_[i + "Buffer_"]).updating = !1;
                                else { var n = i + '/mp4;codecs="' + t[i + "Codec_"] + '"';
                                    o = function(t, e) { var i = t.addSourceBuffer(e),
                                            o = Object.create(null);
                                        o.updating = !1, o.realBuffer_ = i; for (var n in i) ! function(t) { "function" == typeof i[t] ? o[t] = function() { return i[t].apply(i, arguments) } : void 0 === o[t] && Object.defineProperty(o, t, { get: function() { return i[t] }, set: function(e) { return i[t] = e } }) }(n); return o }(t.mediaSource_.nativeMediaSource_, n), t.mediaSource_[i + "Buffer_"] = o } t[i + "Buffer_"] = o, ["update", "updatestart", "updateend"].forEach(function(n) { o.addEventListener(n, function() { if ("audio" !== i || !t.audioDisabled_) return "updateend" === n && (t[i + "Buffer_"].updating = !1), e.every(function(e) { return !("audio" !== e || !t.audioDisabled_) || i === e || !t[e + "Buffer_"] || !t[e + "Buffer_"].updating }) ? t.trigger(n) : void 0 }) }) } }) } }, { key: "appendBuffer", value: function(t) { if (this.bufferUpdating_ = !0, this.audioBuffer_ && this.audioBuffer_.buffered.length) { var e = this.audioBuffer_.buffered;
                            this.transmuxer_.postMessage({ action: "setAudioAppendStart", appendStart: e.end(e.length - 1) }) } this.videoBuffer_ && this.transmuxer_.postMessage({ action: "alignGopsWith", gopsToAlignWith: function(t, e, i) { if (void 0 === e || null === e || !t.length) return []; var o = Math.ceil(9e4 * (e - i + 3)),
                                    n = void 0; for (n = 0; n < t.length && !(t[n].pts > o); n++); return t.slice(n) }(this.gopBuffer_, this.mediaSource_.player_ ? this.mediaSource_.player_.currentTime() : null, this.timeMapping_) }), this.transmuxer_.postMessage({ action: "push", data: t.buffer, byteOffset: t.byteOffset, byteLength: t.byteLength }, [t.buffer]), this.transmuxer_.postMessage({ action: "flush" }) } }, { key: "appendGopInfo_", value: function(t) { this.gopBuffer_ = function(t, e, i) { if (!e.length) return t; if (i) return e.slice(); for (var o = e[0].pts, n = 0; n < t.length && !(t[n].pts >= o); n++); return t.slice(0, n).concat(e) }(this.gopBuffer_, t.data.gopInfo, this.safeAppend_) } }, { key: "remove", value: function(t, e) { if (this.videoBuffer_ && (this.videoBuffer_.updating = !0, this.videoBuffer_.remove(t, e), this.gopBuffer_ = function(t, e, i, o) { for (var n = Math.ceil(9e4 * (e - o)), s = Math.ceil(9e4 * (i - o)), r = t.slice(), a = t.length; a-- && !(t[a].pts <= s);); if (-1 === a) return r; for (var h = a + 1; h-- && !(t[h].pts <= n);); return h = Math.max(h, 0), r.splice(h, a - h + 1), r }(this.gopBuffer_, t, e, this.timeMapping_)), !this.audioDisabled_ && this.audioBuffer_ && (this.audioBuffer_.updating = !0, this.audioBuffer_.remove(t, e)), $l(t, e, this.metadataTrack_), this.inbandTextTracks_)
                            for (var i in this.inbandTextTracks_) $l(t, e, this.inbandTextTracks_[i]) } }, { key: "processPendingSegments_", value: function() { var t = { video: { segments: [], bytes: 0 }, audio: { segments: [], bytes: 0 }, captions: [], metadata: [] };
                        t = this.pendingBuffers_.reduce(function(t, e) { var i = e.type,
                                o = e.data,
                                n = e.initSegment; return t[i].segments.push(o), t[i].bytes += o.byteLength, t[i].initSegment = n, e.captions && (t.captions = t.captions.concat(e.captions)), e.info && (t[i].info = e.info), e.metadata && (t.metadata = t.metadata.concat(e.metadata)), t }, t), this.videoBuffer_ || this.audioBuffer_ || (0 === t.video.bytes && (this.videoCodec_ = null), 0 === t.audio.bytes && (this.audioCodec_ = null), this.createRealSourceBuffers_()), t.audio.info && this.mediaSource_.trigger({ type: "audioinfo", info: t.audio.info }), t.video.info && this.mediaSource_.trigger({ type: "videoinfo", info: t.video.info }), this.appendAudioInitSegment_ && (!this.audioDisabled_ && this.audioBuffer_ && (t.audio.segments.unshift(t.audio.initSegment), t.audio.bytes += t.audio.initSegment.byteLength), this.appendAudioInitSegment_ = !1); var e = !1;
                        this.videoBuffer_ && t.video.bytes ? (t.video.segments.unshift(t.video.initSegment), t.video.bytes += t.video.initSegment.byteLength, this.concatAndAppendSegments_(t.video, this.videoBuffer_), ec(this, t.captions, t.metadata)) : !this.videoBuffer_ || !this.audioDisabled_ && this.audioBuffer_ || (e = !0), !this.audioDisabled_ && this.audioBuffer_ && this.concatAndAppendSegments_(t.audio, this.audioBuffer_), this.pendingBuffers_.length = 0, e && this.trigger("updateend"), this.bufferUpdating_ = !1 } }, { key: "concatAndAppendSegments_", value: function(t, e) { var i = 0,
                            o = void 0; if (t.bytes) { o = new Uint8Array(t.bytes), t.segments.forEach(function(t) { o.set(t, i), i += t.byteLength }); try { e.updating = !0, e.appendBuffer(o) } catch (t) { this.mediaSource_.player_ && this.mediaSource_.player_.error({ code: -3, type: "APPEND_BUFFER_ERR", message: t.message, originalError: t }) } } } }, { key: "abort", value: function() { this.videoBuffer_ && this.videoBuffer_.abort(), !this.audioDisabled_ && this.audioBuffer_ && this.audioBuffer_.abort(), this.transmuxer_ && this.transmuxer_.postMessage({ action: "reset" }), this.pendingBuffers_.length = 0, this.bufferUpdating_ = !1 } }]), e }(),
            vc = function(i) {
                function o() { nl(this, o); var i = al(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this)),
                        n = void 0; for (n in i.nativeMediaSource_ = new e.MediaSource, i.nativeMediaSource_) n in o.prototype || "function" != typeof i.nativeMediaSource_[n] || (i[n] = i.nativeMediaSource_[n].bind(i.nativeMediaSource_)); return i.duration_ = NaN, Object.defineProperty(i, "duration", { get: function() { return this.duration_ === 1 / 0 ? this.duration_ : this.nativeMediaSource_.duration }, set: function(t) {
                            (this.duration_ = t) === 1 / 0 || (this.nativeMediaSource_.duration = t) } }), Object.defineProperty(i, "seekable", { get: function() { return this.duration_ === 1 / 0 ? Nt.createTimeRanges([
                                [0, this.nativeMediaSource_.duration]
                            ]) : this.nativeMediaSource_.seekable } }), Object.defineProperty(i, "readyState", { get: function() { return this.nativeMediaSource_.readyState } }), Object.defineProperty(i, "activeSourceBuffers", { get: function() { return this.activeSourceBuffers_ } }), i.sourceBuffers = [], i.activeSourceBuffers_ = [], i.updateActiveSourceBuffers_ = function() { if (i.activeSourceBuffers_.length = 0, 1 === i.sourceBuffers.length) { var t = i.sourceBuffers[0]; return t.appendAudioInitSegment_ = !0, t.audioDisabled_ = !t.audioCodec_, void i.activeSourceBuffers_.push(t) } for (var e = !1, o = !0, n = 0; n < i.player_.audioTracks().length; n++) { var s = i.player_.audioTracks()[n]; if (s.enabled && "main" !== s.kind) { o = !(e = !0); break } } i.sourceBuffers.forEach(function(t, n) { if (t.appendAudioInitSegment_ = !0, t.videoCodec_ && t.audioCodec_) t.audioDisabled_ = e;
                            else if (t.videoCodec_ && !t.audioCodec_) t.audioDisabled_ = !0, o = !1;
                            else if (!t.videoCodec_ && t.audioCodec_ && (t.audioDisabled_ = n ? o : !o, t.audioDisabled_)) return;
                            i.activeSourceBuffers_.push(t) }) }, i.onPlayerMediachange_ = function() { i.sourceBuffers.forEach(function(t) { t.appendAudioInitSegment_ = !0 }) }, i.onHlsReset_ = function() { i.sourceBuffers.forEach(function(t) { t.transmuxer_ && t.transmuxer_.postMessage({ action: "resetCaptions" }) }) }, i.onHlsSegmentTimeMapping_ = function(t) { i.sourceBuffers.forEach(function(e) { return e.timeMapping_ = t.mapping }) }, ["sourceopen", "sourceclose", "sourceended"].forEach(function(t) { this.nativeMediaSource_.addEventListener(t, this.trigger.bind(this)) }, i), i.on("sourceopen", function(e) { var o = t.querySelector('[src="' + i.url_ + '"]');
                        o && (i.player_ = Nt(o.parentNode), i.player_ && (i.player_.tech_.on("hls-reset", i.onHlsReset_), i.player_.tech_.on("hls-segment-time-mapping", i.onHlsSegmentTimeMapping_), i.player_.audioTracks && i.player_.audioTracks() && (i.player_.audioTracks().on("change", i.updateActiveSourceBuffers_), i.player_.audioTracks().on("addtrack", i.updateActiveSourceBuffers_), i.player_.audioTracks().on("removetrack", i.updateActiveSourceBuffers_)), i.player_.on("mediachange", i.onPlayerMediachange_))) }), i.on("sourceended", function(t) { for (var e = tc(i.duration), o = 0; o < i.sourceBuffers.length; o++) { var n = i.sourceBuffers[o],
                                s = n.metadataTrack_ && n.metadataTrack_.cues;
                            s && s.length && (s[s.length - 1].endTime = e) } }), i.on("sourceclose", function(t) { this.sourceBuffers.forEach(function(t) { t.transmuxer_ && t.transmuxer_.terminate() }), this.sourceBuffers.length = 0, this.player_ && (this.player_.audioTracks && this.player_.audioTracks() && (this.player_.audioTracks().off("change", this.updateActiveSourceBuffers_), this.player_.audioTracks().off("addtrack", this.updateActiveSourceBuffers_), this.player_.audioTracks().off("removetrack", this.updateActiveSourceBuffers_)), this.player_.el_ && this.player_.off("mediachange", this.onPlayerMediachange_), this.player_.tech_ && this.player_.tech_.el_ && (this.player_.tech_.off("hls-reset", this.onHlsReset_), this.player_.tech_.off("hls-segment-time-mapping", this.onHlsSegmentTimeMapping_))) }), i } return rl(o, Nt.EventTarget), sl(o, [{ key: "addSeekableRange_", value: function(t, e) { var i = void 0; if (this.duration !== 1 / 0) throw (i = new Error("MediaSource.addSeekableRange() can only be invoked when the duration is Infinity")).name = "InvalidStateError", i.code = 11, i;
                        (e > this.nativeMediaSource_.duration || isNaN(this.nativeMediaSource_.duration)) && (this.nativeMediaSource_.duration = e) } }, { key: "addSourceBuffer", value: function(t) { var e, i, o = void 0,
                            n = (e = { type: "", parameters: {} }, i = t.trim().split(";"), e.type = i.shift().trim(), i.forEach(function(t) { var i = t.trim().split("="); if (1 < i.length) { var o = i[0].replace(/"/g, "").trim(),
                                        n = i[1].replace(/"/g, "").trim();
                                    e.parameters[o] = n } }), e); if (/^(video|audio)\/mp2t$/i.test(n.type)) { var s = [];
                            n.parameters && n.parameters.codecs && (s = n.parameters.codecs.split(","), s = (s = pc(s)).filter(function(t) { return bc(t) || gc(t) })), 0 === s.length && (s = ["avc1.4d400d", "mp4a.40.2"]), o = new _c(this, s), 0 !== this.sourceBuffers.length && (this.sourceBuffers[0].createRealSourceBuffers_(), o.createRealSourceBuffers_(), this.sourceBuffers[0].audioDisabled_ = !0) } else o = this.nativeMediaSource_.addSourceBuffer(t); return this.sourceBuffers.push(o), o } }]), o }(),
            xc = 0;
        Nt.mediaSources = {}; var Sc = function(t, e) { var i = Nt.mediaSources[t]; if (!i) throw new Error("Media Source not found (Video.js)");
                i.trigger({ type: "sourceopen", swfId: e }) },
            Cc = function() { return !!e.MediaSource && !!e.MediaSource.isTypeSupported && e.MediaSource.isTypeSupported('video/mp4;codecs="avc1.4d400d,mp4a.40.2"') },
            wc = function() { if (this.MediaSource = { open: Sc, supportsNativeMediaSources: Cc }, Cc()) return new vc; throw new Error("Cannot use create a virtual MediaSource for this video") };
        wc.open = Sc, wc.supportsNativeMediaSources = Cc; var Ac = { createObjectURL: function(t) { var i = void 0; return t instanceof vc ? (i = e.URL.createObjectURL(t.nativeMediaSource_), t.url_ = i) : t instanceof vc ? (i = "blob:vjs-media-source/" + xc, xc++, Nt.mediaSources[i] = t, i) : (i = e.URL.createObjectURL(t), t.url_ = i) } };
        Nt.MediaSource = wc, Nt.URL = Ac; var Tc = Nt.EventTarget,
            Pc = Nt.mergeOptions,
            kc = function(t, e) { for (var i = Pc(t, { duration: e.duration, minimumUpdatePeriod: e.minimumUpdatePeriod }), o = 0; o < e.playlists.length; o++) { var n = pl(i, e.playlists[o]);
                    n && (i = n) } return ul(e, function(t, e, o, n) { if (t.playlists && t.playlists.length) { var s = t.playlists[0].uri,
                            r = pl(i, t.playlists[0]);
                        r && ((i = r).mediaGroups[e][o][n].playlists[0] = i.playlists[s]) } }), i },
            Mc = function(t) {
                function i(t, o, n, s) { nl(this, i); var r = al(this, (i.__proto__ || Object.getPrototypeOf(i)).call(this)); if (r.hls_ = o, r.withCredentials = n, !t) throw new Error("A non-empty playlist URL or playlist is required"); return r.on("minimumUpdatePeriod", function() { r.refreshXml_() }), r.on("mediaupdatetimeout", function() { r.refreshMedia_() }), "string" == typeof t ? (r.srcUrl = t, r.state = "HAVE_NOTHING", al(r)) : (r.masterPlaylistLoader_ = s, r.state = "HAVE_METADATA", r.started = !0, r.media(t), e.setTimeout(function() { r.trigger("loadedmetadata") }, 0), r) } return rl(i, Tc), sl(i, [{ key: "dispose", value: function() { this.stopRequest(), e.clearTimeout(this.mediaUpdateTimeout) } }, { key: "stopRequest", value: function() { if (this.request) { var t = this.request;
                            this.request = null, t.onreadystatechange = null, t.abort() } } }, { key: "media", value: function(t) { if (!t) return this.media_; if ("HAVE_NOTHING" === this.state) throw new Error("Cannot switch media playlist from " + this.state); var e = this.state; if ("string" == typeof t) { if (!this.master.playlists[t]) throw new Error("Unknown playlist URI: " + t);
                            t = this.master.playlists[t] } var i = !this.media_ || t.uri !== this.media_.uri;
                        this.state = "HAVE_METADATA", i && (this.media_ && this.trigger("mediachanging"), this.media_ = t, this.refreshMedia_(), "HAVE_MASTER" !== e && this.trigger("mediachange")) } }, { key: "pause", value: function() { this.stopRequest(), e.clearTimeout(this.mediaUpdateTimeout), "HAVE_NOTHING" === this.state && (this.started = !1) } }, { key: "load", value: function(t) { var i = this;
                        e.clearTimeout(this.mediaUpdateTimeout); var o = this.media(); if (t) { var n = o ? o.targetDuration / 2 * 1e3 : 5e3;
                            this.mediaUpdateTimeout = e.setTimeout(function() { return i.load() }, n) } else this.started ? this.trigger("loadedplaylist") : this.start() } }, { key: "parseMasterXml", value: function() { var t = hr(this.masterXml_, { manifestUri: this.srcUrl, clientOffset: this.clientOffset_ });
                        t.uri = this.srcUrl; for (var e = 0; e < t.playlists.length; e++) { var i = "placeholder-uri-" + e;
                            t.playlists[e].uri = i, t.playlists[i] = t.playlists[e] } return ul(t, function(e, i, o, n) { if (e.playlists && e.playlists.length) { var s = "placeholder-uri-" + i + "-" + o + "-" + n;
                                e.playlists[0].uri = s, t.playlists[s] = e.playlists[0] } }), ml(t), fl(t), t } }, { key: "start", value: function() { var t = this;
                        this.started = !0, this.request = this.hls_.xhr({ uri: this.srcUrl, withCredentials: this.withCredentials }, function(e, i) { if (t.request) { if (t.request = null, e) return t.error = { status: i.status, message: "DASH playlist request error at URL: " + t.srcUrl, responseText: i.responseText, code: 2 }, "HAVE_NOTHING" === t.state && (t.started = !1), t.trigger("error");
                                t.masterXml_ = i.responseText, i.responseHeaders && i.responseHeaders.date ? t.masterLoaded_ = Date.parse(i.responseHeaders.date) : t.masterLoaded_ = Date.now(), t.syncClientServerClock_(t.onClientServerClockSync_.bind(t)) } }) } }, { key: "syncClientServerClock_", value: function(t) { var e = this,
                            i = lr(this.masterXml_); return null === i ? (this.clientOffset_ = this.masterLoaded_ - Date.now(), t()) : "DIRECT" === i.method ? (this.clientOffset_ = i.value - Date.now(), t()) : void(this.request = this.hls_.xhr({ uri: ol(this.srcUrl, i.value), method: i.method, withCredentials: this.withCredentials }, function(o, n) { if (e.request) { if (o) return e.clientOffset_ = e.masterLoaded_ - Date.now(), t(); var s = void 0;
                                s = "HEAD" === i.method ? n.responseHeaders && n.responseHeaders.date ? Date.parse(n.responseHeaders.date) : e.masterLoaded_ : Date.parse(n.responseText), e.clientOffset_ = s - Date.now(), t() } })) } }, { key: "onClientServerClockSync_", value: function() { var t = this;
                        this.master = this.parseMasterXml(), this.state = "HAVE_MASTER", this.trigger("loadedplaylist"), this.media_ || this.media(this.master.playlists[0]), e.setTimeout(function() { t.trigger("loadedmetadata") }, 0), this.master.minimumUpdatePeriod && e.setTimeout(function() { t.trigger("minimumUpdatePeriod") }, this.master.minimumUpdatePeriod) } }, { key: "refreshXml_", value: function() { var t = this;
                        this.request = this.hls_.xhr({ uri: this.srcUrl, withCredentials: this.withCredentials }, function(i, o) { if (t.request) { if (t.request = null, i) return t.error = { status: o.status, message: "DASH playlist request error at URL: " + t.srcUrl, responseText: o.responseText, code: 2 }, "HAVE_NOTHING" === t.state && (t.started = !1), t.trigger("error");
                                t.masterXml_ = o.responseText; var n = t.parseMasterXml();
                                t.master = kc(t.master, n), e.setTimeout(function() { t.trigger("minimumUpdatePeriod") }, t.master.minimumUpdatePeriod) } }) } }, { key: "refreshMedia_", value: function() { var t = this,
                            i = void 0,
                            o = void 0;
                        o = this.masterPlaylistLoader_ ? (i = this.masterPlaylistLoader_.master, this.masterPlaylistLoader_.parseMasterXml()) : (i = this.master, this.parseMasterXml()); var n = kc(i, o);
                        n ? (this.masterPlaylistLoader_ ? this.masterPlaylistLoader_.master = n : this.master = n, this.media_ = n.playlists[this.media_.uri]) : this.trigger("playlistunchanged"), this.media().endList || (this.mediaUpdateTimeout = e.setTimeout(function() { t.trigger("mediaupdatetimeout") }, yl(this.media(), !!n))), this.trigger("loadedplaylist") } }]), i }(),
            Ec = function(t) { return Nt.log.debug ? Nt.log.debug.bind(Nt, "VHS:", t + " >") : function() {} },
            Bc = function() {
                function t(e, i, o, n) { nl(this, t), this.callbacks_ = [], this.pendingCallback_ = null, this.timestampOffset_ = 0, this.mediaSource = e, this.processedAppend_ = !1, this.type_ = o, this.mimeType_ = i, this.logger_ = Ec("SourceUpdater[" + o + "][" + i + "]"), "closed" === e.readyState ? e.addEventListener("sourceopen", this.createSourceBuffer_.bind(this, i, n)) : this.createSourceBuffer_(i, n) } return sl(t, [{ key: "createSourceBuffer_", value: function(t, e) { var i = this;
                        this.sourceBuffer_ = this.mediaSource.addSourceBuffer(t), this.logger_("created SourceBuffer"), e && (e.trigger("sourcebufferadded"), this.mediaSource.sourceBuffers.length < 2) ? e.on("sourcebufferadded", function() { i.start_() }) : this.start_() } }, { key: "start_", value: function() { var t = this;
                        this.started_ = !0, this.onUpdateendCallback_ = function() { var e = t.pendingCallback_;
                            t.pendingCallback_ = null, t.logger_("buffered [" + Zl(t.buffered()) + "]"), e && e(), t.runCallback_() }, this.sourceBuffer_.addEventListener("updateend", this.onUpdateendCallback_), this.runCallback_() } }, { key: "abort", value: function(t) { var e = this;
                        this.processedAppend_ && this.queueCallback_(function() { e.sourceBuffer_.abort() }, t) } }, { key: "appendBuffer", value: function(t, e) { var i = this;
                        this.processedAppend_ = !0, this.queueCallback_(function() { i.sourceBuffer_.appendBuffer(t) }, e) } }, { key: "buffered", value: function() { return this.sourceBuffer_ ? this.sourceBuffer_.buffered : Nt.createTimeRanges() } }, { key: "remove", value: function(t, e) { var i = this,
                            o = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : Xt;
                        this.processedAppend_ && this.queueCallback_(function() { i.logger_("remove [" + t + " => " + e + "]"), i.sourceBuffer_.remove(t, e) }, o) } }, { key: "updating", value: function() { return !this.sourceBuffer_ || this.sourceBuffer_.updating || this.pendingCallback_ } }, { key: "timestampOffset", value: function(t) { var e = this; return void 0 !== t && (this.queueCallback_(function() { e.sourceBuffer_.timestampOffset = t }), this.timestampOffset_ = t), this.timestampOffset_ } }, { key: "queueCallback_", value: function(t, e) { this.callbacks_.push([t.bind(this), e]), this.runCallback_() } }, { key: "runCallback_", value: function() { var t = void 0;!this.updating() && this.callbacks_.length && this.started_ && (t = this.callbacks_.shift(), this.pendingCallback_ = t[1], t[0]()) } }, { key: "dispose", value: function() { this.sourceBuffer_.removeEventListener("updateend", this.onUpdateendCallback_), this.sourceBuffer_ && "open" === this.mediaSource.readyState && this.sourceBuffer_.abort() } }]), t }(),
            Ic = { GOAL_BUFFER_LENGTH: 30, MAX_GOAL_BUFFER_LENGTH: 60, GOAL_BUFFER_LENGTH_RATE: 1, INITIAL_BANDWIDTH: 4194304, BANDWIDTH_VARIANCE: 1.2, BUFFER_LOW_WATER_LINE: 0, MAX_BUFFER_LOW_WATER_LINE: 30, BUFFER_LOW_WATER_LINE_RATE: 1 },
            Dc = function(t) { var e, i, o = {}; return t.byterange && (o.Range = (e = t.byterange, i = e.offset + e.length - 1, "bytes=" + e.offset + "-" + i)), o },
            Lc = function(t) { t.forEach(function(t) { t.abort() }) },
            Oc = function(t, e) { return e.timedout ? { status: e.status, message: "HLS request timed-out at URL: " + e.uri, code: -101, xhr: e } : e.aborted ? { status: e.status, message: "HLS request aborted at URL: " + e.uri, code: -102, xhr: e } : t ? { status: e.status, message: "HLS request errored at URL: " + e.uri, code: 2, xhr: e } : null },
            Rc = function(t, e, i) { var o = 0,
                    n = !1; return function(s, r) { var a, h, l; if (!n) return s ? (n = !0, Lc(t), i(s, r)) : (o += 1) === t.length ? (r.endOfAllRequests = Date.now(), r.encryptedBytes ? (h = r, l = i, (a = e).addEventListener("message", function t(e) { if (e.data.source === h.requestId) { a.removeEventListener("message", t); var i = e.data.decrypted; return h.bytes = new Uint8Array(i.bytes, i.byteOffset, i.byteLength), l(null, h) } }), void a.postMessage(Gl({ source: h.requestId, encrypted: h.encryptedBytes, key: h.key.bytes, iv: h.key.iv }), [h.encryptedBytes.buffer, h.key.bytes.buffer])) : i(null, r)) : void 0 } },
            Fc = function(t, e) { return function(i) { var o, n, s; return t.stats = Nt.mergeOptions(t.stats, (n = (o = i).target, (s = { bandwidth: 1 / 0, bytesReceived: 0, roundTripTime: Date.now() - n.requestTime || 0 }).bytesReceived = o.loaded, s.bandwidth = Math.floor(s.bytesReceived / s.roundTripTime * 8 * 1e3), s)), !t.stats.firstBytesReceivedAt && t.stats.bytesReceived && (t.stats.firstBytesReceivedAt = Date.now()), e(i, t) } },
            Vc = function(t, e, i, o, n, s, r) { var a, h, l, c, d, u = [],
                    p = Rc(u, i, r); if (n.key) { var m = t(Nt.mergeOptions(e, { uri: n.key.resolvedUri, responseType: "arraybuffer" }), (a = n, h = p, function(t, e) { var i = e.response,
                            o = Oc(t, e); if (o) return h(o, a); if (16 !== i.byteLength) return h({ status: e.status, message: "Invalid HLS key at URL: " + e.uri, code: 2, xhr: e }, a); var n = new DataView(i); return a.key.bytes = new Uint32Array([n.getUint32(0), n.getUint32(4), n.getUint32(8), n.getUint32(12)]), h(null, a) }));
                    u.push(m) } if (n.map && !n.map.bytes) { var f = t(Nt.mergeOptions(e, { uri: n.map.resolvedUri, responseType: "arraybuffer", headers: Dc(n.map) }), (l = n, c = o, d = p, function(t, e) { var i = e.response,
                            o = Oc(t, e); return o ? d(o, l) : 0 === i.byteLength ? d({ status: e.status, message: "Empty HLS segment content at URL: " + e.uri, code: 2, xhr: e }, l) : (l.map.bytes = new Uint8Array(e.response), c.isInitialized() || c.init(), l.map.timescales = Zr.timescale(l.map.bytes), l.map.videoTrackIds = Zr.videoTrackIds(l.map.bytes), d(null, l)) }));
                    u.push(f) } var y, b, g, _ = t(Nt.mergeOptions(e, { uri: n.resolvedUri, responseType: "arraybuffer", headers: Dc(n) }), (y = n, b = o, g = p, function(t, e) { var i, o = e.response,
                        n = Oc(t, e),
                        s = void 0; return n ? g(n, y) : 0 === o.byteLength ? g({ status: e.status, message: "Empty HLS segment content at URL: " + e.uri, code: 2, xhr: e }, y) : (y.stats = { bandwidth: (i = e).bandwidth, bytesReceived: i.bytesReceived || 0, roundTripTime: i.roundTripTime || 0 }, y.key ? y.encryptedBytes = new Uint8Array(e.response) : y.bytes = new Uint8Array(e.response), y.map && y.map.bytes && (b.isInitialized() || b.init(), (s = b.parse(y.bytes, y.map.videoTrackIds, y.map.timescales)) && s.captions && (y.captionStreams = s.captionStreams, y.fmp4Captions = s.captions)), g(null, y)) })); return _.addEventListener("progress", Fc(n, s)), u.push(_),
                    function() { return Lc(u) } },
            Gc = function(t, i) { var o; return t && (o = e.getComputedStyle(t)) ? o[i] : "" },
            Uc = function(t, e) { var i = t.slice();
                t.sort(function(t, o) { var n = e(t, o); return 0 === n ? i.indexOf(t) - i.indexOf(o) : n }) },
            Nc = function(t, i) { var o = void 0,
                    n = void 0; return t.attributes.BANDWIDTH && (o = t.attributes.BANDWIDTH), o = o || e.Number.MAX_VALUE, i.attributes.BANDWIDTH && (n = i.attributes.BANDWIDTH), o - (n = n || e.Number.MAX_VALUE) },
            jc = function(t, e, i) { if (!t || !e) return !1; var o = i === t.segments.length; return t.endList && "open" === e.readyState && o },
            Wc = function(t) { return "number" == typeof t && isFinite(t) },
            Xc = function(t) {
                function i(t) { nl(this, i); var e = al(this, (i.__proto__ || Object.getPrototypeOf(i)).call(this)); if (!t) throw new TypeError("Initialization settings are required"); if ("function" != typeof t.currentTime) throw new TypeError("No currentTime getter specified"); if (!t.mediaSource) throw new TypeError("No MediaSource specified"); return e.bandwidth = t.bandwidth, e.throughput = { rate: 0, count: 0 }, e.roundTrip = NaN, e.resetStats_(), e.mediaIndex = null, e.hasPlayed_ = t.hasPlayed, e.currentTime_ = t.currentTime, e.seekable_ = t.seekable, e.seeking_ = t.seeking, e.duration_ = t.duration, e.mediaSource_ = t.mediaSource, e.hls_ = t.hls, e.loaderType_ = t.loaderType, e.startingMedia_ = void 0, e.segmentMetadataTrack_ = t.segmentMetadataTrack, e.goalBufferLength_ = t.goalBufferLength, e.sourceType_ = t.sourceType, e.inbandTextTracks_ = t.inbandTextTracks, e.state_ = "INIT", e.checkBufferTimeout_ = null, e.error_ = void 0, e.currentTimeline_ = -1, e.pendingSegment_ = null, e.mimeType_ = null, e.sourceUpdater_ = null, e.xhrOptions_ = null, e.activeInitSegmentId_ = null, e.initSegments_ = {}, e.captionParser_ = new Rh, e.decrypter_ = t.decrypter, e.syncController_ = t.syncController, e.syncPoint_ = { segmentIndex: 0, time: 0 }, e.syncController_.on("syncinfoupdate", function() { return e.trigger("syncinfoupdate") }), e.mediaSource_.addEventListener("sourceopen", function() { return e.ended_ = !1 }), e.fetchAtBuffer_ = !1, e.logger_ = Ec("SegmentLoader[" + e.loaderType_ + "]"), Object.defineProperty(e, "state", { get: function() { return this.state_ }, set: function(t) { t !== this.state_ && (this.logger_(this.state_ + " -> " + t), this.state_ = t) } }), e } return rl(i, Nt.EventTarget), sl(i, [{ key: "resetStats_", value: function() { this.mediaBytesTransferred = 0, this.mediaRequests = 0, this.mediaRequestsAborted = 0, this.mediaRequestsTimedout = 0, this.mediaRequestsErrored = 0, this.mediaTransferDuration = 0, this.mediaSecondsLoaded = 0 } }, { key: "dispose", value: function() { this.state = "DISPOSED", this.pause(), this.abort_(), this.sourceUpdater_ && this.sourceUpdater_.dispose(), this.resetStats_(), this.captionParser_.reset() } }, { key: "abort", value: function() { "WAITING" === this.state ? (this.abort_(), this.state = "READY", this.paused() || this.monitorBuffer_()) : this.pendingSegment_ && (this.pendingSegment_ = null) } }, { key: "abort_", value: function() { this.pendingSegment_ && this.pendingSegment_.abortRequests(), this.pendingSegment_ = null } }, { key: "error", value: function(t) { return void 0 !== t && (this.error_ = t), this.pendingSegment_ = null, this.error_ } }, { key: "endOfStream", value: function() { this.ended_ = !0, this.pause(), this.trigger("ended") } }, { key: "buffered_", value: function() { return this.sourceUpdater_ ? this.sourceUpdater_.buffered() : Nt.createTimeRanges() } }, { key: "initSegment", value: function(t) { var e = 1 < arguments.length && void 0 !== arguments[1] && arguments[1]; if (!t) return null; var i = Ul(t),
                            o = this.initSegments_[i]; return e && !o && t.bytes && (this.initSegments_[i] = o = { resolvedUri: t.resolvedUri, byterange: t.byterange, bytes: t.bytes, timescales: t.timescales, videoTrackIds: t.videoTrackIds }), o || t } }, { key: "couldBeginLoading_", value: function() { return this.playlist_ && (this.sourceUpdater_ || this.mimeType_ && "INIT" === this.state) && !this.paused() } }, { key: "load", value: function() { if (this.monitorBuffer_(), this.playlist_) { if (this.syncController_.setDateTimeMapping(this.playlist_), "INIT" === this.state && this.couldBeginLoading_()) return this.init_();!this.couldBeginLoading_() || "READY" !== this.state && "INIT" !== this.state || (this.state = "READY") } } }, { key: "init_", value: function() { return this.state = "READY", this.sourceUpdater_ = new Bc(this.mediaSource_, this.mimeType_, this.loaderType_, this.sourceBufferEmitter_), this.resetEverything(), this.monitorBuffer_() } }, { key: "playlist", value: function(t) { var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}; if (t) { var i = this.playlist_,
                                o = this.pendingSegment_;
                            this.playlist_ = t, this.xhrOptions_ = e, this.hasPlayed_() || (t.syncInfo = { mediaSequence: t.mediaSequence, time: 0 }); var n = i ? i.id : null; if (this.logger_("playlist update [" + n + " => " + t.id + "]"), this.trigger("syncinfoupdate"), "INIT" === this.state && this.couldBeginLoading_()) return this.init_(); if (i && i.uri === t.uri) { var s = t.mediaSequence - i.mediaSequence;
                                this.logger_("live window shift [" + s + "]"), null !== this.mediaIndex && (this.mediaIndex -= s), o && (o.mediaIndex -= s, 0 <= o.mediaIndex && (o.segment = t.segments[o.mediaIndex])), this.syncController_.saveExpiredSegmentInfo(i, t) } else null !== this.mediaIndex && this.resyncLoader() } } }, { key: "pause", value: function() { this.checkBufferTimeout_ && (e.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = null) } }, { key: "paused", value: function() { return null === this.checkBufferTimeout_ } }, { key: "mimeType", value: function(t, e) { this.mimeType_ || (this.mimeType_ = t, this.sourceBufferEmitter_ = e, "INIT" === this.state && this.couldBeginLoading_() && this.init_()) } }, { key: "resetEverything", value: function(t) { this.ended_ = !1, this.resetLoader(), this.remove(0, this.duration_(), t), this.captionParser_.clearAllCaptions(), this.trigger("reseteverything") } }, { key: "resetLoader", value: function() { this.fetchAtBuffer_ = !1, this.resyncLoader() } }, { key: "resyncLoader", value: function() { this.mediaIndex = null, this.syncPoint_ = null, this.abort() } }, { key: "remove", value: function(t, e, i) { if (this.sourceUpdater_ && this.sourceUpdater_.remove(t, e, i), $l(t, e, this.segmentMetadataTrack_), this.inbandTextTracks_)
                            for (var o in this.inbandTextTracks_) $l(t, e, this.inbandTextTracks_[o]) } }, { key: "monitorBuffer_", value: function() { this.checkBufferTimeout_ && e.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = e.setTimeout(this.monitorBufferTick_.bind(this), 1) } }, { key: "monitorBufferTick_", value: function() { "READY" === this.state && this.fillBuffer_(), this.checkBufferTimeout_ && e.clearTimeout(this.checkBufferTimeout_), this.checkBufferTimeout_ = e.setTimeout(this.monitorBufferTick_.bind(this), 500) } }, { key: "fillBuffer_", value: function() { if (!this.sourceUpdater_.updating()) { this.syncPoint_ || (this.syncPoint_ = this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_())); var t = this.checkBuffer_(this.buffered_(), this.playlist_, this.mediaIndex, this.hasPlayed_(), this.currentTime_(), this.syncPoint_);
                            t && (jc(this.playlist_, this.mediaSource_, t.mediaIndex) ? this.endOfStream() : (t.mediaIndex !== this.playlist_.segments.length - 1 || "ended" !== this.mediaSource_.readyState || this.seeking_()) && ((t.timeline !== this.currentTimeline_ || null !== t.startOfSegment && t.startOfSegment < this.sourceUpdater_.timestampOffset()) && (this.syncController_.reset(), t.timestampOffset = t.startOfSegment, this.captionParser_.clearAllCaptions()), this.loadSegment_(t))) } } }, { key: "checkBuffer_", value: function(t, e, i, o, n, s) { var r = 0,
                            a = void 0;
                        t.length && (r = t.end(t.length - 1)); var h = Math.max(0, r - n); if (!e.segments.length) return null; if (h >= this.goalBufferLength_()) return null; if (!o && 1 <= h) return null; if (null === s) return i = this.getSyncSegmentCandidate_(e), this.generateSegmentInfo_(e, i, null, !0); if (null !== i) { var l = e.segments[i]; return a = l && l.end ? l.end : r, this.generateSegmentInfo_(e, i + 1, a, !1) } if (this.fetchAtBuffer_) { var c = Dl.getMediaInfoForTime(e, r, s.segmentIndex, s.time);
                            i = c.mediaIndex, a = c.startTime } else { var d = Dl.getMediaInfoForTime(e, n, s.segmentIndex, s.time);
                            i = d.mediaIndex, a = d.startTime } return this.generateSegmentInfo_(e, i, a, !1) } }, { key: "getSyncSegmentCandidate_", value: function(t) { var e = this; if (-1 === this.currentTimeline_) return 0; var i = t.segments.map(function(t, e) { return { timeline: t.timeline, segmentIndex: e } }).filter(function(t) { return t.timeline === e.currentTimeline_ }); return i.length ? i[Math.min(i.length - 1, 1)].segmentIndex : Math.max(t.segments.length - 1, 0) } }, { key: "generateSegmentInfo_", value: function(t, e, i, o) { if (e < 0 || e >= t.segments.length) return null; var n = t.segments[e]; return { requestId: "segment-loader-" + Math.random(), uri: n.resolvedUri, mediaIndex: e, isSyncRequest: o, startOfSegment: i, playlist: t, bytes: null, encryptedBytes: null, timestampOffset: null, timeline: n.timeline, duration: n.duration, segment: n } } }, { key: "abortRequestEarly_", value: function(t) { if (this.hls_.tech_.paused() || !this.xhrOptions_.timeout || !this.playlist_.attributes.BANDWIDTH) return !1; if (Date.now() - (t.firstBytesReceivedAt || Date.now()) < 1e3) return !1; var e = this.currentTime_(),
                            i = t.bandwidth,
                            o = this.pendingSegment_.duration,
                            n = Dl.estimateSegmentRequestTime(o, i, this.playlist_, t.bytesReceived),
                            s = function(t, e) { var i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 1; return ((t.length ? t.end(t.length - 1) : 0) - e) / i }(this.buffered_(), e, this.hls_.tech_.playbackRate()) - 1; if (n <= s) return !1; var r = function(t) { var e = t.master,
                                i = t.currentTime,
                                o = t.bandwidth,
                                n = t.duration,
                                s = t.segmentDuration,
                                r = t.timeUntilRebuffer,
                                a = t.currentTimeline,
                                h = t.syncController,
                                l = e.playlists.filter(function(t) { return !Dl.isIncompatible(t) }),
                                c = l.filter(Dl.isEnabled);
                            c.length || (c = l.filter(function(t) { return !Dl.isDisabled(t) })); var d = c.filter(Dl.hasAttribute.bind(null, "BANDWIDTH")).map(function(t) { var e = h.getSyncPoint(t, n, a, i) ? 1 : 2; return { playlist: t, rebufferingImpact: Dl.estimateSegmentRequestTime(s, o, t) * e - r } }),
                                u = d.filter(function(t) { return t.rebufferingImpact <= 0 }); return Uc(u, function(t, e) { return Nc(e.playlist, t.playlist) }), u.length ? u[0] : (Uc(d, function(t, e) { return t.rebufferingImpact - e.rebufferingImpact }), d[0] || null) }({ master: this.hls_.playlists.master, currentTime: e, bandwidth: i, duration: this.duration_(), segmentDuration: o, timeUntilRebuffer: s, currentTimeline: this.currentTimeline_, syncController: this.syncController_ }); if (r) { var a = n - s - r.rebufferingImpact,
                                h = .5; return s <= Jl && (h = 1), !(!r.playlist || r.playlist.uri === this.playlist_.uri || a < h) && (this.bandwidth = r.playlist.attributes.BANDWIDTH * Ic.BANDWIDTH_VARIANCE + 1, this.abort(), this.trigger("earlyabort"), !0) } } }, { key: "handleProgress_", value: function(t, e) { this.pendingSegment_ && e.requestId === this.pendingSegment_.requestId && !this.abortRequestEarly_(e.stats) && this.trigger("progress") } }, { key: "loadSegment_", value: function(t) { this.state = "WAITING", this.pendingSegment_ = t, this.trimBackBuffer_(t), t.abortRequests = Vc(this.hls_.xhr, this.xhrOptions_, this.decrypter_, this.captionParser_, this.createSimplifiedSegmentObj_(t), this.handleProgress_.bind(this), this.segmentRequestFinished_.bind(this)) } }, { key: "trimBackBuffer_", value: function(t) { var e, i, o, n, s = (e = this.seekable_(), i = this.currentTime_(), o = this.playlist_.targetDuration || 10, n = void 0, n = e.length && 0 < e.start(0) && e.start(0) < i ? e.start(0) : i - 30, Math.min(n, i - o));
                        0 < s && this.remove(0, s) } }, { key: "createSimplifiedSegmentObj_", value: function(t) { var e = t.segment,
                            i = { resolvedUri: e.resolvedUri, byterange: e.byterange, requestId: t.requestId }; if (e.key) { var o = e.key.iv || new Uint32Array([0, 0, 0, t.mediaIndex + t.playlist.mediaSequence]);
                            i.key = { resolvedUri: e.key.resolvedUri, iv: o } } return e.map && (i.map = this.initSegment(e.map)), i } }, { key: "segmentRequestFinished_", value: function(t, e) { if (this.mediaRequests += 1, e.stats && (this.mediaBytesTransferred += e.stats.bytesReceived, this.mediaTransferDuration += e.stats.roundTripTime), this.pendingSegment_) { if (e.requestId === this.pendingSegment_.requestId) { if (t) return this.pendingSegment_ = null, this.state = "READY", -102 === t.code ? void(this.mediaRequestsAborted += 1) : (this.pause(), -101 === t.code ? (this.mediaRequestsTimedout += 1, this.bandwidth = 1, this.roundTrip = NaN, void this.trigger("bandwidthupdate")) : (this.mediaRequestsErrored += 1, this.error(t), void this.trigger("error")));
                                this.bandwidth = e.stats.bandwidth, this.roundTrip = e.stats.roundTripTime, e.map && (e.map = this.initSegment(e.map, !0)), this.processSegmentResponse_(e) } } else this.mediaRequestsAborted += 1 } }, { key: "processSegmentResponse_", value: function(t) { var e = this.pendingSegment_;
                        e.bytes = t.bytes, t.map && (e.segment.map.bytes = t.map.bytes), e.endOfAllRequests = t.endOfAllRequests, t.fmp4Captions && (function(t, e, i) { for (var o in i)
                                if (!t[o]) { e.trigger({ type: "usage", name: "hls-608" }); var n = e.textTracks().getTrackById(o);
                                    t[o] = n || e.addRemoteTextTrack({ kind: "captions", id: o, label: o }, !1).track } }(this.inbandTextTracks_, this.hls_.tech_, t.captionStreams), function(t) { var e = t.inbandTextTracks,
                                i = t.captionArray,
                                o = t.timestampOffset; if (i) { var n = window.WebKitDataCue || window.VTTCue;
                                i.forEach(function(t) { var i = t.stream,
                                        s = t.startTime,
                                        r = t.endTime;
                                    e[i] && (s += o, r += o, e[i].addCue(new n(s, r, t.text))) }) } }({ inbandTextTracks: this.inbandTextTracks_, captionArray: t.fmp4Captions, timestampOffset: 0 }), this.captionParser_.clearParsedCaptions()), this.handleSegment_() } }, { key: "handleSegment_", value: function() { var t = this; if (this.pendingSegment_) { var e = this.pendingSegment_,
                                i = e.segment,
                                o = this.syncController_.probeSegmentInfo(e);
                            void 0 === this.startingMedia_ && o && (o.containsAudio || o.containsVideo) && (this.startingMedia_ = { containsAudio: o.containsAudio, containsVideo: o.containsVideo }); var n, s, r, a = (n = this.loaderType_, s = this.startingMedia_, r = o, "main" === n && s && r ? r.containsAudio || r.containsVideo ? s.containsVideo && !r.containsVideo ? "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest." : !s.containsVideo && r.containsVideo ? "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest." : null : "Neither audio nor video found in segment." : null); if (a) return this.error({ message: a, blacklistDuration: 1 / 0 }), void this.trigger("error"); if (e.isSyncRequest) return this.trigger("syncinfoupdate"), this.pendingSegment_ = null, void(this.state = "READY");
                            null !== e.timestampOffset && e.timestampOffset !== this.sourceUpdater_.timestampOffset() && (this.sourceUpdater_.timestampOffset(e.timestampOffset), this.trigger("timestampoffset")); var h, l, c, d, u, p, m, f, y, b, g, _ = this.syncController_.mappingForTimeline(e.timeline); if (null !== _ && this.trigger({ type: "segmenttimemapping", mapping: _ }), this.state = "APPENDING", i.map) { var v = Ul(i.map); if (!this.activeInitSegmentId_ || this.activeInitSegmentId_ !== v) { var x = this.initSegment(i.map);
                                    this.sourceUpdater_.appendBuffer(x.bytes, function() { t.activeInitSegmentId_ = v }) } } e.byteLength = e.bytes.byteLength, "number" == typeof i.start && "number" == typeof i.end ? this.mediaSecondsLoaded += i.end - i.start : this.mediaSecondsLoaded += i.duration, this.logger_((l = (h = e).segment, c = l.start, d = l.end, u = h.playlist, p = u.mediaSequence, m = u.id, f = u.segments, y = void 0 === f ? [] : f, b = h.mediaIndex, g = h.timeline, ["appending [" + b + "] of [" + p + ", " + (p + y.length) + "] from playlist [" + m + "]", "[" + c + " => " + d + "] in timeline [" + g + "]"].join(" "))), this.sourceUpdater_.appendBuffer(e.bytes, this.handleUpdateEnd_.bind(this)) } else this.state = "READY" } }, { key: "handleUpdateEnd_", value: function() { if (!this.pendingSegment_) return this.state = "READY", void(this.paused() || this.monitorBuffer_()); var t = this.pendingSegment_,
                            e = t.segment,
                            i = null !== this.mediaIndex;
                        this.pendingSegment_ = null, this.recordThroughput_(t), this.addSegmentMetadataCue_(t), this.state = "READY", this.mediaIndex = t.mediaIndex, this.fetchAtBuffer_ = !0, this.currentTimeline_ = t.timeline, this.trigger("syncinfoupdate"), e.end && this.currentTime_() - e.end > 3 * t.playlist.targetDuration ? this.resetEverything() : (i && this.trigger("bandwidthupdate"), this.trigger("progress"), jc(t.playlist, this.mediaSource_, t.mediaIndex + 1) && this.endOfStream(), this.paused() || this.monitorBuffer_()) } }, { key: "recordThroughput_", value: function(t) { var e = this.throughput.rate,
                            i = Date.now() - t.endOfAllRequests + 1,
                            o = Math.floor(t.byteLength / i * 8 * 1e3);
                        this.throughput.rate += (o - e) / ++this.throughput.count } }, { key: "addSegmentMetadataCue_", value: function(t) { if (this.segmentMetadataTrack_) { var i = t.segment,
                                o = i.start,
                                n = i.end; if (Wc(o) && Wc(n)) { $l(o, n, this.segmentMetadataTrack_); var s = e.WebKitDataCue || e.VTTCue,
                                    r = { dateTimeObject: i.dateTimeObject, dateTimeString: i.dateTimeString, bandwidth: t.playlist.attributes.BANDWIDTH, resolution: t.playlist.attributes.RESOLUTION, codecs: t.playlist.attributes.CODECS, byteLength: t.byteLength, uri: t.uri, timeline: t.timeline, playlist: t.playlist.uri, start: o, end: n },
                                    a = new s(o, n, JSON.stringify(r));
                                a.value = r, this.segmentMetadataTrack_.addCue(a) } } } }]), i }(),
            Hc = function(t) { return decodeURIComponent(escape(String.fromCharCode.apply(null, t))) },
            zc = new Uint8Array("\n\n".split("").map(function(t) { return t.charCodeAt(0) })),
            Jc = function(t) {
                function i(t) { var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
                    nl(this, i); var o = al(this, (i.__proto__ || Object.getPrototypeOf(i)).call(this, t, e)); return o.mediaSource_ = null, o.subtitlesTrack_ = null, o } return rl(i, Xc), sl(i, [{ key: "buffered_", value: function() { if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues.length) return Nt.createTimeRanges(); var t = this.subtitlesTrack_.cues,
                            e = t[0].startTime,
                            i = t[t.length - 1].startTime; return Nt.createTimeRanges([
                            [e, i]
                        ]) } }, { key: "initSegment", value: function(t) { var e = 1 < arguments.length && void 0 !== arguments[1] && arguments[1]; if (!t) return null; var i = Ul(t),
                            o = this.initSegments_[i]; if (e && !o && t.bytes) { var n = zc.byteLength + t.bytes.byteLength,
                                s = new Uint8Array(n);
                            s.set(t.bytes), s.set(zc, t.bytes.byteLength), this.initSegments_[i] = o = { resolvedUri: t.resolvedUri, byterange: t.byterange, bytes: s } } return o || t } }, { key: "couldBeginLoading_", value: function() { return this.playlist_ && this.subtitlesTrack_ && !this.paused() } }, { key: "init_", value: function() { return this.state = "READY", this.resetEverything(), this.monitorBuffer_() } }, { key: "track", value: function(t) { return void 0 === t || (this.subtitlesTrack_ = t, "INIT" === this.state && this.couldBeginLoading_() && this.init_()), this.subtitlesTrack_ } }, { key: "remove", value: function(t, e) { $l(t, e, this.subtitlesTrack_) } }, { key: "fillBuffer_", value: function() { var t = this;
                        this.syncPoint_ || (this.syncPoint_ = this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_())); var e = this.checkBuffer_(this.buffered_(), this.playlist_, this.mediaIndex, this.hasPlayed_(), this.currentTime_(), this.syncPoint_); if (e = this.skipEmptySegments_(e)) { if (null === this.syncController_.timestampOffsetForTimeline(e.timeline)) return this.syncController_.one("timestampoffset", function() { t.state = "READY", t.paused() || t.monitorBuffer_() }), void(this.state = "WAITING_ON_TIMELINE");
                            this.loadSegment_(e) } } }, { key: "skipEmptySegments_", value: function(t) { for (; t && t.segment.empty;) t = this.generateSegmentInfo_(t.playlist, t.mediaIndex + 1, t.startOfSegment + t.duration, t.isSyncRequest); return t } }, { key: "handleSegment_", value: function() { var t = this; if (this.pendingSegment_ && this.subtitlesTrack_) { this.state = "APPENDING"; var i = this.pendingSegment_,
                                o = i.segment; if ("function" != typeof e.WebVTT && this.subtitlesTrack_ && this.subtitlesTrack_.tech_) { var n = function() { t.handleSegment_() }; return this.state = "WAITING_ON_VTTJS", this.subtitlesTrack_.tech_.one("vttjsloaded", n), void this.subtitlesTrack_.tech_.one("vttjserror", function() { t.subtitlesTrack_.tech_.off("vttjsloaded", n), t.error({ message: "Error loading vtt.js" }), t.state = "READY", t.pause(), t.trigger("error") }) } o.requested = !0; try { this.parseVTTCues_(i) } catch (i) { return this.error({ message: i.message }), this.state = "READY", this.pause(), this.trigger("error") } if (this.updateTimeMapping_(i, this.syncController_.timelines[i.timeline], this.playlist_), i.isSyncRequest) return this.trigger("syncinfoupdate"), this.pendingSegment_ = null, void(this.state = "READY");
                            i.byteLength = i.bytes.byteLength, this.mediaSecondsLoaded += o.duration, i.cues.length && this.remove(i.cues[0].endTime, i.cues[i.cues.length - 1].endTime), i.cues.forEach(function(e) { t.subtitlesTrack_.addCue(e) }), this.handleUpdateEnd_() } else this.state = "READY" } }, { key: "parseVTTCues_", value: function(t) { var i = void 0,
                            o = !1; "function" == typeof e.TextDecoder ? i = new e.TextDecoder("utf8") : (i = e.WebVTT.StringDecoder(), o = !0); var n = new e.WebVTT.Parser(e, e.vttjs, i); if (t.cues = [], t.timestampmap = { MPEGTS: 0, LOCAL: 0 }, n.oncue = t.cues.push.bind(t.cues), n.ontimestampmap = function(e) { return t.timestampmap = e }, n.onparsingerror = function(t) { Nt.log.warn("Error encountered when parsing cues: " + t.message) }, t.segment.map) { var s = t.segment.map.bytes;
                            o && (s = Hc(s)), n.parse(s) } var r = t.bytes;
                        o && (r = Hc(r)), n.parse(r), n.flush() } }, { key: "updateTimeMapping_", value: function(t, e, i) { var o = t.segment; if (e)
                            if (t.cues.length) { var n = t.timestampmap,
                                    s = n.MPEGTS / 9e4 - n.LOCAL + e.mapping; if (t.cues.forEach(function(t) { t.startTime += s, t.endTime += s }), !i.syncInfo) { var r = t.cues[0].startTime,
                                        a = t.cues[t.cues.length - 1].startTime;
                                    i.syncInfo = { mediaSequence: i.mediaSequence + t.mediaIndex, time: Math.min(r, a - o.duration) } } } else o.empty = !0 } }]), i }(),
            qc = function(t, e) { for (var i = t.cues, o = 0; o < i.length; o++) { var n = i[o]; if (e >= n.adStartTime && e <= n.adEndTime) return n } return null },
            Yc = function(t, e) { var i; return (i = Wh.aac.isLikelyAacData(t) ? function(t) { for (var e, i = !1, o = 0, n = null, s = null, r = 0, a = 0; 3 <= t.length - a;) { switch (Wh.aac.parseType(t, a)) {
                            case "timed-metadata":
                                if (t.length - a < 10) { i = !0; break } if ((r = Wh.aac.parseId3TagSize(t, a)) > t.length) { i = !0; break } null === s && (e = t.subarray(a, a + r), s = Wh.aac.parseAacTimestamp(e)), a += r; break;
                            case "audio":
                                if (t.length - a < 7) { i = !0; break } if ((r = Wh.aac.parseAdtsSize(t, a)) > t.length) { i = !0; break } null === n && (e = t.subarray(a, a + r), n = Wh.aac.parseSampleRate(e)), o++, a += r; break;
                            default:
                                a++ } if (i) return null } if (null === n || null === s) return null; var h = 9e4 / n; return { audio: [{ type: "audio", dts: s, pts: s }, { type: "audio", dts: s + 1024 * o * h, pts: s + 1024 * o * h }] } }(t) : Jh(t)) && (i.audio || i.video) ? (function(t, e) { if (t.audio && t.audio.length) { var i = e;
                        void 0 === i && (i = t.audio[0].dts), t.audio.forEach(function(t) { t.dts = jh(t.dts, i), t.pts = jh(t.pts, i), t.dtsTime = t.dts / 9e4, t.ptsTime = t.pts / 9e4 }) } if (t.video && t.video.length) { var o = e; if (void 0 === o && (o = t.video[0].dts), t.video.forEach(function(t) { t.dts = jh(t.dts, o), t.pts = jh(t.pts, o), t.dtsTime = t.dts / 9e4, t.ptsTime = t.pts / 9e4 }), t.firstKeyFrame) { var n = t.firstKeyFrame;
                            n.dts = jh(n.dts, o), n.pts = jh(n.pts, o), n.dtsTime = n.dts / 9e4, n.ptsTime = n.dts / 9e4 } } }(i, e), i) : null },
            Kc = [{ name: "VOD", run: function(t, e, i, o, n) { return i === 1 / 0 ? null : { time: 0, segmentIndex: 0 } } }, { name: "ProgramDateTime", run: function(t, e, i, o, n) { if (!t.datetimeToDisplayTime) return null; var s = e.segments || [],
                        r = null,
                        a = null;
                    n = n || 0; for (var h = 0; h < s.length; h++) { var l = s[h]; if (l.dateTimeObject) { var c = l.dateTimeObject.getTime() / 1e3 + t.datetimeToDisplayTime,
                                d = Math.abs(n - c); if (null !== a && a < d) break;
                            a = d, r = { time: c, segmentIndex: h } } } return r } }, { name: "Segment", run: function(t, e, i, o, n) { var s = e.segments || [],
                        r = null,
                        a = null;
                    n = n || 0; for (var h = 0; h < s.length; h++) { var l = s[h]; if (l.timeline === o && void 0 !== l.start) { var c = Math.abs(n - l.start); if (null !== a && a < c) break;
                            (!r || null === a || c <= a) && (a = c, r = { time: l.start, segmentIndex: h }) } } return r } }, { name: "Discontinuity", run: function(t, e, i, o, n) { var s = null; if (n = n || 0, e.discontinuityStarts && e.discontinuityStarts.length)
                        for (var r = null, a = 0; a < e.discontinuityStarts.length; a++) { var h = e.discontinuityStarts[a],
                                l = e.discontinuitySequence + a + 1,
                                c = t.discontinuities[l]; if (c) { var d = Math.abs(n - c.time); if (null !== r && r < d) break;
                                (!s || null === r || d <= r) && (r = d, s = { time: c.time, segmentIndex: h }) } }
                    return s } }, { name: "Playlist", run: function(t, e, i, o, n) { return e.syncInfo ? { time: e.syncInfo.time, segmentIndex: e.syncInfo.mediaSequence - e.mediaSequence } : null } }],
            Zc = function(t) {
                function e() { nl(this, e); var t = al(this, (e.__proto__ || Object.getPrototypeOf(e)).call(this)); return t.inspectCache_ = void 0, t.timelines = [], t.discontinuities = [], t.datetimeToDisplayTime = null, t.logger_ = Ec("SyncController"), t } return rl(e, Nt.EventTarget), sl(e, [{ key: "getSyncPoint", value: function(t, e, i, o) { var n = this.runStrategies_(t, e, i, o); return n.length ? this.selectSyncPoint_(n, { key: "time", value: o }) : null } }, { key: "getExpiredTime", value: function(t, e) { if (!t || !t.segments) return null; var i = this.runStrategies_(t, e, t.discontinuitySequence, 0); if (!i.length) return null; var o = this.selectSyncPoint_(i, { key: "segmentIndex", value: 0 }); return 0 < o.segmentIndex && (o.time *= -1), Math.abs(o.time + xl(t, o.segmentIndex, 0)) } }, { key: "runStrategies_", value: function(t, e, i, o) { for (var n = [], s = 0; s < Kc.length; s++) { var r = Kc[s],
                                a = r.run(this, t, e, i, o);
                            a && (a.strategy = r.name, n.push({ strategy: r.name, syncPoint: a })) } return n } }, { key: "selectSyncPoint_", value: function(t, e) { for (var i = t[0].syncPoint, o = Math.abs(t[0].syncPoint[e.key] - e.value), n = t[0].strategy, s = 1; s < t.length; s++) { var r = Math.abs(t[s].syncPoint[e.key] - e.value);
                            r < o && (o = r, i = t[s].syncPoint, n = t[s].strategy) } return this.logger_("syncPoint for [" + e.key + ": " + e.value + "] chosen with strategy [" + n + "]: [time:" + i.time + ", segmentIndex:" + i.segmentIndex + "]"), i } }, { key: "saveExpiredSegmentInfo", value: function(t, e) { for (var i = e.mediaSequence - t.mediaSequence - 1; 0 <= i; i--) { var o = t.segments[i]; if (o && void 0 !== o.start) { e.syncInfo = { mediaSequence: t.mediaSequence + i, time: o.start }, this.logger_("playlist refresh sync: [time:" + e.syncInfo.time + ", mediaSequence: " + e.syncInfo.mediaSequence + "]"), this.trigger("syncinfoupdate"); break } } } }, { key: "setDateTimeMapping", value: function(t) { if (!this.datetimeToDisplayTime && t.segments && t.segments.length && t.segments[0].dateTimeObject) { var e = t.segments[0].dateTimeObject.getTime() / 1e3;
                            this.datetimeToDisplayTime = -e } } }, { key: "reset", value: function() { this.inspectCache_ = void 0 } }, { key: "probeSegmentInfo", value: function(t) { var e = t.segment,
                            i = t.playlist,
                            o = void 0; return (o = e.map ? this.probeMp4Segment_(t) : this.probeTsSegment_(t)) && this.calculateSegmentTimeMapping_(t, o) && (this.saveDiscontinuitySyncInfo_(t), i.syncInfo || (i.syncInfo = { mediaSequence: i.mediaSequence + t.mediaIndex, time: e.start })), o } }, { key: "probeMp4Segment_", value: function(t) { var e = t.segment,
                            i = Zr.timescale(e.map.bytes),
                            o = Zr.startTime(i, t.bytes); return null !== t.timestampOffset && (t.timestampOffset -= o), { start: o, end: o + e.duration } } }, { key: "probeTsSegment_", value: function(t) { var e = Yc(t.bytes, this.inspectCache_),
                            i = void 0,
                            o = void 0; return e ? (e.video && 2 === e.video.length ? (this.inspectCache_ = e.video[1].dts, i = e.video[0].dtsTime, o = e.video[1].dtsTime) : e.audio && 2 === e.audio.length && (this.inspectCache_ = e.audio[1].dts, i = e.audio[0].dtsTime, o = e.audio[1].dtsTime), { start: i, end: o, containsVideo: e.video && 2 === e.video.length, containsAudio: e.audio && 2 === e.audio.length }) : null } }, { key: "timestampOffsetForTimeline", value: function(t) { return void 0 === this.timelines[t] ? null : this.timelines[t].time } }, { key: "mappingForTimeline", value: function(t) { return void 0 === this.timelines[t] ? null : this.timelines[t].mapping } }, { key: "calculateSegmentTimeMapping_", value: function(t, e) { var i = t.segment,
                            o = this.timelines[t.timeline]; if (null !== t.timestampOffset) o = { time: t.startOfSegment, mapping: t.startOfSegment - e.start }, this.timelines[t.timeline] = o, this.trigger("timestampoffset"), this.logger_("time mapping for timeline " + t.timeline + ": [time: " + o.time + "] [mapping: " + o.mapping + "]"), i.start = t.startOfSegment, i.end = e.end + o.mapping;
                        else { if (!o) return !1;
                            i.start = e.start + o.mapping, i.end = e.end + o.mapping } return !0 } }, { key: "saveDiscontinuitySyncInfo_", value: function(t) { var e = t.playlist,
                            i = t.segment; if (i.discontinuity) this.discontinuities[i.timeline] = { time: i.start, accuracy: 0 };
                        else if (e.discontinuityStarts && e.discontinuityStarts.length)
                            for (var o = 0; o < e.discontinuityStarts.length; o++) { var n = e.discontinuityStarts[o],
                                    s = e.discontinuitySequence + o + 1,
                                    r = n - t.mediaIndex,
                                    a = Math.abs(r); if (!this.discontinuities[s] || this.discontinuities[s].accuracy > a) { var h = void 0;
                                    h = r < 0 ? i.start - xl(e, t.mediaIndex, n) : i.end + xl(e, t.mediaIndex + 1, n), this.discontinuities[s] = { time: h, accuracy: a } } } } }]), e }(),
            Qc = new jt("./decrypter-worker.worker.js", function(t, e) { var i, o, n, s, r, a, h, l, c = this;
                i = function(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") }, o = function() {
                    function t(t, e) { for (var i = 0; i < e.length; i++) { var o = e[i];
                            o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o) } } return function(e, i, o) { return i && t(e.prototype, i), o && t(e, o), e } }(), n = null, s = function() {
                    function t(e) { i(this, t), n || (n = function() { var t = [
                                    [
                                        [],
                                        [],
                                        [],
                                        [],
                                        []
                                    ],
                                    [
                                        [],
                                        [],
                                        [],
                                        [],
                                        []
                                    ]
                                ],
                                e = t[0],
                                i = t[1],
                                o = e[4],
                                n = i[4],
                                s = void 0,
                                r = void 0,
                                a = void 0,
                                h = [],
                                l = [],
                                c = void 0,
                                d = void 0,
                                u = void 0,
                                p = void 0,
                                m = void 0; for (s = 0; s < 256; s++) l[(h[s] = s << 1 ^ 283 * (s >> 7)) ^ s] = s; for (r = a = 0; !o[r]; r ^= c || 1, a = l[a] || 1)
                                for (u = (u = a ^ a << 1 ^ a << 2 ^ a << 3 ^ a << 4) >> 8 ^ 255 & u ^ 99, m = 16843009 * h[d = h[c = h[n[o[r] = u] = r]]] ^ 65537 * d ^ 257 * c ^ 16843008 * r, p = 257 * h[u] ^ 16843008 * u, s = 0; s < 4; s++) e[s][r] = p = p << 24 ^ p >>> 8, i[s][u] = m = m << 24 ^ m >>> 8; for (s = 0; s < 5; s++) e[s] = e[s].slice(0), i[s] = i[s].slice(0); return t }()), this._tables = [
                            [n[0][0].slice(), n[0][1].slice(), n[0][2].slice(), n[0][3].slice(), n[0][4].slice()],
                            [n[1][0].slice(), n[1][1].slice(), n[1][2].slice(), n[1][3].slice(), n[1][4].slice()]
                        ]; var o = void 0,
                            s = void 0,
                            r = void 0,
                            a = void 0,
                            h = void 0,
                            l = this._tables[0][4],
                            c = this._tables[1],
                            d = e.length,
                            u = 1; if (4 !== d && 6 !== d && 8 !== d) throw new Error("Invalid aes key size"); for (a = e.slice(0), h = [], this._key = [a, h], o = d; o < 4 * d + 28; o++) r = a[o - 1], (o % d == 0 || 8 === d && o % d == 4) && (r = l[r >>> 24] << 24 ^ l[r >> 16 & 255] << 16 ^ l[r >> 8 & 255] << 8 ^ l[255 & r], o % d == 0 && (r = r << 8 ^ r >>> 24 ^ u << 24, u = u << 1 ^ 283 * (u >> 7))), a[o] = a[o - d] ^ r; for (s = 0; o; s++, o--) r = a[3 & s ? o : o - 4], h[s] = o <= 4 || s < 4 ? r : c[0][l[r >>> 24]] ^ c[1][l[r >> 16 & 255]] ^ c[2][l[r >> 8 & 255]] ^ c[3][l[255 & r]] } return t.prototype.decrypt = function(t, e, i, o, n, s) { var r = this._key[1],
                            a = t ^ r[0],
                            h = o ^ r[1],
                            l = i ^ r[2],
                            c = e ^ r[3],
                            d = void 0,
                            u = void 0,
                            p = void 0,
                            m = r.length / 4 - 2,
                            f = void 0,
                            y = 4,
                            b = this._tables[1],
                            g = b[0],
                            _ = b[1],
                            v = b[2],
                            x = b[3],
                            S = b[4]; for (f = 0; f < m; f++) d = g[a >>> 24] ^ _[h >> 16 & 255] ^ v[l >> 8 & 255] ^ x[255 & c] ^ r[y], u = g[h >>> 24] ^ _[l >> 16 & 255] ^ v[c >> 8 & 255] ^ x[255 & a] ^ r[y + 1], p = g[l >>> 24] ^ _[c >> 16 & 255] ^ v[a >> 8 & 255] ^ x[255 & h] ^ r[y + 2], c = g[c >>> 24] ^ _[a >> 16 & 255] ^ v[h >> 8 & 255] ^ x[255 & l] ^ r[y + 3], y += 4, a = d, h = u, l = p; for (f = 0; f < 4; f++) n[(3 & -f) + s] = S[a >>> 24] << 24 ^ S[h >> 16 & 255] << 16 ^ S[l >> 8 & 255] << 8 ^ S[255 & c] ^ r[y++], d = a, a = h, h = l, l = c, c = d }, t }(), r = function() {
                    function t() { i(this, t), this.listeners = {} } return t.prototype.on = function(t, e) { this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push(e) }, t.prototype.off = function(t, e) { if (!this.listeners[t]) return !1; var i = this.listeners[t].indexOf(e); return this.listeners[t].splice(i, 1), -1 < i }, t.prototype.trigger = function(t) { var e = this.listeners[t]; if (e)
                            if (2 === arguments.length)
                                for (var i = e.length, o = 0; o < i; ++o) e[o].call(this, arguments[1]);
                            else
                                for (var n = Array.prototype.slice.call(arguments, 1), s = e.length, r = 0; r < s; ++r) e[r].apply(this, n) }, t.prototype.dispose = function() { this.listeners = {} }, t.prototype.pipe = function(t) { this.on("data", function(e) { t.push(e) }) }, t }(), a = function(t) {
                    function e() { i(this, e); var o = function(t, e) { if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return !e || "object" != typeof e && "function" != typeof e ? t : e }(this, t.call(this, r)); return o.jobs = [], o.delay = 1, o.timeout_ = null, o } return function(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                        t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e) }(e, t), e.prototype.processJob_ = function() { this.jobs.shift()(), this.jobs.length ? this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay) : this.timeout_ = null }, e.prototype.push = function(t) { this.jobs.push(t), this.timeout_ || (this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay)) }, e }(r), h = function(t) { return t << 24 | (65280 & t) << 8 | (16711680 & t) >> 8 | t >>> 24 }, l = function() {
                    function t(e, o, n, s) { i(this, t); var r = t.STEP,
                            l = new Int32Array(e.buffer),
                            c = new Uint8Array(e.byteLength),
                            d = 0; for (this.asyncStream_ = new a, this.asyncStream_.push(this.decryptChunk_(l.subarray(d, d + r), o, n, c)), d = r; d < l.length; d += r) n = new Uint32Array([h(l[d - 4]), h(l[d - 3]), h(l[d - 2]), h(l[d - 1])]), this.asyncStream_.push(this.decryptChunk_(l.subarray(d, d + r), o, n, c));
                        this.asyncStream_.push(function() { var t;
                            s(null, (t = c).subarray(0, t.byteLength - t[t.byteLength - 1])) }) } return t.prototype.decryptChunk_ = function(t, e, i, o) { return function() { var n = function(t, e, i) { var o = new Int32Array(t.buffer, t.byteOffset, t.byteLength >> 2),
                                    n = new s(Array.prototype.slice.call(e)),
                                    r = new Uint8Array(t.byteLength),
                                    a = new Int32Array(r.buffer),
                                    l = void 0,
                                    c = void 0,
                                    d = void 0,
                                    u = void 0,
                                    p = void 0,
                                    m = void 0,
                                    f = void 0,
                                    y = void 0,
                                    b = void 0; for (l = i[0], c = i[1], d = i[2], u = i[3], b = 0; b < o.length; b += 4) p = h(o[b]), m = h(o[b + 1]), f = h(o[b + 2]), y = h(o[b + 3]), n.decrypt(p, m, f, y, a, b), a[b] = h(a[b] ^ l), a[b + 1] = h(a[b + 1] ^ c), a[b + 2] = h(a[b + 2] ^ d), a[b + 3] = h(a[b + 3] ^ u), l = p, c = m, d = f, u = y; return r }(t, e, i);
                            o.set(n, t.byteOffset) } }, o(t, null, [{ key: "STEP", get: function() { return 32e3 } }]), t }(), new function(t) { t.onmessage = function(e) { var i = e.data,
                            o = new Uint8Array(i.encrypted.bytes, i.encrypted.byteOffset, i.encrypted.byteLength),
                            n = new Uint32Array(i.key.bytes, i.key.byteOffset, i.key.byteLength / 4),
                            s = new Uint32Array(i.iv.bytes, i.iv.byteOffset, i.iv.byteLength / 4);
                        new l(o, n, s, function(e, o) { var n, s;
                            t.postMessage((n = { source: i.source, decrypted: o }, s = {}, Object.keys(n).forEach(function(t) { var e = n[t];
                                ArrayBuffer.isView(e) ? s[t] = { bytes: e.buffer, byteOffset: e.byteOffset, byteLength: e.byteLength } : s[t] = e }), s), [o.buffer]) }) } }(c) }),
            $c = function(t, e) { t.abort(), t.pause(), e && e.activePlaylistLoader && (e.activePlaylistLoader.pause(), e.activePlaylistLoader = null) },
            td = function(t, e) {
                (e.activePlaylistLoader = t).load() },
            ed = { AUDIO: function(t, e) { return function() { var i = e.segmentLoaders[t],
                            o = e.mediaTypes[t],
                            n = e.blacklistCurrentPlaylist;
                        $c(i, o); var s = o.activeTrack(),
                            r = o.activeGroup(),
                            a = (r.filter(function(t) { return t.default })[0] || r[0]).id,
                            h = o.tracks[a]; if (s !== h) { for (var l in Nt.log.warn("Problem encountered loading the alternate audio track.Switching back to default."), o.tracks) o.tracks[l].enabled = o.tracks[l] === h;
                            o.onTrackChanged() } else n({ message: "Problem encountered loading the default audio track." }) } }, SUBTITLES: function(t, e) { return function() { var i = e.segmentLoaders[t],
                            o = e.mediaTypes[t];
                        Nt.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track."), $c(i, o); var n = o.activeTrack();
                        n && (n.mode = "disabled"), o.onTrackChanged() } } },
            id = { AUDIO: function(t, e, i) { if (e) { var o = i.tech,
                            n = i.requestOptions,
                            s = i.segmentLoaders[t];
                        e.on("loadedmetadata", function() { var t = e.media();
                            s.playlist(t, n), (!o.paused() || t.endList && "none" !== o.preload()) && s.load() }), e.on("loadedplaylist", function() { s.playlist(e.media(), n), o.paused() || s.load() }), e.on("error", ed[t](t, i)) } }, SUBTITLES: function(t, e, i) { var o = i.tech,
                        n = i.requestOptions,
                        s = i.segmentLoaders[t],
                        r = i.mediaTypes[t];
                    e.on("loadedmetadata", function() { var t = e.media();
                        s.playlist(t, n), s.track(r.activeTrack()), (!o.paused() || t.endList && "none" !== o.preload()) && s.load() }), e.on("loadedplaylist", function() { s.playlist(e.media(), n), o.paused() || s.load() }), e.on("error", ed[t](t, i)) } },
            od = function(t, e) { return function(i) { return i.attributes[t] === e } },
            nd = function(t) { return function(e) { return e.resolvedUri === t } },
            sd = { AUDIO: function(t, e) { var i, o, n = e.hls,
                        s = e.sourceType,
                        r = e.segmentLoaders[t],
                        a = e.requestOptions.withCredentials,
                        h = e.master,
                        l = h.mediaGroups,
                        c = h.playlists,
                        d = e.mediaTypes[t],
                        u = d.groups,
                        p = d.tracks,
                        m = e.masterPlaylistLoader; for (var f in l[t] && 0 !== Object.keys(l[t]).length || (l[t] = { main: { default: { default: !0 } } }), l[t]) { u[f] || (u[f] = []); var y = c.filter(od(t, f)); for (var b in l[t][f]) { var g = l[t][f][b];
                            y.filter(nd(g.resolvedUri)).length && delete g.resolvedUri; var _ = void 0; if (_ = g.resolvedUri ? new bl(g.resolvedUri, n, a) : g.playlists && "dash" === s ? new Mc(g.playlists[0], n, a, m) : null, g = Nt.mergeOptions({ id: b, playlistLoader: _ }, g), id[t](t, g.playlistLoader, e), u[f].push(g), void 0 === p[b]) { var v = new Nt.AudioTrack({ id: b, kind: (i = g, o = void 0, o = i.default ? "main" : "alternative", i.characteristics && 0 <= i.characteristics.indexOf("public.accessibility.describes-video") && (o = "main-desc"), o), enabled: !1, language: g.language, default: g.default, label: b });
                                p[b] = v } } } r.on("error", ed[t](t, e)) }, SUBTITLES: function(t, e) { var i = e.tech,
                        o = e.hls,
                        n = e.sourceType,
                        s = e.segmentLoaders[t],
                        r = e.requestOptions.withCredentials,
                        a = e.master.mediaGroups,
                        h = e.mediaTypes[t],
                        l = h.groups,
                        c = h.tracks,
                        d = e.masterPlaylistLoader; for (var u in a[t])
                        for (var p in l[u] || (l[u] = []), a[t][u])
                            if (!a[t][u][p].forced) { var m = a[t][u][p],
                                    f = void 0; if ("hls" === n ? f = new bl(m.resolvedUri, o, r) : "dash" === n && (f = new Mc(m.playlists[0], o, r, d)), m = Nt.mergeOptions({ id: p, playlistLoader: f }, m), id[t](t, m.playlistLoader, e), l[u].push(m), void 0 === c[p]) { var y = i.addRemoteTextTrack({ id: p, kind: "subtitles", default: m.default && m.autoselect, language: m.language, label: p }, !1).track;
                                    c[p] = y } } s.on("error", ed[t](t, e)) }, "CLOSED-CAPTIONS": function(t, e) { var i = e.tech,
                        o = e.master.mediaGroups,
                        n = e.mediaTypes[t],
                        s = n.groups,
                        r = n.tracks; for (var a in o[t])
                        for (var h in s[a] || (s[a] = []), o[t][a]) { var l = o[t][a][h]; if (l.instreamId.match(/CC\d/) && (s[a].push(Nt.mergeOptions({ id: h }, l)), void 0 === r[h])) { var c = i.addRemoteTextTrack({ id: l.instreamId, kind: "captions", default: l.default && l.autoselect, language: l.language, label: h }, !1).track;
                                r[h] = c } } } },
            rd = { AUDIO: function(t, e) { return function() { var i = e.mediaTypes[t].tracks; for (var o in i)
                            if (i[o].enabled) return i[o]; return null } }, SUBTITLES: function(t, e) { return function() { var i = e.mediaTypes[t].tracks; for (var o in i)
                            if ("showing" === i[o].mode) return i[o]; return null } } },
            ad = function(t) {
                ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(e) { sd[e](e, t) }); var e = t.mediaTypes,
                    i = t.masterPlaylistLoader,
                    o = t.tech,
                    n = t.hls;
                ["AUDIO", "SUBTITLES"].forEach(function(i) { var o, n, s, r, a, h;
                    e[i].activeGroup = (o = i, n = t, function(t) { var e = n.masterPlaylistLoader,
                            i = n.mediaTypes[o].groups,
                            s = e.media(); if (!s) return null; var r = null; return s.attributes[o] && (r = i[s.attributes[o]]), r = r || i.main, void 0 === t ? r : null === t ? null : r.filter(function(e) { return e.id === t.id })[0] || null }), e[i].activeTrack = rd[i](i, t), e[i].onGroupChanged = (s = i, r = t, function() { var t = r.segmentLoaders,
                            e = t[s],
                            i = t.main,
                            o = r.mediaTypes[s],
                            n = o.activeTrack(),
                            a = o.activeGroup(n),
                            h = o.activePlaylistLoader;
                        $c(e, o), a && (a.playlistLoader ? (e.resyncLoader(), td(a.playlistLoader, o)) : h && i.resetEverything()) }), e[i].onTrackChanged = (a = i, h = t, function() { var t = h.segmentLoaders,
                            e = t[a],
                            i = t.main,
                            o = h.mediaTypes[a],
                            n = o.activeTrack(),
                            s = o.activeGroup(n),
                            r = o.activePlaylistLoader;
                        $c(e, o), s && (s.playlistLoader ? (r !== s.playlistLoader && (e.track && e.track(n), e.resetEverything()), td(s.playlistLoader, o)) : i.resetEverything()) }) }); var s = e.AUDIO.activeGroup(),
                    r = (s.filter(function(t) { return t.default })[0] || s[0]).id;
                e.AUDIO.tracks[r].enabled = !0, e.AUDIO.onTrackChanged(), i.on("mediachange", function() {
                    ["AUDIO", "SUBTITLES"].forEach(function(t) { return e[t].onGroupChanged() }) }); var a = function() { e.AUDIO.onTrackChanged(), o.trigger({ type: "usage", name: "hls-audio-change" }) }; for (var h in o.audioTracks().addEventListener("change", a), o.remoteTextTracks().addEventListener("change", e.SUBTITLES.onTrackChanged), n.on("dispose", function() { o.audioTracks().removeEventListener("change", a), o.remoteTextTracks().removeEventListener("change", e.SUBTITLES.onTrackChanged) }), o.clearTracks("audio"), e.AUDIO.tracks) o.audioTracks().addTrack(e.AUDIO.tracks[h]) },
            hd = void 0,
            ld = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred"],
            cd = function(t) {
                function i(t) { nl(this, i); var e, o = al(this, (i.__proto__ || Object.getPrototypeOf(i)).call(this)),
                        n = t.url,
                        s = t.withCredentials,
                        r = t.tech,
                        a = t.bandwidth,
                        h = t.externHls,
                        l = t.useCueTags,
                        c = t.blacklistDuration,
                        d = t.enableLowInitialPlaylist,
                        u = t.sourceType,
                        p = t.seekTo; if (!n) throw new Error("A non-empty playlist URL is required");
                    hd = h, o.withCredentials = s, o.tech_ = r, o.hls_ = r.hls, o.seekTo_ = p, o.sourceType_ = u, o.useCueTags_ = l, o.blacklistDuration = c, o.enableLowInitialPlaylist = d, o.useCueTags_ && (o.cueTagsTrack_ = o.tech_.addTextTrack("metadata", "ad-cues"), o.cueTagsTrack_.inBandMetadataTrackDispatchType = ""), o.requestOptions_ = { withCredentials: o.withCredentials, timeout: null }, o.mediaTypes_ = (e = {}, ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(function(t) { e[t] = { groups: {}, tracks: {}, activePlaylistLoader: null, activeGroup: Xt, activeTrack: Xt, onGroupChanged: Xt, onTrackChanged: Xt } }), e), o.mediaSource = new Nt.MediaSource, o.mediaSource.addEventListener("sourceopen", o.handleSourceOpen_.bind(o)), o.seekable_ = Nt.createTimeRanges(), o.hasPlayed_ = function() { return !1 }, o.syncController_ = new Zc(t), o.segmentMetadataTrack_ = r.addRemoteTextTrack({ kind: "metadata", label: "segment-metadata" }, !1).track, o.decrypter_ = new Qc, o.inbandTextTracks_ = {}; var m = { hls: o.hls_, mediaSource: o.mediaSource, currentTime: o.tech_.currentTime.bind(o.tech_), seekable: function() { return o.seekable() }, seeking: function() { return o.tech_.seeking() }, duration: function() { return o.mediaSource.duration }, hasPlayed: function() { return o.hasPlayed_() }, goalBufferLength: function() { return o.goalBufferLength() }, bandwidth: a, syncController: o.syncController_, decrypter: o.decrypter_, sourceType: o.sourceType_, inbandTextTracks: o.inbandTextTracks_ }; return o.masterPlaylistLoader_ = "dash" === o.sourceType_ ? new Mc(n, o.hls_, o.withCredentials) : new bl(n, o.hls_, o.withCredentials), o.setupMasterPlaylistLoaderListeners_(), o.mainSegmentLoader_ = new Xc(Nt.mergeOptions(m, { segmentMetadataTrack: o.segmentMetadataTrack_, loaderType: "main" }), t), o.audioSegmentLoader_ = new Xc(Nt.mergeOptions(m, { loaderType: "audio" }), t), o.subtitleSegmentLoader_ = new Jc(Nt.mergeOptions(m, { loaderType: "vtt" }), t), o.setupSegmentLoaderListeners_(), ld.forEach(function(t) { o[t + "_"] = function(t) { return this.audioSegmentLoader_[t] + this.mainSegmentLoader_[t] }.bind(o, t) }), o.logger_ = Ec("MPC"), o.masterPlaylistLoader_.load(), o } return rl(i, Nt.EventTarget), sl(i, [{ key: "setupMasterPlaylistLoaderListeners_", value: function() { var t = this;
                        this.masterPlaylistLoader_.on("loadedmetadata", function() { var e = t.masterPlaylistLoader_.media(),
                                i = 1.5 * t.masterPlaylistLoader_.targetDuration * 1e3;
                            Il(t.masterPlaylistLoader_.master, t.masterPlaylistLoader_.media()) ? t.requestOptions_.timeout = 0 : t.requestOptions_.timeout = i, e.endList && "none" !== t.tech_.preload() && (t.mainSegmentLoader_.playlist(e, t.requestOptions_), t.mainSegmentLoader_.load()), ad({ sourceType: t.sourceType_, segmentLoaders: { AUDIO: t.audioSegmentLoader_, SUBTITLES: t.subtitleSegmentLoader_, main: t.mainSegmentLoader_ }, tech: t.tech_, requestOptions: t.requestOptions_, masterPlaylistLoader: t.masterPlaylistLoader_, hls: t.hls_, master: t.master(), mediaTypes: t.mediaTypes_, blacklistCurrentPlaylist: t.blacklistCurrentPlaylist.bind(t) }), t.triggerPresenceUsage_(t.master(), e); try { t.setupSourceBuffers_() } catch (e) { return Nt.log.warn("Failed to create SourceBuffers", e), t.mediaSource.endOfStream("decode") } t.setupFirstPlay(), t.trigger("selectedinitialmedia") }), this.masterPlaylistLoader_.on("loadedplaylist", function() { var e = t.masterPlaylistLoader_.media(); if (!e) { t.excludeUnsupportedVariants_(); var i = void 0; return t.enableLowInitialPlaylist && (i = t.selectInitialPlaylist()), i || (i = t.selectPlaylist()), t.initialMedia_ = i, void t.masterPlaylistLoader_.media(t.initialMedia_) } if (t.useCueTags_ && t.updateAdCues_(e), t.mainSegmentLoader_.playlist(e, t.requestOptions_), t.updateDuration(), t.tech_.paused() || (t.mainSegmentLoader_.load(), t.audioSegmentLoader_ && t.audioSegmentLoader_.load()), !e.endList) { var o = function() { var e = t.seekable();
                                    0 !== e.length && t.mediaSource.addSeekableRange_(e.start(0), e.end(0)) };
                                t.duration() !== 1 / 0 ? t.tech_.one("durationchange", function e() { t.duration() === 1 / 0 ? o() : t.tech_.one("durationchange", e) }) : o() } }), this.masterPlaylistLoader_.on("error", function() { t.blacklistCurrentPlaylist(t.masterPlaylistLoader_.error) }), this.masterPlaylistLoader_.on("mediachanging", function() { t.mainSegmentLoader_.abort(), t.mainSegmentLoader_.pause() }), this.masterPlaylistLoader_.on("mediachange", function() { var e = t.masterPlaylistLoader_.media(),
                                i = 1.5 * t.masterPlaylistLoader_.targetDuration * 1e3;
                            Il(t.masterPlaylistLoader_.master, t.masterPlaylistLoader_.media()) ? t.requestOptions_.timeout = 0 : t.requestOptions_.timeout = i, t.mainSegmentLoader_.playlist(e, t.requestOptions_), t.mainSegmentLoader_.load(), t.tech_.trigger({ type: "mediachange", bubbles: !0 }) }), this.masterPlaylistLoader_.on("playlistunchanged", function() { var e = t.masterPlaylistLoader_.media();
                            t.stuckAtPlaylistEnd_(e) && (t.blacklistCurrentPlaylist({ message: "Playlist no longer updating." }), t.tech_.trigger("playliststuck")) }), this.masterPlaylistLoader_.on("renditiondisabled", function() { t.tech_.trigger({ type: "usage", name: "hls-rendition-disabled" }) }), this.masterPlaylistLoader_.on("renditionenabled", function() { t.tech_.trigger({ type: "usage", name: "hls-rendition-enabled" }) }) } }, { key: "triggerPresenceUsage_", value: function(t, e) { var i = t.mediaGroups || {},
                            o = !0,
                            n = Object.keys(i.AUDIO); for (var s in i.AUDIO)
                            for (var r in i.AUDIO[s]) i.AUDIO[s][r].uri || (o = !1);
                        o && this.tech_.trigger({ type: "usage", name: "hls-demuxed" }), Object.keys(i.SUBTITLES).length && this.tech_.trigger({ type: "usage", name: "hls-webvtt" }), hd.Playlist.isAes(e) && this.tech_.trigger({ type: "usage", name: "hls-aes" }), hd.Playlist.isFmp4(e) && this.tech_.trigger({ type: "usage", name: "hls-fmp4" }), n.length && 1 < Object.keys(i.AUDIO[n[0]]).length && this.tech_.trigger({ type: "usage", name: "hls-alternate-audio" }), this.useCueTags_ && this.tech_.trigger({ type: "usage", name: "hls-playlist-cue-tags" }) } }, { key: "setupSegmentLoaderListeners_", value: function() { var t = this;
                        this.mainSegmentLoader_.on("bandwidthupdate", function() { var e = t.selectPlaylist(),
                                i = t.masterPlaylistLoader_.media(),
                                o = t.tech_.buffered(),
                                n = o.length ? o.end(o.length - 1) - t.tech_.currentTime() : 0,
                                s = t.bufferLowWaterLine();
                            (!i.endList || t.duration() < Ic.MAX_BUFFER_LOW_WATER_LINE || e.attributes.BANDWIDTH < i.attributes.BANDWIDTH || s <= n) && t.masterPlaylistLoader_.media(e), t.tech_.trigger("bandwidthupdate") }), this.mainSegmentLoader_.on("progress", function() { t.trigger("progress") }), this.mainSegmentLoader_.on("error", function() { t.blacklistCurrentPlaylist(t.mainSegmentLoader_.error()) }), this.mainSegmentLoader_.on("syncinfoupdate", function() { t.onSyncInfoUpdate_() }), this.mainSegmentLoader_.on("timestampoffset", function() { t.tech_.trigger({ type: "usage", name: "hls-timestamp-offset" }) }), this.audioSegmentLoader_.on("syncinfoupdate", function() { t.onSyncInfoUpdate_() }), this.mainSegmentLoader_.on("ended", function() { t.onEndOfStream() }), this.mainSegmentLoader_.on("earlyabort", function() { t.blacklistCurrentPlaylist({ message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering." }, 120) }), this.mainSegmentLoader_.on("reseteverything", function() { t.tech_.trigger("hls-reset") }), this.mainSegmentLoader_.on("segmenttimemapping", function(e) { t.tech_.trigger({ type: "hls-segment-time-mapping", mapping: e.mapping }) }), this.audioSegmentLoader_.on("ended", function() { t.onEndOfStream() }) } }, { key: "mediaSecondsLoaded_", value: function() { return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded) } }, { key: "load", value: function() { this.mainSegmentLoader_.load(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.load(), this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.load() } }, { key: "smoothQualityChange_", value: function() { var t = this.selectPlaylist();
                        t !== this.masterPlaylistLoader_.media() && (this.masterPlaylistLoader_.media(t), this.mainSegmentLoader_.resetLoader()) } }, { key: "fastQualityChange_", value: function() { var t = this,
                            e = this.selectPlaylist();
                        e !== this.masterPlaylistLoader_.media() && (this.masterPlaylistLoader_.media(e), this.mainSegmentLoader_.resetEverything(function() { Nt.browser.IE_VERSION || Nt.browser.IS_EDGE ? t.tech_.setCurrentTime(t.tech_.currentTime() + .04) : t.tech_.setCurrentTime(t.tech_.currentTime()) })) } }, { key: "play", value: function() { if (!this.setupFirstPlay()) { this.tech_.ended() && this.seekTo_(0), this.hasPlayed_() && this.load(); var t = this.tech_.seekable(); return this.tech_.duration() === 1 / 0 && this.tech_.currentTime() < t.start(0) ? this.seekTo_(t.end(t.length - 1)) : void 0 } } }, { key: "setupFirstPlay", value: function() { var t = this,
                            e = this.masterPlaylistLoader_.media(); if (!e || this.tech_.paused() || this.hasPlayed_()) return !1; if (!e.endList) { var i = this.seekable(); if (!i.length) return !1; if (Nt.browser.IE_VERSION && 0 === this.tech_.readyState()) return this.tech_.one("loadedmetadata", function() { t.trigger("firstplay"), t.seekTo_(i.end(0)), t.hasPlayed_ = function() { return !0 } }), !1;
                            this.trigger("firstplay"), this.seekTo_(i.end(0)) } return this.hasPlayed_ = function() { return !0 }, this.load(), !0 } }, { key: "handleSourceOpen_", value: function() { try { this.setupSourceBuffers_() } catch (t) { return Nt.log.warn("Failed to create Source Buffers", t), this.mediaSource.endOfStream("decode") } if (this.tech_.autoplay()) { var t = this.tech_.play();
                            void 0 !== t && "function" == typeof t.then && t.then(null, function(t) {}) } this.trigger("sourceopen") } }, { key: "onEndOfStream", value: function() { var t = this.mainSegmentLoader_.ended_;
                        this.mediaTypes_.AUDIO.activePlaylistLoader && (t = !this.mainSegmentLoader_.startingMedia_ || this.mainSegmentLoader_.startingMedia_.containsVideo ? t && this.audioSegmentLoader_.ended_ : this.audioSegmentLoader_.ended_), t && this.mediaSource.endOfStream() } }, { key: "stuckAtPlaylistEnd_", value: function(t) { if (!this.seekable().length) return !1; var e = this.syncController_.getExpiredTime(t, this.mediaSource.duration); if (null === e) return !1; var i = hd.Playlist.playlistEnd(t, e),
                            o = this.tech_.currentTime(),
                            n = this.tech_.buffered(); if (!n.length) return i - o <= .1; var s = n.end(n.length - 1); return s - o <= .1 && i - s <= .1 } }, { key: "blacklistCurrentPlaylist", value: function() { var t, e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {},
                            i = arguments[1],
                            o = void 0; if (o = e.playlist || this.masterPlaylistLoader_.media(), i = i || e.blacklistDuration || this.blacklistDuration, !o) { this.error = e; try { return this.mediaSource.endOfStream("network") } catch (t) { return this.trigger("error") } } var n = 1 === this.masterPlaylistLoader_.master.playlists.filter(El).length; return n ? (Nt.log.warn("Problem encountered with the current HLS playlist. Trying again since it is the final playlist."), this.tech_.trigger("retryplaylist"), this.masterPlaylistLoader_.load(n)) : (o.excludeUntil = Date.now() + 1e3 * i, this.tech_.trigger("blacklistplaylist"), this.tech_.trigger({ type: "usage", name: "hls-rendition-blacklisted" }), t = this.selectPlaylist(), Nt.log.warn("Problem encountered with the current HLS playlist." + (e.message ? " " + e.message : "") + " Switching to another playlist."), this.masterPlaylistLoader_.media(t)) } }, { key: "pauseLoading", value: function() { this.mainSegmentLoader_.pause(), this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.pause(), this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.pause() } }, { key: "setCurrentTime", value: function(t) { var e = Yl(this.tech_.buffered(), t); return this.masterPlaylistLoader_ && this.masterPlaylistLoader_.media() && this.masterPlaylistLoader_.media().segments ? e && e.length ? t : (this.mainSegmentLoader_.resetEverything(), this.mainSegmentLoader_.abort(), this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.resetEverything(), this.audioSegmentLoader_.abort()), this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.resetEverything(), this.subtitleSegmentLoader_.abort()), void this.load()) : 0 } }, { key: "duration", value: function() { return this.masterPlaylistLoader_ ? this.mediaSource ? this.mediaSource.duration : hd.Playlist.duration(this.masterPlaylistLoader_.media()) : 0 } }, { key: "seekable", value: function() { return this.seekable_ } }, { key: "onSyncInfoUpdate_", value: function() { var t = void 0,
                            e = void 0; if (this.masterPlaylistLoader_) { var i = this.masterPlaylistLoader_.media(); if (i) { var o = this.syncController_.getExpiredTime(i, this.mediaSource.duration); if (null !== o && 0 !== (t = hd.Playlist.seekable(i, o)).length) { if (this.mediaTypes_.AUDIO.activePlaylistLoader) { if (i = this.mediaTypes_.AUDIO.activePlaylistLoader.media(), null === (o = this.syncController_.getExpiredTime(i, this.mediaSource.duration))) return; if (0 === (e = hd.Playlist.seekable(i, o)).length) return } e ? e.start(0) > t.end(0) || t.start(0) > e.end(0) ? this.seekable_ = t : this.seekable_ = Nt.createTimeRanges([
                                        [e.start(0) > t.start(0) ? e.start(0) : t.start(0), e.end(0) < t.end(0) ? e.end(0) : t.end(0)]
                                    ]) : this.seekable_ = t, this.logger_("seekable updated [" + Zl(this.seekable_) + "]"), this.tech_.trigger("seekablechanged") } } } } }, { key: "updateDuration", value: function() { var t = this,
                            e = this.mediaSource.duration,
                            i = hd.Playlist.duration(this.masterPlaylistLoader_.media()),
                            o = this.tech_.buffered(),
                            n = function e() { t.mediaSource.duration = i, t.tech_.trigger("durationchange"), t.mediaSource.removeEventListener("sourceopen", e) };
                        0 < o.length && (i = Math.max(i, o.end(o.length - 1))), e !== i && ("open" !== this.mediaSource.readyState ? this.mediaSource.addEventListener("sourceopen", n) : n()) } }, { key: "dispose", value: function() { var t = this;
                        this.decrypter_.terminate(), this.masterPlaylistLoader_.dispose(), this.mainSegmentLoader_.dispose(), ["AUDIO", "SUBTITLES"].forEach(function(e) { var i = t.mediaTypes_[e].groups; for (var o in i) i[o].forEach(function(t) { t.playlistLoader && t.playlistLoader.dispose() }) }), this.audioSegmentLoader_.dispose(), this.subtitleSegmentLoader_.dispose() } }, { key: "master", value: function() { return this.masterPlaylistLoader_.master } }, { key: "media", value: function() { return this.masterPlaylistLoader_.media() || this.initialMedia_ } }, { key: "setupSourceBuffers_", value: function() { var t, e = this.masterPlaylistLoader_.media(); if (e && "open" === this.mediaSource.readyState) { if ((t = yc(this.masterPlaylistLoader_.master, e)).length < 1) return this.error = "No compatible SourceBuffer configuration for the variant stream:" + e.resolvedUri, this.mediaSource.endOfStream("decode");
                            this.configureLoaderMimeTypes_(t), this.excludeIncompatibleVariants_(e) } } }, { key: "configureLoaderMimeTypes_", value: function(t) { var e = 1 < t.length && -1 === t[0].indexOf(",") && t[0] !== t[1] ? new Nt.EventTarget : null;
                        this.mainSegmentLoader_.mimeType(t[0], e), t[1] && this.audioSegmentLoader_.mimeType(t[1], e) } }, { key: "excludeUnsupportedVariants_", value: function() { this.master().playlists.forEach(function(t) { t.attributes.CODECS && e.MediaSource && e.MediaSource.isTypeSupported && !e.MediaSource.isTypeSupported('video/mp4; codecs="' + t.attributes.CODECS.replace(/avc1\.(\d+)\.(\d+)/i, function(t) { return pc([t])[0] }) + '"') && (t.excludeUntil = 1 / 0) }) } }, { key: "excludeIncompatibleVariants_", value: function(t) { var e = 2,
                            i = null,
                            o = void 0;
                        t.attributes.CODECS && (o = mc(t.attributes.CODECS), i = o.videoCodec, e = o.codecCount), this.master().playlists.forEach(function(t) { var o = { codecCount: 2, videoCodec: null };
                            t.attributes.CODECS && (o = mc(t.attributes.CODECS)), o.codecCount !== e && (t.excludeUntil = 1 / 0), o.videoCodec !== i && (t.excludeUntil = 1 / 0) }) } }, { key: "updateAdCues_", value: function(t) { var i = 0,
                            o = this.seekable();
                        o.length && (i = o.start(0)),
                            function(t, i) { var o = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 0; if (t.segments)
                                    for (var n = o, s = void 0, r = 0; r < t.segments.length; r++) { var a = t.segments[r]; if (s || (s = qc(i, n + a.duration / 2)), s) { if ("cueIn" in a) { s.endTime = n, s.adEndTime = n, n += a.duration, s = null; continue } if (n < s.endTime) { n += a.duration; continue } s.endTime += a.duration } else if ("cueOut" in a && ((s = new e.VTTCue(n, n + a.duration, a.cueOut)).adStartTime = n, s.adEndTime = n + parseFloat(a.cueOut), i.addCue(s)), "cueOutCont" in a) { var h, l, c = a.cueOutCont.split("/").map(parseFloat),
                                                d = hl(c, 2);
                                            h = d[0], l = d[1], (s = new e.VTTCue(n, n + a.duration, "")).adStartTime = n - h, s.adEndTime = s.adStartTime + l, i.addCue(s) } n += a.duration } }(t, this.cueTagsTrack_, i) } }, { key: "goalBufferLength", value: function() { var t = this.tech_.currentTime(),
                            e = Ic.GOAL_BUFFER_LENGTH,
                            i = Ic.GOAL_BUFFER_LENGTH_RATE,
                            o = Math.max(e, Ic.MAX_GOAL_BUFFER_LENGTH); return Math.min(e + t * i, o) } }, { key: "bufferLowWaterLine", value: function() { var t = this.tech_.currentTime(),
                            e = Ic.BUFFER_LOW_WATER_LINE,
                            i = Ic.BUFFER_LOW_WATER_LINE_RATE,
                            o = Math.max(e, Ic.MAX_BUFFER_LOW_WATER_LINE); return Math.min(e + t * i, o) } }]), i }(),
            dd = function t(e, i, o) { nl(this, t); var n, s, r, a = e.masterPlaylistController_,
                    h = a[(e.options_.smoothQualityChange ? "smooth" : "fast") + "QualityChange_"].bind(a); if (i.attributes.RESOLUTION) { var l = i.attributes.RESOLUTION;
                    this.width = l.width, this.height = l.height } this.bandwidth = i.attributes.BANDWIDTH, this.id = o, this.enabled = (n = e.playlists, s = i.uri, r = h, function(t) { var e = n.master.playlists[s],
                        i = Ml(e),
                        o = El(e); return void 0 === t ? o : (t ? delete e.disabled : e.disabled = !0, t === o || i || (r(), t ? n.trigger("renditionenabled") : n.trigger("renditiondisabled")), t) }) },
            ud = ["seeking", "seeked", "pause", "playing", "error"],
            pd = function() {
                function t(i) { var o = this;
                    nl(this, t), this.tech_ = i.tech, this.seekable = i.seekable, this.seekTo = i.seekTo, this.consecutiveUpdates = 0, this.lastRecordedTime = null, this.timer_ = null, this.checkCurrentTimeTimeout_ = null, this.logger_ = Ec("PlaybackWatcher"), this.logger_("initialize"); var n = function() { return o.monitorCurrentTime_() },
                        s = function() { return o.techWaiting_() },
                        r = function() { return o.cancelTimer_() },
                        a = function() { return o.fixesBadSeeks_() };
                    this.tech_.on("seekablechanged", a), this.tech_.on("waiting", s), this.tech_.on(ud, r), this.tech_.on("canplay", n), this.dispose = function() { o.logger_("dispose"), o.tech_.off("seekablechanged", a), o.tech_.off("waiting", s), o.tech_.off(ud, r), o.tech_.off("canplay", n), o.checkCurrentTimeTimeout_ && e.clearTimeout(o.checkCurrentTimeTimeout_), o.cancelTimer_() } } return sl(t, [{ key: "monitorCurrentTime_", value: function() { this.checkCurrentTime_(), this.checkCurrentTimeTimeout_ && e.clearTimeout(this.checkCurrentTimeTimeout_), this.checkCurrentTimeTimeout_ = e.setTimeout(this.monitorCurrentTime_.bind(this), 250) } }, { key: "checkCurrentTime_", value: function() { if (this.tech_.seeking() && this.fixesBadSeeks_()) return this.consecutiveUpdates = 0, void(this.lastRecordedTime = this.tech_.currentTime()); if (!this.tech_.paused() && !this.tech_.seeking()) { var t = this.tech_.currentTime(),
                                e = this.tech_.buffered(); if (this.lastRecordedTime === t && (!e.length || t + .1 >= e.end(e.length - 1))) return this.techWaiting_();
                            5 <= this.consecutiveUpdates && t === this.lastRecordedTime ? (this.consecutiveUpdates++, this.waiting_()) : t === this.lastRecordedTime ? this.consecutiveUpdates++ : (this.consecutiveUpdates = 0, this.lastRecordedTime = t) } } }, { key: "cancelTimer_", value: function() { this.consecutiveUpdates = 0, this.timer_ && (this.logger_("cancelTimer_"), clearTimeout(this.timer_)), this.timer_ = null } }, { key: "fixesBadSeeks_", value: function() { var t = this.tech_.seeking(),
                            e = this.seekable(),
                            i = this.tech_.currentTime(),
                            o = void 0; return t && this.afterSeekableWindow_(e, i) && (o = e.end(e.length - 1)), t && this.beforeSeekableWindow_(e, i) && (o = e.start(0) + .1), void 0 !== o && (this.logger_("Trying to seek outside of seekable at time " + i + " with seekable range " + Zl(e) + ". Seeking to " + o + "."), this.seekTo(o), !0) } }, { key: "waiting_", value: function() { if (!this.techWaiting_()) { var t = this.tech_.currentTime(),
                                e = this.tech_.buffered(),
                                i = Yl(e, t); return i.length && t + 3 <= i.end(0) ? (this.cancelTimer_(), this.seekTo(t), this.logger_("Stopped at " + t + " while inside a buffered region [" + i.start(0) + " -> " + i.end(0) + "]. Attempting to resume playback by seeking to the current time."), void this.tech_.trigger({ type: "usage", name: "hls-unknown-waiting" })) : void 0 } } }, { key: "techWaiting_", value: function() { var t = this.seekable(),
                            e = this.tech_.currentTime(); if (this.tech_.seeking() && this.fixesBadSeeks_()) return !0; if (this.tech_.seeking() || null !== this.timer_) return !0; if (this.beforeSeekableWindow_(t, e)) { var i = t.end(t.length - 1); return this.logger_("Fell out of live window at time " + e + ". Seeking to live point (seekable end) " + i), this.cancelTimer_(), this.seekTo(i), this.tech_.trigger({ type: "usage", name: "hls-live-resync" }), !0 } var o = this.tech_.buffered(),
                            n = Kl(o, e); if (this.videoUnderflow_(n, o, e)) return this.cancelTimer_(), this.seekTo(e), this.tech_.trigger({ type: "usage", name: "hls-video-underflow" }), !0; if (0 < n.length) { var s = n.start(0) - e; return this.logger_("Stopped at " + e + ", setting timer for " + s + ", seeking to " + n.start(0)), this.timer_ = setTimeout(this.skipTheGap_.bind(this), 1e3 * s, e), !0 } return !1 } }, { key: "afterSeekableWindow_", value: function(t, e) { return !!t.length && e > t.end(t.length - 1) + .1 } }, { key: "beforeSeekableWindow_", value: function(t, e) { return !!(t.length && 0 < t.start(0) && e < t.start(0) - .1) } }, { key: "videoUnderflow_", value: function(t, e, i) { if (0 === t.length) { var o = this.gapFromVideoUnderflow_(e, i); if (o) return this.logger_("Encountered a gap in video from " + o.start + " to " + o.end + ". Seeking to current time " + i), !0 } return !1 } }, { key: "skipTheGap_", value: function(t) { var e = this.tech_.buffered(),
                            i = this.tech_.currentTime(),
                            o = Kl(e, i);
                        this.cancelTimer_(), 0 !== o.length && i === t && (this.logger_("skipTheGap_:", "currentTime:", i, "scheduled currentTime:", t, "nextRange start:", o.start(0)), this.seekTo(o.start(0) + Jl), this.tech_.trigger({ type: "usage", name: "hls-gap-skip" })) } }, { key: "gapFromVideoUnderflow_", value: function(t, e) { for (var i = function(t) { if (t.length < 2) return Nt.createTimeRanges(); for (var e = [], i = 1; i < t.length; i++) { var o = t.end(i - 1),
                                        n = t.start(i);
                                    e.push([o, n]) } return Nt.createTimeRanges(e) }(t), o = 0; o < i.length; o++) { var n = i.start(o),
                                s = i.end(o); if (e - n < 4 && 2 < e - n) return { start: n, end: s } } return null } }]), t }(),
            md = { errorInterval: 30, getSource: function(t) { return t(this.tech({ IWillNotUseThisInPlugins: !0 }).currentSource_) } },
            fd = function(t) {! function t(e, i) { var o = 0,
                        n = 0,
                        s = Nt.mergeOptions(md, i);
                    e.ready(function() { e.trigger({ type: "usage", name: "hls-error-reload-initialized" }) }); var r = function() { n && e.currentTime(n) },
                        a = function(t) { null != t && (n = e.duration() !== 1 / 0 && e.currentTime() || 0, e.one("loadedmetadata", r), e.src(t), e.trigger({ type: "usage", name: "hls-error-reload" }), e.play()) },
                        h = function() { if (Date.now() - o < 1e3 * s.errorInterval) e.trigger({ type: "usage", name: "hls-error-reload-canceled" });
                            else { if (s.getSource && "function" == typeof s.getSource) return o = Date.now(), s.getSource.call(e, a);
                                Nt.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!") } },
                        l = function t() { e.off("loadedmetadata", r), e.off("error", h), e.off("dispose", t) };
                    e.on("error", h), e.on("dispose", l), e.reloadSourceOnError = function(i) { l(), t(e, i) } }(this, t) };
        Nt.use("*", function(t) { return { setSource: function(t, e) { e(null, t) }, setCurrentTime: function(e) { return t.vhs && t.currentSource().src === t.vhs.source_.src && t.vhs.setCurrentTime(e), e }, play: function() { t.vhs && t.currentSource().src === t.vhs.source_.src && t.vhs.setCurrentTime(t.currentTime()) } } }); var yd = { PlaylistLoader: bl, Playlist: Dl, Decrypter: il, AsyncStream: $h, decrypt: el, utils: jl, STANDARD_PLAYLIST_SELECTOR: function() { return function(t, i, o, n, s) { var r = t.playlists.map(function(t) { var i, o; return i = t.attributes.RESOLUTION && t.attributes.RESOLUTION.width, o = t.attributes.RESOLUTION && t.attributes.RESOLUTION.height, { bandwidth: t.attributes.BANDWIDTH || e.Number.MAX_VALUE, width: i, height: o, playlist: t } });
                    Uc(r, function(t, e) { return t.bandwidth - e.bandwidth }); var a = (r = r.filter(function(t) { return !Dl.isIncompatible(t.playlist) })).filter(function(t) { return Dl.isEnabled(t.playlist) });
                    a.length || (a = r.filter(function(t) { return !Dl.isDisabled(t.playlist) })); var h = a.filter(function(t) { return t.bandwidth * Ic.BANDWIDTH_VARIANCE < i }),
                        l = h[h.length - 1],
                        c = h.filter(function(t) { return t.bandwidth === l.bandwidth })[0]; if (!1 === s) { var d = c || a[0] || r[0]; return d ? d.playlist : null } var u = h.filter(function(t) { return t.width && t.height });
                    Uc(u, function(t, e) { return t.width - e.width }); var p = u.filter(function(t) { return t.width === o && t.height === n });
                    l = p[p.length - 1]; var m = p.filter(function(t) { return t.bandwidth === l.bandwidth })[0],
                        f = void 0,
                        y = void 0,
                        b = void 0;
                    m || (y = (f = u.filter(function(t) { return t.width > o || t.height > n })).filter(function(t) { return t.width === f[0].width && t.height === f[0].height }), l = y[y.length - 1], b = y.filter(function(t) { return t.bandwidth === l.bandwidth })[0]); var g = b || m || c || a[0] || r[0]; return g ? g.playlist : null }(this.playlists.master, this.systemBandwidth, parseInt(Gc(this.tech_.el(), "width"), 10), parseInt(Gc(this.tech_.el(), "height"), 10), this.limitRenditionByPlayerDimensions) }, INITIAL_PLAYLIST_SELECTOR: function() { var t = this.playlists.master.playlists.filter(Dl.isEnabled); return Uc(t, function(t, e) { return Nc(t, e) }), t.filter(function(t) { return mc(t.attributes.CODECS).videoCodec })[0] || null }, comparePlaylistBandwidth: Nc, comparePlaylistResolution: function(t, i) { var o = void 0,
                    n = void 0; return t.attributes.RESOLUTION && t.attributes.RESOLUTION.width && (o = t.attributes.RESOLUTION.width), o = o || e.Number.MAX_VALUE, i.attributes.RESOLUTION && i.attributes.RESOLUTION.width && (n = i.attributes.RESOLUTION.width), o === (n = n || e.Number.MAX_VALUE) && t.attributes.BANDWIDTH && i.attributes.BANDWIDTH ? t.attributes.BANDWIDTH - i.attributes.BANDWIDTH : o - n }, xhr: Rl() };
        ["GOAL_BUFFER_LENGTH", "MAX_GOAL_BUFFER_LENGTH", "GOAL_BUFFER_LENGTH_RATE", "BUFFER_LOW_WATER_LINE", "MAX_BUFFER_LOW_WATER_LINE", "BUFFER_LOW_WATER_LINE_RATE", "BANDWIDTH_VARIANCE"].forEach(function(t) { Object.defineProperty(yd, t, { get: function() { return Nt.log.warn("using Hls." + t + " is UNSAFE be sure you know what you are doing"), Ic[t] }, set: function(e) { Nt.log.warn("using Hls." + t + " is UNSAFE be sure you know what you are doing"), "number" != typeof e || e < 0 ? Nt.log.warn("value of Hls." + t + " must be greater than or equal to 0") : Ic[t] = e } }) }); var bd = "videojs-vhs",
            gd = function(t) { return /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i.test(t) ? "hls" : /^application\/dash\+xml/i.test(t) ? "dash" : null },
            _d = function(t, e) { for (var i = e.media(), o = -1, n = 0; n < t.length; n++)
                    if (t[n].id === i.uri) { o = n; break } t.selectedIndex_ = o, t.trigger({ selectedIndex: o, type: "change" }) };
        yd.canPlaySource = function() { return Nt.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.") }; var vd = function(t) { if ("dash" === t.options_.sourceType) { var e = Nt.players[t.tech_.options_.playerId]; if (e.eme) { var i = function(t, e, i) { if (!t) return t; var o = {}; for (var n in t) o[n] = { audioContentType: 'audio/mp4; codecs="' + i.attributes.CODECS + '"', videoContentType: 'video/mp4; codecs="' + e.attributes.CODECS + '"' }, e.contentProtection && e.contentProtection[n] && e.contentProtection[n].pssh && (o[n].pssh = e.contentProtection[n].pssh), "string" == typeof t[n] && (o[n].url = t[n]); return Nt.mergeOptions(t, o) }(t.source_.keySystems, t.playlists.media(), t.masterPlaylistController_.mediaTypes_.AUDIO.activePlaylistLoader.media());
                        i && (e.currentSource().keySystems = i, e.eme.initializeMediaKeys && e.eme.initializeMediaKeys()) } } },
            xd = function() { if (!window.localStorage) return null; var t = window.localStorage.getItem(bd); if (!t) return null; try { return JSON.parse(t) } catch (t) { return null } };
        yd.supportsNativeHls = function() { var e = t.createElement("video"); return !!Nt.getTech("Html5").isSupported() && ["application/vnd.apple.mpegurl", "audio/mpegurl", "audio/x-mpegurl", "application/x-mpegurl", "video/x-mpegurl", "video/mpegurl", "application/mpegurl"].some(function(t) { return /maybe|probably/i.test(e.canPlayType(t)) }) }(), yd.supportsNativeDash = !!Nt.getTech("Html5").isSupported() && /maybe|probably/i.test(t.createElement("video").canPlayType("application/dash+xml")), yd.supportsTypeNatively = function(t) { return "hls" === t ? yd.supportsNativeHls : "dash" === t && yd.supportsNativeDash }, yd.isSupported = function() { return Nt.log.warn("HLS is no longer a tech. Please remove it from your player's techOrder.") }; var Sd = Nt.getComponent("Component"),
            Cd = function(e) {
                function i(e, o, n) { nl(this, i); var s = al(this, (i.__proto__ || Object.getPrototypeOf(i)).call(this, o, n.hls)); if (o.options_ && o.options_.playerId) { var r = Nt(o.options_.playerId);
                        r.hasOwnProperty("hls") || Object.defineProperty(r, "hls", { get: function() { return Nt.log.warn("player.hls is deprecated. Use player.tech().hls instead."), o.trigger({ type: "usage", name: "hls-player-access" }), s }, configurable: !0 }), r.vhs = s, (r.dash = s).player_ = r } if (s.tech_ = o, s.source_ = e, s.stats = {}, s.setOptions_(), s.options_.overrideNative && o.overrideNativeAudioTracks && o.overrideNativeVideoTracks) o.overrideNativeAudioTracks(!0), o.overrideNativeVideoTracks(!0);
                    else if (s.options_.overrideNative && (o.featuresNativeVideoTracks || o.featuresNativeAudioTracks)) throw new Error("Overriding native HLS requires emulated tracks. See https://git.io/vMpjB"); return s.on(t, ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], function(e) { var i = t.fullscreenElement || t.webkitFullscreenElement || t.mozFullScreenElement || t.msFullscreenElement;
                        i && i.contains(s.tech_.el()) && s.masterPlaylistController_.smoothQualityChange_() }), s.on(s.tech_, "seeking", function() { this.tech_.seeking() && 0 === this.tech_.currentTime() && this.tech_.player_.loop() && this.setCurrentTime(0) }), s.on(s.tech_, "error", function() { this.masterPlaylistController_ && this.masterPlaylistController_.pauseLoading() }), s.on(s.tech_, "play", s.play), s } return rl(i, Sd), sl(i, [{ key: "setOptions_", value: function() { var t = this; if (this.options_.withCredentials = this.options_.withCredentials || !1, this.options_.limitRenditionByPlayerDimensions = !1 !== this.options_.limitRenditionByPlayerDimensions, this.options_.smoothQualityChange = this.options_.smoothQualityChange || !1, this.options_.useBandwidthFromLocalStorage = void 0 !== this.source_.useBandwidthFromLocalStorage ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || !1, "number" != typeof this.options_.blacklistDuration && (this.options_.blacklistDuration = 300), "number" != typeof this.options_.bandwidth && this.options_.useBandwidthFromLocalStorage) { var e = xd();
                            e && e.bandwidth && (this.options_.bandwidth = e.bandwidth, this.tech_.trigger({ type: "usage", name: "hls-bandwidth-from-local-storage" })), e && e.throughput && (this.options_.throughput = e.throughput, this.tech_.trigger({ type: "usage", name: "hls-throughput-from-local-storage" })) } "number" != typeof this.options_.bandwidth && (this.options_.bandwidth = Ic.INITIAL_BANDWIDTH), this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Ic.INITIAL_BANDWIDTH, ["withCredentials", "limitRenditionByPlayerDimensions", "bandwidth", "smoothQualityChange"].forEach(function(e) { void 0 !== t.source_[e] && (t.options_[e] = t.source_[e]) }), this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions } }, { key: "src", value: function(t, e) { var i = this;
                        t && (this.setOptions_(), this.options_.url = this.source_.src, this.options_.tech = this.tech_, this.options_.externHls = yd, this.options_.sourceType = gd(e), this.options_.seekTo = function(t) { i.tech_.setCurrentTime(t), i.setCurrentTime(t) }, this.masterPlaylistController_ = new cd(this.options_), this.playbackWatcher_ = new pd(Nt.mergeOptions(this.options_, { seekable: function() { return i.seekable() } })), this.masterPlaylistController_.on("error", function() { Nt.players[i.tech_.options_.playerId].error(i.masterPlaylistController_.error) }), this.masterPlaylistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : yd.STANDARD_PLAYLIST_SELECTOR.bind(this), this.masterPlaylistController_.selectInitialPlaylist = yd.INITIAL_PLAYLIST_SELECTOR.bind(this), this.playlists = this.masterPlaylistController_.masterPlaylistLoader_, this.mediaSource = this.masterPlaylistController_.mediaSource, Object.defineProperties(this, { selectPlaylist: { get: function() { return this.masterPlaylistController_.selectPlaylist }, set: function(t) { this.masterPlaylistController_.selectPlaylist = t.bind(this) } }, throughput: { get: function() { return this.masterPlaylistController_.mainSegmentLoader_.throughput.rate }, set: function(t) { this.masterPlaylistController_.mainSegmentLoader_.throughput.rate = t, this.masterPlaylistController_.mainSegmentLoader_.throughput.count = 1 } }, bandwidth: { get: function() { return this.masterPlaylistController_.mainSegmentLoader_.bandwidth }, set: function(t) { this.masterPlaylistController_.mainSegmentLoader_.bandwidth = t, this.masterPlaylistController_.mainSegmentLoader_.throughput = { rate: 0, count: 0 } } }, systemBandwidth: { get: function() { var t = 1 / (this.bandwidth || 1),
                                        e = void 0; return e = 0 < this.throughput ? 1 / this.throughput : 0, Math.floor(1 / (t + e)) }, set: function() { Nt.log.error('The "systemBandwidth" property is read-only') } } }), this.options_.bandwidth && (this.bandwidth = this.options_.bandwidth), this.options_.throughput && (this.throughput = this.options_.throughput), Object.defineProperties(this.stats, { bandwidth: { get: function() { return i.bandwidth || 0 }, enumerable: !0 }, mediaRequests: { get: function() { return i.masterPlaylistController_.mediaRequests_() || 0 }, enumerable: !0 }, mediaRequestsAborted: { get: function() { return i.masterPlaylistController_.mediaRequestsAborted_() || 0 }, enumerable: !0 }, mediaRequestsTimedout: { get: function() { return i.masterPlaylistController_.mediaRequestsTimedout_() || 0 }, enumerable: !0 }, mediaRequestsErrored: { get: function() { return i.masterPlaylistController_.mediaRequestsErrored_() || 0 }, enumerable: !0 }, mediaTransferDuration: { get: function() { return i.masterPlaylistController_.mediaTransferDuration_() || 0 }, enumerable: !0 }, mediaBytesTransferred: { get: function() { return i.masterPlaylistController_.mediaBytesTransferred_() || 0 }, enumerable: !0 }, mediaSecondsLoaded: { get: function() { return i.masterPlaylistController_.mediaSecondsLoaded_() || 0 }, enumerable: !0 }, buffered: { get: function() { return Ql(i.tech_.buffered()) }, enumerable: !0 }, currentTime: { get: function() { return i.tech_.currentTime() }, enumerable: !0 }, currentSource: { get: function() { return i.tech_.currentSource_ }, enumerable: !0 }, currentTech: { get: function() { return i.tech_.name_ }, enumerable: !0 }, duration: { get: function() { return i.tech_.duration() }, enumerable: !0 }, master: { get: function() { return i.playlists.master }, enumerable: !0 }, playerDimensions: { get: function() { return i.tech_.currentDimensions() }, enumerable: !0 }, seekable: { get: function() { return Ql(i.tech_.seekable()) }, enumerable: !0 }, timestamp: { get: function() { return Date.now() }, enumerable: !0 }, videoPlaybackQuality: { get: function() { return i.tech_.getVideoPlaybackQuality() }, enumerable: !0 } }), this.tech_.one("canplay", this.masterPlaylistController_.setupFirstPlay.bind(this.masterPlaylistController_)), this.tech_.on("bandwidthupdate", function() { i.options_.useBandwidthFromLocalStorage && function(t) { if (window.localStorage) { var e = xd();
                                    e = e ? Nt.mergeOptions(e, t) : t; try { window.localStorage.setItem(bd, JSON.stringify(e)) } catch (t) { return } } }({ bandwidth: i.bandwidth, throughput: Math.round(i.throughput) }) }), this.masterPlaylistController_.on("selectedinitialmedia", function() { var t, e;
                            e = (t = i).playlists, t.representations = function() { return e.master.playlists.filter(function(t) { return !Ml(t) }).map(function(e, i) { return new dd(t, e, e.uri) }) }, vd(i) }), this.on(this.masterPlaylistController_, "progress", function() { this.tech_.trigger("progress") }), this.tech_.ready(function() { return i.setupQualityLevels_() }), this.tech_.el() && this.tech_.src(Nt.URL.createObjectURL(this.masterPlaylistController_.mediaSource))) } }, { key: "setupQualityLevels_", value: function() { var t = this,
                            e = Nt.players[this.tech_.options_.playerId];
                        e && e.qualityLevels && (this.qualityLevels_ = e.qualityLevels(), this.masterPlaylistController_.on("selectedinitialmedia", function() { var e, i;
                            e = t.qualityLevels_, (i = t).representations().forEach(function(t) { e.addQualityLevel(t) }), _d(e, i.playlists) }), this.playlists.on("mediachange", function() { _d(t.qualityLevels_, t.playlists) })) } }, { key: "play", value: function() { this.masterPlaylistController_.play() } }, { key: "setCurrentTime", value: function(t) { this.masterPlaylistController_.setCurrentTime(t) } }, { key: "duration", value: function() { return this.masterPlaylistController_.duration() } }, { key: "seekable", value: function() { return this.masterPlaylistController_.seekable() } }, { key: "dispose", value: function() { this.playbackWatcher_ && this.playbackWatcher_.dispose(), this.masterPlaylistController_ && this.masterPlaylistController_.dispose(), this.qualityLevels_ && this.qualityLevels_.dispose(), this.player_ && (delete this.player_.vhs, delete this.player_.dash, delete this.player_.hls), this.tech_ && this.tech_.hls && delete this.tech_.hls,
                            function t(e, i, o) { null === e && (e = Function.prototype); var n = Object.getOwnPropertyDescriptor(e, i); if (void 0 === n) { var s = Object.getPrototypeOf(e); return null === s ? void 0 : t(s, i, o) } if ("value" in n) return n.value; var r = n.get; return void 0 !== r ? r.call(o) : void 0 }(i.prototype.__proto__ || Object.getPrototypeOf(i.prototype), "dispose", this).call(this) } }, { key: "convertToStreamTime", value: function(t, e) { return Hl({ playlist: this.masterPlaylistController_.media(), time: t, callback: e }) } }, { key: "seekToStreamTime", value: function(t, e) { var i = !(2 < arguments.length && void 0 !== arguments[2]) || arguments[2],
                            o = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 2; return zl({ streamTime: t, playlist: this.masterPlaylistController_.media(), retryCount: o, pauseAfterSeek: i, seekTo: this.options_.seekTo, tech: this.options_.tech, callback: e }) } }]), i }(),
            wd = { name: "videojs-http-streaming", VERSION: "1.5.1", canHandleSource: function(t) { var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
                        i = Nt.mergeOptions(Nt.options, e); return wd.canPlayType(t.type, i) }, handleSource: function(t, e) { var i = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : {},
                        o = Nt.mergeOptions(Nt.options, i); return e.hls = new Cd(t, e, o), e.hls.xhr = Rl(), e.hls.src(t.src, t.type), e.hls }, canPlayType: function(t) { var e = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {},
                        i = Nt.mergeOptions(Nt.options, e).hls.overrideNative,
                        o = gd(t); return !o || yd.supportsTypeNatively(o) && !i ? "" : "maybe" } }; return void 0 !== Nt.MediaSource && void 0 !== Nt.URL || (Nt.MediaSource = wc, Nt.URL = Ac), wc.supportsNativeMediaSources() && Nt.getTech("Html5").registerSourceHandler(wd, 0), Nt.HlsHandler = Cd, Nt.HlsSourceHandler = wd, Nt.Hls = yd, Nt.use || Nt.registerComponent("Hls", yd), Nt.options.hls = Nt.options.hls || {}, Nt.registerPlugin ? Nt.registerPlugin("reloadSourceOnError", fd) : Nt.plugin("reloadSourceOnError", fd), Nt });
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i() { return e.call(this) || this } return __extends(i, e), i.prototype.init = function() { var t = this; if (this.game.scale.fullScreenTarget = document.getElementById("game"), this.game.input.maxPointers = 1, this.game.renderer.renderSession.roundPixels = !0, this.game.storage.setNamespace(Constants.STORAGE_NAMESPACE), this.game.canvas.oncontextmenu = function(t) { t.preventDefault() }, this.game.device.desktop) this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL, this.scale.pageAlignHorizontally = !0, this.game.scale.windowConstraints.bottom = "visual";
            else { this.scale.scaleMode = Phaser.ScaleManager.USER_SCALE, this.scale.fullScreenScaleMode = Phaser.ScaleManager.USER_SCALE, window.addEventListener("resize", function(e) { return i.mobileResizeCallback(t.game.scale) }), this.game.state.onStateChange.add(function() { return i.initFullScreenListener(t.game) }), this.game.scale.onSizeChange.add(function() { return i.sizeChange(t.game) }, this), i.mobileResizeCallback(this.game.scale), i.setScaling(this.game); var e = navigator.userAgent,
                    o = !1,
                    n = !1; /iPod|iPhone/i.test(e) && (navigator.appVersion.match(/OS (\d+)/), /AppleWebKit/.test(e) && (n = !0), o = !0), o && n && (this.iosTimer = setInterval(function() { window.scrollTo(1, 1) }, 1e3)) } }, i.sizeChange = function(t) { t.ph2UIManager.events.onGameResize(Constants.CALCULATED_WIDTH, Constants.CALCULATED_HEIGHT), t.state.getCurrentState().resize() }, i.initFullScreenListener = function(t) { t.input.onTap.add(function() { return i.startFullScreen(t) }) }, i.startFullScreen = function(t) { Constants.AUTO_FULLSCREEN_ENABLED && t.device.android && (t.scale.isFullScreen || t.scale.startFullScreen(!1)) }, i.stopFullScreen = function(t) { Constants.AUTO_FULLSCREEN_ENABLED && t.device.android && t.scale.isFullScreen && t.scale.stopFullScreen() }, i.mobileResizeCallback = function(t) { var e = window.innerWidth,
                o = window.innerHeight,
                n = Constants.GAME_WIDTH * Constants.GAME_SCALE,
                s = Constants.GAME_HEIGHT * Constants.GAME_SCALE,
                r = 1;
            r /= e > o ? o / s : o / n, Constants.LANDSCAPE_LOCKED ? e > o ? i.handleCorrect() : i.handleIncorrect() : Constants.PORTRAIT_LOCKED && (e < o ? i.handleCorrect() : i.handleIncorrect()), t.game.state.getCurrentState().resize(), Constants.CALCULATED_WIDTH = Math.ceil(e * r), Constants.CALCULATED_HEIGHT = Math.ceil(o * r), t.game.ph2UIManager.events.onGameResize(Constants.CALCULATED_WIDTH, Constants.CALCULATED_HEIGHT), t.setGameSize(Constants.CALCULATED_WIDTH, Constants.CALCULATED_HEIGHT), t.setUserScale(1 / r, 1 / r) }, i.setScaling = function(t) { Constants.GAME_SCALE = 1 }, i.handleCorrect = function() { document.getElementById("orientation").style.display = "none", document.getElementById("game").style.display = "block", t.Instances.IncorrectOrientation = !1 }, i.handleIncorrect = function() { document.getElementById("orientation").style.display = "block", document.getElementById("game").style.display = "none", t.Instances.IncorrectOrientation = !0 }, i.prototype.create = function() { this.loadWebFont(), this.game.state.start("preloaderState") }, i.prototype.loadWebFont = function() { var t = this,
                e = function() { t.recursiveUpdateText(t.stage) };
            WebFont.load({ custom: { families: ["Bonk", "LubalinGraphITCTurnerAra-Bd", "LubalinGraphITCTurner"], urls: ["assets/fonts/Bonk.css", "assets/fonts/LubalinGraphITCTurnerAra/LubalinGraphITCTurnerAra-Bd.css", "assets/fonts/LubalinGraphITCTurner/LubalinGraphITCTurner-Bold.css"] }, active: e, inactive: e }) }, i.prototype.recursiveUpdateText = function(t) { var e = this;
            t instanceof Phaser.Text && (t.dirty = !0), t.children && t.children.length > 0 && t.children.forEach(function(t) { e.recursiveUpdateText(t) }) }, i.prototype.preload = function() { this.game.load.cacheBuster = "undefined" == typeof version ? null : version, this.game.load.json("resources", "./resources.json"), this.game.load.json("audiosprite", "assets/audio/audiosprite.json"), this.game.load.atlas("load_cn", "assets/atlases/load_cn.png", "assets/atlases/load_cn.json"), this.game.load.image("fg_logo", "assets/images/fg_logo.png") }, i }(Phaser.State);
    t.BootState = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i() { return e.call(this) || this } return __extends(i, e), i.prototype.preload = function() {-1 === t.Instances.pathLoads.indexOf("comic") && (t.Instances.pathLoads.push("comic"), this.game.ph2Loader.load("comic")) }, i.prototype.init = function(t, e) { void 0 === t && (t = !0), void 0 === e && (e = 1), this.game.world.removeAll(), this.isIntro = t, this.outroNum = e }, i.prototype.create = function() { var e = this;
            this.bgMusic = t.MusicID.MENU, this.bg = this.game.add.image(0, 0, "comic_map_bg"), this.comicUi = new t.UIComicIntro(this, this.isIntro, this.outroNum), this.mainGroup = this.game.add.group(), this.mainGroup.add(this.bg), this.mainGroup.add(this.comicUi), this.game.ph2AudioManager.getMusicEnabled() && t.Audios.playMusic(this.game, this.bgMusic), t.Instances.transition.playOut().addOnce(function() { e.comicUi.playIntro() }, this), this.resize() }, i.prototype.onPressPlay = function() { t.Instances.transition.playIn().addOnce(this._transitionComic, this) }, i.prototype._transitionComic = function() { this.isIntro ? this.game.state.start("levelselectState", !0, !1, 0) : this.game.state.start("mainmenuState", !0, !1) }, i.prototype.resize = function() { this.bg.width = this.game.width, this.bg.height = this.game.height, this.comicUi.resize() }, i.prototype.shutdown = function() { e.prototype.shutdown.call(this) }, i }(Phaser.State);
    t.ComicState = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i() { var i = e.call(this) || this; return i.grabingScreen = !1, i.timestamp = 0, i.phyElapsed = 0, t.Instances.isGameplayActive = !1, i } return __extends(i, e), i.prototype.preload = function() { var e = []; - 1 === t.Instances.pathLoads.indexOf("gameplay") && (t.Instances.pathLoads.push("gameplay"), e.push("gameplay")), -1 === t.Instances.pathLoads.indexOf(this.lvJsonName) && (t.Instances.pathLoads.push(this.lvJsonName), e.push(this.lvJsonName)), this.game.cache.getJSON("resources").hasOwnProperty(this.lvJsonName) || -1 === t.Instances.pathLoads.indexOf("randomLevel") && (t.Instances.pathLoads.push("randomLevel"), e.push("randomLevel")), e.length > 0 && this.game.ph2Loader.load(e) }, i.prototype.init = function(t, e, i, o) { void 0 === i && (i = !1), void 0 === o && (o = !1), this.game.world.removeAll(), this.lastPointerPosition = new Phaser.Point, this.lvJsonName = e, this.isStateEnable = !1, this.isPauseEnable = !1, this.playBeginning = t, this.fromAbove = i, this.fromRetry = o, this.joystickUI = null, this.finishUi = null, this.gameoverUi = null, this.confirmationUi = null, this.settingsUi = null, this.tutorialUi = null, this.game.onBlur.add(this.onBlur, this) }, i.prototype.enableState = function() { this.game.device.desktop || (this.createMobileButtons(), this.mapLoader.joystickUI = this.joystickUI, this.joystickUI.disableInput()), t.Instances.controllKeyboard.setController(this, t.ControllerType.uiGameplay), t.Instances.controllKeyboard.addControl(), this.enablePause() }, i.prototype.enablePause = function() { t.Instances.dataManager.isTutorialPending() || (this.isPauseEnable = !0, this.isStateEnable = !0, this.game.device.desktop || this.joystickUI.show(), Ph2.UISystem.findObject("pause_container/pause", this.gameplayUI).onInputUp.add(this.showPause, this)) }, i.prototype.disableState = function() { this.isStateEnable = !1, this.game.device.desktop || this.joystickUI.hide(), t.Instances.controllKeyboard.removeControl(), Ph2.UISystem.findObject("pause_container/pause", this.gameplayUI).onInputUp.remove(this.showPause, this) }, i.prototype.create = function() { this.componentManager = Ph2.ComponentPlugin.initComponents(this), t.Instances.callbackSubscriber = this.componentManager.addComponent(t.ComponentCallbackSubscriber), this.aabb = new box2d.b2AABB, this.mainGroup = this.game.add.group(), this.backGroup = this.game.add.group(null, "backgrounds"), this.mapGroup = this.game.add.group(null, "map"), this.decoGroup = this.game.add.group(null, "deco_back"), this.objectsGroup = this.game.add.group(null, "objects"), this.frontDecoGroup = this.game.add.group(null, "deco_front"), this.uiGroup = this.game.add.group(null, "ui"), this.uiGroup.fixedToCamera = !0, this.mainGroup.add(this.backGroup), this.mainGroup.add(this.mapGroup), this.mainGroup.add(this.decoGroup), this.mainGroup.add(this.objectsGroup), this.mainGroup.add(this.frontDecoGroup), this.mainGroup.add(this.uiGroup), this.gameplayUI = this.game.add.ph2UI("ui_gameplay", "atlas_ui_gameplay"), this.uiGroup.add(this.gameplayUI), this.pauseOverlay = this.game.add.tileSprite(0, 0, this.game.width, this.game.height, "mask"), this.pauseOverlay.visible = !1, this.pauseOverlay.inputEnabled = !0, this.uiGroup.add(this.pauseOverlay), this.pauseUi = new t.UIPausa(this), this.uiGroup.add(this.pauseUi), this.pauseUi.visible = !1, Ph2.UISystem.findObject("alert_container", this.gameplayUI).visibility.enable(!1), Ph2.UISystem.findObject("alert_container", this.gameplayUI).visible = !1, Ph2.UISystem.findObject("left_fx", this.gameplayUI).visibility.enable(!1), Ph2.UISystem.findObject("left_fx", this.gameplayUI).visible = !1, Ph2.UISystem.findObject("right_fx", this.gameplayUI).visibility.enable(!1), Ph2.UISystem.findObject("right_fx", this.gameplayUI).visible = !1; var e = Ph2.UISystem.findObject("life_container/character", this.gameplayUI),
                i = Ph2.UISystem.findObject("life_container/life", this.gameplayUI),
                o = Ph2.UISystem.findObject("life_container/power", this.gameplayUI); if (Ph2.UISystem.findObject("life_container", this.gameplayUI).visibility.enable(!1), i.visibility.enable(!1), o.visibility.enable(!1), this.game.physics.startSystem(Phaser.Physics.BOX2D), Constants.DEBUG_ENABLED && (this.game.physics.box2d.debugDraw.shapes = !0, this.game.physics.box2d.debugDraw.pixelsPerMeter = this.game.world.scale.x * this.game.physics.box2d.ptmRatio), this.game.physics.box2d.useElapsedTime = !0, this.game.physics.box2d.gravity.y = 23 * GameData.PixToMet, this.player = new t.Player(this.game, 0, 0, this.objectsGroup), this.player.disableComponents(), t.Instances.cameraManager.init(this.player), i.width = i.texture.frame.width, this.player.lifeBar.setTilesprite(i), o.width = o.texture.frame.width, this.player.powerBar.setTilesprite(o), this.frontDecoGroup.add(this.player), this.game.world.setBounds(-2e4, -2e4, 4e4, 4e4), this.mapLoader = new t.MapLoader(this.game, this.player, this.playBeginning, this.fromAbove, this.fromRetry, this.lvJsonName, this.backGroup, this.mapGroup, this.decoGroup, this.objectsGroup, this.frontDecoGroup, this.uiGroup, this.gameplayUI, null), this.tutorialUi = new t.UITutorial(this), this.uiGroup.add(this.tutorialUi), this.player.onAfterIntro.addOnce(this.checkShowTutorial, this), Ph2.UISystem.findObject("life_container_container", this.gameplayUI).visibility.enable(!1), Ph2.UISystem.findObject("life_container_container", this.gameplayUI).visible = !1, this.mapLoader.isBoss) { var n = Ph2.UISystem.findObject("life_container_container/life", this.gameplayUI),
                    s = Ph2.UISystem.findObject("life_container_container/life2", this.gameplayUI),
                    r = Ph2.UISystem.findObject("life_container_container/life3", this.gameplayUI); switch (n.anchor.set(0, .5), n.scale.x = -1, this.mapLoader.boss.difficulty) {
                    case 1:
                        break;
                    case 2:
                        n.frameName = "boss_bar_2.png", s.frameName = "boss_bar_3-3.png", r.visibility.enable(!1), r.visible = !1; break;
                    case 3:
                        n.frameName = "boss_bar_3.png", s.visibility.enable(!1), s.visible = !1, r.visibility.enable(!1), r.visible = !1; break;
                    default:
                        n.frameName = "boss_bar_3.png", s.visibility.enable(!1), s.visible = !1, r.visibility.enable(!1), r.visible = !1 } this.mapLoader.boss.barManager.setTilesprite(n) } t.Instances.MapLoader = this.mapLoader, e.frameName = t.CharactersTag[this.mapLoader.spawnCharacter] + ".png", this.mapLoader.onGameEnd.add(this.endGame, this), this.mapLoader.onSectionEnd.add(this.disableState, this), this.game.world.setBounds(this.mapLoader.mapBounds.lowerBound.x, this.mapLoader.mapBounds.lowerBound.y, this.mapLoader.mapWidth, this.mapLoader.mapHeight); var a = new Phaser.Rectangle(this.mapLoader.mapBounds.lowerBound.x, this.mapLoader.mapBounds.lowerBound.y, this.mapLoader.mapWidth, this.mapLoader.mapHeight);
            t.Instances.cameraManager.setBoundRectangle(a), this.game.physics.box2d.setBoundsToWorld(!1, !1, !1, !1), t.Instances.transition.animationUI.visible && (this.mapLoader.setPlayerinit(), t.Instances.transition.playOut().addOnce(this.mapLoader.startLevelBeggining, this.mapLoader)), this.setLevelMusic(), Constants.CHEATS_ENABLED && (e.inputEnabled = !0, e.events.onInputDown.add(this.goToNextSection, this), this.initCheats()) }, i.prototype.initCheats = function() { this.game.input.keyboard.addKey(Phaser.Keyboard.N).onDown.removeAll(), this.game.input.keyboard.addKey(Phaser.Keyboard.M).onDown.removeAll(), this.game.input.keyboard.addKey(Phaser.Keyboard.N).onDown.add(this.goToNextSection, this), this.game.input.keyboard.addKey(Phaser.Keyboard.M).onDown.add(this.retryGameplay, this), this.game.input.keyboard.addKey(Phaser.Keyboard.T).onDown.add(this.checkShowTutorial, this) }, i.prototype.onPressBack = function() {!0 === this.pauseUi.visible ? this.pauseUi.pressPlay(null, null, !0) : this.showPause(null, null, !0) }, i.prototype.setLevelMusic = function() { if (this.mapLoader.isBoss) this.bgMusic = t.MusicID.BOSS;
            else switch (t.Instances.currentLevelId) {
                case 0:
                    this.bgMusic = t.MusicID.GAMEPLAY1; break;
                case 1:
                    1 === this.mapLoader.currentSectionNum ? this.bgMusic = t.MusicID.GAMEPLAY3 : this.bgMusic = t.MusicID.GAMEPLAY2; break;
                case 2:
                    1 === this.mapLoader.currentSectionNum ? this.bgMusic = t.MusicID.GAMEPLAY4 : this.bgMusic = t.MusicID.GAMEPLAY3; break;
                case 3:
                    1 === this.mapLoader.currentSectionNum ? this.bgMusic = t.MusicID.GAMEPLAY2 : this.bgMusic = t.MusicID.GAMEPLAY1; break;
                case 4:
                    this.bgMusic = t.MusicID.GAMEPLAY4; break;
                default:
                    this.bgMusic = t.MusicID.GAMEPLAY1 } this.game.ph2AudioManager.getMusicEnabled() && t.Audios.playMusic(this.game, this.bgMusic) }, i.prototype.goToNextSection = function() { this.mapLoader.endSection(!1) }, i.prototype.endGame = function(e) { var i = this;
            this.disableState(), e ? (t.Instances.currentLevelId >= 0 && (null !== t.Instances.currentLevelFounditem && t.Instances.dataManager.savelevelItemFound(t.Instances.currentLevelId, t.Instances.currentLevelFounditem), t.Instances.dataManager.saveLevelComplete(t.Instances.currentLevelId)), this.joystickUI && this.joystickUI.disableInput(), this.player.playFinishAnim(), this.player.onAfterOutro.addOnce(this.onEndBenOutWin, this)) : (this.joystickUI && this.joystickUI.disableInput(), this.game.time.events.add(GameData.gameLoseDelay, function() { i.pauseOverlay.visible = !0, i.gameplayUI.visible = !1, i.joystickUI && i.joystickUI.hide(), i.showUIGameover() })) }, i.prototype.onEndBenOutWin = function() { this.pauseOverlay.visible = !0, this.gameplayUI.visible = !1, this.joystickUI && this.joystickUI.hide(), this.showUIFinish() }, i.prototype.showUIFinish = function() { this.finishUi || (this.finishUi = new t.UIFinish(this, this.mapLoader.isBoss), this.uiGroup.add(this.finishUi)), this.game.ph2AudioManager.playEffect("popup_mission_completed", !1), this.uiGroup.bringToTop(this.pauseOverlay), this.uiGroup.bringToTop(this.finishUi), this.finishUi.show() }, i.prototype.showUIGameover = function() { this.gameoverUi || (this.gameoverUi = new t.UIGameover(this), this.uiGroup.add(this.gameoverUi)), this.game.ph2AudioManager.playEffect("popup_failed_mission", !1), this.uiGroup.bringToTop(this.pauseOverlay), this.uiGroup.bringToTop(this.gameoverUi), this.gameoverUi.show() }, i.prototype.showControls = function() { this.game.ph2AudioManager.playEffect("button1", !1), this.pauseOverlay.visible = !0, this.pauseUi.visible = !1, this.uiGroup.bringToTop(this.pauseOverlay), this.uiGroup.bringToTop(this.tutorialUi), this.tutorialUi.show() }, i.prototype.checkShowTutorial = function() { t.Instances.dataManager.isTutorialPending() ? (this.pauseOverlay.visible = !0, this.tutorialUi.show(), this.player.disableComponents()) : this.enableState() }, i.prototype.onCloseTutorial = function() { t.Instances.dataManager.isTutorialPending() ? (this.pauseOverlay.visible = !1, t.Instances.dataManager.saveTutorialComplete(), this.player.enableComponents(), this.enableState()) : (this.pauseUi.visible = !0, t.Instances.controllKeyboard.setController(this.pauseUi, t.ControllerType.uiPause), this.pauseUi.enableInput(), this.uiGroup.bringToTop(this.pauseUi)) }, i.prototype.respawnPlayer = function() { Constants.CHUNKS_ENABLED && this.mapLoader.clearCurrentChunkGroup(), this.player.body.reset(this.mapLoader.spawnPoint.x, this.mapLoader.spawnPoint.y), this.player.body.setZeroVelocity(), t.Instances.cameraManager.followPlayer(), Constants.CHUNKS_ENABLED && this.mapLoader.chunkPreUpdate() }, i.prototype.mouseMovement = function(t) { this.grabingScreen && (this.game.camera.x -= t.position.x - this.lastPointerPosition.x, this.game.camera.y -= t.position.y - this.lastPointerPosition.y), this.lastPointerPosition.set(t.position.x, t.position.y) }, i.prototype.createMobileButtons = function() { this.game.input.maxPointers = 2, this.joystickUI = new t.UIJoystickMobile(this) }, i.prototype.onPressDirection = function(t) { this.player.moveDpad(t) }, i.prototype.onReleasedDirection = function() { this.player.stopDpad() }, i.prototype.onPressJump = function() { this.player.jumpComponent.isEnabled && this.player.jumpComponent.jump() }, i.prototype.onPressAttack = function() { this.player.pressAttack() }, i.prototype.onPressSuper = function() { this.player.specialAttack.enable && this.player.specialAttack.attack() }, i.prototype.update = function() { this.phyElapsed = 1 / this.game.time.fps, this.phyElapsed < .017 ? this.game.time.physicsElapsed = 1 / this.game.time.fps : this.game.time.physicsElapsed = .017, t.Instances.visibilityManager.update(), Constants.CHUNKS_ENABLED && t.Instances.isGameplayActive && this.mapLoader.chunkUpdate(), this.player.position.y > this.mapLoader.mapBounds.upperBound.y + this.game.height && this.respawnPlayer() }, i.prototype.preRender = function() {}, i.prototype.render = function() { Constants.DEBUG_ENABLED, this.game.config.enableDebug && this.game.debug.box2dWorld() }, i.prototype.resize = function() { this.joystickUI && this.joystickUI.resize(), this.gameoverUi && this.gameoverUi.resize(), this.finishUi && this.finishUi.resize(), this.pauseOverlay && (this.pauseOverlay.width = this.game.width, this.pauseOverlay.height = this.game.height), t.Instances.cameraManager.resize(), this.mapLoader.resize() }, i.prototype.showPause = function(e, i, o) { o && (this.game.ph2AudioManager.playEffect("button1", !1), this.game.ph2AudioManager.setVolumeCurrentMusic(.5), this.pauseUi.show(), this.joystickUI && this.joystickUI.hide(), this.isPauseEnable = !1, this.gameplayUI.visible = !1, this.pauseOverlay.visible = !0, this.uiGroup.bringToTop(this.pauseOverlay), this.uiGroup.bringToTop(this.pauseUi), t.Instances.paused = !0, this.player.disableComponents(), Ph2.ComponentPlugin.pause(), this.mapLoader.pause(), this.game.time.events.pause(), this.game.tweens.pauseAll(), this.game.physics.box2d.pause(), t.Instances.onPause.dispatch()) }, i.prototype.onHidePause = function() { this.isPauseEnable = !0, t.Instances.controllKeyboard.setController(this, t.ControllerType.uiGameplay), t.Instances.controllKeyboard.addControl(), this.game.ph2AudioManager.setVolumeCurrentMusic(1), this.joystickUI && this.joystickUI.show(), this.gameplayUI.visible = !0, this.pauseOverlay.visible = !1, t.Instances.paused = !1, this.player.enableComponents(), Ph2.ComponentPlugin.resume(), this.mapLoader.resume(), this.game.time.events.resume(), this.game.tweens.resumeAll(), this.game.physics.box2d.resume(), t.Instances.onResume.dispatch() }, i.prototype.showConfirmation = function() { this.confirmationUi || (this.confirmationUi = new t.UIConfirmation(this), this.uiGroup.add(this.confirmationUi)), this.game.ph2AudioManager.playEffect("button1", !1), this.pauseUi.visible = !1, this.uiGroup.bringToTop(this.pauseOverlay), this.uiGroup.bringToTop(this.confirmationUi), this.confirmationUi.show() }, i.prototype.showSettings = function() { this.settingsUi || (this.settingsUi = new t.UISettings(this), this.uiGroup.add(this.settingsUi)), this.game.ph2AudioManager.playEffect("button1", !1), this.pauseUi.visible = !1, this.uiGroup.bringToTop(this.pauseOverlay), this.uiGroup.bringToTop(this.settingsUi), this.settingsUi.show() }, i.prototype.onHideSettings = function() { this.uiGroup.bringToTop(this.pauseOverlay), this.uiGroup.bringToTop(this.pauseUi), this.pauseUi.visible = !0, t.Instances.controllKeyboard.setController(this.pauseUi, t.ControllerType.uiPause), this.pauseUi.enableInput() }, i.prototype.onPressYes = function() { this.returnMainmenu() }, i.prototype.onPressNo = function() { this.pauseUi.visible = !0, t.Instances.controllKeyboard.setController(this.pauseUi, t.ControllerType.uiPause), this.pauseUi.enableInput(), this.uiGroup.bringToTop(this.pauseOverlay), this.uiGroup.bringToTop(this.pauseUi) }, i.prototype.onChangeButton = function(t) {}, i.prototype.onPressButton = function(t) {}, i.prototype.retryGameplay = function() { this.disableState(), t.Instances.transition.playIn().addOnce(this._transitionRetryGameplay, this) }, i.prototype._transitionRetryGameplay = function() { this.game.state.start("gameplayState", !0, !1, !1, this.lvJsonName, !1, !0) }, i.prototype.returnMainmenu = function() { this.disableState(), t.Instances.transition.playIn().addOnce(this._transitionReturnMainmenu, this) }, i.prototype.goToComicOutro = function() { this.game.state.start("comicState", !0, !1, !1, 1) }, i.prototype._transitionReturnMainmenu = function() { this.game.state.start("levelselectState", !0, !1, t.Instances.currentMission) }, i.prototype.onBlur = function() { this.isStateEnable && this.isPauseEnable && this.showPause(null, null, !0) }, i.prototype.shutdown = function() { t.Instances.cameraManager.end(), t.Instances.visibilityManager.destroyAllObjectCheck(), e.prototype.shutdown.call(this), this.game.onBlur.remove(this.onBlur, this), this.mapLoader.shutdown(), this.game.physics.box2d.clear(), this.mainGroup.destroy(!0), this.mapGroup.destroy(!0), this.decoGroup.destroy(!0), this.objectsGroup.destroy(!0), this.frontDecoGroup.destroy(!0), this.uiGroup.destroy(!0), t.Instances.callbackSubscriber = null, this.game.input.onDown.removeAll(), this.game.input.onUp.removeAll(), this.game.input.deleteMoveCallback(this.mouseMovement, this), this.game.input.mouse.mouseWheelCallback = null, this.grabingScreen = !1, this.componentManager.removeAllComponents(), this.camera.scale.set(1), this.camera.position.set(0), t.Instances.paused && (t.Instances.paused = !1, this.game.time.events.resume(), Ph2.ComponentPlugin.resume(), this.game.physics.box2d.resume()), this.pauseUi = null, this.finishUi = null, this.confirmationUi = null, this.gameoverUi = null, this.player = null, this.joystickUI && (this.joystickUI.destroy(), this.joystickUI = null), this.game.ph2AudioManager.setVolumeCurrentMusic(1) }, i }(Phaser.State);
    t.GameplayState = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i() { return e.call(this) || this } return __extends(i, e), i.prototype.init = function() { this.video = null, Array.prototype.map = Array.prototype.map || function(t) { for (var e = [], i = 0; i < this.length; i++) e[i] = t(this[i]); return e }, this.game.ph2UIManager.enableVisibilityAndOrientationComponent = !1, this.game.stage.backgroundColor = 0; var e = this.game.cache.getJSON("resources");
            this.game.ph2Loader.debug(!1), this.game.ph2Loader.setAssetsResources(e), GameData.idleTimer *= 1e3, GameData.invulnerabilityTimeSoft *= 1e3, GameData.invulnerabilityTimeHard *= 1e3, GameData.invulnerabilityEnemyTimeSoft *= 1e3, GameData.invulnerabilityEnemyTimeHard *= 1e3, GameData.stinkflyAcidPoolHitRate *= 1e3, GameData.stinkflyAcidPoolDuration *= 1e3, GameData.cannonboltChargingTime *= 1e3, GameData.rathChargingTime *= 1e3, GameData.gameWinDelay *= 1e3, GameData.gameLoseDelay *= 1e3, GameData.enemyMeleeCChargeTime *= 1e3, GameData.enemyMeleeBRestTime *= 1e3, GameData.stunTime *= 1e3, GameData.platformIdleTime *= 1e3, GameData.stinkflySuperCooldown *= 1e3, GameData.heatblastSuperCooldown *= 1e3, GameData.arrowMarkerTime *= 1e3, GameData.waveStartDelay *= 1e3, GameData.waveSetDelay *= 1e3, GameData.waveSpawnTime *= 1e3, GameData.waveNewFloorTime *= 1e3, GameData.waveEndDelay *= 1e3, GameData.BossAudioFadeTime *= 1e3, GameData.Boss1WaveSpawnTime *= 1e3, GameData.Boss1DashDelay *= 1e3, GameData.Boss1WhipDelay *= 1e3, GameData.Boss3DashDelay *= 1e3, GameData.Boss3SpikeDelay *= 1e3, GameData.Boss3SpikeSecuenceTime *= 1e3, GameData.Boss3SpikeLifeTime *= 1e3, t.Instances.onPause = new Phaser.Signal, t.Instances.onResume = new Phaser.Signal }, i.prototype.preload = function() { t.Audios.initAudio(this.game), this.group = new Phaser.Group(this.game), this.loadingCN = new t.LoadingCN(this), t.Instances.pathLoads.push("firstLoad"), this.game.ph2Loader.load("firstLoad"), t.Audios.loadAudioSprite(this.game, "audiosprite"), t.Instances.dataManager = new t.DataManager(this.game), this.game.load.onFileComplete.add(this.progress, this), this.resize(), this.progress(0), this.game.add.existing(this.group), this.group.add(this.loadingCN) }, i.prototype.progress = function(t) { this.loadingCN.setPercent(t) }, i.prototype.create = function() { this.game.load.onFileComplete.remove(this.progress, this), t.Instances.dataManager.getSoundState() || (this.game.ph2AudioManager.switchMusicState(), this.game.ph2AudioManager.switchSfxState()), this.game.time.advancedTiming = !0, this.game.forceSingleUpdate = !0, this.loadingCN.showPlayButton(), t.Instances.transition = new t.Transition(this.game), t.Instances.initKeyboard(this.game), t.Instances.initControlKeyboard(this.game), t.Instances.initLocalization(this.game), t.Instances.initVisibilityManager(this.game), t.Instances.initCameraManager(this.game), this.changeFontUI() }, i.prototype.onPressPlay = function() { Constants.SHOW_VIDEO ? this.game.time.events.add(100, this.showVideo, this) : this.onEndVideo() }, i.prototype.showVideo = function() { this.video = new t.VideoManager(this.game, urlVideo), this.video.onCompleteVideo.addOnce(this.onEndVideo, this) }, i.prototype.onEndVideo = function() { this.game.state.start("mainmenuState") }, i.prototype.changeFontUI = function() { var t = ["ar", "bg", "cs", "da", "de", "en", "es", "fr", "hu", "it", "nl", "no", "pl", "pt", "ro", "ru", "sv", "tr"]; "no" !== language && "da" !== language || (Ph2.UITextStyle.testStringDefault = "|MÃ‰qgyȘåÅ", Ph2.UITextStyle.baseLineXDefault = 1.2, Ph2.UITextStyle.baseLineYDefault = 1.8), "sv" !== language && "ro" !== language || (Ph2.UITextStyle.testStringDefault = "|MÃ‰qgyȘåÅ", Ph2.UITextStyle.baseLineXDefault = 1.2, Ph2.UITextStyle.baseLineYDefault = 1.9), "fr" !== language && "hu" !== language || (Ph2.UITextStyle.testStringDefault = "|MÃ‰qgyȘåÉ", Ph2.UITextStyle.baseLineXDefault = 1.2, Ph2.UITextStyle.baseLineYDefault = 1.85), "pt" === language && (Ph2.UITextStyle.testStringDefault = "|MÃ‰qgyȘåÇ", Ph2.UITextStyle.baseLineXDefault = 1.2, Ph2.UITextStyle.baseLineYDefault = 1.85), "ar" === language && (Ph2.UITextStyle.testStringDefault = "|MÃ‰qgyȘåÇي", Ph2.UITextStyle.baseLineXDefault = 1.2, Ph2.UITextStyle.baseLineYDefault = 1.85); var e = "ar" === language ? "LubalinGraphITCTurnerAra-Bd" : "LubalinGraphITCTurner"; if (-1 !== t.indexOf(language))
                for (var i, o = ["ui_comic", "ui_confirmation", "ui_gameover", "ui_level_completed", "ui_main_menu", "ui_map", "ui_pause", "ui_settings", "ui_tutorial"], n = 0, s = o.length; n < s; n++) { i = this.game.cache.getJSON(o[n]).properties; for (var r in i) i.hasOwnProperty(r) && void 0 !== i[r].font && (i[r].font.name = e) } }, i.prototype.resize = function() { this.loadingCN.resize() }, i.prototype.shutdown = function() { e.prototype.shutdown.call(this), Constants.SHOW_VIDEO && (this.video.destroy(), this.video = null), this.loadingCN = null, this.group = null, this.game = null }, i }(Phaser.State);
    t.PreloaderState = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i() { return e.call(this) || this } return __extends(i, e), i.prototype.init = function() { this.game.world.removeAll(), t.Instances.currentLevelId = 0 }, i.prototype.create = function() { this.bgMusic = t.MusicID.MENU, this.bg = this.game.add.image(0, 0, "mm_bg"), this.mainUi = new t.UIMainMenu(this), this.settingsUi = null, this.overlay = this.game.add.tileSprite(0, 0, this.game.width, this.game.height, "mask"), this.overlay.visible = !1, this.overlay.inputEnabled = !0, this.mainGroup = this.game.add.group(), this.mainGroup.add(this.mainUi), this.mainGroup.add(this.overlay), t.Instances.transition.animationUI.visible && (this.mainUi.disableInput(), t.Instances.transition.playOut().addOnce(this.mainUi.enableInput, this.mainUi)), this.game.ph2AudioManager.getMusicEnabled() && t.Audios.playMusic(this.game, this.bgMusic), t.Instances.fileListenerInitiated || (this.initFileListener(), t.Instances.fileListenerInitiated = !0), Constants.CHEATS_ENABLED && this.initCheats(), this.resize() }, i.prototype.initCheats = function() { this.game.input.keyboard.addKey(Phaser.Keyboard.B).onDown.add(this.playBossBattle, this), this.game.input.keyboard.addKey(Phaser.Keyboard.C).onDown.add(this.goToComic, this), this.game.input.keyboard.addKey(Phaser.Keyboard.U).onDown.add(this.unlockMissionTwo, this), t.Instances.dataManager.lockSecondMission() }, i.prototype.unlockMissionTwo = function() { t.Instances.dataManager.unlockSecondMission(), this.game.state.restart(!0, !1) }, i.prototype.playBossBattle = function() { var e = this;
            t.Instances.transition.playIn().addOnce(function() { e.game.state.start("gameplayState", !0, !1, !0, "boss01_section1") }, this) }, i.prototype.goToComic = function() { var e = this;
            t.Instances.transition.playIn().addOnce(function() { e.game.state.start("comicState", !0, !1, !0) }, this) }, i.prototype.goToLevelSelect = function(e) { var i = this;
            void 0 === e && (e = 0), t.Instances.currentMission = e, e > 0 && (t.Instances.currentLevelId = 11), t.Instances.transition.playIn().addOnce(function() { i.game.state.start("levelselectState", !0, !1, t.Instances.currentMission) }, this) }, i.prototype.onPressPlay = function() { t.Instances.dataManager.isFirstLaunch() ? (t.Instances.dataManager.endFirstLaunch(), this.goToComic()) : this.goToLevelSelect(0) }, i.prototype.onPressPlay2 = function() { this.goToLevelSelect(1) }, i.prototype.onShowSettings = function() { this.settingsUi || (this.settingsUi = new t.UISettings(this), this.mainGroup.add(this.settingsUi)), this.overlay.visible = !0, this.settingsUi.show(), this.mainUi.hideMiddleElements() }, i.prototype.onHideSettings = function() { this.overlay.visible = !1, this.mainUi.showMiddleElements(), this.mainUi.enableInput() }, i.prototype.initFileListener = function() { var t = this;
            this.DnDFileController("body", function(e) { t.startfileRead(e) }) }, i.prototype.DnDFileController = function(t, e) { var i = document.querySelector(t);
            i.addEventListener("dragenter", function(t) { t.stopPropagation(), t.preventDefault(), i.classList.add("dropping") }, !1), i.addEventListener("dragover", function(t) { t.stopPropagation(), t.preventDefault() }, !1), i.addEventListener("dragleave", function(t) { t.stopPropagation(), t.preventDefault() }, !1), i.addEventListener("drop", function(t) { t.stopPropagation(), t.preventDefault(), i.classList.remove("dropping"), e(t.dataTransfer.files, t) }, !1) }, i.prototype.startfileRead = function(t) { var e = t[0],
                i = new FileReader,
                o = this;
            i.onloadend = function(t) { o.transformJSONToData(i.result, e.name) }.bind(this), i.readAsText(e) }, i.prototype.transformJSONToData = function(e, i) { var o = JSON.parse(e);
            this.game.cache.addJSON(i, "", o), this.loadedFileName = i, t.Instances.transition.playIn().addOnce(this._transitionPlayLoadedFile, this) }, i.prototype._transitionPlayLoadedFile = function() { this.game.state.start("gameplayState", !0, !1, !0, this.loadedFileName) }, i.prototype.resize = function() { this.bg.width = this.game.width, this.bg.height = this.game.height, this.overlay.width = this.game.width, this.overlay.height = this.game.height }, i.prototype.shutdown = function() { e.prototype.shutdown.call(this), this.mainUi = null, this.mainGroup = null, this.mainUi = null }, i }(Phaser.State);
    t.MainMenuState = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e() { return null !== t && t.apply(this, arguments) || this } return __extends(e, t), e.prototype.init = function(t) { void 0 === t && (t = !1), this.badEnd = t }, e.prototype.create = function() { this.badEnd ? this.finishUi = this.game.add.ph2UI("ui_gameover", "atlas_ui_gameover") : this.finishUi = this.game.add.ph2UI("ui_level_completed", "atlas_ui_level_completed"), this.game.input.onDown.addOnce(this.goToMainMenu, this) }, e.prototype.goToMainMenu = function() { this.game.state.start("mainmenuState", !0, !1) }, e.prototype.update = function() {}, e.prototype.resize = function() {}, e.prototype.shutdown = function() { t.prototype.shutdown.call(this), this.game.input.onDown.removeAll() }, e }(Phaser.State);
    t.FinishState = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i() { return e.call(this) || this } return __extends(i, e), i.prototype.preload = function() {-1 === t.Instances.pathLoads.indexOf("levelSelect") && (t.Instances.pathLoads.push("levelSelect"), this.game.ph2Loader.load("levelSelect")) }, i.prototype.init = function(e) { this.game.world.removeAll(), this.game.stage.backgroundColor = 1447446, this.tweenLocation = null, this.tweenButton = null, this.tweenMap = null, this.isBoss = !1, this.tutorialUi = null, this.overlay = null, this.lastButton = null, this.missionIndex = e, this.currentLevelId = t.Instances.currentLevelId }, i.prototype.create = function() { this.mainGroup = this.game.add.group(), this.bg = this.game.add.image(0, 0, "comic_map_bg", null, this.mainGroup), this.mapUi = this.game.add.ph2UI("ui_map", "atlas_ui_map"), this.localization(), this.mainGroup.add(this.mapUi), this.alienCursor = Ph2.UISystem.findObject("aliens_left/level_container/select", this.mapUi), this.alienCursor.inputEnableChildren = !1, this.alienCursorBase = Ph2.UISystem.findObject("aliens_left/level_container/select/base", this.mapUi), this.alienCursorBaseBorder = Ph2.UISystem.findObject("aliens_left/level_container/select/base/border", this.mapUi), this.alienCursorBaseBorder.visibility.enable(!1), this.playButton = Ph2.UISystem.findObject("button_play/container/button_play", this.mapUi), this.exitButton = Ph2.UISystem.findObject("button_play/container/button_exit", this.mapUi), this.controlsButton = Ph2.UISystem.findObject("button_play/container/button_tutorial", this.mapUi), this.locationText = Ph2.UISystem.findObject("button_play/container/location_title/location", this.mapUi), this.mapCursor = this.game.add.sprite(0, 0, "atlas_ui_map", "mark.png"), this.mapCursor.anchor.set(.5), this.game.add.tween(this.mapCursor).to({ angle: 360 }, 5e3, Phaser.Easing.Linear.None, !0, 0, -1), this.mapBg = Ph2.UISystem.findObject("map_container/map", this.mapUi), this.setMapMarkers(), this.mapMarks[0].parent.addChild(this.mapCursor), this.mapCursor.position.copyFrom(this.mapMarks[0].position), this.mapCursor.x = 0, this.mapCursor.y = 0, this.mapBg.x = 0 - this.mapMarks[0].x, this.mapBg.y = 46 - this.mapMarks[0].y; for (var e = 4; e < 11; e++) this.mapMarks[e].visibility.enable(!1), this.mapMarks[e].visible = !1;
            this.bossCursor = Ph2.UISystem.findObject("boss/boss_select", this.mapUi), this.bossCursor.visibility.enable(!1), this.bossCursor.visible = !1; var i = Ph2.UISystem.findObject("boss/container1", this.mapUi);
            i.visibility.enable(!1), i.addChild(this.bossCursor), t.Instances.controllKeyboard.setController(this, t.ControllerType.uiLevelSelect, !1), this.setLevelUnlock(), this.lastButton && t.Instances.controllKeyboard.setButton(this.lastButton, !1), this.alienCursorBase.ph2Animations.play("select_loop", 1, !0), this.resize(), this.game.ph2AudioManager.getMusicEnabled() && t.Audios.playMusic(this.game, t.MusicID.MENU), Constants.CHEATS_ENABLED && this.initCheats(), t.Instances.transition.playOut().addOnce(this.initInput, this) }, i.prototype.setMapMarkers = function() { this.mapMarks = [], this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_paris", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_rio", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_tokyo", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_yucatan", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_london", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_london", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_tokyo", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_rio", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_paris", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_yucatan", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_north_pole", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_paris", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_rio", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_tokyo", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_yucatan", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_london", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_london", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_tokyo", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_rio", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_paris", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_yucatan", this.mapUi)), this.mapMarks.push(Ph2.UISystem.findObject("map_container/mark_north_pole", this.mapUi)) }, i.prototype.initInput = function() { this.exitButton.events.onInputUp.add(this.goToMainmenu, this), this.controlsButton.events.onInputUp.add(this.showControls, this), this.playButton.events.onInputUp.add(this.goToGameplay, this), t.Instances.controllKeyboard.addControl(), this.enableInputLevels() }, i.prototype.enableInputLevels = function() { for (var t = 0; t < 5; t++) this.mapLevelsUnlock[0][t] && (this.leftRow[t].inputEnabled = !0), this.mapLevelsUnlock[2][t] && (this.rightRow[t].inputEnabled = !0);
            this.mapLevelsUnlock[1][0] && (this.bossSpr.inputEnabled = !0) }, i.prototype.localization = function() { GameData.locationById[0] = t.Instances.localizationManager.getSringForKey("location_paris"), GameData.locationById[1] = t.Instances.localizationManager.getSringForKey("location_rio"), GameData.locationById[2] = t.Instances.localizationManager.getSringForKey("location_tokyo"), GameData.locationById[3] = t.Instances.localizationManager.getSringForKey("location_yucatan"), GameData.locationById[4] = t.Instances.localizationManager.getSringForKey("location_london"), GameData.locationById[5] = t.Instances.localizationManager.getSringForKey("location_london"), GameData.locationById[6] = t.Instances.localizationManager.getSringForKey("location_tokyo"), GameData.locationById[7] = t.Instances.localizationManager.getSringForKey("location_rio"), GameData.locationById[8] = t.Instances.localizationManager.getSringForKey("location_paris"), GameData.locationById[9] = t.Instances.localizationManager.getSringForKey("location_yucatan"), GameData.locationById[10] = t.Instances.localizationManager.getSringForKey("location_north_pole"), GameData.locationById[11] = t.Instances.localizationManager.getSringForKey("location_paris"), GameData.locationById[12] = t.Instances.localizationManager.getSringForKey("location_rio"), GameData.locationById[13] = t.Instances.localizationManager.getSringForKey("location_tokyo"), GameData.locationById[14] = t.Instances.localizationManager.getSringForKey("location_yucatan"), GameData.locationById[15] = t.Instances.localizationManager.getSringForKey("location_london"), GameData.locationById[16] = t.Instances.localizationManager.getSringForKey("location_london"), GameData.locationById[17] = t.Instances.localizationManager.getSringForKey("location_tokyo"), GameData.locationById[18] = t.Instances.localizationManager.getSringForKey("location_rio"), GameData.locationById[19] = t.Instances.localizationManager.getSringForKey("location_paris"), GameData.locationById[20] = t.Instances.localizationManager.getSringForKey("location_yucatan"), GameData.locationById[21] = t.Instances.localizationManager.getSringForKey("location_north_pole"), t.Instances.localizationManager.localizeUIText("title/title/text", this.mapUi, "level_select") }, i.prototype.initKeyboardControl = function() { t.Instances.controllKeyboard.setController(this, t.ControllerType.uiLevelSelect, !1), this.lastButton && t.Instances.controllKeyboard.setButton(this.lastButton, !1) }, i.prototype.onChangeButton = function(e) { var i, o;
            this.lastButton = e; var n; if ("10" === e) this.selectBossBattle();
            else { n = +e; var s = GameData.AliensPerMission * this.missionIndex,
                    r = GameData.LevelsPerMission * this.missionIndex;
                n > 4 ? (i = Ph2.UISystem.findObject("aliens_right/level_container/alien" + (n - 4), this.mapUi), o = t.CharactersTag[n - 5 + s] + "02_section1") : (i = Ph2.UISystem.findObject("aliens_left/level_container/alien" + (n + 1), this.mapUi), o = t.CharactersTag[n + s] + "01_section1"), i.parent.addChild(this.alienCursor), this.selectLevel(i.x, i.y, o, n + r) } }, i.prototype.onPressButton = function(t) { this.goToGameplay(null, null, !0) }, i.prototype.onPressBack = function() { this.goToMainmenu(null, null, !0) }, i.prototype.setLevelUnlock = function() { var e = this,
                i = [],
                o = t.Instances.dataManager.isAllLevelCompleted() || Constants.ALL_LEVELS_UNLOCKED;
            this.bossSpr = Ph2.UISystem.findObject("boss/container1", this.mapUi), this.bossSpr.visibility.enable(!1), this.bossSpr.visible = o, o ? (this.missionIndex > 0 && (Ph2.UISystem.findObject("boss/container1/character", this.mapUi).frameName = "kevin.png"), this.bossSpr.events.onInputDown.add(this.selectBossBattle, this)) : Ph2.UISystem.findObject("map_container", this.mapUi).position.y -= 115, this.leftRow = [], this.rightRow = []; var n = GameData.AliensPerMission * this.missionIndex,
                s = GameData.LevelsPerMission * this.missionIndex;
            this.lastButton = (t.Instances.currentLevelId - s).toString(); var r = [580, 10, 840, 260, 1100],
                a = 0;
            i[0] = [], i[1] = [o], i[2] = []; for (var h = this, l = 0; l < 5; l++) ! function(o) { i[0][o] = !0; var l = Ph2.UISystem.findObject("aliens_left/level_container/alien" + (o + 1), h.mapUi),
                    c = Ph2.UISystem.findObject("aliens_right/level_container/alien" + (o + 1), h.mapUi),
                    d = t.CharactersTag[o + n] + "01_section1",
                    u = t.CharactersTag[o + n] + "02_section1"; if (h.currentLevelId - s > 4 ? o === h.currentLevelId - 5 - s && (h.currentLevel = u, c.parent.addChild(h.alienCursor), h.alienCursor.position.set(c.x, c.y), h.locationText.text = GameData.locationById[h.currentLevelId]) : o === h.currentLevelId - s && (h.currentLevel = d, l.parent.addChild(h.alienCursor), h.alienCursor.position.set(l.x, l.y), h.locationText.text = GameData.locationById[h.currentLevelId]), t.Instances.dataManager.getLevelCompleted(o + s) ? (l.frameName = t.CharactersTag[o + n] + "_3_l.png", t.Instances.dataManager.getLevelItemFound(o + s) ? Ph2.UISystem.playAnimationObject("aliens_left/level_container/star" + (o + 1), h.mapUi, "star_gold_in", 1, !1) : Ph2.UISystem.playAnimationObject("aliens_left/level_container/star" + (o + 1), h.mapUi, "star_grey_in", 1, !1)) : (l.frameName = t.CharactersTag[o + n] + "_2.png", (f = Ph2.UISystem.findObject("aliens_left/level_container/star" + (o + 1), h.mapUi)).visibility.enable(!1), f.visible = !1), l.events.onInputUp.add(function(t) { t.parent.addChild(e.alienCursor), e.selectLevel(t.x, t.y, d, o + s) }, h), t.Instances.dataManager.getLevelCompleted(o + s) || Constants.ALL_LEVELS_UNLOCKED) { i[2][o] = !0; var p = o + 5,
                        m = Ph2.UISystem.findObject("aliens_right/level_container/alien" + (o + 1) + "/lock", h.mapUi); if (m.visibility.enable(!1), m.visible = !1, t.Instances.dataManager.getLevelCompleted(p + s)) c.frameName = t.CharactersTag[o + n] + "_3_l.png", t.Instances.dataManager.getLevelItemFound(p + s) ? Ph2.UISystem.playAnimationObject("aliens_right/level_container/star" + (o + 1), h.mapUi, "star_gold_in", 1, !1) : Ph2.UISystem.playAnimationObject("aliens_right/level_container/star" + (o + 1), h.mapUi, "star_grey_in", 1, !1);
                    else { c.frameName = t.CharactersTag[o + n] + "_2.png"; var f = Ph2.UISystem.findObject("aliens_right/level_container/star" + (o + 1), h.mapUi);
                        f.visibility.enable(!1), f.visible = !1 } c.children[0].visibility.enable(!1), c.children[0].visible = !1, c.events.onInputUp.add(function(t) { t.parent.addChild(e.alienCursor), e.selectLevel(t.x, t.y, u, p + s) }, h) } else i[2][o] = !1, c.frameName = t.CharactersTag[o + n] + "_1.png", h.game.time.events.add(r[a], h.playLockAnimation, h, o), a++;
                h.leftRow.push(l), h.rightRow.push(c) }(l);
            this.mapLevelsUnlock = i; for (var c, d, u, p, m = 0; m < 5; m++) u = null, c = 0 === m ? null : (m - 1).toString(), p = i[1][0] ? "10" : i[2][m] ? (5 + m).toString() : -1 !== i[2].lastIndexOf(!0, m) ? (5 + i[2].lastIndexOf(!0, m)).toString() : -1 !== i[2].indexOf(!0, m) ? (5 + i[2].indexOf(!0, m)).toString() : null, d = m < 4 ? (m + 1).toString() : null, t.Instances.controllKeyboard.setButtonFlow(m.toString(), c, d, u, p), i[2][m] && (p = null, c = 0 === m ? null : i[2][m - 1] ? (m + 5 - 1).toString() : -1 !== i[2].lastIndexOf(!0, m - 1) ? (5 + i[2].lastIndexOf(!0, m - 1)).toString() : null, u = i[1][0] ? "10" : m.toString(), d = m < 4 && i[2][m + 1] ? (m + 5 + 1).toString() : -1 !== i[2].indexOf(!0, m + 1) ? (5 + i[2].indexOf(!0, m + 1)).toString() : null, t.Instances.controllKeyboard.setButtonFlow((m + 5).toString(), c, d, u, p));
            i[1][0] && (u = "0", p = "5", c = null, d = null, t.Instances.controllKeyboard.setButtonFlow("10", c, d, u, p)), 10 !== this.currentLevelId && 21 !== this.currentLevelId || (this.currentLevel = "boss0" + (this.missionIndex + 1) + "_section1", this.isBoss = !0, this.alienCursor.visible = !1, this.bossCursor.visible = !0, this.bossCursor.ph2Animations.play("select_container_anim", 1, !1), this.bossCursor.children[0].ph2Animations.play("red_select_loop", 1, !0), this.locationText.text = GameData.locationById[this.currentLevelId]), this.setMapLocation(this.currentLevelId) }, i.prototype.showControls = function() { this.tutorialUi || (this.overlay = this.game.add.tileSprite(0, 0, this.game.width, this.game.height, "mask"), this.overlay.inputEnabled = !0, this.tutorialUi = new t.UITutorial(this), this.mainGroup.add(this.overlay), this.mainGroup.add(this.tutorialUi)), this.overlay.visible = !0, this.tutorialUi.show() }, i.prototype.onCloseTutorial = function() { this.initKeyboardControl(), t.Instances.controllKeyboard.addControl(), this.overlay.visible = !1 }, i.prototype.initCheats = function() { this.game.input.keyboard.addKey(Phaser.Keyboard.B).onDown.add(this.selectBossBattle, this), this.game.input.keyboard.addKey(Phaser.Keyboard.A).onDown.add(this.unlockAllLevels, this) }, i.prototype.playLockAnimation = function(t) { Ph2.UISystem.playAnimationObject("aliens_right/level_container/alien" + (t + 1) + "/lock", this.mapUi, "lock_loop", 1, !0) }, i.prototype.selectLevel = function(e, i, o, n) { if (this.isBoss = !1, this.currentLevelId !== n) { this.currentLevelId = n, this.currentLevel = o; var s = GameData.LevelsPerMission * this.missionIndex;
                this.game.ph2AudioManager.playEffect("button2", !1), this.tweenButton && (this.tweenButton.onComplete.removeAll(), this.tweenButton.stop()), this.currentLevelId - s != 10 && (this.currentLevelId - s <= 4 && n - s <= 4 || this.currentLevelId - s > 4 && n - s > 4) ? (this.tweenButton = this.game.add.tween(this.alienCursor).to({ x: e, y: i }, 300, Phaser.Easing.Linear.None, !0), this.tweenButton.onComplete.add(this.onCompletedMove, this), this.alienCursorBaseBorder.visible = !1, this.alienCursorBase.ph2Animations.stop("select_loop", !1)) : (this.alienCursor.position.set(e, i), this.onCompletedMove()), t.Instances.controllKeyboard.setButton((n - s).toString(), !1), this.bossCursor.visible && (this.bossCursor.visible = !1, this.alienCursor.visible = !0, this.bossCursor.ph2Animations.stop("select_container_anim", !1), this.bossCursor.children[0].ph2Animations.stop("red_select_loop", !1)), this.tweenLocation && (this.tweenLocation.onComplete.removeAll(), this.tweenLocation.stop()), this.tweenMap && this.tweenMap.stop(), this.tweenLocation = this.game.add.tween(this.locationText).to({ alpha: 0 }, 100), this.tweenLocation.onComplete.addOnce(this.switchName, this, 0, n), this.tweenLocation.start(), this.setMapLocation(n) } }, i.prototype.setMapLocation = function(t) { var e = 0 - this.mapMarks[t].x,
                i = 46 - this.mapMarks[t].y;
            this.tweenMap = this.game.add.tween(this.mapBg).to({ x: e, y: i }, 300, Phaser.Easing.Quadratic.InOut, !0) }, i.prototype.selectBossBattle = function() { var e = 10 + this.missionIndex * GameData.LevelsPerMission; if (this.currentLevelId !== e) { this.game.ph2AudioManager.playEffect("button2", !1), this.currentLevelId = e, t.Instances.controllKeyboard.setButton("10", !1), this.tweenLocation = this.game.add.tween(this.locationText).to({ alpha: 0 }, 100), this.tweenLocation.onComplete.addOnce(this.switchName, this, 0, this.currentLevelId), this.tweenLocation.start(), this.isBoss = !0, this.alienCursor.visible = !1, this.bossCursor.visible = !0, this.bossCursor.ph2Animations.play("select_container_anim", 1, !1), this.bossCursor.children[0].ph2Animations.play("red_select_loop", 1, !0), this.currentLevel = "boss0" + (this.missionIndex + 1) + "_section1"; var i = 0 - this.mapMarks[this.currentLevelId].x,
                    o = 46 - this.mapMarks[this.currentLevelId].y;
                this.game.add.tween(this.mapBg).to({ x: i, y: o }, 300, Phaser.Easing.Quadratic.InOut, !0) } }, i.prototype.unlockAllLevels = function() { Constants.ALL_LEVELS_UNLOCKED = !0, this.game.state.restart(!0, !1, this.missionIndex) }, i.prototype.onCompletedMove = function() { if (this.alienCursorBaseBorder.visible = !0, t.Instances.dataManager.getLevelCompleted(this.currentLevelId)) { var e = void 0,
                    i = void 0,
                    o = GameData.LevelsPerMission * this.missionIndex;
                this.currentLevelId - o > 4 ? (i = this.currentLevelId - o - 4, e = "right") : (i = this.currentLevelId - o + 1, e = "left"), t.Instances.dataManager.getLevelItemFound(this.currentLevelId) ? Ph2.UISystem.playAnimationObject("aliens_" + e + "/level_container/star" + i, this.mapUi, "star_gold_shake", 1, !1) : Ph2.UISystem.playAnimationObject("aliens_" + e + "/level_container/star" + i, this.mapUi, "star_grey_shake", 1, !1) } this.alienCursorBase.ph2Animations.play("select_loop", 1, !0), this.alienCursor.ph2Animations.play("select_container_anim", 1, !1) }, i.prototype.switchName = function(t, e, i) { this.locationText.text = GameData.locationById[i], this.tweenLocation = this.game.add.tween(this.locationText).to({ alpha: 1 }, 100), this.tweenLocation.start() }, i.prototype.goToGameplay = function(e, i, o) { o && (this.game.ph2AudioManager.playEffect("button1", !1), this.disableButtons(), t.Instances.transition.playIn().addOnce(this._transitionGoToGameplay, this)) }, i.prototype._transitionGoToGameplay = function() { t.Instances.currentLevelId = this.currentLevelId, t.Instances.currentLevelFounditem = null, this.game.state.start("gameplayState", !0, !1, !0, this.currentLevel) }, i.prototype.goToMainmenu = function(t, e, i) { i && (this.game.ph2AudioManager.playEffect("button1", !1), this.disableButtons(), this.game.state.start("mainmenuState", !0, !1)) }, i.prototype.disableButtons = function() { t.Instances.controllKeyboard.removeControl(), this.exitButton.events.onInputUp.remove(this.goToMainmenu, this), this.playButton.events.onInputUp.remove(this.goToGameplay, this), this.controlsButton.events.onInputUp.remove(this.showControls, this); for (var e = 0, i = this.leftRow; e < i.length; e++) i[e].inputEnabled = !1; for (var o = 0, n = this.rightRow; o < n.length; o++) n[o].inputEnabled = !1;
            this.bossSpr.inputEnabled = !1 }, i.prototype.resize = function() { var t = Ph2.UISystem.findObject("aliens_left/level_container", this.mapUi),
                e = Ph2.UISystem.findObject("aliens_right/level_container", this.mapUi),
                i = Ph2.UISystem.findObject("boss/container1", this.mapUi),
                o = Ph2.UISystem.findObject("button_play/container", this.mapUi),
                n = 1,
                s = 0;
            this.bg.width = this.game.width, this.bg.height = this.game.height, this.game.width >= 1120 ? (t.x = 0, e.x = 0, i.y = 0, o.y = 0, t.scale.set(1, 1), e.scale.set(1, 1), i.scale.set(1, 1), o.scale.set(1, 1)) : this.game.width < 1120 && this.game.width >= 960 ? (t.x = 0, e.x = 0, t.scale.set(1, 1), e.scale.set(1, 1), n = 1 - (1120 - this.game.width) / 160 * .3, n = Math.floor(100 * n) / 100, i.scale.set(n, n), s = (374 - 374 * n) / 2, i.y = -s, s = (350 - 350 * n) / 2, o.y = s, o.scale.set(n, n)) : (n = 1 - (960 - this.game.width) / 240 * .25, s = (260 - 260 * (n = Math.floor(100 * n) / 100)) / 2, t.x = -s, e.x = -s, t.scale.set(n, n), e.scale.set(n, n), s = (374 - 261.8) / 2, i.y = -s, i.scale.set(.7, .7), s = (350 - 350 * .7) / 2, o.y = s, o.scale.set(.7, .7)) }, i.prototype.shutdown = function() { e.prototype.shutdown.call(this), this.disableButtons(), t.Instances.controllKeyboard.removeControl(), this.tweenLocation && (this.tweenLocation.onComplete.removeAll(), this.tweenLocation.stop()), this.tweenButton && (this.tweenButton.onComplete.removeAll(), this.tweenButton.stop()), this.tweenMap && this.tweenMap.stop(); for (var i = 1; i < 6; i++) t.Instances.dataManager.getLevelCompleted(i - 1) && Ph2.UISystem.findObject("aliens_left/level_container/star" + i, this.mapUi).ph2Animations.stop(), t.Instances.dataManager.getLevelCompleted(i + 4) && Ph2.UISystem.findObject("aliens_right/level_container/star" + i, this.mapUi).ph2Animations.stop(), Ph2.UISystem.findObject("aliens_right/level_container/alien" + i + "/lock", this.mapUi).ph2Animations.stop();
            this.alienCursorBase.ph2Animations.stop(), this.bossCursor.ph2Animations.stop(), this.bossCursor.children[0].ph2Animations.stop(), this.bossCursor.ph2Animations.stop(), this.mapLevelsUnlock = null, this.bossCursor = null, this.mainGroup = null, this.bg = null, this.alienCursor = null, this.alienCursorBase = null, this.playButton = null, this.exitButton = null, this.controlsButton = null, this.locationText = null, this.mapCursor = null, this.mapMarks = null, this.mapBg = null, this.lastButton = null, this.leftRow = null, this.rightRow = null, this.locationText = null, this.tutorialUi = null, this.overlay = null, this.game.time.events.removeAll() }, i }(Phaser.State);
    t.LevelSelectState = e }(Game || (Game = {}));
var Game;
! function(t) {! function(t) { t[t.GAMEPLAY1 = 0] = "GAMEPLAY1", t[t.GAMEPLAY2 = 1] = "GAMEPLAY2", t[t.GAMEPLAY3 = 2] = "GAMEPLAY3", t[t.GAMEPLAY4 = 3] = "GAMEPLAY4", t[t.BOSS = 4] = "BOSS", t[t.MENU = 5] = "MENU" }(t.MusicID || (t.MusicID = {})); var e = function() {
        function t() {} return t.initAudio = function(e) { e.onBlur.add(t.onBlur, t, 0, e), e.onFocus.add(t.onFocus, t, 0, e) }, t.loadAudioSprite = function(e, i) { var o = e.cache.getJSON(i),
                n = (o.urls.length, ["assets/audio/audiosprite.ogg?v=" + version, "assets/audio/audiosprite.mp3?v=" + version, "assets/audio/audiosprite.m4a?v=" + version]);
            t.audiosprite = new Howl({ src: n, preload: !0, sprite: o.sprite }), e.ph2AudioManager.setAudioEffectsFile(t.audiosprite) }, t.onBlur = function(e, i) { t.pauseMusic(i), t.pauseAllSfx() }, t.onFocus = function(e, i) { t.resumeMusic(i), t.resumeAllSfx() }, t.playMusic = function(e, i) { t.lastMusicID = i, e.ph2AudioManager.switchMusic(t.music[i]), e.ph2AudioManager.setVolumeCurrentMusic(t.currentVolumen) }, t.stopMusic = function(t) { t.ph2AudioManager.stopMusic() }, t.pauseMusic = function(t) { t.ph2AudioManager.pauseMusic() }, t.resumeMusic = function(t) { t.ph2AudioManager.resumeMusic() }, t.changeMusicVolume = function(e, i) { t.currentVolumen = i, e.ph2AudioManager.setVolumeCurrentMusic(i) }, t.playSfx = function(e, i) { var o = e.ph2AudioManager.playEffect(i, !1);
            t.addSoundPlaying(o) }, t.playSfxZone = function(e, i) { var o = e.camera.view,
                n = new Phaser.Rectangle(i.x, i.y, i.width, i.height);
            Phaser.Rectangle.intersects(n, o) && t.playSfx(e, i.key) }, t.playLoopSfx = function(e, i) { var o = e.ph2AudioManager.playEffect(i, !0);
            t.addSoundLoopPlaying(i, o) }, t.addSoundPlaying = function(e) { null !== e && (t.sfxPlaying.push(e), t.audiosprite.on("end", function() { t.removeSoundPlaying(e) }, e)) }, t.addSoundLoopPlaying = function(e, i) { null !== i && (t.sfxLoopPlaying[e] = i) }, t.removeSoundPlaying = function(e) { t.sfxPlaying.splice(t.sfxPlaying.indexOf(e), 1) }, t.removeSoundLoop = function(e) { t.sfxPlaying.splice(t.sfxPlaying.indexOf(t.sfxLoopPlaying[e]), 1), delete t.sfxLoopPlaying[e] }, t.stopLoopSfx = function(e, i) { t.sfxLoopPlaying.hasOwnProperty(i) && (e.ph2AudioManager.stopLoopEffect(i), t.removeSoundLoop(i)) }, t.resumeAllSfx = function() { for (var e = 0, i = t.sfxPlaying.length; e < i; e++) t.audiosprite.play(t.sfxPlaying[e]); for (var o in t.sfxLoopPlaying) t.sfxLoopPlaying.hasOwnProperty(o) && t.audiosprite.play(t.sfxLoopPlaying[o]) }, t.pauseAllSfx = function() { for (var e = 0, i = t.sfxPlaying.length; e < i; e++) t.audiosprite.pause(t.sfxPlaying[e]); for (var o in t.sfxLoopPlaying) t.sfxLoopPlaying.hasOwnProperty(o) && t.audiosprite.pause(t.sfxLoopPlaying[o]) }, t.music = [new Howl({ src: ["assets/audio/music/music_gp1.ogg?v=" + version, "assets/audio/music/music_gp1.mp3?v=" + version, "assets/audio/music/music_gp1.m4a?v=" + version], preload: !0, loop: !0 }), new Howl({ src: ["assets/audio/music/music_gp2.ogg?v=" + version, "assets/audio/music/music_gp2.mp3?v=" + version, "assets/audio/music/music_gp2.m4a?v=" + version], preload: !0, loop: !0 }), new Howl({ src: ["assets/audio/music/music_gp3.ogg?v=" + version, "assets/audio/music/music_gp3.mp3?v=" + version, "assets/audio/music/music_gp3.m4a?v=" + version], preload: !0, loop: !0 }), new Howl({ src: ["assets/audio/music/music_gp4.ogg?v=" + version, "assets/audio/music/music_gp4.mp3?v=" + version, "assets/audio/music/music_gp4.m4a?v=" + version], preload: !0, loop: !0 }), new Howl({ src: ["assets/audio/music/music_boss.ogg?v=" + version, "assets/audio/music/music_boss.mp3?v=" + version, "assets/audio/music/music_boss.m4a?v=" + version], preload: !0, loop: !0 }), new Howl({ src: ["assets/audio/music/music_menu.ogg?v=" + version, "assets/audio/music/music_menu.mp3?v=" + version, "assets/audio/music/music_menu.m4a?v=" + version], preload: !0, loop: !0 })], t.sfxPlaying = [], t.sfxLoopPlaying = {}, t.lastMusicID = null, t.currentVolumen = 1, t }();
    t.Audios = e }(Game || (Game = {}));
var Game;
! function(t) {! function(t) { t[t.left = 0] = "left", t[t.right = 1] = "right", t[t.up = 2] = "up", t[t.down = 3] = "down" }(t.ArrowDirection || (t.ArrowDirection = {}));! function(t) { t[t.None = 0] = "None", t[t.Player = 1] = "Player", t[t.Map = 2] = "Map", t[t.Enemies = 4] = "Enemies", t[t.Platforms = 8] = "Platforms", t[t.Damage = 16] = "Damage", t[t.Bullets = 32] = "Bullets", t[t.Items = 64] = "Items", t[t.Breakable = 128] = "Breakable", t[t.Invulnerable = 256] = "Invulnerable", t[t.EnemyInvulnerable = 512] = "EnemyInvulnerable", t[t.All = 65535] = "All" }(t.CollisionLayers || (t.CollisionLayers = {}));! function(t) { t[t.FourArms = 0] = "FourArms", t[t.XLR8 = 1] = "XLR8", t[t.Stinkfly = 2] = "Stinkfly", t[t.Slapback = 3] = "Slapback", t[t.Cannonbolt = 4] = "Cannonbolt", t[t.Heatblast = 5] = "Heatblast", t[t.Rath = 6] = "Rath", t[t.Humungousaur = 7] = "Humungousaur", t[t.DiamondHead = 8] = "DiamondHead", t[t.ShockRock = 9] = "ShockRock" }(t.CharactersEnum || (t.CharactersEnum = {})), t.CharactersTag = ["fourarms", "xlr8", "stinkfly", "slapback", "cannonbolt", "heatblast", "rath", "humungousaur", "diamondhead", "shockrock"];! function(t) { t[t.MeleeFollower = 0] = "MeleeFollower", t[t.MeleeBerserker = 1] = "MeleeBerserker", t[t.MeleeElite = 2] = "MeleeElite" }(t.EnemiesEnum || (t.EnemiesEnum = {})) }(Game || (Game = {}));
var Constants = function() {
        function t() {} return t.GAME_SCALE = 1, t.CALCULATED_WIDTH = 0, t.CALCULATED_HEIGHT = 0, t.GAME_WIDTH = 1280, t.GAME_HEIGHT = 720, t.SHOW_VIDEO = !0, t.VIDEO_WIDTH = 1920, t.VIDEO_HEIGHT = 1080, t.GAME_RATIO = 1, t.LANDSCAPE_LOCKED = !0, t.PORTRAIT_LOCKED = !1, t.AUTO_FULLSCREEN_ENABLED = !0, t.STORAGE_NAMESPACE = "ben10WR_v1.5", t.DATA_VERSION = 1, t.CHEATS_ENABLED = !1, t.PHYSICS_DEBUG_ENABLED = !1, t.DEBUG_ENABLED = !1, t.CHUNKS_ENABLED = !1, t.ALL_LEVELS_UNLOCKED = !1, t.DEBUG_MOBILE_INPUT = !1, t.LOAD_TRAPS = !0, t.LOAD_DECORATIONS = !0, t.defaultStyle = { font: "bold 20pt Arial", fill: "#fff", strokeThickness: 3, boundsAlignH: "center" }, t.redTextStyle = { font: "bold 20pt Arial", fill: "#f00", strokeThickness: 1, boundsAlignH: "center" }, t }(),
    GameData = function() {
        function t() {} return t.sizeWaveWidth = 1280, t.sizeWaveHeight = 720, t.offsetWaveY = 200, t.platformsMaxDistance = 265, t.diaFlipMask = 1 << 29, t.verFlipMask = 1 << 30, t.horFlipMask = 1 << 31, t.idMask = -1 ^ (t.diaFlipMask | t.verFlipMask | t.horFlipMask), t.PixToMet = 50, t.GroundClearanceAngle = Phaser.Math.degToRad(50), t.GroundClearanceAngleCos = Math.cos(t.GroundClearanceAngle), t.GroundClearanceAngleSin = Math.sin(t.GroundClearanceAngle), t.Angle45Cos = Math.cos(Phaser.Math.degToRad(45)), t.Angle45Sin = Math.sin(Phaser.Math.degToRad(45)), t.sqrt2inv = 1 / Math.sqrt(2), t.zeroPoint = new Phaser.Point(0, 0), t.gameWinDelay = 3, t.gameLoseDelay = .5, t.lifeenergyPackBodySize = 35, t.lifeenergyPlusPackBodySize = 45, t.arrowMarkerTime = 2, t.locationById = ["PARIS", "RIO", "TOKYO", "YUCATAN", "LONDON", "LONDON", "TOKYO", "RIO", "PARIS", "YUCATAN", "NORTH POLE", "PARIS", "RIO", "TOKYO", "YUCATAN", "LONDON", "LONDON", "TOKYO", "RIO", "PARIS", "YUCATAN", "BOSS2"], t.checkPointOffsetX = -170, t.lowFallSpeed = 300, t.highFallSpeed = 1500, t.AliensCount = 10, t.AliensPerMission = 5, t.LevelsPerMission = 11, t.cameraOffsetX = 0, t.cameraOffsetY = -200, t.idleTimer = 10, t.invulnerabilityTimeSoft = 2, t.invulnerabilityTimeHard = 4, t.stunTime = .75, t.stunImpulseX = 350, t.stunImpulseY = 1200, t.benIntroSpeed = .5, t.actionShakeIntensity = .006, t.actionShakeDuration = 200, t.fourarmsSuperWidth = 400, t.fourarmsSuperHeight = 100, t.xlr8SuperWidth = 400, t.xlr8SuperHeight = 100, t.stinkflySuperCooldown = 1, t.stinkflyAcidPoolHitRate = 1, t.stinkflyAcidPoolDuration = 10, t.slapbackSuperWidth = 800, t.slapbackSuperHeight = 700, t.cannonboltChargingTime = .25, t.heatblastSuperCooldown = 1, t.rathChargingTime = .5, t.humungousaurSuperWidth = 500, t.humungousaurSuperHeight = 100, t.diamondheadSuperWidth = 400, t.diamondheadSuperHeight = 100, t.shockrockSuperWidth = 500, t.shockrockSuperHeight = 400, t.healthPackRestore = 50, t.powerPackRestore = 40, t.healthPackIncrease = 10, t.powerPackIncrease = 20, t.enemyCollisionMask = Game.CollisionLayers.Map | Game.CollisionLayers.Damage | Game.CollisionLayers.Bullets | Game.CollisionLayers.Breakable, t.LaserSpeed = 7, t.LaserSpeedTurret = 4, t.LaserMaxBounces = 2, t.LaserMaxDistance = 1e3, t.sightExtents = 110, t.enemySlowSpeed = 2, t.invulnerabilityEnemyTimeSoft = .25, t.invulnerabilityEnemyTimeHard = 1.5, t.enemyStunImpulseX = 200, t.enemyStunImpulseY = 500, t.enemyRangeBScapeDistance = 100, t.enemyRangeBWavePathMargins = 80, t.enemyMeleeBDashDamage = 25, t.enemyMeleeBDashDistance = 500, t.enemyMeleeBDashSpeed = 13, t.enemyMeleeBRestTime = .7, t.enemyMeleeCJumpSpeedX = 500, t.enemyMeleeCJumpSpeedY = -1e3, t.enemyMeleeCDiagonalSpeed = 600, t.enemyMeleeCChargeTime = .6, t.waveStartDelay = 2, t.waveSetDelay = 2, t.waveSpawnTime = 1, t.waveNewFloorTime = 2, t.waveEndDelay = .6, t.waveMaxAlive = 3, t.damageSkinLife = 20, t.rechaseTime = 0, t.spikesDamage = 10, t.wallsLife = 60, t.sawSpeed = 70, t.sawDamage = 20, t.sawAngle = 0, t.steamWallTimeChangeState = 2e3, t.steamWallStartActive = !1, t.steamWallDamage = 15, t.laserSurfaceTimeChangeState = 2e3, t.laserSurfaceStartActive = !1, t.laserSurfaceDamage = 10, t.fireWallTimeChangeState = 2e3, t.fireWallStartActive = !1, t.fireWallDamage = 20, t.mineDamage = 20, t.pendulumDamage = 20, t.pendulumAngle = 70, t.pendulumTime = 2e3, t.platformSpeed = 250, t.platformIdleTime = .5, t.BossAudioFadeTime = 1.5, t.Boss1DashSpeed = 15, t.Boss1WhipSpeed = 15, t.Boss1WalkSpeed = 10, t.Boss1BodyWidth = 100, t.Boss1BodyHeight = 200, t.Boss1DashHitboxWidth = 100, t.Boss1DashHitboxHeight = 150, t.Boss1DashHitboxOffsetX = 50, t.Boss1DashHitboxOffsetY = 50, t.Boss1DashDamage = 10, t.Boss1WhipDamage = 10, t.Boss1Lifes = [300, 350, 450], t.Boss1FacingDistance = 560, t.Boss1Padding = 150, t.Boss1DashDelay = 1, t.Boss1WhipDelay = 1, t.Boss1Wave = [
            [0, 0],
            [0, 0],
            [0, 0]
        ], t.Boss1WaveSpawnTime = .4, t.Boss2Padding = 150, t.Boss2Life = 300, t.Boss2JumpDamage = 10, t.Boss2WalkSpeed = 10, t.Boss2FacingDistance = 560, t.Boss2BodyWidth = 100, t.Boss2BodyHeight = 200, t.Boss2JumpHitboxWidth = 100, t.Boss2JumpHitboxHeight = 250, t.Boss2JumpHitboxOffsetX = 0, t.Boss2JumpHitboxOffsetY = 30, t.Boss2TimeStand = 2, t.Boss2JumpDistanceX = 500, t.Boss2JumpDistanceY = 700, t.Boss2JumpDuration = 1, t.Boss2CountsJump = 3, t.Boss3BodyWidth = 100, t.Boss3BodyHeight = 200, t.Boss3Padding = 150, t.Boss3Life = 350, t.Boss3FacingDistance = 560, t.Boss3DashSpeed = 15, t.Boss3WalkSpeed = 10, t.Boss3DashDelay = 1.5, t.Boss3DashDamage = 10, t.Boss3DashHitboxWidth = 100, t.Boss3DashHitboxHeight = 150, t.Boss3DashHitboxOffsetX = 50, t.Boss3DashHitboxOffsetY = 50, t.Boss3TotalSpikesInArea = 8, t.Boss3SpikeDelay = 1.5, t.Boss3SpikeWidth = 100, t.Boss3SpikeHeight = 100, t.Boss3SpikeOffsetY = 5, t.Boss3SpikeMoveSpeed = 150, t.Boss3SpikeDamage = 20, t.Boss3SpikeSecuenceTime = .3, t.Boss3SpikeLifeTime = 2, t.Boss3SpikesProgresiveHiding = !1, t.Boss3ChangeSideAlone = !1, t.Boss4WalkSpeed = 10, t.Boss4FacingDistance = 560, t.Boss4BodyWidth = 60, t.Boss4BodyHeight = 120, t.Boss4Padding = 150, t.Boss4ShootPositionY = [200, 0, 400], t.Boss4ShootDamage = 10, t.Boss4ShootCooldown = 1, t.Boss4ShootTimeLife = 5, t.Boss4ShootOffsetX = 40, t.Boss4ShootOffsetY = -20, t.Boss4ShootVelcoity = 7, t.Boss4DashHitboxWidth = 60, t.Boss4DashHitboxHeight = 120, t.Boss4DashHitboxOffsetX = 0, t.Boss4DashHitboxOffsetY = 0, t.Boss4DashSpeed = 15, t.Boss4DashDelay = 2, t.Boss4DashDamage = 10, t.Boss4FallVelocity = .6, t }(),
    PlayerParameters = function() {
        function t() {} return t.FourArms = { speed: 13, damage: 25, jump: 30, doubleJump: !1, bodyWidth: 100, bodyHeight: 170, hitComboCount: 4, hitCooldown: 650, connectedHitCooldown: 350, hitWidth: 250, hitHeight: 90, shoot: !1, shootCooldown: 300, shootMaxDistance: 500, shootSpeed: 20, healthPoints: 100, specialPoints: 100, specialCost: 20, specialDamage: 120 }, t.XLR8 = { speed: 20, damage: 20, jump: 30, doubleJump: !1, bodyWidth: 70, bodyHeight: 90, hitComboCount: 2, hitCooldown: 600, connectedHitCooldown: 300, hitWidth: 180, hitHeight: 90, shoot: !1, shootCooldown: 300, shootMaxDistance: 500, shootSpeed: 20, healthPoints: 100, specialPoints: 100, specialCost: 20, specialDamage: 60 }, t.Stinkfly = { speed: 14, damage: 20, jump: 30, doubleJump: !0, bodyWidth: 60, bodyHeight: 140, hitComboCount: 0, hitCooldown: 1e3, connectedHitCooldown: 500, hitWidth: 180, hitHeight: 90, shoot: !0, shootCooldown: 450, shootMaxDistance: 500, shootSpeed: 20, healthPoints: 100, specialPoints: 100, specialCost: 20, specialDamage: 20 }, t.Slapback = { speed: 13, damage: 20, jump: 30, doubleJump: !1, bodyWidth: 90, bodyHeight: 120, hitComboCount: 3, hitCooldown: 750, connectedHitCooldown: 400, hitWidth: 180, hitHeight: 90, shoot: !1, shootCooldown: 300, shootMaxDistance: 500, shootSpeed: 20, healthPoints: 100, specialPoints: 100, specialCost: 20, specialDamage: 60 }, t.Cannonbolt = { speed: 13, damage: 25, jump: 32, doubleJump: !1, bodyWidth: 120, bodyHeight: 90, hitComboCount: 3, hitCooldown: 750, connectedHitCooldown: 450, hitWidth: 180, hitHeight: 90, shoot: !1, shootCooldown: 300, shootMaxDistance: 650, shootSpeed: 50, healthPoints: 100, specialPoints: 100, specialCost: 20, specialDamage: 60 }, t.Heatblast = { speed: 10, damage: 20, jump: 30, doubleJump: !0, bodyWidth: 60, bodyHeight: 140, hitComboCount: 3, hitCooldown: 1e3, connectedHitCooldown: 450, hitWidth: 180, hitHeight: 90, shoot: !1, shootCooldown: 450, shootMaxDistance: 1e3, shootSpeed: 20, healthPoints: 100, specialPoints: 100, specialCost: 20, specialDamage: 60 }, t.Rath = { speed: 18, damage: 20, jump: 30, doubleJump: !1, bodyWidth: 90, bodyHeight: 160, hitComboCount: 3, hitCooldown: 1e3, connectedHitCooldown: 300, hitWidth: 180, hitHeight: 90, shoot: !1, shootCooldown: 300, shootMaxDistance: 500, shootSpeed: 50, healthPoints: 100, specialPoints: 100, specialCost: 20, specialDamage: 60 }, t.Humungousaur = { speed: 13, damage: 30, jump: 30, doubleJump: !1, bodyWidth: 120, bodyHeight: 220, hitComboCount: 3, hitCooldown: 1e3, connectedHitCooldown: 450, hitWidth: 180, hitHeight: 90, shoot: !1, shootCooldown: 300, shootMaxDistance: 500, shootSpeed: 20, healthPoints: 100, specialPoints: 100, specialCost: 20, specialDamage: 150 }, t.DiamondHead = { speed: 17, damage: 20, jump: 30, doubleJump: !1, bodyWidth: 80, bodyHeight: 160, hitComboCount: 3, hitCooldown: 1e3, connectedHitCooldown: 450, hitWidth: 180, hitHeight: 90, shoot: !1, shootCooldown: 300, shootMaxDistance: 500, shootSpeed: 20, healthPoints: 100, specialPoints: 100, specialCost: 20, specialDamage: 60 }, t.ShockRock = { speed: 14, damage: 20, jump: 30, doubleJump: !1, bodyWidth: 110, bodyHeight: 170, hitComboCount: 3, hitCooldown: 1e3, connectedHitCooldown: 500, hitWidth: 180, hitHeight: 90, shoot: !1, shootCooldown: 300, shootMaxDistance: 500, shootSpeed: 20, healthPoints: 100, specialPoints: 100, specialCost: 20, specialDamage: 60 }, t }(),
    EnemiesParameters = function() {
        function t() {} return t.Enemy0 = { speed: 4, jump: 30, damage: 10, hitTimer: 750, bodyWidth: 70, bodyHeight: 110, chaseDistance: 700, hitDistance: 150, stuntTime: 1e3, idleTime: 500, healthPoints: 60, hitWidth: 150, hitHeight: 90 }, t.Enemy1 = { speed: 4, jump: 30, damage: 20, hitTimer: 1500, bodyWidth: 100, bodyHeight: 150, chaseDistance: 400, hitDistance: 150, stuntTime: 1200, idleTime: 750, healthPoints: 120, hitWidth: 200, hitHeight: 90 }, t.Enemy2 = { speed: 6, jump: 30, damage: 20, hitTimer: 1e3, bodyWidth: 120, bodyHeight: 0, chaseDistance: 600, hitDistance: 200, stuntTime: 1e3, idleTime: 1e3, healthPoints: 100, hitWidth: 100, hitHeight: 0 }, t.Enemy3 = { speed: 4, jump: 30, damage: 20, hitTimer: 2500, bodyWidth: 80, bodyHeight: 80, chaseDistance: 600, hitDistance: 1e3, stuntTime: 1e3, idleTime: 1e3, healthPoints: 20, hitWidth: 0, hitHeight: 0 }, t.Enemy4 = { speed: 4, jump: 30, damage: 10, hitTimer: 1500, bodyWidth: 70, bodyHeight: 110, chaseDistance: 600, hitDistance: 200, stuntTime: 1e3, idleTime: 1e3, healthPoints: 60, hitWidth: 0, hitHeight: 0 }, t.Enemy5 = { speed: 6, jump: 30, damage: 20, hitTimer: 750, bodyWidth: 80, bodyHeight: 80, chaseDistance: 600, hitDistance: 600, stuntTime: 750, idleTime: 1e3, healthPoints: 50, hitWidth: 0, hitHeight: 0 }, t.Enemy6 = { speed: 3, jump: 30, damage: 1, hitTimer: 4e3, bodyWidth: 80, bodyHeight: 170, chaseDistance: 600, hitDistance: 600, stuntTime: 1e3, idleTime: 2e3, healthPoints: 50, hitWidth: 0, hitHeight: 0 }, t }(),
    Game;
! function(t) { var e = function() {
        function e() {} return e.initKeyboard = function(t) { e.keyboardKey = t.cache.getJSON("keys") }, e.initControlKeyboard = function(i) { null === e.controllKeyboard && (e.controllKeyboard = new t.ControllerKeyboard(i)) }, e.initLocalization = function(i) { null === e.localizationManager && (e.localizationManager = new t.LocalizationManager(i)) }, e.initVisibilityManager = function(i) { null === e.visibilityManager && (e.visibilityManager = new t.VisibilityManager(i)) }, e.initCameraManager = function(i) { null === e.cameraManager && (e.cameraManager = new t.CameraManager(i)) }, e.IncorrectOrientation = !1, e.fileListenerInitiated = !1, e.currentMission = 0, e.currentLevelId = 0, e.currentLevelFounditem = null, e.keyboardKey = null, e.isGameplayActive = !1, e.controllKeyboard = null, e.localizationManager = null, e.visibilityManager = null, e.pathLoads = [], e.cameraManager = null, e }();
    t.Instances = e }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function e(t) { this.game = t } return e.prototype.init = function(e) { this.player = e, this.lastWaveSize = null, this.camareComponentManager = Ph2.ComponentPlugin.initComponents(this.game.camera), this.cameraMovement = this.camareComponentManager.addComponent(t.CameraMovement, this.player, GameData.cameraOffsetX, GameData.cameraOffsetY) }, e.prototype.followPlayer = function() { this.cameraMovement.follow() }, e.prototype.unFollowPlayer = function() { this.cameraMovement.unFollow() }, e.prototype.setOffset = function(t, e) { this.cameraMovement.setOffset(t, e) }, e.prototype.getOffset = function() { return this.cameraMovement.offset }, e.prototype.focusXY = function(t, e) { this.game.camera.focusOnXY(t, e) }, e.prototype.smoothRefollow = function() { this.cameraMovement.smoothRefollow() }, e.prototype.shake = function(t, e, i) { void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === i && (i = Phaser.Camera.SHAKE_BOTH), this.cameraMovement.shake(t, e, i) }, e.prototype.setBound = function(t, e, i, o) { void 0 === t && (t = null), void 0 === e && (e = null), void 0 === i && (i = null), void 0 === o && (o = null), this.game.camera.bounds.x = null === t ? this.game.camera.bounds.x : t, this.game.camera.bounds.y = null === e ? this.game.camera.bounds.y : e, this.game.camera.bounds.width = null === i ? this.game.camera.bounds.width : i, this.game.camera.bounds.height = null === o ? this.game.camera.bounds.height : o }, e.prototype.initWave = function(t, e, i, o) { this.lastWaveSize = { x: t, y: e, width: i, height: o }, this.cameraMovement.focusWave(t, e, i, o), this.unFollowPlayer() }, e.prototype.endWave = function() { this.setBoundsToWorld(), this.lastWaveSize = null }, e.prototype.setBoundsToWorld = function() { this.game.camera.setBoundsToWorld() }, e.prototype.fixCamera = function() { this.setBound(this.game.camera.x, this.game.camera.y, this.game.width, this.game.height) }, e.prototype.setBoundX = function(t) { this.game.camera.bounds.x = t }, e.prototype.setBoundY = function(t) { this.game.camera.bounds.y = t }, e.prototype.setBoundWidth = function(t) { this.game.camera.bounds.width = t }, e.prototype.setBoundLeft = function(t) { this.game.camera.bounds.left = t }, e.prototype.setBoundRight = function(t) { this.game.camera.bounds.right = t }, e.prototype.setBoundHeight = function(t) { this.game.camera.bounds.height = t }, e.prototype.setBoundRectangle = function(t) { this.game.camera.bounds = t }, e.prototype.resize = function() { this.cameraMovement.resize(), null !== this.lastWaveSize && this.setBound(this.lastWaveSize.x, this.lastWaveSize.y, this.lastWaveSize.width, this.lastWaveSize.height) }, e.prototype.end = function() { this.camareComponentManager.removeAllComponents(), this.camareComponentManager = null, this.player = null, this.cameraMovement = null, this.game.camera.bounds = null }, e }();
    t.CameraManager = e }(Game || (Game = {}));
var Game;
! function(t) { var e;! function(t) { t[t.uiMainMenu = 0] = "uiMainMenu", t[t.uiLevelSelect = 1] = "uiLevelSelect", t[t.uiGameplay = 2] = "uiGameplay", t[t.uiPause = 3] = "uiPause", t[t.uiConfirmation = 4] = "uiConfirmation", t[t.uiFinish = 5] = "uiFinish", t[t.uiGameover = 6] = "uiGameover", t[t.uiSetting = 7] = "uiSetting", t[t.uiTutorial = 8] = "uiTutorial", t[t.uiComic = 9] = "uiComic" }(e = t.ControllerType || (t.ControllerType = {})); var i;! function(t) { t[t.up = 0] = "up", t[t.down = 1] = "down", t[t.left = 2] = "left", t[t.right = 3] = "right", t[t.enter = 4] = "enter", t[t.z = 5] = "z", t[t.esc = 6] = "esc" }(i = t.ButtonKeys || (t.ButtonKeys = {})); var o = function() {
        function o(t) { this.game = t, this.currentButtonEnable = [], this.data = [], this.data[e.uiMainMenu] = { button: [i.up, i.down, i.left, i.right, i.enter, i.z], init: "none", none: { up: "buttonPlay", down: "buttonPlay", left: "buttonPlay", right: "buttonPlay" }, buttonPlay: { up: "buttonSetting", down: null, left: null, right: null }, buttonSetting: { up: null, down: "buttonPlay", left: null, right: null } }, this.data[e.uiLevelSelect] = { button: [i.up, i.down, i.left, i.right, i.enter, i.z, i.esc], init: "0" }, this.data[e.uiComic] = { button: [i.enter, i.z], init: "none" }, this.data[e.uiGameplay] = { button: [i.esc], init: "none" }, this.data[e.uiPause] = { button: [i.up, i.down, i.left, i.right, i.enter, i.z, i.esc], init: "none", none: { up: null, down: null, left: "buttonPlay", right: "buttonPlay" }, buttonExit: { up: null, down: null, left: null, right: "buttonPlay" }, buttonPlay: { up: null, down: null, left: "buttonExit", right: "buttonTutorial" }, buttonTutorial: { up: "buttonSetting", down: null, left: "buttonPlay", right: "buttonSetting" }, buttonSetting: { up: null, down: "buttonTutorial", left: "buttonTutorial", right: null } }, this.data[e.uiConfirmation] = { button: [i.left, i.right, i.enter, i.z, i.esc], init: "none", none: { left: "no", right: "yes" }, yes: { left: "no", right: null }, no: { left: null, right: "yes" } }, this.data[e.uiFinish] = { button: [i.left, i.right, i.enter, i.z], init: "none", none: { left: "finish", right: "finish" }, finish: { left: null, right: null } }, this.data[e.uiSetting] = { button: [i.up, i.down, i.left, i.right, i.enter, i.z, , i.esc], init: "none", none: { up: "buttonPlay", down: "buttonPlay", left: "buttonPlay", right: "buttonPlay" }, buttonPlay: { up: "buttonSfx", down: null, left: "buttonSfx", right: "buttonMusic" }, buttonSfx: { up: null, down: "buttonPlay", left: null, right: "buttonMusic" }, buttonMusic: { up: null, down: "buttonPlay", left: "buttonSfx", right: null } }, this.data[e.uiTutorial] = { button: [i.up, i.down, i.left, i.right, i.enter, i.z, i.esc], init: "none", none: { up: "buttonPlay", down: "buttonPlay", left: "buttonPlay", right: "buttonPlay" }, buttonPlay: { up: null, down: null, left: null, right: null } }, this.initKeys() } return o.prototype.initKeys = function() { this.keys = [], this.keys[Phaser.KeyCode[t.Instances.keyboardKey.up]] = this.game.input.keyboard.addKey(Phaser.KeyCode[t.Instances.keyboardKey.up]), this.keys[Phaser.KeyCode[t.Instances.keyboardKey.down]] = this.game.input.keyboard.addKey(Phaser.KeyCode[t.Instances.keyboardKey.down]), this.keys[Phaser.KeyCode[t.Instances.keyboardKey.left]] = this.game.input.keyboard.addKey(Phaser.KeyCode[t.Instances.keyboardKey.left]), this.keys[Phaser.KeyCode[t.Instances.keyboardKey.right]] = this.game.input.keyboard.addKey(Phaser.KeyCode[t.Instances.keyboardKey.right]), this.keys[Phaser.KeyCode[t.Instances.keyboardKey.enter]] = this.game.input.keyboard.addKey(Phaser.KeyCode[t.Instances.keyboardKey.enter]), this.keys[Phaser.KeyCode[t.Instances.keyboardKey.attack]] = this.game.input.keyboard.addKey(Phaser.KeyCode[t.Instances.keyboardKey.attack]), this.keys[Phaser.KeyCode[t.Instances.keyboardKey.esc]] = this.game.input.keyboard.addKey(Phaser.KeyCode[t.Instances.keyboardKey.esc]) }, o.prototype.setController = function(t, e, i) { void 0 === i && (i = !0), this.controller = t, this.initControl(e, i) }, o.prototype.initControl = function(t, e) { this.removeControl(), this.currentController = t, this.actualButton = this.data[this.currentController].init, this.currentButtonEnable = this.data[this.currentController].button, e && this.controller.onChangeButton(this.actualButton) }, o.prototype.addControl = function() { this.removeControl(); for (var e = 0; e < this.currentButtonEnable.length; e++) switch (this.currentButtonEnable[e]) {
                case i.up:
                    this.keys[Phaser.KeyCode[t.Instances.keyboardKey.up]].onDown.add(this.moveUp, this); break;
                case i.down:
                    this.keys[Phaser.KeyCode[t.Instances.keyboardKey.down]].onDown.add(this.moveDown, this); break;
                case i.left:
                    this.keys[Phaser.KeyCode[t.Instances.keyboardKey.left]].onDown.add(this.moveLeft, this); break;
                case i.right:
                    this.keys[Phaser.KeyCode[t.Instances.keyboardKey.right]].onDown.add(this.moveRight, this); break;
                case i.enter:
                    this.keys[Phaser.KeyCode[t.Instances.keyboardKey.enter]].onDown.add(this.pressEnter, this); break;
                case i.z:
                    this.keys[Phaser.KeyCode[t.Instances.keyboardKey.attack]].onDown.add(this.pressEnter, this); break;
                case i.esc:
                    this.keys[Phaser.KeyCode[t.Instances.keyboardKey.esc]].onDown.add(this.pressEsc, this) } }, o.prototype.removeControl = function() { this.keys[Phaser.KeyCode[t.Instances.keyboardKey.up]].onDown.removeAll(this), this.keys[Phaser.KeyCode[t.Instances.keyboardKey.down]].onDown.removeAll(this), this.keys[Phaser.KeyCode[t.Instances.keyboardKey.left]].onDown.removeAll(this), this.keys[Phaser.KeyCode[t.Instances.keyboardKey.right]].onDown.removeAll(this), this.keys[Phaser.KeyCode[t.Instances.keyboardKey.attack]].onDown.removeAll(this), this.keys[Phaser.KeyCode[t.Instances.keyboardKey.esc]].onDown.removeAll(this), this.keys[Phaser.KeyCode[t.Instances.keyboardKey.enter]].onDown.removeAll(this) }, o.prototype.setButton = function(t, e) { void 0 === e && (e = !0), this.actualButton = t, e && this.controller.onChangeButton(this.actualButton) }, o.prototype.setButtonFlow = function(t, e, i, o, n) { this.data[this.currentController][t] || (this.data[this.currentController][t] = { up: null, down: null, left: null, right: null }), this.data[this.currentController][t].up = e, this.data[this.currentController][t].down = i, this.data[this.currentController][t].left = o, this.data[this.currentController][t].right = n }, o.prototype.moveLeft = function() { var t = this.data[this.currentController][this.actualButton].left;
            null !== t && (this.actualButton = t, this.controller.onChangeButton(t)) }, o.prototype.moveRight = function() { var t = this.data[this.currentController][this.actualButton].right;
            null !== t && (this.actualButton = t, this.controller.onChangeButton(t)) }, o.prototype.moveUp = function() { var t = this.data[this.currentController][this.actualButton].up;
            null !== t && (this.actualButton = t, this.controller.onChangeButton(t)) }, o.prototype.moveDown = function() { var t = this.data[this.currentController][this.actualButton].down;
            null !== t && (this.actualButton = t, this.controller.onChangeButton(t)) }, o.prototype.pressEnter = function() { this.controller.onPressButton(this.actualButton) }, o.prototype.pressEsc = function() { this.controller.onPressBack() }, o }();
    t.ControllerKeyboard = o }(Game || (Game = {}));
var Game;
! function(t) { var e;! function(t) { t[t.health = 0] = "health", t[t.power = 1] = "power" }(e = t.ItemFoundType || (t.ItemFoundType = {})); var i = function() {
        function t(t) { this.game = t, this.isFirstTimeInSession = !0, this.checkIfDataExists() } return t.prototype.checkIfDataExists = function() { if (null == this.game.storage.getItem("gameData" + language)) this.createData(), this.isFirstTime = !0;
            else { this.isFirstTime = !1; try { this.gameData = JSON.parse(this.game.storage.getItem("gameData" + language)) } catch (t) { this.resetAllData() } } }, t.copyPlayerParameters = function(t, e) { e.speed = t.speed, e.damage = t.damage, e.jump = t.jump, e.doubleJump = t.doubleJump, e.bodyWidth = t.bodyWidth, e.bodyHeight = t.bodyHeight, e.hitComboCount = t.hitComboCount, e.hitCooldown = t.hitCooldown, e.connectedHitCooldown = t.connectedHitCooldown, e.hitWidth = t.hitWidth, e.hitHeight = t.hitHeight, e.shoot = t.shoot, e.shootCooldown = t.shootCooldown, e.shootMaxDistance = t.shootMaxDistance, e.shootSpeed = t.shootSpeed, e.healthPoints = t.healthPoints, e.specialPoints = t.specialPoints, e.specialCost = t.specialCost, e.specialDamage = t.specialDamage }, t.copyEnemyParameters = function(t, e) { e.speed = t.speed, e.jump = t.jump, e.damage = t.damage, e.hitTimer = t.hitTimer, e.bodyWidth = t.bodyWidth, e.bodyHeight = t.bodyHeight, e.chaseDistance = t.chaseDistance, e.hitDistance = t.hitDistance, e.stuntTime = t.stuntTime, e.idleTime = t.idleTime, e.healthPoints = t.healthPoints, e.hitWidth = t.hitWidth, e.hitHeight = t.hitHeight }, t.prototype.createData = function() { var t;
            t = { soundEnabled: !0, musicEnabled: !0, levels: [], itemsHealth: 0, itemsPower: 0, tutorialShown: !1, secondPartUnlocked: !1, version: Constants.DATA_VERSION }; for (var e = 0; e < 22; e++) { var i = void 0;
                i = { completed: !1, itemPicked: !1, itemFoundType: null }, t.levels.push(i) } this.gameData = t, this.game.storage.setItem("gameData" + language, JSON.stringify(t)) }, t.prototype.resetAllData = function() { this.game.storage.clear(), location.reload(!0) }, t.prototype.getLevelCompleted = function(t) { return this.gameData.levels[t].completed }, t.prototype.isAllLevelCompleted = function() { for (var t = 0; t < 10; t++)
                if (!this.gameData.levels[t].completed) return !1; return !0 }, t.prototype.getLevelItemFound = function(t) { if (!(t < 0)) return this.gameData.levels[t].itemPicked }, t.prototype.getLevelItemType = function(t) { return this.gameData.levels[t].itemFoundType }, t.prototype.getItemsHealth = function() { return this.gameData.itemsHealth }, t.prototype.getItemsPower = function() { return this.gameData.itemsPower }, t.prototype.savelevelItemFound = function(t, i) { i === e.health ? this.gameData.itemsHealth++ : this.gameData.itemsPower++, this.gameData.levels[t].itemPicked = !0, this.gameData.levels[t].itemFoundType = i }, t.prototype.saveLevelComplete = function(t) { this.gameData.levels[t].completed = !0, this.saveData() }, t.prototype.saveData = function() { this.game.storage.setItem("gameData" + language, JSON.stringify(this.gameData)) }, t.prototype.getSoundState = function() { return this.gameData.soundEnabled }, t.prototype.getMusicState = function() { return this.gameData.musicEnabled }, t.prototype.saveSoundState = function(t) { this.gameData.soundEnabled = t, this.saveData() }, t.prototype.saveMusicState = function(t) { this.gameData.musicEnabled = t, this.saveData() }, t.prototype.isTutorialPending = function() { return !this.gameData.tutorialShown }, t.prototype.saveTutorialComplete = function() { this.gameData.tutorialShown = !0, this.saveData() }, t.prototype.isFirstLaunch = function() { return this.isFirstTime }, t.prototype.endFirstLaunch = function() { this.isFirstTime = !1 }, t.prototype.isSecondMissionUnlocked = function() { return this.gameData.secondPartUnlocked || Constants.ALL_LEVELS_UNLOCKED }, t.prototype.unlockSecondMission = function() { this.gameData.secondPartUnlocked = !0, this.saveData() }, t.prototype.lockSecondMission = function() { this.gameData.secondPartUnlocked = !1, this.saveData() }, t }();
    t.DataManager = i }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function t(t) { this.game = t, this.jsonKey = "localization", this.localizationData = this.game.cache.getJSON(this.jsonKey), this.charInitArg = "{", this.charEndArg = "}" } return t.prototype.localizeUIText = function(t, e, i, o) { void 0 === o && (o = !1); for (var n = [], s = 4; s < arguments.length; s++) n[s - 4] = arguments[s]; var r, a; return r = Ph2.UISystem.findObject(t, e), a = "number" == typeof i ? i.toString() : i, o || (a = this.getSringForKey.call(this, i, n)), r.text = a, r }, t.prototype.localizeAnimText = function(t, e, i, o) { void 0 === o && (o = !1); for (var n = [], s = 4; s < arguments.length; s++) n[s - 4] = arguments[s]; var r, a; return r = Ph2.AnimationSystem.findObject(t, e), a = i, o || (a = this.getSringForKey.call(this, i, n)), r.clearColors(), r.text = a, r }, t.prototype.getSringForKey = function(t) { for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i]; for (var o = this.localizationData[t], n = o.indexOf(this.charInitArg) + 1, s = o.indexOf(this.charEndArg), r = 0, a = o.substring(n, s);
                "" !== a && r < e.length;) o = o.split(this.charInitArg + a + this.charEndArg).join(e[r]), r++, n = o.indexOf(this.charInitArg) + 1, s = o.indexOf(this.charEndArg), a = o.substring(n, s); return o }, t.prototype.addSpriteTo = function(t) { for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i]; for (var o = this.localizationData[t], n = o.indexOf(this.charInitArg) + 1, s = o.indexOf(this.charEndArg), r = 0, a = o.substring(n, s);
                "" !== a && r < e.length;) o = o.split(this.charInitArg + a + this.charEndArg).join(e[r]), r++, n = o.indexOf(this.charInitArg) + 1, s = o.indexOf(this.charEndArg), a = o.substring(n, s); return o }, t.prototype.localizeNumber = function(t, e) { var i = e || 0,
                o = this.getSringForKey("number.decimal_separator"),
                n = this.getSringForKey("number.thousands_separator"); if (null !== o && null !== n) return this._numberFormat(t, i, o, n) }, t.prototype._numberFormat = function(t, e, i, o) { var n = isFinite(+t) ? +t : 0,
                s = isFinite(+e) ? Math.abs(e) : 0,
                r = void 0 === typeof o ? "," : o,
                a = void 0 === typeof i ? "." : i,
                h = (s ? this._toFixedFix(n, s) : Math.round(n)).toString().split("."); return h[0].length > 3 && (h[0] = h[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, r)), (h[1] || "").length < s && (h[1] = h[1] || "", h[1] += new Array(s - h[1].length + 1).join("0")), h.join(a) }, t.prototype._toFixedFix = function(t, e) { var i = Math.pow(10, e); return Math.round(t * i) / i }, t }();
    t.LocalizationManager = e }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function t(t, e) { this.game = t, this.urlVideo = e, this.onCompleteVideo = new Phaser.Signal, this.createVideo() } return t.prototype.createVideo = function() { var t = this;
            document.getElementById("video_holder").style.display = "block", this.video = videojs("video_player"), this.video.src({ type: "video/mp4", src: this.urlVideo }), this.video.width(Constants.VIDEO_WIDTH), this.video.height(Constants.VIDEO_HEIGHT), this.video.ready(function() { var e, i = t.video.getChild("bigPlayButton"),
                    o = t.video.width() / t.video.height(),
                    n = window.innerWidth / window.innerHeight;
                document.getElementById("content").style.display = "none", i.hide(), n > o ? (t.video.width(window.innerWidth), t.video.height(Math.round(window.innerWidth / o)), document.getElementById("video_player").style.top = "-" + Math.round(.5 * Math.abs(window.innerHeight - t.video.height())) + "px") : (t.video.width(Math.round(window.innerHeight * o)), t.video.height(window.innerHeight), document.getElementById("video_player").style.left = "-" + Math.round(.5 * Math.abs(window.innerWidth - t.video.width())) + "px"), t.game.time.events.add(1e3, function() { t.game.device.iOS || t.game.device.safari ? (i.show(), void 0 === (e = t.video.play()) || null === e ? i.show() : e.then(function() { i.show() }, function() { i.show() })) : t.video.play() }, t), t.video.on("ended", function() { t.video.dispose(), t.endVideo() }), t.game.device.iOS || (t.video.on("error", function() { t.video.dispose(), t.endVideo() }), t.video.on("paused", function() { t.video.dispose(), t.endVideo() })) }) }, t.prototype.endVideo = function() { document.getElementById("content").style.display = "block", document.getElementById("video_holder").style.display = "none", this.onCompleteVideo.removeAll(this), this.onCompleteVideo.dispatch() }, t.prototype.destroy = function() { this.onCompleteVideo.removeAll(this), this.video = null, this.game = null }, t }();
    t.VideoManager = e }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function t(t) { this.game = t, this.objectCheck = [], this.lastCheck = 0 } return t.prototype.addObject = function(t, e, i, o, n) { var s = { zoneShow: null, object: null },
                r = new Phaser.Rectangle(e, i, o, n);
            s.object = t, s.zoneShow = r }, t.prototype.update = function() { var t, e = this.game.camera.view; if (this.lastCheck += this.game.time.elapsedMS, this.lastCheck > 100) { this.lastCheck = 0; for (var i = 0, o = this.objectCheck.length; i < o; i++) t = this.objectCheck[i].zoneShow, this.objectCheck[i].object.visible = Phaser.Rectangle.intersects(t, e) } }, t.prototype.destroyAllObjectCheck = function() { for (var t = 0, e = this.objectCheck.length; t < e; t++) this.objectCheck[t].object = null, this.objectCheck[t].zoneShow = null;
            this.objectCheck = [] }, t }();
    t.VisibilityManager = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i() { var i = this,
                o = localStorage.getItem(Constants.STORAGE_NAMESPACE + "_renderer"),
                n = JSON.parse(localStorage.getItem(Constants.STORAGE_NAMESPACE + "_debug"));
            null == n && (n = !1); return null == o && (o = Phaser.CANVAS.toString()), o === Phaser.CANVAS.toString() ? Phaser.CANVAS : Phaser.WEBGL, (i = e.call(this, { enableDebug: Constants.PHYSICS_DEBUG_ENABLED, width: Constants.GAME_WIDTH, height: Constants.GAME_HEIGHT, renderer: Phaser.CANVAS, parent: "content", transparent: !1, antialias: !0, preserveDrawingBuffer: !1, physicsConfig: null, seed: "0", state: null, forceSetTimeOut: !1 }) || this).state.add("bootState", t.BootState, !1), i.state.add("gameplayState", t.GameplayState, !1), i.state.add("preloaderState", t.PreloaderState, !1), i.state.add("mainmenuState", t.MainMenuState, !1), i.state.add("finishState", t.FinishState, !1), i.state.add("levelselectState", t.LevelSelectState, !1), i.state.add("comicState", t.ComicState, !1), Phaser.Device.whenReady(function() { i.stage.disableVisibilityChange = !1; var t = i.device.desktop ? "click" : "touchstart";
                document.getElementById("content").addEventListener(t, function(t) { i.gameResumed(t) }), i.plugins.add(Ph2.LoaderPlugin), i.plugins.add(Ph2.AnimationPlugin), i.plugins.add(Ph2.NotificationPlugin), i.plugins.add(Ph2.AudioPlugin), i.plugins.add(PhaserSuperStorage.StoragePlugin), i.plugins.add(PhaserCachebuster.CacheBuster), i.plugins.add(PhaserSpine.SpinePlugin), i.plugins.add(Ph2.ComponentPlugin), i.plugins.add(Phaser.VirtualJoystick) }), i } return __extends(i, e), i.getInstance = function() { return null === i.instance && (i.instance = new i), i.instance }, i.prototype.start = function() { this.state.start("bootState") }, i.instance = null, i }(Phaser.Game);
    t.App = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e(e, i, o, n, s) { void 0 === s && (s = null); var r = t.call(this, e, i.x, i.y - i.height, Math.min(e.width, i.width), Math.min(e.height, i.height), n, s) || this; if (r.autoCull = !0, r.game = e, r.backgroundObject = i, r.parentGroup = o, r.referencePoint = new Phaser.Point, r.tilePositionOffsetX = 0, r.tilePositionOffsetY = 0, r.limits = { left: r.backgroundObject.x, right: r.backgroundObject.x + r.backgroundObject.width, top: r.backgroundObject.y - r.backgroundObject.height, bottom: r.backgroundObject.y }, r.fixedX = !1, r.fixedY = !1, r.doTile = !1, r.doTileX = !1, r.doTileY = !1, r.doParalax = !1, r.doParalaxX = 0, r.doParalaxY = 0, i.properties)
                for (var a = 0, h = i.properties; a < h.length; a++) { var l = h[a]; switch (l.name) {
                        case "tiled_x":
                            r.doTileX = l.value; break;
                        case "tiled_y":
                            r.doTileY = l.value; break;
                        case "paralax_x":
                            r.doParalaxX = l.value; break;
                        case "paralax_y":
                            r.doParalaxY = l.value } }
            return r.doParalax = 0 !== r.doParalaxX || 0 !== r.doParalaxY, r.doParalax ? !r.doTileY && i.height > r.game.height && (r.height = i.height) : (i.width > r.game.width && (r.doTileX = !0), i.height > r.game.height && (r.doTileY = !0)), r.doTile = r.doTileX || r.doTileY, r.parentGroup.add(r), r.doTileX || (r.texture.frame.width, i.width), r.doTileY || (r.tilePosition.y = -1, r.texture.frame.height, i.height), r } return __extends(e, t), e.prototype.tileUpdate = function() { this.doTile && this.checkTiling(), this.doParalax && this.checkParalax() }, e.prototype.checkTiling = function() { this.doTileX && (this.game.camera.x > this.limits.left && this.game.camera.x + this.game.camera.width < this.limits.right ? (this.doParalax || (this.tilePosition.x = this.limits.left - this.game.camera.x + this.tilePositionOffsetX), this.x = this.game.camera.x, this.fixedX = !1) : this.fixedX || (this.fixedX = !0, this.game.camera.x < this.limits.left && (this.doParalax || (this.tilePosition.x = this.tilePositionOffsetX), this.x = this.limits.left), this.game.camera.x + this.game.camera.width > this.limits.right && (this.doParalax || (this.tilePosition.x = this.limits.left - (this.limits.right - this.game.width) + this.tilePositionOffsetX), this.x = this.limits.right - this.width))), this.doTileY && (this.game.camera.y > this.limits.top && this.game.camera.y + this.game.camera.height < this.limits.bottom ? (this.doParalax || (this.tilePosition.y = this.limits.top - this.game.camera.y + this.tilePositionOffsetY), this.y = this.game.camera.y, this.fixedY = !1) : this.fixedY || (this.fixedY = !0, this.game.camera.y < this.limits.top && (this.doParalax || (this.tilePosition.y = this.tilePositionOffsetY), this.y = this.limits.top), this.game.camera.y + this.game.camera.height > this.limits.bottom && (this.doParalax || (this.tilePosition.y = this.limits.top - (this.limits.bottom - this.game.height) + this.tilePositionOffsetY), this.y = this.limits.bottom - this.height))) }, e.prototype.checkParalax = function() { this.doTileX ? this.tilePosition.x = (this.referencePoint.x - (this.game.camera.x + .5 * this.game.width)) * (1 - this.doParalaxX) : this.x = this.limits.left + (this.referencePoint.x - (this.game.camera.x + .5 * this.game.width)) * (1 - this.doParalaxX), this.doTileY ? this.tilePosition.y = -(this.referencePoint.y - (this.game.camera.y + .5 * this.game.height)) * (1 - this.doParalaxY) : this.y = this.limits.top - (this.referencePoint.y - (this.game.camera.y + .5 * this.game.height)) * (1 - this.doParalaxY) }, e.prototype.setReferencePoint = function(t) { this.referencePoint.set(t.x, t.y) }, e.prototype.resizeController = function() { this.width = Math.min(this.game.width, this.backgroundObject.width) }, e }(Phaser.TileSprite);
    t.BackgroundController = e }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function t(t, e) { void 0 === e && (e = null), this.game = t, this.percent = 1, this.totalWidth = 0, this.bar = e, this.tween = null, this.bar && (this.totalWidth = e.width) } return t.prototype.setPercent = function(t) { t < 0 ? t = 0 : t > 1 && (t = 1), t !== this.percent && (this.percent = t, this.bar && this.game.add.tween(this.bar).to({ width: this.percent * this.totalWidth }, 200, Phaser.Easing.Linear.None, !0)) }, t.prototype.setWidth = function(t) { if (null !== this.bar)
                if (1 === this.percent) this.totalWidth = t, this.bar && (this.bar.width = this.totalWidth);
                else { var e = this.totalWidth / t;
                    this.percent *= e, this.totalWidth = t, this.bar && (this.bar.width = this.percent * this.totalWidth) } }, t.prototype.setTilesprite = function(t) { this.bar = t; var e = this.percent;
            this.percent = 1, this.setWidth(this.bar.width), this.setPercent(e) }, t }();
    t.BarManager = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a, h, l) { var c = e.call(this, i, a - GameData.Boss1Padding, s.y - .5 * s.height, null) || this;
            c.leftBound = r, c.rightBound = a, c.zoneExtend = .5 * (c.rightBound - c.leftBound), c.zoneX = c.leftBound + c.zoneExtend, c.difficulty = h, c.player = o, c.group = n, c.dashSpeed = GameData.Boss1DashSpeed * GameData.PixToMet, c.whipSpeed = GameData.Boss1WhipSpeed * GameData.PixToMet, c.walkSpeed = GameData.Boss1WalkSpeed * GameData.PixToMet, c.timerEvent = null, c.spawnTimerEvent = null, c.normalAux = new box2d.b2Vec2, c.isDashing = !1, c.isDashingBack = !1, c.whipTraveling = !1, c.whipTravelingBack = !1, c.dashDamageActive = !1, c.standingToRight = !0, c.killAfterWhip = !1, c.walkingOut = !1, c.isWaveActive = !1, c.waitingPlayer = !0, c.lookDirection = new Phaser.Point(-1, 0), c.maceDirection = -1, c.waveCounter = 0, c.hitRect = new Phaser.Rectangle(-.5 * GameData.Boss1DashHitboxWidth, -.5 * GameData.Boss1DashHitboxHeight, GameData.Boss1DashHitboxWidth, GameData.Boss1DashHitboxHeight), c.hitCategory = t.CollisionLayers.Player, c.whipOffset = new Phaser.Point(213, 49), c.floorY = c.getFloorPoint(), c.setAudioTrigger(), c.currentLiveEnemies = 1, i.physics.box2d.enable(c), c.body.fixedRotation = !0, c.body.friction = 1, c.body.linearDamping = .5, c.body.setRectangle(GameData.Boss1BodyWidth, GameData.Boss1BodyHeight); var d = new box2d.b2Filter;
            d.categoryBits = t.CollisionLayers.Enemies, d.maskBits = GameData.enemyCollisionMask, c.body.data.m_fixtureList.SetFilterData(d); var u = c.body.addCircle(.5 * GameData.Boss1BodyWidth + 2, 0, .5 * GameData.Boss1BodyHeight); return c.body.setFixtureContactCallback(u, c.contactEntered, c), c.body.data.m_fixtureList.SetFilterData(d), c.groundContactPool = [null, null, null, null], c.lifeManager = new t.LifeManager(GameData.Boss1Lifes[h - 1], c), c.barManager = new t.BarManager(c.game), c.lifeManager.onLostLife.add(c.checkLife, c), c.lifeManager.onNoLife.add(c.setDead, c), c.onStart = new Phaser.Signal, c.onEnd = new Phaser.Signal, c.onGround = !0, c.onWall = !1, c.lastWallContact = null, h > 2 && (c.spawnPoints = [new box2d.b2Vec2(c.leftBound - 100, c.floorY - 200), new box2d.b2Vec2(c.rightBound + 100, c.floorY - 200)], c.spawner = new t.ItemSelector(c.game, c.player, c.spawnPoints, l, c.group), c.enemies = [], c.isWaveActive = !0), c.dashCount = 0, c.maxDashCount = h, c.setWhip(), c.setTrigger(), c.setSpine(), c.createFiniteStateMachine(), c.group.add(c), c.group.add(c.whipMace), Constants.DEBUG_ENABLED && c.setDebugSprite(), c } return __extends(i, e), i.prototype.checkLife = function(t) { this.barManager.setPercent(t), this.isWaveActive && t > 0 && (t <= .25 ? this.waveCounter <= 2 && this.spawner.isSetComplete() && (this.spawner.nextSet(), this.spawnEnemy(), this.waveCounter++, this.isWaveActive = !1) : t <= .5 ? this.waveCounter <= 1 && this.spawner.isSetComplete() && (this.spawner.nextSet(), this.spawnEnemy(), this.waveCounter++) : t <= .75 && 0 === this.waveCounter && (this.spawnEnemy(), this.waveCounter++)) }, i.prototype.setDebugSprite = function() { if (Constants.DEBUG_ENABLED) { var t = this.game.add.graphics(0, 0);
                t.beginFill(16711680, .5), t.drawRect(0, 0, this.hitRect.width, this.hitRect.height), t.endFill(); var e = t.generateTexture();
                t.destroy(), this.hitBoxVisual = this.game.add.sprite(GameData.Boss1DashHitboxOffsetX, GameData.Boss1DashHitboxOffsetX, e), this.hitBoxVisual.anchor.set(.5), this.addChild(this.hitBoxVisual), this.hitBoxVisual.visible = !1 } }, i.prototype.setWhip = function() { this.whipMace = this.game.add.sprite(0, 0, "mace"), this.whipMace.anchor.set(.5), this.whipMace.visible = !1, this.whipTile = this.game.add.tileSprite(this.whipOffset.x, this.whipOffset.y, 0, 53, "whip"), this.whipTile.anchor.set(0, .5), this.addChild(this.whipTile), this.whipTile.visible = !1, this.game.physics.box2d.enable(this.whipMace), this.whipMace.body.setCircle(60), this.whipMace.body.kinematic = !0, this.whipMace.body.sensor = !0, this.whipMace.body.gravityScale = 0, this.whipMace.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Damage, this.whipMace.body.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Player, this.whipMace.body.setCategoryContactCallback(t.CollisionLayers.Player, this.maceEnter, this), this.whipMace.body.data.SetActive(!1) }, i.prototype.setTrigger = function() { var e = this.leftBound,
                i = this.rightBound - e;
            this.triggerSprite = this.game.add.sprite(e + .5 * i, this.floorY - 500), this.game.physics.box2d.enable(this.triggerSprite), this.triggerSprite.body.setRectangle(i, 1e3), this.triggerSprite.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Items, this.triggerSprite.body.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, this.triggerSprite.body.static = !0, this.triggerSprite.body.sensor = !0, this.triggerSprite.body.setBodyContactCallback(this.player, this.triggerEnter, this); var o = new box2d.b2Filter;
            o.categoryBits = t.CollisionLayers.Map, o.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable; var n = .5 * (this.rightBound - this.leftBound);
            this.boundsBody = this.game.physics.box2d.createBody(this.leftBound + n, this.floorY - 500), this.boundsBody.setEdge(-n, -500, -n, 500).SetFilterData(o), this.boundsBody.addEdge(n, -500, n, 500).SetFilterData(o), this.boundsBody.static = !0, this.boundsBody.friction = 0, this.boundsBody.gravityScale = 0, this.boundsBody.data.SetActive(!1), this.boundsBody.data.m_userData = { isSlope: !1, isPlatform: !1, activeCount: 0 } }, i.prototype.triggerEnter = function(t, e, i, o, n, s) { n && this.state.can("start") && (this.triggerSprite.body.removeFromWorld(), this.state.start()) }, i.prototype.maceEnter = function(t, e, i, o, n, s) { n && this.whipMace.visible && e.sprite.hitDamage(GameData.Boss1WhipDamage, !0, e.x > t.x ? 1 : -1, -1) }, i.prototype.setSpine = function() { this.spine = this.game.add.spine(0, 0, "boss1"), this.addChild(this.spine), this.spine.anchor.set(.5, .5), this.setSpineDirection(), this.spineAnimationNames = { dash: "dash2", dashOut: "dash_out", maceAttack: "mace_attack", maceAttackHit: "mace_attack_hit", maceAttackLoop: "mace_attack_loop", run: "run", stand: "stand", standHit: "stand_hit", standDash: "stand_to_dash" }, this.spine.onEvent.add(this.throwWhipEvent, this), this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0) }, i.prototype.createFiniteStateMachine = function() { var t, e = this;
            t = { init: "waiting", transitions: [{ name: "start", from: "waiting", to: "intro" }, { name: "dash", from: "intro", to: "dashing" }, { name: "dash", from: "whiping", to: "dashing" }, { name: "dash", from: "dashing", to: "dashing" }, { name: "whip", from: "dashing", to: "whiping" }], methods: { onStart: function() { e.player.walkIn(e.x - GameData.Boss1FacingDistance, !1), e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0), e.onStart.dispatch(), e.player.onAfterIntro.addOnce(function() { e.game.ph2AudioManager.playEffect("boss1", !1), e.game.time.events.add(1e3, e.startBoss, e), e.boundsBody.data.SetActive(!0) }, e), e.player.onGround || e.player.onGroundCollision.addOnce(function() { e.player.spine.setAnimationByName(0, e.player.spineAnimationNames.walk, !0) }, e) }, onDash: function() { e.setInvulnerable(!0), e.lookDirection.x = e.standingToRight ? -1 : 1, e.setSpineDirection(), e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0), e.timerEvent = e.game.time.events.add(GameData.Boss1DashDelay, e.startDashing, e) }, onWhip: function() { e.dashDamageActive = !1, Constants.DEBUG_ENABLED && (e.hitBoxVisual.visible = !1), e.lookDirection.x *= -1, e.setSpineDirection(), e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0), e.timerEvent = e.game.time.events.add(GameData.Boss1WhipDelay, e.throwWhip, e) } } }, this.state = new StateMachine(t) }, i.prototype.startBoss = function() { this.game.ph2AudioManager.getMusicEnabled() && t.Audios.playMusic(this.game, t.MusicID.BOSS), this.spine.setAnimationByName(0, this.spineAnimationNames.stand), this.timerEvent = null, t.Instances.cameraManager.setBound(this.leftBound, null, this.rightBound - this.leftBound, null), this.player.restoreWalkIn(), this.state.dash() }, i.prototype.startDashing = function() { this.timerEvent = null, this.game.ph2AudioManager.playEffect("boss2", !1), this.spine.setAnimationByName(0, this.spineAnimationNames.standDash), this.spine.onComplete.addOnce(this.executeDash, this) }, i.prototype.executeDash = function() { this.isDashing = !0, this.dashDamageActive = !0, Constants.DEBUG_ENABLED && (this.hitBoxVisual.position.set(GameData.Boss1DashHitboxOffsetX * this.lookDirection.x, GameData.Boss1DashHitboxOffsetY), this.hitBoxVisual.visible = !0), this.spine.setAnimationByName(0, this.spineAnimationNames.dash, !0) }, i.prototype.throwWhip = function() { this.timerEvent = null, this.game.ph2AudioManager.playEffect("boss3", !1), this.spine.setAnimationByName(0, this.spineAnimationNames.maceAttack), this.spine.addAnimationByName(0, this.spineAnimationNames.maceAttackLoop, !0) }, i.prototype.throwWhipEvent = function(t, e) { "attack" === e.data.name && (this.setInvulnerable(!1), this.whipTraveling = !0, this.maceDirection = this.lookDirection.x, this.whipMace.scale.x = -this.lookDirection.x, this.whipMace.body.data.SetActive(!0), this.whipMace.body.reset(this.body.x + this.whipOffset.x * this.lookDirection.x, this.body.y + this.whipOffset.y), this.whipMace.visible = !0, this.whipTile.x = this.whipOffset.x * this.lookDirection.x, this.whipTile.visible = !0) }, i.prototype.update = function() {!t.Instances.paused && this.spine.visible && (this.spine.update(), this.isDashing && this.checkDash(), this.whipTraveling && this.checkWhip(), this.walkingOut && this.checkWalkOut(), this.waitingPlayer && this.player.x > this.audioTriggerPoint.x && this.player.y > this.audioTriggerPoint.y && (this.waitingPlayer = !1, this.game.ph2AudioManager.getMusicEnabled() && this.game.ph2AudioManager.fadeCurrentMusic(1, 0, GameData.BossAudioFadeTime))) }, i.prototype.checkDash = function() { this.dashDamageActive && this.checkDamage(), this.lookDirection.x > 0 ? this.body.x > this.rightBound - GameData.Boss1Padding ? this.endDash(this.rightBound - GameData.Boss1Padding) : this.body.velocity.x = this.dashSpeed * this.lookDirection.x : this.body.x < this.leftBound + GameData.Boss1Padding ? this.endDash(this.leftBound + GameData.Boss1Padding) : this.body.velocity.x = this.dashSpeed * this.lookDirection.x }, i.prototype.checkDamage = function() { var t = this.game.physics.box2d.queryAABB(this.body.x + this.hitRect.x + GameData.Boss1DashHitboxOffsetX * this.lookDirection.x, this.body.y + this.hitRect.y + GameData.Boss1DashHitboxOffsetY, this.hitRect.width, this.hitRect.height); if (t.length > 0)
                for (var e = 0, i = t; e < i.length; e++) { var o = i[e];
                    0 != (o.fixture.m_filter.categoryBits & this.hitCategory) && (this.hitEnemy(o.body), this.dashDamageActive = !1) } }, i.prototype.hitEnemy = function(t) { t.sprite && t.sprite.hitDamage(GameData.Boss1DashDamage, !0, this.lookDirection.x, -1) }, i.prototype.endDash = function(t) { this.dashCount++, this.body.setZeroVelocity(), this.body.reset(t, this.body.y), this.isDashing = !1, this.isDashingBack = !1, this.standingToRight = this.lookDirection.x > 0, this.spine.setAnimationByName(0, this.spineAnimationNames.dashOut), this.dashCount < this.maxDashCount ? this.spine.onComplete.addOnce(this.state.dash, this.state) : (this.dashCount = 0, this.spine.onComplete.addOnce(this.state.whip, this.state)) }, i.prototype.checkWhip = function() { this.maceDirection > 0 ? this.whipMace.body.x > this.rightBound - GameData.Boss1Padding - (this.lookDirection.x < 0 ? this.whipOffset.x : 0) ? this.endWhip(this.rightBound - GameData.Boss1Padding) : (this.whipTile.width = this.whipMace.body.x - this.body.x - this.whipTile.x, this.whipMace.body.velocity.x = this.whipSpeed * this.maceDirection) : this.whipMace.body.x < this.leftBound + GameData.Boss1Padding + (this.lookDirection.x > 0 ? this.whipOffset.x : 0) ? this.endWhip(this.leftBound + GameData.Boss1Padding) : (this.whipTile.width = this.whipMace.body.x - this.body.x - this.whipTile.x, this.whipMace.body.velocity.x = this.whipSpeed * this.maceDirection) }, i.prototype.endWhip = function(t) { this.whipTravelingBack ? (this.whipMace.body.setZeroVelocity(), this.whipMace.body.data.SetActive(!1), this.whipTraveling = !1, this.whipTravelingBack = !1, this.whipMace.visible = !1, this.whipTile.visible = !1, this.whipTile.width = 0, this.whipMace.body.reset(t, this.whipMace.body.y), this.killAfterWhip ? (this.setInvulnerable(!0), this.setDead()) : this.state.dash()) : (this.killAfterWhip || this.game.ph2AudioManager.playEffect("boss4", !1), this.whipTravelingBack = !0, this.whipMace.body.setZeroVelocity(), this.whipMace.body.reset(t, this.whipMace.body.y), this.maceDirection *= -1) }, i.prototype.endWhipOff = function() { this.whipMace.body.setZeroVelocity(), this.whipMace.body.data.SetActive(!1), this.whipTraveling = !1, this.whipTravelingBack = !1, this.whipMace.visible = !1, this.whipTile.visible = !1, this.whipTile.width = 0 }, i.prototype.checkWalkOut = function() { this.body.velocity.x = this.walkSpeed * this.lookDirection.x, this.body.x > this.game.camera.x + this.game.width && (this.walkingOut = !1, this.difficulty > 2 ? this.onEnd.dispatch() : (this.player.playFinishAnim(), this.player.onAfterOutro.add(this.onEnd.dispatch, this.onEnd))) }, i.prototype.hitDamage = function(t, e, i, o) { void 0 === t && (t = 1), void 0 === i && (i = 0), void 0 === o && (o = 0), this.lifeManager.removeLife(t), this.lifeManager.currentlifes > 0 && (this.setInvulnerable(!0), this.game.time.events.add(GameData.invulnerabilityEnemyTimeSoft, this.setVulnerable, this), this.state.is("whiping") && this.whipTraveling && (this.spine.setAnimationByName(0, this.spineAnimationNames.maceAttackHit), this.spine.addAnimationByName(0, this.spineAnimationNames.maceAttackLoop, !0))) }, i.prototype.pause = function() {}, i.prototype.resume = function() {}, i.prototype.setDead = function() { this.whipTraveling ? (this.killAfterWhip = !0, this.whipSpeed *= 1.5, this.whipTravelingBack || (this.whipTravelingBack = !0, this.whipMace.body.setZeroVelocity(), this.maceDirection *= -1), this.player.setInvulnerable(!0), this.player.disableComponents(), this.player.ignoreGroundRestitusion = !0, this.difficulty > 2 && this.endWave()) : (this.player.lookDirection.x = 1, this.player.spine.scale.x = 1, this.boundsBody.removeFromWorld(), this.spine.onComplete.removeAll(), this.body.setZeroVelocity(), this.body.gravityScale = 0, this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.None, this.body.data.m_fixtureList.m_next.m_filter.categoryBits = t.CollisionLayers.None, null !== this.timerEvent && (this.timerEvent.pendingDelete = !0), this.runAway()) }, i.prototype.runAway = function() { this.difficulty > 2 ? this.game.ph2AudioManager.playEffect("boss6", !1) : this.game.ph2AudioManager.playEffect("boss5", !1), this.spine.setAnimationByName(0, this.spineAnimationNames.run, !0), this.lookDirection.x = 1, this.setSpineDirection(), this.walkingOut = !0 }, i.prototype.setAlive = function() { this.revive(), this.body.dynamic = !0, this.game.physics.box2d.addBody(this.body), this.body.dynamic = !0, this.lifeManager.addLife(this.lifeManager.maxlifes) }, i.prototype.contactEntered = function(t, e, i, o, n, s) {}, i.prototype.disableGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.spine.visible = !1, this.spine.state.timeScale = 0 }, i.prototype.enableGameElement = function() { this.revive(), this.body.data.SetActive(!0), this.spine.visible = !0, this.spine.state.timeScale = 1 }, i.prototype.destroyGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.body.removeFromWorld(), this.destroy(!0) }, i.prototype.setInvulnerable = function(e) { e ? (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable) : (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.Enemies) }, i.prototype.setVulnerable = function() {
            (this.state.is("whiping") || this.state.is("resting")) && this.setInvulnerable(!1) }, i.prototype.setSpineDirection = function() { this.spine.scale.x = -this.lookDirection.x }, i.prototype.getFloorPoint = function() { var e = this.y,
                i = t.Utilities.getRaycastPoint(this.game, this.x, this.y, 0, 1); return null !== i && (e = i.y), e }, i.prototype.setAudioTrigger = function() { var e = this.leftBound,
                i = this.y,
                o = t.Utilities.getRaycastPoint(this.game, this.zoneX, this.y, 0, -1);
            null !== o && (i = o.y), null !== (o = t.Utilities.getRaycastPoint(this.game, this.zoneX, this.y, -1, 0)) && (e = o.x), this.audioTriggerPoint = new Phaser.Point(e, i) }, i.prototype.spawnEnemy = function() { if (this.spawner.isSetComplete()) this.checkLife(this.lifeManager.currentlifes / this.lifeManager.maxlifes);
            else if (this.currentLiveEnemies < GameData.waveMaxAlive) { var t = this.spawner.pickNextItem();
                t.setAggresive(!0, this.zoneX, this.zoneExtend), this.enemies.push(t), t.lifeManager.onNoLife.addOnce(this.checkEnemyStock, this), this.currentLiveEnemies++, this.spawner.isSetComplete() || (this.spawnTimerEvent = this.game.time.events.add(GameData.Boss1WaveSpawnTime, this.spawnEnemy, this)) } else this.spawnTimerEvent = null }, i.prototype.checkEnemyStock = function(t) { this.currentLiveEnemies--, this.spawnTimerEvent = this.game.time.events.add(GameData.Boss1WaveSpawnTime, this.spawnEnemy, this), this.quickRemove(this.enemies, t) }, i.prototype.endWave = function() { this.spawnTimerEvent && (this.spawnTimerEvent.pendingDelete = !0); for (var t = 0, e = this.enemies; t < e.length; t++) { var i = e[t];
                i.lifeManager.onNoLife.remove(this.checkEnemyStock, this), i.setInvulnerable(!1), i.lifeManager.removeLife(i.lifeManager.maxlifes) } this.enemies.length = 0 }, i.prototype.quickRemove = function(t, e) { var i = t.indexOf(e);
            i >= 0 && (t[i] = t[t.length - 1], t.length--) }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null }, i }(Phaser.Sprite);
    t.Boss1 = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a) { var h = e.call(this, i, a - GameData.Boss2Padding, s.y - .5 * s.height, null) || this;
            h.difficulty = 1, h.leftBound = r, h.rightBound = a, h.zoneExtend = .5 * (h.rightBound - h.leftBound), h.zoneX = h.leftBound + h.zoneExtend, h.player = o, h.group = n, h.tweenjump = null, h.walkSpeed = GameData.Boss2WalkSpeed * GameData.PixToMet, h.timerStand = h.game.time.create(!1), h.spawnTimerEvent = null, h.normalAux = new box2d.b2Vec2, h.standingToRight = !0, h.isEscaping = !1, h.walkingOut = !1, h.waitingPlayer = !0, h.lookDirection = new Phaser.Point(-1, 0), h.hitRect = new Phaser.Rectangle(-.5 * GameData.Boss2JumpHitboxWidth, -.5 * GameData.Boss2JumpHitboxHeight, GameData.Boss2JumpHitboxWidth, GameData.Boss2JumpHitboxHeight), h.hitCategory = t.CollisionLayers.Player, h.floorY = h.getFloorPoint(), h.setAudioTrigger(), i.physics.box2d.enable(h), h.isDamageJump = !1, h.body.fixedRotation = !0, h.body.friction = 1, h.body.linearDamping = .5, h.body.setRectangle(GameData.Boss2BodyWidth, GameData.Boss2BodyHeight); var l = new box2d.b2Filter;
            l.categoryBits = t.CollisionLayers.Enemies, l.maskBits = GameData.enemyCollisionMask, h.body.data.m_fixtureList.SetFilterData(l); var c = h.body.addCircle(.5 * GameData.Boss2BodyWidth + 2, 0, .5 * GameData.Boss2BodyHeight); return h.body.setFixtureContactCallback(c, h.contactEntered, h), h.body.data.m_fixtureList.SetFilterData(l), h.groundContactPool = [null, null, null, null], h.lifeManager = new t.LifeManager(GameData.Boss2Life, h), h.barManager = new t.BarManager(h.game), h.lifeManager.onLostLife.add(h.checkLife, h), h.lifeManager.onNoLife.add(h.setDead, h), h.onStart = new Phaser.Signal, h.onEnd = new Phaser.Signal, h.onGround = !0, h.setTrigger(), h.setSpine(), h.createFiniteStateMachine(), h.group.add(h), Constants.DEBUG_ENABLED && h.setDebugSprite(), h } return __extends(i, e), i.prototype.checkLife = function(t) { this.barManager.setPercent(t) }, i.prototype.setDebugSprite = function() { if (Constants.DEBUG_ENABLED) { var t = this.game.add.graphics(0, 0);
                t.beginFill(16711680, .5), t.drawRect(0, 0, this.hitRect.width, this.hitRect.height), t.endFill(); var e = t.generateTexture();
                t.destroy(), this.hitBoxVisual = this.game.add.sprite(GameData.Boss2JumpHitboxOffsetX, GameData.Boss2JumpHitboxOffsetY, e), this.hitBoxVisual.anchor.set(.5), this.addChild(this.hitBoxVisual), this.hitBoxVisual.visible = !1 } }, i.prototype.setTrigger = function() { var e = this.leftBound,
                i = this.rightBound - e;
            this.triggerSprite = this.game.add.sprite(e + .5 * i, this.floorY - 500), this.game.physics.box2d.enable(this.triggerSprite), this.triggerSprite.body.setRectangle(i, 1e3), this.triggerSprite.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Items, this.triggerSprite.body.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, this.triggerSprite.body.static = !0, this.triggerSprite.body.sensor = !0, this.triggerSprite.body.setBodyContactCallback(this.player, this.triggerEnter, this); var o = new box2d.b2Filter;
            o.categoryBits = t.CollisionLayers.Map, o.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable; var n = .5 * (this.rightBound - this.leftBound);
            this.boundsBody = this.game.physics.box2d.createBody(this.leftBound + n, this.floorY - 500), this.boundsBody.setEdge(-n, -500, -n, 500).SetFilterData(o), this.boundsBody.addEdge(n, -500, n, 500).SetFilterData(o), this.boundsBody.static = !0, this.boundsBody.friction = 0, this.boundsBody.gravityScale = 0, this.boundsBody.data.SetActive(!1), this.boundsBody.data.m_userData = { isSlope: !1, isPlatform: !1, activeCount: 0 } }, i.prototype.triggerEnter = function(t, e, i, o, n, s) { n && this.state.can("start") && (this.triggerSprite.body.removeFromWorld(), this.state.start()) }, i.prototype.getFloorPoint = function() { var e = this.y,
                i = t.Utilities.getRaycastPoint(this.game, this.x, this.y, 0, 1); return null !== i && (e = i.y), e }, i.prototype.setAudioTrigger = function() { var e = this.leftBound,
                i = this.y,
                o = t.Utilities.getRaycastPoint(this.game, this.zoneX, this.y, 0, -1);
            null !== o && (i = o.y), null !== (o = t.Utilities.getRaycastPoint(this.game, this.zoneX, this.y, -1, 0)) && (e = o.x), this.audioTriggerPoint = new Phaser.Point(e, i) }, i.prototype.setSpine = function() { this.spine = this.game.add.spine(0, 0, "bashmouth"), this.addChild(this.spine), this.spine.anchor.set(.5, .5), this.setSpineDirection(), this.spineAnimationNames = { run: "run", stand: "stand", jumpIn: "roll_in", jumpLoop: "roll_run", jumpOut: "roll_out" }, this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0) }, i.prototype.createFiniteStateMachine = function() { var t, e = this;
            t = { init: "waiting", transitions: [{ name: "start", from: "waiting", to: "intro" }, { name: "jump", from: "intro", to: "jumping" }, { name: "stand", from: "jumping", to: "standing" }, { name: "jump", from: "standing", to: "jumping" }], methods: { onStart: function() { e.player.walkIn(e.x - GameData.Boss2FacingDistance, !1), e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0), e.onStart.dispatch(), e.player.onAfterIntro.addOnce(function() { e.game.ph2AudioManager.playEffect("boss1", !1), e.game.time.events.add(1e3, e.startBoss, e), e.boundsBody.data.SetActive(!0) }, e), e.player.onGround || e.player.onGroundCollision.addOnce(function() { e.player.spine.setAnimationByName(0, e.player.spineAnimationNames.walk, !0) }, e) }, onJump: function() { e.isDamageJump = !0, e.totalJump = GameData.Boss2CountsJump, e.setInvulnerable(!0), e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0), e.startJumps() }, onStand: function() { e.lookDirection.x = e.player.body.x < e.body.x ? -1 : 1, e.setSpineDirection(), e.isEscaping = !1, e.setInvulnerable(!1), e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0), e.timerStand.add(1e3 * GameData.Boss2TimeStand, e.endStand, e), e.timerStand.start() } } }, this.state = new StateMachine(t) }, i.prototype.startBoss = function() { this.game.ph2AudioManager.getMusicEnabled() && t.Audios.playMusic(this.game, t.MusicID.BOSS), t.Instances.cameraManager.setBoundX(this.leftBound), t.Instances.cameraManager.setBoundWidth(this.rightBound - this.leftBound), this.player.restoreWalkIn(), this.state.jump() }, i.prototype.startJumps = function() { if (this.player.isAlive()) { var t, e = this.body.x,
                    i = this.body.y,
                    o = this.body.y - GameData.Boss2JumpDistanceY;
                this.isEscaping ? (Math.abs(this.leftBound - this.body.x) > Math.abs(this.rightBound - this.body.x) ? (this.lookDirection.x = -1, this.setSpineDirection()) : (this.lookDirection.x = 1, this.setSpineDirection()), t = this.lookDirection.x * GameData.Boss2JumpDistanceX) : (this.lookDirection.x = this.player.body.x < this.body.x ? -1 : 1, this.setSpineDirection(), t = Math.abs(this.player.body.x - this.body.x) < GameData.Boss2JumpDistanceX ? this.lookDirection.x * Math.abs(this.player.body.x - this.body.x) : this.lookDirection.x * GameData.Boss2JumpDistanceX), this.tweenjump = this.game.add.tween(this.body).to({ x: [e + .5 * t, e + t], y: [o, i] }, 1e3 * GameData.Boss2JumpDuration, Phaser.Easing.Sinusoidal.InOut), this.tweenjump.start(), this.tweenjump.onComplete.addOnce(this.endJump, this), this.spine.setAnimationByName(0, this.spineAnimationNames.jumpIn, !1), this.spine.addAnimationByName(0, this.spineAnimationNames.jumpLoop, !0), Constants.DEBUG_ENABLED && (this.hitBoxVisual.position.set(GameData.Boss2JumpHitboxOffsetX * this.lookDirection.x, GameData.Boss2JumpHitboxOffsetY), this.hitBoxVisual.visible = !0) } }, i.prototype.endJump = function() { this.spine.setAnimationByName(0, this.spineAnimationNames.jumpOut, !1), this.spine.addAnimationByName(0, this.spineAnimationNames.stand, !0), --this.totalJump <= 0 ? this.state.stand() : this.startJumps() }, i.prototype.endStand = function() { this.timerStand.removeAll(), this.state.jump() }, i.prototype.update = function() {!t.Instances.paused && this.spine.visible && (this.spine.update(), this.walkingOut && this.checkWalkOut(), this.isDamageJump && this.checkDamageJump(), this.waitingPlayer && this.player.x > this.audioTriggerPoint.x && this.player.y > this.audioTriggerPoint.y && (this.waitingPlayer = !1, this.game.ph2AudioManager.getMusicEnabled() && this.game.ph2AudioManager.fadeCurrentMusic(1, 0, GameData.BossAudioFadeTime))) }, i.prototype.checkDamageJump = function() { var t = this.game.physics.box2d.queryAABB(this.body.x + this.hitRect.x, this.body.y + this.hitRect.y, this.hitRect.width, this.hitRect.height); if (t.length > 0)
                for (var e = 0, i = t; e < i.length; e++) { var o = i[e];
                    0 != (o.fixture.m_filter.categoryBits & this.hitCategory) && (this.hitEnemy(o.body), this.isDamageJump = !1, this.isEscaping = !0) } }, i.prototype.hitEnemy = function(t) { t.sprite && t.sprite.hitDamage(GameData.Boss2JumpDamage, !0, this.lookDirection.x, -1) }, i.prototype.checkWalkOut = function() { this.body.velocity.x = this.walkSpeed * this.lookDirection.x, this.body.x > this.game.camera.x + this.game.width && (this.walkingOut = !1, this.difficulty > 2 ? this.onEnd.dispatch() : (this.player.playFinishAnim(), this.player.onAfterOutro.add(this.onEnd.dispatch, this.onEnd))) }, i.prototype.hitDamage = function(t, e, i, o) { void 0 === t && (t = 1), void 0 === i && (i = 0), void 0 === o && (o = 0), this.lifeManager.removeLife(t), this.lifeManager.currentlifes > 0 && (this.setInvulnerable(!0), this.game.time.events.add(GameData.invulnerabilityEnemyTimeSoft, this.setVulnerable, this)) }, i.prototype.setDead = function() { this.player.setInvulnerable(), this.player.lookDirection.x = 1, this.player.spine.scale.x = 1, this.boundsBody.removeFromWorld(), this.spine.onComplete.removeAll(), this.body.setZeroVelocity(), this.body.gravityScale = 0, this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.None, this.body.data.m_fixtureList.m_next.m_filter.categoryBits = t.CollisionLayers.None, this.timerStand.removeAll(), this.runAway() }, i.prototype.runAway = function() { this.spine.setAnimationByName(0, this.spineAnimationNames.run, !0), this.lookDirection.x = 1, this.setSpineDirection(), this.walkingOut = !0 }, i.prototype.setAlive = function() { this.revive(), this.body.dynamic = !0, this.game.physics.box2d.addBody(this.body), this.body.dynamic = !0, this.lifeManager.addLife(this.lifeManager.maxlifes) }, i.prototype.contactEntered = function(t, e, i, o, n, s) {}, i.prototype.disableGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.spine.visible = !1, this.spine.state.timeScale = 0 }, i.prototype.enableGameElement = function() { this.revive(), this.body.data.SetActive(!0), this.spine.visible = !0, this.spine.state.timeScale = 1 }, i.prototype.destroyGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.body.removeFromWorld(), this.destroy(!0) }, i.prototype.setInvulnerable = function(e) { e ? (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable) : (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.Enemies) }, i.prototype.setVulnerable = function() { this.state.is("standing") && this.setInvulnerable(!1) }, i.prototype.setSpineDirection = function() { this.spine.scale.x = -this.lookDirection.x }, i.prototype.pause = function() { this.tweenjump && this.tweenjump.pause(), this.timerStand.pause() }, i.prototype.resume = function() { this.tweenjump && this.tweenjump.resume(), this.timerStand.resume() }, i.prototype.destroy = function(t) { this.tweenjump && this.tweenjump.stop(), this.tweenjump = null, this.timerStand.removeAll(), this.timerStand.destroy(), this.timerStand = null, e.prototype.destroy.call(this, t), this.player = null }, i }(Phaser.Sprite);
    t.Boss2 = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a) { var h = e.call(this, i, a - GameData.Boss3Padding, s.y - .5 * s.height, null) || this;
            h.difficulty = 2, h.leftBound = r, h.rightBound = a, h.zoneExtend = .5 * (h.rightBound - h.leftBound), h.zoneX = h.leftBound + h.zoneExtend, h.player = o, h.group = n, h.walkSpeed = GameData.Boss3WalkSpeed * GameData.PixToMet, h.timerEvent = null, h.spawnTimerEvent = null, h.normalAux = new box2d.b2Vec2, h.standingToRight = !0, h.walkingOut = !1, h.isDashing = !1, h.dashDamageActive = !1, h.waitingPlayer = !0, h.lookDirection = new Phaser.Point(-1, 0), h.hitRect = new Phaser.Rectangle(-.5 * GameData.Boss3DashHitboxWidth, -.5 * GameData.Boss3DashHitboxHeight, GameData.Boss3DashHitboxWidth, GameData.Boss3DashHitboxHeight), h.hitCategory = t.CollisionLayers.Player, h.floorY = h.getFloorPoint(), h.setAudioTrigger(), h.totalSpikes = GameData.Boss3TotalSpikesInArea, h.spikeCreateTime = GameData.Boss3SpikeSecuenceTime, h.disapearProgresive = GameData.Boss3SpikesProgresiveHiding, h.spikeLifeTime = GameData.Boss3SpikeLifeTime, h.spikes = [], h.currentSpike = 0, h.shockActive = !1, h.shockCounter = 0, h.usePairs = !1, h.dashSpeed = GameData.Boss3DashSpeed * GameData.PixToMet, h.changeOnHit = !GameData.Boss3ChangeSideAlone, h.hitted = !1, h.setSpikes(), i.physics.box2d.enable(h), h.body.fixedRotation = !0, h.body.friction = 1, h.body.linearDamping = .5, h.body.setRectangle(GameData.Boss3BodyWidth, GameData.Boss3BodyHeight); var l = new box2d.b2Filter;
            l.categoryBits = t.CollisionLayers.Enemies, l.maskBits = GameData.enemyCollisionMask, h.body.data.m_fixtureList.SetFilterData(l); var c = h.body.addCircle(.5 * GameData.Boss3BodyWidth + 2, 0, .5 * GameData.Boss3BodyHeight); return h.body.setFixtureContactCallback(c, h.contactEntered, h), h.body.data.m_fixtureList.SetFilterData(l), h.groundContactPool = [null, null, null, null], h.lifeManager = new t.LifeManager(GameData.Boss3Life, h), h.barManager = new t.BarManager(h.game), h.lifeManager.onLostLife.add(h.checkLife, h), h.lifeManager.onNoLife.add(h.setDead, h), h.onStart = new Phaser.Signal, h.onEnd = new Phaser.Signal, h.onGround = !0, h.setTrigger(), h.setSpine(), h.createFiniteStateMachine(), h.group.add(h), Constants.DEBUG_ENABLED && h.setDebugSprite(), h } return __extends(i, e), i.prototype.setSpikes = function() { for (var e = (this.rightBound - this.leftBound - 2 * GameData.Boss3Padding) / this.totalSpikes, i = 0; i < this.totalSpikes; i++) { var o = Math.floor(this.leftBound + GameData.Boss3Padding + .5 * e + i * e);
                this.disapearProgresive ? this.spikes[i] = new t.BossSpikes(this.game, this.player, o, this.floorY, this.spikeLifeTime) : this.spikes[i] = new t.BossSpikes(this.game, this.player, o, this.floorY) } }, i.prototype.checkLife = function(t) { this.barManager.setPercent(t) }, i.prototype.setDebugSprite = function() { if (Constants.DEBUG_ENABLED) { var t = this.game.add.graphics(0, 0);
                t.beginFill(16711680, .5), t.drawRect(0, 0, this.hitRect.width, this.hitRect.height), t.endFill(); var e = t.generateTexture();
                t.destroy(), this.hitBoxVisual = this.game.add.sprite(GameData.Boss3DashHitboxOffsetX, GameData.Boss3DashHitboxOffsetX, e), this.hitBoxVisual.anchor.set(.5), this.addChild(this.hitBoxVisual), this.hitBoxVisual.visible = !1 } }, i.prototype.setTrigger = function() { var e = this.leftBound,
                i = this.rightBound - e;
            this.triggerSprite = this.game.add.sprite(e + .5 * i, this.floorY - 500), this.game.physics.box2d.enable(this.triggerSprite), this.triggerSprite.body.setRectangle(i, 1e3), this.triggerSprite.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Items, this.triggerSprite.body.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, this.triggerSprite.body.static = !0, this.triggerSprite.body.sensor = !0, this.triggerSprite.body.setBodyContactCallback(this.player, this.triggerEnter, this); var o = new box2d.b2Filter;
            o.categoryBits = t.CollisionLayers.Map, o.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable; var n = .5 * (this.rightBound - this.leftBound);
            this.boundsBody = this.game.physics.box2d.createBody(this.leftBound + n, this.floorY - 500), this.boundsBody.setEdge(-n, -500, -n, 500).SetFilterData(o), this.boundsBody.addEdge(n, -500, n, 500).SetFilterData(o), this.boundsBody.static = !0, this.boundsBody.friction = 0, this.boundsBody.gravityScale = 0, this.boundsBody.data.SetActive(!1), this.boundsBody.data.m_userData = { isSlope: !1, isPlatform: !1, activeCount: 0 } }, i.prototype.triggerEnter = function(t, e, i, o, n, s) { n && this.state.can("start") && (this.triggerSprite.body.removeFromWorld(), this.state.start()) }, i.prototype.getFloorPoint = function() { var e = this.y,
                i = t.Utilities.getRaycastPoint(this.game, this.x, this.y, 0, 1); return null !== i && (e = i.y), e }, i.prototype.setAudioTrigger = function() { var e = this.leftBound,
                i = this.y,
                o = t.Utilities.getRaycastPoint(this.game, this.zoneX, this.y, 0, -1);
            null !== o && (i = o.y), null !== (o = t.Utilities.getRaycastPoint(this.game, this.zoneX, this.y, -1, 0)) && (e = o.x), this.audioTriggerPoint = new Phaser.Point(e, i) }, i.prototype.setSpine = function() { this.spine = this.game.add.spine(0, 0, "black_ice"), this.addChild(this.spine), this.spine.anchor.set(.5, .5), this.setSpineDirection(), this.spineAnimationNames = { run: "run", stand: "stand", shockIn: "attack", shockOut: "attack_hit", dashIn: "stand_to_dash", dashLoop: "dash2", dashOut: "dash_out", underAttack: "stand_hit" }, this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0) }, i.prototype.createFiniteStateMachine = function() { var t, e = this;
            t = { init: "waiting", transitions: [{ name: "start", from: "waiting", to: "intro" }, { name: "shock", from: "*", to: "shocking" }, { name: "dash", from: "shocking", to: "dashing" }], methods: { onStart: function() { e.player.walkIn(e.x - GameData.Boss3FacingDistance, !1), e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0), e.onStart.dispatch(), e.player.onAfterIntro.addOnce(function() { e.game.ph2AudioManager.playEffect("boss1", !1), e.game.time.events.add(1e3, e.startBoss, e), e.boundsBody.data.SetActive(!0) }, e), e.player.onGround || e.player.onGroundCollision.addOnce(function() { e.player.spine.setAnimationByName(0, e.player.spineAnimationNames.walk, !0) }, e) }, onShock: function() { e.setInvulnerable(!1), e.lookDirection.x = e.standingToRight ? -1 : 1, e.setSpineDirection(), e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0), e.timerEvent = e.game.time.events.add(GameData.Boss3SpikeDelay, e.startShock, e) }, onDash: function() { e.hitted = !1, e.setInvulnerable(!0), e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0), e.timerEvent = e.game.time.events.add(GameData.Boss3DashDelay, e.startDashing, e) } } }, this.state = new StateMachine(t) }, i.prototype.startBoss = function() { this.game.ph2AudioManager.getMusicEnabled() && t.Audios.playMusic(this.game, t.MusicID.BOSS), this.spine.setAnimationByName(0, this.spineAnimationNames.stand), this.timerEvent = null, t.Instances.cameraManager.setBound(this.leftBound, null, this.rightBound - this.leftBound, null), this.player.restoreWalkIn(), this.state.shock() }, i.prototype.startDashing = function() { this.timerEvent = null, this.spine.setAnimationByName(0, this.spineAnimationNames.dashIn, !1), this.spine.onComplete.addOnce(this.executeDash, this) }, i.prototype.startShock = function() { this.timerEvent = null, this.shockActive = !0, this.spine.setAnimationByName(0, this.spineAnimationNames.shockIn, !1), this.spine.addAnimationByName(0, this.spineAnimationNames.shockOut, !1), this.lookDirection.x > 0 ? (this.currentSpike = 0, this.usePairs || this.currentSpike++) : (this.currentSpike = this.totalSpikes - 1, this.usePairs || this.currentSpike--) }, i.prototype.executeDash = function() { this.isDashing = !0, this.dashDamageActive = !0, Constants.DEBUG_ENABLED && (this.hitBoxVisual.position.set(GameData.Boss3DashHitboxOffsetX * this.lookDirection.x, GameData.Boss3DashHitboxOffsetY), this.hitBoxVisual.visible = !0), this.spine.setAnimationByName(0, this.spineAnimationNames.dashLoop, !0) }, i.prototype.updateShock = function() { this.shockCounter += this.game.time.elapsedMS, this.shockCounter >= this.spikeCreateTime && (this.shockCounter -= this.spikeCreateTime, this.spikes[this.currentSpike].spikeIn(), this.lookDirection.x > 0 ? (this.currentSpike += 2, this.currentSpike >= this.spikes.length && this.endSpikeShock()) : (this.currentSpike -= 2, this.currentSpike < 0 && this.endSpikeShock())) }, i.prototype.endSpikeShock = function() { this.shockActive = !1, this.usePairs = !this.usePairs, this.disapearProgresive ? this.setNextAction() : this.timerEvent = this.game.time.events.add(this.spikeLifeTime, this.hideAllSpikes, this) }, i.prototype.setNextAction = function() { this.changeOnHit ? this.hitted ? this.state.dash() : this.state.shock() : this.usePairs ? this.state.shock() : this.state.dash() }, i.prototype.hideAllSpikes = function() { this.timerEvent = null; for (var t = 0, e = this.spikes; t < e.length; t++) e[t].spikeOut();
            this.setNextAction() }, i.prototype.update = function() {!t.Instances.paused && this.spine.visible && (this.spine.update(), this.shockActive && this.updateShock(), this.isDashing && this.updateDash(), this.walkingOut && this.checkWalkOut(), this.waitingPlayer && this.player.x > this.audioTriggerPoint.x && this.player.y > this.audioTriggerPoint.y && (this.waitingPlayer = !1, this.game.ph2AudioManager.getMusicEnabled() && this.game.ph2AudioManager.fadeCurrentMusic(1, 0, GameData.BossAudioFadeTime))) }, i.prototype.updateDash = function() { this.dashDamageActive && this.checkDamage(), this.lookDirection.x > 0 ? this.body.x > this.rightBound - GameData.Boss3Padding ? this.endDash(this.rightBound - GameData.Boss3Padding) : this.body.velocity.x = this.dashSpeed * this.lookDirection.x : this.body.x < this.leftBound + GameData.Boss3Padding ? this.endDash(this.leftBound + GameData.Boss3Padding) : this.body.velocity.x = this.dashSpeed * this.lookDirection.x }, i.prototype.endDash = function(t) { this.body.setZeroVelocity(), this.body.reset(t, this.body.y), this.isDashing = !1, this.standingToRight = this.lookDirection.x > 0, this.spine.setAnimationByName(0, this.spineAnimationNames.dashOut, !1), this.spine.onComplete.addOnce(this.state.shock, this.state) }, i.prototype.checkDamage = function() { var t = this.game.physics.box2d.queryAABB(this.body.x + this.hitRect.x + GameData.Boss3DashHitboxOffsetX * this.lookDirection.x, this.body.y + this.hitRect.y + GameData.Boss3DashHitboxOffsetY, this.hitRect.width, this.hitRect.height); if (t.length > 0)
                for (var e = 0, i = t; e < i.length; e++) { var o = i[e];
                    0 != (o.fixture.m_filter.categoryBits & this.hitCategory) && this.hitEnemy(o.body) } }, i.prototype.hitEnemy = function(t) { t.sprite && t.sprite.hitDamage(GameData.Boss3DashDamage, !0, this.lookDirection.x, -1) }, i.prototype.checkWalkOut = function() { this.body.velocity.x = this.walkSpeed * this.lookDirection.x, this.body.x > this.game.camera.x + this.game.width && (this.walkingOut = !1, this.player.playFinishAnim(), this.player.onAfterOutro.addOnce(this.onEnd.dispatch, this.onEnd)) }, i.prototype.hitDamage = function(t, e, i, o) { void 0 === t && (t = 1), void 0 === i && (i = 0), void 0 === o && (o = 0), this.lifeManager.removeLife(t), this.lifeManager.currentlifes > 0 && (this.setInvulnerable(!0), this.game.time.events.add(GameData.invulnerabilityEnemyTimeSoft, this.setVulnerable, this), this.spine.setAnimationByName(0, this.spineAnimationNames.underAttack), this.hitted = !0) }, i.prototype.setDead = function() { if (this.player.setInvulnerable(!0), this.player.disableComponents(), this.player.ignoreGroundRestitusion = !0, this.shockActive) { this.shockActive = !1; for (var e = 0, i = this.spikes; e < i.length; e++) i[e].disableSpike() } null !== this.timerEvent && (this.timerEvent.pendingDelete = !0), this.spine.onComplete.removeAll(), this.player.lookDirection.x = 1, this.player.spine.scale.x = 1, this.boundsBody.removeFromWorld(), this.body.setZeroVelocity(), this.body.gravityScale = 0, this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.None, this.body.data.m_fixtureList.m_next.m_filter.categoryBits = t.CollisionLayers.None, this.runAway() }, i.prototype.runAway = function() { this.spine.setAnimationByName(0, this.spineAnimationNames.run, !0), this.lookDirection.x = 1, this.setSpineDirection(), this.walkingOut = !0 }, i.prototype.setAlive = function() { this.revive(), this.body.dynamic = !0, this.game.physics.box2d.addBody(this.body), this.body.dynamic = !0, this.lifeManager.addLife(this.lifeManager.maxlifes) }, i.prototype.contactEntered = function(t, e, i, o, n, s) {}, i.prototype.disableGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.spine.visible = !1, this.spine.state.timeScale = 0 }, i.prototype.enableGameElement = function() { this.revive(), this.body.data.SetActive(!0), this.spine.visible = !0, this.spine.state.timeScale = 1 }, i.prototype.destroyGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.body.removeFromWorld(), this.destroy(!0) }, i.prototype.setInvulnerable = function(e) { e ? (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable) : (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.Enemies) }, i.prototype.setVulnerable = function() { this.state.is("shocking") && this.setInvulnerable(!1) }, i.prototype.setSpineDirection = function() { this.spine.scale.x = this.lookDirection.x }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null }, i.prototype.pause = function() {}, i.prototype.resume = function() {}, i }(Phaser.Sprite);
    t.Boss3 = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r) { void 0 === r && (r = -1); var a = e.call(this, i, n, s + .5 * GameData.Boss3SpikeHeight + GameData.Boss3SpikeOffsetY, "thorns") || this;
            a.anchor.set(.5, 0), a.player = o, r > 0 ? (a.timerActive = !0, a.hideTime = r) : a.timerActive = !1, i.add.existing(a), a.autoCull = !0; var h = GameData.Boss3SpikeHeight,
                l = GameData.Boss3SpikeWidth;
            a.originY = a.y, a.moveDistance = GameData.Boss3SpikeHeight, a.moveDirection = -1, a.isMoving = !1, i.physics.box2d.enable(a), a.body.setRectangle(l, h, 0, 0), a.body.fixedRotation = !0, a.body.dynamic = !1, a.body.kinematic = !0, a.body.sensor = !0; var c = new box2d.b2Filter; return c.categoryBits = t.CollisionLayers.Damage, c.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, a.body.data.m_fixtureList.SetFilterData(c), a.body.setBodyContactCallback(o, a.killPlayer, a), a.onRespawn = new Phaser.Signal, a.invIn = !1, a.body.data.SetActive(!1), a } return __extends(i, e), i.prototype.spikeIn = function() { this.isMoving || (this.moveDirection = -1, this.isMoving = !0, this.body.velocity.y = GameData.Boss3SpikeMoveSpeed * this.moveDirection, this.body.data.SetActive(!0), this.timerActive && this.game.time.events.add(this.hideTime, this.spikeOut, this)) }, i.prototype.spikeOut = function() { this.isMoving && (this.moveDirection = 1, this.body.velocity.y = GameData.Boss3SpikeMoveSpeed * this.moveDirection) }, i.prototype.disableSpike = function() { this.isMoving && (this.body.data.SetActive(!1), this.moveDirection = 1, this.body.velocity.y = GameData.Boss3SpikeMoveSpeed * this.moveDirection) }, i.prototype.update = function() { this.isMoving && (this.moveDirection > 0 ? this.body.y > this.originY && (this.body.velocity.y = 0, this.body.reset(this.body.x, this.originY), this.isMoving = !1, this.body.data.SetActive(!1)) : this.body.y < this.originY - GameData.Boss3SpikeHeight && (this.body.velocity.y = 0, this.body.reset(this.body.x, this.originY - GameData.Boss3SpikeHeight))) }, i.prototype.tankDestroy = function() { this.body.removeFromWorld(), this.destroy() }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.killPlayer = function(e, i, o, n, s, r) { s ? n.m_filter.categoryBits === t.CollisionLayers.Invulnerable ? this.invIn || (this.invIn = !0, i.sprite.onRestoreVulnerability.add(this.damagePlayer, this)) : this.damagePlayer() : this.invIn && (this.invIn = !1, i.sprite && i.sprite.onRestoreVulnerability.remove(this.damagePlayer, this)) }, i.prototype.damagePlayer = function() { this.doRespawn ? (this.player.hitDamage(GameData.Boss3SpikeDamage, !1), this.player.playKillAnim(), this.player.lifeManager.currentlifes > 0 && this.game.time.events.add(this.respawnDelay, this.respawnPlayer, this)) : this.player.hitDamage(GameData.Boss3SpikeDamage, !0, this.player.body.x > this.body.x ? 1 : -1, -1) }, i.prototype.respawnPlayer = function() { this.onRespawn.dispatch() }, i.prototype.disableGameElement = function() { this.visible = !1, this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.visible = !0, this.body.data.SetActive(!0) }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null }, i }(Phaser.Sprite);
    t.BossSpikes = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a) { var h = e.call(this, i, a - GameData.Boss4Padding, s.y - .5 * s.height, null) || this;
            h.difficulty = 3, h.leftBound = r, h.rightBound = a, h.zoneExtend = .5 * (h.rightBound - h.leftBound), h.zoneX = h.leftBound + h.zoneExtend, h.player = o, h.group = n, h.isDashing = !1, h.dashSpeed = GameData.Boss4DashSpeed * GameData.PixToMet, h.dashDamageActive = !1, h.tweenMove = null, h.walkSpeed = GameData.Boss4WalkSpeed * GameData.PixToMet, h.timerEvent = null, h.spawnTimerEvent = null, h.normalAux = new box2d.b2Vec2, h.walkingOut = !1, h.waitingPlayer = !0, h.lookDirection = new Phaser.Point(-1, 0), h.hitRect = new Phaser.Rectangle(-.5 * GameData.Boss4DashHitboxWidth, -.5 * GameData.Boss4DashHitboxHeight, GameData.Boss4DashHitboxWidth, GameData.Boss4DashHitboxHeight), h.hitCategory = t.CollisionLayers.Player, h.floorY = h.getFloorPoint(), h.setAudioTrigger(), i.physics.box2d.enable(h), h.body.fixedRotation = !0, h.body.friction = 1, h.body.linearDamping = .5, h.body.setRectangle(GameData.Boss4BodyWidth, GameData.Boss4BodyHeight); var l = new box2d.b2Filter;
            l.categoryBits = t.CollisionLayers.Enemies, l.maskBits = GameData.enemyCollisionMask, h.body.data.m_fixtureList.SetFilterData(l); var c = h.body.addCircle(.5 * GameData.Boss4BodyWidth + 2, 0, .5 * GameData.Boss4BodyHeight); return h.body.setFixtureContactCallback(c, h.contactEntered, h), h.body.data.m_fixtureList.SetFilterData(l), h.groundContactPool = [null, null, null, null], h.lifeManager = new t.LifeManager(GameData.Boss2Life, h), h.barManager = new t.BarManager(h.game), h.lifeManager.onLostLife.add(h.checkLife, h), h.lifeManager.onNoLife.add(h.setDead, h), h.onStart = new Phaser.Signal, h.onEnd = new Phaser.Signal, h.timer = h.game.time.create(!1), h.timer.start(), h.onGround = !0, h.setTrigger(), h.setSpine(), h.createFiniteStateMachine(), h.group.add(h), Constants.DEBUG_ENABLED && h.setDebugSprite(), h } return __extends(i, e), i.prototype.checkLife = function(t) { this.barManager.setPercent(t) }, i.prototype.setDebugSprite = function() { if (Constants.DEBUG_ENABLED) { var t = this.game.add.graphics(0, 0);
                t.beginFill(16711680, .5), t.drawRect(0, 0, this.hitRect.width, this.hitRect.height), t.endFill(); var e = t.generateTexture();
                t.destroy(), this.hitBoxVisual = this.game.add.sprite(GameData.Boss4DashHitboxOffsetX, GameData.Boss4DashHitboxOffsetX, e), this.hitBoxVisual.anchor.set(.5), this.addChild(this.hitBoxVisual), this.hitBoxVisual.visible = !1 } }, i.prototype.setTrigger = function() { var e = this.leftBound,
                i = this.rightBound - e;
            this.triggerSprite = this.game.add.sprite(e + .5 * i, this.floorY - 500), this.game.physics.box2d.enable(this.triggerSprite), this.triggerSprite.body.setRectangle(i, 1e3), this.triggerSprite.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Items, this.triggerSprite.body.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, this.triggerSprite.body.static = !0, this.triggerSprite.body.sensor = !0, this.triggerSprite.body.setBodyContactCallback(this.player, this.triggerEnter, this); var o = new box2d.b2Filter;
            o.categoryBits = t.CollisionLayers.Map, o.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable; var n = .5 * (this.rightBound - this.leftBound);
            this.boundsBody = this.game.physics.box2d.createBody(this.leftBound + n, this.floorY - 500), this.boundsBody.setEdge(-n, -500, -n, 500).SetFilterData(o), this.boundsBody.addEdge(n, -500, n, 500).SetFilterData(o), this.boundsBody.static = !0, this.boundsBody.friction = 0, this.boundsBody.gravityScale = 0, this.boundsBody.data.SetActive(!1), this.boundsBody.data.m_userData = { isSlope: !1, isPlatform: !1, activeCount: 0 } }, i.prototype.triggerEnter = function(t, e, i, o, n, s) { n && this.state.can("start") && (this.triggerSprite.body.removeFromWorld(), this.state.start()) }, i.prototype.getFloorPoint = function() { var e = this.y,
                i = t.Utilities.getRaycastPoint(this.game, this.x, this.y, 0, 1); return null !== i && (e = i.y), e }, i.prototype.setAudioTrigger = function() { var e = this.leftBound,
                i = this.y,
                o = t.Utilities.getRaycastPoint(this.game, this.zoneX, this.y, 0, -1);
            null !== o && (i = o.y), null !== (o = t.Utilities.getRaycastPoint(this.game, this.zoneX, this.y, -1, 0)) && (e = o.x), this.audioTriggerPoint = new Phaser.Point(e, i) }, i.prototype.setSpine = function() { this.spine = this.game.add.spine(0, 0, "hot_shot"), this.addChild(this.spine), this.spine.anchor.set(.5, .5), this.setSpineDirection(), this.spineAnimationNames = { run: "run", stand: "stand", jumpIn: "stand_to_dash", jumpLoop: "dash2", jumpOut: "dash_out", attack: "attack" }, this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0) }, i.prototype.createFiniteStateMachine = function() { var t, e = this;
            t = { init: "waiting", transitions: [{ name: "start", from: "waiting", to: "intro" }, { name: "shoot", from: "intro", to: "shooting" }, { name: "dash", from: "shooting", to: "dashing" }, { name: "shoot", from: "dashing", to: "shooting" }], methods: { onStart: function() { e.player.walkIn(e.x - GameData.Boss4FacingDistance, !1), e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0), e.onStart.dispatch(), e.player.onAfterIntro.addOnce(function() { e.game.ph2AudioManager.playEffect("boss1", !1), e.game.time.events.add(1e3, e.startBoss, e), e.boundsBody.data.SetActive(!0) }, e), e.player.onGround || e.player.onGroundCollision.addOnce(function() { e.player.spine.setAnimationByName(0, e.player.spineAnimationNames.walk, !0) }, e) }, onShoot: function() { e.setVulnerable(), e.spine.addAnimationByName(0, e.spineAnimationNames.stand, !0), e.initY = e.body.y, e.shootPatternIndex = 0, e.initMoveShoot() }, onDash: function() { e.prepareDash() } } }, this.state = new StateMachine(t) }, i.prototype.startBoss = function() { this.game.ph2AudioManager.getMusicEnabled() && t.Audios.playMusic(this.game, t.MusicID.BOSS), this.spine.setAnimationByName(0, this.spineAnimationNames.stand), this.timerEvent = null, t.Instances.cameraManager.setBound(this.leftBound, null, this.rightBound - this.leftBound, null), this.player.restoreWalkIn(), this.state.shoot() }, i.prototype.initMoveShoot = function() { if (this.player.isAlive()) { var t = this.initY - GameData.Boss4ShootPositionY[this.shootPatternIndex],
                    e = Math.abs(this.body.y - t); if (0 === e) this.shootProyectile();
                else { this.spine.setAnimationByName(0, this.spineAnimationNames.jumpIn, !1), this.spine.addAnimationByName(0, this.spineAnimationNames.jumpLoop, !0); var i = e * GameData.Boss4FallVelocity;
                    this.tweenMove = this.game.add.tween(this.body).to({ y: t }, i, Phaser.Easing.Circular.Out, !0), this.tweenMove.onComplete.addOnce(this.shootProyectile, this) } } }, i.prototype.shootProyectile = function() { this.spine.setAnimationByName(0, this.spineAnimationNames.attack, !1), this.spine.onComplete.addOnce(this.endShoot, this), this.createShoot() }, i.prototype.createShoot = function() { if (this.player.isAlive()) new t.BulletNormal(this.game, this.body.x + GameData.Boss4ShootOffsetX * this.lookDirection.x, this.body.y + GameData.Boss4ShootOffsetY, this.parent, this.lookDirection, GameData.Boss4ShootVelcoity * GameData.PixToMet, t.CollisionLayers.Player, GameData.Boss4ShootDamage, 1e3 * GameData.Boss4ShootTimeLife, this.player.body) }, i.prototype.endShoot = function() { var t = Math.abs(this.body.y - this.initY); if (0 === t) this.nextShoot(null, null, !1);
            else { this.spine.setAnimationByName(0, this.spineAnimationNames.jumpLoop, !0); var e = t * GameData.Boss4FallVelocity;
                this.tweenMove = this.game.add.tween(this.body).to({ y: this.initY }, e, Phaser.Easing.Circular.Out, !0), this.tweenMove.onComplete.addOnce(this.nextShoot, this, 0, !0) } }, i.prototype.nextShoot = function(t, e, i) { var o = GameData.Boss4ShootPositionY.length;
            this.shootPatternIndex = this.shootPatternIndex + 1, this.shootPatternIndex === o ? (this.shootPatternIndex = 0, i ? (this.spine.onComplete.removeAll(), this.spine.setAnimationByName(0, this.spineAnimationNames.jumpOut, !1), this.spine.addAnimationByName(0, this.spineAnimationNames.stand, !0), this.spine.onComplete.addOnce(this.initCooldown, this)) : this.initCooldown()) : i ? (this.spine.onComplete.removeAll(), this.spine.setAnimationByName(0, this.spineAnimationNames.jumpOut, !1), this.spine.addAnimationByName(0, this.spineAnimationNames.stand, !0), this.spine.onComplete.addOnce(this.initMoveShoot, this)) : this.initMoveShoot() }, i.prototype.initCooldown = function() { this.timer.add(1e3 * GameData.Boss4ShootCooldown, this.initMoveShoot, this) }, i.prototype.prepareDash = function() { if (this.timer.removeAll(), this.spine.onComplete.removeAll(), this.tweenMove && this.tweenMove.isRunning) return this.tweenMove.onComplete.removeAll(), void this.tweenMove.onComplete.addOnce(this.endFallDash, this); var t = Math.abs(this.body.y - this.initY); if (t > 0) { this.spine.setAnimationByName(0, this.spineAnimationNames.jumpLoop, !0); var e = t * GameData.Boss4FallVelocity;
                this.tweenMove = this.game.add.tween(this.body).to({ y: this.initY }, e, Phaser.Easing.Circular.Out, !0), this.tweenMove.onComplete.addOnce(this.endFallDash, this, 0, !0) } else this.startDash() }, i.prototype.endFallDash = function() { this.spine.setAnimationByName(0, this.spineAnimationNames.jumpOut, !1), this.spine.addAnimationByName(0, this.spineAnimationNames.stand, !0), this.spine.onComplete.addOnce(this.prepareDash, this) }, i.prototype.startDash = function() { this.timer.add(1e3 * GameData.Boss4DashDelay, this.executeDash, this) }, i.prototype.executeDash = function() { this.setInvulnerable(!0), this.isDashing = !0, this.dashDamageActive = !0, Constants.DEBUG_ENABLED && (this.hitBoxVisual.position.set(GameData.Boss4DashHitboxOffsetX * this.lookDirection.x, GameData.Boss4DashHitboxOffsetY), this.hitBoxVisual.visible = !0) }, i.prototype.update = function() {!t.Instances.paused && this.spine.visible && (this.spine.update(), this.isDashing && this.checkDash(), this.walkingOut && this.checkWalkOut(), this.waitingPlayer && this.player.x > this.audioTriggerPoint.x && this.player.y > this.audioTriggerPoint.y && (this.waitingPlayer = !1, this.game.ph2AudioManager.getMusicEnabled() && this.game.ph2AudioManager.fadeCurrentMusic(1, 0, GameData.BossAudioFadeTime))) }, i.prototype.checkDash = function() { this.dashDamageActive && this.checkDamage(), this.lookDirection.x > 0 ? this.body.x > this.rightBound - GameData.Boss4Padding ? this.endDash(this.rightBound - GameData.Boss4Padding) : this.body.velocity.x = this.dashSpeed * this.lookDirection.x : this.body.x < this.leftBound + GameData.Boss4Padding ? this.endDash(this.leftBound + GameData.Boss4Padding) : this.body.velocity.x = this.dashSpeed * this.lookDirection.x }, i.prototype.endDash = function(t) { this.body.setZeroVelocity(), this.body.reset(t, this.body.y), this.isDashing = !1, this.lookDirection.x *= -1, this.setSpineDirection(), this.state.shoot() }, i.prototype.checkDamage = function() { var t = this.game.physics.box2d.queryAABB(this.body.x + this.hitRect.x + GameData.Boss4DashHitboxOffsetX * this.lookDirection.x, this.body.y + this.hitRect.y + GameData.Boss4DashHitboxOffsetY, this.hitRect.width, this.hitRect.height); if (t.length > 0)
                for (var e = 0, i = t; e < i.length; e++) { var o = i[e];
                    0 != (o.fixture.m_filter.categoryBits & this.hitCategory) && this.hitEnemy(o.body) } }, i.prototype.hitEnemy = function(t) { t.sprite && t.sprite.hitDamage(GameData.Boss4DashDamage, !0, this.lookDirection.x, -1) }, i.prototype.checkWalkOut = function() { this.body.velocity.x = this.walkSpeed * this.lookDirection.x, this.body.x > this.game.camera.x + this.game.width && (this.walkingOut = !1, this.difficulty > 2 ? this.onEnd.dispatch() : (this.player.playFinishAnim(), this.player.onAfterOutro.add(this.onEnd.dispatch, this.onEnd))) }, i.prototype.hitDamage = function(t, e, i, o) { void 0 === t && (t = 1), void 0 === i && (i = 0), void 0 === o && (o = 0), this.lifeManager.removeLife(t), this.lifeManager.currentlifes > 0 && (this.setInvulnerable(!0), this.game.time.events.add(GameData.invulnerabilityEnemyTimeSoft, this.setVulnerable, this), this.state.dash()) }, i.prototype.setDead = function() { this.player.setInvulnerable(!0), this.player.lookDirection.x = 1, this.player.spine.scale.x = 1, this.boundsBody.removeFromWorld(), this.spine.onComplete.removeAll(), this.body.setZeroVelocity(), this.body.gravityScale = 0, this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.None, this.body.data.m_fixtureList.m_next.m_filter.categoryBits = t.CollisionLayers.None, null !== this.timerEvent && (this.timerEvent.pendingDelete = !0), this.runAway() }, i.prototype.runAway = function() { this.spine.setAnimationByName(0, this.spineAnimationNames.run, !0), this.lookDirection.x = 1, this.setSpineDirection(), this.walkingOut = !0 }, i.prototype.setAlive = function() { this.revive(), this.body.dynamic = !0, this.game.physics.box2d.addBody(this.body), this.body.dynamic = !0, this.lifeManager.addLife(this.lifeManager.maxlifes) }, i.prototype.contactEntered = function(t, e, i, o, n, s) {}, i.prototype.disableGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.spine.visible = !1, this.spine.state.timeScale = 0 }, i.prototype.enableGameElement = function() { this.revive(), this.body.data.SetActive(!0), this.spine.visible = !0, this.spine.state.timeScale = 1 }, i.prototype.destroyGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.body.removeFromWorld(), this.destroy(!0) }, i.prototype.setInvulnerable = function(e) { e ? (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable) : (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.Enemies) }, i.prototype.setVulnerable = function() { this.state.is("shooting") && this.setInvulnerable(!1) }, i.prototype.pause = function() { this.timer.pause(), this.tweenMove && this.tweenMove.pause() }, i.prototype.resume = function() { this.timer.resume(), this.tweenMove && this.tweenMove.resume() }, i.prototype.setSpineDirection = function() { this.spine.scale.x = this.lookDirection.x }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null, this.timer.removeAll(), this.timer.destroy(), this.timer = null, this.tweenMove && (this.tweenMove.stop(), this.tweenMove.onComplete.removeAll()), this.tweenMove = null }, i }(Phaser.Sprite);
    t.Boss4 = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a, h, l, c) { var d = e.call(this, i, o, n, "atlas_animations", "stinkfly_super0.png") || this; return d._hitDamage = h, d.speed = r, d.damageRate = GameData.stinkflyAcidPoolHitRate, d.acidPoolDuration = GameData.stinkflyAcidPoolDuration, d.collisionCategory = a, d.collided = !1, d.acidHit = !1, d.inTargets = [], c ? (d.targetBody = c, d.useTargetBody = !0) : (d.targetBody = null, d.useTargetBody = !1), d.poolRect = new Phaser.Rectangle(-120, -20, 240, 20), i.physics.box2d.enable(d), d.body.setRectangle(100, 27), d.body.friction = 0, d.body.linearDamping = .2, d.body.sensor = !0, d.body.bullet = !0, d.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Bullets, d.body.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Map | d.collisionCategory, d.animations.add("acid", Phaser.Animation.generateFrameNames("stinkfly_super", 0, 4, ".png"), 15, !0), d.animations.play("acid"), l.add(d), d.poolAnimation = d.game.add.ph2AnimationObject(0, 0, "stinkfly_floor", "atlas_animations"), d.poolAnimation.visible = !1, l.add(d.poolAnimation), d.poolAnimation.sendToBack(), d.hitFx = d.game.add.sprite(0, 0, "atlas_animations", "hit1_0.png"), d.hitFx.animations.add("loop", Phaser.Animation.generateFrameNames("hit1_", 0, 4, ".png"), 15, !1), d.hitFx.visible = !1, l.add(d.hitFx), d.componentManager = Ph2.ComponentPlugin.initComponents(d), d.timer = d.componentManager.addComponent(t.ComponentTimer, d.acidPoolDuration), d.timer.onComplete.add(d.endPool, d), d.timer.onUpdate.add(d.acidUpdate, d), d.lookDirection = new Phaser.Point(s.x, s.y), d.body.velocity.x = d.lookDirection.x * d.speed, d.body.angle = Phaser.Math.radToDeg(Math.atan2(s.y, s.x)), d.hitFx.scale.x = d.lookDirection.x, d.useTargetBody ? (d.targetBody.sprite.body && d.body.setBodyContactCallback(d.targetBody.sprite, d.contactEntered, d), d.body.setCategoryContactCallback(t.CollisionLayers.Map, d.bulletImpact, d)) : d.body.setFixtureContactCallback(d.body.data.m_fixtureList, d.contactEntered, d), t.Instances.onPause.add(d.pause, d), t.Instances.onResume.add(d.resume, d), Constants.DEBUG_ENABLED && (d.debugSprite = d.game.add.sprite(0, 0, "white_pixel"), d.debugSprite.alpha = .6, d.debugSprite.visible = !1), d } return __extends(i, e), i.prototype.contactEntered = function(e, i, o, n, s, r) { s && (n.m_filter.categoryBits === t.CollisionLayers.Map ? this.bulletImpact() : this.hitBulletImpact(i, r)) }, i.prototype.hitBulletImpact = function(t, e) { t.sprite.hitDamage(this._hitDamage, !1, 0, 0, !0), this.bulletImpact() }, i.prototype.bulletImpact = function() { this.hitFx.position.set(this.position.x + 50 * this.lookDirection.x, this.position.y), this.hitFx.animations.play("loop").onComplete.addOnce(this.destroyProyectile, this), this.hitFx.visible = !0, this.body.removeFromWorld(), this.animations.stop(), this.visible = !1, this.checkRaycast() }, i.prototype.checkRaycast = function() { var t;
            (t = this.game.physics.box2d.raycast(this.x, this.y - 10, this.x, this.y + 2e3, !0, i.laserFilter)).length > 0 && this.createAcidPool(t[0].point) }, i.laserFilter = function(e, i, o, n) { return 0 != (i.m_filter.categoryBits & t.CollisionLayers.Map) }, i.prototype.destroyProyectile = function() { this.hitFx.animations.stop(), this.hitFx.visible = !1 }, i.prototype.createAcidPool = function(t) { this.position.set(t.x, t.y), this.poolAnimation.position.set(t.x, t.y - 30), this.poolAnimation.ph2Animations.play("stinkfly_floor_anim"), this.poolAnimation.visible = !0, this.timer.startTimer(), Constants.DEBUG_ENABLED && (this.debugSprite.width = this.poolRect.width, this.debugSprite.height = this.poolRect.height, this.debugSprite.x = t.x + this.poolRect.x, this.debugSprite.y = t.y + this.poolRect.y, this.debugSprite.visible = !0) }, i.prototype.acidUpdate = function() { var t = this;
            this.acidHit || (this.checkTargets(), this.acidHit = !0, this.game.time.events.add(this.damageRate, function() { t.acidHit = !1 }, this)) }, i.prototype.endPool = function() { for (var t = 0, e = this.inTargets; t < e.length; t++) { var i = e[t];
                i.sprite && i.sprite.restoreSpeed() } Constants.DEBUG_ENABLED && (this.debugSprite.visible = !1), this.poolAnimation.ph2Animations.play("stinkfly_floor_out").onComplete.add(this.destroyPool, this) }, i.prototype.destroyPool = function() { this.poolAnimation.ph2Animations.stop(), this.poolAnimation.visible = !1, t.Instances.onPause.remove(this.pause, this), t.Instances.onResume.remove(this.resume, this), this.destroy(!0), this.hitFx.destroy(!0), this.poolAnimation.destroy(!0) }, i.prototype.checkTargets = function() { var e = this.game.physics.box2d.queryAABB(this.position.x + this.poolRect.x, this.position.y + this.poolRect.y, this.poolRect.width, this.poolRect.height),
                i = !1; if (e.length > 0)
                for (var o = 0, n = e; o < n.length; o++) { var s = n[o]; if (i = !1, 0 != (s.fixture.m_filter.categoryBits & this.collisionCategory)) { if (s.fixture.m_filter.categoryBits === t.CollisionLayers.Enemies) { for (var r = 0, a = this.inTargets; r < a.length; r++)
                                if (a[r].id === s.body.id) { i = !0; break } i || (this.inTargets.push(s.body), s.body.sprite.setSpeed(GameData.enemySlowSpeed)) } s.body.sprite.hitDamage(this._hitDamage, !1) } } }, i.prototype.pause = function() { this.poolAnimation.visible && this.poolAnimation.ph2Animations.pause(), this.visible && (this.animations.paused = !0), this.hitFx.visible && (this.hitFx.animations.paused = !0) }, i.prototype.resume = function() { this.poolAnimation.visible && this.poolAnimation.ph2Animations.resume(), this.visible && (this.animations.paused = !1), this.hitFx.visible && (this.hitFx.animations.paused = !1) }, i }(Phaser.Sprite);
    t.BulletAcid = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a, h, l, c, d) { void 0 === c && (c = 0); var u = e.call(this, i, o, n, "atlas_animations", "laser_loop1.png") || this; return u.animations.add("loop", Phaser.Animation.generateFrameNames("laser_loop", 1, 4, ".png"), 15, !0), u.animations.play("loop"), u.anchor.set(1, .5), u.laserLength = 100, u._hitDamage = l, u.speed = .1 * a, u.bounceCount = 0, u.bounceLimit = c, u.timeCount = 0, u.timeLimit = 5e3, u.targetCategory = h, u.collisionCategory = h | t.CollisionLayers.Map, u.collided = !1, d ? (u.targetBody = d, u.useTargetBody = !0) : (u.targetBody = null, u.useTargetBody = !1), u.lookDirection = new Phaser.Point(1, 0), r && (u.lookDirection.set(r.x, r.y), u.angle = Phaser.Math.radToDeg(Math.atan2(r.y, r.x)) - 180), u.hitFx = u.game.add.sprite(0, 0, "atlas_animations", "laser_hit1.png"), u.hitFx.anchor.set(.5), u.hitFx.animations.add("loop", Phaser.Animation.generateFrameNames("laser_hit", 1, 4, ".png"), 15, !1), u.hitFx.visible = !1, s.add(u), s.add(u.hitFx), u } return __extends(i, e), i.prototype.update = function() { this.visible && (this.timeCount += this.game.time.elapsedMS, this.timeCount > this.timeLimit ? (this.hitFx.position.set(this.position.x, this.position.y), this.hitFx.animations.play("loop").onComplete.addOnce(this.destroyProyectile, this), this.hitFx.visible = !0, this.visible = !1) : (this.position.x += this.lookDirection.x * this.speed * this.game.time.elapsedMS, this.position.y += this.lookDirection.y * this.speed * this.game.time.elapsedMS, this.checkRaycast())) }, i.prototype.checkRaycast = function() { var t;
            (t = this.game.physics.box2d.raycast(this.x, this.y, this.x + this.lookDirection.x * this.laserLength, this.y + this.lookDirection.y * this.laserLength, !0, this.laserFilter.bind(this))).length > 0 && (0 != (t[0].fixture.m_filter.categoryBits & this.targetCategory) ? (this.hitFx.position.set(t[0].point.x, t[0].point.y), 0 === t[0].normal.x ? 0 !== t[0].normal.y && (this.hitFx.angle = 90, this.hitFx.scale.x = Phaser.Math.sign(this.lookDirection.y), this.hitFx.visible = !0) : 0 === t[0].normal.y && 0 !== t[0].normal.x && (this.hitFx.angle = 0, this.hitFx.scale.x = Phaser.Math.sign(this.lookDirection.x), this.hitFx.visible = !0), this.bulletImpact(t[0].body)) : (this.position.copyFrom(t[0].point), this.hitFx.position.set(this.position.x, this.position.y), this.bounceRaycast(t[0].normal))) }, i.prototype.laserFilter = function(t, e, i, o) { return 0 != (e.m_filter.categoryBits & this.collisionCategory) }, i.prototype.destroyProyectile = function() { this.hitFx.destroy(!0), this.destroy(!0) }, i.prototype.bulletImpact = function(t) { t.sprite.hitDamage(this._hitDamage, !0, this.lookDirection.x, -1), this.visible = !1, this.hitFx.animations.play("loop").onComplete.addOnce(this.destroyProyectile, this) }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.bounceRaycast = function(t) { 0 === t.x ? 0 !== t.y && (this.lookDirection.y *= -1, this.hitFx.angle = 90, this.hitFx.scale.x = Phaser.Math.sign(this.lookDirection.y), this.hitFx.visible = !0, this.bounce()) : 0 === t.y && 0 !== t.x && (this.lookDirection.x *= -1, this.hitFx.angle = 0, this.hitFx.scale.x = Phaser.Math.sign(this.lookDirection.x), this.hitFx.visible = !0, this.bounce()) }, i.prototype.bounce = function() {++this.bounceCount > this.bounceLimit ? (this.visible = !1, this.hitFx.animations.play("loop").onComplete.addOnce(this.destroyProyectile, this)) : (this.angle = Phaser.Math.radToDeg(Math.atan2(this.lookDirection.y, this.lookDirection.x)) - 180, this.hitFx.animations.play("loop").onComplete.addOnce(this.hideFx, this), this.playSoundBounce()) }, i.prototype.playSoundBounce = function() { var e = { key: "obstacle_laser_wall2", x: this.x - this.width / 2, y: this.y, width: this.width, height: this.height };
            t.Audios.playSfxZone(this.game, e) }, i.prototype.hideFx = function() { this.hitFx.visible = !1 }, i }(Phaser.Sprite);
    t.BulletLaser = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a, h, l, c, d) { var u = e.call(this, i, o, n, "atlas_animations", "laser_loop1.png") || this; return u._hitDamage = l, u.speed = a, u.maxDistance = 1e3, u.collisionCategory = h, u.collided = !1, d ? (u.targetBody = d, u.useTargetBody = !0) : (u.targetBody = null, u.useTargetBody = !1), i.add.existing(u), i.physics.box2d.enable(u), u.body.setRectangle(100, 27), u.body.friction = 0, u.body.linearDamping = 0, u.body.gravityScale = 0, u.body.sensor = !0, u.body.bullet = !0, u.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Bullets, u.body.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Map | u.collisionCategory, u.animations.add("loop", Phaser.Animation.generateFrameNames("laser_loop", 1, 4, ".png"), 15, !0), u.animations.play("loop"), u.hitFx = u.game.add.sprite(0, 0, "atlas_animations", "laser_hit1.png"), u.hitFx.animations.add("loop", Phaser.Animation.generateFrameNames("laser_hit", 1, 4, ".png"), 15, !1), u.hitFx.visible = !1, s.add(u), s.add(u.hitFx), u.componentManager = Ph2.ComponentPlugin.initComponents(u), u.lookDirection = new Phaser.Point(1, 0), r && u.lookDirection.set(r.x, r.y), u.body.velocity.x = u.speed * r.x, u.body.velocity.y = u.speed * r.y, u.scale.x = -u.lookDirection.x, u.hitFx.scale.x = u.lookDirection.x, u.lifeTimer = u.componentManager.addComponent(t.ComponentTimer, c, !0), u.lifeTimer.onComplete.add(u.bulletImpact, u), u.useTargetBody ? (u.targetBody.sprite.body && u.body.setBodyContactCallback(u.targetBody.sprite, u.contactEntered, u), u.body.setCategoryContactCallback(t.CollisionLayers.Map, u.bulletImpact, u)) : (u.body.setCategoryContactCallback(u.collisionCategory, u.contactEntered, u), u.body.setCategoryContactCallback(t.CollisionLayers.Map, u.bulletImpact, u)), t.Instances.onPause.add(u.pause, u), t.Instances.onResume.add(u.resume, u), u } return __extends(i, e), i.prototype.hitBulletImpact = function(t, e) { t.sprite.hitDamage(this._hitDamage, !0, this.lookDirection.x, -1), this.bulletImpact() }, i.prototype.bulletImpact = function() { this.hitFx.position.set(this.position.x + 50 * this.lookDirection.x, this.position.y), this.hitFx.animations.play("loop").onComplete.addOnce(this.destroyProyectile, this), this.hitFx.visible = !0, this.stopProyectile() }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.stopProyectile = function() { this.body.removeFromWorld(), this.animations.stop(), this.visible = !1, this.componentManager.removeAllComponents() }, i.prototype.destroyProyectile = function() { t.Instances.onPause.remove(this.pause, this), t.Instances.onResume.remove(this.resume, this), this.hitFx.animations.stop(), this.hitFx.destroy(!0), this.destroy(!0), this.hitFx = null }, i.prototype.contactEntered = function(t, e, i, o, n, s) { n && this.hitBulletImpact(e, s) }, i.prototype.pause = function() { this.visible && (this.animations.paused = !0), this.hitFx.visible && (this.hitFx.animations.paused = !0) }, i.prototype.resume = function() { this.visible && (this.animations.paused = !1), this.hitFx.visible && (this.hitFx.animations.paused = !1) }, i }(Phaser.Sprite);
    t.BulletNormal = e }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function e(t, e, i, o, n) { this.totalSum = 0, this.game = t, this.player = e, this.spawnPoints = i, this.spawnList = o, this.spawnGroup = n, this.currentSpawnCursor = 0, this.spawnSetCursor = 0, this.spawnItemCursor = 0, this.spawnTable = { ctx: this, items: [{ id: 0, ctor: this.createMeleeA, prob: .5 }, { id: 1, ctor: this.createMeleeB, prob: .5 }, { id: 2, ctor: this.createMeleeC, prob: .5 }, { id: 3, ctor: this.createRangeA, prob: .5 }, { id: 4, ctor: this.createRangeB, prob: .5 }, { id: 5, ctor: this.createRangeC, prob: .5 }] }; for (var s = 0, r = this.spawnTable.items; s < r.length; s++) { var a = r[s];
                this.totalSum += a.prob } this.onSetComplete = new Phaser.Signal, this.onAllComplete = new Phaser.Signal } return e.prototype.pickItem = function(t) { var e; for (e = 0; e < this.spawnTable.items.length; e++)
                if (t === this.spawnTable.items[e].id) return this.spawnTable.items[e].ctor.call(this.spawnTable.ctx); return this.spawnTable.items[0].ctor.call(this.spawnTable.ctx) }, e.prototype.pickNextItem = function() { var t = this.spawnList[this.spawnSetCursor][this.spawnItemCursor];++this.spawnItemCursor === this.spawnList[this.spawnSetCursor].length && this.onSetComplete.dispatch(); var e = this.pickItem(t); return ++this.currentSpawnCursor >= this.spawnPoints.length && (this.currentSpawnCursor = 0), e }, e.prototype.pickRandomItem = function() { for (var t = this.game.rnd.between(0, this.totalSum), e = 0, i = 0; e < t;) e += this.spawnTable.items[i++].prob; return i = Math.max(0, i - 1), this.spawnTable.items[i].ctor.call(this.spawnTable.ctx) }, e.prototype.nextSet = function() { this.spawnSetCursor++, this.spawnItemCursor = 0 }, e.prototype.isSetComplete = function() { return this.spawnItemCursor === this.spawnList[this.spawnSetCursor].length }, e.prototype.waveComplete = function() { return this.spawnSetCursor === this.spawnList.length }, e.prototype.resetIteration = function() { this.spawnSetCursor = 0, this.spawnItemCursor = 0 }, e.prototype.destroy = function() { this.game = null, this.player = null, delete this.spawnTable }, e.prototype.getYPosition = function(t, e) { var i, o = e,
                n = t,
                s = e; return (i = this.game.physics.box2d.raycast(n, s, n, s + 1e3, !0, this.mapRaycastFilter)).length > 0 && (o = i[0].point.y), o }, e.prototype.mapRaycastFilter = function(e, i, o, n) { return i.m_filter.categoryBits === t.CollisionLayers.Map }, e.prototype.createMeleeA = function() { var e = this.spawnPoints[this.currentSpawnCursor],
                i = this.getYPosition(e.x, e.y);
            i -= EnemiesParameters.Enemy0.bodyWidth / 2; var o = new t.EnemyMeleeA(this.game, this.player, e.x, i, 0, 0); return o.spine.scale.x = void 0, this.spawnGroup.add(o), o }, e.prototype.createMeleeB = function() { var e = this.spawnPoints[this.currentSpawnCursor],
                i = this.getYPosition(e.x, e.y);
            i -= EnemiesParameters.Enemy1.bodyWidth / 2; var o = new t.EnemyMeleeB(this.game, this.player, e.x, i, 0, 0); return this.spawnGroup.add(o), o }, e.prototype.createMeleeC = function() { var e = this.spawnPoints[this.currentSpawnCursor],
                i = this.getYPosition(e.x, e.y);
            i -= EnemiesParameters.Enemy2.bodyWidth / 2; var o = new t.EnemyMeleeC(this.game, this.player, e.x, i, 0, 0); return this.spawnGroup.add(o), o }, e.prototype.createRangeA = function() { return null }, e.prototype.createRangeB = function() { var e = this.spawnPoints[this.currentSpawnCursor],
                i = this.getYPosition(e.x, e.y);
            i -= EnemiesParameters.Enemy4.bodyWidth / 2; var o = new t.EnemyRangeB(this.game, this.player, e.x, i, this.game.camera.x + GameData.enemyRangeBWavePathMargins, this.game.camera.x + this.game.width - GameData.enemyRangeBWavePathMargins); return this.spawnGroup.add(o), o }, e.prototype.createRangeC = function() { return null }, e }();
    t.ItemSelector = e }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function t(t, e) { this.maxLifes = t, this.lifes = t, this.onNoLife = new Phaser.Signal, this.onLostLife = new Phaser.Signal, this.onEarnLife = new Phaser.Signal, this.isEnabled = !0, this.parent = e } return t.prototype.addLife = function(t) { void 0 === t && (t = 1), this.isEnabled && (this.lifes + t > this.maxLifes ? this.lifes = this.maxLifes : this.lifes += t, this.onEarnLife.dispatch(this.lifes / this.maxLifes)) }, t.prototype.setLife = function(t) { this.isEnabled && (this.lifes = t, this.onEarnLife.dispatch(this.lifes / this.maxLifes)) }, t.prototype.removeLife = function(t) { void 0 === t && (t = 1), this.isEnabled && (this.lifes - t <= 0 ? (this.lifes = 0, this.onLostLife.dispatch(0), this.onNoLife.dispatch(this.parent)) : (this.lifes -= t, this.onLostLife.dispatch(this.lifes / this.maxLifes))) }, Object.defineProperty(t.prototype, "currentlifes", { get: function() { return this.lifes }, enumerable: !0, configurable: !0 }), Object.defineProperty(t.prototype, "maxlifes", { get: function() { return this.maxLifes }, enumerable: !0, configurable: !0 }), t.prototype.setMaxLifes = function(t) { this.maxLifes = t }, t.prototype.destroy = function() { this.onNoLife.dispose(), this.onLostLife.dispose(), this.onEarnLife.dispose(), this.onEarnLife = null, this.onNoLife = null, this.onLostLife = null, this.parent = null }, t.prototype.isFull = function() { return this.lifes === this.maxLifes }, t }();
    t.LifeManager = e }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function e(e, i, o, n, s, r, a, h, l, c, d, u, p, m) { var f = this; if (this.game = e, this.player = i, this.currentLevel = r, this.playBeginning = o, this.fromAbove = n, this.fromRetry = s, this.gameplayUI = p, this.joystickUI = m, this.sectionEnd = [], this.waveScenes = [], this.mapFixtures = [], this.mapSprites = [], this.platformArray = [], this.mines = [], this.enemies = [], this.platforms = [], this.enemiesPath = [], this.points = [], this.lockSpawners = [], this.backgroundCtrl = [], this.tiledSpriteProxy = [], this.spawnerHeads = [], this.loadedAtlases = [], this.animationsPh2 = [], this.animationsSpr = [], this.spawnPoint = null, this.spawnPointFloor = 0, this.sectionEndTile = null, this.bossObject = null, this.boss = null, this.spawnCharacter = t.CharactersEnum.FourArms, this.lastSafePoint = new Phaser.Point, this.onGameEnd = new Phaser.Signal, this.onSectionEnd = new Phaser.Signal, this.lastDummy = null, this.useAtlas = !1, this.chunkSize = 800, this.currentChunkId = -1, this.currentCol = -1, this.currentRow = -1, this.visibleChunksHor = 2, this.visibleChunksVer = 2, this.gidPatternDictionary = {}, this.currentSectionNum = this.getSectionNumber(), this.nextSection = "", this.nextSectionNum = -1, this.isBoss = !1, this.checkPoint = null, this.player.onDeath.add(this.endLose, this), this.player.onAfterIntro.add(this.afterIntro, this), this.dangerEffectAlert = Ph2.UISystem.findObject("alert_container", this.gameplayUI), this.dangerEffectLeft = Ph2.UISystem.findObject("left_fx", this.gameplayUI), this.dangerEffectRight = Ph2.UISystem.findObject("right_fx", this.gameplayUI), this.animationsPh2.push(this.dangerEffectAlert), this.animationsPh2.push(this.dangerEffectLeft), this.animationsPh2.push(this.dangerEffectRight), this.lifeFullFx = Ph2.UISystem.findObject("life_container/life_bar_fx", this.gameplayUI), this.lifeFullFx.visibility.enable(!1), this.lifeFullFx.visible = !1, this.lifeFullFx.ph2Animations.getAnimations().power_life_bar_fx_full.onComplete.add(function() { f.lifeFullFx.visible = !1 }, this), this.powerFullFx = Ph2.UISystem.findObject("life_container/power_bar_fx", this.gameplayUI), this.powerFullFx.visibility.enable(!1), this.powerFullFx.visible = !1, this.powerFullFx.ph2Animations.getAnimations().power_life_bar_fx_full.onComplete.add(function() { f.powerFullFx.visible = !1 }, this), Constants.DEBUG_ENABLED) { var y = this.game.add.group();
                y.fixedToCamera = !0, this.minimapGroup = this.game.add.group(), y.addChild(this.minimapGroup) } this.backGroup = a, this.mapGroup = h, this.decoGroup = l, this.objectsGroup = c, this.frontDecoGroup = d, this.uiGroup = u, this.arrowMarker = this.game.add.ph2AnimationObject(this.game.width - 110, .5 * this.game.height, "arrow_gp", "atlas_ui_gameplay"), this.arrowMarker.visible = !1, this.uiGroup.add(this.arrowMarker); var b = this.game.cache.getJSON(r); if (1.2 === b.version) { for (var g, _ = 0, v = b.tilesets; _ < v.length; _++) { var x = v[_]; if (x.source) { var S = x.source.split("/"),
                            C = S[S.length - 1].split(".")[0]; if (this.game.cache.checkJSONKey(C)) { g = this.game.cache.getJSON(C); var w = "",
                                A = C.split("_");
                            A.length > 1 && "map" === A[0] && (A.splice(0, 1), w = "atlas_" + A.join("_")), -1 === this.loadedAtlases.indexOf(w) && this.loadedAtlases.push(w); for (var T = 0, P = g.tiles; T < P.length; T++) { var k = P[T];
                                k.atlas = w, this.gidPatternDictionary[x.firstgid + k.id] = k } } } } for (var M = null, E = null, B = null, I = null, D = null, L = null, O = null, R = [], F = 0, V = b.layers; F < V.length; F++) { var G = V[F]; switch (G.name) {
                        case "background":
                            D = G; break;
                        case "map_collision":
                            M = G; break;
                        case "map":
                            E = G; break;
                        case "deco_back":
                            B = G; break;
                        case "objects":
                            L = G; break;
                        case "deco_front":
                            I = G; break;
                        case "misc":
                            O = G; break;
                        default:
                            G.name.indexOf("hidden") >= 0 && R.push(G) } } this.setMapBounds(M), Constants.CHUNKS_ENABLED && this.initChunkList(), this.loadBackgrounds(D), this.loadMapCollision(M), this.loadObjects(L), this.loadMapGraphics(E), Constants.LOAD_DECORATIONS && this.loadMapDecoration(B, this.decoGroup), null === this.spawnPoint && (this.spawnPoint = new Phaser.Point(100, 100)), this.player.changeToCharacter(this.spawnCharacter), this.sectionEndTile && this.addEndOfSection(this.sectionEndTile), this.loadHiddenGraphics(R), Constants.LOAD_DECORATIONS && this.loadMapDecoration(I, this.frontDecoGroup), Constants.CHUNKS_ENABLED && this.chunkPreUpdate(), this.loadMiscellaneous(O) } else this.game.state.start("mainmenuState", !0, !1) } return e.prototype.afterIntro = function() { var e = this;
            t.Instances.isGameplayActive = !0, this.joystickUI && this.joystickUI.enableInput(), this.checkPoint && (this.game.ph2AudioManager.playEffect("checkpoint", !1), this.checkPoint.ph2Animations.play("checkpoint_in", 1, !1).onComplete.addOnce(function() { e.checkPoint.ph2Animations.play("checkpoint_loop", 1, !0) }, this)) }, e.prototype.setMapBounds = function(t) { if (this.mapBounds = new box2d.b2AABB, this.mapBounds.lowerBound.x = 1 / 0, this.mapBounds.lowerBound.y = 1 / 0, this.mapBounds.upperBound.x = -1 / 0, this.mapBounds.upperBound.y = -1 / 0, this.mapWidth = 0, this.mapHeight = 0, null === t) return this.mapWidth = 2e3, void(this.mapHeight = 2e3); if (0 === t.objects.length) return this.mapWidth = 2e3, void(this.mapHeight = 2e3); for (var e = 0, i = t.objects; e < i.length; e++) { var o = i[e];
                o.x < this.mapBounds.lowerBound.x && (this.mapBounds.lowerBound.x = o.x, o.x), o.y < this.mapBounds.lowerBound.y && (this.mapBounds.lowerBound.y = o.y, o.y), o.x + o.width > this.mapBounds.upperBound.x && (this.mapBounds.upperBound.x = o.x + o.width, o.x, o.width), o.y + o.height > this.mapBounds.upperBound.y && (this.mapBounds.upperBound.y = o.y + o.height, o.y, o.height) } this.mapBounds.lowerBound.x === 1 / 0 || this.mapBounds.lowerBound.y === 1 / 0 || this.mapBounds.upperBound.x === -1 / 0 || this.mapBounds.upperBound.y, this.mapBounds.upperBound.y += .5 * this.game.height, this.mapWidth = this.mapBounds.upperBound.x - this.mapBounds.lowerBound.x, this.mapHeight = this.mapBounds.upperBound.y - this.mapBounds.lowerBound.y }, e.prototype.initChunkList = function() { var t, e = Math.ceil(this.mapWidth / this.chunkSize),
                i = Math.ceil(this.mapHeight / this.chunkSize);
            Constants.DEBUG_ENABLED && (this.minimapGroup.x = this.game.width - 6 * e, (t = this.game.add.sprite(0, 0, "black_pixel", null, this.minimapGroup)).width = 6 * e, t.height = 6 * i, t.alpha = .5); var o = 0;
            this.chunks = []; for (var n = 0; n < e; n++) { this.chunks[n] = []; for (var s = 0; s < i; s++) { var r = null;
                    Constants.DEBUG_ENABLED && ((r = this.game.add.sprite(6 * n, 6 * s, "white_pixel")).width = 4, r.height = 4, r.alpha = .5, this.minimapGroup.add(r)), this.chunks[n][s] = { visible: !1, id: o, x: n * this.chunkSize, y: s * this.chunkSize, debugSprite: r, childrenSpr: [], childrenBdy: [], childrenEnemy: [], childrenItems: [] }, o++ } } }, e.prototype.loadBackgrounds = function(e) { if (null === e) return (i = new t.TileController(this.game, "bg_grid")).width = this.game.width, i.height = this.game.height, i.setDefinition(0, this.mapWidth, 0, this.mapHeight, !0, !0), i.alpha = .6, this.backGroup.add(i), void t.Instances.callbackSubscriber.onLateUpdate.add(i.tileUpdate, i); if (0 === e.objects.length) { var i = new t.TileController(this.game, "bg_grid"); return i.width = this.game.width, i.height = this.game.height, i.setDefinition(0, this.mapWidth, 0, this.mapHeight, !0, !0), i.alpha = .6, this.backGroup.add(i), void t.Instances.callbackSubscriber.onLateUpdate.add(i.tileUpdate, i) } for (var o, n = 0, s = e.objects; n < s.length; n++) { var r = s[n]; if (o = r.gid & GameData.idMask, this.gidPatternDictionary[o]) { var a = this.getImageName(this.gidPatternDictionary[o], !1); if (this.game.cache.checkImageKey(a)) { this.checkBgParentParams(r, this.gidPatternDictionary[o]);
                        m = new t.BackgroundController(this.game, r, this.backGroup, a);
                        this.backgroundCtrl.push(m), t.Instances.callbackSubscriber.onLateUpdate.add(m.tileUpdate, m) } else { for (var h = !1, l = void 0, c = 0, d = this.loadedAtlases; c < d.length; c++) { var u = d[c]; if (0 !== u.length) { var p = this.game.cache.getFrameData(u); if (p && p.checkFrameName(a + ".png")) { h = !0, l = u; break } } } if (h) { this.checkBgParentParams(r, this.gidPatternDictionary[o]); var m = new t.BackgroundController(this.game, r, this.backGroup, l, a + ".png");
                            this.backgroundCtrl.push(m), t.Instances.callbackSubscriber.onLateUpdate.add(m.tileUpdate, m) } } } } }, e.prototype.loadMapCollision = function(t) { if (null !== t)
                for (var e = 0, i = t.objects; e < i.length; e++) { var o = i[e];
                    this.addObjectCollision(o) } }, e.prototype.addObjectCollision = function(e, i, o) { void 0 === i && (i = 0), void 0 === o && (o = 0); var n, s, r = this.game.add.sprite(0, 0, null);
            this.game.physics.box2d.enable(r), (n = r.body).data.m_userData = { isSlope: !1, isPlatform: !1, activeCount: 0 }; var a = { left: e.x + i, right: e.x + i, top: e.y + o, bottom: e.y + o };
            s = n.setRectangle(e.width, e.height), a.bottom += e.height, a.right += e.width, n.reset(e.x + i + .5 * e.width, e.y + o + .5 * e.height), n.static = !0, s ? (s.SetFriction(0), s.m_filter.categoryBits = t.CollisionLayers.Map, s.m_filter.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable | t.CollisionLayers.EnemyInvulnerable | t.CollisionLayers.Enemies | t.CollisionLayers.Bullets, this.mapFixtures.push(s), this.mapSprites.push(r), Constants.CHUNKS_ENABLED && (this.addBodyToChunk(n, a), n.data.SetActive(!1))) : n.data.SetActive(!1), e.properties && "platform" === e.properties[0].name && (n.data.m_userData.isPlatform = !0) }, e.prototype.loadMapGraphics = function(t) { if (null !== t)
                for (var e = 0; e < t.objects.length; e++) { var i = t.objects[e];
                    this.checkObjectBody(i), this.loadMapGraphicObject(i, this.mapGroup, e) } }, e.prototype.loadMapGraphicObject = function(e, i, o, n, s) { void 0 === n && (n = !1), void 0 === s && (s = !0); var r, a = e.gid & GameData.idMask; if (this.gidPatternDictionary[a]) { if (this.checkTiledParentParams(e, this.gidPatternDictionary[a]), this.gidPatternDictionary[a].atlas && this.gidPatternDictionary[a].atlas.length > 0 && "arbol" !== this.getImageName(this.gidPatternDictionary[a], !1)) r = new t.SpriteProxy(this.game, e, i, o, this.gidPatternDictionary[a].atlas, this.getImageName(this.gidPatternDictionary[a], !0), s);
                else { var h = this.getImageName(this.gidPatternDictionary[a], !1); if ("tutorial" === h) { var l = this.game.device.desktop ? "desktop" : "mobile";
                        r = new t.SpriteProxy(this.game, e, i, o, l, null, s) } else r = new t.SpriteProxy(this.game, e, i, o, h, null, s) } r.useTileSprite && this.tiledSpriteProxy.push(r), n && Constants.CHUNKS_ENABLED ? this.addSpriteToChunk(r, e) : r.visible = !0 } }, e.prototype.loadMapDecoration = function(t, e) { if (null !== t)
                for (var i = 0; i < t.objects.length; i++) { var o = t.objects[i];
                    this.checkObjectBody(o), this.loadMapGraphicObject(o, e, i, !0, !1) } }, e.prototype.loadObjects = function(e) { if (null !== e) { for (var i, o = Constants.LOAD_TRAPS, n = {}, s = 0, r = e.objects; s < r.length; s++) { var a = r[s]; if (i = a.gid & GameData.idMask, this.gidPatternDictionary[i]) { if (this.gidPatternDictionary[i].type) switch (n[this.gidPatternDictionary[i].type] || (n[this.gidPatternDictionary[i].type] = 0), n[this.gidPatternDictionary[i].type]++, this.gidPatternDictionary[i].type) {
                            case "spawn":
                                var h = a.y,
                                    l = Math.round(a.x + .5 * a.width),
                                    c = a.y - .5 * a.height,
                                    d = void 0;
                                (d = this.game.physics.box2d.raycast(l, c, l, c + 1e3, !0, this.mapRaycastFilter)).length > 0 && (h = d[0].point.y), this.spawnPointFloor = h, this.spawnPoint = new Phaser.Point(l, h); var u = void 0; switch (this.gidPatternDictionary[i].properties[0].value) {
                                    case "fourarms":
                                        this.spawnCharacter = t.CharactersEnum.FourArms, u = PlayerParameters.FourArms; break;
                                    case "xlr8":
                                        this.spawnCharacter = t.CharactersEnum.XLR8, u = PlayerParameters.XLR8; break;
                                    case "stinkfly":
                                        this.spawnCharacter = t.CharactersEnum.Stinkfly, u = PlayerParameters.Stinkfly; break;
                                    case "slapback":
                                        this.spawnCharacter = t.CharactersEnum.Slapback, u = PlayerParameters.Slapback; break;
                                    case "cannonbolt":
                                        this.spawnCharacter = t.CharactersEnum.Cannonbolt, u = PlayerParameters.Cannonbolt; break;
                                    case "heatblast":
                                        this.spawnCharacter = t.CharactersEnum.Heatblast, u = PlayerParameters.Heatblast; break;
                                    case "rath":
                                        this.spawnCharacter = t.CharactersEnum.Rath, u = PlayerParameters.Rath; break;
                                    case "humungousaur":
                                        this.spawnCharacter = t.CharactersEnum.Humungousaur, u = PlayerParameters.Humungousaur; break;
                                    case "diamondhead":
                                        this.spawnCharacter = t.CharactersEnum.DiamondHead, u = PlayerParameters.DiamondHead; break;
                                    case "shockrock":
                                        this.spawnCharacter = t.CharactersEnum.ShockRock, u = PlayerParameters.ShockRock } var p = .5 * (u.bodyHeight + u.bodyWidth + 4);
                                this.spawnPoint.y -= p, t.Instances.cameraManager.setOffset(0, p + GameData.cameraOffsetY); var m = this.spawnPoint.x,
                                    f = this.spawnPoint.y + t.Instances.cameraManager.getOffset().y;
                                t.Instances.cameraManager.focusXY(m, f); for (var y = 0, b = this.backgroundCtrl; y < b.length; y++) b[y].setReferencePoint(new Phaser.Point(m, f)); break;
                            case "platform":
                                this.platforms.push(a); break;
                            case "enemy_0":
                            case "enemy_1":
                            case "enemy_2":
                            case "enemy_3":
                            case "enemy_4":
                            case "enemy_5":
                            case "enemy_6":
                            case "enemy_dummy":
                                if (this.gidPatternDictionary[i])
                                    if (a.type = this.gidPatternDictionary[i].type, "enemy_6" === a.type)
                                        if (a.properties)
                                            for (var g = 0, _ = a.properties; g < _.length; g++) { var v = _[g]; if ("parent" === v.name && -1 !== v.value) { this.spawnerHeads.push(a); break } this.enemies.push(a) } else this.enemies.push(a);
                                        else this.enemies.push(a); break;
                            case "lock_spawner":
                                o && this.lockSpawners.push(a); break;
                            case "power":
                                this.addPowerPack(a); break;
                            case "power_up":
                                this.addPowerPackPlus(a); break;
                            case "healing":
                                this.addLifePack(a); break;
                            case "healing_up":
                                this.addLifePackPlus(a); break;
                            case "mine":
                                o && this.addMine(a); break;
                            case "saw":
                                o && this.addSaw(a); break;
                            case "spike":
                                o && this.addSpike(a); break;
                            case "laser_surface":
                                o && this.addLaserSurface(a); break;
                            case "hammer":
                                o && this.addHammer(a); break;
                            case "pendulum":
                                o && this.addPendulum(a); break;
                            case "breack_wall":
                                o && this.addBreakableWall(a); break;
                            case "steam_wall":
                                o && this.addSteamWall(a); break;
                            case "fire_wall":
                                o && this.addFireWall(a); break;
                            case "spawn_point":
                                if (a.properties)
                                    for (var x = 0, S = a.properties; x < S.length; x++) "parent" === S[x].name && !0;
                                this.points.push(a); break;
                            case "ruler":
                                var C = this.game.add.sprite(a.x, a.y, "ruler");
                                C.anchor.set(0, 1), this.frontDecoGroup.add(C); break;
                            case "section_end":
                                this.sectionEndTile = a; break;
                            case "boss1":
                            case "boss2":
                            case "boss3":
                            case "boss4":
                                this.bossObject = a, this.bossObject.type = this.gidPatternDictionary[i].type } } else "path" === a.type && this.enemiesPath.push(a) } for (var w in n) n.hasOwnProperty(w);
                this.addTestPlatforms(), this.addEnemies(), this.addSpawnScenes(), null !== this.bossObject && this.addBoss(this.bossObject), this.addCheckPointAtTheBeggining() } }, e.prototype.mapRaycastFilter = function(e, i, o, n) { return i.m_filter.categoryBits === t.CollisionLayers.Map }, e.prototype.addTestPlatforms = function() { for (var t = 0, e = this.platforms; t < e.length; t++) { var i = e[t];
                this.addMovingPlatform(i) } }, e.prototype.addMovingPlatform = function(e) { var i = null;
            this.gidPatternDictionary[e.gid].objectgroup && (i = this.gidPatternDictionary[e.gid].objectgroup.objects[0]); var o = new t.MovingPlatform(this.game, this.player, e, i);
            this.platformArray.push(o), this.objectsGroup.add(o) }, e.prototype.addEnemies = function() { for (var t = 0, e = this.enemies; t < e.length; t++) { var i = e[t]; switch (i.type) {
                    case "enemy_0":
                        this.createEnemyMeleeA(i); break;
                    case "enemy_1":
                        this.createEnemyMeleeB(i); break;
                    case "enemy_2":
                        this.createEnemyMeleeC(i); break;
                    case "enemy_3":
                        this.createEnemyRangeA(i); break;
                    case "enemy_4":
                        this.createEnemyRangeB(i); break;
                    case "enemy_5":
                        this.createEnemyRangeC(i); break;
                    case "enemy_6":
                        this.createEnemyDetector(i); break;
                    case "enemy_dummy":
                        this.createEnemyDummy(i); break;
                    default:
                        this.createEnemyMeleeC(i) } } }, e.prototype.addSpawnScenes = function() { for (var t = 0, e = this.lockSpawners; t < e.length; t++) { var i = e[t];
                this.addWaveScene(i) } }, e.prototype.addWaveScene = function(e) { var i = [],
                o = [
                    [0]
                ],
                n = !1,
                s = null; if (e.properties)
                for (var r = 0, a = e.properties; r < a.length; r++) { var h = a[r]; switch (h.name) {
                        case "spawn_list":
                            o = this.readSpawnListFromProperty(h); break;
                        case "elevator":
                            h.value && (n = !0); break;
                        case "bg":
                            for (var l = 0, c = this.backgroundCtrl; l < c.length; l++) { var d = c[l]; if (d.backgroundObject.id === h.value) { s = d; break } } } }
            var u = new t.WaveScene(this.game, this.player, this.objectsGroup, i, o, e, n, s);
            this.waveScenes.push(u), this.animationsPh2.push(u.portals[0]), this.animationsPh2.push(u.portals[1]), u.onStart.addOnce(this.waveStart, this), n ? (u.onFinish.addOnce(this.elevatorFinish, this), u.onEnd.add(this.endSection, this)) : u.onFinish.addOnce(this.waveFinish, this), Constants.CHUNKS_ENABLED }, e.prototype.addBoss = function(e) { var i = this.currentSectionNum; if (i > -1 && (i++, this.nextSection = this.currentLevel.slice(0, this.currentLevel.length - 1) + i.toString(), this.game.cache.checkJSONKey(this.nextSection) ? this.nextSectionNum = i : this.nextSection = ""), "boss1" === e.type) { var o = [],
                    n = void 0,
                    s = void 0; if (this.points.length > 0)
                    for (var r = 0, a = this.points; r < a.length; r++)(C = a[r]).properties[0].value === e.id && o.push(new box2d.b2Vec2(C.x + .5 * C.width, C.y - .5 * C.height));
                o.length < 2 ? (n = e.x + .5 * e.width - 500, s = e.x + .5 * e.width + 500) : o[0].x < o[1].x ? (n = o[0].x, s = o[1].x) : (n = o[1].x, s = o[0].x); var h = 1,
                    l = GameData.Boss1Wave; if (e.properties)
                    for (var c = 0, d = e.properties; c < d.length; c++) "mode" === (T = d[c]).name && (h = T.value); var u = new t.Boss1(this.game, this.player, this.objectsGroup, e, n, s, h, l);
                u.onStart.add(this.startBoss, this), u.onEnd.add(this.endSection, this), this.isBoss = !0, this.boss = u } else if ("boss2" === e.type) { var o = [],
                    n = void 0,
                    s = void 0; if (this.points.length > 0)
                    for (var p = 0, m = this.points; p < m.length; p++)(C = m[p]).properties[0].value === e.id && o.push(new box2d.b2Vec2(C.x + .5 * C.width, C.y - .5 * C.height));
                o.length < 2 ? (n = e.x + .5 * e.width - 500, s = e.x + .5 * e.width + 500) : o[0].x < o[1].x ? (n = o[0].x, s = o[1].x) : (n = o[1].x, s = o[0].x);
                h = 1; if (e.properties)
                    for (var f = 0, y = e.properties; f < y.length; f++) "mode" === (T = y[f]).name && (h = T.value); var b = new t.Boss2(this.game, this.player, this.objectsGroup, e, n, s);
                b.onStart.add(this.startBoss, this), b.onEnd.add(this.endSection, this), this.isBoss = !0, this.boss = b } else if ("boss3" === e.type) { var o = [],
                    n = void 0,
                    s = void 0; if (this.points.length > 0)
                    for (var g = 0, _ = this.points; g < _.length; g++)(C = _[g]).properties[0].value === e.id && o.push(new box2d.b2Vec2(C.x + .5 * C.width, C.y - .5 * C.height));
                o.length < 2 ? (n = e.x + .5 * e.width - 500, s = e.x + .5 * e.width + 500) : o[0].x < o[1].x ? (n = o[0].x, s = o[1].x) : (n = o[1].x, s = o[0].x); var v = new t.Boss3(this.game, this.player, this.objectsGroup, e, n, s);
                v.onStart.add(this.startBoss, this), v.onEnd.add(this.endSection, this), this.isBoss = !0, this.boss = v } else if ("boss4" === e.type) { var o = [],
                    n = void 0,
                    s = void 0; if (this.points.length > 0)
                    for (var x = 0, S = this.points; x < S.length; x++) { var C = S[x];
                        C.properties[0].value === e.id && o.push(new box2d.b2Vec2(C.x + .5 * C.width, C.y - .5 * C.height)) } o.length < 2 ? (n = e.x + .5 * e.width - 500, s = e.x + .5 * e.width + 500) : o[0].x < o[1].x ? (n = o[0].x, s = o[1].x) : (n = o[1].x, s = o[0].x);
                h = 1; if (e.properties)
                    for (var w = 0, A = e.properties; w < A.length; w++) { var T = A[w]; "mode" === T.name && (h = T.value) }
                var P = new t.Boss4(this.game, this.player, this.objectsGroup, e, n, s);
                P.onStart.add(this.startBoss, this), P.onEnd.add(this.endSection, this), this.isBoss = !0, this.boss = P } }, e.prototype.startBoss = function() { Ph2.UISystem.findObject("life_container_container", this.gameplayUI).visible = !0 }, e.prototype.waveStart = function(e, i) { this.showDangerEffect(); var o = 0;
            this.game.width > GameData.sizeWaveWidth && (o = (GameData.sizeWaveWidth - this.game.width) / 2); var n = e - GameData.sizeWaveWidth / 2 + o,
                s = i - GameData.sizeWaveHeight / 2 + GameData.offsetWaveY,
                r = this.game.width > GameData.sizeWaveWidth ? this.game.width : GameData.sizeWaveWidth,
                a = GameData.sizeWaveHeight;
            t.Instances.cameraManager.initWave(n, s, r, a) }, e.prototype.waveFinish = function(e, i) { this.hideDangerEffect(), this.showActionMarker(e, i), t.Instances.cameraManager.smoothRefollow() }, e.prototype.elevatorFinish = function() { this.hideDangerEffect(), t.Instances.cameraManager.smoothRefollow() }, e.prototype.showDangerEffect = function() { this.game.ph2AudioManager.playEffect("indicator_wave", !1), this.dangerEffectAlert.ph2Animations.play("signs_alert_in", 1, !1).onComplete.addOnce(this.showAlertLoopEffect, this), this.dangerEffectLeft.ph2Animations.play("edge_danger_in", 1, !1).onComplete.addOnce(this.showEdgeLoopEffect, this), this.dangerEffectRight.ph2Animations.play("edge_danger_in", 1, !1), this.dangerEffectAlert.visible = !0, this.dangerEffectLeft.visible = !0, this.dangerEffectRight.visible = !0 }, e.prototype.showAlertLoopEffect = function() { this.dangerEffectAlert.ph2Animations.play("sign_alert_loop", 1, !0) }, e.prototype.showEdgeLoopEffect = function() { this.dangerEffectLeft.ph2Animations.play("edge_danger_loop", 1, !0), this.dangerEffectRight.ph2Animations.play("edge_danger_loop", 1, !0) }, e.prototype.hideDangerEffect = function() { this.dangerEffectAlert.ph2Animations.play("sign_alert_out", 1, !1).onComplete.addOnce(this.__afterHideDangerEffect, this), this.dangerEffectLeft.ph2Animations.play("edge_danger_out", 1, !1), this.dangerEffectRight.ph2Animations.play("edge_danger_out", 1, !1) }, e.prototype.__afterHideDangerEffect = function() { this.dangerEffectAlert.visible = !1, this.dangerEffectLeft.visible = !1, this.dangerEffectRight.visible = !1 }, e.prototype.createEnemyMeleeA = function(e) { for (var i = null, o = 0, n = this.enemiesPath; o < n.length; o++) { var s = n[o]; if (s.properties && s.properties[0].value === e.id) { i = s; break } } var r, a;
            null === i ? (r = 0, a = 0) : (r = i.x + i.polyline[0].x, a = i.x + i.polyline[1].x); var h = new t.EnemyMeleeA(this.game, this.player, e.x + .5 * e.width, e.y - .5 * e.height, r, a);
            this.objectsGroup.add(h), Constants.CHUNKS_ENABLED && (h.disableGameElement(), this.addEnemyToChunk(h)) }, e.prototype.createEnemyMeleeB = function(e) { for (var i = null, o = 0, n = this.enemiesPath; o < n.length; o++) { var s = n[o]; if (s.properties && s.properties[0].value === e.id) { i = s; break } } var r, a;
            null === i ? (r = 0, a = 0) : (r = i.x + i.polyline[0].x, a = i.x + i.polyline[1].x); var h = new t.EnemyMeleeB(this.game, this.player, e.x + .5 * e.width, e.y - .5 * e.height, r, a);
            this.objectsGroup.add(h), Constants.CHUNKS_ENABLED && (h.disableGameElement(), this.addEnemyToChunk(h)) }, e.prototype.createEnemyMeleeC = function(e) { for (var i = null, o = 0, n = this.enemiesPath; o < n.length; o++) { var s = n[o]; if (s.properties && s.properties[0].value === e.id) { i = s; break } } var r, a;
            null === i ? (r = 0, a = 0) : (r = i.x + i.polyline[0].x, a = i.x + i.polyline[1].x); var h = new t.EnemyMeleeC(this.game, this.player, e.x + .5 * e.width, e.y - .5 * e.height, r, a);
            this.objectsGroup.add(h), Constants.CHUNKS_ENABLED && (h.disableGameElement(), this.addEnemyToChunk(h)) }, e.prototype.createEnemyRangeA = function(e) { var i = new t.EnemyRangeA(this.game, this.player, e.x + .5 * e.width, e.y - .5 * e.height);
            this.objectsGroup.add(i), Constants.CHUNKS_ENABLED && (i.disableGameElement(), this.addEnemyToChunk(i)) }, e.prototype.createEnemyRangeB = function(e) { for (var i = null, o = 0, n = this.enemiesPath; o < n.length; o++) { var s = n[o]; if (s.properties && s.properties[0].value === e.id) { i = s; break } } var r, a;
            null === i ? (r = e.x + .5 * e.width - 200, a = e.x + .5 * e.width + 200) : (r = i.x + i.polyline[0].x, a = i.x + i.polyline[1].x); var h = new t.EnemyRangeB(this.game, this.player, e.x + .5 * e.width, e.y - .5 * e.height, r, a);
            this.objectsGroup.add(h), Constants.CHUNKS_ENABLED && (h.disableGameElement(), this.addEnemyToChunk(h)) }, e.prototype.createEnemyRangeC = function(e) { for (var i = null, o = 0, n = this.enemiesPath; o < n.length; o++) { var s = n[o]; if (s.properties[0].value === e.id) { i = s; break } } var r, a;
            null === i ? (r = e.x + .5 * e.width - 100, a = e.x + .5 * e.width + 100) : (r = i.x + i.polyline[0].x, a = i.x + i.polyline[1].x); var h = new t.EnemyRangeC(this.game, this.player, e.x + .5 * e.width, e.y - .5 * e.height, r, a);
            this.objectsGroup.add(h), Constants.CHUNKS_ENABLED && (h.disableGameElement(), this.addEnemyToChunk(h)) }, e.prototype.createEnemyDetector = function(e) { var i = []; if (this.points.length > 0)
                for (var o = 0, n = this.points; o < n.length; o++) { var s = n[o];
                    s.properties[0].value === e.id && i.push(new box2d.b2Vec2(s.x + .5 * s.width, s.y - .5 * s.height)) }
            var r = [
                [0]
            ]; if (e.properties)
                for (var a = 0, h = e.properties; a < h.length; a++) "spawn_list" === (f = h[a]).name && (r = this.readSpawnListFromProperty(f)); for (var l = [], c = 0, d = this.spawnerHeads; c < d.length; c++) { var u = d[c]; if (u.properties)
                    for (var p = 0, m = u.properties; p < m.length; p++) { var f = m[p]; if ("parent" === f.name && f.value === e.id) { l.push(u); break } } } var y = new t.EnemyDetector(this.game, e, this.player, this.objectsGroup, i, r, l);
            Constants.CHUNKS_ENABLED && (y.lifeManager.onNoLife.add(this.removeEnemyFromChunk, this), y.disableGameElement(), this.addEnemyToChunk(y)) }, e.prototype.createEnemyDummy = function(e) { var i;
            i = new t.DummyEnemy(this.game, e.x + .5 * e.width, e.y - .5 * e.height), this.lastDummy = i, this.objectsGroup.add(i), Constants.CHUNKS_ENABLED && (i.disableGameElement(), this.addEnemyToChunk(i)) }, e.prototype.addLifePack = function(e) { var i = new t.LifePack(this.game, this.player, e.x + .5 * e.width, e.y - .5 * e.height);
            i.onLifeFull.add(this.playLifeFull, this), this.objectsGroup.add(i), this.animationsPh2.push(i.animation), Constants.CHUNKS_ENABLED && (i.disableGameElement(), this.addItemToChunk(i)) }, e.prototype.addLifePackPlus = function(e) { if (!t.Instances.dataManager.getLevelItemFound(t.Instances.currentLevelId)) { var i = new t.LifePackPlus(this.game, this.player, e.x + .5 * e.width, e.y - .5 * e.height);
                this.objectsGroup.add(i), this.animationsPh2.push(i.animation), Constants.CHUNKS_ENABLED && (i.disableGameElement(), this.addItemToChunk(i)) } }, e.prototype.addPowerPack = function(e) { var i = new t.EnergyPack(this.game, this.player, e.x + .5 * e.width, e.y - .5 * e.height);
            i.onPowerFull.add(this.playPowerFull, this), this.objectsGroup.add(i), this.animationsPh2.push(i.animation), Constants.CHUNKS_ENABLED && (i.disableGameElement(), this.addItemToChunk(i)) }, e.prototype.addPowerPackPlus = function(e) { if (!t.Instances.dataManager.getLevelItemFound(t.Instances.currentLevelId)) { var i = new t.EnergyPackPlus(this.game, this.player, e.x + .5 * e.width, e.y - .5 * e.height);
                this.objectsGroup.add(i), this.animationsPh2.push(i.animation), Constants.CHUNKS_ENABLED && (i.disableGameElement(), this.addItemToChunk(i)) } }, e.prototype.addMine = function(e) { var i = new t.Mine(this.game, this.player, e, 3, 20);
            this.objectsGroup.add(i), this.animationsSpr.push(i), Constants.CHUNKS_ENABLED && (i.disableGameElement(), this.addItemToChunk(i)) }, e.prototype.addSaw = function(e) { var i = new t.Saw(this.game, this.player, e, this.objectsGroup);
            i.onRespawn.add(this.respawnOnCheckPoint, this), Constants.CHUNKS_ENABLED && (i.disableGameElement(), this.addItemToChunk(i)) }, e.prototype.addSpike = function(e) { var i = null;
            this.gidPatternDictionary[e.gid].objectgroup && (i = this.gidPatternDictionary[e.gid].objectgroup.objects[0]); var o = !1; if (e.properties)
                for (var n = 0, s = e.properties; n < s.length; n++) { var r = s[n]; "call_respawn" === r.name && r.value && (o = !0) }
            var a = new t.Spikes(this.game, this.player, o, e, i);
            a.onRespawn.add(this.respawnOnCheckPoint, this), this.objectsGroup.add(a), Constants.CHUNKS_ENABLED && (a.disableGameElement(), this.addItemToChunk(a)) }, e.prototype.addLaserSurface = function(e) { var i = null;
            this.gidPatternDictionary[e.gid].objectgroup && (i = this.gidPatternDictionary[e.gid].objectgroup.objects[0]); var o = new t.LaserSurface(this.game, this.player, e, i);
            o.onRespawn.add(this.respawnOnCheckPoint, this), this.objectsGroup.add(o), this.animationsPh2.push(o.animation), Constants.CHUNKS_ENABLED && (o.disableGameElement(), this.addItemToChunk(o)) }, e.prototype.addHammer = function(e) { var i = new t.Hammer(this.game, this.player, e);
            i.onRespawn.add(this.respawnOnCheckPoint, this), this.objectsGroup.add(i), Constants.CHUNKS_ENABLED && (i.disableGameElement(), this.addItemToChunk(i)) }, e.prototype.addPendulum = function(e) { var i = new t.Pendulum(this.game, this.player, e);
            i.onRespawn.add(this.respawnOnCheckPoint, this), this.objectsGroup.add(i), Constants.CHUNKS_ENABLED && (i.disableGameElement(), this.addItemToChunk(i)) }, e.prototype.addBreakableWall = function(e) { var i = null;
            this.gidPatternDictionary[e.gid].objectgroup && (i = this.gidPatternDictionary[e.gid].objectgroup.objects[0]); var o = new t.BreakWall(this.game, this.player, e, i);
            this.objectsGroup.add(o), this.animationsPh2.push(o.animation), Constants.CHUNKS_ENABLED && (o.disableGameElement(), this.addItemToChunk(o)) }, e.prototype.addSteamWall = function(e) { this.gidPatternDictionary[e.gid].objectgroup && this.gidPatternDictionary[e.gid].objectgroup.objects[0]; var i = new t.StreamWall(this.game, this.player, e, t.StreamWallType.Steam);
            this.objectsGroup.add(i), this.animationsPh2.push(i.stream), Constants.CHUNKS_ENABLED && (i.disableGameElement(), this.addItemToChunk(i)) }, e.prototype.addFireWall = function(e) { this.gidPatternDictionary[e.gid].objectgroup && this.gidPatternDictionary[e.gid].objectgroup.objects[0]; var i = new t.StreamWall(this.game, this.player, e, t.StreamWallType.Fire);
            this.objectsGroup.add(i), this.animationsPh2.push(i.stream), Constants.CHUNKS_ENABLED && (i.disableGameElement(), this.addItemToChunk(i)) }, e.prototype.loadHiddenGraphics = function(t) { if (0 !== t.length)
                for (var e = 0, i = t; e < i.length; e++) { var o = i[e];
                    this.loadHiddenLayer(o) } }, e.prototype.loadHiddenLayer = function(e) { for (var i = this.game.add.group(this.frontDecoGroup), o = 0; o < e.objects.length; o++) { var n = e.objects[o]; if ("trigger" === n.name || "trigger" === n.type) { var s = this.game.physics.box2d.createBody(n.x + .5 * n.width, n.y + .5 * n.height, 0); if (s.addRectangle(n.width, n.height), s.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Items, s.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, s.sensor = !0, s.data.m_userData = { group: i, tween: null, visible: !0 }, s.setBodyContactCallback(this.player, this.triggerCategoriCollision, this), Constants.CHUNKS_ENABLED) { var r = { left: n.x, right: n.x + n.width, top: n.y, bottom: n.y + n.height };
                        this.addBodyToChunk(s, r) } } else this.loadMapGraphicObject(n, i, o) } }, e.prototype.triggerCategoriCollision = function(t, e, i, o, n, s) { var r = t.data.m_userData; if (n) { if (r.visible) { r.visible = !1, this.game.ph2AudioManager.playEffect("hidden_room", !1);
                    a = 200;
                    r.tween && (r.tween.stop(!1), a *= r.group.alpha), r.tween = this.game.add.tween(r.group), r.tween.to({ alpha: 0 }, a, "Linear", !0).onComplete.add(function() { r.group.visible = !1, r.tween = null }) } } else if (!r.visible) { r.visible = !0; var a = 200;
                r.tween && (r.tween.stop(!1), a *= 1 - r.group.alpha), r.group.visible = !0, r.tween = this.game.add.tween(r.group), r.tween.to({ alpha: 1 }, a, "Linear", !0).onComplete.add(function() { r.tween = null }) } }, e.prototype.respawnOnCheckPoint = function() { this.player.respawnInSafePoint(), Constants.CHUNKS_ENABLED && (this.clearCurrentChunkGroup(), this.chunkPreUpdate()) }, e.prototype.getImageName = function(t, e) { if (void 0 === e && (e = !0), t && t.image) { var i = t.image.split("/"); return e ? i[i.length - 1] : i[i.length - 1].split(".")[0] } }, e.prototype.checkObjectBody = function(t) { var e = t.gid & GameData.idMask; if (this.gidPatternDictionary[e] && this.gidPatternDictionary[e].hasOwnProperty("objectgroup"))
                for (var i = 0, o = this.gidPatternDictionary[e].objectgroup.objects; i < o.length; i++) { var n = o[i];
                    this.addObjectCollision(n, t.x, t.y - t.height) } }, e.prototype.addMapNote = function(t) { var e = { wordWrap: t.text.wrap, wordWrapWidth: t.width, fontSize: t.text.pixelsize },
                i = this.game.add.text(t.x, t.y, t.text.text, e);
            this.frontDecoGroup.add(i) }, e.prototype.loadMiscellaneous = function(t) { if (null !== t)
                for (var e = 0, i = t.objects; e < i.length; e++) { var o = i[e];
                    o.hasOwnProperty("text") && this.addMapNote(o) } }, e.prototype.addEndOfSection = function(e) { var i = this.currentSectionNum;
            i++, this.nextSection = this.currentLevel.slice(0, this.currentLevel.length - 1) + i.toString(), this.game.cache.checkJSONKey(this.nextSection) ? this.nextSectionNum = i : this.nextSection = ""; var o = null; if (e.properties)
                for (var n = 0, s = e.properties; n < s.length; n++) { var r = s[n]; if ("bg" === r.name) { for (var a = 0, h = this.backgroundCtrl; a < h.length; a++) { var l = h[a]; if (l.backgroundObject.id === r.value) { o = l; break } } break } }
            var c = new t.SectionEnd(this.game, this.player, e, o, this.nextSection);
            c.onEnter.add(this.enterEndSection, this), c.onEnd.add(this.endSection, this), this.sectionEnd.push(c), Constants.CHUNKS_ENABLED && (c.disableGameElement(), this.addItemToChunk(c)) }, e.prototype.enterEndSection = function(e) { t.Instances.isGameplayActive = !1, this.joystickUI && this.joystickUI.endInput() }, e.prototype.endSection = function(e) { void 0 === e && (e = !1), this.nextSection.length > 0 ? (this.nextEnterVertical = e, this.onSectionEnd.dispatch(), t.Instances.transition.playIn().addOnce(this._transitionGoToNextSection, this)) : this.onGameEnd.dispatch(!0) }, e.prototype._transitionGoToNextSection = function() { this.game.state.start("gameplayState", !0, !1, this.isBoss, this.nextSection, this.nextEnterVertical) }, e.prototype.endLose = function() { t.Instances.isGameplayActive = !1, this.onGameEnd.dispatch(!1) }, e.prototype.getSectionNumber = function() { var t = +this.currentLevel.charAt(this.currentLevel.length - 1); return isNaN(t) && (t = -1), t }, e.prototype.setPlayerinit = function() { this.player.disableComponents(), this.playBeginning ? (this.player.body.reset(this.spawnPoint.x, this.spawnPoint.y), t.Instances.cameraManager.followPlayer(), this.player.initPlayerLevel()) : this.fromRetry ? (this.player.ignoreGroundRestitusion = !0, this.player.body.reset(this.spawnPoint.x, this.spawnPoint.y), t.Instances.cameraManager.followPlayer(), this.player.initPlayerRetry()) : this.fromAbove ? (this.player.body.gravityScale = 0, t.Instances.cameraManager.focusXY(this.spawnPoint.x, this.spawnPoint.y + t.Instances.cameraManager.getOffset().y), this.player.body.reset(this.spawnPoint.x, this.spawnPoint.y - this.game.height)) : (this.player.setNoneCollision(), t.Instances.cameraManager.focusXY(this.spawnPoint.x, this.spawnPoint.y + t.Instances.cameraManager.getOffset().y), this.player.body.gravityScale = 0, this.player.body.reset(this.spawnPoint.x - .5 * this.game.width - 200, this.spawnPoint.y)) }, e.prototype.startLevelBeggining = function() { var e = this;
            this.player.disableComponents(), this.playBeginning ? (t.Instances.cameraManager.followPlayer(), this.player.playLevelStart()) : this.fromRetry ? (t.Instances.cameraManager.followPlayer(), this.player.playRetryTransform()) : this.fromAbove ? (this.player.body.gravityScale = this.player.thisGravity, this.player.body.data.SetAwake(!0), this.player.spine.setAnimationByName(0, this.player.spineAnimationNames.jumpLoop, !0), this.player.onGroundCollision.addOnce(function() { e.player.enableComponents(), e.player.onAfterIntro.dispatch(), t.Instances.cameraManager.followPlayer(), e.player.spine.setAnimationByName(0, e.player.spineAnimationNames.stand, !0), e.player.ignoreGroundRestitusion = !1 }, this)) : (this.player.walkIn(this.spawnPoint.x), this.player.onAfterIntro.addOnce(t.Instances.cameraManager.followPlayer, t.Instances.cameraManager)) }, e.prototype.pause = function() { this.boss && this.boss.pause(), this.player.respawnAnim.animations.paused = !0; for (var t = 0, e = this.animationsPh2; t < e.length; t++)(n = e[t]) && n.visible && n.ph2Animations.pause(); for (var i = 0, o = this.animationsSpr; i < o.length; i++) { var n = o[i];
                n && (n.animations.paused = !0) } }, e.prototype.resume = function() { this.boss && this.boss.resume(), this.player.respawnAnim.animations.paused = !1; for (var t = 0, e = this.animationsPh2; t < e.length; t++)(n = e[t]) && n.visible && n.ph2Animations.resume(); for (var i = 0, o = this.animationsSpr; i < o.length; i++) { var n = o[i];
                n && (n.animations.paused = !1) } }, e.prototype.addSprAnim = function(t) { this.animationsSpr.push(t) }, e.prototype.addPh2Anim = function(t) { this.animationsPh2.push(t) }, e.prototype.checkBgParentParams = function(t, e) { var i = !0,
                o = !0,
                n = !0,
                s = !0; if (t.properties)
                for (var r = 0, a = t.properties; r < a.length; r++) switch ((c = a[r]).name) {
                    case "tiled_x":
                        i = !1; break;
                    case "tiled_y":
                        o = !1; break;
                    case "paralax_x":
                        n = !1; break;
                    case "paralax_y":
                        s = !1 } else t.properties = []; if (e.properties)
                for (var h = 0, l = e.properties; h < l.length; h++) { var c = l[h]; switch (c.name) {
                        case "tiled_x":
                            i && t.properties.push(c); break;
                        case "tiled_y":
                            o && t.properties.push(c); break;
                        case "paralax_x":
                            n && t.properties.push(c); break;
                        case "paralax_y":
                            s && t.properties.push(c) } } }, e.prototype.checkTiledParentParams = function(t, e) { var i = !0,
                o = !0; if (t.properties)
                for (var n = 0, s = t.properties; n < s.length; n++) switch ((h = s[n]).name) {
                    case "tiled_x":
                        i = !1; break;
                    case "tiled_y":
                        o = !1 } else t.properties = []; if (e.properties)
                for (var r = 0, a = e.properties; r < a.length; r++) { var h = a[r]; switch (h.name) {
                        case "tiled_x":
                            i && t.properties.push(h); break;
                        case "tiled_y":
                            o && t.properties.push(h) } } }, e.prototype.showActionMarker = function(e, i) { switch (this.game.ph2AudioManager.playEffect("indicator_go", !1), this.arrowMarker.visible = !0, e ? this.arrowMarker.position.set(110, .5 * this.game.height) : this.arrowMarker.position.set(this.game.width - 110, .5 * this.game.height), i) {
                case t.ArrowDirection.left:
                    this.arrowMarker.scaleX = -1, this.arrowMarker.ph2Animations.play("arrow_side", 1, !0); break;
                case t.ArrowDirection.right:
                    this.arrowMarker.scaleX = 1, this.arrowMarker.ph2Animations.play("arrow_side", 1, !0); break;
                case t.ArrowDirection.up:
                    this.arrowMarker.ph2Animations.play("arrow_up", 1, !0); break;
                case t.ArrowDirection.down:
                    this.arrowMarker.ph2Animations.play("arrow_down", 1, !0) } this.game.time.events.add(GameData.arrowMarkerTime, this.hideActionMarker, this) }, e.prototype.hideActionMarker = function() { this.arrowMarker.visible = !1, this.arrowMarker.ph2Animations.stop() }, e.prototype.readSpawnListFromProperty = function(t) { for (var e = [
                    [0]
                ], i = t.value.split("|"), o = 0; o < i.length; o++) e[o] = i[o].split(",").map(Number); return e }, e.prototype.addBodyToChunk = function(t, e) { var i = Math.max(0, Math.floor((e.left - this.mapBounds.lowerBound.x) / this.chunkSize)),
                o = Math.max(0, Math.floor((e.top - this.mapBounds.lowerBound.y) / this.chunkSize)),
                n = Math.ceil((e.right - this.mapBounds.lowerBound.x) / this.chunkSize),
                s = Math.ceil((e.bottom - this.mapBounds.lowerBound.y) / this.chunkSize); if (i < 0 || o < 0 || n > this.chunks.length || s > this.chunks[0].length);
            else
                for (var r = i; r < n; r++)
                    for (var a = o; a < s; a++) this.chunks[r][a].childrenBdy.push(t) }, e.prototype.addSpriteToChunk = function(t, e) { if (t.width > this.chunkSize || t.height > this.chunkSize)
                for (var i = Math.max(0, Math.floor((e.x - this.mapBounds.lowerBound.x) / this.chunkSize)), o = Math.max(0, Math.floor((e.y - e.height - this.mapBounds.lowerBound.y) / this.chunkSize)), n = Math.ceil((e.x + e.width - this.mapBounds.lowerBound.x) / this.chunkSize), s = Math.ceil((e.y - this.mapBounds.lowerBound.y) / this.chunkSize), r = i; r < n; r++)
                    for (var a = o; a < s; a++) this.chunks[r][a].childrenSpr.push(t);
            else { var h = Math.floor((e.x + .5 * e.width - this.mapBounds.lowerBound.x) / this.chunkSize),
                    l = Math.floor((e.y - .5 * e.height - this.mapBounds.lowerBound.y) / this.chunkSize);
                this.chunks[h] && this.chunks[h][l] && this.chunks[h][l].childrenSpr.push(t) } }, e.prototype.addEnemyToChunk = function(t) { var e = Math.floor((t.x - this.mapBounds.lowerBound.x) / this.chunkSize),
                i = Math.floor((t.y - this.mapBounds.lowerBound.y) / this.chunkSize);
            this.chunks[e][i].childrenEnemy.push(t) }, e.prototype.removeEnemyFromChunk = function(t) { var e = Math.floor((t.x - this.mapBounds.lowerBound.x) / this.chunkSize),
                i = Math.floor((t.y - this.mapBounds.lowerBound.y) / this.chunkSize),
                o = this.chunks[e][i].childrenEnemy.indexOf(t); if (o >= 0) { var n = this.chunks[e][i].childrenEnemy.length - 1;
                o < n ? (this.chunks[e][i].childrenEnemy[o] = this.chunks[e][i].childrenEnemy[n], this.chunks[e][i].childrenEnemy.length--) : this.chunks[e][i].childrenEnemy.length-- } }, e.prototype.addItemToChunk = function(t) { var e = Math.floor((t.x - this.mapBounds.lowerBound.x) / this.chunkSize),
                i = Math.floor((t.y - this.mapBounds.lowerBound.y) / this.chunkSize);
            this.chunks[e][i].childrenItems.push(t) }, e.prototype.chunkPreUpdate = function() { var t = Math.floor((this.spawnPoint.x - this.mapBounds.lowerBound.x) / this.chunkSize),
                e = Math.floor((this.spawnPoint.y - this.mapBounds.lowerBound.y) / this.chunkSize),
                i = this.chunks[t][e];
            this.currentChunkId = i.id, this.currentCol = t, this.currentRow = e; for (var o = t - this.visibleChunksHor < 0 ? 0 : t - this.visibleChunksHor, n = t + this.visibleChunksHor > this.chunks.length - 1 ? this.chunks.length - 1 : t + this.visibleChunksHor, s = e - this.visibleChunksVer < 0 ? 0 : e - this.visibleChunksVer, r = e + this.visibleChunksVer > this.chunks[0].length - 1 ? this.chunks[0].length - 1 : e + this.visibleChunksVer, a = o; a <= n; a++)
                for (var h = s; h <= r; h++) this.activateChunk(this.chunks[a][h], !0);
            Constants.DEBUG_ENABLED && (i.debugSprite.tint = 16711680) }, e.prototype.chunkUpdate = function() { var t = Math.floor((this.player.body.x - this.mapBounds.lowerBound.x) / this.chunkSize),
                e = Math.floor((this.player.body.y - this.mapBounds.lowerBound.y) / this.chunkSize),
                i = null;
            t >= 0 && e >= 0 && (i = this.chunks[t][e]), i && i.id !== this.currentChunkId && (this.activateChunk(i, !0), Constants.DEBUG_ENABLED && (this.chunks[this.currentCol][this.currentRow].debugSprite.tint = 65280, i.debugSprite.tint = 16711680), this.checkChunkSurroundings(t, e, this.currentCol, this.currentRow), this.currentChunkId = i.id, this.currentCol = t, this.currentRow = e) }, e.prototype.checkChunkSurroundings = function(t, e, i, o) { var n = !1,
                s = !1,
                r = !1,
                a = !1;
            i !== t && (i < t ? t < this.chunks.length - 1 && (s = !0) : t > 0 && (n = !0)), o !== e && (o < e ? e < this.chunks[0].length - 1 && (a = !0) : e > 0 && (r = !0)), this.checkShowChunks(t, e, n, s, r, a), n ? n = t + this.visibleChunksHor < this.chunks.length - 1 : s && (s = t - this.visibleChunksHor > 0), r ? r = e + this.visibleChunksVer < this.chunks[0].length - 1 : a && (a = e - this.visibleChunksVer > 0), this.checkHideChunks(t, e, n, s, r, a) }, e.prototype.checkShowChunks = function(t, e, i, o, n, s) { var r, a = t - this.visibleChunksHor < 0 ? 0 : t - this.visibleChunksHor,
                h = t + this.visibleChunksHor > this.chunks.length - 1 ? this.chunks.length - 1 : t + this.visibleChunksHor,
                l = e - this.visibleChunksVer < 0 ? 0 : e - this.visibleChunksVer,
                c = e + this.visibleChunksVer > this.chunks[0].length - 1 ? this.chunks[0].length - 1 : e + this.visibleChunksVer; if (i)
                for (r = l; r <= c; r++) this.activateChunk(this.chunks[a][r], !0); if (o)
                for (r = l; r <= c; r++) this.activateChunk(this.chunks[h][r], !0); if (n)
                for (r = a; r <= h; r++) this.activateChunk(this.chunks[r][l], !0); if (s)
                for (r = a; r <= h; r++) this.activateChunk(this.chunks[r][c], !0) }, e.prototype.checkHideChunks = function(t, e, i, o, n, s) { var r, a = t - (this.visibleChunksHor + 1) < 0 ? 0 : t - (this.visibleChunksHor + 1),
                h = t + (this.visibleChunksHor + 1) > this.chunks.length - 1 ? this.chunks.length - 1 : t + (this.visibleChunksHor + 1),
                l = e - (this.visibleChunksVer + 1) < 0 ? 0 : e - (this.visibleChunksVer + 1),
                c = e + (this.visibleChunksVer + 1) > this.chunks[0].length - 1 ? this.chunks[0].length - 1 : e + (this.visibleChunksVer + 1); if (i)
                for (r = l; r <= c; r++) this.activateChunk(this.chunks[h][r], !1); if (o)
                for (r = l; r <= c; r++) this.activateChunk(this.chunks[a][r], !1); if (n)
                for (r = a; r <= h; r++) this.activateChunk(this.chunks[r][c], !1); if (s)
                for (r = a; r <= h; r++) this.activateChunk(this.chunks[r][l], !1) }, e.prototype.activateChunk = function(t, e) { if (e) { if (!t.visible) { for (var i = 0, o = t.childrenSpr; i < o.length; i++)(u = o[i]).visible = !0; for (var n = 0, s = t.childrenBdy; n < s.length; n++)(f = s[n]).data.m_userData.activeCount++, 1 === f.data.m_userData.activeCount && f.data.SetActive(!0); for (var r = 0, a = t.childrenEnemy; r < a.length; r++)(g = a[r]).enableGameElement(); for (var h = 0, l = t.childrenItems; h < l.length; h++)(x = l[h]).enableGameElement();
                    Constants.DEBUG_ENABLED && (t.debugSprite.tint = 65280), t.visible = !0 } } else if (t.visible) { for (var c = 0, d = t.childrenSpr; c < d.length; c++) { var u = d[c];
                    u.visible = !1 } for (var p = 0, m = t.childrenBdy; p < m.length; p++) { var f = m[p];
                    f.data.m_userData.activeCount--, 0 === f.data.m_userData.activeCount && f.data.SetActive(!1) } for (var y = 0, b = t.childrenEnemy; y < b.length; y++) { var g = b[y];
                    g.disableGameElement() } for (var _ = 0, v = t.childrenItems; _ < v.length; _++) { var x = v[_];
                    x.disableGameElement() } Constants.DEBUG_ENABLED && (t.debugSprite.tint = 16777215), t.visible = !1 } }, e.prototype.clearCurrentChunkGroup = function() { for (var t = this.currentCol - this.visibleChunksHor < 0 ? 0 : this.currentCol - this.visibleChunksHor, e = this.currentCol + this.visibleChunksHor > this.chunks.length - 1 ? this.chunks.length - 1 : this.currentCol + this.visibleChunksHor, i = this.currentRow - this.visibleChunksVer < 0 ? 0 : this.currentRow - this.visibleChunksVer, o = this.currentRow + this.visibleChunksVer > this.chunks[0].length - 1 ? this.chunks[0].length - 1 : this.currentRow + this.visibleChunksVer, n = t; n <= e; n++)
                for (var s = i; s <= o; s++) this.activateChunk(this.chunks[n][s], !1) }, e.prototype.clearChunks = function() { for (var t = 0, e = this.chunks; t < e.length; t++) { for (var i = e[t], o = 0, n = i; o < n.length; o++) { var s = n[o];
                    s.debugSprite = null, s.childrenBdy.length = 0, s.childrenItems.length = 0, s.childrenEnemy.length = 0; for (var r = 0, a = s.childrenSpr; r < a.length; r++) { var h = a[r];
                        h.sprite && h.sprite.destroy(!0), h.parentGroup = null } s.childrenSpr.length = 0 } i.length = 0 } this.chunks.length = 0 }, e.prototype.shutdown = function() { for (var e = 0, i = this.sectionEnd; e < i.length; e++) i[e].destroy(); for (var o = 0, n = this.waveScenes; o < n.length; o++) n[o].destroy();
            Constants.CHUNKS_ENABLED && this.clearChunks(), this.mapFixtures.length = 0; for (var s = 0, r = this.mapSprites; s < r.length; s++) r[s].destroy(!0);
            this.mapSprites.length = 0, this.platformArray.length = 0, this.sectionEnd = null, this.mapGroup = null, this.objectsGroup = null, this.frontDecoGroup = null, this.player = null, t.SpriteProxy.clearPool() }, e.prototype.playLifeFull = function() { this.lifeFullFx.visible || (this.lifeFullFx.ph2Animations.play("power_life_bar_fx_full", 1, !1), this.lifeFullFx.visible = !0) }, e.prototype.playPowerFull = function() { this.powerFullFx.visible || (this.powerFullFx.ph2Animations.play("power_life_bar_fx_full", 1, !1), this.powerFullFx.visible = !0) }, e.prototype.addCheckPointAtTheBeggining = function() { this.currentSectionNum > 1 && (this.checkPoint = this.game.add.ph2AnimationObject(this.spawnPoint.x + GameData.checkPointOffsetX, this.spawnPointFloor - 25, "checkpoint", "atlas_animation2"), this.objectsGroup.add(this.checkPoint), this.animationsPh2.push(this.checkPoint)) }, e.prototype.resize = function() { for (var t = 0, e = this.backgroundCtrl; t < e.length; t++) e[t].resizeController(); for (var i = 0, o = this.tiledSpriteProxy; i < o.length; i++) o[i].resizeProxy() }, e }();
    t.MapLoader = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { void 0 === s && (s = null); var r = e.call(this, i, n.x + .5 * n.width, n.y - .5 * n.height, null) || this; return i.add.existing(r), r.setProperty(n), r.initPhysic(n, s), r.initVisual(), r.isTargetIn = !1, r.isTargetContact = !1, r.isTargetStandingAbove = !1, r.componentManager = Ph2.ComponentPlugin.initComponents(r), r.properties.vertical ? (r.properties.beginLower ? (r.body.reset(r.body.x, n.y - .5 * s.height), r.properties.speed *= -1) : r.body.reset(r.body.x, n.y - n.height + .5 * s.height), r.moveComponent = r.componentManager.addComponent(t.MovementVertical, n.y - n.height, n.y, .5 * s.height, r.properties.speed, r.properties.idleTime)) : (r.properties.beginLower ? r.body.reset(n.x + .5 * s.width, r.body.y) : (r.properties.speed *= -1, r.body.reset(n.x + n.width - .5 * s.width, r.body.y)), r.moveComponent = r.componentManager.addComponent(t.MovementHorizontal, n.x, n.x + n.width, .5 * s.width, r.properties.speed, r.properties.idleTime)), r.onContact = !1, r.lastContact = null, r.evalContact = null, r.evaluatingColl = !1, r.registerColl = !1, r.lookDirection = new Phaser.Point(1, 0), r.playerMoveComponent = o.componentManager.getComponent(t.PlayerMovementHorizontal), r.body.setBodyPostsolveCallback(o, r.postsolvePlatform, r), r.body.setBodyContactCallback(o, r.contacPlatform, r), r } return __extends(i, e), i.prototype.setProperty = function(t) { var e = GameData.platformSpeed,
                i = GameData.platformIdleTime,
                o = !1,
                n = !1; if (t.properties)
                for (var s = 0, r = t.properties; s < r.length; s++) { var a = r[s]; switch (a.name) {
                        case "speed":
                            e = a.value; break;
                        case "idleTime":
                            i = a.value; break;
                        case "startLower":
                            o = a.value; break;
                        case "vertical":
                            n = a.value } } this.properties = { speed: e, idleTime: i, beginLower: o, vertical: n } }, i.prototype.initVisual = function() { this.visual = this.game.add.ph2AnimationObject(0, 0, "platform", "atlas_animation2"), this.visual.ph2Animations.play("good_plataform_anim", 1, !0), this.addChild(this.visual) }, i.prototype.initPhysic = function(e, i) { void 0 === i && (i = null); var o = e.height,
                n = e.width;
            i && (o = i.height, n = i.width), this.game.physics.box2d.enable(this), this.body.setRectangle(n, o, 0, 0), this.body.fixedRotation = !0, this.body.kinematic = !0, this.body.friction = 0; var s = new box2d.b2Filter;
            s.categoryBits = t.CollisionLayers.Map, s.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, this.body.data.m_fixtureList.SetFilterData(s), this.body.data.m_userData = { isSlope: !1, isPlatform: !0, activeCount: 0 } }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.postsolvePlatform = function(t, e, i, o, n, s) { this.isTargetIn || (this.isTargetIn = !0, this.moveComponent.hasPassenger() || this.moveComponent.addPassenger(this.playerMoveComponent)) }, i.prototype.contacPlatform = function(t, e, i, o, n) { n || this.releasePassenger() }, i.prototype.releasePassenger = function() { this.isTargetIn && (this.isTargetIn = !1, this.isTargetStandingAbove = !1, this.moveComponent.hasPassenger() && this.moveComponent.removePassenger()) }, i }(Phaser.Sprite);
    t.MovingPlatform = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { var r = e.call(this, i, o, n, null) || this; return r.onChangeCharacter = new Phaser.Signal, r.attackKey = r.game.input.keyboard.addKey(Phaser.Keyboard[t.Instances.keyboardKey.attack]), r.specialKey = r.game.input.keyboard.addKey(Phaser.Keyboard[t.Instances.keyboardKey.special]), r.parentGroup = s, r.currentDirectionDpad = null, r.attackKey.onDown.add(r.resetIdleCounter, r), r.specialKey.onDown.add(r.resetIdleCounter, r), r.game.input.keyboard.addKey(Phaser.Keyboard[t.Instances.keyboardKey.up]).onDown.add(r.resetIdleCounter, r), r.game.input.keyboard.addKey(Phaser.Keyboard[t.Instances.keyboardKey.left]).onDown.add(r.resetIdleCounter, r), r.game.input.keyboard.addKey(Phaser.Keyboard[t.Instances.keyboardKey.right]).onDown.add(r.resetIdleCounter, r), r.setVulnerableAfterSuper = !1, r.isStunPending = !1, r.idleCounter = 0, r.isFalling = !1, r.isStun = !1, r.walkingIn = !1, r.restoreAfterWalk = !1, r.shootEnabled = !1, r.useDownForce = !0, r.ignoreGroundRestitusion = !0, i.add.existing(r), r.componentManager = Ph2.ComponentPlugin.initComponents(r), r.thisGravity = 3, r.lookDirection = new Phaser.Point(1, 0), r.checkPoint = new Phaser.Point(o, n), r.onWallCollision = new Phaser.Signal, r.onGroundCollision = new Phaser.Signal, r.onTorsoCollision = new Phaser.Signal, r.onAfterIntro = new Phaser.Signal, r.onAfterOutro = new Phaser.Signal, r.onDeath = new Phaser.Signal, r.onRestoreVulnerability = new Phaser.Signal, i.physics.box2d.enable(r), r.body.fixedRotation = !0, r.body.friction = .5, r.body.linearDamping = .6, r.body.gravityScale = r.thisGravity, r.enemyLayer = t.CollisionLayers.Enemies | t.CollisionLayers.Breakable, r.mapCollLayer = t.CollisionLayers.Map | t.CollisionLayers.Breakable | t.CollisionLayers.Platforms, r.normalAux = new box2d.b2Vec2, r.filter = new box2d.b2Filter, r.filter.categoryBits = t.CollisionLayers.Player, r.filter.maskBits = t.CollisionLayers.Map | t.CollisionLayers.Breakable | t.CollisionLayers.Platforms | t.CollisionLayers.Damage | t.CollisionLayers.Bullets | t.CollisionLayers.Items, r.lifeManager = new t.LifeManager(10, r), r.lifeBar = new t.BarManager(r.game), r.lifeManager.onLostLife.add(r.lifeBar.setPercent, r.lifeBar), r.lifeManager.onEarnLife.add(r.lifeBar.setPercent, r.lifeBar), r.lifeManager.onNoLife.add(r.setDeath, r), r.powerManager = new t.LifeManager(10, r), r.powerBar = new t.BarManager(r.game), r.powerManager.onLostLife.add(r.powerBar.setPercent, r.powerBar), r.powerManager.onEarnLife.add(r.powerBar.setPercent, r.powerBar), r.groundMovementComponent = r.componentManager.addComponent(t.PlayerMovementHorizontal, 10), r.airMovementComponent = r.componentManager.addComponent(t.PlayerMovement, 25, !0), r.airMovementComponent.disable(), r.movementComponent = r.groundMovementComponent, r.jumpComponent = r.componentManager.addComponent(t.PlayerJump, 30, !1, !0), r.attackComponent = r.componentManager.addComponent(t.ComponentHit, r.enemyLayer, new Phaser.Rectangle(0, 0, 180, 90), 5, 2, 4), r.shootComponent = r.componentManager.addComponent(t.ShootComponent, r.enemyLayer, t.AmmunitionType.Fireball, r.parentGroup, 65, -30, 3, 4, 20), r.shootComponent.disable(), r.invulnerabilityTimer = r.componentManager.addComponent(t.ComponentTimer, GameData.invulnerabilityTimeHard), r.invulnerabilityTimer.onComplete.add(r.restoreVulnerable, r), r.recoveryTimer = r.componentManager.addComponent(t.ComponentTimer, GameData.stunTime), r.recoveryTimer.onComplete.add(r.restoreStunt, r), r.specialAttack = new t.SpecialAttacks(r.game, r, r.specialKey, r.parentGroup), r.dashComponent = null, r.onGround = !0, r.lastGroundContact = null, r.groundContactPool = [null, null, null, null], r.wallContactPool = [null, null, null, null], r.onWall = !1, r.lastWallContact = null, r.onVertex = !1, r.lastVertexContact = null, r.onConectedGround = !1, r.fallAnimPlaying = !1, r.lowfallAnimPlaying = !1, r.createFiniteStateMachine(), r.spineLocalScale = new Phaser.Point(r.game.world.scale.x, r.game.world.scale.y), r.movementDelta = new Phaser.Point(0, 0), r.benSpine = null, r.currentCharacter = -1, r.changeToCharacter(t.CharactersEnum.FourArms), Constants.CHEATS_ENABLED && (r.game.input.keyboard.addKey(Phaser.Keyboard.ONE).onDown.add(function() { r.changeToCharacter(t.CharactersEnum.FourArms) }, r), r.game.input.keyboard.addKey(Phaser.Keyboard.TWO).onDown.add(function() { r.changeToCharacter(t.CharactersEnum.XLR8) }, r), r.game.input.keyboard.addKey(Phaser.Keyboard.THREE).onDown.add(function() { r.changeToCharacter(t.CharactersEnum.Stinkfly) }, r), r.game.input.keyboard.addKey(Phaser.Keyboard.FOUR).onDown.add(function() { r.changeToCharacter(t.CharactersEnum.Slapback) }, r), r.game.input.keyboard.addKey(Phaser.Keyboard.FIVE).onDown.add(function() { r.changeToCharacter(t.CharactersEnum.Cannonbolt) }, r), r.game.input.keyboard.addKey(Phaser.Keyboard.SIX).onDown.add(function() { r.changeToCharacter(t.CharactersEnum.Heatblast) }, r), r.game.input.keyboard.addKey(Phaser.Keyboard.SEVEN).onDown.add(function() { r.changeToCharacter(t.CharactersEnum.Rath) }, r), r.game.input.keyboard.addKey(Phaser.Keyboard.EIGHT).onDown.add(function() { r.changeToCharacter(t.CharactersEnum.Humungousaur) }, r), r.game.input.keyboard.addKey(Phaser.Keyboard.NINE).onDown.add(function() { r.changeToCharacter(t.CharactersEnum.DiamondHead) }, r), r.game.input.keyboard.addKey(Phaser.Keyboard.ZERO).onDown.add(function() { r.changeToCharacter(t.CharactersEnum.ShockRock) }, r), r.game.input.keyboard.addKey(Phaser.Keyboard.O).onDown.add(r.toggleGodmode, r), r.game.input.keyboard.addKey(Phaser.Keyboard.H).onDown.add(r.fullRestore, r), r.game.input.keyboard.addKey(Phaser.Keyboard.F).onDown.add(r.removeLife, r)), r.addAnimationRespawn(), r } return __extends(i, e), i.prototype.addAnimationRespawn = function() { this.respawnAnim = new Phaser.Sprite(this.game, 0, 0, "atlas_animation2", "flash0.png"), this.respawnAnim.anchor.set(.5, .5); var t = Phaser.Animation.generateFrameNames("flash", 0, 8, ".png");
            this.respawnAnim.animations.add("flash", t, 16, !1), this.respawnAnim.visible = !1, this.addChild(this.respawnAnim) }, i.prototype.moveDpad = function(e) { this.resetIdleCounter(), this.currentDirectionDpad = e, this.movementComponent.isEnabled && (e === t.DpadDirection.right ? this.movementComponent.moveRight() : this.movementComponent.moveLeft()) }, i.prototype.stopDpad = function() { this.currentDirectionDpad = null, this.movementComponent.isEnabled && this.movementComponent.stopMovement() }, i.prototype.pressAttack = function() { this.resetIdleCounter(), this.shootEnabled ? this.preShootProyectile() : this.attackWithEffect() }, i.prototype.attackWithEffect = function() { this.attackComponent.hitCombo() }, i.prototype.fullRestore = function() { this.lifeManager.addLife(this.lifeManager.maxlifes), this.powerManager.addLife(this.powerManager.maxlifes) }, i.prototype.removeLife = function() { this.lifeManager.removeLife(this.lifeManager.currentlifes - 1) }, i.prototype.preShootProyectile = function() { t.Instances.paused || !this.state.can("hit") || this.state.is("hitting") || this.shootComponent.canShoot() && this.state.hit(0) }, i.prototype.toggleGodmode = function() { this.airMovementComponent.isEnabled ? (this.airMovementComponent.disable(), this.groundMovementComponent.enable(), this.movementComponent = this.groundMovementComponent, this.movementComponent = this.groundMovementComponent, this.jumpComponent.disable(), this.body.kinematic = !1, this.body.dynamic = !0, this.body.data.SetAwake(!0), this.body.gravityScale = this.thisGravity, this.setInvulnerable(!1)) : (this.groundMovementComponent.disable(), this.airMovementComponent.enable(), this.jumpComponent.enable(), this.movementComponent = this.airMovementComponent, this.body.gravityScale = 0, this.body.kinematic = !0, this.setNoneCollision()) }, i.prototype.createFiniteStateMachine = function() { var e, i = this;
            e = { init: "standing", transitions: [{ name: "stand", from: "*", to: "standing" }, { name: "walk", from: "jumping", to: "walking" }, { name: "walk", from: "standing", to: "walking" }, { name: "walk", from: "hitting", to: "walking" }, { name: "walk", from: "falling", to: "walking" }, { name: "walk", from: "flying", to: "walking" }, { name: "walk", from: "super", to: "walking" }, { name: "fall", from: "super", to: "falling" }, { name: "fall", from: "standing", to: "falling" }, { name: "fall", from: "walking", to: "falling" }, { name: "fall", from: "jumping", to: "falling" }, { name: "fall", from: "hitting", to: "falling" }, { name: "jump", from: "standing", to: "jumping" }, { name: "jump", from: "walking", to: "jumping" }, { name: "jump", from: "falling", to: "jumping" }, { name: "jump", from: "jumping", to: "jumping" }, { name: "hit", from: "falling", to: "hitting" }, { name: "hit", from: "jumping", to: "hitting" }, { name: "hit", from: "standing", to: "hitting" }, { name: "hit", from: "walking", to: "hitting" }, { name: "hit", from: "hitting", to: "hitting" }, { name: "stun", from: "*", to: "stunt" }, { name: "super", from: "jumping", to: "super" }, { name: "super", from: "standing", to: "super" }, { name: "super", from: "walking", to: "super" }], methods: { onStand: function() { i.spine.setAnimationByName(0, i.spineAnimationNames.stand, !0), i.onGround && i.lastGroundContact && (i.lastGroundContact.IsTouching() || (i.onGround = !1)) }, onWalk: function(t, e) { i.onGround && i.spine.getCurrentAnimationForTrack(0) !== i.spineAnimationNames.walk && (i.spine.setAnimationByName(0, i.spineAnimationNames.walk, !0), i.spine.onComplete.removeAll()), i.spine.scale.x = i.spineLocalScale.x * i.lookDirection.x }, onEnterFalling: function() { i.isFalling = !0 }, onFall: function() {}, onLeaveFalling: function() { i.isFalling = !1, i.fallAnimPlaying = !1, i.lowfallAnimPlaying = !1 }, onJump: function(t, e) { i.body.gravityScale = i.thisGravity, i.movementComponent.externalInfluenceY = 0, i.body.velocity.y = e, i.cameraY = i.body.y, i.onGround = !1, i.spine.setAnimationByName(0, i.spineAnimationNames.jumpIn), i.spine.addAnimationByName(0, i.spineAnimationNames.jumpLoop, !0) }, onHit: function(e, o) { i.shootEnabled ? (i.movementComponent.disableMovement(), i.spine.onComplete.removeAll(), i.onGround ? (i.body.velocity.x = 0, i.spine.setAnimationByName(0, i.spineAnimationNames.attacks[o])) : i.spine.setAnimationByName(0, i.spineAnimationNames.airAttack), i.currentCharacter === t.CharactersEnum.Stinkfly ? (i.game.ph2AudioManager.playEffect(i.game.rnd.pick(i.attackEffectNames), !1), i.shootComponent.shootProyectile()) : i.spine.onEvent.addOnce(function(t, e) { i.shootComponent.shootProyectile() }, i), i.spine.onComplete.addOnce(function() { i.state.stand(), i.movementComponent.enableMovement() }, i)) : (i.movementComponent.disableMovement(), i.spine.onComplete.removeAll(), i.onGround ? (i.body.velocity.x = 0, i.game.ph2AudioManager.playEffect(i.attackEffectNames[o], !1), i.spine.setAnimationByName(0, i.spineAnimationNames.attacks[o])) : (i.game.ph2AudioManager.playEffect(i.attackEffectNames[0], !1), i.spine.setAnimationByName(0, i.spineAnimationNames.airAttack)), i.spine.onComplete.addOnce(function() { i.onGround ? i.state.can("stand") && i.state.stand() : i.state.can("fall") && (i.state.fall(), i.spine.setAnimationByName(0, i.spineAnimationNames.jumpOut)), i.movementComponent.enableMovement() }, i)) }, onStun: function(t, e, o, n) { i.spine.onComplete.removeAll(), i.movementComponent.disableMovement(), i.jumpComponent.disable(), i.attackComponent.resetState(), i.attackComponent.disable(), i.body.setZeroVelocity(), i.setInvulnerable(!0), i.ignoreGroundRestitusion = !0, e ? (i.lookDirection.x = -Phaser.Math.sign(o), i.spine.scale.x = i.spineLocalScale.x * i.lookDirection.x, i.isStun = !0, i.spine.setAnimationByName(0, i.spineAnimationNames.stunned), i.body.velocity.x = GameData.stunImpulseX * o, i.body.velocity.y = GameData.stunImpulseY * n, i.invulnerabilityTimer.setTime(GameData.invulnerabilityTimeHard), i.invulnerabilityTimer.reset(), i.invulnerabilityTimer.startTimer(), i.recoveryTimer.reset(), i.recoveryTimer.startTimer()) : (i.spine.setAnimationByName(0, i.spineAnimationNames.underAttack), i.spine.onComplete.addOnce(function() { i.lifeManager.currentlifes > 0 && i.restoreStunt() }, i), i.invulnerabilityTimer.setTime(GameData.invulnerabilityTimeSoft), i.invulnerabilityTimer.reset(), i.invulnerabilityTimer.startTimer()) }, onSuper: function(t) { i.setInvulnerable(!0) }, onLeaveSuper: function(t) { i.setVulnerableAfterSuper = !0 } } }, this.state = new StateMachine(e) }, i.prototype.changeToCharacter = function(e) { if (this.currentCharacter !== e) { switch (this.spine && this.spine.destroy(!0), e) {
                    case t.CharactersEnum.FourArms:
                        this.spine = this.game.add.spine(0, 0, "fourarms"), this.spine.anchor.set(.5), this.addChild(this.spine), this.spineAnimationNames = { stand: "stand", idle: "random", walk: "run", falling: "jump_loop", jumpIn: "jump_in", jumpLoop: "jump_loop", jumpOut: "jump_out", underAttack: "under_attack", stunned: "stun", recover: "recovery", attacks: ["attack_1", "attack_2", "attack_3", "attack_4"], airAttack: "attack_air", start: "start", win: "game_complete", invulnerable: "vulnerable" }, this.attackEffectNames = ["fourarms_alien_combo1", "fourarms_alien_combo2", "fourarms_alien_combo3", "fourarms_alien_combo4"], this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0), this.setParametersToCharacter(PlayerParameters.FourArms), this.attackComponent.enableOneShotWalls(), this.attackComponent.enableShake(); break;
                    case t.CharactersEnum.XLR8:
                        this.body.gravityScale = this.thisGravity, this.spine = this.game.add.spine(0, 15, "xlr8"), this.spine.anchor.set(.5), this.addChild(this.spine), this.spineAnimationNames = { stand: "stand", idle: "idle", walk: "run", falling: "falling", jumpIn: "jump_in", jumpLoop: "jump_loop", jumpOut: "jump_out", underAttack: "under_attack", stunned: "stun", recover: "recovery", attacks: ["attack1", "attack2"], airAttack: "attack_air", start: "start", win: "win", invulnerable: "vulnerable" }, this.attackEffectNames = ["xlr8_alien_combo1", "xlr8_alien_combo2"], this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0), this.setParametersToCharacter(PlayerParameters.XLR8); break;
                    case t.CharactersEnum.Stinkfly:
                        this.body.gravityScale = this.thisGravity, this.spine = this.game.add.spine(0, -25, "stinkfly"), this.spine.anchor.set(.5), this.addChild(this.spine), this.spineAnimationNames = { stand: "stand", idle: "idle", walk: "run", falling: "jump_out", jumpIn: "jump_in", jumpLoop: "jump_loop", jumpOut: "jump_out", underAttack: "hit", stunned: "stun", recover: "recovery", attacks: ["attack1", "attack2"], airAttack: "attack_air", start: "start", win: "win", invulnerable: "vulnerable" }, this.attackEffectNames = ["stinkfly_alien_combo1", "stinkfly_alien_combo2", "stinkfly_alien_combo3"], this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0), this.setParametersToCharacter(PlayerParameters.Stinkfly), this.shootComponent.setAmmunition(t.AmmunitionType.AcidBall), this.shootComponent.enable(), this.shootComponent.setDamage(PlayerParameters.Stinkfly.specialDamage); break;
                    case t.CharactersEnum.Slapback:
                        this.body.gravityScale = this.thisGravity, this.spine = this.game.add.spine(0, 0, "slapback"), this.spine.anchor.set(.5), this.addChild(this.spine), this.spineAnimationNames = { stand: "stand", idle: "happy", walk: "run", falling: "jump_out", jumpIn: "jump_intro", jumpLoop: "jump_loop", jumpOut: "jump_out", underAttack: "under_attack", stunned: "stun", recover: "recovery", attacks: ["attack1", "attack2", "attack3"], airAttack: "attack_air", start: "start", win: "happy", invulnerable: "vulnerable" }, this.attackEffectNames = ["slapback_alien_combo1", "slapback_alien_combo2", "slapback_alien_combo3"], this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0), this.setParametersToCharacter(PlayerParameters.Slapback), this.attackComponent.enableShake(); break;
                    case t.CharactersEnum.Cannonbolt:
                        this.body.gravityScale = this.thisGravity, this.spine = this.game.add.spine(0, 0, "cannonbolt"), this.spine.anchor.set(.5), this.addChild(this.spine), this.spineAnimationNames = { stand: "stand", idle: "idle", walk: "run", falling: "jump_out", jumpIn: "jump_in", jumpLoop: "jump_loop", jumpOut: "jump_out", underAttack: "under_attack", stunned: "stun", recover: "recovery", attacks: ["attack1", "attack2", "attack3"], airAttack: "attack_air", start: "start", win: "win", invulnerable: "vulnerable" }, this.attackEffectNames = ["cannonball_alien_combo1", "cannonball_alien_combo2", "cannonball_alien_combo3"], this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0), this.setParametersToCharacter(PlayerParameters.Cannonbolt), null === this.dashComponent && (this.dashComponent = this.componentManager.addComponent(t.ComponentDashAttack, this.enemyLayer, new Phaser.Rectangle(0, 0, this.currentParameters.bodyWidth, this.currentParameters.bodyWidth), this.currentParameters.specialDamage, this.currentParameters.shootMaxDistance, this.currentParameters.shootSpeed, this.currentParameters.shootCooldown)), this.attackComponent.enableShake(); break;
                    case t.CharactersEnum.Heatblast:
                        this.body.gravityScale = this.thisGravity, this.spine = this.game.add.spine(0, -30, "heatblast"), this.spine.anchor.set(.5), this.addChild(this.spine), this.spineAnimationNames = { stand: "stand", idle: "stand", walk: "run", falling: "falling", jumpIn: "jump_in", jumpLoop: "jump_loop", jumpOut: "jump_out", underAttack: "under_attack", stunned: "stun", recover: "recovery", attacks: ["attack1", "attack2", "attack3"], airAttack: "attack_air", start: "start", win: "start", invulnerable: "vulnerable" }, this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0), this.setParametersToCharacter(PlayerParameters.Heatblast), this.shootComponent.setAmmunition(t.AmmunitionType.Fireball), this.attackComponent.enableShake(); break;
                    case t.CharactersEnum.Rath:
                        this.body.gravityScale = this.thisGravity, this.spine = this.game.add.spine(0, 0, "rath"), this.spine.anchor.set(.5), this.addChild(this.spine), this.spineAnimationNames = { stand: "stand", idle: "idle", walk: "run", falling: "jump_out", jumpIn: "jump_in", jumpLoop: "jump_loop", jumpOut: "jump_out", underAttack: "hit", stunned: "stun", recover: "recovery", attacks: ["attack1", "attack2", "attack3"], airAttack: "attack_air", start: "start", win: "win", invulnerable: "vulnerable" }, this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0), this.setParametersToCharacter(PlayerParameters.Rath), null === this.dashComponent && (this.dashComponent = this.componentManager.addComponent(t.ComponentDashAttack, this.enemyLayer, new Phaser.Rectangle(0, 0, this.currentParameters.bodyWidth, this.currentParameters.bodyWidth), this.currentParameters.specialDamage, this.currentParameters.shootMaxDistance, this.currentParameters.shootSpeed, this.currentParameters.shootCooldown)), this.attackComponent.enableShake(); break;
                    case t.CharactersEnum.Humungousaur:
                        this.body.gravityScale = this.thisGravity, this.spine = this.game.add.spine(0, 0, "humungousaur"), this.spine.anchor.set(.5), this.addChild(this.spine), this.spineAnimationNames = { stand: "stand", idle: "random", walk: "run", falling: "falling", jumpIn: "jump_in", jumpLoop: "jump_loop", jumpOut: "jump_out", underAttack: "under_attack", stunned: "stun", recover: "recovery", attacks: ["attack1", "attack2", "attack3"], airAttack: "attack_air", start: "start", win: "start", invulnerable: "vulnerable" }, this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0), this.setParametersToCharacter(PlayerParameters.Humungousaur), this.attackComponent.enableOneShotWalls(), this.attackComponent.enableShake(); break;
                    case t.CharactersEnum.DiamondHead:
                        this.body.gravityScale = this.thisGravity, this.spine = this.game.add.spine(0, 0, "diamondhead"), this.spine.anchor.set(.5), this.addChild(this.spine), this.spineAnimationNames = { stand: "stand", idle: "random", walk: "run", falling: "jump_out", jumpIn: "jump_in", jumpLoop: "jump_loop", jumpOut: "jump_out", underAttack: "under_attack", stunned: "stun", recover: "recovery", attacks: ["attack1", "attack2", "attack3"], airAttack: "attack_air", start: "start", win: "game_complete", invulnerable: "vulnerable" }, this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0), this.setParametersToCharacter(PlayerParameters.DiamondHead), this.attackComponent.enableShake(); break;
                    case t.CharactersEnum.ShockRock:
                        this.body.gravityScale = this.thisGravity, this.spine = this.game.add.spine(0, -30, "shockrock"), this.spine.anchor.set(.5), this.addChild(this.spine), this.spineAnimationNames = { stand: "stand", idle: "radom", walk: "run", falling: "jump_out", jumpIn: "jump_in", jumpLoop: "jump_loop", jumpOut: "jump_out", underAttack: "under_attack", stunned: "stun", recover: "recovery", attacks: ["attack1", "attack2", "attack3"], airAttack: "attack_air", start: "start", win: "game_complete", invulnerable: "vulnerable" }, this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0), this.setParametersToCharacter(PlayerParameters.ShockRock), this.attackComponent.enableShake() } this.specialAttack.setCharacterSpecialAttack(e), this.onChangeCharacter.dispatch(this.currentCharacter, e), this.currentCharacter = e, this.spine.scale.set(this.game.world.scale.x, this.game.world.scale.y) } }, i.prototype.setParametersToCharacter = function(e) { this.currentParameters = e, this.torsoFixture = this.body.setRectangle(e.bodyWidth, e.bodyHeight), this.torsoFixture.SetFilterData(this.filter), this.body.setFixtureContactCallback(this.torsoFixture, this.torsoContact, this), this.legsFixture = this.body.addCircle(.5 * e.bodyWidth + 2, 0, .5 * e.bodyHeight), this.legsFixture.SetFilterData(this.filter), this.body.setFixtureContactCallback(this.legsFixture, this.mapContactEntered, this), this.body.setCategoryPresolveCallback(t.CollisionLayers.Map, this.mapContactPreSolver, this); var i = e.healthPoints + GameData.healthPackIncrease * t.Instances.dataManager.getItemsHealth(),
                o = e.specialPoints + GameData.powerPackIncrease * t.Instances.dataManager.getItemsPower();
            this.lifeManager.setMaxLifes(i), this.lifeManager.setLife(i), this.powerManager.setMaxLifes(o), this.powerManager.setLife(o), this.movementComponent.setSpeed(e.speed), this.jumpComponent.setSpeed(e.jump), this.jumpComponent.setDoubleJump(e.doubleJump), this.shootComponent.setDamage(e.damage), this.shootComponent.setCooldown(e.shootCooldown), this.shootComponent.setSpeed(e.shootSpeed), this.shootComponent.setRange(e.shootMaxDistance), this.attackComponent.setDamage(e.damage), this.attackComponent.setComboCount(e.hitComboCount), this.attackComponent.setHitCooldown(e.hitCooldown), this.attackComponent.setHitEffectiveCooldown(e.connectedHitCooldown), this.attackComponent.setHitRect(0, 0, e.hitWidth, e.hitHeight), this.attackComponent.disableOneShotWalls(), this.shootEnabled = e.shoot, this.shootEnabled ? (this.attackKey.onDown.remove(this.attackWithEffect, this), this.attackKey.onDown.add(this.preShootProyectile, this)) : (this.attackKey.onDown.remove(this.preShootProyectile, this), this.attackKey.onDown.add(this.attackWithEffect, this)), this.specialAttack.setCost(e.specialCost), this.specialAttack.setDamage(e.specialDamage), this.attackComponent.resetState(), null !== this.dashComponent && (this.dashComponent.setHitRect(0, 0, e.bodyWidth, e.bodyWidth), this.dashComponent.setDamage(e.specialDamage), this.dashComponent.setDistance(e.shootMaxDistance), this.dashComponent.setSpeed(e.shootSpeed), this.dashComponent.setCooldown(e.shootCooldown)) }, i.prototype.setFilterData = function(t) { void 0 === t && (t = null), null !== t ? (this.torsoFixture.SetFilterData(t), this.legsFixture.SetFilterData(t)) : (this.torsoFixture.SetFilterData(this.filter), this.legsFixture.SetFilterData(this.filter)) }, i.prototype.setFilterMask = function(t) { void 0 === t && (t = null), null !== t ? (this.torsoFixture.m_filter.maskBits = t.maskBits, this.legsFixture.m_filter.maskBits = t.maskBits) : (this.torsoFixture.SetFilterData(this.filter), this.legsFixture.SetFilterData(this.filter)) }, i.prototype.update = function() { var e = this;
            t.Instances.paused || (this.setVulnerableAfterSuper && (this.setVulnerableAfterSuper = !1, this.setInvulnerable(!1)), null !== this.benSpine && this.benSpine.visible && this.benSpine.update(), this.spine.visible && this.spine.update(), this.onGround && (this.cameraY = this.body.y), this.walkingIn ? this.body.x > this.walkInTargetX && (this.walkingIn = !1, this.movementComponent.stopMovement(), this.body.setZeroVelocity(), this.body.reset(this.walkInTargetX, this.body.y), this.restoreAfterWalk ? this.restoreWalkIn() : this.onAfterIntro.dispatch()) : this.onGround ? (this.idleCounter += this.game.time.elapsedMS, this.idleCounter > GameData.idleTimer && (this.idleCounter = 0, this.state.is("standing") && (this.spine.setAnimationByName(0, this.spineAnimationNames.idle), this.spine.onComplete.addOnce(function() { e.spine.getCurrentAnimationForTrack(0) === e.spineAnimationNames.idle && e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0) }, this)))) : this.isFalling && (this.body.velocity.y > GameData.highFallSpeed ? this.fallAnimPlaying || (this.spine.setAnimationByName(0, this.spineAnimationNames.falling), this.fallAnimPlaying = !0) : this.body.velocity.y > GameData.lowFallSpeed && !this.lowfallAnimPlaying && (this.spine.setAnimationByName(0, this.spineAnimationNames.jumpLoop, !0), this.lowfallAnimPlaying = !0))) }, i.prototype.resetIdleCounter = function() { this.idleCounter = 0 }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.hitDamage = function(t, e, i, o) { void 0 === t && (t = 1), void 0 === i && (i = 0), void 0 === o && (o = 0), this.state.is("super") || (this.lifeManager.removeLife(t), this.lifeManager.currentlifes > 0 && (this.playRandomDamageEffect(), this.state.stun(e, i, o))) }, i.prototype.playRandomDamageEffect = function() { var t = this.game.rnd.integerInRange(1, 4);
            this.game.ph2AudioManager.playEffect("alien_damage" + t, !1) }, i.prototype.restoreStunt = function() { this.isStun ? (this.tweenAux = this.game.add.tween(this), this.tweenAux.to({ alpha: 0 }, 200, "Linear", !0, 0, -1, !0), this.spine.setAnimationByName(0, this.spineAnimationNames.recover), this.spine.onComplete.addOnce(this.restoreStunt_, this)) : (this.tweenAux = this.game.add.tween(this), this.tweenAux.to({ alpha: 0 }, 200, "Linear", !0, 0, -1, !0), this.restoreStunt_()) }, i.prototype.restoreStunt_ = function() { this.state.stand(), this.ignoreGroundRestitusion = !1, this.movementComponent.enableMovement(), this.jumpComponent.enable(), this.attackComponent.enable(), this.isStun = !1 }, i.prototype.restoreVulnerable = function() { this.tweenAux && (this.tweenAux.stop(!1), this.tweenAux = null, this.alpha = 1), this.setInvulnerable(!1), this.body.data.SetAwake(!0) }, i.prototype.restoreLife = function(t) { void 0 === t && (t = 1), this.game.ph2AudioManager.playEffect("health_recovery", !1), this.lifeManager.addLife(t) }, i.prototype.increaseLife = function(t) { void 0 === t && (t = 1), this.game.ph2AudioManager.playEffect("hidden_object", !1);
            this.lifeManager.maxlifes }, i.prototype.restorePower = function(t) { void 0 === t && (t = 1), this.game.ph2AudioManager.playEffect("super_recovery", !1), this.powerManager.addLife(t) }, i.prototype.increasePower = function(t) { void 0 === t && (t = 1), this.game.ph2AudioManager.playEffect("hidden_object", !1);
            this.lifeManager.maxlifes }, i.prototype.contactTorsoEnteredPreSolver = function(t, e, i, o, n, s) { n.SetEnabled(!1) }, i.prototype.contactLegsEnteredPreSolver = function(t, e, i, o, n, s) { this.onGround || (t.velocity.y > 0 && s.localNormal.y > GameData.GroundClearanceAngleCos ? (n.SetEnabled(!0), this._GroundIn(n)) : n.SetEnabled(!1)) }, i.prototype.mapContactPreSolver = function(t, e, i, o, n, s) { var r, a; if (this.body.id === t.id ? (a = t, r = e) : (a = e, r = t), r.data.m_userData.isPlatform)
                if (i.id === this.legsFixture.id)
                    if (r.sprite.isTargetStandingAbove) Math.abs(n.GetManifold().localNormal.x) > GameData.GroundClearanceAngleCos && (n.SetEnabled(!1), r.static || (r.sprite.releasePassenger(), this._GroundOut(n), this._WallOut()), e.sprite.isTargetContact = !1);
                    else { var h = n.GetManifold().pointCount,
                            l = new box2d.b2WorldManifold; if (n.GetWorldManifold(l), r.sprite.isTargetContact) return void n.SetEnabled(!1); if (Math.abs(n.GetManifold().localNormal.x) < GameData.GroundClearanceAngleCos)
                            for (var c = 0; c < h; c++) { var d = new box2d.b2Vec2; if (a.data.GetLinearVelocityFromWorldPoint(l.points[c], d), d.y < 0) return r.sprite.isTargetStandingAbove = !0, this._GroundIn(n), void this._WallOut() } e.sprite.isTargetContact = !0, n.SetEnabled(!1) } else i.id === this.torsoFixture.id && n.SetEnabled(!1) }, i.prototype.mapContactEntered = function(t, e, i, o, n, s) { if (0 != (o.m_filter.categoryBits & this.mapCollLayer) && null !== e.data.m_userData) { var r = s.GetManifold().localNormal.y > GameData.GroundClearanceAngleCos;
                n ? (this.state.is("stunt") && (this.body.velocity.x = this.movementComponent.externalInfluenceX), r ? this._GroundIn(s) : e.data.m_userData.isPlatform || (this.onWallCollision.dispatch(), this._WallIn(s))) : (r && this._GroundOut(s), this.onWall && this._WallOut(), e.data.m_userData.isPlatform && (e.static && (e.sprite.isTargetStandingAbove = !1), e.sprite.isTargetContact = !1)) } }, i.prototype.torsoContact = function(t, e, i, o, n, s) { 0 != (o.m_filter.categoryBits & this.mapCollLayer) && n && this.onTorsoCollision.dispatch() }, i.prototype._GroundIn = function(t) { var e = this;
            this.checkPoint.set(this.body.x, this.body.y); for (var i = 0; i < this.groundContactPool.length; i++)
                if (null === this.groundContactPool[i]) { this.groundContactPool[i] = t; break } this.onGround || ((this.lowfallAnimPlaying || this.jumpComponent.isJumping) && this.game.ph2AudioManager.playEffect("alien_ground", !1), this.onGround = !0, this.cameraY = this.body.y), this.lastGroundContact = t, this.ignoreGroundRestitusion || (this.movementComponent.enableMovement(), this.movementComponent.enable(), this.jumpComponent.enable(), this.movementComponent.isMoving ? this.state.is("stunt") ? this.spine.setAnimationByName(0, this.spineAnimationNames.walk, !0) : this.state.can("walk") && this.state.walk() : this.isFalling || this.jumpComponent.isJumping ? (this.spine.onComplete.removeAll(), this.spine.setAnimationByName(0, this.spineAnimationNames.jumpOut), this.spine.onComplete.addOnce(function() { e.movementComponent.isMoving || e.jumpComponent.isJumping || !e.state.can("stand") || e.state.stand() })) : this.state.can("stand") && this.state.stand()), this.isFalling = !1, this.jumpComponent.onGround(), this.attackComponent.onGround(), this.onGroundCollision.dispatch() }, i.prototype._GroundOut = function(t) { this.onGround = !1; for (var e = 0; e < this.groundContactPool.length; e++) null !== this.groundContactPool[e] && (this.groundContactPool[e].IsTouching() ? (this.onGround = !0, this.cameraY = this.body.y, this.lastGroundContact = this.groundContactPool[e]) : this.groundContactPool[e] = null);
            this.onGround || this.state.is("super") || this.state.is("jumping") || (this.body.gravityScale = this.thisGravity, this.state.can("fall") && this.state.fall()) }, i.prototype._WallIn = function(t) { this.onWall = !0, this.lastWallContact = t; for (var e = 0; e < this.wallContactPool.length; e++)
                if (null === this.wallContactPool[e]) { this.wallContactPool[e] = t; break } }, i.prototype._WallOut = function() { this.onWall = !1, this.lastWallContact = null; for (var t = 0; t < this.wallContactPool.length; t++) null !== this.wallContactPool[t] && (this.wallContactPool[t].IsTouching() ? (this.onWall = !0, this.lastWallContact = this.wallContactPool[t]) : this.wallContactPool[t] = null);
            this.onWall }, i.prototype.flipSpine = function() { this.spine.scale.y = this.spineLocalScale.y, this.spine.scale.x = this.spineLocalScale.x * this.movementComponent.lookDirection.x }, i.prototype.respawnInSafePoint = function() { this.lifeManager.currentlifes > 0 && (this.onGround = !0, this.cameraY = this.body.y, this.state.stand(), this.spine.visible = !0, this.movementComponent.enable(), this.body.gravityScale = this.thisGravity, this.body.reset(this.checkPoint.x, this.checkPoint.y)) }, i.prototype.playKillAnim = function() { this.movementComponent.disable(), this.body.gravityScale = 0, this.body.setZeroVelocity(), this.spine.visible = !1, this.respawnAnim.animations.play("flash"), this.respawnAnim.visible = !0 }, i.prototype.setInvulnerable = function(e) { void 0 === e && (e = !1), e ? (this.torsoFixture.m_filter.categoryBits = t.CollisionLayers.Invulnerable, this.legsFixture.m_filter.categoryBits = t.CollisionLayers.Invulnerable) : this.invulnerabilityTimer.isRunning() || this.state.is("super") || (this.torsoFixture.m_filter.categoryBits = t.CollisionLayers.Player, this.legsFixture.m_filter.categoryBits = t.CollisionLayers.Player, this.onRestoreVulnerability.dispatch()) }, i.prototype.isInvulnerable = function() { return this.body.data.m_fixtureList.m_filter.categoryBits === t.CollisionLayers.Invulnerable }, i.prototype.setDeath = function() { var t = this;
            this.onRestoreVulnerability.removeAll(), this.game.ph2AudioManager.playEffect("alien_gameover", !1), this.playKillAnim(), this.respawnAnim.animations.currentAnim.onComplete.addOnce(function() { t.componentManager.sendMessage("disable"), t.componentManager.removeAllComponents(), t.body.removeFromWorld(), t.spine.destroy(!0), t.respawnAnim.destroy(), t.destroy(), t.onDeath.dispatch() }) }, i.prototype.scalePlayer = function(t, e) { this.scale.set(t, e), this.spineLocalScale.set(t, e), this.spine.scale.set(t, e) }, i.prototype.walkOut = function(t) { this.componentManager.sendMessage("disable"), this.ignoreGroundRestitusion = !0, this.movementComponent.removeKeys(), this.movementComponent.enable(), this.body.velocity.y = 0, this.body.gravityScale = 0, this.body.friction = 0, this.body.linearDamping = 0, this.setNoneCollision(), this.movementComponent.lookDirection.x = 0, t > 0 ? this.movementComponent.moveRight() : this.movementComponent.moveLeft() }, i.prototype.setNoneCollision = function() { this.torsoFixture.m_filter.categoryBits = t.CollisionLayers.None, this.legsFixture.m_filter.categoryBits = t.CollisionLayers.None }, i.prototype.walkIn = function(t, e) { void 0 === e && (e = !0), this.ignoreGroundRestitusion = !0, this.disableComponents(), this.movementComponent.removeKeys(), this.movementComponent.initKeys = !1, this.movementComponent.enable(), Phaser.Math.sign(t - this.body.x) > 0 ? this.movementComponent.moveRight() : this.movementComponent.moveLeft(), this.walkInTargetX = t, this.walkingIn = !0, this.restoreAfterWalk = e }, i.prototype.restoreWalkIn = function() { this.torsoFixture.m_filter.categoryBits = t.CollisionLayers.Player, this.legsFixture.m_filter.categoryBits = t.CollisionLayers.Player, this.ignoreGroundRestitusion = !1, this.body.gravityScale = this.thisGravity, this.movementComponent.initKeys = !0, this.movementComponent.start(), this.afterIntro() }, i.prototype.disableComponents = function() { this.movementComponent.disable(), this.jumpComponent.disable(), this.specialAttack.disable(), this.shootComponent.disable(), this.attackComponent.disable() }, i.prototype.enableComponents = function() { this.movementComponent.enable(), this.jumpComponent.enable(), this.specialAttack.enable(), this.shootEnabled ? this.shootComponent.enable() : this.attackComponent.enable() }, i.prototype.isAlive = function() { return this.lifeManager.currentlifes > 0 }, i.prototype.initPlayerLevel = function() { this.spine.visible = !1 }, i.prototype.initPlayerRetry = function() { var t = .5 * (this.currentParameters.bodyHeight + this.currentParameters.bodyWidth) - 160;
            this.spine.visible = !1, this.benSpine = this.game.add.spine(-35, t, "ben"), this.addChild(this.benSpine) }, i.prototype.playRetryTransform = function() { this.benSpine.setAnimationByName(0, "intro2", !0), this.benSpine.onEvent.add(this.benEvent, this), this.benSpine.onComplete.addOnce(this.endLevelStart, this), this.ignoreGroundRestitusion = !1 }, i.prototype.playLevelStart = function() { this.ignoreGroundRestitusion = !0, this.spine.visible = !1; var t = 0;
            t = this.body.x - .5 * this.game.width < this.game.camera.bounds.x ? this.body.x - this.game.camera.bounds.x + 100 : .5 * this.game.width + 100; var e = .5 * (this.currentParameters.bodyHeight + this.currentParameters.bodyWidth) - 160;
            this.benSpine = this.game.add.spine(-t, e, "ben"), this.addChild(this.benSpine), this.benSpine.setAnimationByName(0, "run", !0), this.benSpine.onEvent.add(this.benEvent, this); var i = this.game.add.tween(this.benSpine);
            i.to({ x: -35 }, t / GameData.benIntroSpeed, Phaser.Easing.Linear.None, !0), i.onComplete.addOnce(this.playTransformAnim, this) }, i.prototype.benEvent = function(t, e) { "alien" === e.data.name && (this.spine.visible = !0, this.game.ph2AudioManager.playEffect("omnitrix", !1)) }, i.prototype.playTransformAnim = function() { this.benSpine.setAnimationByName(0, "intro", !1), this.benSpine.onComplete.addOnce(this.endLevelStart, this) }, i.prototype.endLevelStart = function() { this.benSpine.destroy(!0), this.benSpine = null, this.spine.setAnimationByName(0, this.spineAnimationNames.start), this.spine.onComplete.addOnce(this.afterIntro, this), this.spine.addAnimationByName(0, this.spineAnimationNames.stand, !0), this.ignoreGroundRestitusion = !1 }, i.prototype.afterIntro = function() { this.enableComponents(), this.onAfterIntro.dispatch() }, i.prototype.playFinishAnim = function() { this.setInvulnerable(!0), this.onGround ? (this.disableComponents(), this.body.setZeroVelocity(), this.spine.setAnimationByName(0, this.spineAnimationNames.win), this.spine.onComplete.removeAll(), this.spine.onComplete.addOnce(this.playFinishTransformAnim, this), this.benSpine = this.game.add.spine(0, -1e4, "ben"), this.benSpine.visible = !1, this.benSpine.setAnimationByName(0, "final"), this.benSpine.state.timeScale = 0) : (this.disableComponents(), this.ignoreGroundRestitusion = !0, this.onGroundCollision.addOnce(this.playFinishAnim, this)) }, i.prototype.playFinishTransformAnim = function() { var t = .5 * (this.currentParameters.bodyHeight + this.currentParameters.bodyWidth) - 160;
            this.game.ph2AudioManager.playEffect("omnitrix", !1), this.benSpine.state.timeScale = 1, this.benSpine.position.set(-35 * this.lookDirection.x, t), this.benSpine.visible = !0, this.lookDirection.x < 0 && (this.benSpine.scale.x = -1), this.addChild(this.benSpine), this.benSpine.addAnimationByName(0, "run", !0), this.benSpine.onEvent.add(this.benOutEvent, this) }, i.prototype.benOutEvent = function(t, e) { "alien" === e.data.name ? this.spine.visible = !1 : "run" === e.data.name && this.runFinishAnim() }, i.prototype.runFinishAnim = function() { var t;
            t = this.lookDirection.x > 0 ? this.game.width - (this.body.x - this.game.camera.x) + 100 : this.body.x - this.game.camera.x + 100; var e = this.game.add.tween(this.benSpine);
            e.to({ x: t * this.lookDirection.x - this.benSpine.x }, t / GameData.benIntroSpeed, Phaser.Easing.Linear.None, !0), e.onComplete.addOnce(this.endFinishAnim, this) }, i.prototype.endFinishAnim = function() { this.benSpine.destroy(!0), this.benSpine = null, this.onAfterOutro.dispatch() }, i.prototype.destroy = function(i) { this.body.setFixtureContactCallback(this.legsFixture, function() {}, {}), this.body.setCategoryPresolveCallback(t.CollisionLayers.Map, function() {}, {}), e.prototype.destroy.call(this, i), this.body.destroy(), this.body.kill(), this.body.clearFixtures(), this.body.removeFromWorld(), this.specialAttack.destroy(), this.lifeManager.destroy(), this.powerManager.destroy(), this.state = null, this.onRestoreVulnerability.dispose(), this.onRestoreVulnerability = null, this.specialAttack = null, this.benSpine = null, this.spine = null }, i }(Phaser.Sprite);
    t.Player = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a, h, l, c, d) { var u = e.call(this, i, o, n, null) || this;
            u._hitDamage = h, u.speed = l, u.collisionCategory = a, u.startx = o, s.add(u), i.physics.box2d.enable(u), u.body.setRectangle(r.width, r.height), u.body.friction = 0, u.body.linearDamping = 0, u.body.gravityScale = 0, u.body.sensor = !0; var p = new box2d.b2Filter; return p.categoryBits = t.CollisionLayers.Bullets, p.maskBits = t.CollisionLayers.Map | u.collisionCategory, u.body.data.m_fixtureList.SetFilterData(p), u.body.setFixtureContactCallback(u.body.data.m_fixtureList, u.contactEntered, u), u.lookDirection = new Phaser.Point(1, 0), d && (u.lookDirection.set(d.x, d.y), u.body.angle = Phaser.Math.radToDeg(Math.atan2(d.y, d.x))), u.body.velocity.x = u.speed * d.x, u.body.velocity.y = u.speed * d.y, u.componentManager = Ph2.ComponentPlugin.initComponents(u), u.lifeTimer = u.componentManager.addComponent(t.ComponentTimer, c, !0), u.lifeTimer.onComplete.add(u.bulletImpact, u), u.hitFx = u.game.add.sprite(0, 0, "atlas_animations", "hit1_0.png"), u.hitFx.animations.add("loop", Phaser.Animation.generateFrameNames("hit1_", 0, 4, ".png"), 15, !1), u.hitFx.visible = !1, u.hitFx.scale.x = u.lookDirection.x, s.add(u.hitFx), t.Instances.onPause.add(u.pause, u), t.Instances.onResume.add(u.resume, u), u } return __extends(i, e), i.prototype.contactEntered = function(e, i, o, n, s, r) { s && (n.m_filter.categoryBits === t.CollisionLayers.Map ? this.bulletImpact() : this.hitBulletImpact(i)) }, i.prototype.bulletImpact = function() { this.hitFx.position.set(this.position.x + 50 * this.lookDirection.x, this.position.y), this.hitFx.animations.play("loop").onComplete.addOnce(this.destroyProyectile, this), this.hitFx.visible = !0, this.componentManager.removeAllComponents(), this.body.removeFromWorld(), this.animations.stop(), this.visible = !1 }, i.prototype.hitBulletImpact = function(t) { t.sprite.hitDamage(this._hitDamage, !1, 0, 0, !0), this.bulletImpact() }, i.prototype.destroyProyectile = function() { t.Instances.onPause.remove(this.pause, this), t.Instances.onResume.remove(this.resume, this), this.destroy(!0), this.hitFx.destroy() }, i.prototype.pause = function() { this.visible && (this.animations.paused = !0), this.hitFx.visible && (this.hitFx.animations.paused = !0) }, i.prototype.resume = function() { this.visible && (this.animations.paused = !1), this.hitFx.visible && (this.hitFx.animations.paused = !1) }, i }(Phaser.Sprite);
    t.Projectile = e }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function e(e, i, o, n, s) { void 0 === n && (n = null), void 0 === s && (s = ""), this.game = e, this.player = i, this.outDirection = 1, this.isVertical = !1, this.tileBg = n, this.bgSpeedY = 0, this.loadOnAir = !1, this.onEnter = new Phaser.Signal, this.onEnd = new Phaser.Signal, this.isEndOfLevel = !0, s.length > 0 && (this.isEndOfLevel = !1); var r = new box2d.b2Filter;
            r.categoryBits = t.CollisionLayers.Items, r.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, this.x = o.x + .5 * o.width, this.y = o.y - .5 * o.height; var a = this.x,
                h = this.y,
                l = o.width,
                c = o.height; if (o.properties)
                for (var d = 0, u = o.properties; d < u.length; d++) { var p = u[d]; "vertical" === p.name && p.value && (this.isVertical = !0), "bg" === p.name && null !== this.tileBg && (this.loadOnAir = !0) } l -= i.currentParameters.bodyWidth, this.trigger = this.game.physics.box2d.createBody(a, h, 0), this.trigger.setRectangle(l, c), this.trigger.setBodyContactCallback(i, this.checkCollision, this), this.trigger.dynamic = !1, this.trigger.static = !0, this.trigger.sensor = !0, this.trigger.data.m_fixtureList.SetFilterData(r), t.Instances.callbackSubscriber.onUpdate.add(this.enderUpdate, this) } return e.prototype.enderUpdate = function() { this.playerIn && (this.outDirection > 0 ? this.player.x > this.game.camera.x + this.game.width && this.endSection() : this.player.x < this.game.camera.x && this.endSection()) }, e.prototype.checkCollision = function(e, i, o, n, s, r) { var a = this;
            s && (this.playerIn || (this.playerIn = !0, this.onEnter.dispatch(), this.trigger.removeFromWorld(), this.player.disableComponents(), this.isEndOfLevel ? this.endSection() : (this.player.body.x < this.trigger.x ? t.Instances.cameraManager.setBoundX(this.trigger.x - .75 * this.game.width) : t.Instances.cameraManager.setBoundX(this.trigger.x - .25 * this.game.width), t.Instances.cameraManager.setBoundWidth(this.game.width), this.outDirection = Phaser.Math.sign(this.trigger.x - this.player.body.x), this.player.ignoreGroundRestitusion = !0, this.player.onGround ? (this.player.walkOut(this.outDirection), t.Instances.cameraManager.setBoundY(this.game.camera.y), t.Instances.cameraManager.setBoundHeight(this.game.height)) : (this.player.movementComponent.removeKeys(), this.player.onGroundCollision.addOnce(function() { t.Instances.cameraManager.setBoundY(a.game.camera.y), t.Instances.cameraManager.setBoundHeight(a.game.height), a.player.walkOut(a.outDirection) }, this))))) }, e.prototype.endSection = function() { t.Instances.callbackSubscriber.onUpdate.remove(this.enderUpdate, this), this.onEnd.dispatch(this.isVertical) }, e.prototype.set = function(t, e) { this.x = t, this.y = e }, e.prototype.disableGameElement = function() { this.trigger.data.SetActive(!1) }, e.prototype.enableGameElement = function() { this.trigger.data.SetActive(!0) }, e.prototype.destroy = function() { this.player = null }, e }();
    t.SectionEnd = e }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function e(e, i, o, n) { this.game = e, this.player = i, this.enabled = !0, this.effectiveHit = !1, this.onCooldown = !1, this.currentAttack = this.specialAttackFourArms, this.damage = 1, this.spCost = 1, this.componentManager = i.componentManager, this.objectsGroup = n, this.heatblastChargeTime = 1e3, this.heatblastBallScale = 2, this.heatblastPrevPercent = 0, this.auxTimer = this.componentManager.addComponent(t.ComponentTimer, 1e3), this.auxSprite = null, this.key = o, this.key.onDown.add(this.attack, this), this.hitRect = new Phaser.Rectangle(0, 0, 400, 100), Constants.DEBUG_ENABLED && (this.debugSprite = this.game.add.sprite(0, 0, "white_pixel"), this.debugSprite.alpha = .6, this.debugSprite.visible = !1) } return e.prototype.attack = function() {!t.Instances.paused && this.enabled && this.player.powerManager.currentlifes >= this.spCost && this.currentAttack.call(this) }, e.prototype.hitEnemy = function(t) { t.sprite && t.sprite.hitDamage(this.damage, !0, Phaser.Math.sign(t.x - this.player.body.x), -1) }, e.prototype.cooldown = function() { this.onCooldown = !1 }, e.prototype.specialAttackFourArms = function() { this.player.state.can("super") && (this.player.powerManager.removeLife(this.spCost), this.player.state.super(), this.game.ph2AudioManager.playEffect("fourarms_special", !1), this.player.movementComponent.disableMovement(), this.player.attackComponent.disable(), this.player.onGround ? (this.player.body.velocity.x = 0, this.player.spine.setAnimationByName(0, "super_in"), this.player.spine.onComplete.addOnce(this.beginFourArms, this)) : (this.player.ignoreGroundRestitusion = !0, this.player.spine.setAnimationByName(0, "super_in"), this.player.spine.addAnimationByName(0, "super_loop"), this.player.onGroundCollision.addOnce(this.beginFourArms, this))) }, e.prototype.beginFourArms = function() { this.player.body.velocity.x = 0, t.Instances.cameraManager.shake(GameData.actionShakeIntensity, GameData.actionShakeDuration, Phaser.Camera.SHAKE_BOTH), this.hitRect.x = this.player.lookDirection.x > 0 ? this.player.body.x : this.player.body.x - this.hitRect.width, this.hitRect.y = this.player.body.y + .5 * (this.player.currentParameters.bodyHeight + this.player.currentParameters.bodyWidth) - this.hitRect.height, Constants.DEBUG_ENABLED && (this.debugSprite.visible = !0, this.debugSprite.width = this.hitRect.width, this.debugSprite.height = this.hitRect.height, this.debugSprite.x = this.hitRect.x, this.debugSprite.y = this.hitRect.y), t.Instances.callbackSubscriber.onUpdate.add(this.updateFourArms, this), this.player.spine.setAnimationByName(0, "super_out"), this.player.spine.onComplete.addOnce(this.endFourArms, this) }, e.prototype.updateFourArms = function(e) { var i = this.game.physics.box2d.queryAABB(this.hitRect.x, this.hitRect.y, this.hitRect.width, this.hitRect.height); if (this.effectiveHit = !1, i.length > 0)
                for (var o = 0, n = i; o < n.length; o++) { var s = n[o];
                    0 != (s.fixture.m_filter.categoryBits & this.player.enemyLayer) && (this.hitEnemy(s.body), this.effectiveHit = !0) } this.effectiveHit && t.Instances.callbackSubscriber.onUpdate.remove(this.updateFourArms, this) }, e.prototype.endFourArms = function() { this.effectiveHit || t.Instances.callbackSubscriber.onUpdate.remove(this.updateFourArms, this), this.effectiveHit = !1, this.player.state.stand(), this.enabled && (this.player.ignoreGroundRestitusion = !1, this.player.movementComponent.enableMovement(), this.player.attackComponent.enable()), Constants.DEBUG_ENABLED && (this.debugSprite.visible = !1) }, e.prototype.specialAttackXLR8 = function() { this.player.state.can("super") && (t.Instances.cameraManager.shake(GameData.actionShakeIntensity, GameData.actionShakeDuration, Phaser.Camera.SHAKE_BOTH), this.player.powerManager.removeLife(this.spCost), this.player.state.super(), this.game.ph2AudioManager.playEffect("xlr8_alien_special", !1), this.player.movementComponent.disable(), this.player.attackComponent.disable(), this.player.jumpComponent.disable(), this.player.ignoreGroundRestitusion = !0, this.player.spine.setAnimationByName(0, "special"), this.player.spine.onComplete.addOnce(this.endXLR8, this), t.Instances.callbackSubscriber.onUpdate.add(this.updateXLR8, this), Constants.DEBUG_ENABLED && (this.debugSprite.visible = !0, this.debugSprite.width = this.hitRect.width, this.debugSprite.height = this.hitRect.height, this.debugSprite.x = this.player.body.x + this.hitRect.x, this.debugSprite.y = this.player.body.y + this.hitRect.y)) }, e.prototype.updateXLR8 = function(t) { Constants.DEBUG_ENABLED && (this.debugSprite.x = this.player.body.x + this.hitRect.x, this.debugSprite.y = this.player.body.y + this.hitRect.y); var e = this.game.physics.box2d.queryAABB(this.player.body.x + this.hitRect.x, this.player.body.y + this.hitRect.y, this.hitRect.width, this.hitRect.height); if (this.effectiveHit = !1, e.length > 0)
                for (var i = 0, o = e; i < o.length; i++) { var n = o[i];
                    0 != (n.fixture.m_filter.categoryBits & this.player.enemyLayer) && (this.hitEnemy(n.body), this.effectiveHit = !0) } }, e.prototype.endXLR8 = function() { t.Instances.callbackSubscriber.onUpdate.remove(this.updateXLR8, this), this.player.onGround ? this.player.state.stand() : this.player.state.fall(), this.enabled && (this.player.ignoreGroundRestitusion = !1, this.player.movementComponent.enable(), this.player.attackComponent.enable(), this.player.jumpComponent.enable()), Constants.DEBUG_ENABLED && (this.debugSprite.visible = !1) }, e.prototype.specialAttackStinkfly = function() { this.player.state.can("super") && !this.onCooldown && (this.player.powerManager.removeLife(this.spCost), this.player.state.super(), this.game.ph2AudioManager.playEffect("stinkfly_special", !1), this.player.onGround && (this.player.body.velocity.x = 0), this.player.attackComponent.disable(), this.player.movementComponent.disableMovement(), this.player.jumpComponent.disable(), this.auxTimer.setTime(GameData.stinkflySuperCooldown), this.auxTimer.reset(), this.auxTimer.onComplete.addOnce(this.cooldown, this), this.auxTimer.startTimer(), this.onCooldown = !0, this.player.spine.setAnimationByName(0, "super"), this.player.spine.onComplete.addOnce(this.endStinkfly, this)) }, e.prototype.eventStinkfly = function(t, e) { "damage" === e.data.name && this.shootStinkfly() }, e.prototype.shootStinkfly = function() { t.Instances.cameraManager.shake(GameData.actionShakeIntensity, GameData.actionShakeDuration, Phaser.Camera.SHAKE_BOTH);
            new t.BulletAcid(this.game, this.player.x + 20 * this.player.lookDirection.x, this.player.y + -50, this.player.lookDirection, 700, this.player.enemyLayer, this.damage, this.objectsGroup) }, e.prototype.endStinkfly = function() { this.player.onGround ? this.player.state.stand() : this.player.state.fall(), this.enabled && (this.player.attackComponent.enable(), this.player.movementComponent.enableMovement(), this.player.jumpComponent.enable()) }, e.prototype.specialAttackSlapback = function() { this.player.state.can("super") && (t.Instances.cameraManager.shake(GameData.actionShakeIntensity, GameData.actionShakeDuration, Phaser.Camera.SHAKE_BOTH), this.player.powerManager.removeLife(this.spCost), this.player.state.super(), this.game.ph2AudioManager.playEffect("slapback_special", !1), this.player.attackComponent.disable(), this.player.movementComponent.disableMovement(), this.player.jumpComponent.disable(), this.player.onGround ? this.player.body.velocity.x = 0 : (this.player.body.gravityScale = 0, this.player.body.setZeroVelocity()), this.player.spine.setAnimationByName(0, "super"), this.player.spine.onComplete.addOnce(this.endSlapback, this), t.Instances.callbackSubscriber.onUpdate.add(this.updateSlapback, this), Constants.DEBUG_ENABLED && (this.debugSprite.x = this.player.x + this.hitRect.x, this.debugSprite.y = this.player.y + this.hitRect.y, this.debugSprite.visible = !0)) }, e.prototype.updateSlapback = function() { if (!this.effectiveHit) { var e = this.game.physics.box2d.queryAABB(this.player.x + this.hitRect.x, this.player.y + this.hitRect.y, this.hitRect.width, this.hitRect.height); if (this.effectiveHit = !1, e.length > 0)
                    for (var i = 0, o = e; i < o.length; i++) { var n = o[i];
                        0 == (n.fixture.m_filter.categoryBits & t.CollisionLayers.Enemies) && 0 == (n.fixture.m_filter.categoryBits & t.CollisionLayers.Breakable) || (this.hitEnemy(n.body), this.effectiveHit = !0) } } }, e.prototype.endSlapback = function() { t.Instances.callbackSubscriber.onUpdate.remove(this.updateSlapback, this), Constants.DEBUG_ENABLED && (this.debugSprite.visible = !1), this.effectiveHit = !1, this.player.body.data.SetAwake(!0), this.player.body.gravityScale = this.player.thisGravity, this.player.onGround ? this.player.state.stand() : this.player.state.fall(), this.enabled && (this.player.attackComponent.enable(), this.player.movementComponent.enableMovement(), this.player.jumpComponent.enable()) }, e.prototype.specialAttackCannonbolt = function() { this.player.state.can("super") && (t.Instances.cameraManager.shake(GameData.actionShakeIntensity, GameData.actionShakeDuration, Phaser.Camera.SHAKE_BOTH), this.player.powerManager.removeLife(this.spCost), this.player.state.super(), this.game.ph2AudioManager.playEffect("cannonball_special", !1), this.player.setFilterMask(this.auxFilter), this.player.spine.onComplete.removeAll(), this.player.attackComponent.disable(), this.player.onGround ? this.player.body.velocity.x = 0 : this.player.body.setZeroVelocity(), this.player.movementComponent.disableMovement(), this.player.jumpComponent.disable(), this.player.dashComponent.onAfterDash.addOnce(this.finishCannonbolt, this), this.player.spine.setAnimationByName(0, "roll_in"), this.player.onWall ? this.player.lastWallContact.m_fixtureA.m_filter.categoryBits === t.CollisionLayers.Breakable ? (this.player.lastWallContact.SetEnabled(!1), this.dashCannonbolt()) : this.player.spine.onComplete.addOnce(this.finishCannonboltEarly, this) : this.dashCannonbolt()) }, e.prototype.dashCannonbolt = function() { var t = this;
            this.player.body.gravityScale = 0, this.player.spine.addAnimationByName(0, "roll_run", !0), this.auxTimer.onComplete.addOnce(function() { t.player.movementComponent.disable(), t.player.body.gravityScale = t.player.thisGravity, t.player.ignoreGroundRestitusion = !0, t.player.onWallCollision.addOnce(t.finishCannonbolt, t), t.player.onTorsoCollision.addOnce(t.finishCannonbolt, t), t.player.dashComponent.attack() }, this), this.auxTimer.startTimer() }, e.prototype.finishCannonboltEarly = function(t) { "roll_in" === t.animation.name && (this.player.spine.onComplete.removeAll(), this.finishCannonbolt()) }, e.prototype.finishCannonbolt = function() { this.player.setFilterData(), this.player.setInvulnerable(!0), this.player.dashComponent.isDashing && (this.player.dashComponent.interruptDash(), this.player.dashComponent.onAfterDash.remove(this.finishCannonbolt, this)), this.player.onWallCollision.remove(this.finishCannonbolt, this), this.player.onTorsoCollision.remove(this.finishCannonbolt, this), this.player.body.setZeroVelocity(), this.player.spine.setAnimationByName(0, "roll_out"), this.player.spine.onComplete.addOnce(this.endCannonbolt, this) }, e.prototype.endCannonbolt = function() { this.player.ignoreGroundRestitusion = !1, this.player.movementComponent.lookDirection.x = 0, this.player.onGround ? this.player.state.stand() : this.player.state.fall(), this.enabled && (this.player.attackComponent.enable(), this.player.jumpComponent.enable(), this.player.movementComponent.enableMovement(), this.player.movementComponent.enable()) }, e.prototype.specialAttackHeatblast = function() { this.player.state.can("super") && !this.onCooldown && (this.player.powerManager.removeLife(this.spCost), this.player.state.super(), this.game.ph2AudioManager.playEffect("stinkfly_special", !1), this.player.onGround && (this.player.body.velocity.x = 0), this.player.attackComponent.disable(), this.player.movementComponent.disableMovement(), this.player.jumpComponent.disable(), this.auxTimer.setTime(GameData.heatblastSuperCooldown), this.auxTimer.reset(), this.auxTimer.onComplete.addOnce(this.cooldown, this), this.auxTimer.startTimer(), this.onCooldown = !0, this.player.spine.setAnimationByName(0, "special"), this.player.spine.onComplete.addOnce(this.endHeatblast, this)) }, e.prototype.eventHeatblast = function(t, e) { "fire" === e.data.name && this.shootHeatblast() }, e.prototype.shootHeatblast = function() { this.hitRect.setTo(0, 0, 100, 30); var e = PlayerParameters.Heatblast.shootSpeed * GameData.PixToMet,
                i = PlayerParameters.Heatblast.shootMaxDistance / e * 1e3,
                o = new t.Projectile(this.game, this.player.x + 20 * this.player.lookDirection.x, this.player.y + -50, this.objectsGroup, this.hitRect, this.player.enemyLayer, this.damage, e, i, this.player.lookDirection);
            this.onCooldown = !0, o.loadTexture("atlas_animations"), o.frameName = "stinkfly_attack0.png", o.animations.add("acid", Phaser.Animation.generateFrameNames("stinkfly_attack", 0, 3, ".png"), 15, !0), o.animations.play("acid") }, e.prototype.endHeatblast = function() { this.player.onGround ? this.player.state.stand() : this.player.state.fall(), this.enabled && (this.player.attackComponent.enable(), this.player.movementComponent.enableMovement(), this.player.jumpComponent.enable()) }, e.prototype.specialAttackHumungousaur = function() { this.player.state.can("super") && (this.player.powerManager.removeLife(this.spCost), this.player.state.super(), this.game.ph2AudioManager.playEffect("fourarms_special", !1), this.player.movementComponent.disableMovement(), this.player.attackComponent.disable(), this.player.onGround ? (this.player.body.velocity.x = 0, this.player.spine.setAnimationByName(0, "super_in"), this.player.spine.onComplete.addOnce(this.beginHumungousaur, this)) : (this.player.ignoreGroundRestitusion = !0, this.player.spine.setAnimationByName(0, "super_in"), this.player.spine.addAnimationByName(0, "super_loop"), this.player.onGroundCollision.addOnce(this.beginHumungousaur, this))) }, e.prototype.beginHumungousaur = function() { this.hitRect.x = this.player.body.x - .5 * this.hitRect.width, this.hitRect.y = this.player.body.y + .5 * (this.player.currentParameters.bodyHeight + this.player.currentParameters.bodyWidth) - this.hitRect.height, Constants.DEBUG_ENABLED && (this.debugSprite.visible = !0, this.debugSprite.width = this.hitRect.width, this.debugSprite.height = this.hitRect.height, this.debugSprite.x = this.hitRect.x, this.debugSprite.y = this.hitRect.y), t.Instances.callbackSubscriber.onUpdate.add(this.updateHumungousaur, this), this.player.spine.setAnimationByName(0, "super_out"), this.player.spine.onComplete.addOnce(this.endHumungousaur, this) }, e.prototype.updateHumungousaur = function(e) { var i = this.game.physics.box2d.queryAABB(this.hitRect.x, this.hitRect.y, this.hitRect.width, this.hitRect.height); if (this.effectiveHit = !1, i.length > 0)
                for (var o = 0, n = i; o < n.length; o++) { var s = n[o];
                    0 != (s.fixture.m_filter.categoryBits & this.player.enemyLayer) && (this.hitEnemy(s.body), this.effectiveHit = !0) } this.effectiveHit && t.Instances.callbackSubscriber.onUpdate.remove(this.updateHumungousaur, this) }, e.prototype.endHumungousaur = function() { this.effectiveHit || t.Instances.callbackSubscriber.onUpdate.remove(this.updateHumungousaur, this), this.effectiveHit = !1, this.player.state.stand(), this.enabled && (this.player.ignoreGroundRestitusion = !1, this.player.movementComponent.enableMovement(), this.player.attackComponent.enable()), Constants.DEBUG_ENABLED && (this.debugSprite.visible = !1) }, e.prototype.setCharacterSpecialAttack = function(e) { switch (e) {
                case t.CharactersEnum.FourArms:
                    this.currentAttack = this.specialAttackFourArms, this.hitRect.x = 0, this.hitRect.y = 0, this.hitRect.width = GameData.fourarmsSuperWidth, this.hitRect.height = GameData.fourarmsSuperHeight; break;
                case t.CharactersEnum.XLR8:
                    this.currentAttack = this.specialAttackXLR8, this.hitRect.x = -.5 * GameData.xlr8SuperWidth, this.hitRect.y = -.5 * GameData.xlr8SuperHeight, this.hitRect.width = GameData.xlr8SuperWidth, this.hitRect.height = GameData.xlr8SuperHeight; break;
                case t.CharactersEnum.Stinkfly:
                    this.currentAttack = this.specialAttackStinkfly, this.player.spine.onEvent.add(this.eventStinkfly, this); break;
                case t.CharactersEnum.Slapback:
                    this.hitRect.x = -.5 * GameData.slapbackSuperWidth, this.hitRect.y = -GameData.slapbackSuperHeight + .5 * (this.player.currentParameters.bodyHeight + this.player.currentParameters.bodyWidth), this.hitRect.width = GameData.slapbackSuperWidth, this.hitRect.height = GameData.slapbackSuperHeight, this.currentAttack = this.specialAttackSlapback, Constants.DEBUG_ENABLED && (this.debugSprite.width = this.hitRect.width, this.debugSprite.height = this.hitRect.height); break;
                case t.CharactersEnum.Cannonbolt:
                    this.currentAttack = this.specialAttackCannonbolt, this.auxFilter = new box2d.b2Filter, this.auxFilter.categoryBits = t.CollisionLayers.Player, this.auxFilter.maskBits = t.CollisionLayers.Map | t.CollisionLayers.Damage | t.CollisionLayers.Platforms | t.CollisionLayers.Bullets | t.CollisionLayers.Items, this.auxTimer.setTime(GameData.cannonboltChargingTime); break;
                case t.CharactersEnum.Heatblast:
                    this.currentAttack = this.specialAttackHeatblast, this.player.spine.onEvent.add(this.eventHeatblast, this); break;
                case t.CharactersEnum.Rath:
                    this.currentAttack = this.specialAttackCannonbolt, this.auxFilter = new box2d.b2Filter, this.auxFilter.categoryBits = t.CollisionLayers.Player, this.auxFilter.maskBits = t.CollisionLayers.Map | t.CollisionLayers.Damage | t.CollisionLayers.Platforms | t.CollisionLayers.Bullets | t.CollisionLayers.Items, this.auxTimer.setTime(GameData.rathChargingTime); break;
                case t.CharactersEnum.Humungousaur:
                    this.currentAttack = this.specialAttackHumungousaur, this.hitRect.x = 0, this.hitRect.y = 0, this.hitRect.width = GameData.humungousaurSuperWidth, this.hitRect.height = GameData.humungousaurSuperHeight; break;
                case t.CharactersEnum.DiamondHead:
                    this.currentAttack = this.specialAttackFourArms, this.hitRect.x = 0, this.hitRect.y = 0, this.hitRect.width = GameData.diamondheadSuperWidth, this.hitRect.height = GameData.diamondheadSuperHeight; break;
                case t.CharactersEnum.ShockRock:
                    this.currentAttack = this.specialAttackHumungousaur, this.hitRect.x = 0, this.hitRect.y = 0, this.hitRect.width = GameData.shockrockSuperWidth, this.hitRect.height = GameData.shockrockSuperHeight; break;
                default:
                    this.currentAttack = this.specialAttackFourArms, this.hitRect.x = 0, this.hitRect.y = 0, this.hitRect.width = GameData.fourarmsSuperWidth, this.hitRect.height = GameData.fourarmsSuperHeight } }, e.prototype.setDamage = function(t) { this.damage = t }, e.prototype.setCost = function(t) { this.spCost = t }, e.prototype.restoreSpecial = function() { this.enabled = !0 }, e.prototype.disable = function() { this.enabled = !1 }, e.prototype.enable = function() { this.enabled = !0 }, e.prototype.destroy = function() { this.player = null }, e }();
    t.SpecialAttacks = e }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function e(t, e, i, o, n, s, r) { if (void 0 === s && (s = null), void 0 === r && (r = !0), this.game = t, this.key = n, this.frame = s, this.sprite = null, this.index = o, this.useScaling = r, this.visibilityCounter = 0, this.assetTag = null !== s ? this.frame : this.key, this.useTileSprite = !1, e.properties)
                for (var a = 0, h = e.properties; a < h.length; a++) switch (h[a].name) {
                    case "tiled_x":
                    case "tiled_y":
                        this.useTileSprite = !0 } e.gid, GameData.diaFlipMask; var l = 0 != (e.gid & GameData.verFlipMask),
                c = 0 != (e.gid & GameData.horFlipMask);
            this.sprite = null, this.tileObject = e, this.scale = new Phaser.Point(1, 1), this.anchor = new Phaser.Point(0, 1), this.x = e.x, this.y = e.y, this.useTileSprite ? (this.width = Math.min(t.width, e.width), this.height = Math.min(t.height, e.height)) : (this.width = e.width, this.height = e.height), this.angle = e.rotation, l && (this.scale.y = -1, this.anchor.y = 0), c && (this.scale.x = -1, this.anchor.x = 1), this.parentGroup = i } return Object.defineProperty(e.prototype, "visible", { set: function(e) { e ? 1 === ++this.visibilityCounter && (this.useTileSprite ? this.setPoolTileSprite() : this.setPoolSprite(), this.revive(), this.sprite.data.proxy = this, this.sprite.x = this.x, this.sprite.y = this.y, this.sprite.width = this.width, this.sprite.height = this.height, this.sprite.angle = this.angle, this.sprite.scale.x *= this.scale.x, this.sprite.scale.y *= this.scale.y, this.sprite.anchor.x = this.anchor.x, this.sprite.anchor.y = this.anchor.y, this.sprite.autoCull = !0, this.parentGroup.add(this.sprite), this.sprite.data.inUse = !0) : 0 === --this.visibilityCounter && (this.kill(), this.sprite.data.inUse = !1, this.useTileSprite && this.sprite.doTile && t.Instances.callbackSubscriber.onLateUpdate.remove(this.sprite.tileUpdate, this.sprite)) }, enumerable: !0, configurable: !0 }), e.addSpriteToPool = function(t, i, o, n) { var s = t.add.sprite(0, 0, i, o); return s.data = { inUse: !1, proxy: null }, e.poolSpr[n].push(s), s.kill(), s }, e.addTileSpriteToPool = function(i, o, n, s, r) { var a = new t.TileController(i, n, s); return a.data = { inUse: !1, proxy: null }, e.poolTlSpr[r].push(a), a }, e.clearPool = function() { for (var t in e.poolSpr)
                if (e.poolSpr.hasOwnProperty(t)) { for (var i = 0, o = e.poolSpr[t]; i < o.length; i++)(r = o[i]).destroy(!0);
                    e.poolSpr[t].length = 0, delete e.poolSpr[t] } for (var t in e.poolTlSpr)
                if (e.poolTlSpr.hasOwnProperty(t)) { for (var n = 0, s = e.poolTlSpr[t]; n < s.length; n++) { var r = s[n];
                        r.destroy(!0) } e.poolTlSpr[t].length = 0, delete e.poolTlSpr[t] } }, e.prototype.kill = function() { this.sprite.alive = !1, this.sprite.exists = !1, this.sprite.visible = !1 }, e.prototype.revive = function() { this.sprite.alive = !0, this.sprite.exists = !0, this.sprite.visible = !0 }, e.prototype.setPoolTileSprite = function() { if (null === this.sprite || this.sprite.data.inUse)
                if (e.poolTlSpr.hasOwnProperty(this.assetTag)) { this.sprite = null; for (var i = 0, o = e.poolTlSpr[this.assetTag]; i < o.length; i++) { var n = o[i]; if (!n.data.inUse) { this.sprite = n; break } } null == this.sprite && (this.sprite = e.addTileSpriteToPool(this.game, this.tileObject, this.key, this.frame, this.assetTag)) } else { e.poolTlSpr[this.assetTag] = []; for (var s = 0; s < e.minPoolSize; s++) e.addTileSpriteToPool(this.game, this.tileObject, this.key, this.frame, this.assetTag);
                    this.sprite = e.poolTlSpr[this.assetTag][0] } this.sprite.applyObjectDefinition(this.tileObject), this.sprite.doTile && t.Instances.callbackSubscriber.onLateUpdate.add(this.sprite.tileUpdate, this.sprite) }, e.prototype.setPoolSprite = function() { if (e.poolSpr.hasOwnProperty(this.assetTag)) { this.sprite = null; for (var t = 0, i = e.poolSpr[this.assetTag]; t < i.length; t++) { var o = i[t]; if (!o.data.inUse) { this.sprite = o; break } } null == this.sprite && (this.sprite = e.addSpriteToPool(this.game, this.key, this.frame, this.assetTag)) } else { e.poolSpr[this.assetTag] = []; for (var n = 0; n < e.minPoolSize; n++) e.addSpriteToPool(this.game, this.key, this.frame, this.assetTag);
                this.sprite = e.poolSpr[this.assetTag][0] } }, e.prototype.resizeProxy = function() { this.width = Math.min(this.game.width, this.tileObject.width);
            this.sprite.width = this.width, this.sprite.recheckXTiling(!1), this.sprite.doTile ? t.Instances.callbackSubscriber.onLateUpdate.add(this.sprite.tileUpdate, this.sprite) : t.Instances.callbackSubscriber.onLateUpdate.remove(this.sprite.tileUpdate, this.sprite) }, e.poolSpr = {}, e.poolTlSpr = {}, e.minPoolSize = 1, e }();
    t.SpriteProxy = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e(e, i, o) { void 0 === o && (o = ""); var n = t.call(this, e, 0, 0, 1, 1, i, o) || this; return n.autoCull = !0, n.game = e, n.limits = { left: 0, right: 0, top: 0, bottom: 0 }, n.fixedX = !1, n.fixedY = !1, n.doTile = !1, n.doTileX = !1, n.doTileY = !1, n.currentObject = null, n } return __extends(e, t), e.prototype.applyObjectDefinition = function(t) { this.currentObject = t, this.limits.left = t.x, this.limits.right = t.x + t.width, this.limits.top = t.y - t.height, this.limits.bottom = t.y; for (var e = !0, i = !0, o = 0, n = t.properties; o < n.length; o++) { var s = n[o]; switch (s.name) {
                    case "tiled_x":
                        e = !1, t.width > this.game.width && (this.doTileX = s.value); break;
                    case "tiled_y":
                        i = !1, t.height > this.game.height && (this.doTileY = s.value) } } this.doTile = this.doTileX || this.doTileY, e && (this.texture.frame.width, t.width), i && (this.texture.frame.height, t.height) }, e.prototype.setDefinition = function(t, e, i, o, n, s) { void 0 === n && (n = !1), void 0 === s && (s = !1), this.limits.left = t, this.limits.right = e, this.limits.top = i, this.limits.bottom = o, this.doTileX = n, this.doTileY = s, this.doTile = this.doTileX || this.doTileY }, e.prototype.tileUpdate = function() { this.doTile && this.checkTiling() }, e.prototype.checkTiling = function(t) { void 0 === t && (t = !1), this.doTileX && (this.game.camera.x > this.limits.left && this.game.camera.x + this.game.camera.width < this.limits.right ? (this.tilePosition.x = this.limits.left - this.game.camera.x, this.x = this.game.camera.x, this.fixedX = !1) : this.fixedX || (this.fixedX = !0, this.game.camera.x <= this.limits.left && (this.tilePosition.x = 0, this.x = this.limits.left), this.game.camera.x + this.game.width >= this.limits.right && (this.tilePosition.x = this.limits.left - (this.limits.right - this.game.width), this.x = this.limits.right - this.width))), this.doTileY && (this.game.camera.y > this.limits.top && this.game.camera.y + this.game.height < this.limits.bottom ? (this.tilePosition.y = this.limits.top - this.game.camera.y, this.y = this.game.camera.y + this.height, this.fixedY = !1) : this.fixedY || (this.fixedY = !0, this.game.camera.y <= this.limits.top && (this.tilePosition.y = 0, this.y = this.limits.top + this.height), this.game.camera.y + this.game.height >= this.limits.bottom && (this.tilePosition.y = this.limits.top - (this.limits.bottom - this.game.height), this.y = this.limits.bottom))) }, e.prototype.recheckXTiling = function(t) { if (this.fixedX = !1, this.currentObject)
                for (var e = 0, i = this.currentObject.properties; e < i.length; e++) { var o = i[e]; "tiled_x" === o.name && (this.currentObject.width > this.game.width ? this.doTileX = !0 : this.doTileX = o.value) } this.doTile = this.doTileX || this.doTileY, this.checkTiling(t) }, e }(Phaser.TileSprite);
    t.TileController = e }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function t(t) { this.game = t, this.bg = this.game.add.tileSprite(0, 0, 1280, 720, "bg_transition"), this.animationUI = this.game.add.ph2UI("transition", "atlas_transition"), this.animationUI.visible = !1, this.bg.visible = !1, this.bg.anchor.set(.5, .5), this.isShowLoading = !1, Ph2.UISystem.findObject("transition/bg", this.animationUI).addChild(this.bg), this.game.stage.addChild(this.animationUI), this.animationUI.children[0].ph2Animations.getAnimations().transition2_out.onComplete.add(this.hideAll, this), this.game.scale.onSizeChange.add(this.resize, this); var e = this;
            window.addEventListener("resize", function(t) { return e.loadingResize() }), this.resize(), this.localization() } return t.prototype.localization = function() { Ph2.UISystem.findObject("transition/logo", this.animationUI).loadTexture("logo") }, t.prototype.playIn = function() { return this.animationUI.visible = !0, this.bg.visible = !0, this.game.ph2AudioManager.playEffect("transition_in", !1), this.showLoadingCircle(), Ph2.UISystem.playAnimationObject("transition", this.animationUI, "transition2_in", 1, !1).onComplete }, t.prototype.playOut = function() { return this.game.ph2AudioManager.playEffect("transition_out", !1), this.hideLoadingCircle(), Ph2.UISystem.playAnimationObject("transition", this.animationUI, "transition2_out", 1, !1).onComplete }, t.prototype.hideAll = function() { this.animationUI.visible = !1, this.bg.visible = !1, this.bg.stopScroll() }, t.prototype.showLoadingCircle = function() { this.isShowLoading = !0, document.getElementById("loader").style.display = "block", this.resize() }, t.prototype.hideLoadingCircle = function() { this.isShowLoading = !1, document.getElementById("loader").style.display = "none" }, t.prototype.resize = function() { if (this.bg.width = this.game.width, this.bg.height = this.game.height, this.isShowLoading) { var t = document.documentElement.clientHeight,
                    e = window.innerHeight,
                    i = t < e ? e : t,
                    o = parseInt(this.game.canvas.style.height, 10),
                    n = 1280 / 720 / (window.innerWidth / i);
                n > 1 && (n = 1); var s = i - o + 20 + "px";
                document.getElementById("loader").style.bottom = s, document.getElementById("loader").style.right = "50%" } }, t.prototype.loadingResize = function() { if (this.isShowLoading) { var t = document.documentElement.clientHeight,
                    e = window.innerHeight,
                    i = t < e ? e : t,
                    o = parseInt(this.game.canvas.style.height, 10),
                    n = 1280 / 720 / (window.innerWidth / i);
                n > 1 && (n = 1); var s = i - o + 20 + "px";
                document.getElementById("loader").style.bottom = s, document.getElementById("loader").style.right = "50%" } }, t }();
    t.Transition = e }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function e(e, i, o, n, s, r, a, h) { void 0 === a && (a = !1), void 0 === h && (h = null), this.game = e, this.player = i, this.spawnGroup = o, this.spawnPoints = null, this.spawnList = s, this.showInPortal = !1, this.isElevator = a, this.tileBg = h, this.scrolling = !1, this.scrollSpeed = .1, this.sceneCompleted = !1, this.shakeIntesity = .01, this.isElevator && (null === this.tileBg ? this.isElevator = !1 : this.scrollSpeed = this.tileBg.texture.frame.width / GameData.waveNewFloorTime * 2), this.playerIn = !1, this.useScreenBounds = !1, this.xLocked = !1, this.yLocked = !1, this.enterSignX = 0, this.enterSignY = 0, this.onStart = new Phaser.Signal, this.onFinish = new Phaser.Signal, this.onEnd = new Phaser.Signal; var l = new box2d.b2Filter;
            l.categoryBits = t.CollisionLayers.Items, l.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, this.x = r.x + .5 * r.width, this.y = r.y - .5 * r.height, this.componentManager = Ph2.ComponentPlugin.initComponents(this); var c = this.x,
                d = this.y,
                u = this.game.width,
                p = r.height;
            this.trigger = this.game.physics.box2d.createBody(c, d, 0), this.trigger.setRectangle(u, p), this.trigger.setBodyContactCallback(i, this.checkCollision, this), this.trigger.dynamic = !1, this.trigger.static = !0, this.trigger.sensor = !0, this.trigger.data.m_fixtureList.SetFilterData(l), this.trigger.data.m_userData = { isSlope: !1, isPlatform: !1, activeCount: 0 }, this.spawningTimer = this.componentManager.addComponent(t.ComponentTimer, GameData.waveStartDelay, !1, !0), this.spawningTimer.onComplete.add(this.spawnEnemy, this), this.spawnPoints = [new box2d.b2Vec2(this.x - GameData.sizeWaveWidth / 2, this.y), new box2d.b2Vec2(this.x + GameData.sizeWaveWidth / 2, this.y)], this.spawner = new t.ItemSelector(this.game, this.player, this.spawnPoints, this.spawnList, this.spawnGroup), this.spawner.onSetComplete.add(this.spawningTimer.stop, this.spawningTimer), this.spawnMargin = 50, this.originalBounds = new Phaser.Rectangle(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height), this.bounds = { x_A: -.5 * GameData.sizeWaveWidth, x_B: .5 * GameData.sizeWaveWidth, y_A: -.5 * this.game.height, y_B: .5 * this.game.height }, this.maxSimultaneousEnemies = GameData.waveMaxAlive, this.currentLiveEnemies = 0, this.patrolExtents = 100; var m = new box2d.b2Filter; if (m.categoryBits = t.CollisionLayers.Map, m.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, this.body = this.game.physics.box2d.createBody(this.x, this.y), this.body.setEdge(this.bounds.x_A, this.bounds.y_A, this.bounds.x_A, this.bounds.y_B).SetFilterData(m), this.body.addEdge(this.bounds.x_B, this.bounds.y_A, this.bounds.x_B, this.bounds.y_B).SetFilterData(m), this.body.static = !0, this.body.friction = 0, this.body.data.SetActive(!1), this.body.data.m_userData = { isSlope: !1, isPlatform: !1, activeCount: 0 }, t.Instances.callbackSubscriber.onUpdate.add(this.waveUpdate, this), this.arrowToLeft = !1, this.arrowType = t.ArrowDirection.right, r.properties)
                for (var f = 0, y = r.properties; f < y.length; f++) { var b = y[f]; if ("left" === b.name) this.arrowToLeft = b.value;
                    else if ("arrow" === b.name) switch (b.value) {
                        case "left":
                            this.arrowType = t.ArrowDirection.left; break;
                        case "right":
                            this.arrowType = t.ArrowDirection.right; break;
                        case "up":
                            this.arrowType = t.ArrowDirection.up; break;
                        case "down":
                            this.arrowType = t.ArrowDirection.down } } this.addPortals() } return e.prototype.addPortals = function() { this.portals = [], this.portals[0] = this.game.add.ph2AnimationObject(this.x - GameData.sizeWaveWidth / 2, this.y + GameData.sizeWaveHeight / 2 - 150, "portal", "atlas_animation2"), this.portals[1] = this.game.add.ph2AnimationObject(this.x + GameData.sizeWaveWidth / 2, this.y + GameData.sizeWaveHeight / 2 - 150, "portal", "atlas_animation2"), this.portals[0].visible = !1, this.portals[1].visible = !1, this.spawnGroup.addMultiple(this.portals) }, e.prototype.waveUpdate = function() { this.playerIn && (this.xLocked || Phaser.Math.sign(this.player.body.x - this.x) === this.enterSignX || (this.xLocked = !0, this.body.data.SetActive(!0)), this.xLocked && !this.yLocked && this.player.onGround && (this.yLocked = !0), this.xLocked && this.yLocked && (this.playerIn = !1, t.Instances.callbackSubscriber.onUpdate.remove(this.waveUpdate, this), this.isElevator && t.Instances.callbackSubscriber.onUpdate.add(this.bgUpdate, this), this.trigger.removeFromWorld(), this.beginSpawning())) }, e.prototype.bgUpdate = function() { this.scrolling && (this.tileBg.tilePositionOffsetY += this.scrollSpeed * this.game.time.elapsedMS) }, e.prototype.checkCollision = function(e, i, o, n, s, r) { if (s) { if (!this.playerIn) { var a = 0;
                    this.game.width > GameData.sizeWaveWidth && (a = (GameData.sizeWaveWidth - this.game.width) / 2); var h = this.x - GameData.sizeWaveWidth / 2 + a,
                        l = this.game.width > GameData.sizeWaveWidth ? this.game.width : GameData.sizeWaveWidth;
                    this.playerIn = !0, this.enterSignX = Phaser.Math.sign(this.player.body.x - this.x), this.enterSignY = Phaser.Math.sign(this.player.body.y - this.y), this.outDirection = -this.enterSignX, -1 === this.enterSignX ? t.Instances.cameraManager.setBoundRight(h + l) : t.Instances.cameraManager.setBoundLeft(h) } } else this.playerIn && (this.playerIn = !1, t.Instances.cameraManager.setBoundsToWorld()) }, e.prototype.beginSpawning = function() { if (!this.showInPortal) { this.showInPortal = !0, this.portals[0].visible = !0, this.portals[1].visible = !0; var e = this.portals[0].ph2Animations.play("portal_in", 1, !1);
                this.portals[1].ph2Animations.play("portal_in", 1, !1), e.onComplete.addOnce(this.endInPortal, this) } this.onStart.dispatch(this.x, this.y), this.isElevator && this.tileBg ? (this.scrolling = !0, t.Instances.cameraManager.shake(this.shakeIntesity, 200, Phaser.Camera.SHAKE_VERTICAL), this.game.time.events.add(GameData.waveNewFloorTime, this.stopScrollAndSpawn, this)) : this.spawningTimer.startTimer() }, e.prototype.endInPortal = function() { this.portals[0].ph2Animations.play("portal_anim", 1, !0), this.portals[1].ph2Animations.play("portal_anim", 1, !0) }, e.prototype.stopScrollAndSpawn = function() { this.scrolling = !1, this.tileBg.tilePositionOffsetY = 0, t.Instances.cameraManager.shake(this.shakeIntesity, 200, Phaser.Camera.SHAKE_VERTICAL), this.spawningTimer.startTimer() }, e.prototype.spawnEnemy = function() { this.currentLiveEnemies < this.maxSimultaneousEnemies && this.generateEnemy() }, e.prototype.generateEnemy = function() { this.spawningTimer.setTime(GameData.waveSpawnTime); var t = this.spawner.pickNextItem();
            t.setAggresive(!0, this.x), t.lifeManager.onNoLife.addOnce(this.checkEnemyStock, this), this.currentLiveEnemies++ }, e.prototype.mapRaycastFilter = function(e, i, o, n) { return i.m_filter.categoryBits === t.CollisionLayers.Map }, e.prototype.checkEnemyStock = function(t) { 0 === --this.currentLiveEnemies && this.spawner.isSetComplete() && (this.spawner.nextSet(), this.spawner.waveComplete() ? this.endWave() : (this.spawningTimer.setTime(GameData.waveSetDelay), this.beginSpawning())) }, e.prototype.endWave = function() { var e = this.portals[0].ph2Animations.play("portal_out", 1, !1);
            this.portals[1].ph2Animations.play("portal_out", 1, !1), e.onComplete.addOnce(this.endOutPortal, this), this.isElevator ? (this.player.ignoreGroundRestitusion = !0, this.player.disableComponents(), this.game.time.events.add(GameData.waveEndDelay, this.playerEnd, this)) : t.Instances.cameraManager.endWave(), this.onFinish.dispatch(this.arrowToLeft, this.arrowType), this.body.removeFromWorld() }, e.prototype.playerEnd = function() { var e = this;
            this.player.onGround ? (this.player.walkOut(this.outDirection), t.Instances.callbackSubscriber.onUpdate.add(this.enderUpdate, this)) : this.player.onGroundCollision.addOnce(function() { e.player.walkOut(e.outDirection), t.Instances.callbackSubscriber.onUpdate.add(e.enderUpdate, e) }, this) }, e.prototype.endOutPortal = function() { this.portals[0].visible = !1, this.portals[1].visible = !1 }, e.prototype.enderUpdate = function() { this.outDirection > 0 ? this.player.x > this.game.camera.x + this.game.width + 200 && this.endSection() : this.player.x < this.game.camera.x - 200 && this.endSection() }, e.prototype.endSection = function() { t.Instances.callbackSubscriber.onUpdate.remove(this.enderUpdate, this), this.onEnd.dispatch() }, e.prototype.set = function(t, e) { this.x = t, this.y = e }, e.prototype.disableGameElement = function() { this.componentManager.sendMessage("disable") }, e.prototype.enableGameElement = function() { this.componentManager.sendMessage("enable") }, e.prototype.destroy = function() { t.Instances.cameraManager.setBoundsToWorld(), this.componentManager.sendMessage("disable"), this.portals[0].ph2Animations.stop("portal_anim"), this.portals[1].ph2Animations.stop("portal_anim"), this.spawner.destroy(), this.spawner = null, this.portals = null, this.player = null, this.componentManager.removeAllComponents() }, e.prototype.setParameters = function(t) { this.spawningTimer.setTime(t.hitTimer) }, e }();
    t.WaveScene = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { void 0 === s && (s = null); var r = e.call(this, i, n.x + .5 * n.width, n.y - 182, null) || this;
            i.add.existing(r), i.physics.box2d.enable(r), r.body.setRectangle(70, 364), r.body.fixedRotation = !0, r.body.dynamic = !1, r.body.friction = 0, r.body.static = !0, t.Instances.visibilityManager.addObject(r, r.x - 45, r.y - 192, 90, 384); var a = new box2d.b2Filter; return a.categoryBits = t.CollisionLayers.Breakable, a.maskBits = t.CollisionLayers.All, r.body.data.m_fixtureList.SetFilterData(a), r.body.data.SetSleepingAllowed(!1), r.animation = r.game.add.ph2AnimationObject(0, 0, "door", "atlas_animations"), r.addChild(r.animation), r.respawnDelay = 500, r.onRespawn = new Phaser.Signal, r.totalLife = GameData.wallsLife, r.life = r.totalLife, r } return __extends(i, e), i.prototype.hitDamage = function(t) { void 0 === t && (t = 0), this.life -= t, this.life <= 0 ? (this.game.ph2AudioManager.playEffect("obstacle_wall", !1), this.body.removeFromWorld(), this.animation.ph2Animations.play("door_anim2")) : this.life / this.totalLife <= .5 && this.animation.ph2Animations.play("door_anim1") }, i.prototype.disableGameElement = function() { this.animation && (this.animation.visible = !1, this.visible = !1), this.body && this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.animation && (this.animation.visible = !0, this.visible = !0), this.body && this.body.data.SetActive(!0) }, i }(Phaser.Sprite);
    t.BreakWall = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { var r = e.call(this, i, n, s, null) || this;
            i.add.existing(r), i.physics.box2d.enable(r), r.body.setCircle(GameData.lifeenergyPackBodySize), r.body.fixedRotation = !0, r.body.dynamic = !1, r.body.sensor = !0, r.autoCull = !0; var a = new box2d.b2Filter; return a.categoryBits = t.CollisionLayers.Items, a.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, r.body.data.m_fixtureList.SetFilterData(a), r.body.setBodyContactCallback(o, r.restorePowerBar, r), r.animation = r.game.add.ph2AnimationObject(0, 0, "power", "atlas_animation2"), r.addChild(r.animation), r.animation.ph2Animations.play("life_loop"), r.animation.ph2Animations.getAnimations().life_out.onComplete.add(r.destroyEnergy, r), r.onPowerFull = new Phaser.Signal, r } return __extends(i, e), i.prototype.eatEnergy = function() { this.body.removeFromWorld(), this.animation.ph2Animations.play("life_out") }, i.prototype.destroyEnergy = function() { this.animation.ph2Animations.stop(), this.animation.destroy(!0), this.animation = null, this.destroy(!0) }, i.prototype.restorePowerBar = function(t, e, i, o, n, s) { n && (e.sprite.powerManager.isFull() ? this.onPowerFull.dispatch() : (e.sprite.restorePower(GameData.powerPackRestore), this.eatEnergy())) }, i.prototype.disableGameElement = function() { this.animation && (this.animation.ph2Animations.pause(), this.visible = !1), this.body && this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.animation && (this.animation.ph2Animations.resume(), this.visible = !0), this.body && this.body.data.SetActive(!0) }, i }(Phaser.Sprite);
    t.EnergyPack = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { var r = e.call(this, i, n, s, null) || this;
            i.add.existing(r), i.physics.box2d.enable(r), r.body.setCircle(GameData.lifeenergyPlusPackBodySize), r.body.fixedRotation = !0, r.body.dynamic = !1, r.body.sensor = !0, r.autoCull = !0; var a = new box2d.b2Filter; return a.categoryBits = t.CollisionLayers.Items, a.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, r.body.data.m_fixtureList.SetFilterData(a), r.body.setBodyContactCallback(o, r.increasePowerBar, r), r.animation = r.game.add.ph2AnimationObject(0, 0, "power_plus", "atlas_animation2"), r.addChild(r.animation), r.animation.ph2Animations.play("power_plus_loop"), r.animation.ph2Animations.getAnimations().life_plus_out.onComplete.add(r.destroyEnergyPlus, r), r } return __extends(i, e), i.prototype.eatEnergy = function() { this.body.removeFromWorld(), this.animation.ph2Animations.play("life_plus_out", 1, !1) }, i.prototype.destroyEnergyPlus = function() { this.animation.ph2Animations.stop(), this.animation.destroy(!0), this.animation = null, this.destroy(!0) }, i.prototype.increasePowerBar = function(e, i, o, n, s, r) { s && (i.sprite.restorePower(9999), t.Instances.currentLevelFounditem = t.ItemFoundType.power, this.eatEnergy()) }, i.prototype.restorePowerBar = function(t, e, i, o, n, s) { n && (e.sprite.restorePower(GameData.powerPackRestore), this.eatEnergy()) }, i.prototype.disableGameElement = function() { this.animation && (this.animation.ph2Animations.pause(), this.visible = !1), this.body && this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.animation && (this.animation.ph2Animations.resume(), this.visible = !0), this.body && this.body.data.SetActive(!0) }, i }(Phaser.Sprite);
    t.EnergyPackPlus = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { void 0 === s && (s = null); var r = e.call(this, i, n.x + .5 * n.width, n.y - .5 * n.height, "atlas_animations", "bomb.png") || this;
            r.origin = new Phaser.Point(r.x, r.y), r.scale.set(.8), r.anchor.set(.5), r.chain = r.game.add.tileSprite(r.x, r.y - 200, 10, 200, "ruler"), r.autoCull = !0, r.events.onAddedToGroup.add(function(t, e) { e.add(r.chain), r.bringToTop() }), r.onRespawn = new Phaser.Signal, i.add.existing(r), i.physics.box2d.enable(r), r.body.setCircle(.5 * r.width), r.body.fixedRotation = !0, r.body.kinematic = !0, r.body.sensor = !0, r.body.gravityScale = 0; var a = new box2d.b2Filter;
            a.categoryBits = t.CollisionLayers.Damage, a.maskBits = t.CollisionLayers.Player, r.body.data.m_fixtureList.SetFilterData(a), r.componentManager = Ph2.ComponentPlugin.initComponents(r), r.timerFall = r.componentManager.addComponent(t.ComponentTimer, 1e3, !0), r.timerFall.onComplete.add(r.fall, r), r.timerRestore = r.componentManager.addComponent(t.ComponentTimer, 1e3), r.timerRestore.onComplete.add(r.restorePosition, r), r.body.setBodyContactCallback(o, r.killPlayer, r), r.limitY = r.y; var h; return (h = r.game.physics.box2d.raycast(r.x, r.y + .5 * r.width, r.x, r.y + 1e3, !0, r.filter)).length > 0 ? h[0].point.y > r.limitY && (r.limitY = h[0].point.y) : r.limitY += 500, r.limitY -= .5 * r.width, r } return __extends(i, e), i.prototype.filter = function(e, i, o, n) { return i.m_filter.categoryBits === t.CollisionLayers.Map }, i.prototype.fall = function() { var e = this,
                i = this.game.add.tween(this.body).to({ y: this.origin.y + 5 }, 60, Phaser.Easing.Linear.None, !0, 0, 4, !0);
            i.onComplete.add(function() { e.body.kinematic = !1, e.body.dynamic = !0, e.body.gravityScale = 1, t.Instances.callbackSubscriber.onLateUpdate.add(e.checkHammerLimit, e) }), i.onUpdateCallback(this.updateChain, this) }, i.prototype.checkHammerLimit = function() { this.body.y > this.limitY && (this.body.gravityScale = 0, this.body.y = this.limitY, this.body.setZeroVelocity(), t.Instances.callbackSubscriber.onLateUpdate.remove(this.checkHammerLimit, this), this.body.kinematic = !0, this.timerRestore.startTimer()), this.updateChain() }, i.prototype.restorePosition = function() { var t = this.game.add.tween(this.body).to({ y: this.origin.y }, 4e3, Phaser.Easing.Linear.None, !0);
            t.onComplete.add(this.timerFall.start, this.timerFall), t.onComplete.add(this.updateChain, this), t.onUpdateCallback(this.updateChain, this) }, i.prototype.updateChain = function() { this.chain.height = this.body.y - this.origin.y + 200, this.chain.tilePosition.y = this.body.y - this.origin.y }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.killPlayer = function(t, e, i, o, n, s) { n && (s.SetEnabled(!1), e.sprite.hitDamage(GameData.spikesDamage, !0, e.x > t.x ? 1 : -1, -1)) }, i.prototype.respawnPlayer = function() { this.onRespawn.dispatch() }, i.prototype.disableGameElement = function() { this.visible = !1, this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.visible = !0, this.body.data.SetActive(!0) }, i }(Phaser.Sprite);
    t.Hammer = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { void 0 === s && (s = null); var r = e.call(this, i, n.x, n.y, null) || this;
            r.player = o, r.setProperty(n), r.x += .5 * n.width * Math.cos(Phaser.Math.degToRad(n.rotation)) + .5 * n.height * Math.sin(Phaser.Math.degToRad(n.rotation)), r.y += -.5 * n.height * Math.cos(Phaser.Math.degToRad(n.rotation)) + .5 * n.width * Math.sin(Phaser.Math.degToRad(n.rotation)), i.add.existing(r), t.Instances.visibilityManager.addObject(r, r.x - 195, r.y - 40, 390, 80), r.collisionEnabled = !0, r.timeCursor = 0; var a = n.height,
                h = n.width,
                l = 0,
                c = 0;
            s && (a = s.height, h = s.width, l = s.x + .5 * s.width - .5 * r.width, c = s.y + .5 * s.height - .5 * r.height), i.physics.box2d.enable(r), r.body.setRectangle(h, a, l, c), r.body.fixedRotation = !0, r.body.dynamic = !1, r.body.sensor = !0, r.body.angle = n.rotation; var d = new box2d.b2Filter; return d.categoryBits = t.CollisionLayers.Damage, d.maskBits = t.CollisionLayers.Player, r.body.data.m_fixtureList.SetFilterData(d), r.animation = r.game.add.ph2AnimationObject(0, 0, "elect", "atlas_animations"), r.addChild(r.animation), r.componentManager = Ph2.ComponentPlugin.initComponents(r), r.timerToggle = r.componentManager.addComponent(t.ComponentTimer, r.properties.timeChangeState[0], !0, !0), r.timerToggle.onComplete.add(r.toggleState, r), r.advanceTimer(), r.body.setBodyContactCallback(o, r.hitPlayer, r), r.body.data.SetActive(!1), r.player.onDeath.add(r.disableCollision, r), r.isOn && r.animation.ph2Animations.play("elect_in").onComplete.add(r.playLoopAndActivate, r), r.respawnDelay = 500, r.onRespawn = new Phaser.Signal, r } return __extends(i, e), i.prototype.playLoopAndActivate = function() { if (this.animation.ph2Animations.play("elect_loop"), this.collisionEnabled) { var e = this.body.data.m_fixtureList.GetAABB(0);
                this.player && this.player.body.data.m_fixtureList.m_filter.categoryBits !== t.CollisionLayers.Invulnerable && e.TestOverlap(this.player.body.data.m_fixtureList.GetAABB(0)) && this.hitPlayer(), this.body.data.SetActive(!0) } }, i.prototype.setProperty = function(t) { this.doRespawn = !1; var e = [GameData.steamWallTimeChangeState],
                i = GameData.steamWallStartActive,
                o = GameData.steamWallDamage; if (t.properties)
                for (var n = 0, s = t.properties; n < s.length; n++) { var r = s[n]; switch (r.name) {
                        case "call_respawn":
                            this.doRespawn = r.value; break;
                        case "timeChangeState":
                            e = r.value.split("|").map(Number); break;
                        case "startActive":
                            i = r.value; break;
                        case "damage":
                            o = r.value } } this.isOn = i, this.properties = { timeChangeState: e, startActive: i, damage: o } }, i.prototype.advanceTimer = function() { this.timerToggle.setTime(this.properties.timeChangeState[this.timeCursor]), ++this.timeCursor >= this.properties.timeChangeState.length && (this.timeCursor = 0) }, i.prototype.toggleState = function() { this.isOn = !this.isOn, this.advanceTimer(), this.visible && this.checkState() }, i.prototype.checkState = function() { if (this.isOn) { this.playSoundLaser(); var t = this.animation.ph2Animations.play("elect_in");
                0 === t.onComplete.getNumListeners() && t.onComplete.add(this.playLoopAndActivate, this) } else this.animation.ph2Animations.play("elect_out"), this.collisionEnabled && this.body.data.SetActive(!1) }, i.prototype.playSoundLaser = function() { var e = { key: "obstacle_laser_floor", x: this.x - 185, y: this.y - 30, width: 370, height: 60 };
            t.Audios.playSfxZone(this.game, e) }, i.prototype.disableCollision = function() { this.collisionEnabled = !1, this.body.removeFromWorld() }, i.prototype.tankDestroy = function() { this.body.removeFromWorld(), this.destroy() }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.hitPlayer = function(t, e, i, o, n, s) { void 0 === t && (t = this.body), void 0 === e && (e = this.player.body), void 0 === i && (i = this.body.data.m_fixtureList), void 0 === o && (o = this.player.body.data.m_fixtureList), void 0 === n && (n = !0), void 0 === s && (s = null), n && (this.doRespawn ? (e.sprite.hitDamage(this.properties.damage, !1), e.sprite.playKillAnim(), e.sprite.lifeManager.currentlifes > 0 && this.game.time.events.add(this.respawnDelay, this.respawnPlayer, this)) : e.sprite.hitDamage(this.properties.damage, !0, e.x > t.x ? 1 : -1, -1)) }, i.prototype.respawnPlayer = function() { this.onRespawn.dispatch() }, i.prototype.disableGameElement = function(t) { void 0 === t && (t = !1), this.visible = t, this.body.data.SetActive(!1), this.timerToggle.disable() }, i.prototype.enableGameElement = function() { this.visible = !0, this.body.data.SetActive(!0), this.timerToggle.enable(), this.checkState() }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null }, i }(Phaser.Sprite);
    t.LaserSurface = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { var r = e.call(this, i, n, s, null) || this;
            i.add.existing(r), i.physics.box2d.enable(r), r.body.setCircle(GameData.lifeenergyPackBodySize), r.body.fixedRotation = !0, r.body.dynamic = !1, r.body.sensor = !0, r.autoCull = !0; var a = new box2d.b2Filter; return a.categoryBits = t.CollisionLayers.Items, a.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, r.body.data.m_fixtureList.SetFilterData(a), r.body.setBodyContactCallback(o, r.restoreLife, r), r.animation = r.game.add.ph2AnimationObject(0, 0, "life", "atlas_animation2"), r.addChild(r.animation), r.animation.ph2Animations.play("life_loop"), r.animation.ph2Animations.getAnimations().life_out.onComplete.add(r.destroyLife, r), r.onLifeFull = new Phaser.Signal, r } return __extends(i, e), i.prototype.eatLife = function() { this.body.removeFromWorld(), this.animation.ph2Animations.play("life_out") }, i.prototype.destroyLife = function() { this.animation.ph2Animations.stop(), this.animation.destroy(!0), this.animation = null, this.destroy(!0) }, i.prototype.restoreLife = function(t, e, i, o, n, s) { n && (e.sprite.lifeManager.isFull() ? this.onLifeFull.dispatch() : (e.sprite.restoreLife(GameData.healthPackRestore), this.eatLife())) }, i.prototype.disableGameElement = function() { this.animation && (this.animation.ph2Animations.pause(), this.visible = !1), this.body && this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.animation && (this.animation.ph2Animations.resume(), this.visible = !0), this.body && this.body.data.SetActive(!0) }, i }(Phaser.Sprite);
    t.LifePack = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { var r = e.call(this, i, n, s, null) || this;
            i.add.existing(r), i.physics.box2d.enable(r), r.body.setCircle(GameData.lifeenergyPlusPackBodySize), r.body.fixedRotation = !0, r.body.dynamic = !1, r.body.sensor = !0, r.autoCull = !0; var a = new box2d.b2Filter; return a.categoryBits = t.CollisionLayers.Items, a.maskBits = t.CollisionLayers.Player, r.body.data.m_fixtureList.SetFilterData(a), r.body.setCategoryContactCallback(t.CollisionLayers.Player, r.increaseLifeBar, r), r.animation = r.game.add.ph2AnimationObject(0, 0, "life_plus", "atlas_animation2"), r.addChild(r.animation), r.animation.ph2Animations.play("life_plus_loop"), r.animation.ph2Animations.getAnimations().life_plus_out.onComplete.add(r.destroyLifePlus, r), r } return __extends(i, e), i.prototype.eatLifePlus = function() { this.body.removeFromWorld(), this.animation.ph2Animations.play("life_plus_out", 1, !1) }, i.prototype.destroyLifePlus = function() { this.animation.ph2Animations.stop(), this.animation.destroy(!0), this.animation = null, this.destroy(!0) }, i.prototype.increaseLifeBar = function(e, i, o, n, s, r) { s && (i.sprite.restoreLife(9999), t.Instances.currentLevelFounditem = t.ItemFoundType.health, this.eatLifePlus()) }, i.prototype.disableGameElement = function() { this.animation && (this.animation.ph2Animations.pause(), this.visible = !1), this.body && this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.animation && (this.animation.ph2Animations.resume(), this.visible = !0), this.body && this.body.data.SetActive(!0) }, i }(Phaser.Sprite);
    t.LifePackPlus = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(t, i, o, n, s) { void 0 === n && (n = 5), void 0 === s && (s = 5); var r = e.call(this, t, o.x + .5 * o.width, o.y - .5 * o.height, "atlas_animations", "bomb_1.png") || this; return r.setProperty(o), t.add.existing(r), r.autoCull = !0, r.hitForce = s * GameData.PixToMet, r.destroyed = !1, r.invIn = !1, r.player = i, r.initPhysic(), r.addAnimation(), r } return __extends(i, e), i.prototype.setProperty = function(t) { var e = GameData.mineDamage; if (t.properties)
                for (var i = 0, o = t.properties; i < o.length; i++) { var n = o[i]; switch (n.name) {
                        case "damage":
                            e = n.value } } this.properties = { damage: e } }, i.prototype.initPhysic = function() { this.game.physics.box2d.enable(this), this.body.fixedRotation = !0, this.body.dynamic = !1, this.body.sensor = !0; var e = new box2d.b2Filter;
            e.categoryBits = t.CollisionLayers.Breakable, e.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable | t.CollisionLayers.Bullets, this.body.data.m_fixtureList.SetFilterData(e), this.body.setBodyContactCallback(this.player, this.blowContact, this) }, i.prototype.hitDamage = function(t, e, i, o, n) { this.player.isInvulnerable() || !0 === n ? this.mineDestroy() : this.blowUp() }, i.prototype.addAnimation = function() { var t = ["bomb_1.png", "bomb_2.png"];
            this.animations.add("loop", t, 5, !0), this.animations.play("loop") }, i.prototype.mineDestroy = function() { var t = this;
            this.game.ph2AudioManager.playEffect("obstacle_mine", !1), this.explodeAnim = this.game.add.sprite(this.x, this.y, "atlas_animation2", "exp_all0.png"), this.body.removeFromWorld(), this.parent.addChild(this.explodeAnim), this.explodeAnim.anchor.set(.5, .5); var e = Phaser.Animation.generateFrameNames("exp_all", 0, 7, ".png");
            this.explodeAnim.animations.add("explode", e, 10, !1), this.explodeAnim.animations.play("explode").onComplete.addOnce(function() { t.destroyed = !0, t.explodeAnim.destroy(!0) }, this), this.visible = !1 }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.blowContact = function(e, i, o, n, s, r) { s ? n.m_filter.categoryBits === t.CollisionLayers.Invulnerable ? this.invIn || (this.invIn = !0, i.sprite.onRestoreVulnerability.addOnce(this.blowUp, this)) : this.blowUp() : this.invIn && (this.invIn = !1, i.sprite && i.sprite.onRestoreVulnerability.remove(this.blowUp, this)) }, i.prototype.blowUp = function() { this.player.hitDamage(this.properties.damage, !0, this.player.body.x > this.body.x ? 1 : -1, -1), this.mineDestroy() }, i.prototype.disableGameElement = function() { this.destroyed || (this.animations.paused = !0, this.visible = !1, this.body.data.SetActive(!1)) }, i.prototype.enableGameElement = function() { this.destroyed || (this.animations.paused = !1, this.visible = !0, this.body.data.SetActive(!0)) }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null }, i }(Phaser.Sprite);
    t.Mine = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { void 0 === s && (s = null); var r = e.call(this, i, n.x + .5 * n.width, n.y - n.height, "white_pixel") || this;
            r.setProperty(n), r.origin = new Phaser.Point(r.x, r.y), t.Instances.visibilityManager.addObject(r, r.x - 450, r.y, 900, 500), r.onRespawn = new Phaser.Signal, i.add.existing(r), i.physics.box2d.enable(r); var a = new box2d.b2Filter;
            a.categoryBits = t.CollisionLayers.Damage, a.maskBits = t.CollisionLayers.Player, r.componentManager = Ph2.ComponentPlugin.initComponents(r), r.limitY = r.y; var h;
            (h = r.game.physics.box2d.raycast(r.x, r.y + .5 * r.width, r.x, r.y + 1e3, !0, r.filter)).length > 0 ? h[0].point.y > r.limitY && (r.limitY = h[0].point.y) : r.limitY += 500; var l = r.game.add.sprite(7, 0, "atlas_animations", "bomb.png");
            l.anchor.set(.5), l.scale.set(.8); var c = r.game.add.tileSprite(0, 0, 22, r.limitY - r.y - .5 * l.width, "atlas_animations", "chain.png");
            c.anchor.set(.5, 0), r.limitY -= .5 * l.width, l.y = r.limitY - r.y, r.addChild(c), r.addChild(l), r.body.setCircle(.5 * l.width, 0, r.limitY - r.y), r.body.kinematic = !0, r.body.sensor = !0, r.body.data.SetSleepingAllowed(!1), r.body.data.m_fixtureList.SetFilterData(a), r.body.setBodyContactCallback(o, r.killPlayer, r); var d = r.properties.angle; return r.body.angle = -d, r.game.add.tween(r.body).to({ angle: d }, r.properties.time, Phaser.Easing.Quadratic.InOut, !0, 0, -1, !0), r } return __extends(i, e), i.prototype.setProperty = function(t) { var e = GameData.pendulumDamage,
                i = GameData.pendulumAngle,
                o = GameData.pendulumTime; if (t.properties)
                for (var n = 0, s = t.properties; n < s.length; n++) { var r = s[n]; switch (r.name) {
                        case "damage":
                            e = r.value; break;
                        case "angle":
                            i = r.value; break;
                        case "time":
                            o = r.value } } this.properties = { damage: e, angle: i, time: o } }, i.prototype.filter = function(e, i, o, n) { return i.m_filter.categoryBits === t.CollisionLayers.Map }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.killPlayer = function(t, e, i, o, n, s) { n && e.sprite.hitDamage(this.properties.damage, !0, e.x > t.x ? 1 : -1, -1) }, i.prototype.respawnPlayer = function() { this.onRespawn.dispatch() }, i.prototype.disableGameElement = function() { this.visible = !1, this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.visible = !0, this.body.data.SetActive(!0) }, i }(Phaser.Sprite);
    t.Pendulum = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { var r = e.call(this, i, n.x + .5 * n.width, n.y - .5 * n.height, "saw") || this;
            r.setProperty(n), r.respawnDelay = 500, r.onRespawn = new Phaser.Signal, r.lookDirection = new Phaser.Point(1, 0), r.scale.set(.6), r.anchor.set(.5), r.autoCull = !0, r.initPhysic(), r.body.setBodyContactCallback(o, r.killPlayer, r), r.componentManager = Ph2.ComponentPlugin.initComponents(r); var a;
            r.properties.useMask && (a = r.game.add.graphics(0, 0)).beginFill(16777215), s.add(r); var h = .5 * r.width; switch (r.properties.angle) {
                case 90:
                    r.initPositionVertical(n.y - n.height + h, n.y - h), r.moveComponent = r.componentManager.addComponent(t.MovementVertical, n.y - n.height + h, n.y - h, 0, r.properties.speed, 0), r.properties.useMask && a.drawRect(-.5 * r.width, -.5 * r.height, .5 * r.width, r.height); break;
                case 180:
                    r.initPositionHorizontal(n.x + h, n.x + n.width - h), r.moveComponent = r.componentManager.addComponent(t.MovementHorizontal, n.x + h, n.x + n.width - h, 0, r.properties.speed, 0), r.properties.useMask && a.drawRect(-.5 * r.width, 0, r.width, .5 * r.height); break;
                case 270:
                    r.initPositionVertical(n.y - n.height + h, n.y - h), r.moveComponent = r.componentManager.addComponent(t.MovementVertical, n.y - n.height + h, n.y - h, 0, r.properties.speed, 0), r.properties.useMask && a.drawRect(0, -.5 * r.height, .5 * r.width, r.height); break;
                default:
                    r.initPositionHorizontal(n.x + h, n.x + n.width - h), r.moveComponent = r.componentManager.addComponent(t.MovementHorizontal, n.x + h, n.x + n.width - h, 0, r.properties.speed, 0), r.properties.useMask && a.drawRect(-.5 * r.width, -.5 * r.height, r.width, .5 * r.height) } return r.properties.useMask && (a.endFill(), a.position = r.position, r.mask = a), r } return __extends(i, e), i.prototype.initPositionHorizontal = function(t, e) { this.properties.beginLower ? this.body.reset(t, this.body.y) : (this.body.reset(e, this.body.y), this.properties.speed *= -1) }, i.prototype.initPositionVertical = function(t, e) { this.properties.beginLower ? (this.body.reset(this.body.x, e), this.properties.speed *= -1) : this.body.reset(this.body.x, t) }, i.prototype.setProperty = function(t) { var e = GameData.sawAngle,
                i = GameData.sawSpeed,
                o = GameData.sawDamage,
                n = !1,
                s = !0; if (t.properties)
                for (var r = 0, a = t.properties; r < a.length; r++) { var h = a[r]; switch (h.name) {
                        case "angle":
                            e = 90 === h.value || 270 === h.value || 180 === h.value ? h.value : 0; break;
                        case "speed":
                            i = h.value; break;
                        case "damage":
                            o = h.value; break;
                        case "mask":
                            s = h.value; break;
                        case "startLower":
                            n = h.value } } this.properties = { angle: e, speed: i, damage: o, beginLower: n, useMask: s } }, i.prototype.initPhysic = function() { this.game.physics.box2d.enable(this), this.body.setCircle(.5 * this.width), this.body.kinematic = !0, this.body.sensor = !0, this.body.angularVelocity = 6; var e = new box2d.b2Filter;
            e.categoryBits = t.CollisionLayers.Damage, e.maskBits = t.CollisionLayers.Player, this.body.data.m_fixtureList.SetFilterData(e) }, i.prototype.tankDestroy = function() { this.body.removeFromWorld(), this.destroy(!0) }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.killPlayer = function(e, i, o, n, s, r) { s && n.m_filter.categoryBits === t.CollisionLayers.Player && i.sprite.hitDamage(this.properties.damage, !0, i.x > e.x ? 1 : -1, -1) }, i.prototype.respawnPlayer = function() { this.onRespawn.dispatch() }, i.prototype.disableGameElement = function() { this.body && (this.visible = !1, this.body.data.SetActive(!1)) }, i.prototype.enableGameElement = function() { this.body && (this.visible = !0, this.body.data.SetActive(!0)) }, i }(Phaser.Sprite);
    t.Saw = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r) { void 0 === r && (r = null); var a = e.call(this, i, s.x, s.y, "thorns") || this;
            a.setProperty(s), a.x += .5 * s.width * Math.cos(Phaser.Math.degToRad(s.rotation)) + .5 * s.height * Math.sin(Phaser.Math.degToRad(s.rotation)), a.y += -.5 * s.height * Math.cos(Phaser.Math.degToRad(s.rotation)) + .5 * s.width * Math.sin(Phaser.Math.degToRad(s.rotation)), a.anchor.set(.5), a.doRespawn = n, a.player = o, i.add.existing(a), a.autoCull = !0; var h = s.height,
                l = 120,
                c = 0,
                d = 0;
            r && (h = r.height, l = r.width, c = r.x + .5 * r.width - .5 * a.width, d = r.y + .5 * r.height - .5 * a.height), i.physics.box2d.enable(a), a.body.setRectangle(l, h, c, d), a.body.fixedRotation = !0, a.body.dynamic = !1, a.body.sensor = !0, a.body.angle = s.rotation; var u = new box2d.b2Filter; return u.categoryBits = t.CollisionLayers.Damage, u.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, a.body.data.m_fixtureList.SetFilterData(u), a.body.setBodyContactCallback(o, a.killPlayer, a), a.respawnDelay = 500, a.onRespawn = new Phaser.Signal, a.invIn = !1, a } return __extends(i, e), i.prototype.setProperty = function(t) { var e = GameData.spikesDamage; if (t.properties)
                for (var i = 0, o = t.properties; i < o.length; i++) { var n = o[i]; switch (n.name) {
                        case "damage":
                            e = n.value } } this.properties = { damage: e } }, i.prototype.tankDestroy = function() { this.body.removeFromWorld(), this.destroy() }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.killPlayer = function(e, i, o, n, s, r) { s ? n.m_filter.categoryBits === t.CollisionLayers.Invulnerable ? this.invIn || (this.invIn = !0, i.sprite.onRestoreVulnerability.add(this.damagePlayer, this)) : this.damagePlayer() : this.invIn && (this.invIn = !1, i.sprite && i.sprite.onRestoreVulnerability.remove(this.damagePlayer, this)) }, i.prototype.damagePlayer = function() { this.doRespawn ? (this.player.hitDamage(this.properties.damage, !1), this.player.playKillAnim(), this.player.lifeManager.currentlifes > 0 && this.game.time.events.add(this.respawnDelay, this.respawnPlayer, this)) : this.player.hitDamage(this.properties.damage, !0, this.player.body.x > this.body.x ? 1 : -1, -1) }, i.prototype.respawnPlayer = function() { this.onRespawn.dispatch() }, i.prototype.disableGameElement = function() { this.visible = !1, this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.visible = !0, this.body.data.SetActive(!0) }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null }, i }(Phaser.Sprite);
    t.Spikes = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e;! function(t) { t[t.Steam = 0] = "Steam", t[t.Fire = 1] = "Fire" }(e = t.StreamWallType || (t.StreamWallType = {})); var i = function(i) {
        function o(o, n, s, r) { var a = i.call(this, o, s.x + .5 * s.width, s.y - s.height, null) || this;
            a.setProperty(s), a.player = n, a.typeWall = r; var h, l; return a.typeWall === e.Steam ? (h = "steam_gp", l = 43, a.sfx = "obstacle_steam", a.animsKey = ["steam_in", "steam_loop", "steam_out"]) : (h = "fire_gp", l = 45, a.sfx = "obstacle_fire", a.animsKey = ["fire_anim_in", "fire_anim_loop", "fire_anim_out"]), a.stream = a.game.add.ph2AnimationObject(0, l, h, "atlas_animations"), a.stream.anchor.set(.5, 1), a.streamLength = 450, a.streamWidth = 40, t.Instances.visibilityManager.addObject(a, a.x - 65, a.y, 130, a.streamLength + 40), a.timeCursor = 0, a.isOn = a.properties.startActive, a.collisionEnabled = !0, a.onRespawn = new Phaser.Signal, a.initPhysic(), a.componentManager = Ph2.ComponentPlugin.initComponents(a), a.timerToggle = a.componentManager.addComponent(t.ComponentTimer, a.properties.timeChangeState[0], !0, !0), a.timerToggle.onComplete.add(a.toggleState, a), a.advanceTimer(), a.body.setBodyContactCallback(a.player, a.hitPlayer, a), a.player.onDeath.add(a.disableCollision, a), a.addChild(a.stream), a.checkState(), a } return __extends(o, i), o.prototype.setProperty = function(t) { var e = [GameData.steamWallTimeChangeState],
                i = GameData.steamWallStartActive,
                o = GameData.steamWallDamage; if (t.properties)
                for (var n = 0, s = t.properties; n < s.length; n++) { var r = s[n]; switch (r.name) {
                        case "timeChangeState":
                            "string" === r.type ? e = r.value.split("|").map(Number) : e[0] = r.value; break;
                        case "startActive":
                            i = r.value; break;
                        case "damage":
                            o = r.value } } this.properties = { timeChangeState: e, startActive: i, damage: o } }, o.prototype.initPhysic = function() { this.game.physics.box2d.enable(this), this.body.setRectangle(this.streamWidth, this.streamLength, 0, .5 * this.streamLength), this.body.fixedRotation = !0, this.body.dynamic = !1, this.body.static = !0, this.body.sensor = !0; var e = new box2d.b2Filter;
            e.categoryBits = t.CollisionLayers.Damage, e.maskBits = t.CollisionLayers.Player, this.body.data.m_fixtureList.SetFilterData(e), this.isOn || this.body.data.SetActive(!1) }, o.prototype.disableCollision = function() { this.collisionEnabled = !1, this.body.removeFromWorld() }, o.prototype.hitPlayer = function(t, e, i, o, n, s) { void 0 === t && (t = this.body), void 0 === e && (e = this.player.body), void 0 === i && (i = this.body.data.m_fixtureList), void 0 === o && (o = this.player.body.data.m_fixtureList), void 0 === n && (n = !0), void 0 === s && (s = null), n && e.sprite.hitDamage(this.properties.damage, !0, e.x > t.x ? 1 : -1, -1) }, o.prototype.disableGameElement = function() { this.kill(), this.stream.visible = !1, this.body.data.SetActive(!1) }, o.prototype.enableGameElement = function() { this.revive(), this.stream.visible = !0, this.checkState() }, o.prototype.toggleState = function() { this.isOn = !this.isOn, this.visible && this.checkState() }, o.prototype.checkState = function() { if (this.isOn) { if (this.collisionEnabled) { var e = this.body.data.m_fixtureList.GetAABB(0);
                    this.player && this.player.body.data.m_fixtureList.m_filter.categoryBits !== t.CollisionLayers.Invulnerable && e.TestOverlap(this.player.body.data.m_fixtureList.GetAABB(0)) && this.hitPlayer(), this.body.data.SetActive(!0) } this.playAnimationIn(), this.advanceTimer() } else this.collisionEnabled && this.body.data.SetActive(!1), this.playAnimationOut(), this.advanceTimer() }, o.prototype.advanceTimer = function() { this.timerToggle.setTime(this.properties.timeChangeState[this.timeCursor]), ++this.timeCursor >= this.properties.timeChangeState.length && (this.timeCursor = 0) }, o.prototype.playAnimationIn = function() { this.playInWall(), this.stream.ph2Animations.play(this.animsKey[0], 1, !1).onComplete.add(this.playAnimationLoop, this) }, o.prototype.playInWall = function() { var e = { key: this.sfx, x: this.x - 50, y: this.y, width: 100, height: this.streamLength + 30 };
            t.Audios.playSfxZone(this.game, e) }, o.prototype.playAnimationLoop = function() { this.stream.ph2Animations.play(this.animsKey[1], 1, !0) }, o.prototype.playAnimationOut = function() { this.stream.ph2Animations.play(this.animsKey[2], 1, !1).onComplete.add(this.onEndAnimationOut, this) }, o.prototype.onEndAnimationOut = function() {}, o.prototype.destroy = function(t) { i.prototype.destroy.call(this, t), this.player = null }, o }(Phaser.Sprite);
    t.StreamWall = i }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n) { var s = e.call(this, i, o, n, "Dummy") || this;
            i.add.existing(s), s.lookDirection = new Phaser.Point(1, 0), i.physics.box2d.enable(s), s.body.static = !0; var r = new box2d.b2Filter; return r.categoryBits = t.CollisionLayers.Enemies, r.maskBits = GameData.enemyCollisionMask, s.body.data.m_fixtureList.SetFilterData(r), s.componentManager = Ph2.ComponentPlugin.initComponents(s), s.onGround = !1, s.createFiniteStateMachine(), s.damageText = i.add.text(0, -100, "0", Constants.redTextStyle), s.damageText.visible = !1, s.textTween = null, s.addChild(s.damageText), s.stunTimer = s.componentManager.addComponent(t.ComponentTimer, 500), s.stunTimer.onComplete.add(s.restoreStunt, s), s } return __extends(i, e), i.prototype.createFiniteStateMachine = function() { var t;
            t = { init: "standing", transitions: [{ name: "stand", from: "jumping", to: "standing" }, { name: "stand", from: "walking", to: "standing" }, { name: "stand", from: "hitting", to: "standing" }, { name: "stand", from: "falling", to: "standing" }, { name: "stand", from: "flying", to: "standing" }, { name: "stand", from: "stunt", to: "standing" }, { name: "walk", from: "jumping", to: "walking" }, { name: "walk", from: "standing", to: "walking" }, { name: "walk", from: "hitting", to: "walking" }, { name: "walk", from: "falling", to: "walking" }, { name: "walk", from: "flying", to: "walking" }, { name: "fall", from: "standing", to: "falling" }, { name: "fall", from: "walking", to: "falling" }, { name: "jump", from: "standing", to: "jumping" }, { name: "jump", from: "walking", to: "jumping" }, { name: "jump", from: "jumping", to: "jumping" }, { name: "hit", from: "standing", to: "hitting" }, { name: "hit", from: "walking", to: "hitting" }, { name: "hit", from: "hitting", to: "hitting" }, { name: "stun", from: "walking", to: "stunt" }, { name: "stun", from: "jumping", to: "stunt" }, { name: "stun", from: "falling", to: "stunt" }, { name: "fly", from: "jumping", to: "flying" }, { name: "fly", from: "falling", to: "flying" }], methods: { onStand: function() {}, onWalk: function(t, e) {}, onEnterFalling: function() {}, onFall: function() {}, onLeaveFalling: function() {}, onJump: function(t, e) {}, onHit: function(t, e) {}, onStun: function(t) {}, onFly: function(t) {} } }, this.state = new StateMachine(t) }, i.prototype.hitDamage = function(t) { var e = this;
            void 0 === t && (t = 1), this.textTween && (this.textTween.stop(!1), this.damageText.y = -100), this.damageText.setText(t.toString(), !0), this.damageText.visible = !0, this.textTween = this.game.add.tween(this.damageText).to({ y: -200 }, 1e3, Phaser.Easing.Cubic.Out, !0), this.textTween.onComplete.add(function() { e.damageText.visible = !1, e.damageText.y = -100, e.textTween = null }) }, i.prototype.setDead = function() { this.kill() }, i.prototype.setAlive = function() { this.revive() }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.disableGameElement = function() { this.visible = !1, this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.visible = !0, this.body.data.SetActive(!0) }, i.prototype.destroyGameElement = function() { this.visible = !1, this.body.data.SetActive(!1) }, i.prototype.setAggresive = function() {}, i.prototype.setParameters = function(t) {}, i.prototype.setInvulnerable = function(e) { this.body.data.m_fixtureList.m_filter.categoryBits = e ? t.CollisionLayers.EnemyInvulnerable : t.CollisionLayers.Enemies }, i.prototype.restoreStunt = function() { this.setInvulnerable(!1) }, i.prototype.setSpeed = function(t) {}, i.prototype.restoreSpeed = function() {}, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null }, i }(Phaser.Sprite);
    t.DummyEnemy = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a) { var h = e.call(this, i, n, s, null) || this;
            i.add.existing(h), h.player = o, h.autoCull = !0, h.spineLocalScale = new Phaser.Point(-1, 1), h.isStun = !1, h.isChasing = !1, h.isAttacking = !1, h.isAggresive = !1, h.beginOnGround = !1, h.longSightSize = 500, h.longSightSizeSq = h.longSightSize * h.longSightSize, h.lookDirection = new Phaser.Point(1, 0), i.physics.box2d.enable(h), h.body.fixedRotation = !0, h.body.friction = 1, h.body.linearDamping = .5, h.parameters = EnemiesParameters.Enemy0, h.body.setRectangle(h.parameters.bodyWidth, h.parameters.bodyHeight); var l = new box2d.b2Filter;
            l.categoryBits = t.CollisionLayers.Enemies, l.maskBits = GameData.enemyCollisionMask, h.body.data.m_fixtureList.SetFilterData(l); var c = h.body.addCircle(.5 * h.parameters.bodyWidth + 2, 0, .5 * h.parameters.bodyHeight + 2); return h.body.setFixtureContactCallback(c, h.contactEntered, h), h.body.data.m_fixtureList.SetFilterData(l), h.groundContactPool = [null, null, null, null], h.componentManager = Ph2.ComponentPlugin.initComponents(h), h.waveZoneLimitComponent = null, h.chaseComponent = h.componentManager.addComponent(t.MoveToPointHorizontal, null, h.parameters.speed, !1, r, a), h.chaseComponent.setPoint(h.player.position, !0), h.chaseComponent.disable(), h.chaseComponent.onComplete.add(h.checkChasingReached, h), h.chaseComponent.onLimit.add(h.stopOnLimit, h), h.lifeManager = new t.LifeManager(h.parameters.healthPoints, h), h.lifeManager.onNoLife.add(h.setDead, h), h.onGround = !1, h.onWall = !1, h.lastWallContact = null, h.attackComponent = h.componentManager.addComponent(t.ComponentHit, t.CollisionLayers.Player, new Phaser.Rectangle(0, 0, h.parameters.hitWidth, h.parameters.hitHeight), 0, h.parameters.damage), h.attackComponent.onAfterHit.add(h.attackCallback, h), h.sightComponent = h.componentManager.addComponent(t.DistanceCollisionChecker, h.player, h.parameters.chaseDistance, !0), h.sightComponent.onCollide.add(h.beginChasing, h), h.sightComponent.disable(), h.lookComponent = h.componentManager.addComponent(t.BotLook, h.player, h.parameters.hitDistance), h.lookComponent.onLookEnter.add(h.beginAttack, h), h.lookComponent.disable(), h.stunTimer = h.componentManager.addComponent(t.ComponentTimer, GameData.invulnerabilityEnemyTimeSoft), h.stunTimer.onComplete.add(h.restoreStunt, h), h.hitCastingTimer = h.componentManager.addComponent(t.ComponentTimer, h.parameters.hitTimer), h.hitCastingTimer.onComplete.add(h.attack, h), h.setSpine(), h.createFiniteStateMachine(), h } return __extends(i, e), i.prototype.checkChasingReached = function() { this.lookDirection.x = this.player.x < this.x ? -1 : 1, this.spine.scale.x = this.spineLocalScale.x * this.lookDirection.x }, i.prototype.stopOnLimit = function() { this.body.setZeroVelocity(), this.state.can("stand") && this.state.stand() }, i.prototype.update = function() {!t.Instances.paused && this.spine.visible && (this.spine.update(), this.isChasing && (this.isAggresive || this.sightComponent.isTargetInRange() || (this.isChasing = !1, this.chaseComponent.disable(), this.stunTimer.setTime(GameData.invulnerabilityEnemyTimeHard), this.stunTimer.startTimer(), this.body.setZeroVelocity(), this.state.can("stand") && this.state.stand()))) }, i.prototype.setSpine = function() { this.spine = this.game.add.spine(0, 5, "enemy2"), this.spine.setSkinByName("normal"), this.spine.anchor.set(.5), this.addChild(this.spine), this.spine.scale.x = this.spineLocalScale.x, this.spine.scale.y = this.spineLocalScale.y, this.spineAnimationNames = { stand: "stand", walk: "walk", falling: "death", jump: "stand", doubleJump: "death", fly: "death", underAttack: "hit", stunned: "stun", recover: "recovery", attack: "attack", death: "death" }, this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0), this.spine.setToSetupPose() }, i.prototype.createFiniteStateMachine = function() { var t, e = this;
            t = { init: "standing", transitions: [{ name: "stand", from: "*", to: "standing" }, { name: "walk", from: "jumping", to: "walking" }, { name: "walk", from: "standing", to: "walking" }, { name: "walk", from: "hitting", to: "walking" }, { name: "walk", from: "falling", to: "walking" }, { name: "walk", from: "flying", to: "walking" }, { name: "fall", from: "standing", to: "falling" }, { name: "fall", from: "walking", to: "falling" }, { name: "jump", from: "*", to: "jumping" }, { name: "jump", from: "standing", to: "jumping" }, { name: "jump", from: "walking", to: "jumping" }, { name: "jump", from: "jumping", to: "jumping" }, { name: "hit", from: "standing", to: "hitting" }, { name: "hit", from: "walking", to: "hitting" }, { name: "hit", from: "hitting", to: "hitting" }, { name: "stun", from: "*", to: "stunt" }, { name: "fly", from: "jumping", to: "flying" }, { name: "fly", from: "falling", to: "flying" }], methods: { onStand: function() { e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0), e.spine.scale.x = e.spineLocalScale.x * e.lookDirection.x }, onWalk: function(t, i) { e.onGround && e.spine.getCurrentAnimationForTrack(0) !== e.spineAnimationNames.walk && e.spine.setAnimationByName(0, e.spineAnimationNames.walk, !0), e.spine.scale.x = e.spineLocalScale.x * e.lookDirection.x }, onEnterFalling: function() {}, onFall: function() {}, onLeaveFalling: function() {}, onJump: function(t, i) { e.body.velocity.y = i, e.onGround && (e.onGround = !1, e.spine.setAnimationByName(0, e.spineAnimationNames.jump)) }, onHit: function(t, i) { e.spine.setAnimationByName(0, e.spineAnimationNames.attack), e.spine.onComplete.addOnce(function() { e.onGround && e.state.can("stand") && e.state.stand() }, e) }, onStun: function(t, i, o, n) { e.setInvulnerable(!0), e.hitCastingTimer.isRunning() && e.hitCastingTimer.stop(), e.isChasing && e.chaseComponent.disable(), e.sightComponent.disable(), e.lookComponent.disable(), e.body.setZeroVelocity(), i ? (e.isStun = !0, e.spine.setAnimationByName(0, e.spineAnimationNames.stunned), e.stunTimer.setTime(GameData.invulnerabilityEnemyTimeHard), e.body.velocity.x = GameData.enemyStunImpulseX * o, e.body.velocity.y = GameData.enemyStunImpulseY * n) : (e.stunTimer.setTime(GameData.invulnerabilityEnemyTimeSoft), e.spine.setAnimationByName(0, e.spineAnimationNames.underAttack)), e.stunTimer.startTimer() }, onFly: function(t) { e.spine.setAnimationByName(0, e.spineAnimationNames.fly, !0) } } }, this.state = new StateMachine(t) }, i.prototype.beginChasing = function() { this.isChasing = !0, this.lookDirection.x = this.player.x < this.x ? -1 : 1, this.onGround ? this.isAggresive ? (this.chaseComponent.resetFollow(), this.chaseComponent.enable(), this.state.walk(), this.spine.visible = !0) : (this.chaseComponent.resetFollow(), this.chaseComponent.enable(), this.sightComponent.disable(), this.lookComponent.enable(), this.lookComponent.resumeLook(), this.lookComponent.isLookingTarget() || this.chaseComponent.isOnLimit() || this.state.walk()) : this.beginOnGround = !0 }, i.prototype.beginAttack = function(t) { this.chaseComponent.disable(), this.state.can("stand") && this.state.stand(), this.body.gravityScale = 0, this.body.setZeroVelocity(), this.hitCastingTimer.startTimer() }, i.prototype.attack = function() { var t = this.game.rnd.sign() > 0 ? "enemy_hit1_1" : "enemy_hit1_2";
            this.game.ph2AudioManager.playEffect(t, !1), this.attackComponent.hitCombo() }, i.prototype.attackCallback = function(t) { this.lookComponent.isLookingTarget() ? this.hitCastingTimer.startTimer() : 0 === GameData.rechaseTime ? this.restoreChase() : this.game.time.events.add(GameData.rechaseTime, this.restoreChase, this) }, i.prototype.hitDamage = function(e, i, o, n) { void 0 === e && (e = 1), void 0 === o && (o = 0), void 0 === n && (n = 0), this.lifeManager.removeLife(e), this.spine.onComplete.removeAll(), this.lifeManager.currentlifes > 0 && (t.Utilities.playRandomEnemyHitEffect(this.game), this.lifeManager.currentlifes <= GameData.damageSkinLife && this.spine.setSkinByName("break"), this.state.stun(i, o, n)) }, i.prototype.restoreStunt = function() { this.body.gravityScale = 1, this.isStun ? (this.spine.setAnimationByName(0, this.spineAnimationNames.recover), this.spine.onComplete.addOnce(this.restoreStunt_, this)) : this.restoreStunt_() }, i.prototype.restoreChase = function() { this.isStun || (this.lookDirection.x = this.player.x < this.x ? -1 : 1, this.state.stand(), this.isChasing ? (this.chaseComponent.resetFollow(), this.chaseComponent.enable(), this.lookComponent.enable(), this.lookComponent.resumeLook(), this.lookComponent.isLookingTarget() || this.state.walk()) : (this.chaseComponent.disable(), this.lookComponent.disable(), this.sightComponent.enable())) }, i.prototype.restoreStunt_ = function() { this.lookDirection.x = this.player.x < this.x ? -1 : 1, this.isStun = !1, this.state.stand(), this.isChasing ? (this.chaseComponent.resetFollow(), this.chaseComponent.enable(), this.lookComponent.enable(), this.lookComponent.resumeLook(), this.lookComponent.isLookingTarget() || this.state.walk()) : (this.chaseComponent.disable(), this.lookComponent.disable(), this.sightComponent.enable()), this.setInvulnerable(!1) }, i.prototype.setDead = function() { var e = this;
            t.Utilities.playRandomEnemyFinalHitEffect(this.game), this.isChasing = !1, this.componentManager.sendMessage("disable"), this.body.removeFromWorld(), this.spine.setAnimationByName(0, this.spineAnimationNames.death), this.spine.onComplete.add(function() { e.destroyGameElement() }) }, i.prototype.setAlive = function() { this.revive(), this.body.dynamic = !0, this.game.physics.box2d.addBody(this.body), this.body.dynamic = !0, this.lifeManager.addLife(this.lifeManager.maxlifes) }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.addMapCollision = function(t) {}, i.prototype.addPlatformCollision = function(t) {}, i.prototype.contactEntered = function(e, i, o, n, s, r) { if (0 != (n.m_filter.categoryBits & (t.CollisionLayers.Map | t.CollisionLayers.Breakable))) { var a = r.GetManifold().localNormal.y > GameData.GroundClearanceAngleCos;
                s ? a && this._GroundIn(r) : a && this._GroundOut(r) } }, i.prototype._GroundIn = function(t) { for (var e = 0; e < this.groundContactPool.length; e++)
                if (null === this.groundContactPool[e]) { this.groundContactPool[e] = t; break } this.onGround = !0, this.isStun ? this.body.setZeroVelocity() : (this.isChasing ? this.beginOnGround ? (this.beginOnGround = !1, this.beginChasing()) : this.lookComponent.enable() : this.sightComponent.enable(), this.isAggresive || (this.chaseComponent.isEnabled ? this.state.can("walk") && this.state.walk() : this.state.can("stand") && this.state.stand())) }, i.prototype._GroundOut = function(t) { this.onGround = !1; for (var e = 0; e < this.groundContactPool.length; e++) null !== this.groundContactPool[e] && (this.groundContactPool[e].IsTouching() ? (this.onGround = !0, this.lastGroundContact = this.groundContactPool[e]) : this.groundContactPool[e] = null);
            this.onGround || (this.body.gravityScale = 1, this.isChasing && this.lookComponent.disable()) }, i.prototype.disableGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.spine.visible = !1, this.spine.state.timeScale = 0 }, i.prototype.enableGameElement = function() { this.revive(), this.body.data.SetActive(!0), this.spine.visible = !0, this.spine.state.timeScale = 1 }, i.prototype.destroyGameElement = function() { this.visible = !1, this.body.data.SetActive(!1), this.componentManager.sendMessage("disable"), this.body.removeFromWorld(), this.componentManager.removeAllComponents(), this.destroy(!0) }, i.prototype.setAggresive = function(e, i, o) { void 0 === o && (o = GameData.sizeWaveWidth / 2), this.isAggresive || (this.setInvulnerable(!0), this.isAggresive = !0, this.beginChasing()), e && (this.waveZoneLimitComponent = this.componentManager.addComponent(t.WaveZoneLimit), this.waveZoneLimitComponent.setLimit(i - o, i + o)) }, i.prototype.inWaveZone = function() { this.setInvulnerable(!1), this.sightComponent.disable(), this.lookComponent.enable(), this.lookComponent.resumeLook() }, i.prototype.setParameters = function(e) { this.parameters = e, this.body.setRectangle(e.bodyWidth, e.bodyHeight); var i = this.body.addCircle(.5 * e.bodyWidth + 2, 0, .5 * e.bodyHeight + 2);
            this.body.setFixtureContactCallback(i, this.contactEntered, this), this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.m_filter.maskBits = GameData.enemyCollisionMask, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.GetNext().m_filter.maskBits = GameData.enemyCollisionMask, this.lifeManager.setMaxLifes(e.healthPoints), this.lifeManager.addLife(e.healthPoints), this.chaseComponent.setSpeed(e.speed), this.attackComponent.setDamage(e.damage), this.attackComponent.setHitRect(0, 0, this.parameters.hitWidth, this.parameters.hitHeight), this.sightComponent.setDistance(e.chaseDistance), this.lookComponent.setDistance(e.hitDistance), this.hitCastingTimer.setTime(e.hitTimer) }, i.prototype.setInvulnerable = function(e) { e ? (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable) : (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.Enemies) }, i.prototype.setSpeed = function(t) { this.chaseComponent.setSpeed(t) }, i.prototype.restoreSpeed = function() { this.chaseComponent.setSpeed(this.parameters.speed) }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null, this.spine = null, this.groundContactPool = null }, i }(Phaser.Sprite);
    t.EnemyMeleeA = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a) { var h = e.call(this, i, n, s, null) || this;
            i.add.existing(h), h.player = o, h.autoCull = !0, h.normalAux = new box2d.b2Vec2, h.spineLocalScale = new Phaser.Point(-1, 1), h.isChasing = !1, h.isAttacking = !1, h.isAggresive = !1, h.isStun = !1, h.isWave = !1, h.isInDash = !1, h.lookDirection = new Phaser.Point(1, 0), i.physics.box2d.enable(h), h.body.fixedRotation = !0, h.body.friction = 1, h.body.linearDamping = .5, h.parameters = EnemiesParameters.Enemy1, h.body.setRectangle(h.parameters.bodyWidth, h.parameters.bodyHeight); var l = new box2d.b2Filter;
            l.categoryBits = t.CollisionLayers.Enemies, l.maskBits = GameData.enemyCollisionMask, h.body.data.m_fixtureList.SetFilterData(l); var c = h.body.addCircle(.5 * h.parameters.bodyWidth + 2, 0, .5 * h.parameters.bodyHeight + 2); return h.body.setFixtureContactCallback(c, h.contactEntered, h), h.body.data.m_fixtureList.SetFilterData(l), h.groundContactPool = [null, null, null, null], h.componentManager = Ph2.ComponentPlugin.initComponents(h), h.waveZoneLimitComponent = null, h.chaseComponent = h.componentManager.addComponent(t.MoveToPointHorizontal, null, h.parameters.speed, !1, r, a), h.chaseComponent.disable(), h.chaseComponent.onComplete.add(h.checkChasingReached, h), h.chaseComponent.onLimit.add(h.stopOnLimit, h), h.lifeManager = new t.LifeManager(h.parameters.healthPoints, h), h.lifeManager.onNoLife.add(h.setDead, h), h.onGround = !0, h.onWall = !1, h.lastWallContact = null, h.attackComponent = h.componentManager.addComponent(t.ComponentHit, t.CollisionLayers.Player, new Phaser.Rectangle(0, 0, h.parameters.hitWidth, h.parameters.hitHeight), 0, h.parameters.damage), h.attackComponent.onAfterHit.add(h.attackCallback, h), h.sightComponent = h.componentManager.addComponent(t.DistanceCollisionChecker, h.player, h.parameters.chaseDistance, !0), h.sightComponent.onCollide.add(h.beginChasing, h), h.sightComponent.disable(), h.lookComponent = h.componentManager.addComponent(t.BotLook, h.player, h.parameters.hitDistance), h.lookComponent.onLookEnter.add(h.beginAttack, h), h.lookComponent.disable(), h.stunTimer = h.componentManager.addComponent(t.ComponentTimer, GameData.invulnerabilityEnemyTimeSoft), h.stunTimer.onComplete.add(h.restoreStunt, h), h.hitCastingTimer = h.componentManager.addComponent(t.ComponentTimer, h.parameters.hitTimer), h.hitCastingTimer.onComplete.add(h.attack, h), h.dashComponent = h.componentManager.addComponent(t.ComponentDashAttack, t.CollisionLayers.Player, new Phaser.Rectangle(0, 30, h.parameters.bodyWidth, h.parameters.bodyHeight - 30), GameData.enemyMeleeBDashDamage, GameData.enemyMeleeBDashDistance, GameData.enemyMeleeBDashSpeed, GameData.enemyMeleeBRestTime), h.dashComponent.onAfterDash.add(h.restAfterDash, h), h.dashComponent.onAfterCooldown.add(h.continueChasing, h), h.setSpine(), h.createFiniteStateMachine(), h } return __extends(i, e), i.prototype.stopOnLimit = function() { this.body.setZeroVelocity(), this.state.can("stand") && this.state.stand() }, i.prototype.restAfterDash = function() { this.setInvulnerable(!1), this.body.setZeroVelocity(), this.spine.setAnimationByName(0, "berserker_attack_out"), this.spine.onComplete.addOnce(this.dashOut, this) }, i.prototype.dashOut = function() { this.setInvulnerable(!1), this.isInDash = !1, this.state.can("stand") && this.state.stand() }, i.prototype.update = function() {!t.Instances.paused && this.spine.visible && (this.spine.update(), this.dashComponent.isDashing || this.isChasing && this.player.onGround && !this.dashComponent.isDashing && (this.isAggresive || this.sightComponent.isTargetInRange() || (this.spine.onComplete.removeAll(), this.isChasing = !1, this.chaseComponent.disable(), this.lookComponent.disable(), this.stunTimer.setTime(GameData.invulnerabilityEnemyTimeHard), this.stunTimer.startTimer(), this.body.setZeroVelocity(), !this.isStun && this.state.can("stand") && this.state.stand()))) }, i.prototype.setSpine = function() { this.spine = this.game.add.spine(0, 20, "enemy1"), this.addChild(this.spine), this.spine.scale.x = this.spineLocalScale.x, this.spine.scale.y = this.spineLocalScale.y, this.spine.anchor.set(.5, .5), this.spineAnimationNames = { stand: "stand", walk: "walk", falling: "death", jump: "stand", doubleJump: "death", fly: "death", underAttack: "hit", stunned: "stun", recover: "recovery", attacks: ["attack", "berserker_attack_in", "berserker_attack"], death: "death" }, this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0) }, i.prototype.createFiniteStateMachine = function() { var t, e = this;
            t = { init: "standing", transitions: [{ name: "stand", from: "*", to: "standing" }, { name: "walk", from: "jumping", to: "walking" }, { name: "walk", from: "standing", to: "walking" }, { name: "walk", from: "hitting", to: "walking" }, { name: "walk", from: "falling", to: "walking" }, { name: "walk", from: "flying", to: "walking" }, { name: "walk", from: "stunt", to: "walking" }, { name: "fall", from: "standing", to: "falling" }, { name: "fall", from: "walking", to: "falling" }, { name: "jump", from: "*", to: "jumping" }, { name: "jump", from: "standing", to: "jumping" }, { name: "jump", from: "walking", to: "jumping" }, { name: "jump", from: "jumping", to: "jumping" }, { name: "hit", from: "standing", to: "hitting" }, { name: "hit", from: "walking", to: "hitting" }, { name: "hit", from: "hitting", to: "hitting" }, { name: "stun", from: "*", to: "stunt" }, { name: "fly", from: "jumping", to: "flying" }, { name: "fly", from: "falling", to: "flying" }], methods: { onStand: function() { e.spine.scale.x = e.spineLocalScale.x * e.lookDirection.x, e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0) }, onWalk: function(t, i) { e.isAggresive && (e.lookDirection.x = e.player.x < e.x ? -1 : 1, e.spine.scale.x = e.spineLocalScale.x * e.lookDirection.x, e.chaseComponent.setPoint(e.player.position, !0)), e.spine.onComplete.removeAll(), e.spine.scale.x = e.spineLocalScale.x * e.lookDirection.x, e.onGround && e.spine.getCurrentAnimationForTrack(0) !== e.spineAnimationNames.walk && e.spine.setAnimationByName(0, e.spineAnimationNames.walk, !0) }, onEnterFalling: function() {}, onFall: function() {}, onLeaveFalling: function() {}, onJump: function(t, i) { e.body.velocity.y = i, e.onGround && (e.onGround = !1, e.spine.setAnimationByName(0, e.spineAnimationNames.jump)) }, onHit: function(t, i) { 2 === i ? e.spine.setAnimationByName(0, e.spineAnimationNames.attacks[i], !0) : (e.spine.setAnimationByName(0, e.spineAnimationNames.attacks[i]), e.spine.onComplete.addOnce(function() { e.onGround && e.state.can("stand") && e.state.stand() }, e)) }, onStun: function(t, i, o, n) { e.setInvulnerable(!0), e.hitCastingTimer.isRunning() && e.hitCastingTimer.stop(), e.isChasing && e.chaseComponent.disable(), e.isAggresive && (e.dashComponent.onAfterCooldown.remove(e.continueChasing, e), e.lookComponent.disable()), e.body.gravityScale = 1, e.sightComponent.disable(), e.body.setZeroVelocity(), i ? (e.isStun = !0, e.spine.setAnimationByName(0, e.spineAnimationNames.stunned), e.stunTimer.setTime(GameData.invulnerabilityEnemyTimeHard), e.body.velocity.x = GameData.enemyStunImpulseX * o, e.body.velocity.y = GameData.enemyStunImpulseY * n) : (e.stunTimer.setTime(GameData.invulnerabilityEnemyTimeSoft), e.spine.setAnimationByName(0, e.spineAnimationNames.underAttack), e.spine.onComplete.addOnce(function(t) { e.state.stand() }, e)), e.stunTimer.startTimer() }, onFly: function(t) { e.spine.setAnimationByName(0, e.spineAnimationNames.fly, !0) } } }, this.state = new StateMachine(t) }, i.prototype.checkChasingReached = function() { this.lookDirection.x = this.player.x < this.x ? -1 : 1, this.spine.scale.x = this.spineLocalScale.x * this.lookDirection.x }, i.prototype.beginAttack = function(t) { this.isStun || (this.lookDirection.x = this.player.x < this.x ? -1 : 1, this.chaseComponent.disable(), this.lookComponent.disable(), this.body.setZeroVelocity(), this.hitCastingTimer.startTimer(), this.state.can("stand") && this.state.stand()) }, i.prototype.beginChasing = function() { var t = this;
            this.chaseComponent.setPoint(null), this.lookDirection.x = this.player.x < this.x ? -1 : 1, this.spine.scale.x = this.spineLocalScale.x * this.lookDirection.x, this.isChasing = !0, this.sightComponent.disable(), this.spine.setAnimationByName(0, this.spineAnimationNames.attacks[1]), this.isInDash = !0, this.spine.onComplete.addOnce(function() { t.isInDash = !1; for (var e = !1, i = t.body.data.m_contactList; null !== i;) { if (i.contact.GetManifold().localNormal.x === t.lookDirection.x) { e = !0; break } i = i.next } t.setInvulnerable(!0), e ? t.restAfterDash() : (t.game.ph2AudioManager.playEffect("enemy_hit3", !1), t.dashComponent.attack(), t.state.hit(2)) }, this) }, i.prototype.continueChasing = function() { this.isChasing && (this.lookDirection.x = this.player.x < this.x ? -1 : 1, this.spine.scale.x = this.spineLocalScale.x * this.lookDirection.x, this.chaseComponent.setPoint(this.player.position, !0), this.chaseComponent.enable(), this.lookComponent.enable(), this.lookComponent.resumeLook(), this.lookComponent.isLookingTarget() || this.state.can("walk") && this.state.walk()) }, i.prototype.attack = function() { var t = this.game.rnd.sign() > 0 ? "enemy_hit1_1" : "enemy_hit1_2";
            this.game.ph2AudioManager.playEffect(t, !1), this.attackComponent.hitCombo() }, i.prototype.attackCallback = function(t) { this.lookComponent.isLookingTarget() ? this.hitCastingTimer.startTimer() : 0 === GameData.rechaseTime ? this.restoreChase() : this.game.time.events.add(GameData.rechaseTime, this.restoreChase, this) }, i.prototype.hitDamage = function(e, i, o, n) { void 0 === e && (e = 1), void 0 === o && (o = 0), void 0 === n && (n = 0), this.lifeManager.removeLife(e), this.lifeManager.currentlifes > 0 && (t.Utilities.playRandomEnemyHitEffect(this.game), this.isInDash && !this.isAggresive && (this.isInDash = !1, this.continueChasing()), this.spine.onComplete.removeAll(), this.spine.onComplete.removeAll(), this.state.stun(i, o, n)) }, i.prototype.restoreStunt = function() { this.body.gravityScale = 1, this.isStun ? (this.spine.setAnimationByName(0, this.spineAnimationNames.recover), this.spine.onComplete.addOnce(this.restoreStunt_, this)) : this.restoreStunt_() }, i.prototype.restoreChase = function() { this.isStun || (this.state.stand(), this.isChasing ? (this.lookComponent.isLookingTarget() || (this.chaseComponent.resetFollow(), this.chaseComponent.enable(), this.state.can("walk") && this.state.walk()), this.lookComponent.enable(), this.lookComponent.resumeLook()) : (this.chaseComponent.disable(), this.lookComponent.disable(), this.sightComponent.enable())) }, i.prototype.restoreStunt_ = function() { this.body.gravityScale = 1, this.setInvulnerable(!1), this.isStun && (this.state.stand(), this.isStun = !1), this.isChasing ? (this.lookComponent.isLookingTarget() || (this.chaseComponent.resetFollow(), this.chaseComponent.enable(), this.state.can("walk") && this.state.walk()), this.lookComponent.enable(), this.lookComponent.resumeLook()) : (this.setInvulnerable(!1), this.chaseComponent.disable(), this.lookComponent.disable(), this.sightComponent.enable()) }, i.prototype.setDead = function() { var e = this;
            t.Utilities.playRandomEnemyFinalHitEffect(this.game), this.spine.onComplete.removeAll(), this.isChasing = !1, this.componentManager.sendMessage("disable"), this.body.removeFromWorld(), this.spine.setAnimationByName(0, this.spineAnimationNames.death), this.spine.onComplete.add(function() { e.destroyGameElement() }) }, i.prototype.setAlive = function() { this.revive(), this.body.dynamic = !0, this.game.physics.box2d.addBody(this.body), this.body.dynamic = !0, this.lifeManager.addLife(this.lifeManager.maxlifes) }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.addMapCollision = function(t) {}, i.prototype.addPlatformCollision = function(t) {}, i.prototype.contactEntered = function(e, i, o, n, s, r) { if (0 != (n.m_filter.categoryBits & (t.CollisionLayers.Map | t.CollisionLayers.Breakable))) { var a = r.GetManifold().localNormal.y > GameData.GroundClearanceAngleCos;
                s ? a ? (this._GroundIn(r), this.isStun && this.body.setZeroVelocity()) : this.isStun ? this.body.setZeroVelocity() : this.isChasing && (this.setInvulnerable(!1), this.dashComponent.interruptDash(), this.spine.setAnimationByName(0, this.spineAnimationNames.underAttack), this.stunTimer.setTime(GameData.invulnerabilityEnemyTimeSoft), this.stunTimer.startTimer()) : a && this._GroundOut(r) } }, i.prototype._GroundIn = function(t) { for (var e = 0; e < this.groundContactPool.length; e++)
                if (null === this.groundContactPool[e]) { this.groundContactPool[e] = t; break } this.onGround = !0, this.isStun || this.isChasing || (this.isWave ? (this.chaseComponent.enable(), this.chaseComponent.setPoint(this.player.position, !0), this.restoreSpeed(), this.state.can("walk") && this.state.walk()) : this.sightComponent.enable()) }, i.prototype._GroundOut = function(t) { this.onGround = !1; for (var e = 0; e < this.groundContactPool.length; e++) null !== this.groundContactPool[e] && (this.groundContactPool[e].IsTouching() ? (this.onGround = !0, this.lastGroundContact = this.groundContactPool[e]) : this.groundContactPool[e] = null);
            this.onGround || (this.body.gravityScale = 1, this.isChasing || this.sightComponent.disable()) }, i.prototype.disableGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.spine.visible = !1, this.spine.state.timeScale = 0 }, i.prototype.enableGameElement = function() { this.revive(), this.body.data.SetActive(!0), this.spine.visible = !0, this.spine.state.timeScale = 1 }, i.prototype.destroyGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.componentManager.sendMessage("disable"), this.body.removeFromWorld(), this.componentManager.removeAllComponents(), this.destroy(!0) }, i.prototype.setAggresive = function(e, i, o) { void 0 === o && (o = GameData.sizeWaveWidth / 2), this.isAggresive || (this.isAggresive = !0), e && (this.checkChasingReached(), this.isWave = !0, this.waveZoneLimitComponent = this.componentManager.addComponent(t.WaveZoneLimit), this.waveZoneLimitComponent.setLimit(i - o, i + o)) }, i.prototype.inWaveZone = function() { this.beginChasing() }, i.prototype.setParameters = function(e) { this.parameters = e, this.body.setRectangle(e.bodyWidth, e.bodyHeight); var i = this.body.addCircle(.5 * e.bodyWidth + 2, 0, .5 * e.bodyHeight + 2);
            this.body.setFixtureContactCallback(i, this.contactEntered, this), this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.m_filter.maskBits = GameData.enemyCollisionMask, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.GetNext().m_filter.maskBits = GameData.enemyCollisionMask, this.lifeManager.setMaxLifes(e.healthPoints), this.lifeManager.addLife(e.healthPoints), this.chaseComponent.setSpeed(e.speed), this.attackComponent.setDamage(e.damage), this.attackComponent.setHitRect(0, 0, this.parameters.hitWidth, this.parameters.hitHeight), this.sightComponent.setDistance(e.chaseDistance), this.lookComponent.setDistance(e.hitDistance), this.hitCastingTimer.setTime(e.hitTimer), this.dashComponent.setHitRect(0, 0, e.bodyWidth, e.bodyWidth), this.dashComponent.setDamage(GameData.enemyMeleeBDashDamage), this.dashComponent.setDistance(GameData.enemyMeleeBDashDistance), this.dashComponent.setSpeed(GameData.enemyMeleeBDashSpeed), this.dashComponent.setCooldown(GameData.enemyMeleeBRestTime) }, i.prototype.setInvulnerable = function(e) { e ? (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable) : (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.Enemies) }, i.prototype.setSpeed = function(t) { this.chaseComponent.setSpeed(t) }, i.prototype.restoreSpeed = function() { this.chaseComponent.setSpeed(this.parameters.speed) }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null, this.spine = null, this.groundContactPool = null }, i }(Phaser.Sprite);
    t.EnemyMeleeB = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a) { var h = e.call(this, i, n, s, null) || this;
            i.add.existing(h), h.autoCull = !0, h.player = o, h.normalAux = new box2d.b2Vec2, h.spineLocalScale = new Phaser.Point(-1, 1), h.isStun = !1, h.isChasing = !1, h.isAttacking = !1, h.isPositioning = !1, h.isAggresive = !1, h.longSightSize = 500, h.longSightSizeSq = h.longSightSize * h.longSightSize, h.lookDirection = new Phaser.Point(1, 0), h.attackDistance = 400, h.onGroundCollision = new Phaser.Signal, i.physics.box2d.enable(h), h.body.fixedRotation = !0, h.body.friction = 1, h.body.linearDamping = .5, h.parameters = EnemiesParameters.Enemy2; var l = new box2d.b2Filter;
            l.categoryBits = t.CollisionLayers.Enemies, l.maskBits = GameData.enemyCollisionMask; var c = h.body.setCircle(.5 * h.parameters.bodyWidth); return h.body.setFixtureContactCallback(c, h.contactEntered, h), h.body.data.m_fixtureList.SetFilterData(l), h.groundContactPool = [null, null, null, null], h.componentManager = Ph2.ComponentPlugin.initComponents(h), h.chaseComponent = h.componentManager.addComponent(t.MoveToPointHorizontal, null, h.parameters.speed, !1, r, a), h.chaseComponent.disable(), h.lifeManager = new t.LifeManager(h.parameters.healthPoints, h), h.lifeManager.onNoLife.add(h.setDead, h), h.onGround = !0, h.onWall = !1, h.lastWallContact = null, h.sightComponent = h.componentManager.addComponent(t.DistanceCollisionChecker, h.player, h.parameters.chaseDistance, !0), h.sightComponent.onCollide.add(h.continueChasing, h), h.lookComponent = h.componentManager.addComponent(t.BotLook, h.player, h.parameters.hitDistance), h.lookComponent.onLookEnter.add(h.beginAttack, h), h.lookComponent.disable(), h.stunTimer = h.componentManager.addComponent(t.ComponentTimer, GameData.invulnerabilityEnemyTimeSoft), h.stunTimer.onComplete.add(h.restoreStunt, h), h.hitCastingTimer = h.componentManager.addComponent(t.ComponentTimer, h.parameters.hitTimer), h.hitCastingTimer.onComplete.add(h.attack, h), h.deltaComponent = h.componentManager.addComponent(t.ComponentDeltaAttack, t.CollisionLayers.Player, h.parameters.bodyWidth, h.parameters.damage), h.setSpine(), h.createFiniteStateMachine(), h } return __extends(i, e), i.prototype.update = function() {!t.Instances.paused && this.visible && (!this.isAggresive && this.isChasing && this.onGround && this.player.onGround && !this.sightComponent.isTargetInRange() && (this.onGroundCollision.removeAll(), this.isChasing = !1, this.isPositioning = !1, this.isAttacking = !1, this.chaseComponent.disable(), this.lookComponent.disable(), this.stunTimer.setTime(GameData.invulnerabilityEnemyTimeHard), this.stunTimer.startTimer(), this.body.setZeroVelocity(), this.sightComponent.enable(), this.hitCastingTimer.stop(), this.state.can("stand") && this.state.stand()), (this.isAttacking || this.isPositioning) && (this.bodySaw.angle += Phaser.Math.degToRad(20 * this.game.time.elapsedMS) * this.lookDirection.x)) }, i.prototype.setSpine = function() { this.bodySaw = this.game.add.sprite(0, 0, "atlas_animation2", "elite_followers.png"), this.bodySaw.scale.set(.8), this.bodySaw.anchor.set(.5), this.addChild(this.bodySaw), this.explosionAnim = this.game.add.sprite(0, 0, "atlas_animations", "exp1.png"), this.explosionAnim.animations.add("exp", Phaser.Animation.generateFrameNames("exp", 1, 7, ".png"), 14, !1), this.explosionAnim.anchor.set(.5), this.addChild(this.explosionAnim), this.explosionAnim.visible = !1 }, i.prototype.createFiniteStateMachine = function() { var t, e = this;
            t = { init: "standing", transitions: [{ name: "stand", from: "jumping", to: "standing" }, { name: "stand", from: "walking", to: "standing" }, { name: "stand", from: "hitting", to: "standing" }, { name: "stand", from: "falling", to: "standing" }, { name: "stand", from: "flying", to: "standing" }, { name: "stand", from: "stunt", to: "standing" }, { name: "walk", from: "jumping", to: "walking" }, { name: "walk", from: "standing", to: "walking" }, { name: "walk", from: "hitting", to: "walking" }, { name: "walk", from: "falling", to: "walking" }, { name: "walk", from: "flying", to: "walking" }, { name: "fall", from: "standing", to: "falling" }, { name: "fall", from: "walking", to: "falling" }, { name: "jump", from: "*", to: "jumping" }, { name: "jump", from: "standing", to: "jumping" }, { name: "jump", from: "walking", to: "jumping" }, { name: "jump", from: "jumping", to: "jumping" }, { name: "hit", from: "standing", to: "hitting" }, { name: "hit", from: "walking", to: "hitting" }, { name: "hit", from: "hitting", to: "hitting" }, { name: "stun", from: "*", to: "stunt" }, { name: "fly", from: "jumping", to: "flying" }, { name: "fly", from: "falling", to: "flying" }], methods: { onStand: function() {}, onWalk: function(t, e) {}, onEnterFalling: function() {}, onFall: function() {}, onLeaveFalling: function() {}, onJump: function(t, i) { e.body.velocity.y = i, e.onGround && (e.onGround = !1) }, onHit: function(t, e) {}, onStun: function(t, i, o, n) { e.chaseComponent.disable(), e.lookComponent.disable(), e.chaseComponent.onComplete.removeAll(), e.hitCastingTimer.stop(), e.body.setZeroVelocity(), e.setInvulnerable(!0), e.isAttacking = !1, e.isPositioning = !1, i ? (e.isStun = !0, e.stunTimer.setTime(GameData.invulnerabilityEnemyTimeHard), e.body.velocity.x = GameData.enemyStunImpulseX * o, e.body.velocity.y = GameData.enemyStunImpulseY * n) : e.stunTimer.setTime(GameData.invulnerabilityEnemyTimeSoft), e.stunTimer.startTimer() } } }, this.state = new StateMachine(t) }, i.prototype.beginChasing = function() { this.lookDirection.x = this.player.x < this.x ? -1 : 1, this.isChasing = !0, this.onGround && (this.isAttacking = !0, this.sightComponent.disable(), this.deltaComponent.jump()) }, i.prototype.endJump = function() { this.isAttacking = !1, this.deltaComponent.endJump(), this.continueChasing() }, i.prototype.continueChasing = function() { this.onGround ? (this.sightComponent.disable(), this.isChasing = !0, this.isAttacking = !1, this.isPositioning = !0, this.body.setZeroVelocity(), this.lookDirection.x = this.x > this.player.x ? -1 : 1, this.lookComponent.isLookingTarget() ? this.state.can("stand") && this.state.stand() : (this.chaseComponent.setPoint(this.player.position), this.chaseComponent.enable()), this.lookComponent.resumeLook(), this.lookComponent.enable()) : this.onGroundCollision.addOnce(this.continueChasing, this) }, i.prototype.beginAttack = function() { this.chaseComponent.disable(), this.lookComponent.disable(), this.body.x < this.player.body.x ? this.chaseComponent.setPoint(new Phaser.Point(this.player.body.x - this.attackDistance, 0)) : this.chaseComponent.setPoint(new Phaser.Point(this.player.body.x + this.attackDistance, 0)), this.chaseComponent.onComplete.addOnce(this.prepareToAttack, this), this.chaseComponent.enable() }, i.prototype.prepareToAttack = function() { this.isPositioning = !1, this.lookDirection.x = this.x > this.player.x ? -1 : 1, this.state.can("stand") && this.state.stand(), this.chaseComponent.disable(), this.hitCastingTimer.startTimer(), this.body.setZeroVelocity() }, i.prototype.attack = function() { this.isAttacking = !0, this.lookDirection.x = this.player.x > this.x ? 1 : -1, this.deltaComponent.jump(), this.onGroundCollision.addOnce(this.continueChasing, this) }, i.prototype.restoreStunt = function() { this.body.gravityScale = 1, this.chaseComponent.onComplete.removeAll(), this.isStun, this.restoreStunt_() }, i.prototype.restoreStunt_ = function() { this.body.gravityScale = 1, this.chaseComponent.onComplete.removeAll(), this.setInvulnerable(!1), this.isStun = !1, this.isChasing ? (this.isAttacking = !1, this.isPositioning = !1, this.chaseComponent.disable(), this.lookComponent.disable(), this.continueChasing()) : (this.isAttacking = !1, this.isPositioning = !1, this.chaseComponent.disable(), this.lookComponent.disable(), this.sightComponent.enable()) }, i.prototype.hitDamage = function(e, i, o, n) { void 0 === e && (e = 1), void 0 === o && (o = 0), void 0 === n && (n = 0), this.lifeManager.removeLife(e), this.lifeManager.currentlifes > 0 && (t.Utilities.playRandomEnemyHitEffect(this.game), this.state.stun(i, o, n)) }, i.prototype.setDead = function() { var e = this;
            t.Utilities.playRandomEnemyFinalHitEffect(this.game), this.isChasing = !1, this.componentManager.sendMessage("disable"), this.body.removeFromWorld(), this.hitCastingTimer.stop(), this.explosionAnim.visible = !0, this.bodySaw.visible = !1, this.explosionAnim.animations.play("exp").onComplete.addOnce(function() { e.destroyGameElement() }, this) }, i.prototype.setAlive = function() { this.revive(), this.body.dynamic = !0, this.game.physics.box2d.addBody(this.body), this.body.dynamic = !0, this.lifeManager.addLife(this.lifeManager.maxlifes) }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.addMapCollision = function(t) {}, i.prototype.addPlatformCollision = function(t) {}, i.prototype.contactEntered = function(e, i, o, n, s, r) { if (0 != (n.m_filter.categoryBits & (t.CollisionLayers.Map | t.CollisionLayers.Breakable))) { var a = r.GetManifold().localNormal.y > GameData.GroundClearanceAngleCos;
                s ? a ? this.onGround || (this._GroundIn(r), this.onGroundCollision.dispatch(), this.deltaComponent.endJump(), this.isStun && this.body.setZeroVelocity()) : this.isChasing && (this.isPositioning ? (this.body.setZeroVelocity(), this.chaseComponent.onComplete.removeAll(), this.chaseComponent.disable(), this.lookComponent.disable(), this.prepareToAttack()) : this.isAttacking && (this.onGroundCollision.removeAll(), this.hitCastingTimer.stop(), this.deltaComponent.endJump(), this.body.setZeroVelocity(), this.body.gravityScale = 1, this.isAttacking = !1, this.onGroundCollision.addOnce(this.continueChasing, this))) : a && (this._GroundOut(r), this.onGround || this.isChasing && this.isPositioning && (this.chaseComponent.disable(), this.chaseComponent.onComplete.removeAll(), this.isPositioning = !1, this.onGroundCollision.addOnce(this.continueChasing, this))) } }, i.prototype._GroundIn = function(t) { for (var e = 0; e < this.groundContactPool.length; e++)
                if (null === this.groundContactPool[e]) { this.groundContactPool[e] = t; break } this.onGround = !0 }, i.prototype._GroundOut = function(t) { this.onGround = !1; for (var e = 0; e < this.groundContactPool.length; e++) null !== this.groundContactPool[e] && (this.groundContactPool[e].IsTouching() ? (this.onGround = !0, this.lastGroundContact = this.groundContactPool[e]) : this.groundContactPool[e] = null);
            this.onGround || (this.body.gravityScale = 1) }, i.prototype.disableGameElement = function() { this.kill(), this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.revive(), this.body.data.SetActive(!0) }, i.prototype.distanceSquare = function(t) { var e = t.body.x - this.body.x,
                i = t.body.y - this.body.y; return e * e + i * i }, i.prototype.destroyGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.componentManager.sendMessage("disable"), this.body.removeFromWorld(), this.componentManager.removeAllComponents(), this.destroy(!0) }, i.prototype.setSpineDirection = function() {}, i.prototype.setAggresive = function() { this.isAggresive || (this.isAggresive = !0, this.sightComponent.enable(), this.continueChasing()) }, i.prototype.setParameters = function(e) { this.parameters = e; var i = this.body.setCircle(.5 * this.parameters.bodyWidth);
            this.body.setFixtureContactCallback(i, this.contactEntered, this), this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.m_filter.maskBits = GameData.enemyCollisionMask, this.lifeManager.setMaxLifes(e.healthPoints), this.lifeManager.addLife(e.healthPoints), this.chaseComponent.setSpeed(e.speed), this.deltaComponent.setDamage(e.damage), this.deltaComponent.setHitSize(e.bodyWidth), this.sightComponent.setDistance(e.chaseDistance), this.lookComponent.setDistance(e.hitDistance), this.hitCastingTimer.setTime(e.hitTimer) }, i.prototype.setInvulnerable = function(e) { this.body.data.m_fixtureList.m_filter.categoryBits = e ? t.CollisionLayers.EnemyInvulnerable : t.CollisionLayers.Enemies }, i.prototype.setSpeed = function(t) { this.chaseComponent.setSpeed(t) }, i.prototype.restoreSpeed = function() { this.chaseComponent.setSpeed(this.parameters.speed) }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null, this.groundContactPool = null }, i }(Phaser.Sprite);
    t.EnemyMeleeC = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { var r = e.call(this, i, n, s, "atlas_animations", "laser_1.png") || this;
            i.add.existing(r), r.autoCull = !0, r.player = o, r.lookDirection = new Phaser.Point(1, 0), r.shootOffset = new Phaser.Point(0, 0), r.isAttacking = !1, r.parameters = EnemiesParameters.Enemy3, i.physics.box2d.enable(r), r.body.setRectangle(r.parameters.bodyWidth, r.parameters.bodyHeight), r.body.static = !0; var a = new box2d.b2Filter; return a.categoryBits = t.CollisionLayers.Enemies, a.maskBits = t.CollisionLayers.Damage | t.CollisionLayers.Bullets, r.body.data.m_fixtureList.SetFilterData(a), r.componentManager = Ph2.ComponentPlugin.initComponents(r), r.lifeManager = new t.LifeManager(r.parameters.healthPoints, r), r.lifeManager.onNoLife.add(r.setDead, r), r.shootCastingTimer = r.componentManager.addComponent(t.ComponentTimer, r.parameters.hitTimer), r.shootCastingTimer.onComplete.add(r.shoot, r), r.setTrigger(), r._damage = r.parameters.damage, r.createFiniteStateMachine(), r.otherSprite = i.add.sprite(1, 0, "atlas_animations", "laser_2.png"), r.otherSprite.anchor.set(.505, .5), r.otherSprite.visible = !1, r.addChild(r.otherSprite), r } return __extends(i, e), i.prototype.createFiniteStateMachine = function() { var t;
            t = { init: "standing", transitions: [{ name: "stand", from: "jumping", to: "standing" }, { name: "stand", from: "walking", to: "standing" }, { name: "stand", from: "hitting", to: "standing" }, { name: "stand", from: "falling", to: "standing" }, { name: "stand", from: "flying", to: "standing" }, { name: "stand", from: "stunt", to: "standing" }, { name: "walk", from: "jumping", to: "walking" }, { name: "walk", from: "standing", to: "walking" }, { name: "walk", from: "hitting", to: "walking" }, { name: "walk", from: "falling", to: "walking" }, { name: "walk", from: "flying", to: "walking" }, { name: "fall", from: "standing", to: "falling" }, { name: "fall", from: "walking", to: "falling" }, { name: "jump", from: "standing", to: "jumping" }, { name: "jump", from: "walking", to: "jumping" }, { name: "jump", from: "jumping", to: "jumping" }, { name: "hit", from: "standing", to: "hitting" }, { name: "hit", from: "walking", to: "hitting" }, { name: "hit", from: "hitting", to: "hitting" }, { name: "stun", from: "*", to: "stunt" }, { name: "fly", from: "jumping", to: "flying" }, { name: "fly", from: "falling", to: "flying" }], methods: { onStand: function() {}, onWalk: function(t, e) {}, onEnterFalling: function() {}, onFall: function() {}, onLeaveFalling: function() {}, onJump: function(t, e) {}, onHit: function(t, e) {}, onStun: function(t) {}, onFly: function(t) {} } }, this.state = new StateMachine(t) }, i.prototype.beginAttack = function() { this.isAttacking = !0, this.lookDirection.x = this.player.x < this.x ? -1 : 1, this.otherSprite.visible = !0, this.otherSprite.scale.x = this.lookDirection.x, this.shootCastingTimer.isRunning() || this.shoot() }, i.prototype.shoot = function() { if (this.player && this.isAttacking) { this.game.ph2AudioManager.playEffect("obstacle_laser_wall1", !1), this.setLookDiscrete();
                new t.BulletLaser(this.game, this.body.x, this.body.y, this.parent, this.lookDirection, GameData.LaserSpeedTurret, t.CollisionLayers.Player, this._damage, GameData.LaserMaxBounces, this.player.body);
                this.shootCastingTimer.startTimer() } }, i.prototype.hitDamage = function(e) { void 0 === e && (e = 1), this.lifeManager.removeLife(e), this.lifeManager.currentlifes > 0 && t.Utilities.playRandomEnemyHitEffect(this.game) }, i.prototype.setDead = function() { var e = this;
            t.Utilities.playRandomEnemyFinalHitEffect(this.game), this.body.removeFromWorld(), this.triggerSprite.body.removeFromWorld(), this.isAttacking = !1, this.shootCastingTimer.stop(), this.shootCastingTimer.remove(), this.explodeAnim = this.game.add.sprite(this.x, this.y, "atlas_animation2", "exp_all0.png"), this.parent.addChild(this.explodeAnim), this.explodeAnim.anchor.set(.5, .5), this.explodeAnim.scale.set(.6, .6); var i = Phaser.Animation.generateFrameNames("exp_all", 0, 7, ".png");
            this.explodeAnim.animations.add("explode", i, 10, !1), this.explodeAnim.animations.play("explode").onComplete.addOnce(function() { e.destroyGameElement() }, this), this.visible = !1 }, i.prototype.setAlive = function() {}, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.hitStunt = function(t, e) {}, i.prototype.disableGameElement = function() { this.kill(), this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.revive(), this.body.data.SetActive(!0) }, i.prototype.destroyGameElement = function() { this.destroy(!0), this.triggerSprite.destroy(!0), this.explodeAnim.destroy(!0), this.componentManager.destroy() }, i.prototype.setLookAbsolute = function() { this.lookDirection.set(this.player.x - this.x, this.player.y - this.y), this.lookDirection.normalize() }, i.prototype.setLookDiscrete = function() { this.player.x > this.x ? (this.otherSprite.scale.x = 1, this.lookDirection.set(GameData.sqrt2inv, GameData.sqrt2inv)) : (this.otherSprite.scale.x = -1, this.lookDirection.set(-GameData.sqrt2inv, GameData.sqrt2inv)) }, i.prototype.setAggresive = function() {}, i.prototype.setParameters = function(e) { this.parameters = e, this.body.setRectangle(e.bodyWidth, e.bodyHeight), this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.m_filter.maskBits = GameData.enemyCollisionMask, this.lifeManager.setMaxLifes(e.healthPoints), this.lifeManager.addLife(e.healthPoints), this._damage = e.damage, this.shootCastingTimer.setTime(e.hitTimer) }, i.prototype.setInvulnerable = function(t) {}, i.prototype.setSpeed = function(t) {}, i.prototype.restoreSpeed = function() {}, i.prototype.getFloorPoint = function() { var t, e = this.y; return (t = this.game.physics.box2d.raycast(this.x, this.y, this.x, this.y + 1e3, !0, this.filter)).length > 0 ? t[0].point.y > e && (e = t[0].point.y) : e += 500, e }, i.prototype.filter = function(e, i, o, n) { return i.m_filter.categoryBits === t.CollisionLayers.Map }, i.prototype.triggerEnter = function(t, e, i, o, n, s) { n ? this.isAttacking || this.beginAttack() : this.isAttacking && (this.isAttacking = !1, this.otherSprite.visible = !1) }, i.prototype.setTrigger = function() { var e = this.getFloorPoint() - this.y,
                i = 2 * this.parameters.hitDistance;
            this.triggerSprite = this.game.add.sprite(this.x, this.y + .5 * e), this.game.physics.box2d.enable(this.triggerSprite), this.triggerSprite.body.setRectangle(i, e), this.triggerSprite.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Items, this.triggerSprite.body.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, this.triggerSprite.body.static = !0, this.triggerSprite.body.sensor = !0, this.triggerSprite.body.setBodyContactCallback(this.player, this.triggerEnter, this) }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null }, i }(Phaser.Sprite);
    t.EnemyRangeA = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a) { var h = e.call(this, i, n, s, null) || this;
            i.add.existing(h), h.autoCull = !0, h.player = o, h.isStun = !1, h.isChasing = !1, h.waitingShoot = !1, h.isAggresive = !1, h.lookDirection = new Phaser.Point(1, 0), h.shootOffset = new Phaser.Point(100, -20), h.spineLocalScale = new Phaser.Point(-1, 1), i.physics.box2d.enable(h), h.body.fixedRotation = !0, h.body.friction = 1, h.body.linearDamping = .5, h.parameters = EnemiesParameters.Enemy4, h.body.setRectangle(h.parameters.bodyWidth, h.parameters.bodyHeight); var l = new box2d.b2Filter;
            l.categoryBits = t.CollisionLayers.Enemies, l.maskBits = GameData.enemyCollisionMask, h.body.data.m_fixtureList.SetFilterData(l); var c = h.body.addCircle(.5 * h.parameters.bodyWidth + 2, 0, .5 * h.parameters.bodyHeight + 2); return h.body.setFixtureContactCallback(c, h.contactEntered, h), h.body.data.m_fixtureList.SetFilterData(l), h.groundContactPool = [null, null, null, null], h.componentManager = Ph2.ComponentPlugin.initComponents(h), h.waveZoneLimitComponent = null, h.moveComponent = 0 === r && 0 === a ? h.componentManager.addComponent(t.BotMovementHorizontal, h.game.width - 600, h.game.width - 400, 0, h.parameters.speed, h.parameters.idleTime) : h.componentManager.addComponent(t.BotMovementHorizontal, r, a, 0, h.parameters.speed, h.parameters.idleTime), h.lifeManager = new t.LifeManager(h.parameters.healthPoints, h), h.lifeManager.onNoLife.add(h.setDead, h), h.onGround = !1, h.onWall = !1, h.lastWallContact = null, h.attackTrigger = h.componentManager.addComponent(t.DistanceCollisionChecker, h.player, h.parameters.chaseDistance, !0), h.attackTrigger.onCollide.add(h.beginAttack, h), h.runTrigger = h.componentManager.addComponent(t.DistanceCollisionChecker, h.player, GameData.enemyRangeBScapeDistance, !0), h.runTrigger.onCollide.add(h.takeDistance, h), h.runTrigger.disable(), h.stunTimer = h.componentManager.addComponent(t.ComponentTimer, h.parameters.stuntTime), h.stunTimer.onComplete.add(h.restoreStunt, h), h.shootCastingTimer = h.componentManager.addComponent(t.ComponentTimer, h.parameters.hitTimer), h.shootCastingTimer.onComplete.add(h.shoot, h), h.bulletLifeTime = GameData.LaserMaxDistance / (GameData.LaserSpeed / GameData.PixToMet), h._damage = h.parameters.damage, h.isAggresive = !1, h.setSpine(), h.createFiniteStateMachine(), h } return __extends(i, e), i.prototype.update = function() {!t.Instances.paused && this.spine.visible && this.spine.update() }, i.prototype.setSpine = function() { this.spine = this.game.add.spine(0, 10, "enemy2"), this.spine.setSkinByName("normal"), this.spine.anchor.set(.5), this.addChild(this.spine), this.spine.scale.x = this.spineLocalScale.x, this.spine.scale.y = this.spineLocalScale.y, this.spineAnimationNames = { stand: "laser_robot_stand", walk: "laser_robot_walk", falling: "laser_robot_death", underAttack: "laser_robot_hit", stunned: "laser_robot_stun", recover: "laser_robot_recovery", attack: "laser_robot_shoot", death: "laser_robot_death" }, this.spine.onEvent.add(this.generateBullet, this), this.spine.setAnimationByName(0, this.spineAnimationNames.stand, !0) }, i.prototype.createFiniteStateMachine = function() { var t, e = this;
            t = { init: "standing", transitions: [{ name: "stand", from: "*", to: "standing" }, { name: "walk", from: "jumping", to: "walking" }, { name: "walk", from: "standing", to: "walking" }, { name: "walk", from: "hitting", to: "walking" }, { name: "walk", from: "falling", to: "walking" }, { name: "walk", from: "flying", to: "walking" }, { name: "fall", from: "standing", to: "falling" }, { name: "fall", from: "walking", to: "falling" }, { name: "jump", from: "standing", to: "jumping" }, { name: "jump", from: "walking", to: "jumping" }, { name: "jump", from: "jumping", to: "jumping" }, { name: "hit", from: "standing", to: "hitting" }, { name: "hit", from: "walking", to: "hitting" }, { name: "hit", from: "hitting", to: "hitting" }, { name: "stun", from: "*", to: "stunt" }], methods: { onStand: function() { e.spine.setAnimationByName(0, e.spineAnimationNames.stand, !0) }, onWalk: function(t, i) { e.onGround && e.spine.getCurrentAnimationForTrack(0) !== e.spineAnimationNames.walk && e.spine.setAnimationByName(0, e.spineAnimationNames.walk, !0), e.setSpineDirection() }, onEnterFalling: function() {}, onFall: function() {}, onLeaveFalling: function() {}, onJump: function(t, e) {}, onHit: function(t, i) { e.waitingShoot = !0, e.spine.setAnimationByName(0, e.spineAnimationNames.attack), e.spine.addAnimationByName(0, e.spineAnimationNames.stand, !0) }, onLeaveHit: function(t, i) { e.waitingShoot && (e.waitingShoot = !1) }, onStun: function(t, i, o, n) { e.setInvulnerable(!0), e.shootCastingTimer.isRunning() && e.shootCastingTimer.stop(), e.body.setZeroVelocity(), e.moveComponent.disable(), e.attackTrigger.disable(), i ? (e.isStun = !0, e.spine.setAnimationByName(0, e.spineAnimationNames.stunned), e.stunTimer.setTime(GameData.invulnerabilityEnemyTimeHard), e.body.velocity.x = GameData.enemyStunImpulseX * o, e.body.velocity.y = GameData.enemyStunImpulseY * n) : (e.spine.setAnimationByName(0, e.spineAnimationNames.underAttack), e.stunTimer.setTime(GameData.invulnerabilityEnemyTimeSoft)), e.stunTimer.startTimer() } } }, this.state = new StateMachine(t) }, i.prototype.beginAttack = function() { this.runTrigger.isTargetInRange() || (this.lookDirection.x = this.player.x < this.x ? -1 : 1, this.state.stand(), this.setSpineDirection(), this.attackTrigger.disable(), this.runTrigger.enable(), this.isChasing = !0, this.moveComponent.pauseMove(), this.shootCastingTimer.startTimer()) }, i.prototype.takeDistance = function() { this.lookDirection.x = this.player.body.x < this.body.x ? 1 : -1, this.setSpineDirection(), this.shootCastingTimer.stop(), this.moveComponent.setDirection(this.lookDirection.x), this.moveComponent.resumeMove(), this.runTrigger.disable(), this.attackTrigger.enable() }, i.prototype.generateBullet = function(e, i) { if (this.player.isAlive()) { if ("shoot" === i.data.name && this.waitingShoot) { new t.BulletNormal(this.game, this.body.x + this.shootOffset.x * this.lookDirection.x, this.body.y + this.shootOffset.y, this.parent, this.lookDirection, GameData.LaserSpeed * GameData.PixToMet, t.CollisionLayers.Player, this._damage, this.bulletLifeTime, this.player.body);
                    this.shootCastingTimer.startTimer(), this.waitingShoot = !1 } } else this.attackTrigger.disable(), this.runTrigger.disable() }, i.prototype.shoot = function() { this.lookDirection.set(this.player.body.x > this.x ? 1 : -1, 0), this.setSpineDirection(), this.player && this.attackTrigger.isTargetInRange() ? this.runTrigger.isTargetInRange() ? this.takeDistance() : this.state.can("hit") && !this.waitingShoot && (this.game.ph2AudioManager.playEffect("enemy_hit2", !1), this.state.hit(0)) : (this.state.stand(), this.isAggresive ? (this.lookDirection.x = this.player.body.x < this.body.x ? -1 : 1, this.attackTrigger.enable(), this.moveComponent.setDirection(this.lookDirection.x), this.moveComponent.resumeMove()) : (this.moveComponent.resumeMove(), this.attackTrigger.enable(), this.isChasing = !1)) }, i.prototype.hitDamage = function(e, i, o, n) { void 0 === e && (e = 1), void 0 === o && (o = 0), void 0 === n && (n = 0), this.lifeManager.removeLife(e), this.spine.onComplete.removeAll(), this.lifeManager.currentlifes > 0 && (t.Utilities.playRandomEnemyHitEffect(this.game), this.lifeManager.currentlifes <= GameData.damageSkinLife && this.spine.setSkinByName("break"), this.state.stun(i, o, n)) }, i.prototype.restoreStunt = function() { this.isStun ? (this.spine.setAnimationByName(0, this.spineAnimationNames.recover), this.spine.onComplete.addOnce(this.restoreStunt_, this)) : this.restoreStunt_() }, i.prototype.restoreStunt_ = function() { this.state.stand(), this.isStun = !1, this.moveComponent.enable(), this.attackTrigger.enable(), this.setInvulnerable(!1), this.isAggresive && (this.lookDirection.x = this.player.body.x < this.body.x ? -1 : 1) }, i.prototype.setDead = function() { var e = this;
            t.Utilities.playRandomEnemyFinalHitEffect(this.game), this.componentManager.sendMessage("disable"), this.body.removeFromWorld(), this.shootCastingTimer.stop(), this.spine.setAnimationByName(0, this.spineAnimationNames.death), this.spine.onComplete.add(function() { e.destroyGameElement() }) }, i.prototype.setAlive = function() { this.revive(), this.body.dynamic = !0, this.game.physics.box2d.addBody(this.body), this.moveComponent.enable(), this.body.dynamic = !0, this.lifeManager.addLife(this.lifeManager.maxlifes) }, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.addMapCollision = function(t) {}, i.prototype.addPlatformCollision = function(t) {}, i.prototype.contactEntered = function(e, i, o, n, s, r) { if (0 != (n.m_filter.categoryBits & (t.CollisionLayers.Map | t.CollisionLayers.Breakable))) { var a = r.GetManifold().localNormal.y > GameData.GroundClearanceAngleCos;
                s ? a && this._GroundIn(r) : a && this._GroundOut(r) } }, i.prototype._GroundIn = function(t) { for (var e = 0; e < this.groundContactPool.length; e++)
                if (null === this.groundContactPool[e]) { this.groundContactPool[e] = t; break } this.onGround = !0, this.isStun ? this.body.setZeroVelocity() : (this.isChasing, this.moveComponent.isEnabled ? this.state.can("walk") && this.state.walk() : this.state.stand()) }, i.prototype._GroundOut = function(t) { this.onGround = !1; for (var e = 0; e < this.groundContactPool.length; e++) null !== this.groundContactPool[e] && (this.groundContactPool[e].IsTouching() ? (this.onGround = !0, this.lastGroundContact = this.groundContactPool[e]) : this.groundContactPool[e] = null);
            this.onGround || (this.body.gravityScale = 1, this.attackTrigger.disable(), this.runTrigger.disable()) }, i.prototype.disableGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.spine.visible = !1, this.spine.state.timeScale = 0 }, i.prototype.enableGameElement = function() { this.revive(), this.body.data.SetActive(!0), this.spine.visible = !0, this.spine.state.timeScale = 1 }, i.prototype.destroyGameElement = function() { this.body.removeFromWorld(), this.componentManager.destroy(), this.spine.destroy(!0), this.destroy(!0) }, i.prototype.setSpineDirection = function() { this.spine.scale.y = this.spineLocalScale.y, this.spine.scale.x = this.spineLocalScale.x * this.lookDirection.x }, i.prototype.setAggresive = function(e, i, o) { void 0 === o && (o = GameData.sizeWaveWidth / 2), this.isAggresive = !0, this.player.x > this.x ? (this.lookDirection.x = 1, this.moveComponent.setDirection(1)) : (this.lookDirection.x = -1, this.moveComponent.setDirection(-1)), e && (this.waveZoneLimitComponent = this.componentManager.addComponent(t.WaveZoneLimit), this.waveZoneLimitComponent.setLimit(i - o, i + o)), this.attackTrigger.disable() }, i.prototype.inWaveZone = function() { this.attackTrigger.enable(), this.setInvulnerable(!1) }, i.prototype.setParameters = function(e) { this.parameters = e, this.body.setRectangle(e.bodyWidth, e.bodyHeight); var i = this.body.addCircle(.5 * e.bodyWidth + 2, 0, .5 * e.bodyHeight + 2);
            this.body.setFixtureContactCallback(i, this.contactEntered, this), this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.m_filter.maskBits = GameData.enemyCollisionMask, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.GetNext().m_filter.maskBits = GameData.enemyCollisionMask, this.lifeManager.setMaxLifes(e.healthPoints), this.lifeManager.addLife(e.healthPoints), this._damage = e.damage, this.moveComponent.setSpeed(e.speed), this.moveComponent.setIdleTime(e.idleTime), this.attackTrigger.setDistance(e.chaseDistance), this.stunTimer.setTime(e.stuntTime), this.shootCastingTimer.setTime(e.hitTimer) }, i.prototype.setInvulnerable = function(e) { e ? (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.EnemyInvulnerable) : (this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.GetNext().m_filter.categoryBits = t.CollisionLayers.Enemies) }, i.prototype.setSpeed = function(t) { this.moveComponent.setSpeed(t) }, i.prototype.restoreSpeed = function() { this.moveComponent.setSpeed(this.parameters.speed) }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null, this.spine = null, this.groundContactPool = null }, i }(Phaser.Sprite);
    t.EnemyRangeB = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a) { var h = e.call(this, i, n, s, null) || this;
            h.isAttacking = !1, h.autoCull = !0, h.player = o, h.lookDirection = new Phaser.Point(1, 0), h.shootOffset = new Phaser.Point(30, 30), h.directionSnap = 1, h.targetDirSnap = 1, h.parameters = EnemiesParameters.Enemy5, h.bulletLifeTime = GameData.LaserMaxDistance / (GameData.LaserSpeed / GameData.PixToMet), i.physics.box2d.enable(h), h.body.setRectangle(h.parameters.bodyWidth, h.parameters.bodyHeight), h.body.gravityScale = 0, h.body.kinematic = !0; var l = new box2d.b2Filter; return l.categoryBits = t.CollisionLayers.Enemies, l.maskBits = GameData.enemyCollisionMask, h.body.data.m_fixtureList.SetFilterData(l), h.componentManager = Ph2.ComponentPlugin.initComponents(h), h.lifeManager = new t.LifeManager(h.parameters.healthPoints, h), h.lifeManager.onNoLife.add(h.setDead, h), h.shootCastingTimer = h.componentManager.addComponent(t.ComponentTimer, h.parameters.idleTime), h.shootCastingTimer.onComplete.add(h.preShoot, h), h.shootLoadTimer = h.componentManager.addComponent(t.ComponentTimer, h.parameters.hitTimer), h.shootLoadTimer.onComplete.add(h.shoot, h), h.moveComponent = h.componentManager.addComponent(t.BotMovementHorizontal, r, a, 0, h.parameters.speed, 0), h.setTrigger(), h.animation = h.game.add.ph2AnimationObject(0, 0, "drone_turret", "atlas_animation2"), h.animation.ph2Animations.play("camera_loop", 1, !0), h.addChild(h.animation), h.animation.scale.set(.6), h._damage = h.parameters.damage, h.createFiniteStateMachine(), h } return __extends(i, e), i.prototype.createFiniteStateMachine = function() { var t, e = this;
            t = { init: "standing", transitions: [{ name: "stand", from: "jumping", to: "standing" }, { name: "stand", from: "walking", to: "standing" }, { name: "stand", from: "hitting", to: "standing" }, { name: "stand", from: "falling", to: "standing" }, { name: "stand", from: "flying", to: "standing" }, { name: "stand", from: "stunt", to: "standing" }, { name: "walk", from: "jumping", to: "walking" }, { name: "walk", from: "standing", to: "walking" }, { name: "walk", from: "hitting", to: "walking" }, { name: "walk", from: "falling", to: "walking" }, { name: "walk", from: "flying", to: "walking" }, { name: "fall", from: "standing", to: "falling" }, { name: "fall", from: "walking", to: "falling" }, { name: "jump", from: "standing", to: "jumping" }, { name: "jump", from: "walking", to: "jumping" }, { name: "jump", from: "jumping", to: "jumping" }, { name: "hit", from: "standing", to: "hitting" }, { name: "hit", from: "walking", to: "hitting" }, { name: "hit", from: "hitting", to: "hitting" }, { name: "stun", from: "*", to: "stunt" }, { name: "fly", from: "jumping", to: "flying" }, { name: "fly", from: "falling", to: "flying" }], methods: { onStand: function() {}, onWalk: function(t, i) { e.scale.x = -e.moveComponent.lookDirection.x }, onEnterFalling: function() {}, onFall: function() {}, onLeaveFalling: function() {}, onJump: function(t, e) {}, onHit: function(t, e) {}, onStun: function(t) {}, onFly: function(t) {} } }, this.state = new StateMachine(t) }, i.prototype.beginAttack = function() { this.isAttacking = !0, this.shootCastingTimer.startTimer() }, i.prototype.preShoot = function() { this.moveComponent.lookDirection.x > 0 ? this.player.x > this.x ? this.holdForShoot() : this.shootCastingTimer.startTimer() : this.moveComponent.lookDirection.x < 0 && this.player.x < this.x ? this.holdForShoot() : this.shootCastingTimer.startTimer() }, i.prototype.holdForShoot = function() { this.moveComponent.disable(), this.body.setZeroVelocity(), this.shootLoadTimer.startTimer() }, i.prototype.shoot = function() { if (this.isAttacking) { this.game.ph2AudioManager.playEffect("enemy_hit2", !1), this.setLookDiscrete();
                new t.BulletLaser(this.game, this.body.x, this.body.y, this.parent, this.lookDirection, GameData.LaserSpeedTurret, t.CollisionLayers.Player, this._damage, 0, this.player.body);
                this.shootCastingTimer.startTimer(), this.moveComponent.enable() } }, i.prototype.hitDamage = function(e) { var i = this;
            void 0 === e && (e = 1), this.lifeManager.removeLife(e), this.lifeManager.currentlifes > 0 && (t.Utilities.playRandomEnemyHitEffect(this.game), this.animation.ph2Animations.play("camera_hit", 1, !1).onComplete.addOnce(function() { i.animation.ph2Animations.play("camera_loop", 1, !0) })) }, i.prototype.setDead = function() { var e = this;
            t.Utilities.playRandomEnemyFinalHitEffect(this.game), this.body.removeFromWorld(), this.triggerSprite.body.removeFromWorld(), this.componentManager.removeAllComponents(), this.animation.ph2Animations.play("camera_death", 1, !1).onComplete.addOnce(function() { e.destroyGameElement() }) }, i.prototype.setAlive = function() {}, i.prototype.disableGameElement = function() { this.kill(), this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.revive(), this.body.data.SetActive(!0) }, i.prototype.destroyGameElement = function() { this.triggerSprite.destroy(!0), this.animation.destroy(!0), this.componentManager.destroy(), this.destroy(!0), this.triggerSprite = null, this.animation = null }, i.prototype.setLookAbsolute = function() { this.lookDirection.set(this.player.x - this.x, this.player.y - this.y), this.lookDirection.normalize() }, i.prototype.setLookDiscreteOld = function() { var t = new Phaser.Point(this.x - this.player.x, this.y - this.player.y),
                e = GameData.zeroPoint.angle(t); if (e < 0) { e += Phaser.Math.degToRad(22.5); var i = Math.floor(e / Phaser.Math.degToRad(45)); switch (i) {
                    case 0:
                        this.lookDirection.set(-1, 0); break;
                    case -1:
                        this.lookDirection.set(-GameData.sqrt2inv, GameData.sqrt2inv); break;
                    case -2:
                        this.player.x < this.x ? this.lookDirection.set(-GameData.sqrt2inv, GameData.sqrt2inv) : this.lookDirection.set(GameData.sqrt2inv, GameData.sqrt2inv); break;
                    case -3:
                        this.lookDirection.set(GameData.sqrt2inv, GameData.sqrt2inv); break;
                    case -4:
                        this.lookDirection.set(1, 0); break;
                    default:
                        this.lookDirection.set(0, 1) } } else e > Phaser.Math.degToRad(90) ? this.lookDirection.set(1, 0) : this.lookDirection.set(-1, 0) }, i.prototype.setLookDiscrete = function() { var t = new Phaser.Point(this.x - this.player.x, this.y - this.player.y);
            this.moveComponent.lookDirection.x > 0 ? this.player.x > this.x && (t = new Phaser.Point(this.player.x - this.x, this.y - this.player.y)) : this.moveComponent.lookDirection.x < 0 && this.player.x < this.x && (t = new Phaser.Point(this.x - this.player.x, this.y - this.player.y)); var e = Phaser.Math.radToDeg(GameData.zeroPoint.angle(t));
            e < 22.5 && e > -90 && (e > -22.5 ? this.lookDirection.set(-1, 0) : this.lookDirection.set(-GameData.sqrt2inv, GameData.sqrt2inv)), this.lookDirection.x *= -this.moveComponent.lookDirection.x }, i.prototype.setAggresive = function() {}, i.prototype.setParameters = function(e) { this.parameters = e, this.body.setRectangle(e.bodyWidth, e.bodyHeight), this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Damage | t.CollisionLayers.Bullets, this.lifeManager.setMaxLifes(e.healthPoints), this.lifeManager.addLife(e.healthPoints), this._damage = e.damage, this.moveComponent.setSpeed(e.speed), this.shootCastingTimer.setTime(e.idleTime), this.shootLoadTimer.setTime(e.hitTimer);
            this.getFloorPoint(), this.y, this.parameters.hitDistance }, i.prototype.setInvulnerable = function(t) {}, i.prototype.setSpeed = function(t) { this.moveComponent.setSpeed(t) }, i.prototype.restoreSpeed = function() { this.moveComponent.setSpeed(this.parameters.speed) }, i.prototype.getFloorPoint = function() { var t, e = this.y; return (t = this.game.physics.box2d.raycast(this.x, this.y, this.x, this.y + 1e3, !0, this.filter)).length > 0 ? t[0].point.y > e && (e = t[0].point.y) : e += 500, e }, i.prototype.filter = function(e, i, o, n) { return i.m_filter.categoryBits === t.CollisionLayers.Map }, i.prototype.triggerEnter = function(t, e, i, o, n, s) { n ? this.isAttacking || this.beginAttack() : this.isAttacking && (this.isAttacking = !1, this.shootCastingTimer.stop(), this.shootLoadTimer.stop()) }, i.prototype.setTrigger = function() { var e = this.getFloorPoint() - this.y,
                i = 2 * this.parameters.hitDistance;
            this.triggerSprite = this.game.add.sprite(this.x, this.y + .5 * e), this.game.physics.box2d.enable(this.triggerSprite), this.triggerSprite.body.setRectangle(i, e), this.triggerSprite.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Items, this.triggerSprite.body.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, this.triggerSprite.body.static = !0, this.triggerSprite.body.sensor = !0, this.triggerSprite.body.setBodyContactCallback(this.player, this.triggerEnter, this) }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null }, i }(Phaser.Sprite);
    t.EnemyRangeC = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a, h) { var l = e.call(this, i, o.x + .5 * o.width, o.y - o.height, null) || this;
            s.add(l), l.autoCull = !0, l.player = n, l.spawnGroup = s, l.enemies = [], l.spawnHeads = [], l.useScreenBounds = !1, l.isLooking = !1, l.lookingRight = !1, l.isAttacking = !1, l.margin = .5 * i.width, l.lookDirection = new Phaser.Point(1, 0), l.shootOffset = new Phaser.Point(30, 30), l.parameters = EnemiesParameters.Enemy6; var c = new box2d.b2Filter; if (c.categoryBits = t.CollisionLayers.Enemies, c.maskBits = t.CollisionLayers.Damage | t.CollisionLayers.Bullets, i.physics.box2d.enable(l), l.body.setRectangle(l.parameters.bodyWidth, l.parameters.bodyHeight, 0, .5 * l.parameters.bodyHeight).SetFilterData(c), l.body.static = !0, l.componentManager = Ph2.ComponentPlugin.initComponents(l), l.lifeManager = new t.LifeManager(l.parameters.healthPoints, l), l.lifeManager.onNoLife.add(l.lightDeath, l), l.lifeManager.onNoLife.add(l.checkHeadsToDie, l), l.spawningTimer = l.componentManager.addComponent(t.ComponentTimer, l.parameters.hitTimer, !1, !0), l.spawningTimer.onComplete.add(l.spawnEnemy, l), l.animation = l.game.add.ph2AnimationObject(0, 0, "detector", "atlas_animations"), l.animation.ph2Animations.play("detector_anim", 1, !0), l.addChild(l.animation), h.length > 0)
                for (var d = 0, u = h; d < u.length; d++) { var p = u[d],
                        m = new t.EnemyDetectorHead(i, p, n, s);
                    m.lifeManager.onNoLife.add(l.checkHeadsToDie, l), l.spawnHeads.push(m) }
            if (l.spawnPoints = r, l.spawnList = a, l.originalBounds = new Phaser.Rectangle(l.game.world.bounds.x, l.game.world.bounds.y, l.game.world.bounds.width, l.game.world.bounds.height), l.bounds = { x_A: -.5 * l.game.width, x_B: .5 * l.game.width, y_A: -l.game.height, y_B: +l.game.height }, 0 === l.spawnPoints.length) l.useScreenBounds = !0, l.spawnPoints.push(new box2d.b2Vec2(l.x, l.y));
            else
                for (var f = 0; f < l.spawnPoints.length; f++) l.asignBounds(l.spawnPoints[f]);
            l.spawner = new t.ItemSelector(l.game, l.player, l.spawnPoints, l.spawnList, l.spawnGroup), l.setTrigger(), l.maxSimultaneousEnemies = GameData.waveMaxAlive, l.currentLiveEnemies = 0, l.patrolExtents = 100; var y = new box2d.b2Filter; return y.categoryBits = t.CollisionLayers.Map, y.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, l.subBody = l.game.physics.box2d.createBody(l.x, l.y), l.subBody.addEdge(l.bounds.x_A, l.bounds.y_A, l.bounds.x_A, l.bounds.y_B).SetFilterData(y), l.subBody.addEdge(l.bounds.x_B, l.bounds.y_A, l.bounds.x_B, l.bounds.y_B).SetFilterData(y), l.subBody.static = !0, l.subBody.friction = 0, l.subBody.data.SetActive(!1), l.subBody.data.m_userData = { isSlope: !1, isPlatform: !1, activeCount: 0 }, l } return __extends(i, e), i.prototype.update = function() { e.prototype.update.call(this), this.isLooking && (this.player.x > this.x ? this.lookingRight || (this.lookingRight = !0, this.animation.ph2Animations.play("detector_anim_left_right")) : this.lookingRight && (this.lookingRight = !1, this.animation.ph2Animations.play("detector_anim_right_left"))) }, i.prototype.asignBounds = function(t) { var e = t.x - this.x,
                i = t.y - this.y;
            Math.abs(e) > Math.abs(i) ? e < 0 ? e + this.spawnMargin < this.bounds.x_A && (this.bounds.x_A = e + this.spawnMargin) : e - this.spawnMargin > this.bounds.x_B && (this.bounds.x_B = e - this.spawnMargin) : i < 0 ? i < this.bounds.y_A && (this.bounds.y_A = i) : i > this.bounds.y_B && (this.bounds.y_B = i) }, i.prototype.beginSpawning = function() { this.isLooking = !0, Ph2.AnimationSystem.findObject("circle/red_detector", this.animation).ph2Animations.play("detector_red", 1, !0); for (var e = 0, i = this.spawnHeads; e < i.length; e++) i[e].activate();
            this.subBody.data.SetActive(!0), this.player.x < this.x ? (this.lookDirection.x = -1, this.lookingRight = !0) : (this.lookDirection.x = 1, this.lookingRight = !1), t.Instances.cameraManager.setBound(this.x + this.bounds.x_A, this.y + this.bounds.y_A, this.bounds.x_B - this.bounds.x_A, this.bounds.y_B - this.bounds.y_A), this.spawningTimer.startTimer() }, i.prototype.spawnEnemy = function() { var t = this; if (this.currentLiveEnemies < this.maxSimultaneousEnemies) { var e = this.spawner.pickNextItem();
                e.setAggresive(!0), e.lifeManager.onNoLife.addOnce(function(e) { t.enemies.splice(t.enemies.indexOf(e), 1), t.currentLiveEnemies--, t.alive || 0 !== t.currentLiveEnemies || t.endWave() }, this), this.enemies.push(e), this.currentLiveEnemies++ } }, i.prototype.endWave = function() { this.subBody.removeFromWorld() }, i.prototype.hitDamage = function(e) { void 0 === e && (e = 1), this.lifeManager.removeLife(e), this.lifeManager.currentlifes > 0 && t.Utilities.playRandomEnemyHitEffect(this.game) }, i.prototype.checkHeadsToDie = function() { if (this.spawnHeads.length > 0) { for (var t = !0, e = 0, i = this.spawnHeads; e < i.length; e++)
                    if (i[e].alive) { t = !1; break } t && !this.alive && this.setDead() } else this.setDead() }, i.prototype.lightDeath = function() { var t = this;
            this.kill(), this.body.removeFromWorld(), this.explodeAnim = this.game.add.sprite(this.x, this.y, "atlas_animation2", "exp_all0.png"), this.parent.addChild(this.explodeAnim), this.explodeAnim.anchor.set(.5, .5), this.explodeAnim.scale.set(.6, .6); var e = Phaser.Animation.generateFrameNames("exp_all", 0, 7, ".png");
            this.explodeAnim.animations.add("explode", e, 10, !1), this.explodeAnim.animations.play("explode").onComplete.addOnce(function() { t.explodeAnim.destroy(), t.explodeAnim = null }, this) }, i.prototype.setDead = function() { t.Utilities.playRandomEnemyFinalHitEffect(this.game), this.subBody.removeFromWorld(), t.Instances.cameraManager.setBoundsToWorld(), this.componentManager.destroy(), this.spawner.destroy(), this.destroy(!0) }, i.prototype.setAlive = function() {}, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.disableGameElement = function() { this.kill(), this.body.data.SetActive(!1), this.triggerSprite.body.data.SetActive(!1), this.componentManager.sendMessage("disable") }, i.prototype.enableGameElement = function() { this.revive(), this.body.data.SetActive(!0), this.triggerSprite.body.data.SetActive(!0), this.componentManager.sendMessage("enable") }, i.prototype.destroyGameElement = function() { t.Instances.cameraManager.setBoundsToWorld(), this.kill(), this.body.data.SetActive(!1), this.componentManager.destroy(), this.body.removeFromWorld(); for (var e = 0, i = this.enemies; e < i.length; e++) i[e].destroyGameElement();
            this.componentManager.removeAllComponents(), this.destroy(!0) }, i.prototype.pickRandomPoint = function() { return this.game.rnd.pick(this.spawnPoints) }, i.prototype.setAggresive = function() {}, i.prototype.setParameters = function(e) { this.body.setRectangle(e.bodyWidth, e.bodyHeight), this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Damage | t.CollisionLayers.Bullets, this.lifeManager.setMaxLifes(e.healthPoints), this.lifeManager.addLife(e.healthPoints), this.spawningTimer.setTime(e.hitTimer) }, i.prototype.setInvulnerable = function(t) {}, i.prototype.setSpeed = function(t) {}, i.prototype.restoreSpeed = function() {}, i.prototype.getFloorPoint = function() { var t, e = this.y; return (t = this.game.physics.box2d.raycast(this.x, this.y, this.x, this.y + 1e3, !0, this.filter)).length > 0 ? t[0].point.y > e && (e = t[0].point.y) : e += 500, e }, i.prototype.filter = function(e, i, o, n) { return i.m_filter.categoryBits === t.CollisionLayers.Map }, i.prototype.triggerEnter = function(t, e, i, o, n, s) { n && !this.isLooking && (this.beginSpawning(), this.triggerSprite.body.removeFromWorld()) }, i.prototype.setTrigger = function() { var e = this.getFloorPoint() - this.y,
                i = this.bounds.x_B - this.bounds.x_A;
            i - 2 * this.margin < 20 ? (this.margin = .5 * i - 10, i = 20) : i -= 2 * this.margin, this.triggerSprite = this.game.add.sprite(this.x, this.y + .5 * e), this.game.physics.box2d.enable(this.triggerSprite), this.triggerSprite.body.setRectangle(i, e, .5 * i + this.bounds.x_A + this.margin), this.triggerSprite.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Items, this.triggerSprite.body.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Player | t.CollisionLayers.Invulnerable, this.triggerSprite.body.static = !0, this.triggerSprite.body.sensor = !0, this.triggerSprite.body.setCategoryContactCallback(t.CollisionLayers.Player, this.triggerEnter, this) }, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null }, i }(Phaser.Sprite);
    t.EnemyDetector = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { var r = e.call(this, i, o.x + .5 * o.width, o.y - o.height, null) || this;
            s.add(r), r.player = n, r.autoCull = !0, r.lookDirection = new Phaser.Point(1, 0), r.shootOffset = new Phaser.Point(30, 30), r.isLooking = !1, r.lookingRight = !1, r.parameters = EnemiesParameters.Enemy6; var a = new box2d.b2Filter; return a.categoryBits = t.CollisionLayers.Enemies, a.maskBits = t.CollisionLayers.Damage | t.CollisionLayers.Bullets, i.physics.box2d.enable(r), r.body.setRectangle(r.parameters.bodyWidth, r.parameters.bodyHeight, 0, .5 * r.parameters.bodyHeight).SetFilterData(a), r.body.static = !0, r.componentManager = Ph2.ComponentPlugin.initComponents(r), r.lifeManager = new t.LifeManager(r.parameters.healthPoints, r), r.lifeManager.onNoLife.add(r.setDead, r), r.animation = r.game.add.ph2AnimationObject(0, 0, "detector", "atlas_animations"), r.animation.ph2Animations.play("detector_anim", 1, !0), r.addChild(r.animation), r } return __extends(i, e), i.prototype.update = function() { e.prototype.update.call(this), this.isLooking && (this.player.x > this.x ? this.lookingRight || (this.lookingRight = !0, this.animation.ph2Animations.play("detector_anim_left_right")) : this.lookingRight && (this.lookingRight = !1, this.animation.ph2Animations.play("detector_anim_right_left"))) }, i.prototype.activate = function() { this.isLooking = !0, Ph2.AnimationSystem.findObject("circle/red_detector", this.animation).ph2Animations.play("detector_red", 1, !0), this.player.x < this.x ? (this.lookDirection.x = -1, this.lookingRight = !0) : (this.lookDirection.x = 1, this.lookingRight = !1) }, i.prototype.hitDamage = function(e) { void 0 === e && (e = 1), this.lifeManager.removeLife(e), this.lifeManager.currentlifes > 0 && t.Utilities.playRandomEnemyHitEffect(this.game) }, i.prototype.setDead = function() { var e = this;
            t.Utilities.playRandomEnemyFinalHitEffect(this.game), this.body.removeFromWorld(), this.kill(), this.explodeAnim = this.game.add.sprite(this.x, this.y, "atlas_animation2", "exp_all0.png"), this.parent.addChild(this.explodeAnim), this.explodeAnim.anchor.set(.5, .5), this.explodeAnim.scale.set(.6, .6); var i = Phaser.Animation.generateFrameNames("exp_all", 0, 7, ".png");
            this.explodeAnim.animations.add("explode", i, 10, !1), this.explodeAnim.animations.play("explode").onComplete.addOnce(function() { e.destroyGameElement() }, this) }, i.prototype.setAlive = function() {}, i.prototype.set = function(t, e) { this.x = t, this.y = e }, i.prototype.hitStunt = function(t, e) {}, i.prototype.disableGameElement = function() { this.kill(), this.body.data.SetActive(!1) }, i.prototype.enableGameElement = function() { this.revive(), this.body.data.SetActive(!0), this.componentManager.sendMessage("enable") }, i.prototype.destroyGameElement = function() { this.explodeAnim.destroy(), this.body.removeFromWorld(), this.componentManager.destroy(), this.destroy(!0) }, i.prototype.setAggresive = function() {}, i.prototype.setParameters = function(e) { this.body.setRectangle(e.bodyWidth, e.bodyHeight), this.body.data.m_fixtureList.m_filter.categoryBits = t.CollisionLayers.Enemies, this.body.data.m_fixtureList.m_filter.maskBits = t.CollisionLayers.Damage | t.CollisionLayers.Bullets, this.lifeManager.setMaxLifes(e.healthPoints), this.lifeManager.addLife(e.healthPoints) }, i.prototype.setInvulnerable = function(t) {}, i.prototype.setSpeed = function(t) {}, i.prototype.restoreSpeed = function() {}, i.prototype.destroy = function(t) { e.prototype.destroy.call(this, t), this.player = null }, i }(Phaser.Sprite);
    t.EnemyDetectorHead = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e(e, i) { void 0 === i && (i = 200); var o = t.call(this, null, !1) || this; return o.lookDistance = i, o.onLookEnter = new Phaser.Signal, o.target = e, o } return __extends(e, t), e.prototype.start = function() { if (Constants.DEBUG_ENABLED) { var t = this.game.add.graphics(0, 0);
                t.beginFill(16711680, .2), t.drawRect(0, -1, this.lookDistance, 2 * GameData.sightExtents), t.endFill(), this.hitTexture = t.generateTexture(), t.destroy(), this.hitRayOffset = .5 * this.hitTexture.width, this.hitBoxVisual = this.game.add.sprite(0, 0, this.hitTexture), this.hitBoxVisual.anchor.set(0, .5), this.gameObject.addChild(this.hitBoxVisual) } }, e.prototype.update = function() { this.looked || this.checkTarget() }, e.prototype.checkAABB = function() { Constants.DEBUG_ENABLED && (this.hitBoxVisual.width = this.gameObject.lookDirection.x * this.lookDistance); var t = this.game.physics.box2d.queryAABB(this.gameObject.lookDirection.x > 0 ? this.gameObject.body.x : this.gameObject.body.x - this.lookDistance, this.gameObject.body.y - GameData.sightExtents, this.lookDistance, 2 * GameData.sightExtents); if (t.length > 0)
                for (var e = 0, i = t; e < i.length; e++) { var o = i[e]; if (o.fixture.m_filter.categoryBits === this.lookCategory) { this.lookEnemy(o.body); break } } }, e.prototype.checkRayCast = function() { Constants.DEBUG_ENABLED && (this.hitBoxVisual.scale.x = this.gameObject.lookDirection.x); var t = this.game.physics.box2d.raycast(this.gameObject.body.x, this.gameObject.body.y, this.gameObject.body.x + this.lookDistance * this.gameObject.lookDirection.x, this.gameObject.body.y, !0); if (t.length > 0)
                for (var e = 0, i = t; e < i.length; e++) { var o = i[e]; if (o.fixture.m_filter.categoryBits === this.lookCategory) { this.lookEnemy(o.body); break } } }, e.prototype.checkTarget = function() { this.isLookingTarget() && this.lookTarget() }, e.prototype.lookEnemy = function(t) { this.looked = !0, this.onLookEnter.dispatch(t), Constants.DEBUG_ENABLED && this.hitBoxVisual && (this.hitBoxVisual.visible = !1) }, e.prototype.lookTarget = function() { this.looked = !0, this.onLookEnter.dispatch(this.target.body), Constants.DEBUG_ENABLED && this.hitBoxVisual && (this.hitBoxVisual.visible = !1) }, e.prototype.resumeLook = function() { this.looked = !1, Constants.DEBUG_ENABLED && this.hitBoxVisual && (this.hitBoxVisual.visible = !0) }, e.prototype.pauseLook = function() { this.looked = !0, Constants.DEBUG_ENABLED && this.hitBoxVisual && (this.hitBoxVisual.visible = !1) }, e.prototype.isLookingTarget = function() { if (Constants.DEBUG_ENABLED && this.hitBoxVisual && (this.hitBoxVisual.width = this.gameObject.lookDirection.x * this.lookDistance), this.target.y > this.gameObject.y - GameData.sightExtents && this.target.y < this.gameObject.y + GameData.sightExtents)
                if (this.gameObject.lookDirection.x > 0) { if (this.target.x > this.gameObject.body.x && this.target.x < this.gameObject.body.x + this.lookDistance) return !0 } else if (this.target.x < this.gameObject.body.x && this.target.x > this.gameObject.body.x - this.lookDistance) return !0; return !1 }, e.prototype.setDistance = function(t) { this.lookDistance = t, Constants.DEBUG_ENABLED && this.hitBoxVisual && (this.hitBoxVisual.width = t) }, e.prototype.onDisable = function() { Constants.DEBUG_ENABLED && this.hitBoxVisual && (this.hitBoxVisual.visible = !1) }, e.prototype.onDestroy = function() { this.onLookEnter.dispose(), this.onLookEnter = null, this.hitTexture = null, this.hitBoxVisual = null, this.target = null }, e }(Ph2.Component);
    t.BotLook = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a) { void 0 === n && (n = 50), void 0 === r && (r = -1), void 0 === a && (a = !1); var h = e.call(this, 1, !0) || this; return h.speed = (s || .1) * GameData.PixToMet, h.stillTime = r < 0 ? 1e3 : r, h.leftLimit = i, h.rightLimit = o, h.lastDirection = new Phaser.Point(1, 0), h.timer = new t.ComponentTimer(h.stillTime), h.timer.onComplete.add(h.resumeMove, h), h.isMoving = !0, h.lookDirection = new Phaser.Point(1, 0), h.limitsMargin = n, h.useAbsoluteLimits = a, h } return __extends(i, e), i.prototype.start = function() { this.componentManager.addComponent(this.timer), this.gameObject.body.velocity.x = this.speed * this.lookDirection.x }, i.prototype.update = function() { this.isMoving && (this.checkDirection(), this.gameObject.body.velocity.x = this.speed * this.lookDirection.x) }, i.prototype.checkDirection = function() { var t, e; return this.lookDirection.x > 0 ? (t = this.rightLimit, e = this.limitsMargin) : (t = this.leftLimit, e = -this.limitsMargin), this.gameObject.body.x * this.lookDirection.x > (t - e) * this.lookDirection.x && (this.hitLimit(), this.useAbsoluteLimits && (this.gameObject.body.x = t - e), !0) }, i.prototype.hitLimit = function() { this.lookDirection.x *= -1, this.isMoving = !1, this.lastDirection.x = this.lookDirection.x, this.lookDirection.x = 0, this.gameObject.body.velocity.x = 0, this.currentPassenger && (this.currentPassenger.externalInfluenceX = 0), this.gameObject.state.can("stand") && this.gameObject.state.stand(), this.timer.startTimer() }, i.prototype.resumeMove = function() { this.timer.isRunning() ? this.timer.enable() : this.isMoving || (this.isMoving = !0, this.lookDirection.x = this.lastDirection.x, this.gameObject.lookDirection.x = this.lookDirection.x, this.gameObject.body.velocity.x = this.speed * this.lookDirection.x, this.currentPassenger && (this.currentPassenger.externalInfluenceX = this.gameObject.body.velocity.x, this.currentPassenger.externalInfluenceY = this.gameObject.body.velocity.y), this.gameObject.state.can("walk") && this.gameObject.state.walk()) }, i.prototype.setLimits = function(t, e) { this.leftLimit = t, this.rightLimit = e }, i.prototype.setDirection = function(t) { this.lookDirection.x = t, this.lastDirection.x = t }, i.prototype.pauseMove = function() { this.isMoving && (this.isMoving = !1, this.lastDirection.x = this.lookDirection.x, this.gameObject.body.velocity.x = 0, this.gameObject.body.velocity.y = 0), this.timer.isRunning() && this.timer.disable() }, i.prototype.getDirection = function() { return this.lookDirection }, i.prototype.onDisable = function() { this.timer.isRunning() && this.timer.disable() }, i.prototype.onEnable = function() { this.timer.isRunning() && this.timer.enable() }, i.prototype.onDestroy = function() { this.timer.disable() }, i.prototype.addPassenger = function(t) { this.currentPassenger = t, this.currentPassenger.externalInfluenceX = this.gameObject.body.velocity.x, this.currentPassenger.externalInfluenceY = this.gameObject.body.velocity.y }, i.prototype.removePassenger = function() { this.currentPassenger.externalInfluenceX = 0, this.currentPassenger = null }, i.prototype.setIdleTime = function(t) { this.stillTime = t }, i.prototype.setSpeed = function(t) { this.speed = t * GameData.PixToMet }, i }(Ph2.Component);
    t.BotMovementHorizontal = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e(e, i, o, n, s, r, a) { void 0 === i && (i = 0), void 0 === o && (o = 0), void 0 === n && (n = -1), void 0 === s && (s = !1), void 0 === r && (r = !1), void 0 === a && (a = 0); var h = t.call(this, 11, !1) || this; return h.direction = new Phaser.Point(0, 0), h.tmpPoint = new Phaser.Point(0, 0), h.deltaPosition = new Phaser.Point(0, 0), h.movementDelta = new Phaser.Point(0, 0), h.prevPosition = new Phaser.Point(0, 0), h.offset = new Phaser.Point(i, o), h.reached = !1, h.callbackDispatched = !1, h.isFocusWave = !1, h.normalize = s, h.smoothVelocity = .1, h.lerpPlayerX = .1, h.lerpPlayerY = .1, h.lerpCameraX = .1, h.lerpCameraY = .1, h.extraXViewMove = 100, h.safeDistanceY = 170, h.player = e, h.target = e.body, h.useLerp = r, h.lerpFactor = a, h.following = !1, h.onComplete = new Phaser.Signal, h.centerOffsetX = 0, h.centerOffsetY = 0, h.minShakeValue = 2, h._shake = { x: 0, y: 0, xDir: 1, yDir: 1, duration: 0, horizontal: !0, vertical: !0, intensity: 0, interval: 0, shakeStep: 16, shakeStepCounter: 0 }, h } return __extends(e, t), e.prototype.start = function() { this.prevPosition.set(this.gameObject.x, this.gameObject.y), this.centerOffsetX = -.5 * this.game.width, this.centerOffsetY = -.5 * this.game.height }, e.prototype.setSpeed = function(t) { this.speed = t }, e.prototype.lateUpdate = function() { if (this.prevPosition.set(this.gameObject.x, this.gameObject.y), this.following)
                if (this.useLerp) this.lerpUpdate();
                else if (this.smooth && !this.player.airMovementComponent.isEnabled && 0 === this._shake.duration) { var t = void 0,
                    e = void 0,
                    i = void 0;
                t = Math.abs(this.target.velocity.x - this.player.movementComponent.externalInfluenceX) > 0 ? this.target.x + this.extraXViewMove * this.player.lookDirection.x + this.centerOffsetX + this.offset.x : this.target.x + this.centerOffsetX + this.offset.x, e = this.player.cameraY + this.centerOffsetY + this.offset.y, i = this.target.y + this.centerOffsetY + this.offset.y; var o = Math.abs(i - this.gameObject.y);
                this.updateSmooth(t, e, this.lerpPlayerX, this.lerpPlayerY), o > this.safeDistanceY && i > this.gameObject.y && (this.gameObject.y = i - this.safeDistanceY + 10) } else this.gameObject.x = this.target.x + this.centerOffsetX + this.offset.x, this.gameObject.y = this.target.y + this.centerOffsetY + this.offset.y;
            else if (this.isFocusWave) { var t = this.game.width >= this.waveWidth ? this.waveX : this.waveX + (this.waveWidth - this.game.width) / 2,
                    e = this.waveY;
                this.game.width, this.waveWidth;
                this.updateSmooth(t, e, this.lerpCameraX, this.lerpCameraY), this.gameObject.x >= t && this.gameObject.x <= t + this.waveWidth && this.gameObject.y >= e && this.onCompletedFocusWave() } this._shake.duration > 0 && this.updateShakeStep() }, e.prototype.updateSmooth = function(t, e, i, o, n, s) { void 0 === n && (n = !0), void 0 === s && (s = !0), this.gameObject.y !== e && s && (this.gameObject.y = Phaser.Math.linear(this.gameObject.y, e, o), this.gameObject.y = Math.ceil(this.gameObject.y)), this.gameObject.x !== t && n && (this.gameObject.x = Phaser.Math.linear(this.gameObject.x, t, i), this.gameObject.x = Math.ceil(this.gameObject.x)) }, e.prototype.lerpUpdate = function() { this.gameObject.x = this.target.x + this.centerOffsetX + this.offset.x, this.gameObject.y = this.target.y + this.centerOffsetY + this.offset.y }, e.prototype.updateShake = function() { this._shake.duration -= this._shake.shakeStep, this._shake.duration <= 0 ? (this._shake.duration = 0, this._shake.x = 0, this._shake.y = 0, this.gameObject.x = this.target.x + this.centerOffsetX + this.offset.x, this.gameObject.y = this.target.y + this.centerOffsetY + this.offset.y) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.game.camera.view.width * 2 - this._shake.intensity * this.game.camera.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.game.camera.view.height * 2 - this._shake.intensity * this.game.camera.view.height)), this.gameObject.x += this._shake.x, this.gameObject.y += this._shake.y }, e.prototype.updateShakeStep = function() { this._shake.shakeStepCounter += this.game.time.elapsedMS, this._shake.shakeStepCounter >= this._shake.shakeStep && (this._shake.shakeStepCounter = 0, this._shake.duration -= this._shake.shakeStep, this._shake.duration <= 0 ? (this._shake.duration = 0, this._shake.x = 0, this._shake.y = 0, this.gameObject.x = this.target.x + this.centerOffsetX + this.offset.x, this.gameObject.y = this.target.y + this.centerOffsetY + this.offset.y) : (this._shake.horizontal && (this._shake.vertical ? this._shake.xDir = this.game.rnd.sign() : this._shake.xDir *= -1, this._shake.x = this.minShakeValue + this.game.rnd.frac() * this._shake.intensity * this.game.camera.view.width * this._shake.xDir), this._shake.vertical && (this._shake.horizontal ? this._shake.yDir = this.game.rnd.sign() : this._shake.yDir *= -1, this._shake.y = this.minShakeValue + this.game.rnd.frac() * this._shake.intensity * this.game.camera.view.height * this._shake.yDir))), this.gameObject.x += this._shake.x, this.gameObject.y += this._shake.y }, e.prototype.shake = function(t, e, i) { void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === i && (i = Phaser.Camera.SHAKE_BOTH), this._shake.duration > 0 || (this._shake.intensity = t, this._shake.duration = e, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = i === Phaser.Camera.SHAKE_BOTH || i === Phaser.Camera.SHAKE_HORIZONTAL, this._shake.vertical = i === Phaser.Camera.SHAKE_BOTH || i === Phaser.Camera.SHAKE_VERTICAL) }, e.prototype.setOffset = function(t, e) { this.offset.set(t, e) }, e.prototype.lerpNumber = function(t, e, i) { return i = i < 0 ? 0 : i, i = i > 1 ? 1 : i, Math.abs(e - t) < .001 ? e : t + (e - t) * i }, e.prototype.follow = function() { this.following = !0, this.smooth = !0 }, e.prototype.focusWave = function(t, e, i, o) { this.following = !1, this.isFocusWave = !0, this.waveX = t, this.waveY = e, this.waveWidth = i, this.waveHeight = o }, e.prototype.onCompletedFocusWave = function() { this.following = !0, this.isFocusWave = !1, this.game.camera.bounds.x = this.waveX, this.game.camera.bounds.y = this.waveY, this.game.camera.bounds.width = this.waveWidth, this.game.camera.bounds.height = this.waveHeight }, e.prototype.smoothRefollow = function() { this.following = !0, this.smooth = !0, this.distancePercent = 1; var t = this.game.add.tween(this).to({ distancePercent: 0 }, 1e3, Phaser.Easing.Quadratic.InOut, !0, 200);
            t.onUpdateCallback(this.refollowUpdate, this), t.onComplete.addOnce(this.follow, this) }, e.prototype.refollowUpdate = function() { this.tmpPoint.x = this.target.x + this.centerOffsetX + this.offset.x, this.tmpPoint.y = this.target.y + this.centerOffsetY + this.offset.y, this.gameObject.x = this.tmpPoint.x - (this.tmpPoint.x - this.gameObject.x) * this.distancePercent, this.gameObject.y = this.tmpPoint.y - (this.tmpPoint.y - this.gameObject.y) * this.distancePercent }, e.prototype.unFollow = function() { this.following = !1 }, e.prototype.resize = function() { this.centerOffsetX = -.5 * this.game.width, this.centerOffsetY = -.5 * this.game.height, this.lateUpdate() }, e.prototype.onDestroy = function() { this.player = null, this.target = null }, e }(Ph2.Component);
    t.CameraMovement = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e() { var e = t.call(this, 10, !1) || this; return e.onStart = new Phaser.Signal, e.onUpdate = new Phaser.Signal, e.onLateUpdate = new Phaser.Signal, e } return __extends(e, t), e.prototype.start = function() { this.onStart.dispatch() }, e.prototype.update = function() { this.onUpdate.dispatch() }, e.prototype.lateUpdate = function() { this.onLateUpdate.dispatch() }, e }(Ph2.Component);
    t.ComponentCallbackSubscriber = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(t, i, o, n, s, r) { var a = e.call(this, null, !0) || this; return a.hitDamage = o || 1, a.isDashing = !1, a.cantMove = !1, a.hitRect = i, a.speed = s * GameData.PixToMet, a.dashActive = !0, a.startX = 0, a.cooldownCounter = 0, a.cooldownTime = r, a.hitDistance = n, a.hitCategory = t, a.onAfterDash = new Phaser.Signal, a.onAfterCooldown = new Phaser.Signal, a } return __extends(i, e), i.prototype.createDebugSprite = function() { if (Constants.DEBUG_ENABLED) { var t = this.game.add.graphics(0, 0);
                t.beginFill(16711680, .5), t.drawRect(0, 0, this.hitRect.width, this.hitRect.height), t.endFill(), this.hitTexture = t.generateTexture(), t.destroy(), this.hitRayOffset = .5 * this.hitTexture.width, this.hitBoxVisual = this.game.add.sprite(0, 0, this.hitTexture), this.hitBoxVisual.anchor.set(.5), this.gameObject.addChild(this.hitBoxVisual) } }, i.prototype.attack = function() { this.dashActive && !this.isDashing && (Constants.DEBUG_ENABLED && (this.hitBoxVisual ? this.hitBoxVisual.visible = !0 : this.createDebugSprite()), this.isDashing = !0, this.gameObject.body.setZeroVelocity(), this.startX = this.gameObject.body.x, this.gameObject.body.velocity.x = this.speed * this.gameObject.lookDirection.x) }, i.prototype.interruptDash = function() { this.dashActive = !1, this.isDashing = !1, Constants.DEBUG_ENABLED && this.hitBoxVisual && (this.hitBoxVisual.visible = !1) }, i.prototype.update = function() { this.isDashing ? (this.gameObject.body.velocity.x = this.speed * this.gameObject.lookDirection.x, this.checkAABBHit(), this.gameObject.lookDirection.x > 0 ? this.gameObject.body.x > this.startX + this.hitDistance && (this.dashActive = !1, this.isDashing = !1, Constants.DEBUG_ENABLED && (this.hitBoxVisual.visible = !1), this.onAfterDash.dispatch()) : this.gameObject.body.x < this.startX - this.hitDistance && (this.dashActive = !1, this.isDashing = !1, Constants.DEBUG_ENABLED && (this.hitBoxVisual.visible = !1), this.onAfterDash.dispatch())) : this.dashActive || (this.cooldownCounter += this.game.time.elapsedMS, this.cooldownCounter > this.cooldownTime && (this.dashActive = !0, this.cooldownCounter = 0, this.onAfterCooldown.dispatch())) }, i.prototype.checkAABBHit = function() { if (this.dashActive) { Constants.DEBUG_ENABLED && (this.hitBoxVisual.scale.x = this.gameObject.lookDirection.x); var t = this.game.physics.box2d.queryAABB(this.gameObject.body.x - .5 * this.hitRect.width, this.gameObject.body.y - .5 * this.hitRect.height, this.hitRect.width, this.hitRect.height); if (t.length > 0)
                    for (var e = 0, i = t; e < i.length; e++) { var o = i[e];
                        0 != (o.fixture.m_filter.categoryBits & this.hitCategory) && this.hitEnemy(o.body) } } }, i.prototype.hitEnemy = function(e) { e.sprite && (e.sprite.hitDamage(this.hitDamage, !0, this.gameObject.lookDirection.x, -1), e.data.m_fixtureList.m_filter.categoryBits === t.CollisionLayers.Breakable && t.Instances.cameraManager.shake(GameData.actionShakeIntensity, GameData.actionShakeDuration, Phaser.Camera.SHAKE_BOTH)) }, i.prototype.setDamage = function(t) { this.hitDamage = t }, i.prototype.setSpeed = function(t) { this.speed = t * GameData.PixToMet }, i.prototype.setDistance = function(t) { this.hitDistance = t }, i.prototype.setCooldown = function(t) { this.cooldownTime = t }, i.prototype.setHitRect = function(t, e, i, o) { this.hitRect.setTo(t, e, i, o) }, i }(Ph2.Component);
    t.ComponentDashAttack = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e(e, i, o, n, s) { void 0 === i && (i = 100), void 0 === s && (s = 300); var r = t.call(this, null, !0) || this; return r.hitDamage = o || 1, r.hitForce = (n || 1) * GameData.PixToMet, r.isDashing = !1, r.isJumping = !1, r.bodySize = i, r.isActive = !1, r.startX = 0, r.cooldownCounter = 0, r.cooldownTime = s, r.hitCategory = e, r.onAfterAttack = new Phaser.Signal, r.currentVelocity = new box2d.b2Vec2, r.attackTimerActive = !1, r.attackTimeCounter = 0, r.attackCastingTime = GameData.enemyMeleeCChargeTime, r } return __extends(e, t), e.prototype.start = function() { Constants.DEBUG_ENABLED && this.createDebugSprite() }, e.prototype.createDebugSprite = function() { if (Constants.DEBUG_ENABLED) { var t = this.game.add.graphics(0, 0);
                t.beginFill(16711680, .5), t.drawRect(0, 0, this.bodySize, this.bodySize), t.endFill(), this.hitTexture = t.generateTexture(), t.destroy(), this.hitBoxVisual = this.game.add.sprite(0, 0, this.hitTexture), this.hitBoxVisual.anchor.set(.5), this.gameObject.addChild(this.hitBoxVisual) } }, e.prototype.jump = function() { this.isEnabled && (this.gameObject.body.velocity.x = GameData.enemyMeleeCJumpSpeedX * this.gameObject.lookDirection.x, this.gameObject.body.velocity.y = GameData.enemyMeleeCJumpSpeedY, Constants.DEBUG_ENABLED && (this.hitBoxVisual.visible = !0), this.isJumping = !0, this.isActive = !0, this.isDashing = !0) }, e.prototype.attack = function() { this.isEnabled && !this.isDashing && (Constants.DEBUG_ENABLED && (this.hitBoxVisual.visible = !0), this.isDashing = !0, this.gameObject.body.velocity.y = GameData.enemyMeleeCDiagonalSpeed * GameData.Angle45Cos, this.gameObject.body.velocity.x = GameData.enemyMeleeCDiagonalSpeed * this.gameObject.lookDirection.x * GameData.Angle45Sin) }, e.prototype.endJump = function() { this.isJumping = !1, this.isDashing = !1, Constants.DEBUG_ENABLED && this.hitBoxVisual && (this.hitBoxVisual.visible = !1) }, e.prototype.endDash = function() { this.isDashing = !1, Constants.DEBUG_ENABLED && (this.hitBoxVisual.visible = !1) }, e.prototype.update = function() { this.attackTimerActive && (this.attackTimeCounter += this.game.time.elapsedMS, this.attackTimeCounter > this.attackCastingTime && (this.attack(), this.attackTimerActive = !1, this.attackTimeCounter = 0)), this.isJumping ? (this.gameObject.body.velocity.x = GameData.enemyMeleeCJumpSpeedX * this.gameObject.lookDirection.x, this.checkAABBHit(), this.isDashing && this.gameObject.body.x * this.gameObject.lookDirection.x > (this.gameObject.player.body.x - (this.gameObject.player.body.y - this.gameObject.body.y) * this.gameObject.lookDirection.x) * this.gameObject.lookDirection.x && (this.endJump(), this.gameObject.body.setZeroVelocity(), this.gameObject.body.gravityScale = 0, this.attackTimerActive = !0)) : this.isDashing && (this.gameObject.body.velocity.y = GameData.enemyMeleeCDiagonalSpeed * GameData.Angle45Cos, this.gameObject.body.velocity.x = GameData.enemyMeleeCDiagonalSpeed * this.gameObject.lookDirection.x * GameData.Angle45Sin, this.checkAABBHit()) }, e.prototype.checkAABBHit = function() { if (this.isActive) { Constants.DEBUG_ENABLED && (this.hitBoxVisual.scale.x = this.gameObject.lookDirection.x); var t = this.game.physics.box2d.queryAABB(this.gameObject.body.x - .5 * this.bodySize, this.gameObject.body.y - .5 * this.bodySize, this.bodySize, this.bodySize); if (t.length > 0)
                    for (var e = 0, i = t; e < i.length; e++) { var o = i[e]; if (0 != (o.fixture.m_filter.categoryBits & this.hitCategory)) { this.hitEnemy(o.body); break } } } }, e.prototype.hitEnemy = function(t) { this.isActive = !1, t.sprite && t.sprite.hitDamage(this.hitDamage, !0, this.gameObject.lookDirection.x, -1) }, e.prototype.setDamage = function(t) { this.hitDamage = t }, e.prototype.setHitSize = function(t) { this.bodySize = t, Constants.DEBUG_ENABLED && (this.hitBoxVisual.width = t, this.hitBoxVisual.height = t) }, e.prototype.setForce = function(t) { this.hitForce = t }, e }(Ph2.Component);
    t.ComponentDeltaAttack = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a, h) { void 0 === a && (a = 600), void 0 === h && (h = 500); var l = e.call(this, null, !0) || this; return l.hitDamage = s || 1, l.hitForce = (r || 1) * GameData.PixToMet, l.isMoving = !1, l.cantMove = !1, l.doShake = !1, l.hitActive = !1, l.checkHitArea = !1, l.hitTime = a, l.hitted = !1, l.hitCount = 0, l.inCombo = !1, l.oneShotWall = !1, l.cooldownCounter = 0, l.cooldownTime = h, l.hitRect = o, l.hitChain = n, l.hitCategory = i, l.onAfterHit = new Phaser.Signal, l.timer = new t.ComponentTimer(l.hitTime), l.timer.onComplete.add(l.endHitChain, l), l.tmpDamage = 0, l } return __extends(i, e), i.prototype.start = function() { var t = this; if (Constants.DEBUG_ENABLED) { var e = this.game.add.graphics(0, 0);
                e.beginFill(16711680, .5), e.drawRect(0, 0, this.hitRect.width, this.hitRect.height), e.endFill(), this.hitTexture = e.generateTexture(), e.destroy(), this.hitRayOffset = .5 * this.hitTexture.width, this.hitBoxVisual = this.game.add.sprite(0, 0, this.hitTexture), this.hitBoxVisual.anchor.set(0, .5), this.hitBoxVisual.visible = !1, this.gameObject.addChild(this.hitBoxVisual) } this.componentManager.addComponent(this.timer), this.hitFx = this.game.add.sprite(0, 0, "atlas_animations", "hit1_0.png"), this.hitFx.animations.add("loop", Phaser.Animation.generateFrameNames("hit1_", 0, 4, ".png"), 15, !1).onComplete.add(function() { t.hitFx.visible = !1 }, this), this.hitFx.visible = !1 }, i.prototype.update = function() { this.checkHitArea && this.checkAABBHit(), this.hitted && (this.cooldownCounter += this.game.time.elapsedMS, this.cooldownCounter > this.cooldownTime && (this.hitted = !1, this.cooldownCounter = 0)) }, i.prototype.lateUpdate = function() { this.checkHitArea && Constants.DEBUG_ENABLED && (this.hitBoxVisual.width = this.gameObject.lookDirection.x * this.hitRect.width) }, i.prototype.checkAABBHit = function() { var e, i;
            e = this.gameObject.lookDirection.x > 0 ? this.gameObject.body.x : this.gameObject.body.x - this.hitRect.width, i = this.hitRect.width, Constants.DEBUG_ENABLED && (this.hitBoxVisual.width = this.gameObject.lookDirection.x * this.hitRect.width); var o = this.game.physics.box2d.queryAABB(e, this.gameObject.body.y - .5 * this.hitRect.height, i, this.hitRect.height),
                n = !1; if (o.length > 0)
                for (var s = 0, r = o; s < r.length; s++) { var a = r[s];
                    0 != (a.fixture.m_filter.categoryBits & this.hitCategory) && (this.oneShotWall && 0 != (a.fixture.m_filter.categoryBits & t.CollisionLayers.Breakable) ? a.body.sprite.hitDamage(GameData.wallsLife) : this.hitEnemy(a.body), n || (this.hitFx.position.set(a.body.x, this.gameObject.y), this.hitFx.scale.x = this.gameObject.lookDirection.x, this.hitFx.animations.play("loop"), this.hitFx.visible = !0, n = !0)) } Constants.DEBUG_ENABLED && n && (this.hitBoxVisual.alpha = .5, this.hitBoxVisual.tint = 6316128), this.endEffectiveHit() }, i.prototype.endEffectiveHit = function() { this.hitted = !0, this.checkHitArea = !1, this.hitCount++, this.gameObject.onGround && (this.hitCount >= this.hitChain ? (this.timer.reset(), this.timer.startTimer()) : (this.hitActive = !1, this.onAfterHit.dispatch(!0))) }, i.prototype.hitEnemy = function(e) { e.sprite && (this.hitChain > 2 && this.hitCount + 1 === this.hitChain ? (e.sprite.hitDamage(this.hitDamage, !0, this.gameObject.lookDirection.x, -1), this.doShake && t.Instances.cameraManager.shake(GameData.actionShakeIntensity, GameData.actionShakeDuration, Phaser.Camera.SHAKE_BOTH)) : e.sprite.hitDamage(this.hitDamage, !1)) }, i.prototype.hitCombo = function() { this.canHit() && this.gameObject.state.can("hit") && (this.gameObject.state.hit(this.hitCount), this.gameObject.onGround && (this.timer.reset(), this.timer.startTimer()), this.checkHitArea = !0, this.hitActive = !0, Constants.DEBUG_ENABLED && (this.hitBoxVisual.visible = !0)) }, i.filterRay = function(e, i, o, n) { return 0 != (i.m_filter.categoryBits & t.CollisionLayers.Enemies) }, i.prototype.endHitChain = function(t) { void 0 === t && (t = !1), this.timer.stop(), this.hitCount = 0, this.checkHitArea = !1, this.hitActive = !1, Constants.DEBUG_ENABLED && this.hitBoxVisual && (this.hitBoxVisual.visible = !1, this.hitBoxVisual.alpha = 1, this.hitBoxVisual.tint = 16777215), this.onAfterHit.dispatch(t) }, i.prototype.setDamage = function(t) { this.hitDamage = t }, i.prototype.setForce = function(t) { this.hitForce = t }, i.prototype.setComboCount = function(t) { this.hitChain = t }, i.prototype.setHitCooldown = function(t) { this.hitTime = t, this.timer.setTime(t) }, i.prototype.setHitEffectiveCooldown = function(t) { this.cooldownTime = t }, i.prototype.setHitRect = function(t, e, i, o) { this.hitRect.setTo(t, e, i, o), Constants.DEBUG_ENABLED && this.hitBoxVisual && (this.hitBoxVisual.width = i, this.hitBoxVisual.height = o) }, i.prototype.resetState = function() { this.endHitChain(), this.cooldownCounter = 0, this.onAfterHit.removeAll() }, i.prototype.onGround = function() { this.hitted = !1, this.cooldownCounter = 0, this.endHitChain() }, i.prototype.canHit = function() { return this.isEnabled && !this.hitActive && !this.hitted }, i.prototype.enableOneShotWalls = function() { this.oneShotWall = !0 }, i.prototype.disableOneShotWalls = function() { this.oneShotWall = !1 }, i.prototype.enableShake = function(t) { void 0 === t && (t = !0), this.doShake = t }, i }(Ph2.Component);
    t.ComponentHit = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e(e, i, o, n, s, r, a) { void 0 === i && (i = 100), void 0 === o && (o = 20), void 0 === n && (n = -20), void 0 === a && (a = 300); var h = t.call(this, null, !0) || this; return h.hitDamage = s || 1, h.hitForce = r || 1, h.isJumping = !1, h.bodySize = i, h.speed = o * GameData.PixToMet, h.upSpeed = n * GameData.PixToMet, h.isActive = !1, h.startX = 0, h.cooldownCounter = 0, h.cooldownTime = a, h.hitCategory = e, h.onAfterAttack = new Phaser.Signal, h.currentVelocity = new box2d.b2Vec2, h.attackTimerActive = !1, h.attackTimeCounter = 0, h.attackCastingTime = 1e3, h } return __extends(e, t), e.prototype.start = function() { if (Constants.DEBUG_ENABLED) { var t = this.game.add.graphics(0, 0);
                t.beginFill(16711680, .5), t.drawRect(0, 0, this.bodySize, this.bodySize), t.endFill(), this.hitTexture = t.generateTexture(), t.destroy(), this.hitBoxVisual = this.game.add.sprite(0, 0, this.hitTexture), this.hitBoxVisual.anchor.set(.5), this.hitBoxVisual.visible = !1, this.gameObject.addChild(this.hitBoxVisual) } }, e.prototype.jumpAttack = function() { this.isEnabled && !this.isJumping && (this.gameObject.body.velocity.x = this.speed * this.gameObject.lookDirection.x, this.gameObject.body.velocity.y = this.upSpeed, Constants.DEBUG_ENABLED && (this.hitBoxVisual.visible = !0), this.isJumping = !0, this.isActive = !0) }, e.prototype.endJump = function() { this.isJumping = !1, Constants.DEBUG_ENABLED && (this.hitBoxVisual.visible = !1) }, e.prototype.update = function() { this.isJumping && this.checkAABBHit() }, e.prototype.checkAABBHit = function() { if (this.isActive) { Constants.DEBUG_ENABLED && (this.hitBoxVisual.scale.x = this.gameObject.lookDirection.x); var t = this.game.physics.box2d.queryAABB(this.gameObject.body.x - .5 * this.bodySize, this.gameObject.body.y - .5 * this.bodySize, this.bodySize, this.bodySize); if (t.length > 0)
                    for (var e = 0, i = t; e < i.length; e++) { var o = i[e];
                        0 != (o.fixture.m_filter.categoryBits & this.hitCategory) && this.hitEnemy(o.body) } } }, e.prototype.hitEnemy = function(t) { this.isActive = !1, t.sprite && t.sprite.hitDamage(this.hitDamage, !0, this.gameObject.lookDirection.x, -1) }, e.prototype.setDamage = function(t) { this.hitDamage = t }, e.prototype.setForce = function(t) { this.hitForce = t }, e.prototype.setSpeed = function(t) { this.speed = t * GameData.PixToMet }, e.prototype.setUpSpeed = function(t) { this.upSpeed = t * GameData.PixToMet }, e }(Ph2.Component);
    t.ComponentJumpAttack = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e(e, i, o) { void 0 === i && (i = !1), void 0 === o && (o = !1); var n = t.call(this, null, !1) || this; return n.timer = 0, n.timeLimit = e, n.paused = !1, n.running = !1, n.isLoop = o, n.autoStart = i, n.onStart = new Phaser.Signal, n.onUpdate = new Phaser.Signal, n.onComplete = new Phaser.Signal, n } return __extends(e, t), e.prototype.start = function() { this.autoStart && (this.running = !0) }, e.prototype.update = function() {!this.paused && this.running && (this.onUpdate.dispatch(this.timer / this.timeLimit), this.timer += this.game.time.elapsedMS, this.timer >= this.timeLimit && this.onTimerEnd()) }, e.prototype.startTimer = function() { this.running = !0, this.paused = !1, this.onStart.dispatch() }, e.prototype.pause = function() { this.paused = !0 }, e.prototype.resume = function() { this.paused = !1 }, e.prototype.reset = function() { this.timer = 0 }, e.prototype.stop = function() { this.timer = 0, this.paused = !1, this.running = !1 }, e.prototype.onTimerEnd = function() { this.isLoop ? this.reset() : this.stop(), this.onComplete.dispatch() }, e.prototype.setTime = function(t) { this.timeLimit = t, this.timer = 0 }, e.prototype.isRunning = function() { return this.running }, e.prototype.isPaused = function() { return this.paused }, e }(Ph2.Component);
    t.ComponentTimer = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e(e, i, o, n, s) { void 0 === e && (e = null), void 0 === i && (i = 0), void 0 === o && (o = !1), void 0 === n && (n = GameData.sightExtents), void 0 === s && (s = !1); var r = t.call(this, null, !1) || this; return r.target = e, r.distance = i, r.distanceY = n, r.distanceSq = i * i, r.onCollide = new Phaser.Signal, r.useAABB = o, r.checkXOnly = s, r } return __extends(e, t), e.prototype.update = function() { null !== this.target && (this.useAABB ? this.AABBUpdate() : this.distanceUpdate()) }, e.prototype.distanceUpdate = function() { this.distanceSquare(this.target) < this.distanceSq && this.onCollide.dispatch(this, this.target) }, e.prototype.AABBUpdate = function() { this.distanceAABB(this.target) && this.onCollide.dispatch(this, this.target) }, e.prototype.isTargetInRange = function() { return null !== this.target && (this.useAABB ? this.distanceAABB(this.target) : this.distanceSquare(this.target) < this.distanceSq) }, e.prototype.setTarget = function(t, e) { this.distanceSq = e * e, this.target = t }, e.prototype.removeTarget = function() { this.target = null }, e.prototype.distanceSquare = function(t) { var e = t.x - this.gameObject.x,
                i = t.y - this.gameObject.y; return e * e + i * i }, e.prototype.distanceAABB = function(t) { if (this.target.x > this.gameObject.x - this.distance && this.target.x < this.gameObject.x + this.distance) { if (this.checkXOnly) return !0; if (this.target.y > this.gameObject.y - this.distanceY && this.target.y < this.gameObject.y + this.distanceY) return !0 } return !1 }, e.prototype.onDestroy = function() { this.target = null, this.onCollide.dispose() }, e.prototype.setDistance = function(t) { this.distance = t }, e }(Ph2.Component);
    t.DistanceCollisionChecker = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s) { void 0 === n && (n = !1), void 0 === s && (s = !1); var r = e.call(this, null, !0) || this; return r.speed = 5 * GameData.PixToMet, r.currentSpeed = 0, r.direction = 1, r.acceleration = .5, r.maxTime = 500, r.minTime = 500, r.useRandom = n, r.currentTime = n ? r.minTime + r.maxTime * Math.random() : r.maxTime, r.timer = new t.ComponentTimer(r.maxTime, !0, !0), r.timer.onComplete.add(r.changeDirection, r), r.leftLimit = i, r.rightLimit = o, r.isOut = !1, r.useSmooth = s, r.currentPassenger = null, r } return __extends(i, e), i.prototype.start = function() { this.componentManager.addComponent(this.timer) }, i.prototype.onEnable = function() { this.timer.startTimer() }, i.prototype.onDisable = function() { this.timer.stop() }, i.prototype.update = function() { this.useSmooth ? this.customTween() : this.currentSpeed = this.speed * this.direction, this.gameObject.body.x < this.leftLimit && !this.isOut ? (this.useSmooth || (this.gameObject.body.x = this.leftLimit), this.timer.reset(), this.direction = 1, this.isOut = !0) : this.gameObject.body.x > this.rightLimit && !this.isOut ? (this.useSmooth || (this.gameObject.body.x = this.rightLimit), this.timer.reset(), this.direction = -1, this.isOut = !0) : this.isOut && (this.isOut = !1), this.gameObject.body.velocity.x = this.currentSpeed, this.currentPassenger && (this.currentPassenger.externalInfluenceX = this.gameObject.body.velocity.x) }, i.prototype.changeDirection = function() { this.isOut || (this.direction *= -1, this.useRandom && (this.currentTime = this.minTime + this.maxTime * Math.random(), this.timer.setTime(this.currentTime))) }, i.prototype.setStartDirection = function(t) { this.direction = t }, i.prototype.customTween = function() { var t = this.speed * this.direction;
            this.currentSpeed !== t && (t < this.currentSpeed ? (this.currentSpeed -= this.acceleration * this.game.time.elapsedMS, this.currentSpeed < t && (this.currentSpeed = t)) : (this.currentSpeed += this.acceleration * this.game.time.elapsedMS, this.currentSpeed > t && (this.currentSpeed = t))) }, i.prototype.addPassenger = function(t) { this.currentPassenger = t, this.currentPassenger.externalInfluenceX = this.gameObject.body.velocity.x, this.currentPassenger.externalInfluenceY = this.gameObject.body.velocity.y }, i.prototype.removePassenger = function() { this.currentPassenger.externalInfluenceX = 0, this.currentPassenger = null }, i.prototype.setLimits = function(t, e) { this.leftLimit = t, this.rightLimit = e }, i.prototype.hasPassenger = function() { return null !== this.currentPassenger }, i }(Ph2.Component);
    t.HorizontalWaving = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a) { void 0 === n && (n = 50), void 0 === r && (r = -1), void 0 === a && (a = !1); var h = e.call(this, 1, !0) || this; return h.speed = s || .1, h.speed > 0 ? (h.lastDirection = new Phaser.Point(1, 0), h.lookDirection = new Phaser.Point(1, 0)) : (h.lastDirection = new Phaser.Point(-1, 0), h.lookDirection = new Phaser.Point(-1, 0), h.speed = Math.abs(h.speed)), h.stillTime = r < 0 ? 1e3 : r, h.leftLimit = i, h.rightLimit = o, h.timer = new t.ComponentTimer(h.stillTime), h.timer.onComplete.add(h.resumeMove, h), h.isMoving = !0, h.limitsMargin = n, h.useAbsoluteLimits = a, h.currentPassenger = null, h } return __extends(i, e), i.prototype.start = function() { this.componentManager.addComponent(this.timer), this.gameObject.body.velocity.x = this.speed * this.lookDirection.x }, i.prototype.update = function() { this.isMoving && (this.checkDirection(), this.gameObject.body.velocity.x = this.speed * this.lookDirection.x) }, i.prototype.checkDirection = function() { var t, e; return this.lookDirection.x > 0 ? (t = this.rightLimit, e = this.limitsMargin) : (t = this.leftLimit, e = -this.limitsMargin), this.gameObject.body.x * this.lookDirection.x > (t - e) * this.lookDirection.x && (this.hitLimit(), this.useAbsoluteLimits && (this.gameObject.body.x = t - e), !0) }, i.prototype.hitLimit = function() { this.lookDirection.x *= -1, this.isMoving = !1, this.lastDirection.x = this.lookDirection.x, this.lookDirection.x = 0, this.gameObject.body.velocity.x = 0, this.currentPassenger && (this.currentPassenger.externalInfluenceX = 0, this.currentPassenger.gameObject.body.velocity.x = 0), this.timer.startTimer() }, i.prototype.resumeMove = function() { this.timer.isRunning() ? this.timer.enable() : this.isMoving || (this.isMoving = !0, this.lookDirection.x = this.lastDirection.x, this.gameObject.lookDirection.x = this.lookDirection.x, this.gameObject.body.velocity.x = this.speed * this.lookDirection.x, this.currentPassenger && (this.currentPassenger.externalInfluenceX = this.gameObject.body.velocity.x, this.currentPassenger.externalInfluenceY = this.gameObject.body.velocity.y)) }, i.prototype.setLimits = function(t, e) { this.leftLimit = t, this.rightLimit = e }, i.prototype.pauseMove = function() { this.isMoving && (this.isMoving = !1, this.lastDirection.x = this.lookDirection.x, this.gameObject.body.velocity.x = 0, this.gameObject.body.velocity.y = 0), this.timer.isRunning() && this.timer.disable() }, i.prototype.getDirection = function() { return this.lookDirection }, i.prototype.onDisable = function() { this.timer.isRunning() && this.timer.disable() }, i.prototype.onEnable = function() { this.timer.isRunning() && this.timer.enable() }, i.prototype.onDestroy = function() { this.timer.disable() }, i.prototype.addPassenger = function(t) { this.currentPassenger = t, this.currentPassenger.externalInfluenceX = this.gameObject.body.velocity.x }, i.prototype.removePassenger = function() { this.currentPassenger.externalInfluenceX = 0, this.currentPassenger = null }, i.prototype.hasPassenger = function() { return null !== this.currentPassenger }, i }(Ph2.Component);
    t.MovementHorizontal = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n, s, r, a) { void 0 === n && (n = 50), void 0 === r && (r = -1), void 0 === a && (a = !1); var h = e.call(this, 1, !0) || this; return h.speed = s || .1, h.speed > 0 ? (h.lastDirection = new Phaser.Point(0, 1), h.lookDirection = new Phaser.Point(0, 1)) : (h.lastDirection = new Phaser.Point(0, -1), h.lookDirection = new Phaser.Point(0, -1), h.speed = Math.abs(h.speed)), h.stillTime = r < 0 ? 1e3 : r, h.topLimit = i, h.bottomLimit = o, h.timer = new t.ComponentTimer(h.stillTime), h.timer.onComplete.add(h.resumeMove, h), h.isMoving = !0, h.limitsMargin = n, h.useAbsoluteLimits = a, h.currentPassenger = null, h } return __extends(i, e), i.prototype.start = function() { this.componentManager.addComponent(this.timer), this.gameObject.body.velocity.y = this.speed * this.lookDirection.y }, i.prototype.update = function() { this.isMoving && (this.checkDirection(), this.gameObject.body.velocity.y = this.speed * this.lookDirection.y) }, i.prototype.checkDirection = function() { var t, e; return this.lookDirection.y > 0 ? (t = this.bottomLimit, e = this.limitsMargin) : (t = this.topLimit, e = -this.limitsMargin), this.gameObject.body.y * this.lookDirection.y > (t - e) * this.lookDirection.y && (this.hitLimit(), this.useAbsoluteLimits && (this.gameObject.body.y = t - e), !0) }, i.prototype.hitLimit = function() { this.lookDirection.y *= -1, this.isMoving = !1, this.lastDirection.y = this.lookDirection.y, this.lookDirection.y = 0, this.gameObject.body.velocity.y = 0, this.currentPassenger && (this.currentPassenger.externalInfluenceY = 0, this.currentPassenger.gameObject.body.velocity.y = 0), this.timer.startTimer() }, i.prototype.resumeMove = function() { this.timer.isRunning() ? this.timer.enable() : this.isMoving || (this.isMoving = !0, this.lookDirection.y = this.lastDirection.y, this.gameObject.lookDirection.y = this.lookDirection.y, this.gameObject.body.velocity.y = this.speed * this.lookDirection.y, this.currentPassenger && (this.currentPassenger.externalInfluenceX = this.gameObject.body.velocity.x, this.currentPassenger.externalInfluenceY = this.gameObject.body.velocity.y)) }, i.prototype.setLimits = function(t, e) { this.topLimit = t, this.bottomLimit = e }, i.prototype.pauseMove = function() { this.isMoving && (this.isMoving = !1, this.lastDirection.y = this.lookDirection.y, this.gameObject.body.velocity.x = 0, this.gameObject.body.velocity.y = 0), this.timer.isRunning() && this.timer.disable() }, i.prototype.getDirection = function() { return this.lookDirection }, i.prototype.onDisable = function() { this.timer.isRunning() && this.timer.disable() }, i.prototype.onEnable = function() { this.timer.isRunning() && this.timer.enable() }, i.prototype.onDestroy = function() { this.timer.disable() }, i.prototype.addPassenger = function(t) { this.currentPassenger = t, this.currentPassenger.externalInfluenceY = this.gameObject.body.velocity.y }, i.prototype.removePassenger = function() { this.currentPassenger.externalInfluenceY = 0, this.currentPassenger = null }, i.prototype.hasPassenger = function() { return null !== this.currentPassenger }, i }(Ph2.Component);
    t.MovementVertical = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e(e, i, o, n, s, r) { void 0 === o && (o = 0), void 0 === n && (n = 0), void 0 === s && (s = !1), void 0 === r && (r = -1); var a = t.call(this, -1, !1) || this; return a.speed = (i || .3) * GameData.PixToMet, a.direction = new Phaser.Point(0, 0), a.deltaPosition = new Phaser.Point(0, 0), a.movementDelta = new Phaser.Point(0, 0), a.previousPosition = new Phaser.Point(0, 0), a.offset = new Phaser.Point(o, n), a.reached = !1, a.callbackDispatched = !1, a.keepFollowing = s, a.targetPoint = e, r > 0 ? (a.useTravelLimit = !0, a.travelLimitSq = r * r, a.totalTravel = 0) : a.useTravelLimit = !1, a.onComplete = new Phaser.Signal, a } return __extends(e, t), e.prototype.start = function() { this.previousPosition.copyFrom(this.gameObject.position), this.targetPoint ? this.setPoint(this.targetPoint, this.keepFollowing) : this.targetPoint = null }, e.prototype.setSpeed = function(t) { this.speed = t }, e.prototype.update = function() { null !== this.targetPoint && (this.reached ? (this.callbackDispatched || (this.onComplete.dispatch(), this.callbackDispatched = !0), this.keepFollowing && this.gameObject.body.x + this.offset.x !== this.targetPoint.x && (this.reached = !1)) : (this.keepFollowing && (this.direction.x = this.gameObject.x + this.offset.x > this.targetPoint.x ? -1 : 1, this.direction.y = this.gameObject.y + this.offset.y > this.targetPoint.y ? -1 : 1), this.straightStep(), this.movementDelta.set(this.gameObject.position.x - this.previousPosition.x, this.gameObject.position.y - this.previousPosition.y), this.gameObject.body.x === this.targetPoint.x - this.offset.x && this.gameObject.body.y === this.targetPoint.y - this.offset.y ? (this.reached = !0, this.callbackDispatched = !1) : this.useTravelLimit && (this.totalTravel += this.movementDelta.getMagnitude(), this.totalTravel * this.totalTravel > this.travelLimitSq && (this.reached = !0, this.callbackDispatched = !1)), this.previousPosition.copyFrom(this.gameObject.position))) }, e.prototype.straightStep = function() {
            (this.gameObject.body.x + this.offset.x) * this.direction.x > this.targetPoint.x * this.direction.x ? this.gameObject.body.x = this.targetPoint.x - this.offset.x : this.gameObject.body.velocity.x = this.speed * this.direction.x, (this.gameObject.body.y + this.offset.y) * this.direction.y > this.targetPoint.y * this.direction.y ? this.gameObject.body.y = this.targetPoint.y - this.offset.y : this.gameObject.body.velocity.y = this.speed * this.direction.y }, e.prototype.setPoint = function(t, e) { void 0 === e && (e = !1), this.keepFollowing = e, this.keepFollowing ? this.targetPoint = t : this.targetPoint = new PIXI.Point(t.x, t.y), this.callbackDispatched = !1 }, e.prototype.setPointByDir = function(t, e) { this.keepFollowing = !1, this.direction.set(t.x, t.y), this.targetPoint = new PIXI.Point(this.gameObject.x + t.x * e, this.gameObject.y + t.y * e), this.callbackDispatched = !1 }, e.prototype.setOffset = function(t, e) { this.offset.set(t, e) }, e.prototype.lerpNumber = function(t, e, i) { return i = i < 0 ? 0 : i, i = i > 1 ? 1 : i, Math.abs(e - t) < .001 ? e : t + (e - t) * i }, e }(Ph2.Component);
    t.MoveToPoint = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e(e, i, o, n, s) { void 0 === o && (o = !1), void 0 === n && (n = 0), void 0 === s && (s = 0); var r = t.call(this, null, !1) || this; return r.speed = (i || .3) * GameData.PixToMet, r.reached = !1, r.oncompleteDispatched = !1, r.onlimitDispatched = !1, r.keepFollowing = o, r.targetPoint = e, r.onComplete = new Phaser.Signal, r.onLimit = new Phaser.Signal, r.previousDirection = 0, 0 === n && 0 === s ? r.useBounds = !1 : (r.useBounds = !0, r.boundLeft = n, r.boundRight = s), r } return __extends(e, t), e.prototype.start = function() { this.targetPoint ? this.setPoint(this.targetPoint, this.keepFollowing) : this.targetPoint = null }, e.prototype.setSpeed = function(t) { this.speed = t * GameData.PixToMet }, e.prototype.update = function() { null !== this.targetPoint && (this.reached ? (this.oncompleteDispatched || (this.onComplete.dispatch(), this.oncompleteDispatched = !0), this.keepFollowing && this.gameObject.x !== this.targetPoint.x && this.resetFollow()) : this.gameObject.x * this.previousDirection > this.targetPoint.x * this.previousDirection ? (this.reached = !0, this.oncompleteDispatched = !1) : this.useBounds ? this.gameObject.body.x >= this.boundLeft && this.gameObject.body.x <= this.boundRight ? this.gameObject.body.velocity.x = this.speed * this.previousDirection : this.keepFollowing ? this.onlimitDispatched ? this.targetPoint.x > this.boundLeft && this.targetPoint.x < this.boundRight && (this.resetFollow(), this.onlimitDispatched = !1, this.gameObject.body.x < this.boundLeft ? this.gameObject.body.reset(this.boundLeft, this.gameObject.body.y) : this.gameObject.body.x > this.boundRight && this.gameObject.body.reset(this.boundRight, this.gameObject.body.y), this.gameObject.body.velocity.x = this.speed * this.previousDirection) : (this.gameObject.body.velocity.x = 0, this.onlimitDispatched = !0, this.onLimit.dispatch()) : (this.reached = !0, this.onlimitDispatched || (this.onlimitDispatched = !0, this.onLimit.dispatch())) : this.gameObject.body.velocity.x = this.speed * this.previousDirection) }, e.prototype.setPoint = function(t, e) { void 0 === e && (e = !1), null !== t ? (e ? (this.keepFollowing = e, this.targetPoint = t) : this.targetPoint = new PIXI.Point(t.x, t.y), this.resetFollow(), this.oncompleteDispatched = !1, this.onlimitDispatched = !1) : this.targetPoint = null }, e.prototype.resetFollow = function() { this.targetPoint && (this.previousDirection = this.targetPoint.x > this.gameObject.x ? 1 : -1), this.gameObject.lookDirection.x = this.previousDirection, this.reached = !1 }, e.prototype.forceReach = function() { this.reached = !0, this.onComplete.dispatch(), this.oncompleteDispatched = !0 }, e.prototype.isOnLimit = function() { return !!this.onlimitDispatched && (this.targetPoint.x < this.boundLeft || this.targetPoint.x > this.boundRight) }, e }(Ph2.Component);
    t.MoveToPointHorizontal = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(t, i, o) { void 0 === i && (i = !1), void 0 === o && (o = !1); var n = e.call(this, null, !0) || this; return n.speed = (t || .5) * GameData.PixToMet, n.cantMove = !1, n.isJumping = !1, n.onAirJump = !1, n.lookDirection = 0, n.lastPosition = new Phaser.Point(0, 0), n.lerpAmont = .5, n.enableDoubleJump = i, n.useKeys = o, n.jumpKeys = [], n } return __extends(i, e), i.prototype.start = function() { this.lastPosition.set(this.gameObject.x, this.gameObject.y), this.useKeys && (this.jumpKeys.push(this.game.input.keyboard.addKey(Phaser.Keyboard[t.Instances.keyboardKey.up])), this.setKeys()) }, i.prototype.onEnable = function() { this.jumpKeys.length > 0 && this.setKeys() }, i.prototype.onDisable = function() { this.jumpKeys.length > 0 && this.clearKeys() }, i.prototype.jump = function() { this.gameObject.onGround ? (this.playRandomJumpEffect(), this.gameObject.state.can("jump") && (this.gameObject.state.jump(-this.speed), this.isJumping = !0)) : this.enableDoubleJump && !this.onAirJump && (this.playRandomJumpEffect(), this.gameObject.state.can("jump") && (this.isJumping = !0, this.onAirJump = !0, this.gameObject.state.jump(-this.speed))) }, i.prototype.setDoubleJump = function(t) { this.enableDoubleJump = t }, i.prototype.setSpeed = function(t) { this.speed = t * GameData.PixToMet }, i.prototype.onGround = function() { this.onAirJump = !1, this.isJumping = !1 }, i.prototype.setKeys = function() { this.jumpKeys[0].onDown.add(this.jump, this) }, i.prototype.clearKeys = function() { this.jumpKeys[0].onDown.remove(this.jump, this) }, i.prototype.playRandomJumpEffect = function() { var t = this.game.rnd.integerInRange(1, 5);
            this.game.ph2AudioManager.playEffect("alien_jump" + t, !1) }, i }(Ph2.Component);
    t.PlayerJump = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(t, i, o) { void 0 === i && (i = !1), void 0 === o && (o = !1); var n = e.call(this, null, !0) || this; return n.speed = (t || .5) * GameData.PixToMet, n.isMoving = !1, n.cantMove = !1, n.lookDirection = new Phaser.Point(0, 0), n.lastPosition = new Phaser.Point(0, 0), n.normalized = i, n.inverseRoot2 = 1 / Math.SQRT2, n.lerpFactor = .5, n.externalInfluenceX = 0, n.externalInfluenceY = 0, n } return __extends(i, e), i.prototype.start = function() {}, i.prototype.onEnable = function() { this.setKeys() }, i.prototype.onDisable = function() { this.clearKeys() }, i.prototype.update = function() { this.cantMove || (this.lastPosition.set(this.gameObject.x, this.gameObject.y), this.isMoving && (this.step = this.game.time.elapsed * this.speed, this.normalized ? this.normalizedUpdate() : this.liteUpdate())) }, i.prototype.liteUpdate = function() { this.gameObject.body.velocity.x !== this.speed * this.lookDirection.x && (this.gameObject.body.velocity.x = this.speed * this.lookDirection.x), this.gameObject.body.velocity.y !== this.speed * this.lookDirection.y && (this.gameObject.body.velocity.y = this.speed * this.lookDirection.y) }, i.prototype.normalizedUpdate = function() { 0 === this.lookDirection.x ? 0 !== this.lookDirection.y && (this.gameObject.body.velocity.y = this.speed * this.lookDirection.y) : 0 === this.lookDirection.y ? this.gameObject.body.velocity.x = this.speed * this.lookDirection.x : (this.gameObject.body.velocity.x = this.speed * this.lookDirection.x * this.inverseRoot2, this.gameObject.body.velocity.y = this.speed * this.lookDirection.y * this.inverseRoot2) }, i.prototype.moveLeft = function() { this.lookDirection.x -= 1, this.isMoving = this.checkMoveState() }, i.prototype.moveRight = function() { this.lookDirection.x += 1, this.isMoving = this.checkMoveState() }, i.prototype.stopLeft = function() { this.lookDirection.x += 1, this.isMoving = this.checkMoveState() }, i.prototype.stopRight = function() { this.lookDirection.x -= 1, this.isMoving = this.checkMoveState() }, i.prototype.moveUp = function() { this.lookDirection.y -= 1, this.isMoving = this.checkMoveState() }, i.prototype.moveDown = function() { this.lookDirection.y += 1, this.isMoving = this.checkMoveState() }, i.prototype.stopUp = function() { this.lookDirection.y += 1, this.isMoving = this.checkMoveState() }, i.prototype.stopDown = function() { this.lookDirection.y -= 1, this.isMoving = this.checkMoveState() }, i.prototype.stopMovement = function() { this.lookDirection.x = 0, this.lookDirection.y = 0, this.isMoving = this.checkMoveState() }, i.prototype.checkMoveState = function() { return 0 === this.lookDirection.x ? this.gameObject.body.velocity.x = 0 : this.gameObject.lookDirection.set(this.lookDirection.x, this.lookDirection.y), 0 === this.lookDirection.y && (this.gameObject.body.velocity.y = 0), 0 !== this.lookDirection.x || 0 !== this.lookDirection.y }, i.prototype.hold = function() { this.cantMove = !0, this.isMoving = !1 }, i.prototype.continue = function() { this.cantMove = !1, 0 === this.lookDirection.x && 0 === this.lookDirection.y || (this.isMoving = !0) }, i.prototype.setSpeed = function(t) { this.speed = t * GameData.PixToMet }, i.prototype.onDestroy = function() { this.keys[0].onDown.remove(this.moveLeft, this), this.keys[0].onUp.remove(this.stopLeft, this), this.keys[1].onDown.remove(this.moveRight, this), this.keys[1].onUp.remove(this.stopRight, this), this.keys[2].onDown.remove(this.moveUp, this), this.keys[2].onUp.remove(this.stopUp, this) }, i.prototype.lerpNumber = function(t, e, i) { return i = i < 0 ? 0 : i, i = i > 1 ? 1 : i, Math.abs(e - t) < .001 ? e : t + (e - t) * i }, i.prototype.setSurfaceData = function(t) {}, i.prototype.waitDirection = function(t) {}, i.prototype.setKeys = function() { var e = this.game.input.keyboard.addKey(Phaser.Keyboard[t.Instances.keyboardKey.left]),
                i = this.game.input.keyboard.addKey(Phaser.Keyboard[t.Instances.keyboardKey.right]),
                o = this.game.input.keyboard.addKey(Phaser.Keyboard[t.Instances.keyboardKey.up]),
                n = this.game.input.keyboard.addKey(Phaser.Keyboard.DOWN);
            this.keys = [e, i, o, n], this.keys[0].onDown.add(this.moveLeft, this), this.keys[0].onUp.add(this.stopLeft, this), this.keys[1].onDown.add(this.moveRight, this), this.keys[1].onUp.add(this.stopRight, this), this.keys[2].onDown.add(this.moveUp, this), this.keys[2].onUp.add(this.stopUp, this), this.keys[3].onDown.add(this.moveDown, this), this.keys[3].onUp.add(this.stopDown, this), e.isDown && this.moveLeft(), i.isDown && this.moveRight(), o.isDown && this.moveUp(), n.isDown && this.moveDown() }, i.prototype.clearKeys = function() { this.keys[0].onDown.remove(this.moveLeft, this), this.keys[0].onUp.remove(this.stopLeft, this), this.keys[1].onDown.remove(this.moveRight, this), this.keys[1].onUp.remove(this.stopRight, this), this.keys[2].onDown.remove(this.moveUp, this), this.keys[2].onUp.remove(this.stopUp, this), this.keys[3].onDown.remove(this.moveDown, this), this.keys[3].onUp.remove(this.stopDown, this), this.lookDirection.x = 0, this.lookDirection.y = 0 }, i.prototype.removeKeys = function() { this.keys.length > 0 && (this.clearKeys(), this.keys = []) }, i.prototype.disableMovement = function() {}, i.prototype.enableMovement = function() {}, i }(Ph2.Component);
    t.PlayerMovement = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(t, i) { void 0 === i && (i = !0); var o = e.call(this, null, !0) || this; return o.speed = (t || .5) * GameData.PixToMet, o.isMoving = !1, o.cantMove = !1, o.lookDirection = new Phaser.Point(0, 0), o.lastPosition = new Phaser.Point(0, 0), o.lerpFactor = .5, o.externalInfluenceX = 0, o.externalInfluenceY = 0, o.waitingForDirChange = !1, o.movementEnabled = !0, o.keys = [], o.initKeys = i, o } return __extends(i, e), i.prototype.start = function() { if (this.initKeys) { var e = this.game.input.keyboard.addKey(Phaser.Keyboard[t.Instances.keyboardKey.left]),
                    i = this.game.input.keyboard.addKey(Phaser.Keyboard[t.Instances.keyboardKey.right]);
                this.keys.push(e), this.keys.push(i), this.lastPosition.set(this.gameObject.x, this.gameObject.y), this.setKeys() } }, i.prototype.update = function() { if (this.movementEnabled) { if (this.cantMove) return;
                this.gameObject.body.velocity.x !== this.speed * this.lookDirection.x + this.externalInfluenceX && (this.gameObject.body.velocity.x = this.speed * this.lookDirection.x + this.externalInfluenceX), 0 !== this.externalInfluenceY && (this.gameObject.body.velocity.y = this.externalInfluenceY) } else 0 !== this.externalInfluenceX && (this.gameObject.body.velocity.x = this.externalInfluenceX), 0 !== this.externalInfluenceY && (this.gameObject.body.velocity.y = this.externalInfluenceY);
            this.gameObject.movementDelta.set(this.gameObject.body.x - this.lastPosition.x, this.gameObject.body.y - this.lastPosition.y), this.lastPosition.set(this.gameObject.body.x, this.gameObject.body.y) }, i.prototype.moveLeft = function() { this.lookDirection.x -= 1, this.lookDirection.x < -1 && (this.lookDirection.x = -1), this.checkMoveState() }, i.prototype.moveRight = function() { this.lookDirection.x += 1, this.lookDirection.x > 1 && (this.lookDirection.x = 1), this.checkMoveState() }, i.prototype.stopLeft = function() { this.lookDirection.x += 1, this.lookDirection.x > 1 && (this.lookDirection.x = 1), this.checkMoveState() }, i.prototype.stopRight = function() { this.lookDirection.x -= 1, this.lookDirection.x < -1 && (this.lookDirection.x = -1), this.checkMoveState() }, i.prototype.stopMovement = function() { this.lookDirection.x = 0, this.checkMoveState() }, i.prototype.hold = function() { this.cantMove = !0, this.isMoving = !1 }, i.prototype.checkMoveState = function() { this.movementEnabled && (0 === this.lookDirection.x ? (this.isMoving = !1, this.gameObject.onGround && this.gameObject.state.can("stand") && this.gameObject.state.stand()) : (this.isMoving = !0, this.gameObject.lookDirection.set(this.lookDirection.x, this.lookDirection.y), this.waitingForDirChange && (this.lookDirection.x === this.dirExpected ? this.cantMove = !1 : this.cantMove = !0), this.gameObject.onGround && this.gameObject.state.can("walk") ? this.gameObject.state.walk() : this.gameObject.flipSpine())) }, i.prototype.continue = function() { this.cantMove = !1, 0 !== this.lookDirection.x && (this.isMoving = !0), this.waitingForDirChange = !1 }, i.prototype.setSpeed = function(t) { this.speed = t * GameData.PixToMet }, i.prototype.lerpNumber = function(t, e, i) { return i = i < 0 ? 0 : i, i = i > 1 ? 1 : i, Math.abs(e - t) < .001 ? e : t + (e - t) * i }, i.prototype.waitDirection = function(t) { this.waitingForDirChange = !0, this.dirExpected = t, this.cantMove = !0 }, i.prototype.setSurfaceData = function(t) { this.contactData = t }, i.prototype.onEnable = function() { this.keys.length > 0 && this.setKeys() }, i.prototype.onDisable = function() { this.keys.length > 0 && (this.clearKeys(), this.lookDirection.x = 0) }, i.prototype.setKeys = function() { this.keys[0].onDown.add(this.moveLeft, this), this.keys[0].onUp.add(this.stopLeft, this), this.keys[1].onDown.add(this.moveRight, this), this.keys[1].onUp.add(this.stopRight, this), (this.keys[0].isDown || this.gameObject.currentDirectionDpad === t.DpadDirection.left) && this.moveLeft(), (this.keys[1].isDown || this.gameObject.currentDirectionDpad === t.DpadDirection.right) && this.moveRight() }, i.prototype.clearKeys = function() { this.keys[0].onDown.remove(this.moveLeft, this), this.keys[0].onUp.remove(this.stopLeft, this), this.keys[1].onDown.remove(this.moveRight, this), this.keys[1].onUp.remove(this.stopRight, this), this.isMoving = !1 }, i.prototype.removeKeys = function() { this.keys.length > 0 && (this.clearKeys(), this.keys = []) }, i.prototype.disableMovement = function() { this.movementEnabled = !1 }, i.prototype.enableMovement = function() { this.movementEnabled = !0, this.checkMoveState() }, i }(Ph2.Component);
    t.PlayerMovementHorizontal = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e(e, i, o, n, s) { void 0 === e && (e = 10), void 0 === i && (i = 10), void 0 === o && (o = 0), void 0 === n && (n = 0), void 0 === s && (s = !0); var r = t.call(this, null, !1) || this; return r.width = e, r.height = i, r.offSet = new Phaser.Point(o, n), r.anchor = new Phaser.Point(.5, .5), r.debug = !0, r.renderColor = 16711680, r.doRender = s, r } return __extends(e, t), e.prototype.start = function() { this.renderGraphics = this.game.add.graphics(this.gameObject.x, this.gameObject.y), this.renderGraphics.beginFill(this.renderColor, .5), this.renderGraphics.drawRect(-this.width * this.anchor.x + this.offSet.x, -this.height * this.anchor.y + this.offSet.y, this.width, this.height), this.renderGraphics.endFill() }, e.prototype.update = function() { this.doRender && this.renderGraphics.position.set(this.gameObject.x, this.gameObject.y) }, e.prototype.render = function(t) { if (void 0 === t && (t = !1), this.debug && this.game.debug.context) { var e = this.game.debug.context;
                e.fillStyle = this.renderColor, e.strokeStyle = this.renderColor; var i = this.gameObject.x + this.offSet.x - this.width / 2,
                    o = this.gameObject.y + this.offSet.y - this.height / 2;
                t ? e.fillRect(i, o, this.width, this.height) : e.strokeRect(i, o, this.width, this.height) } }, e.prototype.setBody = function(t, e, i, o) { this.width = t, this.height = void 0 !== e ? e : this.height; var n = void 0 !== i ? i : this.offSet.x,
                s = void 0 !== o ? o : this.offSet.y;
            this.offSet = new Phaser.Point(n, s) }, e.prototype.getBody = function() { return { x: this.gameObject.x + this.offSet.x, y: this.gameObject.y + this.offSet.y, width: this.width, height: this.height } }, e.prototype.onDestroy = function() { this.renderGraphics.destroy(!0) }, e }(Ph2.Component);
    t.RectangleBody = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e;! function(t) { t[t.Fireball = 0] = "Fireball", t[t.AcidBall = 1] = "AcidBall" }(e = t.AmmunitionType || (t.AmmunitionType = {})); var i = function(i) {
        function o(e, o, n, s, r, a, h, l, c, d) { void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === h && (h = 1), void 0 === l && (l = 300), void 0 === c && (c = 500), void 0 === d && (d = null); var u = i.call(this, null, !0) || this; return u.group = n, u.hitDamage = a || 1, u.isMoving = !1, u.cantMove = !1, u.lookDirection = 1, u.lastPosition = new Phaser.Point(0, 0), u.offset = new Phaser.Point(s, r), u.amunitionRect = new Phaser.Rectangle(0, 0, 30, 15), u.proyectileSpeed = h * GameData.PixToMet, u.bulletLifeTime = c / u.proyectileSpeed * 1e3, u.hitActive = !1, u.onCooldown = !1, u.hitCount = 0, u.inCombo = !1, u.cooldownCounter = 0, u.cooldownTime = l, u.shootCategory = e, u.follow = !1, u.target = d, null !== u.target ? u.targetPoint = u.target.sprite.position : u.targetPoint = null, u.amunitionType = o, u.setAmmunitionParams(), u.timer = new t.ComponentTimer(u.cooldownTime), u.timer.onComplete.add(u.endCooldown, u), u.onAfterShoot = new Phaser.Signal, u.onAfterCooldown = new Phaser.Signal, u } return __extends(o, i), o.prototype.setAmmunitionParams = function() { switch (this.amunitionType) {
                case e.Fireball:
                case e.AcidBall:
                    this.amunitionRect.width = 100, this.amunitionRect.height = 30, this.proyectileAtlas = "atlas_animations", this.proyectileAnim = "stinkfly_attack"; break;
                default:
                    this.proyectileAtlas = "atlas_animations", this.proyectileAnim = "stinkfly_attack" } }, o.prototype.start = function() { this.componentManager.addComponent(this.timer) }, o.prototype.shootProyectile = function() { if (this.isEnabled && !this.onCooldown) { var i = new t.Projectile(this.game, this.gameObject.x + this.offset.x * this.gameObject.lookDirection.x, this.gameObject.y + this.offset.y, this.group, this.amunitionRect, this.shootCategory, this.hitDamage, this.proyectileSpeed, this.bulletLifeTime, this.gameObject.lookDirection);
                this.onCooldown = !0, this.timer.startTimer(), this.amunitionType !== e.Fireball && this.amunitionType !== e.AcidBall || (i.loadTexture("atlas_animations"), i.frameName = "stinkfly_attack0.png", i.animations.add("acid", Phaser.Animation.generateFrameNames("stinkfly_attack", 0, 3, ".png"), 15, !0), i.animations.play("acid")), this.onAfterShoot.dispatch() } }, o.filterRay = function(e, i, o, n) { return 0 != (i.m_filter.categoryBits & t.CollisionLayers.Enemies) }, o.prototype.endCooldown = function() { this.onCooldown = !1, this.onAfterCooldown.dispatch() }, o.prototype.setSpeed = function(t) { this.proyectileSpeed = t * GameData.PixToMet }, o.prototype.setDamage = function(t) { this.hitDamage = t }, o.prototype.setCooldown = function(t) { this.cooldownTime = t, this.timer.setTime(t) }, o.prototype.setAmmunition = function(t) { this.amunitionType = t, this.setAmmunitionParams() }, o.prototype.setRange = function(t) { void 0 === t && (t = 500), this.bulletLifeTime = t / this.proyectileSpeed * 1e3 }, o.prototype.canShoot = function() { return this.isEnabled && !this.onCooldown }, o }(Ph2.Component);
    t.ShootComponent = i }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e() { var e = t.call(this, null, !1) || this; return e.limitLeft = null, e.limitRight = null, e } return __extends(e, t), e.prototype.start = function() { this.lastX = this.gameObject.x, this.gameObject.setInvulnerable(!0), this.isIn = !1 }, e.prototype.setLimit = function(t, e) { this.limitLeft = t, this.limitRight = e }, e.prototype.lateUpdate = function() { if (null !== this.limitLeft && null !== this.limitRight) { var t = this.gameObject.parameters.bodyWidth,
                    e = this.gameObject.x - t / 2,
                    i = this.gameObject.x + t / 2,
                    o = (this.lastX, this.lastX, this.game.camera.x, this.game.camera.x, GameData.sizeWaveWidth, e < this.limitLeft && this.isIn),
                    n = i > this.limitRight && this.isIn,
                    s = !this.isIn && e > this.limitLeft,
                    r = !this.isIn && i < this.limitRight;
                n && (this.gameObject.x = this.limitRight), o && (this.gameObject.x = this.limitLeft), s && r && (this.isIn = !0, this.gameObject.inWaveZone && this.gameObject.inWaveZone()), this.lastX = this.gameObject.x } }, e }(Ph2.Component);
    t.WaveZoneLimit = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(t) {
        function e(e, i, o) { var n = t.call(this, e) || this; return n.percent = 100, n.sprite = new Phaser.Sprite(e, 0, 0, i, o), n.totalHeight = n.sprite.height, n.totalWidth = n.sprite.width, n.rect = new Phaser.Rectangle(0, 0, n.percent / 100 * n.totalWidth, n.totalHeight), n.sprite.crop(n.rect, !0), n.add(n.sprite), n } return __extends(e, t), e.prototype.setAnchor = function(t, e) { this.sprite.anchor.set(t, e), this.sprite.pivot.x = this.totalWidth * this.sprite.anchor.x, this.sprite.pivot.y = this.totalHeight * this.sprite.anchor.y }, e.prototype.setPercent = function(t) { if (t !== this.percent) { if (t < 0 ? t = 0 : t > 100 && (t = 100), this.percent = t, this.totalHeight <= 0) return;
                this.rect.width = Math.max(0, this.percent / 100 * this.totalWidth), this.sprite.crop(this.rect, !0) } }, e.prototype.destroy = function() { this.sprite.destroy(), this.sprite = null, this.rect = null, t.prototype.destroy.call(this) }, e.prototype.hideLoadingBar = function() { this.sprite.visible = !1 }, e }(Phaser.Group);
    t.LoadingBar = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i) { var o = e.call(this, i.game) || this;
            o.controller = i, o.tween = null, o.loadingBar = new t.LoadingBar(o.game, "load_cn", "loading1.png"); var n = new Phaser.Point(o.game.width / 2, o.game.height / 2); return o.logo = new Phaser.Sprite(o.game, n.x, n.y - 55, "fg_logo"), o.logo.anchor.set(.5, .5), o.loadingBg = new Phaser.Sprite(o.game, n.x, n.y + 150, "load_cn", "loading0.png"), o.loadingBg.anchor.set(.5, .5), o.loadingBar.sprite.x = n.x - o.loadingBg.width / 2, o.loadingBar.sprite.y = n.y + 98 + 75, o.loadingBar.setAnchor(0, .5), o.playButton = new Phaser.Sprite(o.game, n.x + 20, n.y + 200, "load_cn", "play_button.png"), o.playButton.anchor.set(.5, .5), o.playButton.inputEnabled = !0, o.playButton.input.useHandCursor = !0, o.playButton.visible = !1, o.add(o.logo), o.add(o.loadingBg), o.add(o.playButton), o.setPercent(0), o } return __extends(i, e), i.prototype.setPercent = function(t) { null !== this.loadingBar && this.loadingBar.setPercent(t) }, i.prototype.showPlayButton = function() { this.loadingBg.visible = !1, this.loadingBar.sprite.visible = !1, this.playButton.visible = !0, this.playButton.events.onInputUp.addOnce(this.pressPlayButton, this), this.tween = this.game.add.tween(this.playButton.scale).to({ x: 1.1, y: 1.1 }, 500, Phaser.Easing.Back.Out, !0, 1e3, 0, !0), this.tween.repeat(-1, 800) }, i.prototype.pressPlayButton = function() { this.controller.onPressPlay() }, i.prototype.destroy = function() { this.playButton.inputEnabled = !1, this.logo = null, this.loadingBg = null, this.loadingBar = null, this.playButton = null, this.tween && this.tween.stop(), this.tween = null, e.prototype.destroy.call(this) }, i.prototype.resize = function() { var t = new Phaser.Point(this.game.width / 2, this.game.height / 2);
            this.logo.x = t.x, this.logo.y = t.y - 55, this.loadingBg.x = t.x, this.loadingBg.y = t.y + 150, this.loadingBar.sprite.x = t.x - this.loadingBg.width / 2, this.loadingBar.sprite.y = t.y + 98 + 75, this.playButton.x = t.x + 20, this.playButton.y = t.y + 200 }, i }(Phaser.Group);
    t.LoadingCN = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(i, o, n) { void 0 === o && (o = !0), void 0 === n && (n = 1); var s = e.call(this, i.game) || this;
            s.controller = i, s.isIntro = o, s.outroNum = n; var r; return o ? (r = "ui_comic_intro", s.animIn = "comic_intro_in", s.animOut = "comic_intro_out", s.mainElement = "comic_intro") : (r = "ui_comic_outro" + n, s.animIn = "comic_outro" + n + "_in", s.animOut = "comic_outro" + n + "_out", s.mainElement = "comic_outro_1"), s.ui = s.game.add.ph2UI("ui_comic", r), s.add(s.ui), o ? (Ph2.UISystem.findObject("comic_outro_1", s.ui).visibility.enable(!1), Ph2.UISystem.findObject("comic_outro_2", s.ui).visibility.enable(!1), Ph2.UISystem.findObject("comic_outro_1", s.ui).visible = !1, Ph2.UISystem.findObject("comic_outro_2", s.ui).visible = !1) : (Ph2.UISystem.findObject("comic_intro", s.ui).visibility.enable(!1), Ph2.UISystem.findObject("comic_intro", s.ui).visible = !1, 1 === s.outroNum ? (Ph2.UISystem.findObject("comic_outro_2", s.ui).visibility.enable(!1), Ph2.UISystem.findObject("comic_outro_2", s.ui).visible = !1) : (Ph2.UISystem.findObject("comic_outro_1", s.ui).visibility.enable(!1), Ph2.UISystem.findObject("comic_outro_1", s.ui).visible = !1)), t.Instances.controllKeyboard.setController(s, t.ControllerType.uiComic), s.addTouchListener(), s.visible = !1, s.localization(), s } return __extends(i, e), i.prototype.onChangeButton = function() {}, i.prototype.onPressButton = function() { this.goToNextState() }, i.prototype.localization = function() { t.Instances.localizationManager.localizeUIText("comic_intro/base/intro_2/text_bad/text1", this.ui, "intro_comic_message_1"), t.Instances.localizationManager.localizeUIText("comic_intro/base/intro_5/text_good/text2", this.ui, "intro_comic_message_2"), t.Instances.localizationManager.localizeUIText("comic_outro_1/base/text_container/text", this.ui, "outro_comic_message_1") }, i.prototype.playIntro = function() { this.visible = !0, Ph2.UISystem.playAnimationObject(this.mainElement, this.ui, this.animIn, 1, !1).onComplete.addOnce(this.showButton, this) }, i.prototype.showButton = function() { this.nextButton.visible = !0, Ph2.UISystem.playAnimationObject("button_next", this.ui, "button_settings_in", 1, !1).onComplete.addOnce(this.enableButton, this) }, i.prototype.enableButton = function() { t.Instances.controllKeyboard.addControl(), this.nextButton.inputEnabled = !0 }, i.prototype.addTouchListener = function() { this.nextButton = t.Utilities.addTouchCallbackToButton("button_next/button_settings", this.ui, this.goToNextState, this), this.nextButton.inputEnabled = !1, this.nextButton.visible = !1 }, i.prototype.removeTouchListener = function() { t.Instances.controllKeyboard.removeControl(), t.Utilities.removeTouchCallbackToButton("button_next/button_settings", this.ui) }, i.prototype.goToNextState = function() { t.Instances.controllKeyboard.removeControl(), Ph2.UISystem.playAnimationObject(this.mainElement, this.ui, this.animOut, 1, !1).onComplete.addOnce(this.changeState, this), Ph2.UISystem.playAnimationObject("button_next", this.ui, "button_settings_out", 1, !1) }, i.prototype.changeState = function() { this.controller.onPressPlay && this.controller.onPressPlay() }, i.prototype.resize = function() { var t = Ph2.UISystem.findObject("comic_intro", this.ui),
                e = Ph2.UISystem.findObject("comic_outro_1", this.ui),
                i = Ph2.UISystem.findObject("comic_outro_2", this.ui); if (this.game.width >= 1280) t.scale.set(1, 1), e.scale.set(1, 1), i.scale.set(1, 1);
            else { var o = this.game.width / 1280;
                t.scale.set(o, o), e.scale.set(o, o), i.scale.set(o, o) } }, i.prototype.destroy = function() { this.removeTouchListener(), e.prototype.destroy.call(this), this.ui = null, this.controller = null, this.nextButton = null }, i }(Phaser.Group);
    t.UIComicIntro = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(t) { var i = e.call(this, t.game) || this; return i.controller = t, i.ui = i.game.add.ph2UI("ui_confirmation", "atlas_ui_gameover"), i.add(i.ui), i.addTouchListener(), i.visible = !1, i.localization(), i } return __extends(i, e), i.prototype.localization = function() { t.Instances.localizationManager.localizeUIText("confirmation_container/container/title", this.ui, "confirmation_exit_gameplay") }, i.prototype.addTouchListener = function() { t.Utilities.addTouchCallbackToButton("confirmation_container/button_yes", this.ui, this.pressYes, this), t.Utilities.addTouchCallbackToButton("confirmation_container/button_no", this.ui, this.pressNo, this) }, i.prototype.removeTouchListener = function() { t.Utilities.removeTouchCallbackToButton("confirmation_container/button_yes", this.ui), t.Utilities.removeTouchCallbackToButton("confirmation_container/button_no", this.ui) }, i.prototype.onPressBack = function() { this.pressNo() }, i.prototype.onChangeButton = function(t) { var e = Ph2.UISystem.findObject("confirmation_container/button_yes", this.ui),
                i = Ph2.UISystem.findObject("confirmation_container/button_no", this.ui); switch (e.scale.set(1, 1), i.scale.set(1, 1), e.setFrames("button_yes_hl.png", "button_yes.png", "button_yes_p.png", "button_yes.png"), i.setFrames("button_no_hl.png", "button_no.png", "button_no_p.png", "button_no.png"), t) {
                case "yes":
                    e.setFrames("button_yes_hl.png", "button_yes_hl.png", "button_yes_p.png", "button_yes_hl.png"), e.scale.set(1.2, 1.2); break;
                case "no":
                    i.setFrames("button_no_hl.png", "button_no_hl.png", "button_no_p.png", "button_no_hl.png"), i.scale.set(1.2, 1.2) } }, i.prototype.onPressButton = function(t) { switch (t) {
                case "yes":
                    this.pressYes(); break;
                case "no":
                    this.pressNo() } }, i.prototype.pressYes = function(t, e, i) { void 0 === i && (i = !0), i && (this.game.ph2AudioManager.playEffect("button1", !1), this.hide(), this.controller.onPressYes && this.controller.onPressYes()) }, i.prototype.pressNo = function(t, e, i) { void 0 === i && (i = !0), i && (this.game.ph2AudioManager.playEffect("button1", !1), this.hide(), this.controller.onPressNo && this.controller.onPressNo()) }, i.prototype.show = function() { t.Instances.controllKeyboard.setController(this, t.ControllerType.uiConfirmation), this.visible = !0, this.enableAll() }, i.prototype.hide = function() { this.disableAll(), this.onCompletedHide() }, i.prototype.onCompletedHide = function() { this.visible = !1, this.controller.onCompletedHideConfirmation && this.controller.onCompletedHideConfirmation() }, i.prototype.enableAll = function() { t.Instances.controllKeyboard.addControl(), t.Utilities.enableTouch("confirmation_container/button_yes", this.ui), t.Utilities.enableTouch("confirmation_container/button_no", this.ui) }, i.prototype.disableAll = function() { t.Instances.controllKeyboard.removeControl(), t.Utilities.disableTouch("confirmation_container/button_yes", this.ui), t.Utilities.disableTouch("confirmation_container/button_no", this.ui) }, i.prototype.destroy = function() { this.removeTouchListener(), t.Instances.controllKeyboard.removeControl(), e.prototype.destroy.call(this), this.ui = null, this.controller = null }, i }(Phaser.Group);
    t.UIConfirmation = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e;! function(t) { t[t.itemFound = 0] = "itemFound", t[t.star = 1] = "star" }(e || (e = {})); var i = function(i) {
        function o(t, e) { void 0 === e && (e = !1); var o = i.call(this, t.game) || this; return o.controller = t, o.game = t.game, o.ui = o.game.add.ph2UI("ui_level_completed", "atlas_ui_level_completed"), o.ui.fixedToCamera = !0, o.toComic = e, o.saveElement(), o.addTouchCallback(), o.visible = !1, o.localization(), o } return __extends(o, i), o.prototype.localization = function() { t.Instances.localizationManager.localizeUIText("title/banner_2/title", this.ui, "level_complete") }, o.prototype.saveElement = function() { this.elements = []; for (var t = ["title/banner_2/object_base/object", "title/banner_2/object_base/star_base/star"], i = 0, o = t.length; i < o; i++) this.elements[e.itemFound + i] = Ph2.UISystem.findObject(t[i], this.ui) }, o.prototype.addTouchCallback = function() { t.Utilities.addTouchCallbackToButton("play/button_play", this.ui, this.pressExit, this) }, o.prototype.removeTouchCallback = function() { t.Utilities.removeTouchCallbackToButton("play/button_play", this.ui) }, o.prototype.enableInput = function() { t.Utilities.enableTouch("play/button_play", this.ui), t.Instances.controllKeyboard.addControl() }, o.prototype.disableInput = function() { t.Utilities.enableTouch("play/button_play", this.ui), t.Instances.controllKeyboard.removeControl() }, o.prototype.onChangeButton = function(t) { var e = Ph2.UISystem.findObject("play/button_play", this.ui); "finish" === t && (e.setFrames("button_play_hl.png", "button_play_hl.png", "button_play_p.png", "button_play_hl.png"), e.scale.set(1.2, 1.2)) }, o.prototype.onPressButton = function(t) { this.pressExit(null, null, !0) }, o.prototype.show = function() { this.resize(), t.Instances.controllKeyboard.setController(this, t.ControllerType.uiFinish), this.setUI(), this.disableInput(), this.visible = !0, this.playInStep1() }, o.prototype.setUI = function() { if (!(t.Instances.currentLevelId < 0)) { if (!t.Instances.dataManager.getLevelItemFound(t.Instances.currentLevelId)) { var i = Ph2.UISystem.findObject("title/banner_2/object_base", this.ui); return i.visibility.enable(!1), void(i.visible = !1) } var o = this.elements[e.star],
                    n = this.elements[e.itemFound],
                    s = t.Instances.dataManager.getLevelItemType(t.Instances.currentLevelId);
                o.frameName = "star_3.png", n.frameName = s === t.ItemFoundType.health ? "object_4.png" : "object_3.png" } }, o.prototype.playInStep1 = function() { Ph2.UISystem.playAnimationObject("title", this.ui, "lc_title_in", 1, !1).onComplete.addOnce(this.playLoop, this) }, o.prototype.playLoop = function() { this.enableInput(), Ph2.UISystem.playAnimationObject("title", this.ui, "lc_title_loop", 1, !0) }, o.prototype.pressExit = function(t, e, i) { i && (this.game.ph2AudioManager.playEffect("button1", !1), this.hide()) }, o.prototype.hide = function() { this.disableInput(), this.playOutStep1(), this.toComic ? this.controller.goToComicOutro() : this.controller.returnMainmenu() }, o.prototype.playOutStep1 = function() { Ph2.UISystem.playAnimationObject("title", this.ui, "lc_title_out", 1, !1).onComplete.addOnce(this.playOutStep2, this) }, o.prototype.playOutStep2 = function() { this.visible = !1 }, o.prototype.resize = function() { var t = Ph2.UISystem.findObject("title", this.ui); if (this.game.width >= 1280) t.scale.set(1, 1);
            else { var e = this.game.width / 1280;
                t.scale.set(e, e) } }, o.prototype.destroy = function() { i.prototype.destroy.call(this), this.removeTouchCallback(), this.ui = null, this.controller = null, this.elements = null }, o }(Phaser.Group);
    t.UIFinish = i }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(t) { var i = e.call(this, t.game) || this; return i.controller = t, i.game = t.game, i.ui = i.game.add.ph2UI("ui_gameover", "atlas_ui_gameover"), i.ui.fixedToCamera = !0, i.addTouchCallback(), i.visible = !1, i.localization(), i } return __extends(i, e), i.prototype.localization = function() { t.Instances.localizationManager.localizeUIText("title/banner_title/title", this.ui, "level_failed"), t.Instances.localizationManager.localizeUIText("buttons/description_container/decription", this.ui, "try_again") }, i.prototype.addTouchCallback = function() { t.Utilities.addTouchCallbackToButton("buttons/yes_container/button_yes", this.ui, this.pressRetry, this), t.Utilities.addTouchCallbackToButton("buttons/no_container/button_no", this.ui, this.pressExit, this) }, i.prototype.removeTouchCallback = function() { t.Utilities.removeTouchCallbackToButton("buttons/no_container/button_no", this.ui), t.Utilities.removeTouchCallbackToButton("buttons/yes_container/button_yes", this.ui) }, i.prototype.enableInput = function() { t.Instances.controllKeyboard.addControl(), t.Utilities.enableTouch("buttons/no_container/button_no", this.ui), t.Utilities.enableTouch("buttons/yes_container/button_yes", this.ui) }, i.prototype.disableInput = function() { t.Instances.controllKeyboard.removeControl(), t.Utilities.enableTouch("buttons/no_container/button_no", this.ui), t.Utilities.enableTouch("buttons/yes_container/button_yes", this.ui) }, i.prototype.onChangeButton = function(t) { var e = Ph2.UISystem.findObject("buttons/yes_container/button_yes", this.ui),
                i = Ph2.UISystem.findObject("buttons/no_container/button_no", this.ui); switch (e.parent.scale.set(1, 1), i.parent.scale.set(1, 1), e.setFrames("button_yes_hl.png", "button_yes.png", "button_yes_p.png", "button_yes.png"), i.setFrames("button_no_hl.png", "button_no.png", "button_no_p.png", "button_no.png"), t) {
                case "yes":
                    e.setFrames("button_yes_hl.png", "button_yes_hl.png", "button_yes_p.png", "button_yes_hl.png"), e.parent.scale.set(1.2, 1.2); break;
                case "no":
                    i.setFrames("button_no_hl.png", "button_no_hl.png", "button_no_p.png", "button_no_hl.png"), i.parent.scale.set(1.2, 1.2) } }, i.prototype.onPressButton = function(t) { switch (t) {
                case "yes":
                    this.pressRetry(null, null, !0); break;
                case "no":
                    this.pressExit(null, null, !0) } }, i.prototype.show = function() { this.resize(), t.Instances.controllKeyboard.setController(this, t.ControllerType.uiConfirmation), this.disableInput(), this.visible = !0, this.playInStep1() }, i.prototype.playInStep1 = function() { Ph2.UISystem.playAnimationObject("title", this.ui, "go_title_in", 1, !1), Ph2.UISystem.playAnimationObject("buttons", this.ui, "go_buttons_in", 1, !1).onComplete.addOnce(this.playLoop, this) }, i.prototype.playLoop = function() { this.enableInput(), Ph2.UISystem.playAnimationObject("buttons", this.ui, "go_buttons_loop", 1, !0) }, i.prototype.pressExit = function(t, e, i) { i && (this.game.ph2AudioManager.playEffect("button1", !1), this.hide(), this.controller.returnMainmenu()) }, i.prototype.pressRetry = function(t, e, i) { i && (this.game.ph2AudioManager.playEffect("button1", !1), this.hide(), this.controller.retryGameplay()) }, i.prototype.hide = function() { this.disableInput(), this.playOutStep1() }, i.prototype.playOutStep1 = function() { Ph2.UISystem.playAnimationObject("title", this.ui, "go_title_out", 1, !1), Ph2.UISystem.playAnimationObject("buttons", this.ui, "go_buttons_out", 1, !1).onComplete.addOnce(this.playOutStep2, this) }, i.prototype.playOutStep2 = function() { this.visible = !1 }, i.prototype.resize = function() { var t = Ph2.UISystem.findObject("character", this.ui),
                e = Ph2.UISystem.findObject("title", this.ui),
                i = Ph2.UISystem.findObject("buttons", this.ui); if (this.game.width >= 1280) t.scale.set(1, 1), e.scale.set(1, 1), i.scale.set(1, 1), t.children[0].y = 283;
            else { var o = this.game.width / 1280;
                t.scale.set(o, o), e.scale.set(o, o), i.scale.set(o, o), t.children[0].y = 283 + .5 * (720 - 720 * o) } }, i.prototype.destroy = function() { e.prototype.destroy.call(this), this.removeTouchCallback(), this.ui = null, this.controller = null }, i }(Phaser.Group);
    t.UIGameover = e }(Game || (Game = {}));
var Game;
! function(t) { var e;! function(t) { t[t.attack = 0] = "attack", t[t.jump = 1] = "jump", t[t.super = 2] = "super" }(e || (e = {})); var i;! function(t) { t[t.left = 0] = "left", t[t.right = 1] = "right" }(i = t.DpadDirection || (t.DpadDirection = {})); var o = function() {
        function t(t) { this.controller = t, this.game = t.game, this.joystickPlugin = this.game.plugins.plugins[this.game.plugins.plugins.length - 1], this.dpad = this.joystickPlugin.addDPad(0, 0, 140, "atlas_ui_mobile", "move.png", "move.png", "move.png", "move_l.png", "move_r.png"), this.button = [], this.button[e.attack] = this.joystickPlugin.addButton(0, 0, "atlas_ui_mobile", "attack.png", "attack_p.png", Phaser.VirtualJoystick.RECT_BUTTON), this.button[e.jump] = this.joystickPlugin.addButton(0, 0, "atlas_ui_mobile", "jump.png", "jump_p.png", Phaser.VirtualJoystick.RECT_BUTTON), this.button[e.super] = this.joystickPlugin.addButton(0, 0, "atlas_ui_mobile", "super.png", "super_p.png", Phaser.VirtualJoystick.RECT_BUTTON), this.dpad.sprite.alpha = .8, this.button[e.attack].sprite.alpha = .8, this.button[e.jump].sprite.alpha = .8, this.button[e.super].sprite.alpha = .8, this.initInput(), this.hide(), this.setHitAreaButton(), this.resize(), this.checkDebug(), this.showDebug() } return t.prototype.checkDebug = function() { Constants.DEBUG_MOBILE_INPUT && (this.inputZones = [], this.inputZones[0] = this.game.make.graphics(0, 0), this.inputZones[1] = this.game.make.graphics(0, 0), this.inputZones[2] = this.game.make.graphics(0, 0), this.inputZones[3] = this.game.make.graphics(0, 0), this.dpad.sprite.addChild(this.inputZones[0]), this.button[e.jump].sprite.addChild(this.inputZones[1]), this.button[e.attack].sprite.addChild(this.inputZones[2]), this.button[e.super].sprite.addChild(this.inputZones[3])) }, t.prototype.setHitAreaButton = function(t) { void 0 === t && (t = !1), this.dpad.stickHitArea.diameter = 370, t || (this.button[e.jump].hitArea.width *= .8, this.button[e.jump].hitArea.height *= .7, this.button[e.attack].hitArea.width *= .8, this.button[e.attack].hitArea.height *= .8, this.button[e.super].hitArea.width *= .8, this.button[e.super].hitArea.height *= .7), this.button[e.jump].hitArea.x = this.button[e.jump].sprite.x - this.button[e.jump].hitArea.width / 2, this.button[e.jump].hitArea.y = this.button[e.jump].sprite.y - this.button[e.jump].hitArea.height / 2, this.button[e.attack].hitArea.x = this.button[e.attack].sprite.x - this.button[e.attack].hitArea.width / 2, this.button[e.attack].hitArea.y = this.button[e.attack].sprite.y - this.button[e.attack].hitArea.height / 2, this.button[e.super].hitArea.x = this.button[e.super].sprite.x - this.button[e.super].hitArea.width / 2, this.button[e.super].hitArea.y = this.button[e.super].sprite.y - this.button[e.super].hitArea.height / 2 }, t.prototype.showDebug = function() { if (Constants.DEBUG_MOBILE_INPUT) { this.inputZones[0].clear(), this.inputZones[0].beginFill(16711680, .3), this.inputZones[0].drawCircle(0, 0, this.dpad.stickHitArea.diameter), this.inputZones[0].endFill(); var t = void 0,
                    i = void 0,
                    o = void 0,
                    n = void 0;
                t = this.button[e.jump].hitArea.x - this.button[e.jump].sprite.x, i = this.button[e.jump].hitArea.y - this.button[e.jump].sprite.y, o = this.button[e.jump].hitArea.width, n = this.button[e.jump].hitArea.height, this.inputZones[1].clear(), this.inputZones[1].beginFill(16711680, .3), this.inputZones[1].drawRect(t, i, o, n), this.inputZones[1].endFill(), t = this.button[e.attack].hitArea.x - this.button[e.attack].sprite.x, i = this.button[e.attack].hitArea.y - this.button[e.attack].sprite.y, o = this.button[e.attack].hitArea.width, n = this.button[e.attack].hitArea.height, this.inputZones[2].clear(), this.inputZones[2].beginFill(16711680, .3), this.inputZones[2].drawRect(t, i, o, n), this.inputZones[2].endFill(), t = this.button[e.super].hitArea.x - this.button[e.super].sprite.x, i = this.button[e.super].hitArea.y - this.button[e.super].sprite.y, o = this.button[e.super].hitArea.width, n = this.button[e.super].hitArea.height, this.inputZones[3].clear(), this.inputZones[3].beginFill(16711680, .3), this.inputZones[3].drawRect(t, i, o, n), this.inputZones[3].endFill() } }, t.prototype.initInput = function() { this.isDpadpress = !1, this.lastDpadDirection = null, this.dpad.onMove.add(this.pressDpad, this), this.dpad.onUp.add(this.releaseDpad, this), this.button[e.attack].onDown.add(this.pressAttack, this), this.button[e.attack].onDown.add(this.pressAttack, this), this.button[e.jump].onDown.add(this.pressJump, this), this.button[e.super].onDown.add(this.pressSuper, this) }, t.prototype.endInput = function() { this.isDpadpress = !1, this.dpad.onMove.remove(this.pressDpad, this), this.dpad.onUp.remove(this.releaseDpad, this), this.button[e.attack].onDown.remove(this.pressAttack, this), this.button[e.jump].onDown.remove(this.pressJump, this), this.button[e.super].onDown.remove(this.pressSuper, this) }, t.prototype.pressDpad = function(t) { var e; if (e = t.angleFull >= 90 && t.angleFull < 270 ? i.left : i.right, this.isDpadpress) { if (e === this.lastDpadDirection) return;
                this.releaseDpad() } this.isDpadpress = !0, this.lastDpadDirection = e, e === i.left ? this.controller.onPressDirection(i.left) : this.controller.onPressDirection(i.right) }, t.prototype.releaseDpad = function() { this.isDpadpress && this.controller.onReleasedDirection(), this.lastDpadDirection = null, this.isDpadpress = !1 }, t.prototype.pressAttack = function() { this.controller.onPressAttack() }, t.prototype.pressJump = function() { this.controller.onPressJump() }, t.prototype.pressSuper = function() { this.controller.onPressSuper() }, t.prototype.enableInput = function() { this.dpad.enabled = !0, this.button[e.attack].enabled = !0, this.button[e.jump].enabled = !0, this.button[e.super].enabled = !0 }, t.prototype.disableInput = function() { this.dpad.enabled = !1, this.button[e.attack].enabled = !1, this.button[e.jump].enabled = !1, this.button[e.super].enabled = !1 }, t.prototype.show = function() { this.enableInput(), this.dpad.visible = !0, this.button[e.attack].visible = !0, this.button[e.jump].visible = !0, this.button[e.super].visible = !0 }, t.prototype.hide = function() { this.disableInput(), this.isDpadpress && this.releaseDpad(), this.dpad.visible = !1, this.button[e.attack].visible = !1, this.button[e.jump].visible = !1, this.button[e.super].visible = !1 }, t.prototype.resize = function() { this.dpad.posX = 200, this.dpad.posY = this.game.height - 110, this.button[e.jump].posX = this.game.width - 105, this.button[e.jump].posY = this.game.height - 100, this.button[e.attack].posX = this.game.width - 300, this.button[e.attack].posY = this.game.height - 80, this.button[e.super].posX = this.game.width - 105, this.button[e.super].posY = this.game.height - 280, this.setHitAreaButton(!0) }, t.prototype.destroy = function() { this.endInput(), this.dpad.destroy(), this.button[e.attack].destroy(), this.button[e.jump].destroy(), this.button[e.super].destroy(), this.button = null, this.dpad = null, this.game = null, this.controller = null, this.joystickPlugin = null }, t }();
    t.UIJoystickMobile = o }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e;! function(t) { t[t.play = 0] = "play", t[t.play2 = 1] = "play2", t[t.settings = 2] = "settings", t[t.logo = 3] = "logo" }(e = t.ElementsUIMainMenu || (t.ElementsUIMainMenu = {})); var i = function(i) {
        function o(e) { var o = i.call(this, e.game) || this; return o.controller = e, o.ui = o.game.add.ph2UI("ui_main_menu", "atlas_ui_main_menu"), o.checkSecondMission(), o.add(o.ui), o.saveElement(), o.addTouchListener(), o.playLoopAniamtion(), t.Instances.controllKeyboard.setController(o, t.ControllerType.uiMainMenu), o.enableInput(), o.localization(), o } return __extends(o, i), o.prototype.checkSecondMission = function() { if (t.Instances.dataManager.isSecondMissionUnlocked()) { var e = void 0;
                (e = Ph2.UISystem.findObject("play/next_mission_container/next_mission", this.ui)).frameName = "button_play_m_2.png", e.setFrames("button_play_m_3.png", "button_play_m_2.png", "button_play_m_4.png", "button_play_m_2.png");
                Ph2.UISystem.findObject("play/next_mission_container/next_mission/title", this.ui).position.set(0); var i = void 0;
                (i = Ph2.UISystem.findObject("play/next_mission_container/next_mission/lock", this.ui)).visibility.enable(!1), i.visible = !1 } }, o.prototype.localization = function() { this.elements[e.logo].loadTexture("logo"), t.Instances.localizationManager.localizeUIText("play/play_container/play/title", this.ui, "title_mission", !1, "1"), t.Instances.localizationManager.localizeUIText("play/next_mission_container/next_mission/title", this.ui, "title_mission", !1, "2"), t.Instances.localizationManager.localizeUIText("play/next_mission_container/next_mission/title2", this.ui, "coming_soon") }, o.prototype.saveElement = function() { this.elements = [], this.elements[e.play] = Ph2.UISystem.findObject("play/play_container/play", this.ui), t.Instances.dataManager.isSecondMissionUnlocked() && (this.elements[e.play2] = Ph2.UISystem.findObject("play/next_mission_container/next_mission", this.ui)), this.elements[e.settings] = Ph2.UISystem.findObject("settings/button_settings", this.ui), this.elements[e.logo] = Ph2.UISystem.findObject("logo/logo", this.ui) }, o.prototype.playLoopAniamtion = function() { Ph2.UISystem.playAnimationObject("logo", this.ui, "logo_loop", 1, !0), Ph2.UISystem.playAnimationObject("play/play_container/play", this.ui, "play_mm_loop", 1, !0), Ph2.UISystem.playAnimationObject("bg", this.ui, "bg_anim", 1, !0), Ph2.UISystem.findObject("logo", this.ui).visibility.enable(!1), Ph2.UISystem.findObject("play", this.ui).visibility.enable(!1), Ph2.UISystem.findObject("settings", this.ui).visibility.enable(!1) }, o.prototype.addTouchListener = function() { t.Utilities.addTouchCallbackToButton("play/play_container/play", this.ui, this.pressPlay, this), t.Utilities.addTouchCallbackToButton("settings/button_settings", this.ui, this.pressSetting, this), t.Instances.dataManager.isSecondMissionUnlocked() && t.Utilities.addTouchCallbackToButton("play/next_mission_container/next_mission", this.ui, this.pressPlay2, this) }, o.prototype.removeTouchListener = function() { t.Utilities.removeTouchCallbackToButton("play/play_container/play", this.ui), t.Utilities.removeTouchCallbackToButton("settings/button_settings", this.ui), t.Instances.dataManager.isSecondMissionUnlocked() && t.Utilities.removeTouchCallbackToButton("play/next_mission_container/next_mission", this.ui), t.Instances.controllKeyboard.removeControl() }, o.prototype.disableInput = function() { t.Utilities.disableTouch("play/play_container/play", this.ui), t.Utilities.disableTouch("settings/button_settings", this.ui), t.Instances.controllKeyboard.removeControl() }, o.prototype.enableInput = function() { t.Utilities.enableTouch("play/play_container/play", this.ui), t.Utilities.enableTouch("settings/button_settings", this.ui), t.Instances.controllKeyboard.addControl() }, o.prototype.pressPlay = function(t, e, i) { i && (this.game.ph2AudioManager.playEffect("button1", !1), this.disableInput(), this.controller.onPressPlay()) }, o.prototype.pressPlay2 = function(t, e, i) { i && (this.game.ph2AudioManager.playEffect("button1", !1), this.disableInput(), this.controller.onPressPlay2()) }, o.prototype.pressSetting = function(t, e, i) { i && (this.disableInput(), this.controller.onShowSettings()) }, o.prototype.onChangeButton = function(t) { var i = this.elements[e.play],
                o = this.elements[e.settings]; switch (i.setFrames("button_play_m_3.png", "button_play_m_2.png", "button_play_m_4.png", "button_play_m_2.png"), i.parent.scale.set(1, 1), o.setFrames("button_settings_hl.png", "button_settings.png", "button_settings_p.png", "button_settings.png"), o.parent.scale.set(1, 1), t) {
                case "buttonPlay":
                    i.setFrames("button_play_m_3.png", "button_play_m_3.png", "button_play_m_4.png", "button_play_m_3.png"), i.parent.scale.set(1.2, 1.2); break;
                case "buttonSetting":
                    o.setFrames("button_settings_hl.png", "button_settings_hl.png", "button_settings_p.png", "button_settings_hl.png"), o.parent.scale.set(1.2, 1.2) } }, o.prototype.onPressButton = function(t) { switch (t) {
                case "buttonPlay":
                    this.pressPlay(null, null, !0); break;
                case "buttonSetting":
                    this.pressSetting(null, null, !0); break;
                case "none":
                    this.pressPlay(null, null, !0) } }, o.prototype.hideMiddleElements = function() { Ph2.UISystem.findObject("logo", this.ui).visible = !1, Ph2.UISystem.findObject("play", this.ui).visible = !1, Ph2.UISystem.findObject("settings", this.ui).visible = !1 }, o.prototype.showMiddleElements = function() { t.Instances.controllKeyboard.setController(this, t.ControllerType.uiMainMenu), Ph2.UISystem.findObject("logo", this.ui).visible = !0, Ph2.UISystem.findObject("play", this.ui).visible = !0, Ph2.UISystem.findObject("settings", this.ui).visible = !0 }, o.prototype.destroy = function() { this.removeTouchListener(), Ph2.UISystem.stopAnimationObject("logo", this.ui, "logo_loop"), Ph2.UISystem.stopAnimationObject("play/play_container/play", this.ui, "play_mm_loop"), Ph2.UISystem.stopAnimationObject("bg", this.ui, "bg_anim"), i.prototype.destroy.call(this), this.game = null, this.controller = null, this.ui = null }, o }(Phaser.Group);
    t.UIMainMenu = i }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e;! function(t) { t[t.play = 0] = "play", t[t.exit = 1] = "exit", t[t.tutorial = 2] = "tutorial", t[t.settings = 3] = "settings" }(e = t.ElementsUIPause || (t.ElementsUIPause = {})); var i = function(i) {
        function o(t) { var e = i.call(this, t.game) || this; return e.controller = t, e.ui = e.game.add.ph2UI("ui_pause", "atlas_ui_pause"), e.add(e.ui), e.saveElement(), e.addTouchListener(), e.localization(), e } return __extends(o, i), o.prototype.localization = function() { t.Instances.localizationManager.localizeUIText("pause_container/banner_title/title", this.ui, "title_pause") }, o.prototype.saveElement = function() { this.elements = [], this.elements[e.play] = Ph2.UISystem.findObject("pause_container/play_container/button_play", this.ui), this.elements[e.exit] = Ph2.UISystem.findObject("pause_container/exit_container/button_exit", this.ui), this.elements[e.tutorial] = Ph2.UISystem.findObject("pause_container/tutorial_container/button_tutorial", this.ui), this.elements[e.settings] = Ph2.UISystem.findObject("settings/button_settings", this.ui) }, o.prototype.addTouchListener = function() { this.elements[e.play].onInputUp.add(this.pressPlay, this), this.elements[e.exit].onInputUp.add(this.pressExit, this), this.elements[e.tutorial].onInputUp.add(this.pressTutorial, this), this.elements[e.settings].onInputUp.add(this.pressSetting, this) }, o.prototype.removeTouchListener = function() { this.elements[e.play].inputEnabled = !1, this.elements[e.play].onInputUp.removeAll(), this.elements[e.exit].inputEnabled = !1, this.elements[e.exit].onInputUp.removeAll(), this.elements[e.tutorial].inputEnabled = !1, this.elements[e.tutorial].onInputUp.removeAll(), this.elements[e.settings].inputEnabled = !1, this.elements[e.settings].onInputUp.removeAll() }, o.prototype.disableInput = function() { this.elements[e.play].inputEnabled = !1, this.elements[e.exit].inputEnabled = !1, this.elements[e.tutorial].inputEnabled = !1, this.elements[e.settings].inputEnabled = !1, t.Instances.controllKeyboard.removeControl() }, o.prototype.enableInput = function() { this.elements[e.play].inputEnabled = !0, this.elements[e.exit].inputEnabled = !0, this.elements[e.tutorial].inputEnabled = !0, this.elements[e.settings].inputEnabled = !0, t.Instances.controllKeyboard.addControl() }, o.prototype.resetButtons = function() { this.elements[e.play].parent.scale.set(1, 1), this.elements[e.play].setFrames("button_play_hl.png", "button_play.png", "button_play_p.png", "button_play.png"), this.elements[e.exit].parent.scale.set(1, 1), this.elements[e.exit].setFrames("button_exit_hl.png", "button_exit.png", "button_exit_p.png", "button_exit.png"), this.elements[e.tutorial].parent.scale.set(1, 1), this.elements[e.tutorial].setFrames("button_tutorial_hl.png", "button_tutorial.png", "button_tutorial_p.png", "button_tutorial.png"), this.elements[e.settings].parent.scale.set(1, 1), this.elements[e.settings].setFrames("button_settings_hl.png", "button_settings.png", "button_settings_p.png", "button_settings.png") }, o.prototype.pressPlay = function(t, e, i) { i && (this.game.ph2AudioManager.playEffect("button1", !1), this.disableInput(), this.resetButtons(), Ph2.UISystem.stopAnimationObject("pause_container", this.ui, "pause_container_loop", !1), Ph2.UISystem.playAnimationObject("settings", this.ui, "button_settings_out", 1, !1), Ph2.UISystem.playAnimationObject("pause_container", this.ui, "pause_container_out", 1, !1).onComplete.addOnce(this.hide, this)) }, o.prototype.pressExit = function(t, e, i) { i && this.controller.showConfirmation() }, o.prototype.pressTutorial = function(t, e, i) { i && this.controller.showControls() }, o.prototype.pressSetting = function(t, e, i) { i && (this.disableInput(), this.controller.showSettings()) }, o.prototype.show = function() { this.visible = !0, t.Instances.controllKeyboard.setController(this, t.ControllerType.uiPause), Ph2.UISystem.playAnimationObject("settings", this.ui, "button_settings_in", 1, !1), Ph2.UISystem.playAnimationObject("pause_container", this.ui, "pause_container_in", 1, !1).onComplete.addOnce(this.showEnable, this) }, o.prototype.showEnable = function() { this.enableInput(), Ph2.UISystem.playAnimationObject("pause_container", this.ui, "pause_container_loop", 1, !0) }, o.prototype.hide = function() { this.visible = !1, this.controller.onHidePause() }, o.prototype.onChangeButton = function(t) { switch (this.resetButtons(), t) {
                case "buttonExit":
                    this.elements[e.exit].setFrames("button_exit_hl.png", "button_exit_hl.png", "button_exit_p.png", "button_exit_hl.png"), this.elements[e.exit].parent.scale.set(1.2, 1.2); break;
                case "buttonPlay":
                    this.elements[e.play].setFrames("button_play_hl.png", "button_play_hl.png", "button_play_p.png", "button_play_hl.png"), this.elements[e.play].parent.scale.set(1.2, 1.2); break;
                case "buttonTutorial":
                    this.elements[e.tutorial].setFrames("button_tutorial_hl.png", "button_tutorial_hl.png", "button_tutorial_p.png", "button_tutorial_hl.png"), this.elements[e.tutorial].parent.scale.set(1.2, 1.2); break;
                case "buttonSetting":
                    this.elements[e.settings].setFrames("button_settings_hl.png", "button_settings_hl.png", "button_settings_p.png", "button_settings_hl.png"), this.elements[e.settings].parent.scale.set(1.2, 1.2) } }, o.prototype.onPressButton = function(t) { switch (t) {
                case "buttonExit":
                    this.pressExit(null, null, !0); break;
                case "buttonPlay":
                    this.pressPlay(null, null, !0); break;
                case "buttonSetting":
                    this.pressSetting(null, null, !0); break;
                case "buttonTutorial":
                    this.pressTutorial(null, null, !0) } }, o.prototype.onPressBack = function() { this.pressPlay(null, null, !0) }, o.prototype.destroy = function() { this.removeTouchListener(), i.prototype.destroy.call(this), this.game = null, this.controller = null, this.ui = null }, o }(Phaser.Group);
    t.UIPausa = i }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(t) { var i = e.call(this, t.game) || this; return i.controller = t, i.ui = i.game.add.ph2UI("ui_settings", "atlas_ui_pause"), i.add(i.ui), i.addTouchListener(), i.checkAudioStates(), i.visible = !1, i.localization(), i } return __extends(i, e), i.prototype.localization = function() { t.Instances.localizationManager.localizeUIText("settings_container/banner_title/title", this.ui, "setting_title") }, i.prototype.addTouchListener = function() { this.soundButton = t.Utilities.addTouchCallbackToButton("settings_container/sound_container/button_sound", this.ui, this.toggleSound, this), this.musicButton = t.Utilities.addTouchCallbackToButton("settings_container/music_container/button_music", this.ui, this.toggleMusic, this), t.Utilities.addTouchCallbackToButton("settings_container/play_container/button_play", this.ui, this.hide, this) }, i.prototype.removeTouchListener = function() { t.Utilities.removeTouchCallbackToButton("settings_container/sound_container/button_sound", this.ui), t.Utilities.removeTouchCallbackToButton("settings_container/music_container/button_music", this.ui), t.Utilities.removeTouchCallbackToButton("settings_container/play_container/button_play", this.ui) }, i.prototype.checkAudioStates = function() { this.game.ph2AudioManager.getSfxEnabled() ? this.soundButton.setFrames("button_sound_hl.png", "button_sound_on.png", "button_sound_p.png", "button_sound_on.png") : this.soundButton.setFrames("button_sound_hl_off.png", "button_sound_off.png", "button_sound_p.png", "button_sound_off.png"), this.game.ph2AudioManager.getMusicEnabled() ? this.musicButton.setFrames("button_music_hl.png", "button_music_on.png", "button_music_p.png", "button_music_on.png") : this.musicButton.setFrames("button_music_hl_off.png", "button_music_off.png", "button_music_p.png", "button_music_off.png") }, i.prototype.toggleSound = function(e, i, o) { o && (this.game.ph2AudioManager.playEffect("button1", !1), this.game.ph2AudioManager.switchSfxState(), t.Instances.dataManager.saveSoundState(this.game.ph2AudioManager.getSfxEnabled()), this.game.ph2AudioManager.getSfxEnabled() ? this.soundButton.setFrames("button_sound_hl.png", "button_sound_on.png", "button_sound_p.png", "button_sound_on.png") : this.soundButton.setFrames("button_sound_hl_off.png", "button_sound_off.png", "button_sound_p.png", "button_sound_off.png")) }, i.prototype.toggleMusic = function(e, i, o) { o && (this.game.ph2AudioManager.playEffect("button1", !1), this.game.ph2AudioManager.switchMusicState(), t.Instances.dataManager.saveMusicState(this.game.ph2AudioManager.getMusicEnabled()), this.game.ph2AudioManager.getMusicEnabled() ? (t.Audios.playMusic(this.game, this.controller.bgMusic), this.musicButton.setFrames("button_music_hl.png", "button_music_on.png", "button_music_p.png", "button_music_on.png")) : (t.Audios.stopMusic(this.game), this.musicButton.setFrames("button_music_hl_off.png", "button_music_off.png", "button_music_p.png", "button_music_off.png"))) }, i.prototype.onPressBack = function() { this.hide() }, i.prototype.onChangeButton = function(t) { var e = Ph2.UISystem.findObject("settings_container/play_container/button_play", this.ui); switch (this.resetButton(), t) {
                case "buttonPlay":
                    e.setFrames("button_play_hl.png", "button_play_hl.png", "button_play_p.png", "button_play_hl.png"), e.parent.scale.set(1.2, 1.2); break;
                case "buttonSfx":
                    this.game.ph2AudioManager.getSfxEnabled() ? this.soundButton.setFrames("button_sound_hl.png", "button_sound_hl.png", "button_sound_p.png", "button_sound_hl.png") : this.soundButton.setFrames("button_sound_hl_off.png", "button_sound_hl_off.png", "button_sound_p.png", "button_sound_hl_off.png"), this.soundButton.parent.scale.set(1.2, 1.2); break;
                case "buttonMusic":
                    this.game.ph2AudioManager.getMusicEnabled() ? this.musicButton.setFrames("button_music_hl.png", "button_music_hl.png", "button_music_p.png", "button_music_hl.png") : this.musicButton.setFrames("button_music_hl_off.png", "button_music_hl_off.png", "button_music_p.png", "button_music_hl_off.png"), this.musicButton.parent.scale.set(1.2, 1.2) } }, i.prototype.resetButton = function() { var t = Ph2.UISystem.findObject("settings_container/play_container/button_play", this.ui);
            t.setFrames("button_play_hl.png", "button_play.png", "button_play_p.png", "button_play.png"), t.parent.scale.set(1, 1), this.game.ph2AudioManager.getSfxEnabled() ? this.soundButton.setFrames("button_sound_hl.png", "button_sound_on.png", "button_sound_p.png", "button_sound_on.png") : this.soundButton.setFrames("button_sound_hl_off.png", "button_sound_off.png", "button_sound_p.png", "button_sound_off.png"), this.soundButton.parent.scale.set(1, 1), this.game.ph2AudioManager.getMusicEnabled() ? this.musicButton.setFrames("button_music_hl.png", "button_music_on.png", "button_music_p.png", "button_music_on.png") : this.musicButton.setFrames("button_music_hl_off.png", "button_music_off.png", "button_music_p.png", "button_music_off.png"), this.musicButton.parent.scale.set(1, 1) }, i.prototype.onPressButton = function(t) { switch (t) {
                case "buttonPlay":
                    this.hide(); break;
                case "buttonSfx":
                    this.toggleSound(null, null, !0), this.onChangeButton("buttonSfx"); break;
                case "buttonMusic":
                    this.toggleMusic(null, null, !0), this.onChangeButton("buttonMusic") } }, i.prototype.show = function() { t.Instances.controllKeyboard.setController(this, t.ControllerType.uiSetting), Ph2.UISystem.playAnimationObject("settings_container", this.ui, "settings_container_in", 1, !1).onComplete.addOnce(this.enableAll, this), this.visible = !0 }, i.prototype.hide = function() { this.resetButton(), this.disableAll(), Ph2.UISystem.playAnimationObject("settings_container", this.ui, "settings_container_out", 1, !1).onComplete.addOnce(this.onCompletedHide, this) }, i.prototype.onCompletedHide = function() { this.visible = !1, this.controller.onHideSettings && this.controller.onHideSettings() }, i.prototype.enableAll = function() { t.Instances.controllKeyboard.addControl(), t.Utilities.enableTouch("settings_container/sound_container/button_sound", this.ui), t.Utilities.enableTouch("settings_container/music_container/button_music", this.ui), t.Utilities.enableTouch("settings_container/play_container/button_play", this.ui), Ph2.UISystem.playAnimationObject("settings_container", this.ui, "settings_container_loop", 1, !0) }, i.prototype.disableAll = function() { t.Instances.controllKeyboard.removeControl(), t.Utilities.disableTouch("settings_container/sound_container/button_sound", this.ui), t.Utilities.disableTouch("settings_container/music_container/button_music", this.ui), t.Utilities.disableTouch("settings_container/play_container/button_play", this.ui) }, i.prototype.destroy = function() { e.prototype.destroy.call(this), this.ui = null, this.controller = null, this.musicButton = null, this.soundButton = null }, i }(Phaser.Group);
    t.UISettings = e }(Game || (Game = {}));
var __extends = this && this.__extends || function() { var t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, e) { t.__proto__ = e } || function(t, e) { for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]) }; return function(e, i) {
            function o() { this.constructor = e } t(e, i), e.prototype = null === i ? Object.create(i) : (o.prototype = i.prototype, new o) } }(),
    Game;
! function(t) { var e = function(e) {
        function i(t) { var i = e.call(this, t.game) || this; return i.controller = t, i.ui = i.game.add.ph2UI("ui_tutorial", "atlas_ui_tutorial"), i.add(i.ui), i.addTouchListener(), i.visible = !1, i.game.device.desktop || i.setMobileFrames(), i.localization(), i } return __extends(i, e), i.prototype.localization = function() { if (this.game.device.desktop) { Ph2.UISystem.findObject("tutorial_container/base/move_base_button", this.ui).loadTexture("keymove"), Ph2.UISystem.findObject("tutorial_container/base/jump_base_button", this.ui).loadTexture("keyjump"), Ph2.UISystem.findObject("tutorial_container/base/attack_base_button", this.ui).loadTexture("keyattack"), Ph2.UISystem.findObject("tutorial_container/base/special_attack_base_button", this.ui).loadTexture("keyspecial") } t.Instances.localizationManager.localizeUIText("tutorial_container/banner_title/title", this.ui, "tutorial_title"), t.Instances.localizationManager.localizeUIText("tutorial_container/base/move_text", this.ui, "move_tutorial"), t.Instances.localizationManager.localizeUIText("tutorial_container/base/jump_text", this.ui, "jump_tutorial"), t.Instances.localizationManager.localizeUIText("tutorial_container/base/attack_text", this.ui, "attack_tutorial"), t.Instances.localizationManager.localizeUIText("tutorial_container/base/special_attack_text", this.ui, "special_attack_tutorial") }, i.prototype.setMobileFrames = function() { Ph2.UISystem.findObject("tutorial_container/base/move_base_button", this.ui).frameName = "mobile_move.png", Ph2.UISystem.findObject("tutorial_container/base/jump_base_button", this.ui).frameName = "mobile_jump.png", Ph2.UISystem.findObject("tutorial_container/base/attack_base_button", this.ui).frameName = "mobile_attack.png", Ph2.UISystem.findObject("tutorial_container/base/special_attack_base_button", this.ui).frameName = "mobile_special.png" }, i.prototype.addTouchListener = function() { t.Utilities.addTouchCallbackToButton("tutorial_container/play_container/button_play", this.ui, this.hide, this).inputEnabled = !1 }, i.prototype.removeTouchListener = function() { t.Utilities.removeTouchCallbackToButton("tutorial_container/play_container/button_play", this.ui) }, i.prototype.onChangeButton = function(t) { var e = Ph2.UISystem.findObject("tutorial_container/play_container/button_play", this.ui); switch (e.setFrames("button_yes_hl.png", "button_yes.png", "button_yes_p.png", "button_yes.png"), e.parent.scale.set(1, 1), t) {
                case "buttonPlay":
                    e.setFrames("button_yes_hl.png", "button_yes_hl.png", "button_yes_p.png", "button_yes_hl.png"), e.parent.scale.set(1.2, 1.2) } }, i.prototype.onPressButton = function(t) { this.hide() }, i.prototype.onPressBack = function() { this.hide() }, i.prototype.show = function() { t.Instances.controllKeyboard.setController(this, t.ControllerType.uiTutorial), Ph2.UISystem.playAnimationObject("tutorial_container", this.ui, "tutorial_container_in", 1, !1).onComplete.addOnce(this.enableAll, this), this.visible = !0 }, i.prototype.hide = function() { this.disableAll(), Ph2.UISystem.playAnimationObject("tutorial_container", this.ui, "tutorial_container_out", 1, !1).onComplete.addOnce(this.onCompletedHide, this) }, i.prototype.onCompletedHide = function() { this.visible = !1, this.controller.onCloseTutorial && this.controller.onCloseTutorial() }, i.prototype.enableAll = function() { t.Instances.controllKeyboard.addControl(), t.Utilities.enableTouch("tutorial_container/play_container/button_play", this.ui), Ph2.UISystem.playAnimationObject("tutorial_container", this.ui, "tutorial_container_loop", 1, !0) }, i.prototype.disableAll = function() { t.Instances.controllKeyboard.removeControl(), t.Utilities.disableTouch("tutorial_container/play_container/button_play", this.ui) }, i.prototype.destroy = function() { this.removeTouchListener(), e.prototype.destroy.call(this), this.ui = null, this.controller = null }, i }(Phaser.Group);
    t.UITutorial = e }(Game || (Game = {}));
var Game;
! function(t) { var e = function() {
        function e() {} return e.createGraphicButton = function(t, e, i, o, n, s, r, a) { void 0 === a && (a = 20); var h = t.add.graphics(0, 0);
            h.beginFill(s), h.drawRect(0, 0, o, n), h.endFill(); var l = t.add.sprite(e, i, h.generateTexture());
            l.anchor.set(.5); var c = t.add.text(0, 0, r, Constants.defaultStyle); return c.anchor.set(.5), c.fontSize = a, h.destroy(), l.addChild(c), l.fixedToCamera = !0, l.inputEnabled = !0, l }, e.addTouchCallbackToButton = function(t, e, i, o, n) { void 0 === n && (n = 0); for (var s = [], r = 5; r < arguments.length; r++) s[r - 5] = arguments[r]; var a; return (a = Ph2.UISystem.findObject(t, e)).onInputUp.add(i, o, n, s), a }, e.removeTouchCallbackToButton = function(t, e) { var i; return i = Ph2.UISystem.findObject(t, e), i.inputEnabled = !1, i.onInputUp.removeAll(), i }, e.addTouchCallbackToText = function(t, e, i, o) { var n; return n = Ph2.UISystem.findObject(t, e), n.inputEnabled = !0, n.input.useHandCursor = !0, n.events.onInputUp.add(i, o), n }, e.addTouchCallbackToSprite = function(t, e, i, o, n) { void 0 === n && (n = 0); for (var s = [], r = 5; r < arguments.length; r++) s[r - 5] = arguments[r]; var a; return a = Ph2.UISystem.findObject(t, e), a.inputEnabled = !0, a.input.useHandCursor = !0, a.events.onInputUp.add(i, o, n, s), a }, e.removeTouchCallbackToSprite = function(t, e) { var i; return i = Ph2.UISystem.findObject(t, e), i.inputEnabled = !1, i.events.onInputUp.removeAll(), i }, e.addTouchCallbackToSpriteAnimation = function(t, e, i, o) { var n; return n = Ph2.AnimationSystem.findObject(t, e), n.inputEnabled = !0, n.input.useHandCursor = !0, n.events.onInputUp.add(i, o), n }, e.addInputToPreventPropagation = function(t, e) { var i;
            (i = Ph2.UISystem.findObject(t, e)).inputEnabled = !0, i.input.useHandCursor = !1 }, e.disableTouch = function(t, e) { Ph2.UISystem.findObject(t, e).inputEnabled = !1 }, e.enableTouch = function(t, e) { var i;
            (i = Ph2.UISystem.findObject(t, e)).inputEnabled = !0, i.input.useHandCursor = !0 }, e.disableTouchAnimation = function(t, e) { Ph2.AnimationSystem.findObject(t, e).inputEnabled = !1 }, e.enableTouchAnimation = function(t, e) { var i;
            (i = Ph2.AnimationSystem.findObject(t, e)).inputEnabled = !0, i.input.useHandCursor = !0 }, e.getAllInteractiveObjects = function(t, e, i) { for (var o = t.input.interactiveItems.first, n = []; o;) o.checked = !1, !o.validForInput(-1, 0, !1) || t.paused && !o.sprite.noPause || (o.checked = !0, (e && o.checkPointerDown(i, !0) || !e && o.checkPointerOver(i, !0)) && (o, n.push(o))), o = t.input.interactiveItems.next; for (o = t.input.interactiveItems.first; o;) !o.checked && o.validForInput(-1, 0, !0) && (e && o.checkPointerDown(i, !1) || !e && o.checkPointerOver(i, !1)) && (o, n.push(o)), o = t.input.interactiveItems.next; return n }, e.playRandomEnemyHitEffect = function(t) { var e = t.rnd.integerInRange(1, 3);
            t.ph2AudioManager.playEffect("enemy_damage" + e, !1) }, e.playRandomEnemyFinalHitEffect = function(t) { var e = t.rnd.integerInRange(1, 2);
            t.ph2AudioManager.playEffect("enemy_damage_final" + e, !1) }, e.getRaycastPoint = function(t, e, i, o, n) { var s; return (s = t.physics.box2d.raycast(e, i, e + 2e3 * o, i + 2e3 * n, !0, this.mapFilter)).length > 0 ? s[0].point : null }, e.mapFilter = function(e, i, o, n) { return i.m_filter.categoryBits === t.CollisionLayers.Map }, e }();
    t.Utilities = e }(Game || (Game = {}));